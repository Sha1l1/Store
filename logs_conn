commit bd55d9cbba1ce2f6a9a922edf40b5f1db489de6e
Author: Changhyeok Bae <changhyeok.bae@lge.com>
Date:   Fri Mar 9 11:00:44 2018 +0900

    webOS Open Source Edition initial release

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..7a888a3
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,40 @@
+# Copyright (c) 2012-2018 LG Electronics, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+
+# .gitignore for components that enforce "out-of-source" builds, (e.g. ones that
+# use "cmake-modules-webos")
+#
+# @@@VERSION
+# r3
+# VERSION@@@
+
+# Common Eclipse project files
+.project
+.cproject
+
+# Directory created by OpenEmbedded
+patches/
+
+# Ignore all build directories and their trees. This should exclude all
+# build artifacts.
+BUILD*/
+
+# Ignore code generated by gdbus-codegen
+src/connman-interface.*
+
+# Backup files created by astyle
+*.orig
+
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..c95aaea
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,164 @@
+# Copyright (c) 2012-2018 LG Electronics, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+
+#
+# webos-connman-adapter/CMakeLists.txt
+#
+
+
+cmake_minimum_required(VERSION 2.8.7)
+
+project(webos-connman-adapter C)
+
+include(webOS/webOS)
+webos_modules_init(1 0 0 QUALIFIER RC4)
+webos_component(1 1 0)
+
+set(WIFI_IFACE_NAME "wlan0" CACHE STRING "WiFi interface name")
+set(WIRED_IFACE_NAME "eth0" CACHE STRING "Wired interface name")
+set(CONNMAN_CONFIG_DIR "/var/lib/connman" CACHE STRING "Default connman config folder")
+
+find_program(GDBUS_CODEGEN_EXECUTABLE NAMES gdbus-codegen DOC "gdbus-codegen executable")
+if(NOT GDBUS_CODEGEN_EXECUTABLE)
+	message(FATAL_ERROR "Executable gdbus-codegen not found")
+endif()
+
+include(FindPkgConfig)
+
+pkg_check_modules(GLIB2 REQUIRED glib-2.0)
+include_directories(${GLIB2_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${GLIB2_CFLAGS_OTHER})
+
+pkg_check_modules(LUNASERVICE2 REQUIRED luna-service2)
+include_directories(${LUNASERVICE2_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${LUNASERVICE2_CFLAGS_OTHER})
+
+pkg_check_modules(GIO-UNIX REQUIRED gio-unix-2.0)
+include_directories(${GIO-UNIX_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${GIO-UNIX_CFLAGS_OTHER})
+
+pkg_check_modules(PBNJSON_C REQUIRED pbnjson_c)
+include_directories(${PBNJSON_C_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${PBNJSON_C_CFLAGS_OTHER})
+
+pkg_check_modules(OPENSSL REQUIRED openssl)
+include_directories(${OPENSSL_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${OPENSSL_CFLAGS_OTHER})
+
+pkg_check_modules(LUNAPREFS REQUIRED luna-prefs)
+include_directories(${LUNAPREFS_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${LUNAPREFS_CFLAGS_OTHER})
+
+pkg_check_modules(PMLOG REQUIRED PmLogLib)
+include_directories(${PMLOG_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${PMLOG_CFLAGS_OTHER})
+
+pkg_check_modules(WCA_SUPPORT REQUIRED wca-support)
+include_directories(${WCA_SUPPORT_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${WCA_SUPPORT_CFLAGS_OTHER})
+
+pkg_check_modules(WCA_SUPPORT_API REQUIRED wca-support-api>=0.1.0)
+include_directories(${WCA_SUPPORT_API_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${WCA_SUPPORT_API_CFLAGS_OTHER})
+
+pkg_check_modules(NYXLIB REQUIRED nyx)
+include_directories(${NYXLIB_INCLUDE_DIRS})
+webos_add_compiler_flags(ALL ${NYXLIB_CFLAGS_OTHER})
+
+webos_add_compiler_flags(ALL -Wall -g)
+
+webos_add_linker_options(ALL --no-undefined)
+
+set(GDBUS_IF_DIR ${WEBOS_BINARY_CONFIGURED_DIR}/src)
+
+file (MAKE_DIRECTORY ${GDBUS_IF_DIR})
+
+execute_process(COMMAND ${GDBUS_CODEGEN_EXECUTABLE} --c-namespace ConnmanInterface --generate-c-code 
+			${GDBUS_IF_DIR}/connman-interface --interface-prefix net.connman. 
+			${CMAKE_CURRENT_SOURCE_DIR}/files/xml/connman.xml
+			RESULT_VARIABLE codegen_failed)
+if(codegen_failed)
+		message(FATAL_ERROR "Error in generating code for connman interface using gdbus-codegen")
+endif()
+
+execute_process(COMMAND ${GDBUS_CODEGEN_EXECUTABLE} --c-namespace PacrunnerInterface --generate-c-code
+			${GDBUS_IF_DIR}/pacrunner-interface --interface-prefix org.pacrunner.
+			${CMAKE_CURRENT_SOURCE_DIR}/files/xml/pacrunner.xml
+			RESULT_VARIABLE codegen_failed)
+if(codegen_failed)
+		message(FATAL_ERROR "Error in generating code for pacrunner interface using gdbus-codegen")
+endif()
+
+
+set(ENABLE_SINGLE_PROFILE FALSE CACHE BOOL "Enable support for maintaining only a single profile")
+if (ENABLE_SINGLE_PROFILE)
+webos_add_compiler_flags(ALL -DENABLE_SINGLE_PROFILE)
+endif()
+
+if (ENABLE_QUICK_WOL)
+webos_add_compiler_flags(ALL -DENABLE_QUICK_WOL)
+endif()
+
+include_directories(src ${GDBUS_IF_DIR})
+webos_configure_header_files(src)
+
+file(GLOB SOURCE_FILES
+    src/common.c
+    src/connectionmanager_service.c
+    src/connman_agent.c
+    src/connman_counter.c
+    src/connman_group.c
+    src/connman_manager.c
+    src/connman_service.c
+    src/connman_service_discovery.c
+    src/connman_technology.c
+    src/json_utils.c
+    src/lunaservice_utils.c
+    src/main.c
+    src/nyx.c
+    src/pacrunner_client.c
+    src/utils.c
+    src/wifi_tethering_service.c
+    src/wifi_profile.c
+    src/wifi_service.c
+    src/wifi_setting.c
+    src/wifi_scan.c
+    src/wan_service.c
+    src/pan_service.c
+    src/state_recovery.c
+    ${GDBUS_IF_DIR}/connman-interface.c
+    ${GDBUS_IF_DIR}/pacrunner-interface.c)
+
+add_executable(webos-connman-adapter ${SOURCE_FILES})
+target_link_libraries(webos-connman-adapter
+                        ${GLIB2_LDFLAGS}
+                        ${LUNASERVICE2_LDFLAGS}
+                        ${GIO-UNIX_LDFLAGS}
+                        ${PBNJSON_C_LDFLAGS}
+                        ${OPENSSL_LDFLAGS}
+                        ${LUNAPREFS_LDFLAGS}
+                        ${PMLOG_LDFLAGS}
+                        ${WCA_SUPPORT_LDFLAGS}
+                        ${NYXLIB_LDFLAGS}
+                        rt
+                        pthread)
+
+webos_build_daemon()
+webos_build_system_bus_files()
+
+webos_config_build_doxygen(doc Doxyfile)
+
+add_subdirectory(tests)
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..53f83d3
--- /dev/null
+++ b/README.md
@@ -0,0 +1,29 @@
+webos-connman-adapter
+====================
+
+Summary
+-------
+webOS component for managing network connections using connman
+
+Description
+-----------
+webos-connman-adapter is a daemon to manage network connections on webos using connman in the backend. It provides the com.webos.service.wifi and com.webos.service.connectionmanager
+services which are stateless by themselves but talk to the connman daemon on dbus to provide all the relevant information to the rest of the webos world.
+
+# Copyright and License Information
+
+Copyright (c) 2012-2018 LG Electronics, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this content except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+SPDX-License-Identifier: Apache-2.0
diff --git a/astyle_options b/astyle_options
new file mode 100644
index 0000000..a6bb883
--- /dev/null
+++ b/astyle_options
@@ -0,0 +1,18 @@
+style=ansi
+indent=tab=4
+indent-switches
+indent-namespaces
+indent-col1-comments
+break-blocks
+pad-oper
+pad-header
+unpad-paren
+align-pointer=name
+align-reference=name
+add-brackets
+convert-tabs
+close-templates
+break-after-logical
+max-code-length=80
+lineend=linux
+
diff --git a/doc/Doxyfile.in b/doc/Doxyfile.in
new file mode 100644
index 0000000..e6d5234
--- /dev/null
+++ b/doc/Doxyfile.in
@@ -0,0 +1,1706 @@
+# @@@LICENSE
+#
+#      Copyright (c) 2012 Hewlett-Packard Development Company, L.P.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# LICENSE@@@
+
+# Doxyfile 1.7.3
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file 
+# that follow. The default is UTF-8 which is also the encoding used for all 
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the 
+# iconv built into libc) for the transcoding. See 
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = "@CMAKE_PROJECT_NAME@"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = @WEBOS_COMPONENT_VERSION@
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer
+# a quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = @WEBOS_PROJECT_SUMMARY@
+
+# With the PROJECT_LOGO tag one can specify an logo or icon that is 
+# included in the documentation. The maximum height of the logo should not 
+# exceed 55 pixels and the maximum width should not exceed 200 pixels. 
+# Doxygen will copy the logo to the output directory.
+
+PROJECT_LOGO           = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = @WEBOS_DOC_LOCATION@
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German, 
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English 
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak, 
+# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful if your file system 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like regular Qt-style comments 
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = YES
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will 
+# interpret the first line (until the first dot) of a Qt-style 
+# comment as the brief description. If set to NO, the comments 
+# will behave just like regular Qt-style comments (thus requiring 
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Java. For instance, namespaces will be presented as packages, qualified 
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL 
+# sources. Doxygen will then generate output that is tailored for 
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it 
+# parses. With this tag you can assign which parser to use for a given extension. 
+# Doxygen has a built-in mapping, but you can override or extend it using this 
+# tag. The format is ext=language, where ext is a file extension, and language 
+# is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C, 
+# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make 
+# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C 
+# (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions 
+# you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.
+
+EXTENSION_MAPPING      = 
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want 
+# to include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also makes the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to 
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only. 
+# Doxygen will parse them like normal C++ but will assume all classes use public 
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter 
+# and setter methods for a property. Setting this option to YES (the default) 
+# will make doxygen replace the get and set methods by a property in the 
+# documentation. This will only work if the methods are indeed getting or 
+# setting a simple type. If this is not the case, or you want to show the 
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum 
+# is documented as struct, union, or enum with the name of the typedef. So 
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct 
+# with name TypeT. When disabled the typedef will appear as a member of a file, 
+# namespace, or class. And the struct will be named TypeS. This can typically 
+# be useful for C code in case the coding convention dictates that all compound 
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
+# determine which symbols to keep in memory and which to flush to disk. 
+# When the cache is full, less often used symbols will be written to disk. 
+# For small to medium size projects (<1000 input files) the default value is 
+# probably good enough. For larger projects a too small cache size can cause 
+# doxygen to be busy swapping symbols to and from disk most of the time 
+# causing a significant performance penalty. 
+# If the system has enough physical memory increasing the cache will improve the 
+# performance by keeping more symbols in memory. Note that the value works on 
+# a logarithmic scale so increasing the size by one will roughly double the 
+# memory usage. The cache size is given by this formula: 
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = YES
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = YES
+
+# If this flag is set to YES, the members of anonymous namespaces will be 
+# extracted and appear in the documentation as a namespace called 
+# 'anonymous_namespace{file}', where file will be replaced with the base 
+# name of the file that contains the anonymous namespace. By default 
+# anonymous namespaces are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = YES
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen 
+# will list include files with double quotes in the documentation 
+# rather than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = YES
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen 
+# will sort the (brief and detailed) documentation of class members so that 
+# constructors and destructors are listed first. If set to NO (the default) 
+# the constructors will appear in the respective orders defined by 
+# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS. 
+# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO 
+# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the 
+# hierarchy of group names into alphabetical order. If set to NO (the default) 
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = YES
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES. 
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to
+# do proper type resolution of all parameters of a function it will reject a 
+# match between the prototype and the implementation of a member function even
+# if there is only one candidate or it is obvious which candidate to choose
+# by doing a simple string match. By disabling STRICT_PROTO_MATCHING doxygen 
+# will still accept a match between prototype and implementation in such cases.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = NO
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = NO
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or macro consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and macros in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = NO
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. 
+# This will remove the Files entry from the Quick Index and from the 
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
+# Namespaces page.  This will remove the Namespaces entry from the Quick Index 
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = NO
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from 
+# the version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed 
+# by doxygen. The layout file controls the global structure of the generated 
+# output files in an output format independent way. The create the layout file 
+# that represents doxygen's defaults, run doxygen with the -l option. 
+# You can optionally specify a file name after the option, if omitted 
+# DoxygenLayout.xml will be used as the name of the layout file.
+
+LAYOUT_FILE            = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = YES
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# The WARN_NO_PARAMDOC option can be enabled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = YES
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = @CMAKE_SOURCE_DIR@/src
+
+# This tag can be used to specify the character encoding of the source files 
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is 
+# also the default input encoding. Doxygen uses libiconv (or the iconv built 
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for 
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh 
+# *.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py 
+# *.f90 *.f *.for *.vhd *.vhdl
+
+FILE_PATTERNS          =
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix file system feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the 
+# output. The symbol name can be a fully qualified name, a word, or if the 
+# wildcard * is used, a substring. Examples: ANamespace, AClass, 
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty or if 
+# non of the patterns match the file name, INPUT_FILTER is applied.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file 
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) 
+# and it is also possible to disable source filtering for a specific pattern 
+# using *.ext= (so without naming a filter). This option only has effect when 
+# FILTER_SOURCE_FILES is enabled.
+
+FILTER_SOURCE_PATTERNS = 
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default) 
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from 
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will 
+# link to the source code.  Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = YES
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. 
+# Doxygen will adjust the colors in the stylesheet and background images 
+# according to this color. Hue is specified as an angle on a colorwheel, 
+# see http://en.wikipedia.org/wiki/Hue for more information. 
+# For instance the value 0 represents red, 60 is yellow, 120 is green, 
+# 180 is cyan, 240 is blue, 300 purple, and 360 is red again. 
+# The allowed range is 0 to 359.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of 
+# the colors in the HTML output. For a value of 0 the output will use 
+# grayscales only. A value of 255 will produce the most vivid colors.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to 
+# the luminance component of the colors in the HTML output. Values below 
+# 100 gradually make the output lighter, whereas values above 100 make 
+# the output darker. The value divided by 100 is the actual gamma applied, 
+# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2, 
+# and 100 does not change the gamma.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML 
+# page will contain the date and time when the page was generated. Setting 
+# this to NO can help when comparing the output of multiple runs.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
+# documentation will contain sections that can be hidden and shown after the 
+# page has loaded. For this to work a browser that supports 
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files 
+# will be generated that can be used as input for Apple's Xcode 3 
+# integrated development environment, introduced with OSX 10.5 (Leopard). 
+# To create a documentation set, doxygen will generate a Makefile in the 
+# HTML output directory. Running make will produce the docset in that 
+# directory and running "make install" will install the docset in 
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find 
+# it at startup. 
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html 
+# for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the 
+# feed. A documentation feed provides an umbrella under which multiple 
+# documentation sets from a single provider (such as a company or product suite) 
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that 
+# should uniquely identify the documentation set bundle. This should be a 
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen 
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify 
+# the documentation publisher. This should be a reverse domain-name style 
+# string, e.g. com.mycompany.MyDocSet.documentation.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING 
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file 
+# content.
+
+CHM_INDEX_ENCODING     = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and 
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated 
+# that can be used as input for Qt's qhelpgenerator to generate a 
+# Qt Compressed Help (.qch) of the generated HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
+# be used to specify the file name of the resulting .qch file. 
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to 
+# add. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the 
+# custom filter to add. For more information please see 
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters"> 
+# Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this 
+# project's 
+# filter section matches. 
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes"> 
+# Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
+# be used to specify the location of Qt's qhelpgenerator. 
+# If non-empty doxygen will try to run qhelpgenerator on the generated 
+# .qhp file.
+
+QHG_LOCATION           = 
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files  
+# will be generated, which together with the HTML files, form an Eclipse help 
+# plugin. To install this plugin and make it available under the help contents 
+# menu in Eclipse, the contents of the directory containing the HTML and XML 
+# files needs to be copied into the plugins directory of eclipse. The name of 
+# the directory within the plugins directory should be the same as 
+# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before 
+# the help appears.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the eclipse help plugin. When installing the plugin 
+# the directory name containing the HTML and XML files should also have 
+# this name.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [0,1..20]) 
+# that doxygen will group on one line in the generated HTML documentation. 
+# Note that a value of 0 will completely suppress the enum values from
+# appearing in the overview section.
+
+ENUM_VALUES_PER_LINE   = 1
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index 
+# structure should be generated to display hierarchical information. 
+# If the tag value is set to YES, a side panel will be generated 
+# containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser). 
+# Windows users are probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = YES
+
+# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories, 
+# and Class Hierarchy pages using a tree view instead of an ordered list.
+
+USE_INLINE_TREES       = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open 
+# links to external symbols imported via tag files in a separate window.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of Latex formulas included 
+# as images in the HTML documentation. The default is 10. Note that 
+# when you change the font size after a successful doxygen run you need 
+# to manually remove any form_*.png images from the HTML output directory 
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images 
+# generated for formulas are transparent PNGs. Transparent PNGs are 
+# not supported properly for IE 6.0, but are supported on all modern browsers. 
+# Note that when changing this option you need to delete any form_*.png files 
+# in the HTML output before the changes have effect.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax 
+# (see http://www.mathjax.org) which uses client side Javascript for the 
+# rendering instead of using prerendered bitmaps. Use this if you do not 
+# have LaTeX installed or if you want to formulas look prettier in the HTML 
+# output. When enabled you also need to install MathJax separately and 
+# configure the path to it using the MATHJAX_RELPATH option.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you need to specify the location relative to the 
+# HTML output directory using the MATHJAX_RELPATH option. The destination 
+# directory should contain the MathJax.js script. For instance, if the mathjax 
+# directory is located at the same level as the HTML output directory, then 
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the
+# mathjax.org site, so you can quickly see the result without installing 
+# MathJax, but it is strongly recommended to install a local copy of MathJax 
+# before deployment.
+
+MATHJAX_RELPATH        = http://www.mathjax.org/mathjax
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box 
+# for the HTML output. The underlying search engine uses javascript 
+# and DHTML and should work on any modern browser. Note that when using 
+# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets 
+# (GENERATE_DOCSET) there is already a search function so this one should 
+# typically be disabled. For large projects the javascript based search engine 
+# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be 
+# implemented using a PHP enabled web server instead of at the web client 
+# using Javascript. Doxygen will generate the search PHP script and index 
+# file to put on the web server. The advantage of the server 
+# based approach is that it scales better to large projects and allows 
+# full text search. The disadvantages are that it is more difficult to setup 
+# and does not have live searching capabilities.
+
+SERVER_BASED_SEARCH    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name. 
+# Note that when enabling USE_PDFLATEX this option is only used for 
+# generating bitmaps for formulas in the HTML output, but not in the 
+# Makefile that is written to the output directory.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+# If LATEX_SOURCE_CODE is set to YES then doxygen will include 
+# source code with syntax highlighting in the LaTeX output. 
+# Note that which sources are shown also depends on other settings 
+# such as SOURCE_BROWSER.
+
+LATEX_SOURCE_CODE      = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = YES
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = YES
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = @CMAKE_SOURCE_DIR@/src
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = *.h
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition that
+# overrules the definition found in the source code.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all references to function-like macros 
+# that are alone on a line, have an all uppercase name, and do not end with a 
+# semicolon, because these will confuse the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links. 
+# Note that each tag file must have a unique name 
+# (where the name does NOT include the path) 
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option also works with HAVE_DOT disabled, but it is recommended to 
+# install and use dot, since it yields more powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see 
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the 
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where 
+# the mscgen tool resides. If left empty the tool is assumed to be found in the 
+# default search path.
+
+MSCGEN_PATH            = 
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is 
+# allowed to run in parallel. When set to 0 (the default) doxygen will 
+# base this on the number of processors available in the system. You can set it 
+# explicitly to a value larger than 0 to get control over the balance 
+# between CPU load and processing speed.
+
+DOT_NUM_THREADS        = 0
+
+# By default doxygen will write a font called Helvetica to the output 
+# directory and reference it in all dot files that doxygen generates. 
+# When you want a differently looking font you can specify the font name 
+# using DOT_FONTNAME. You need to make sure dot is able to find the font, 
+# which can be done by putting it in a standard location or by setting the 
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
+# containing the font.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs. 
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the 
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
+# different font using DOT_FONTNAME you can set the path where dot 
+# can find it using this tag.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then 
+# doxygen will generate a call dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable call graphs 
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = YES
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then 
+# doxygen will generate a caller dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable caller 
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include 
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, svg, gif or svg. 
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that 
+# contain msc files that are included in the documentation (see the 
+# \mscfile command).
+
+MSCFILE_DIRS           = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen if the 
+# number of direct children of the root node in a graph is already larger than 
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note 
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that the size of a graph can be further restricted by 
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, because dot on Windows does not 
+# seem to support this out of the box. Warning: Depending on the platform used, 
+# enabling this option may lead to badly anti-aliased labels on the edges of 
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
diff --git a/files/launch/webos-connman-adapter.conf.in b/files/launch/webos-connman-adapter.conf.in
new file mode 100644
index 0000000..8456b8e
--- /dev/null
+++ b/files/launch/webos-connman-adapter.conf.in
@@ -0,0 +1,26 @@
+# Copyright (c) 2012-2018 LG Electronics, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+
+description "@WEBOS_PROJECT_SUMMARY@"
+
+start on started connman
+
+respawn
+
+# Comment this line out to suppress logs on the console
+#console output
+
+exec @WEBOS_INSTALL_SBINDIR@/webos-connman-adapter
diff --git a/files/launch/webos-connman-adapter.in b/files/launch/webos-connman-adapter.in
new file mode 100644
index 0000000..df786f5
--- /dev/null
+++ b/files/launch/webos-connman-adapter.in
@@ -0,0 +1,20 @@
+# Copyright (c) 2012-2018 LG Electronics, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+
+start on started connman
+
+respawn
+exec @WEBOS_INSTALL_SBINDIR@/webos-connman-adapter
diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
new file mode 100644
index 0000000..931ba3d
--- /dev/null
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -0,0 +1,97 @@
+{
+    "networking.internal": [
+        "com.webos.service.connectionmanager/checkinternetstatus",
+        "com.webos.service.connectionmanager/findProxyForURL",
+        "com.webos.service.connectionmanager/getinfo",
+        "com.webos.service.connectionmanager/getStatus",
+        "com.webos.service.connectionmanager/getstatus",
+        "com.webos.service.connectionmanager/getUserStatus",
+        "com.webos.service.connectionmanager/monitorActivity",
+        "com.webos.service.connectionmanager/setdns",
+        "com.webos.service.connectionmanager/setEthernetTethering",
+        "com.webos.service.connectionmanager/setipv4",
+        "com.webos.service.connectionmanager/setipv6",
+        "com.webos.service.connectionmanager/setProxy",
+        "com.webos.service.connectionmanager/setstate",
+        "com.webos.service.connectionmanager/setTechnologyState",
+        "com.webos.service.wan/connect",
+        "com.webos.service.wan/disconnect",
+        "com.webos.service.wan/getStatus",
+        "com.webos.service.wan/getContexts",
+        "com.webos.service.wan/getContext",
+        "com.webos.service.wan/setHostRoutes",
+        "com.webos.service.wifi/cancel",
+        "com.webos.service.wifi/cancelwps",
+        "com.webos.service.wifi/changeNetwork",
+        "com.webos.service.wifi/connect",
+        "com.webos.service.wifi/createwpspin",
+        "com.webos.service.wifi/deleteprofile",
+        "com.webos.service.wifi/findnetworks",
+        "com.webos.service.wifi/getmultichannelschedmode",
+        "com.webos.service.wifi/getNetworks",
+        "com.webos.service.wifi/getprofile",
+        "com.webos.service.wifi/getprofilelist",
+        "com.webos.service.wifi/getstatus",
+        "com.webos.service.wifi/getwifidiagnostics",
+        "com.webos.service.wifi/scan",
+        "com.webos.service.wifi/setmultichannelschedmode",
+        "com.webos.service.wifi/setPassthroughParams",
+        "com.webos.service.wifi/setstate",
+        "com.webos.service.wifi/startwps"
+    ],
+    "networking": [
+        "com.webos.service.connectionmanager/checkinternetstatus",
+        "com.webos.service.connectionmanager/findProxyForURL",
+        "com.webos.service.connectionmanager/getinfo",
+        "com.webos.service.connectionmanager/getStatus",
+        "com.webos.service.connectionmanager/getstatus",
+        "com.webos.service.connectionmanager/getUserStatus",
+        "com.webos.service.connectionmanager/monitorActivity",
+        "com.webos.service.connectionmanager/setdns",
+        "com.webos.service.connectionmanager/setEthernetTethering",
+        "com.webos.service.connectionmanager/setipv4",
+        "com.webos.service.connectionmanager/setipv6",
+        "com.webos.service.connectionmanager/setProxy",
+        "com.webos.service.connectionmanager/setstate",
+        "com.webos.service.connectionmanager/setTechnologyState",
+        "com.webos.service.wan/connect",
+        "com.webos.service.wan/disconnect",
+        "com.webos.service.wan/getStatus",
+        "com.webos.service.wan/getContexts",
+        "com.webos.service.wan/getContext",
+        "com.webos.service.wan/setHostRoutes",
+        "com.webos.service.wifi/cancel",
+        "com.webos.service.wifi/cancelwps",
+        "com.webos.service.wifi/changeNetwork",
+        "com.webos.service.wifi/connect",
+        "com.webos.service.wifi/createwpspin",
+        "com.webos.service.wifi/deleteprofile",
+        "com.webos.service.wifi/findnetworks",
+        "com.webos.service.wifi/getmultichannelschedmode",
+        "com.webos.service.wifi/getNetworks",
+        "com.webos.service.wifi/getprofile",
+        "com.webos.service.wifi/getprofilelist",
+        "com.webos.service.wifi/getstatus",
+        "com.webos.service.wifi/getwifidiagnostics",
+        "com.webos.service.wifi/scan",
+        "com.webos.service.wifi/setmultichannelschedmode",
+        "com.webos.service.wifi/setPassthroughParams",
+        "com.webos.service.wifi/setstate",
+        "com.webos.service.wifi/startwps"
+    ],
+    "networking.query": [
+        "com.webos.service.connectionmanager/checkinternetstatus",
+        "com.webos.service.connectionmanager/findProxyForURL",
+        "com.webos.service.connectionmanager/getinfo",
+        "com.webos.service.connectionmanager/getStatus",
+        "com.webos.service.connectionmanager/getstatus",
+        "com.webos.service.connectionmanager/getUserStatus",
+        "com.webos.service.connectionmanager/getwolwowlstatus",
+        "com.webos.service.connectionmanager/monitorActivity",
+        "com.webos.service.wan/getStatus",
+        "com.webos.service.wan/getContexts",
+        "com.webos.service.wan/getContext",
+        "com.webos.service.wifi/getstatus",
+        "com.webos.service.wifi/getwifidiagnostics"
+    ]
+}
diff --git a/files/sysbus/webos-connman-adapter.perm.json b/files/sysbus/webos-connman-adapter.perm.json
new file mode 100644
index 0000000..03a838a
--- /dev/null
+++ b/files/sysbus/webos-connman-adapter.perm.json
@@ -0,0 +1,22 @@
+{
+    "com.webos.service.wifi": [
+        "settings",
+        "devices",
+        "networking.internal"
+    ],
+    "com.webos.service.connectionmanager": [
+        "settings",
+        "devices",
+        "networking.internal"
+    ],
+    "com.webos.service.wan": [
+        "settings",
+        "devices",
+        "networking.internal"
+    ],
+    "com.webos.service.pan": [
+        "settings",
+        "devices",
+        "networking.internal"
+    ]
+}
diff --git a/files/sysbus/webos-connman-adapter.role.json.in b/files/sysbus/webos-connman-adapter.role.json.in
new file mode 100644
index 0000000..270216a
--- /dev/null
+++ b/files/sysbus/webos-connman-adapter.role.json.in
@@ -0,0 +1,36 @@
+{
+    "exeName":"@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter",
+    "type":"regular",
+    "allowedNames":["com.webos.service.wifi", "com.webos.service.connectionmanager", "com.webos.service.wan", "com.webos.service.pan"],
+    "permissions": [
+        {
+            "service":"com.webos.service.wifi",
+            "outbound":["com.webos.service.pdm",
+                        "com.webos.settingsservice",
+                        "com.webos.service.wifi",
+                        "com.webos.service.config",
+                        "com.webos.service.connectionmanager"]
+        },
+        {
+            "service":"com.webos.service.connectionmanager",
+            "outbound":["com.webos.service.pdm",
+                        "com.webos.settingsservice",
+                        "com.webos.service.wifi",
+                        "com.webos.service.config"]
+        },
+        {
+            "service":"com.webos.service.wan",
+            "outbound":["com.webos.service.pdm",
+                        "com.webos.settingsservice",
+                        "com.webos.service.wifi",
+                        "com.webos.service.config"]
+        },
+        {
+            "service":"com.webos.service.pan",
+            "outbound":["com.webos.service.pdm",
+                        "com.webos.settingsservice",
+                        "com.webos.service.wifi",
+                        "com.webos.service.config"]
+        }
+    ]
+}
diff --git a/files/sysbus/webos-connman-adapter.service.in b/files/sysbus/webos-connman-adapter.service.in
new file mode 100644
index 0000000..caa8971
--- /dev/null
+++ b/files/sysbus/webos-connman-adapter.service.in
@@ -0,0 +1,4 @@
+[D-BUS Service]
+Name=com.webos.service.wifi;com.webos.service.wan;com.webos.service.connectionmanager;com.webos.service.pan
+Exec="@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter
+Type=static
diff --git a/files/xml/connman.xml b/files/xml/connman.xml
new file mode 100644
index 0000000..54d2e1d
--- /dev/null
+++ b/files/xml/connman.xml
@@ -0,0 +1,244 @@
+<!-- LICENSE@@@
+
+Copyright (c) 2013 LG Electronics, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+@@@LICENSE -->
+
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+		"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+	<interface name="net.connman.Manager">
+		<method name="GetProperties">
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<method name="SetProperty">
+			<arg type="s" direction="in"/>
+			<arg type="v" direction="in"/>
+		</method>
+		<method name="GetState">
+			<arg type="s" direction="out"/>
+		</method>
+		<method name="EnableTechnology">
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="DisableTechnology">
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="GetServices">
+			<arg type="a(oa{sv})" direction="out"/>
+		</method>
+		<method name="GetSavedServices">
+			<arg type="a(oa{sv})" direction="out"/>
+		</method>
+		<method name="ChangeSavedService">
+			<arg type="s" direction="in"/>
+			<arg type="a{sv}" direction="in"/>
+		</method>
+		<method name="GetTechnologies">
+			<arg type="a(oa{sv})" direction="out"/>
+		</method>
+		<method name="GetGroups">
+			<arg type="a(oa{sv})" direction="out"/>
+		</method>
+		<method name="RegisterAgent">
+			<arg type="o" direction="in"/>
+		</method>
+		<method name="UnregisterAgent">
+			<arg type="o" direction="in"/>
+		</method>
+		<method name="RegisterCounter">
+			<arg type="o" direction="in"/>
+			<arg type="u" direction="in"/>
+			<arg type="u" direction="in"/>
+		</method>
+		<method name="UnregisterCounter">
+			<arg type="o" direction="in"/>
+		</method>
+		<method name="CreateGroup">
+			<arg type="s" direction="in"/>
+			<arg type="s" direction="in"/>
+			<arg type="o" direction="out"/>
+		</method>
+		<method name="GetStaCount">
+			<arg type="i" direction="out"/>
+		</method>
+		<signal name="PropertyChanged">
+			<arg type="s"/>
+			<arg type="v"/>
+		</signal>
+		<signal name="TechnologyAdded">
+			<arg type="o"/>
+			<arg type="a{sv}"/>
+		</signal>
+		<signal name="TechnologyRemoved">
+			<arg type="o"/>
+		</signal>
+		<signal name="ServicesChanged">
+			<arg type="a(oa{sv})"/>
+			<arg type="ao"/>
+		</signal>
+		<signal name="SavedServicesChanged">
+			<arg type="a(oa{sv})"/>
+			<arg type="ao"/>
+		</signal>
+		<signal name="GroupAdded">
+			<arg type="o"/>
+			<arg type="a{sv}"/>
+		</signal>
+		<signal name="GroupRemoved">
+			<arg type="o"/>
+		</signal>
+	</interface>
+	<interface name="net.connman.Technology">
+		<method name="GetProperties">
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<method name="SetProperty">
+			<arg type="s" direction="in"/>
+			<arg type="v" direction="in"/>
+		</method>
+		<method name="Scan">
+		</method>
+		<method name="StartWPS">
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="CancelP2P">
+		</method>
+		<method name="CancelWPS">
+		</method>
+		<method name="RemoveSavedServices">
+			<arg type="s" name="exception" direction="in"/>
+		</method>
+		<method name="GetInterfaceProperties">
+			<arg type="s" direction="in"/>
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<signal name="PropertyChanged">
+			<arg type="s"/>
+			<arg type="v"/>
+		</signal>
+		<signal name="WPSFailed"/>
+		<signal name="TetheringStaAuthorized"/>
+		<signal name="TetheringStaDeauthorized"/>
+	</interface>
+	<interface name="net.connman.Service">
+		<method name="GetProperties">
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<method name="SetProperty">
+			<arg type="s" direction="in"/>
+			<arg type="v" direction="in"/>
+		</method>
+		<method name="Connect">
+		</method>
+		<method name="Disconnect">
+		</method>
+		<method name="Remove">
+		</method>
+		<method name="RejectPeer">
+		</method>
+		<signal name="PropertyChanged">
+			<arg type="s"/>
+			<arg type="v"/>
+		</signal>
+	</interface>
+	<interface name="net.connman.Agent">
+		<method name="Release">
+		</method>
+		<method name="ReportError">
+			<arg type="o" direction="in"/>
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="RequestBrowser">
+			<arg type="o" direction="in"/>
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="RequestInput">
+			<arg type="o" direction="in"/>
+			<arg type="a{sv}" direction="in"/>
+			<arg type="a{sv}" direction="out"/>
+		</method>
+	</interface>
+	<interface name="net.connman.Counter">
+		<method name="Release">
+		</method>
+		<method name="Usage">
+			<arg type="o" direction="in"/>
+			<arg type="a{sv}" direction="in"/>
+			<arg type="a{sv}" direction="in"/>
+		</method>
+	</interface>
+	<interface name="net.connman.Group">
+		<method name="GetProperties">
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<method name="SetProperty">
+			<arg type="s" direction="in"/>
+			<arg type="v" direction="in"/>
+		</method>
+		<method name="Disconnect">
+		</method>
+		<method name="Invite">
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="GetPeers">
+			<arg type="a(oa{sv})" direction="out"/>
+		</method>
+		<signal name="PropertyChanged">
+			<arg type="s"/>
+			<arg type="v"/>
+		</signal>
+	</interface>
+	<interface name="net.connman.ServiceDiscovery">
+		<method name="GetProperties">
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<method name="SetProperty">
+			<arg type="s" direction="in"/>
+			<arg type="v" direction="in"/>
+		</method>
+		<method name="RequestDiscoverUPnPService">
+			<arg type="s" direction="in"/>
+			<arg type="i" direction="in"/>
+			<arg type="s" direction="in"/>
+			<arg type="i" direction="out"/>
+		</method>
+		<method name="RequestDiscoverBonjourService">
+			<arg type="s" direction="in"/>
+			<arg type="ay" direction="in"/>
+			<arg type="i" direction="out"/>
+		</method>
+		<method name="RegisterUPnPService">
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="RemoveUPnPService">
+			<arg type="s" direction="in"/>
+		</method>
+		<method name="RegisterBonjourService">
+			<arg type="ay" direction="in"/>
+			<arg type="ay" direction="in"/>
+		</method>
+		<method name="RemoveBonjourService">
+			<arg type="ay" direction="in"/>
+		</method>
+		<signal name="DiscoveryResponse">
+			<arg type="s"/>
+			<arg type="i"/>
+			<arg type="ay">
+				<annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+			</arg>
+		</signal>
+	</interface>
+</node>
diff --git a/files/xml/pacrunner.xml b/files/xml/pacrunner.xml
new file mode 100644
index 0000000..a3cf5d5
--- /dev/null
+++ b/files/xml/pacrunner.xml
@@ -0,0 +1,29 @@
+<!-- LICENSE@@@
+
+Copyright (c) 2013 LG Electronics, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+@@@LICENSE -->
+
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+		"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+	<interface name="org.pacrunner.Client">
+		<method name="FindProxyForURL">
+			<arg name="url" type="s" direction="in"/>
+			<arg name="host" type="s" direction="in"/>
+			<arg name="proxy" type="s" direction="out"/>
+		</method>
+	</interface>
+</node>
diff --git a/src/common.c b/src/common.c
new file mode 100644
index 0000000..a7e4421
--- /dev/null
+++ b/src/common.c
@@ -0,0 +1,401 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  common.c
+ *
+ * @brief Implements some of the common utility functions
+ */
+
+#include <glib.h>
+#include <arpa/inet.h>
+
+#include "common.h"
+#include "logging.h"
+#include "errors.h"
+#include "wifi_service.h"
+#include "lunaservice_utils.h"
+
+static gchar *current_system_locale = NULL;
+
+/**
+ *  @brief Check if the connman manager is available and if network access is allowed and
+ *  send an error message to the supplied luna message handle if one of both checks
+ *  returns FALSE.
+ *
+ *  @param manager Connman manager object
+ *  @param sh Luna service bus handle
+ *  @param message Luna message handle
+ *
+ *  @return TRUE if the connman manager is not available or network access is not allowed.
+ *  FALSE otherwise.
+ */
+
+gboolean connman_status_check(connman_manager_t *manager, LSHandle *sh,
+                              LSMessage *message)
+{
+	if (!connman_manager_is_manager_available(manager))
+	{
+		LSMessageReplyCustomError(sh, message, "Connman service unavailable",
+		                          WCA_API_ERROR_CONNMAN_UNAVAILABLE);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_status_check_with_subscription(connman_manager_t *manager,
+        LSHandle *sh, LSMessage *message, bool subscribed)
+{
+	if (!connman_manager_is_manager_available(manager))
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message,
+		        "Connman service unavailable",
+		        WCA_API_ERROR_CONNMAN_UNAVAILABLE, subscribed);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+/**
+ *  @brief Check wether the wifi technology is powered (the "Powered" property has the
+ *  value true).
+ *
+ *  @return Returns true if wifi technology is powered on
+ */
+
+gboolean is_wifi_powered(void)
+{
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	return (NULL != technology) && technology->powered;
+}
+
+/**
+ *  @brief Check wether the wifi technology is currently tethering (the "Tethering"
+ *         property has the value true)
+ *
+ * @return Returns true if wifi technology is currently tethering, false otherwise.
+ */
+gboolean is_wifi_tethering(void)
+{
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	return (NULL != technology) && technology->tethering;
+}
+
+/**
+ *  @brief Check if the wifi technology is available. If the technology is not available
+ *  an error message is send to the supplied luna message handle.
+ *
+ *  @param sh Luna śervice handle
+ *  @param message Luna message handle
+ *  @return TRUE if wifi technology is available, FALSE otherwise.
+ */
+
+gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message)
+{
+	if (NULL == connman_manager_find_wifi_technology(manager))
+	{
+		LSMessageReplyCustomError(sh, message, "WiFi technology unavailable",
+		                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
+        LSMessage *message, bool subscribed)
+{
+	if (NULL == connman_manager_find_wifi_technology(manager))
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message,
+		        "WiFi technology unavailable",
+		        WCA_API_ERROR_WIFI_TECH_UNAVAILABLE, subscribed);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+/**
+ * @brief Set the wifi power status according to wether network access is allowed or not
+ */
+
+gboolean set_wifi_powered_status(gboolean state)
+{
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (wifi_tech)
+	{
+		if (connman_technology_set_powered(wifi_tech, state, NULL))
+		{
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+void set_cellular_powered_status(gboolean state)
+{
+	connman_technology_t *cellular_tech = connman_manager_find_cellular_technology(
+	        manager);
+
+	if (!cellular_tech)
+	{
+		return;
+	}
+
+	connman_technology_set_powered(cellular_tech, state, NULL);
+}
+
+/**
+*  @brief Returns true if wan technology is powered on
+*
+*/
+
+gboolean is_cellular_powered(void)
+{
+	connman_technology_t *technology = connman_manager_find_cellular_technology(
+	                                       manager);
+	return (NULL != technology) && technology->powered;
+}
+
+/**
+*  @brief Check if the wan technology is available
+*   Send an error luna message if its not available
+*
+*  @param sh
+*  @param message
+*/
+
+gboolean cellular_technology_status_check(LSHandle *sh, LSMessage *message)
+{
+	if (NULL == connman_manager_find_cellular_technology(manager))
+	{
+		LSMessageReplyCustomError(sh, message, "Cellular technology unavailable",
+		                          WCA_API_ERROR_CELLULAR_TECH_UNAVAILABLE);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean cellular_technology_status_check_with_subscription(LSHandle *sh,
+        LSMessage *message, bool subscribed)
+{
+	if (NULL == connman_manager_find_cellular_technology(manager))
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message,
+		        "Cellular technology unavailable",
+		        WCA_API_ERROR_CELLULAR_TECH_UNAVAILABLE, subscribed);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool is_valid_ipv6address(char *ipAddress)
+{
+	unsigned char ipv6_addr[sizeof(struct in6_addr)];
+	int result = 0;
+
+	if (strstr(ipAddress, ":") != NULL)
+	{
+		result = inet_pton(AF_INET6, ipAddress, &ipv6_addr);
+	}
+
+	return result != 0;
+}
+
+bool is_valid_ipaddress(char *ipAddress)
+{
+	struct sockaddr_in sa;
+	int result;
+
+	if (is_valid_ipv6address(ipAddress))
+	{
+		result = TRUE;
+	}
+	else
+	{
+		result = inet_pton(AF_INET, ipAddress, &(sa.sin_addr));
+	}
+
+	return result != 0;
+}
+
+/**
+ * @brief Handle a response of a call to com.webos.settingsservice/getSystemSettings for
+ * the current system UI locale.
+ *
+ * @param sh Luna service handle
+ * @param message Luna message handle
+ * @param ctx User context data
+ *
+ * @return TRUE if response handling was successfull. Otherwise FALSE.
+ */
+
+static bool locale_status_cb(LSHandle *sh, LSMessage *message, void *ctx)
+{
+	jvalue_ref parsedObj = {0};
+	jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT,
+	                           NULL);
+
+	if (!input_schema)
+	{
+		return false;
+	}
+
+	JSchemaInfo schemaInfo;
+	jschema_info_init(&schemaInfo, input_schema, NULL,
+	                  NULL); // no external refs & no error handlers
+	parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)),
+	                       DOMOPT_NOOPT, &schemaInfo);
+	jschema_release(&input_schema);
+
+	if (jis_null(parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref settingsObj = {0}, localeInfoObj = {0}, localesObj = {0}, UIObj = {0};
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("settings"), &settingsObj))
+	{
+		if (jobject_get_exists(settingsObj, J_CSTR_TO_BUF("localeInfo"),
+		                       &localeInfoObj))
+		{
+			if (jobject_get_exists(localeInfoObj, J_CSTR_TO_BUF("locales"), &localesObj))
+			{
+				if (jobject_get_exists(localesObj, J_CSTR_TO_BUF("UI"), &UIObj))
+				{
+					g_free(current_system_locale);
+					raw_buffer address_buf = jstring_get(UIObj);
+					current_system_locale = g_strdup(address_buf.m_str);
+					jstring_free_buffer(address_buf);
+
+					WCALOG_DEBUG("Received system locale '%s'", current_system_locale);
+
+					wifi_service_local_has_changed();
+				}
+			}
+		}
+	}
+
+	j_release(&parsedObj);
+
+	return true;
+}
+
+/**
+ * @brief Retrieve the currently configured system UI locale from the settings service
+ */
+
+void retrieve_system_locale_info(LSHandle *handle)
+{
+	if (!LSCall(handle, "palm://com.webos.settingsservice/getSystemSettings",
+	       "{\"keys\":[\"localeInfo\"],\"subscribe\":true}", locale_status_cb, NULL, NULL,
+	       NULL))
+		WCALOG_DEBUG("Failed to get system locale information from com.webos.settingsservice");
+}
+
+const gchar *get_current_system_locale()
+{
+	return current_system_locale;
+}
+
+gboolean ethernet_technology_status_check(LSHandle *sh, LSMessage *message)
+{
+	if (NULL == connman_manager_find_ethernet_technology(manager))
+	{
+		LSMessageReplyCustomError(sh, message, "Ethernet technology unavailable",
+		                          WCA_API_ERROR_ETHERNET_TECHNOLOGY_UNAVAILABLE);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean is_ethernet_tethering(void)
+{
+	connman_technology_t *technology = connman_manager_find_ethernet_technology(
+	                                       manager);
+	return (NULL != technology) && technology->tethering;
+}
+
+/**
+ *  @brief Check wether the bluetooth technology is powered (the "Powered" property has the
+ *  value true).
+ *
+ *  @return Returns true if bluetooth technology is powered on
+ */
+
+gboolean is_bluetooth_powered(void)
+{
+	connman_technology_t *technology = connman_manager_find_bluetooth_technology(
+	                                       manager);
+	return (NULL != technology) && technology->powered;
+}
+
+/**
+ *  @brief Check wether the bluetooth technology is currently tethering (the "Tethering"
+ *         property has the value true)
+ *
+ * @return Returns true if bluetooth technology is currently tethering, false otherwise.
+ */
+gboolean is_bluetooth_tethering(void)
+{
+	connman_technology_t *technology = connman_manager_find_bluetooth_technology(
+	                                       manager);
+	return (NULL != technology) && technology->tethering;
+}
+
+/**
+ *  @brief Check if the bluetooth technology is available. If the technology is not available
+ *  an error message is send to the supplied luna message handle.
+ *
+ *  @param sh Luna śervice handle
+ *  @param message Luna message handle
+ *  @return TRUE if bluetooth technology is available, FALSE otherwise.
+ */
+
+gboolean bluetooth_technology_status_check(LSHandle *sh, LSMessage *message)
+{
+	if (NULL == connman_manager_find_bluetooth_technology(manager))
+	{
+		LSMessageReplyCustomError(sh, message, "Bluetooth technology unavailable",
+		                          WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean bluetooth_technology_status_check_with_subscription(LSHandle *sh,
+        LSMessage *message, bool subscribed)
+{
+	if (NULL == connman_manager_find_bluetooth_technology(manager))
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message,
+		        "Bluetooth technology unavailable",
+		        WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE, subscribed);
+		return FALSE;
+	}
+
+	return TRUE;
+}
diff --git a/src/common.h b/src/common.h
new file mode 100644
index 0000000..bd1ae22
--- /dev/null
+++ b/src/common.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+#include "connman_manager.h"
+#include "connman_agent.h"
+
+
+extern connman_manager_t *manager;
+extern connman_agent_t *agent;
+
+extern gboolean connman_status_check(connman_manager_t *manager, LSHandle *sh,
+                                     LSMessage *message);
+extern gboolean is_wifi_powered(void);
+extern gboolean is_wifi_tethering(void);
+extern gboolean is_cellular_powered(void);
+extern gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message);
+extern gboolean cellular_technology_status_check(LSHandle *sh,
+        LSMessage *message);
+extern gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
+                                                        LSMessage *message, bool subscribed);
+extern gboolean connman_status_check_with_subscription(connman_manager_t *manager,
+                                                LSHandle *sh, LSMessage *message, bool subscribed);
+extern gboolean set_wifi_powered_status(gboolean state);
+extern const gchar *get_current_system_locale();
+extern void retrieve_system_locale_info(LSHandle *handle);
+extern void set_cellular_powered_status(gboolean state);
+extern gboolean is_ethernet_tethering(void);
+extern gboolean is_bluetooth_powered(void);
+extern gboolean is_bluetooth_tethering(void);
+extern bool is_valid_ipv6address(char *ipAddress);
+extern bool is_valid_ipaddress(char *ipAddress);
+extern gboolean bluetooth_technology_status_check(LSHandle *sh,
+        LSMessage *message);
+extern gboolean bluetooth_technology_status_check_with_subscription(
+    LSHandle *sh, LSMessage *message, bool subscribed);
+extern gboolean ethernet_technology_status_check(LSHandle *sh, LSMessage *message);
+
+#endif /* _COMMON_H_ */
+
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
new file mode 100644
index 0000000..30df74c
--- /dev/null
+++ b/src/connectionmanager_service.c
@@ -0,0 +1,2837 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connectionmanager_service.c
+ *
+ * @brief Implements all of the com.webos.service.connectionmanager methods using connman APIs
+ * in the backend.
+ */
+
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+
+@brief This service provides overall management of network connections.
+
+Each call has a standard return response format in the case of a failure, as follows:
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | False to inidicate an error
+errorCode | Yes | Integer | Error code
+errorText | Yes | String | Error description
+
+@{
+@}
+*/
+
+#include <glib.h>
+#include <stdbool.h>
+#include <time.h>
+#include <string.h>
+#include <pbnjson.h>
+#include <errno.h>
+
+#include "common.h"
+#include "connman_manager.h"
+#include "connman_counter.h"
+#include "connman_service.h"
+#include "connectionmanager_service.h"
+#include "lunaservice_utils.h"
+#include "logging.h"
+#include "errors.h"
+#include "wifi_profile.h"
+#include "utils.h"
+#include "nyx.h"
+#include "pacrunner_client.h"
+#include "wan_service.h"
+#include "pan_service.h"
+#include "wifi_setting.h"
+
+#define COUNTER_ACCURACY    10
+#define COUNTER_PERIOD      1
+#define GETINFO_UPDATE_INTERVAL_SECONDS 1
+
+static LSHandle *pLsHandle;
+
+connman_counter_t *counter = NULL;
+connman_counter_data_t counter_data_new[CONNMAN_SERVICE_TYPE_MAX],
+                       counter_data_old[CONNMAN_SERVICE_TYPE_MAX];
+
+gboolean online_status = FALSE;
+gboolean wired_online_checking_status = FALSE;
+gboolean wifi_online_checking_status = FALSE;
+gboolean wired_connected = FALSE;
+gboolean wifi_connected = FALSE;
+gboolean p2p_connected = FALSE;
+gboolean cellular_powered = FALSE;
+gboolean wan_connected = FALSE;
+gboolean pan_connected = FALSE;
+guint block_getstatus_response = 0;
+gboolean old_wifi_tethering = FALSE;
+gboolean old_pan_tethering = FALSE;
+gboolean wired_plugged = FALSE;
+
+char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
+char getinfo_cur_wired_mac_address[MAC_ADDR_STRING_LEN]={0};
+
+static void getinfo_update(void);
+
+#define IS_WIRED_PLUGGED() g_slist_length(manager->wired_services)
+
+static bool is_caller_using_new_interface(LSMessage *message)
+{
+	if (!message)
+	{
+		return false;
+	}
+
+	LSHandle *handle = LSMessageGetConnection(message);
+
+	if (!handle)
+	{
+		return false;
+	}
+
+	const char *name = LSHandleGetName(handle);
+
+	if (!name)
+	{
+		return false;
+	}
+
+	return (g_strcmp0(name, "com.webos.service.connectionmanager") == 0);
+}
+
+static gboolean set_ethernet_tethering_state(bool state)
+{
+	return connman_technology_set_tethering(
+	           connman_manager_find_ethernet_technology(manager), state);
+}
+
+/**
+ * @brief Fill in information about the system's connection status
+ *
+ * @param connected_service The connected connman service the status should be filled into
+ * the supplied json status object
+ * @param status json status object to fill with the service status
+ */
+
+static void update_connection_status(connman_service_t *connected_service,
+                                     jvalue_ref *status)
+{
+	if (NULL == connected_service || NULL == status)
+	{
+		return;
+	}
+
+	int connman_state = 0;
+	connman_state = connman_service_get_state(connected_service->state);
+
+	if (connman_state == CONNMAN_SERVICE_STATE_ONLINE
+		|| connman_state == CONNMAN_SERVICE_STATE_READY
+		|| connman_state == CONNMAN_SERVICE_STATE_CONFIGURATION)
+	{
+		connman_service_get_ipinfo(connected_service);
+		jobject_put(*status, J_CSTR_TO_JVAL("state"), jstring_create("connected"));
+
+		if (NULL != connected_service->ipinfo.iface)
+		{
+			jobject_put(*status, J_CSTR_TO_JVAL("interfaceName"),
+			            jstring_create(connected_service->ipinfo.iface));
+		}
+
+		if (NULL != connected_service->ipinfo.ipv4.address)
+		{
+			jobject_put(*status, J_CSTR_TO_JVAL("ipAddress"),
+			            jstring_create(connected_service->ipinfo.ipv4.address));
+		}
+
+		if (NULL != connected_service->ipinfo.ipv4.netmask)
+		{
+			jobject_put(*status, J_CSTR_TO_JVAL("netmask"),
+			            jstring_create(connected_service->ipinfo.ipv4.netmask));
+		}
+
+		if (NULL != connected_service->ipinfo.ipv4.gateway)
+		{
+			jobject_put(*status, J_CSTR_TO_JVAL("gateway"),
+			            jstring_create(connected_service->ipinfo.ipv4.gateway));
+		}
+
+		gsize i;
+		char dns_str[16];
+
+		for (i = 0; i < g_strv_length(connected_service->ipinfo.dns); i++)
+		{
+			g_snprintf(dns_str, 16, "dns%d", i + 1);
+			jobject_put(*status, jstring_create(dns_str),
+			            jstring_create(connected_service->ipinfo.dns[i]));
+		}
+
+		if (NULL != connected_service->ipinfo.ipv4.method)
+		{
+			jobject_put(*status, J_CSTR_TO_JVAL("method"),
+			            jstring_create(connected_service->ipinfo.ipv4.method));
+		}
+
+		if (connman_service_type_wifi(connected_service))
+		{
+			if (NULL != connected_service->name)
+			{
+				jobject_put(*status, J_CSTR_TO_JVAL("ssid"),
+				            jstring_create(connected_service->name));
+			}
+
+			jobject_put(*status, J_CSTR_TO_JVAL("isWakeOnWifiEnabled"),
+			            jboolean_create(false));
+		}
+
+		const char *s = connman_service_is_online(connected_service) ? "yes" : "no";
+		jobject_put(*status, J_CSTR_TO_JVAL("onInternet"), jstring_create(s));
+		jobject_put(*status, J_CSTR_TO_JVAL("checkingInternet"), jboolean_create(connected_service->online_checking));
+
+		if (NULL != connected_service->ipinfo.ipv6.address)
+		{
+			jvalue_ref connected_ipv6_status = jobject_create();
+
+			jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("ipAddress"),
+			            jstring_create(connected_service->ipinfo.ipv6.address));
+
+			if (connected_service->ipinfo.ipv6.prefix_length >= 0 &&
+			        connected_service->ipinfo.ipv6.prefix_length <= 128)
+			{
+				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("prefixLength"),
+				            jnumber_create_i32(connected_service->ipinfo.ipv6.prefix_length));
+			}
+
+			if (NULL != connected_service->ipinfo.ipv6.gateway)
+			{
+				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("gateway"),
+				            jstring_create(connected_service->ipinfo.ipv6.gateway));
+			}
+
+			if (NULL != connected_service->ipinfo.ipv6.method)
+			{
+				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("method"),
+				            jstring_create(connected_service->ipinfo.ipv6.method));
+			}
+
+			jobject_put(*status, J_CSTR_TO_JVAL("ipv6"), connected_ipv6_status);
+		}
+
+		connman_service_get_proxyinfo(connected_service);
+
+		if (NULL != connected_service->proxyinfo.method)
+		{
+			jvalue_ref connected_proxy_status = jobject_create();
+
+			jobject_put(connected_proxy_status, J_CSTR_TO_JVAL("method"),
+							jstring_create(connected_service->proxyinfo.method));
+
+			if (!g_strcmp0(connected_service->proxyinfo.method, "auto"))
+			{
+				if (NULL != connected_service->proxyinfo.url)
+				{
+					jobject_put(connected_proxy_status, J_CSTR_TO_JVAL("url"),
+								jstring_create(connected_service->proxyinfo.url));
+				}
+			}
+			else if(!g_strcmp0(connected_service->proxyinfo.method, "manual"))
+			{
+				if (NULL != connected_service->proxyinfo.servers)
+				{
+					gsize i;
+					jvalue_ref servers_obj = jarray_create(NULL);
+
+					for (i = 0; i < g_strv_length(connected_service->proxyinfo.servers); i++)
+					{
+						jarray_append(servers_obj, jstring_create(connected_service->proxyinfo.servers[i]));
+					}
+
+					jobject_put(connected_proxy_status, J_CSTR_TO_JVAL("servers"), servers_obj);
+				}
+
+				if (NULL != connected_service->proxyinfo.excludes)
+				{
+					gsize i;
+					jvalue_ref excludes_obj = jarray_create(NULL);
+
+					for (i = 0; i < g_strv_length(connected_service->proxyinfo.excludes); i++)
+					{
+						jarray_append(excludes_obj, jstring_create(connected_service->proxyinfo.excludes[i]));
+					}
+
+					jobject_put(connected_proxy_status, J_CSTR_TO_JVAL("excludes"), excludes_obj);
+				}
+			}
+
+			jobject_put(*status, J_CSTR_TO_JVAL("proxyinfo"), connected_proxy_status);
+		}
+
+	}
+	else
+	{
+		jobject_put(*status, J_CSTR_TO_JVAL("state"), jstring_create("disconnected"));
+	}
+}
+
+/**
+ * @brief Handle the "PropertyChanged" signal for a net.connman.Group dbus object.
+ *
+ * @param data User context data
+ * @param property Name of the property which has changed.
+ * @param value Value of the changed property.
+ */
+
+static void group_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	if (!g_strcmp0(property, "LocalAddress"))
+	{
+		connman_service_t *connected_p2p_service =
+		    connman_manager_get_connected_service(manager->p2p_services);
+
+		if (NULL != connected_p2p_service)
+		{
+			connman_service_set_changed(connected_p2p_service,
+			                            CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+			connectionmanager_send_status_to_subscribers();
+		}
+	}
+}
+
+/**
+ * @brief Append the P2P connection status of a connman service object to a existing JSON
+ * object.
+ *
+ * @param status JSON object where the P2P connection status should be appended to
+ * @param connected_service Connman service object which status should be used
+ */
+
+static void append_p2p_connection_status(jvalue_ref *status,
+        connman_service_t *connected_service)
+{
+	if (NULL == connected_service || NULL == status)
+	{
+		return;
+	}
+
+	int connman_state = 0;
+	connman_state = connman_service_get_state(connected_service->state);
+
+	if (connman_state == CONNMAN_SERVICE_STATE_ONLINE ||
+	        connman_state == CONNMAN_SERVICE_STATE_READY)
+	{
+		jobject_put(*status, J_CSTR_TO_JVAL("state"), jstring_create("connected"));
+
+		GSList *groupnode, *peernode;
+
+		for (groupnode = manager->groups; groupnode ; groupnode = groupnode->next)
+		{
+			connman_group_t *group = (connman_group_t *)(groupnode->data);
+
+			if (connman_manager_populate_group_peers(manager, group) == TRUE)
+			{
+				for (peernode = group->peer_list; peernode ; peernode = peernode->next)
+				{
+					connman_service_t *peer_service = (connman_service_t *) peernode->data;
+
+					if (connected_service == peer_service)
+					{
+						/* to cover the case where the PropertyChanged signal for local address is missed */
+						if (!group->local_address)
+						{
+							connman_group_get_local_address(group);
+						}
+
+						if (group->local_address)
+						{
+							jobject_put(*status, J_CSTR_TO_JVAL("localIp"),
+							            jstring_create(group->local_address));
+						}
+
+						connman_group_register_property_changed_cb(group,
+						        group_property_changed_callback);
+					}
+				}
+			}
+		}
+
+		GSList *listnode;
+		jvalue_ref peer_list = jarray_create(NULL);
+
+		for (listnode = manager->p2p_services; listnode ; listnode = listnode->next)
+		{
+			connman_service_t *service = (connman_service_t *)(listnode->data);
+			int service_state = connman_service_get_state(service->state);
+
+			if (service_state == CONNMAN_SERVICE_STATE_ONLINE ||
+			        service_state == CONNMAN_SERVICE_STATE_READY)
+			{
+				jvalue_ref peer_info = jobject_create();
+
+				jobject_put(peer_info, J_CSTR_TO_JVAL("deviceName"),
+				            jstring_create(service->name));
+
+				if (service->peer.address)
+				{
+					jobject_put(peer_info, J_CSTR_TO_JVAL("deviceAddress"),
+					            jstring_create(service->peer.address));
+				}
+
+				jobject_put(peer_info, J_CSTR_TO_JVAL("groupOwner"),
+				            jboolean_create(service->peer.group_owner));
+
+				if (service->peer.config_method)
+				{
+					jobject_put(peer_info, J_CSTR_TO_JVAL("configMethod"),
+					            jnumber_create_i32(service->peer.config_method));
+				}
+
+				jobject_put(peer_info, J_CSTR_TO_JVAL("signalLevel"),
+				            jnumber_create_i32(service->strength));
+
+				if (NULL != service->ipinfo.ipv4.address)
+				{
+					jobject_put(peer_info, J_CSTR_TO_JVAL("peerIp"),
+					            jstring_create(service->ipinfo.ipv4.address));
+				}
+
+				jvalue_ref peer_list_j = jobject_create();
+				jobject_put(peer_list_j, J_CSTR_TO_JVAL("peerInfo"), peer_info);
+				jarray_append(peer_list, peer_list_j);
+			}
+		}
+
+		jobject_put(*status,  J_CSTR_TO_JVAL("connectedPeers"), peer_list);
+	}
+	else
+	{
+		jobject_put(*status, J_CSTR_TO_JVAL("state"), jstring_create("disconnected"));
+	}
+}
+
+/**
+ * @brief Append the current connection status to a supplied JSON object. The format
+ * matches the response format for the com.webos.service.connectionmanager/getstatus method.
+ *
+ * @param reply JSON object where we will append the connection status to.
+ */
+
+static void append_connection_status(jvalue_ref *reply, bool subscribed,
+                                     bool with_new_interface)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+	jobject_put(*reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	gboolean online = connman_manager_is_manager_online(manager);
+	jobject_put(*reply, J_CSTR_TO_JVAL("isInternetConnectionAvailable"),
+	            jboolean_create(online));
+	gboolean offlineMode = !connman_manager_is_manager_available(manager);
+	jobject_put(*reply, J_CSTR_TO_JVAL("offlineMode"),
+	            jstring_create(offlineMode ? "enabled" : "disabled"));
+
+	jvalue_ref connected_wired_status = jobject_create();
+	jvalue_ref disconnected_wired_status = jobject_create();
+	jvalue_ref connected_wifi_status = jobject_create();
+	jvalue_ref disconnected_wifi_status = jobject_create();
+	jvalue_ref connected_p2p_status = jobject_create();
+	jvalue_ref disconnected_p2p_status = jobject_create();
+
+	jobject_put(disconnected_wired_status, J_CSTR_TO_JVAL("state"),
+	            jstring_create("disconnected"));
+	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("state"),
+	            jstring_create("disconnected"));
+	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
+	            jboolean_create(is_wifi_tethering()));
+	jobject_put(disconnected_p2p_status, J_CSTR_TO_JVAL("state"),
+	            jstring_create("disconnected"));
+
+	/* get the service which is currently connecting or already in connected */
+	connman_service_t *connected_wired_service =
+	    connman_manager_get_connected_service(manager->wired_services);
+
+	if (NULL != connected_wired_service)
+	{
+		update_connection_status(connected_wired_service, &connected_wired_status);
+		jobject_put(connected_wired_status, J_CSTR_TO_JVAL("plugged"),
+		            jboolean_create(true));
+		jobject_put(*reply, J_CSTR_TO_JVAL("wired"), connected_wired_status);
+		j_release(&disconnected_wired_status);
+	}
+	else
+	{
+		jobject_put(disconnected_wired_status, J_CSTR_TO_JVAL("plugged"),
+		            jboolean_create(wired_plugged ? true : false));
+		jobject_put(*reply, J_CSTR_TO_JVAL("wired"), disconnected_wired_status);
+		j_release(&connected_wired_status);
+	}
+
+	connman_service_t *connected_wifi_service = NULL;
+
+	if (is_wifi_powered())
+	{
+		connected_wifi_service = connman_manager_get_connected_service(
+		                             manager->wifi_services);
+	}
+
+	if (NULL != connected_wifi_service)
+	{
+		update_connection_status(connected_wifi_service, &connected_wifi_status);
+
+		// When we're connected to a WiFi service we can't have tethering enabled
+		jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
+		            jboolean_create(false));
+
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifi"), connected_wifi_status);
+		j_release(&disconnected_wifi_status);
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifi"), disconnected_wifi_status);
+		j_release(&connected_wifi_status);
+	}
+
+	connman_service_t *connected_p2p_service = NULL;
+
+	if (is_wifi_powered())
+	{
+		connected_p2p_service = connman_manager_get_connected_service(
+		                            manager->p2p_services);
+	}
+
+	if (NULL != connected_p2p_service)
+	{
+		append_p2p_connection_status(&connected_p2p_status, connected_p2p_service);
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), connected_p2p_status);
+		j_release(&disconnected_p2p_status);
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), disconnected_p2p_status);
+		j_release(&connected_p2p_status);
+	}
+
+	if (with_new_interface)
+	{
+		jvalue_ref cellular_obj = jobject_create();
+		gboolean cellular_enabled = is_cellular_powered();
+
+		jobject_put(cellular_obj, J_CSTR_TO_JVAL("enabled"),
+		            jboolean_create(cellular_enabled));
+		jobject_put(*reply, J_CSTR_TO_JVAL("cellular"), cellular_obj);
+
+		jvalue_ref wan_obj = jobject_create();
+
+		if (cellular_enabled)
+		{
+			append_wan_status(wan_obj);
+		}
+		else
+		{
+			jvalue_ref connected_contexts_obj = jarray_create(NULL);
+			jobject_put(wan_obj, J_CSTR_TO_JVAL("connected"), jboolean_create(false));
+			jobject_put(wan_obj, J_CSTR_TO_JVAL("connectedContexts"),
+			            connected_contexts_obj);
+		}
+
+		jobject_put(*reply, J_CSTR_TO_JVAL("wan"), wan_obj);
+
+		jvalue_ref connected_pan_status = jobject_create();
+		jvalue_ref disconnected_pan_status = jobject_create();
+		jobject_put(disconnected_pan_status, J_CSTR_TO_JVAL("state"),
+		            jstring_create("disconnected"));
+		jobject_put(disconnected_pan_status, J_CSTR_TO_JVAL("tetheringEnabled"),
+		            jboolean_create(is_bluetooth_tethering()));
+
+		connman_service_t *connected_pan_service =
+		    connman_manager_get_connected_service(manager->bluetooth_services);
+
+		if (NULL != connected_pan_service)
+		{
+			append_nap_info(&connected_pan_status);
+			update_connection_status(connected_pan_service, &connected_pan_status);
+
+			// When we're connected to a PAN service we can't have tethering enabled
+			jobject_put(connected_pan_status, J_CSTR_TO_JVAL("tetheringEnabled"),
+			            jboolean_create(false));
+
+			jobject_put(*reply, J_CSTR_TO_JVAL("bluetooth"), connected_pan_status);
+			j_release(&disconnected_pan_status);
+		}
+		else
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("bluetooth"), disconnected_pan_status);
+			j_release(&connected_pan_status);
+		}
+
+	}
+}
+
+/**
+ * @brief Check wether a connman service object was updated. This depends on the currently
+ * implemented code inside the connman_service object which only sets the updated flag for
+ * a limited number of service properties (those which are relevant for a response of the
+ * com.webos.service.connectionmanager/getstatus method).
+ *
+ * @param service The connman service object to check
+ * @param technology_connected The current connections status of the technology the supplied
+ * service belongs to.
+ *
+ * @return TRUE if the service object was updated. FALSE otherwise.
+ */
+
+static gboolean check_service_for_update(connman_service_t *service,
+        gboolean tech_connected)
+{
+	gboolean needed = FALSE;
+
+	if ((service != NULL && !tech_connected) || (service == NULL && tech_connected))
+	{
+		needed = TRUE;
+	}
+
+	if (service != NULL &&
+	        connman_service_is_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS))
+	{
+		needed = TRUE;
+		/* mark service as unchanged to get notified about future updates */
+		connman_service_unset_changed(service,
+		                              CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+	}
+
+	/* In case of P2P service, a service will be treated as connected only
+	   if a group is present */
+	if (service != NULL && service->type == CONNMAN_SERVICE_TYPE_P2P)
+	{
+		if (!tech_connected && manager->groups == NULL)
+		{
+			needed = FALSE;
+		}
+	}
+
+	return needed;
+}
+
+/**
+ * @brief Check whether a update needs to be send for subscribers of the
+ * com.webos.service.connectionmanager/getstatus method.
+ *
+ * @return TRUE if a update needs to be send. FALSE otherwise.
+ */
+
+static gboolean check_update_is_needed(void)
+{
+	gboolean needed = FALSE;
+
+	if (!manager)
+	{
+		return FALSE;
+	}
+
+	if (old_wifi_tethering != is_wifi_tethering())
+	{
+		old_wifi_tethering = is_wifi_tethering();
+		needed = TRUE;
+	}
+
+	if (old_pan_tethering != is_bluetooth_tethering())
+	{
+		old_pan_tethering = is_bluetooth_tethering();
+		needed = TRUE;
+	}
+
+	gboolean old_online_status = online_status;
+
+	online_status = connman_manager_is_manager_online(manager);
+
+	if (old_online_status != online_status)
+	{
+		needed = TRUE;
+	}
+
+	connman_service_t *connected_wifi_service = NULL;
+
+	if (is_wifi_powered())
+	{
+		connected_wifi_service = connman_manager_get_connected_service(
+		                             manager->wifi_services);
+	}
+
+	if (check_service_for_update(connected_wifi_service, wifi_connected))
+	{
+		needed = TRUE;
+	}
+
+	wifi_connected = (connected_wifi_service != NULL);
+
+	connman_service_t *connected_wired_service =
+	    connman_manager_get_connected_service(manager->wired_services);
+
+	if (check_service_for_update(connected_wired_service, wired_connected))
+	{
+		needed = TRUE;
+	}
+
+	wired_connected = (connected_wired_service != NULL);
+
+	if (IS_WIRED_PLUGGED() != wired_plugged)
+	{
+		needed = TRUE;
+	}
+
+	wired_plugged = IS_WIRED_PLUGGED();
+
+	connman_service_t *connected_p2p_service = NULL;
+
+	if (is_wifi_powered())
+	{
+		connected_p2p_service = connman_manager_get_connected_service(
+		                            manager->p2p_services);
+	}
+
+	if (check_service_for_update(connected_p2p_service, p2p_connected))
+	{
+		needed = TRUE;
+	}
+
+	p2p_connected = (connected_p2p_service != NULL && manager->groups != NULL);
+
+	if (cellular_powered != is_cellular_powered())
+	{
+		cellular_powered = is_cellular_powered();
+		needed = TRUE;
+	}
+
+	connman_service_t *connected_pan_service =
+	    connman_manager_get_connected_service(manager->bluetooth_services);
+
+	if (check_service_for_update(connected_pan_service, pan_connected))
+	{
+		needed = TRUE;
+	}
+
+	pan_connected = (connected_pan_service != NULL);
+
+
+	GSList *iter;
+	guint num_connected = 0;
+
+	for (iter = manager->cellular_services; iter != NULL; iter = iter->next)
+	{
+		connman_service_t *service = iter->data;
+
+		if (!connman_service_is_connected(service))
+		{
+			continue;
+		}
+
+		num_connected++;
+
+		if (check_service_for_update(service, wan_connected || (num_connected > 0)))
+		{
+			needed = TRUE;
+		}
+	}
+
+	gboolean new_wan_connected = (num_connected > 0);
+
+	if (wan_connected != new_wan_connected)
+	{
+		needed = TRUE;
+	}
+
+	wan_connected = new_wan_connected;
+
+	WCALOG_INFO(MSGID_CONNECTION_INFO, 0, "needed: %d",needed);
+
+	return needed;
+}
+
+/**
+ *  @brief Callback function registered with connman manager whenever any of its properties changes.
+ */
+
+void connectionmanager_send_status_to_subscribers(void)
+{
+	bool wired_skip, wifi_skip = false;
+
+	if (manager == NULL)
+		return;
+
+	if (block_getstatus_response || !check_update_is_needed())
+	{
+		// Retrieve the connected service for wired to check the online checking status
+		connman_service_t *connected_wired_service =
+				connman_manager_get_connected_service(manager->wired_services);
+
+		// Retrieve the connected service for wifi to check the online checking sttaus
+		connman_service_t *connected_wifi_service =
+				connman_manager_get_connected_service(manager->wifi_services);
+
+		if (connected_wired_service)
+		{
+			// "block_getstatus_response" blocks connectionmanager/getstatus for 1 seconds
+			// While getstatus is blocked, "wired_skip" flag will be used to emit the
+			// getstatus response if online_checking status is modified.
+			if (connected_wired_service->online_checking == wired_online_checking_status)
+				wired_skip = true;
+			else
+			{
+				wired_online_checking_status = connected_wired_service->online_checking;
+				wired_skip = false;
+			}
+		}
+
+		if (connected_wifi_service)
+		{
+			// "block_getstatus_response" blocks connectionmanager/getstatus for 1 seconds
+			// While getstatus is blocked, "wired_skip" flag will be used to emit the
+			// getstatus response if online_checking status is modified.
+			if (connected_wifi_service->online_checking == wifi_online_checking_status)
+				wifi_skip = true;
+			else
+			{
+				wifi_online_checking_status = connected_wifi_service->online_checking;
+				wifi_skip = false;
+			}
+		}
+
+		// This routine affects when connected service for both wired and wifi exists.
+		if (connected_wired_service && connected_wifi_service)
+		{
+			/* If there is no change of online_checking status for both wired and wifi,
+			 * getstatus will not be emitted. If there is a change of online_checking status
+			 * for both wired and wifi, getstatus response will be emitted.
+			 */
+			if (wired_skip && wifi_skip)
+				return;
+		}
+		// This routine affects when connected service for only wifi exists.
+		else if (!connected_wired_service && connected_wifi_service)
+		{
+			if (wifi_skip)
+				return;
+		}
+		// This routine affects when connected service for only wired exists.
+		else if (connected_wired_service && !connected_wifi_service)
+		{
+			if (wired_skip)
+				return;
+		}
+	}
+
+	jvalue_ref reply = jobject_create();
+	jvalue_ref reply_deprecated = jobject_create();
+	append_connection_status(&reply, true, true);
+	// Same but without mentioning WAN and PAN as we don't support it on the
+	// com.webos.service.connectionmanager service face
+	append_connection_status(&reply_deprecated, true, false);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+		const char *payload_deprecated = jvalue_tostring(reply_deprecated,
+		                                 response_schema);
+
+		WCALOG_INFO(MSGID_CONNECTION_INFO, 0, "connectionmanager_send_status : %s",payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		// com.webos.service.connectionmanager/getstatus
+		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_GETSTATUS,
+		                        payload_deprecated, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		// com.webos.service.connectionmanager/getStatus
+		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_GETSTATUS2,
+		                        payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+	j_release(&reply_deprecated);
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+@{
+@section com_webos_connectionmanager_getstatus getstatus
+
+Gets the current status of network connections (wifi, wired and wifi direct) on the system.
+
+Callers of this method can subscribe to it so that they are notified whenever the
+network status changes.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subcribe | no | Boolean | Subscribe to this method
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+isInternetConnectionAvailable | Yes | Boolean | Indicates if any internet connection is available
+offlineMode | yes | String | "enabled" if manager is offline, "disabled" otherwise
+wired | yes | Object | State of wired connection (see below)
+wifi | yes | Object | State of wifi connection (see below)
+wifiDirect | yes | Object | State of wifi direct connection (see below)
+
+@par "wired" State Object
+
+Optional fields are only present if "state" is "connected".
+
+Name | Required | Type | Description
+-----|--------|------|----------
+state | yes | String | "connected" or "disconnected" to indicate status.
+interfaceName | no | String | Interface name in use (e.g. "eth0")
+ipAddress | no | String | IP address associated with the connection
+netmask | no | String | Net mask value for the connection
+gateway | no | String | IP address of network gateway
+dns<n> | no | String | List of IP Addreses of dns servers for this connection
+method | no | String | How the IP addressed was assigned (e.g. "Manual", "dhcp")
+onInternet | no | String | "yes" or "no" to indicate if the service is "online"
+
+@par "wifi" State Object
+
+Optional fields are only present if "state" is "connected".
+
+Name | Required | Type | Description
+-----|--------|------|----------
+state | yes | String | "connected" or "disconnected" to indicate status.
+interfaceName | no | String | Interface name in use (e.g. "eth0")
+ipAddress | no | String | IP address associated with the connection
+netmask | no | String | Net mask value for the connection
+gateway | no | String | IP address of network gateway
+dns<n> | no | String | List of IP Addreses of dns servers for this connection
+method | no | String | How the IP addressed was assigned (e.g. "Manual", "dhcp")
+ssid | no | String | SSID of the connected service (if known)
+isWakeOnWiFiEnabled | no | Boolean | True if "Wake on WIFI" is enabled
+onInternet | no | String | "yes" or "no" to indicate if the service is "online"
+
+@par "wifiDirect" State Object
+
+Optional fields are only present if "state" is "connected".
+
+Name | Required | Type | Description
+-----|--------|------|----------
+state | yes | String | "connected" or "disconnected"
+localIp | no | String | IP address of the local connection endpoint
+connectedPeers | no | Array | See "peer State Object".
+
+@par "peer" State Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+peerInfo | yes | Object | See "peerInfo State Object"
+
+@par "peerInfo" State Obejct
+
+Name | Required | Type | Description
+-----|--------|------|----------
+deviceName | yes | String | Name of the peer.
+deviceAddress | yes | String | Address of the peer.
+groupOwner | yes | Boolean | true, if the peer is the owner of the current active group. false otherwise
+configMethod | yes | Integer | Configuration methods supported by the peer.
+signalLevel | yes | Integer | Signal level of the peer.
+peerIp | no | String | IP address of the peer if it's currently connected to our group.
+
+@par Returns(Subscription)
+
+The subcription update contains the same information as the initial call.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_status_command(LSHandle *sh, LSMessage *message,
+                                      void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+	jschema_ref response_schema = NULL;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	// Adding the check for manager here, since we only want to error out in that case and not if manager is offline
+	if (NULL == manager)
+	{
+		if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+		{
+			goto cleanup;
+		}
+	}
+
+	append_connection_status(&reply, subscribed,
+	                         is_caller_using_new_interface(message));
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (!jis_null(reply))
+	{
+		j_release(&reply);
+	}
+
+	if (!jis_null(parsedObj))
+	{
+		j_release(&parsedObj);
+	}
+
+	return true;
+}
+
+/**
+ * @brief Loop through the manager's wifi services and match the one with the given ssid.
+ * If 'ssid' is NULL then return the wired service on the system
+ *
+ * @param ssid SSID of the service object we're searching for. If NULL we will return the
+ * first available wired network service.
+ * @return Connman service object or NULL in case of a failure.
+ */
+
+static connman_service_t *retrieve_service_by_ssid(gchar *ssid)
+{
+	if (NULL != ssid)
+	{
+		GSList *ap;
+
+		/* Look up for the service with the given ssid */
+		for (ap = manager->wifi_services; ap; ap = ap->next)
+		{
+			connman_service_t *service = (connman_service_t *)(ap->data);
+
+			if (!g_strcmp0(service->name, ssid))
+			{
+				return service;
+			}
+		}
+	}
+	else
+	{
+		/* Return the first wired service (there will be just one on most systems) */
+		GSList *ap = manager->wired_services;
+
+		if (ap != NULL)
+		{
+			return (connman_service_t *) ap->data;
+		}
+	}
+
+	return NULL;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+@{
+@section com_webos_connectionmanager_setipv4 setipv4
+
+Modify the parameters of an IPv4 connection (wired or WIFI)
+
+If an SSID field is not provided in the request, the modifications are
+applied to the wired connection.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+"method" | yes | String | "dhcp", "manual" or "off"
+"address" | no | String | If specified, sets a new IP address (only when method is "manual")
+"netmask" | no | String | If specified, sets a new netmask (only when method is "manual")
+"gateway" | no | String | If specified, sets a new gateway IP address (only when method is "manual")
+"ssid" | no | String | Select the wifi connection to modify. If absent, the wired connection is changed.
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True, when operation was successfull. False otherwise.
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
+                                    void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(method, string), PROP(address,
+	                                     string),
+	                                     PROP(netmask, string), PROP(gateway, string), PROP(ssid,
+	                                             string)) REQUIRED_1(method))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0}, methodObj = {0}, addressObj = {0}, netmaskObj = {0},
+	           gatewayObj = {0};
+	ipv4info_t ipv4 = {0};
+	gchar *ssid = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
+	{
+		raw_buffer method_buf = jstring_get(methodObj);
+		ipv4.method = g_strdup(method_buf.m_str);
+		jstring_free_buffer(method_buf);
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		ipv4.address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!is_valid_ipaddress(ipv4.address))
+		{
+			goto invalid_params;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("netmask"), &netmaskObj))
+	{
+		raw_buffer netmask_buf = jstring_get(netmaskObj);
+		ipv4.netmask = g_strdup(netmask_buf.m_str);
+		jstring_free_buffer(netmask_buf);
+
+		if (!is_valid_ipaddress(ipv4.netmask))
+		{
+			goto invalid_params;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("gateway"), &gatewayObj))
+	{
+		raw_buffer gateway_buf = jstring_get(gatewayObj);
+		ipv4.gateway = g_strdup(gateway_buf.m_str);
+		jstring_free_buffer(gateway_buf);
+
+		if (!is_valid_ipaddress(ipv4.gateway))
+		{
+			goto invalid_params;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+	}
+
+	connman_service_t *service = retrieve_service_by_ssid(ssid);
+
+	if (NULL != service)
+	{
+		if (connman_service_set_ipv4(service, &ipv4))
+		{
+			LSMessageReplySuccess(sh, message);
+		}
+		else
+		{
+			LSMessageReplyErrorUnknown(sh, message);
+		}
+	}
+	else
+	{
+		if (ssid)
+		{
+			wifi_profile_t *profile = get_profile_by_ssid(ssid);
+
+			if (profile && profile->configured)
+			{
+				if (!g_strcmp0(ipv4.method, "manual"))
+				{
+					if (ipv4.address == NULL || ipv4.netmask == NULL || ipv4.gateway == NULL)
+						LSMessageReplyCustomError(sh, message,
+						                          "Address, netmask as well as gateway should be specified for out of range networks",
+						                          WCA_API_ERROR_INVALID_PARAMETERS);
+					else if (change_network_ipv4(profile->ssid, profile->security[0], ipv4.address,
+					                             ipv4.netmask, ipv4.gateway))
+					{
+						LSMessageReplySuccess(sh, message);
+					}
+					else
+					{
+						LSMessageReplyErrorUnknown(sh, message);
+					}
+				}
+				else if (!g_strcmp0(ipv4.method, "dhcp"))
+				{
+					if (change_network_remove_entry(profile->ssid, profile->security[0], "IPv4"))
+					{
+						LSMessageReplySuccess(sh, message);
+					}
+					else
+					{
+						LSMessageReplyErrorUnknown(sh, message);
+					}
+				}
+				else
+				{
+					goto invalid_params;
+				}
+
+				goto exit;
+			}
+		}
+
+		LSMessageReplyCustomError(sh, message, "Network not found",
+		                          WCA_API_ERROR_NETWORK_NOT_FOUND);
+	}
+
+	goto exit;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+exit:
+	g_free(ipv4.method);
+	g_free(ipv4.address);
+	g_free(ipv4.netmask);
+	g_free(ipv4.gateway);
+	g_free(ssid);
+	j_release(&parsedObj);
+	return true;
+}
+
+static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
+                                    void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(method, string), PROP(address,
+	                                     string),
+	                                     PROP(prefixLength, integer), PROP(gateway, string), PROP(ssid,
+	                                             string)) REQUIRED_1(method))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0}, methodObj = {0}, addressObj = {0}, prefixLengthObj = {0},
+	           gatewayObj = {0};
+	ipv6info_t ipv6 = {0};
+	gchar *ssid = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
+	{
+		raw_buffer method_buf = jstring_get(methodObj);
+		ipv6.method = g_strdup(method_buf.m_str);
+		jstring_free_buffer(method_buf);
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		ipv6.address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!is_valid_ipv6address(ipv6.address))
+		{
+			goto invalid_params;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("prefixLength"),
+	                       &prefixLengthObj))
+	{
+		int prefixLength_val = 0;
+		jnumber_get_i32(prefixLengthObj, &prefixLength_val);
+		ipv6.prefix_length = prefixLength_val;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("gateway"), &gatewayObj))
+	{
+		raw_buffer gateway_buf = jstring_get(gatewayObj);
+		ipv6.gateway = g_strdup(gateway_buf.m_str);
+		jstring_free_buffer(gateway_buf);
+
+		if (!is_valid_ipv6address(ipv6.gateway))
+		{
+			goto invalid_params;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+	}
+
+	connman_service_t *service = retrieve_service_by_ssid(ssid);
+
+	if (NULL != service)
+	{
+		if (connman_service_set_ipv6(service, &ipv6))
+		{
+			LSMessageReplySuccess(sh, message);
+		}
+		else
+		{
+			LSMessageReplyErrorUnknown(sh, message);
+		}
+	}
+	else
+	{
+		if (ssid)
+		{
+			wifi_profile_t *profile = get_profile_by_ssid(ssid);
+
+			if (profile && profile->configured)
+			{
+				if (!g_strcmp0(ipv6.method, "manual"))
+				{
+					if (ipv6.address == NULL || ipv6.prefix_length == NULL || ipv6.gateway == NULL)
+						LSMessageReplyCustomError(sh, message,
+						                          "Address, prefix length as well as gateway should be specified for out of range networks",
+						                          WCA_API_ERROR_INVALID_PARAMETERS);
+					else if (change_network_ipv6(profile->ssid, profile->security[0], ipv6.address,
+					                             ipv6.prefix_length, ipv6.gateway))
+					{
+						LSMessageReplySuccess(sh, message);
+					}
+					else
+					{
+						LSMessageReplyErrorUnknown(sh, message);
+					}
+				}
+				else if (!g_strcmp0(ipv6.method, "dhcp"))
+				{
+					if (change_network_remove_entry(profile->ssid, profile->security[0], "IPv6"))
+					{
+						LSMessageReplySuccess(sh, message);
+					}
+					else
+					{
+						LSMessageReplyErrorUnknown(sh, message);
+					}
+				}
+				else
+				{
+					goto invalid_params;
+				}
+
+				goto exit;
+			}
+		}
+
+		LSMessageReplyCustomError(sh, message, "Network not found",
+		                          WCA_API_ERROR_NETWORK_NOT_FOUND);
+	}
+
+	goto exit;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+
+exit:
+	g_free(ipv6.method);
+	g_free(ipv6.address);
+	g_free(ipv6.gateway);
+	g_free(ssid);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+@{
+@section com_webos_connectionmanager_setdns setdns
+
+Change the DNS servers for the network.
+
+If an SSID field is not provided in the request, the modifications are
+applied to the wired connection.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+dns | yes | Array of String | Each string provides the IP address of a dns server
+ssid | no | String | SSID of wifi connection to be modified.
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True, when configuration has sucessfully applied. False otherwise.
+
+@par Returns(Subscription)
+
+Not applicable
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
+                                   void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(ARRAY(dns, string), PROP(ssid,
+	                                     string)) REQUIRED_1(dns))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0}, dnsObj = {0};
+	GStrv dns = NULL;
+	gchar *ssid = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dns"), &dnsObj))
+	{
+		int i, dns_arrsize = jarray_size(dnsObj);
+		dns = (GStrv) g_new0(GStrv, dns_arrsize + 1);
+
+		for (i = 0; i < dns_arrsize; i++)
+		{
+			raw_buffer dns_buf = jstring_get(jarray_get(dnsObj, i));
+			dns[i] = g_strdup(dns_buf.m_str);
+			jstring_free_buffer(dns_buf);
+
+			if (!(is_valid_ipaddress(dns[i]) || is_valid_ipv6address(dns[i])))
+			{
+				goto invalid_params;
+			}
+		}
+
+		dns[dns_arrsize] = NULL;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+	}
+
+	connman_service_t *service = retrieve_service_by_ssid(ssid);
+
+	if (NULL != service)
+	{
+		if (connman_service_set_nameservers(service, dns))
+		{
+			LSMessageReplySuccess(sh, message);
+		}
+		else
+		{
+			LSMessageReplyErrorUnknown(sh, message);
+		}
+	}
+	else
+	{
+		if (ssid)
+		{
+			wifi_profile_t *profile = get_profile_by_ssid(ssid);
+
+			if (profile && profile->configured)
+			{
+				if (change_network_dns(profile->ssid, profile->security[0], dns))
+				{
+					LSMessageReplySuccess(sh, message);
+				}
+				else
+				{
+					LSMessageReplyErrorUnknown(sh, message);
+				}
+
+				goto exit;
+			}
+		}
+
+		LSMessageReplyCustomError(sh, message, "No connected network",
+		                          WCA_API_ERROR_NO_CONNECTED_NW);
+	}
+
+	goto exit;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+exit:
+	g_strfreev(dns);
+	g_free(ssid);
+	j_release(&parsedObj);
+	return true;
+}
+
+/**
+ *  @brief Returns true if ethernet technology is powered on
+ *
+ *  @return TRUE if the the ethernet technology is powered. FALSE otherwise.
+ */
+
+static gboolean is_ethernet_powered(void)
+{
+	connman_technology_t *technology = connman_manager_find_ethernet_technology(
+	                                       manager);
+
+	if (NULL != technology)
+	{
+		return technology->powered;
+	}
+
+	return FALSE;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+@{
+@section com_webos_connectionmanager_setstate setstate
+
+Enable or disable the state of either or both wifi and wired technologies on the system
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+wifi | no | String | "enabled" or "disabled" to set status accordingly
+wired | no | String | "enabled" or "disabled" to set status accordingly
+offlineMode | no | String | "enabled" or "disabled" to set status accordingly
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not Applicable
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	// Adding the check for manager here, since we only want to error out in that case and not if manager is offline
+	if (NULL == manager)
+	{
+		if (!connman_status_check(manager, sh, message))
+		{
+			return true;
+		}
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_3(PROP(wifi, string), PROP(wired, string),
+	                                     PROP(offlineMode, string)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref wifiObj = {0}, wiredObj = {0}, offlineModeObj = {0};
+	gboolean enable_wifi = FALSE, enable_wired = FALSE, enable_offline = FALSE;
+	gboolean invalidArg = TRUE;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("offlineMode"),
+	                       &offlineModeObj))
+	{
+		if (jstring_equal2(offlineModeObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_offline = TRUE;
+		}
+		else if (jstring_equal2(offlineModeObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_offline = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		gboolean offline = !connman_manager_is_manager_available(manager);
+
+		if (enable_offline == offline)
+		{
+			WCALOG_DEBUG("Offline mode already set to the desired value");
+		}
+		else
+		{
+			if (enable_offline && is_wifi_tethering())
+			{
+				set_wifi_tethering(!enable_offline);
+			}
+
+			connman_manager_set_offlinemode(manager, enable_offline);
+		}
+
+		invalidArg = FALSE;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wifi"), &wifiObj))
+	{
+		if (jstring_equal2(wifiObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_wifi = TRUE;
+		}
+		else if (jstring_equal2(wifiObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_wifi = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		/* Check if we are enabling an already enabled service,
+		 * or disabling an already disabled service */
+		if ((enable_wifi && is_wifi_powered()) || (!enable_wifi && !is_wifi_powered()))
+		{
+			WCALOG_DEBUG("Wifi technology already enabled/disabled");
+		}
+		else
+		{
+			set_wifi_powered_status(enable_wifi);
+		}
+
+		invalidArg = FALSE;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wired"), &wiredObj))
+	{
+		if (jstring_equal2(wiredObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_wired = TRUE;
+		}
+		else if (jstring_equal2(wiredObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_wired = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		/* Check if we are enabling an already enabled service,
+		 * or disabling an already disabled service */
+		if ((enable_wired && is_ethernet_powered()) || (!enable_wired &&
+		        !is_ethernet_powered()))
+		{
+			WCALOG_DEBUG("Wired technology already enabled/disabled");
+		}
+		else
+		{
+			connman_technology_t *technology = connman_manager_find_ethernet_technology(
+			                                       manager);
+
+			if (NULL != technology)
+			{
+				connman_technology_set_powered(technology, enable_wired, NULL);
+			}
+		}
+
+		invalidArg = FALSE;
+	}
+
+	if (invalidArg == TRUE)
+	{
+		goto invalid_params;
+	}
+
+	LSMessageReplySuccess(sh, message);
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+
+}
+
+static void getinfo_add_response(jvalue_ref* reply, bool subscribed)
+{
+	jobject_put(*reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+	jobject_put(*reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	if (getinfo_cur_wifi_mac_address[0])
+	{
+		jvalue_ref wifi_info = jobject_create();
+		jobject_put(wifi_info,
+		            J_CSTR_TO_JVAL("macAddress"),
+		            jstring_create(getinfo_cur_wifi_mac_address));
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifiInfo"), wifi_info);
+	}
+
+	if (getinfo_cur_wired_mac_address[0])
+	{
+		jvalue_ref wired_info = jobject_create();
+		jobject_put(wired_info,
+		            J_CSTR_TO_JVAL("macAddress"),
+		            jstring_create(getinfo_cur_wired_mac_address));
+		jobject_put(*reply, J_CSTR_TO_JVAL("wiredInfo"), wired_info);
+	}
+}
+
+void send_getinfo_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	getinfo_update();
+	getinfo_add_response(&reply, true);
+
+	const char *payload = jvalue_tostring(reply, jschema_all());
+	LSError lserror;
+	LSErrorInit(&lserror);
+	if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_GETINFO, payload, &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+}
+
+/**
+ * Update mac address and send response to subscribers (if any).
+
+ * Note that this method is called both on timer and
+ * standalone, with subscribers and without.
+ */
+static void getinfo_update(void)
+{
+	WCALOG_INFO(MSGID_CM_GET_MAC_INFO, 0, "Updating Wi-Fi & Wired mac info");
+
+	char wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
+	char wired_mac_address[MAC_ADDR_STRING_LEN]={0};
+
+	if (retrieve_wifi_mac_address(wifi_mac_address, MAC_ADDR_STRING_LEN))
+	{
+		if (g_strcmp0(getinfo_cur_wifi_mac_address, wifi_mac_address))
+		{
+			g_strlcpy(getinfo_cur_wifi_mac_address, wifi_mac_address, MAC_ADDR_STRING_LEN);
+		}
+	}
+	else
+	{
+		/** Mark as invalid */
+		if (getinfo_cur_wifi_mac_address[0])
+		{
+			getinfo_cur_wifi_mac_address[0] = 0;
+		}
+
+		WCALOG_ERROR(MSGID_WIFI_MAC_ADDR_ERROR,0,"Error in fetching mac address for wifi interface");
+	}
+
+	if (retrieve_wired_mac_address(wired_mac_address, MAC_ADDR_STRING_LEN))
+	{
+		if (g_strcmp0(getinfo_cur_wired_mac_address, wired_mac_address))
+		{
+			g_strlcpy(getinfo_cur_wired_mac_address, wired_mac_address, MAC_ADDR_STRING_LEN);
+		}
+	}
+	else
+	{
+		/** Mark as invalid */
+		if (getinfo_cur_wired_mac_address[0])
+		{
+			getinfo_cur_wired_mac_address[0] = 0;
+		}
+
+		WCALOG_ERROR(MSGID_WIRED_MAC_ADDR_ERROR,0,"Error in fetching mac address for wired interface");
+	}
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+@{
+@section com_webos_connectionmanager_getinfo getinfo
+
+Lists information about the wifi and wired network interfaces.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subcribe to changes
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+subscribed | yes | Boolean | True when successfully subscribed. False not subscribed or subscription was not possible.
+wiredInfo | no | Object | Object containing information for the current wired connection.
+wifiInfo | no | Object | Object containing information for the current wifi connection.
+
+@par Information Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+macAddress | yes | String | MAC address of the controller for the connection
+
+@par Returns(Subscription)
+
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_info_command(LSHandle *sh, LSMessage *message,
+                                    void *context)
+{
+	UNUSED(context);
+
+	bool subscribed = false;
+	jvalue_ref reply;
+	LSError lserror;
+	LSErrorInit(&lserror);
+	jvalue_ref parsedObj;
+
+	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+		return true;
+
+	reply = jobject_create();
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	getinfo_add_response(&reply, subscribed);
+	LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()), &lserror);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	j_release(&parsedObj);
+	return true;
+}
+
+/* Blocking getstatus response for 1 sec for getting internet status*/
+#define INTERNET_STATUS_TIMEOUT 1
+
+/**
+ * @brief Callback called after the delay set for getting internet status
+ * for connected services. We have to make sure we send out a new status
+ * regardless if anything has changed or not. Some of our users already
+ * rely on this behaviour so we can't change it (see settings app).
+ */
+static gboolean send_updated_internet_status(gpointer data)
+{
+	block_getstatus_response = 0;
+	return FALSE;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_connectionmanager com.webos.connectionmanager
+@{
+@section com_webos_connectionmanager_checkinternetstatus checkinternetstatus
+
+Triggers online check for all connected interfaces.
+
+@par Parameters
+
+None
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_check_internet_status_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	gboolean wired_status = TRUE, wifi_status = TRUE;
+
+	if (block_getstatus_response)
+	{
+		goto exit;
+	}
+
+	if (!connman_status_check(manager, sh, message))
+		return true;
+
+	connman_service_t *connected_wired_service =
+	    connman_manager_get_connected_service(manager->wired_services);
+
+	if (connected_wired_service)
+	{
+		wired_status = connman_service_set_run_online_check(connected_wired_service,
+		               TRUE);
+	}
+
+	connman_service_t *connected_wifi_service =
+	    connman_manager_get_connected_service(manager->wifi_services);
+
+	if (connected_wifi_service)
+	{
+		wifi_status = connman_service_set_run_online_check(connected_wifi_service,
+		              TRUE);
+	}
+
+	WCALOG_INFO(MSGID_CM_ONLINE_CHECK_INFO, 0, "internet check for connected wired service : %p, wifi service : %p",
+		    connected_wired_service, connected_wifi_service);
+
+	if (!connected_wired_service && !connected_wifi_service)
+	{
+		goto exit;
+	}
+
+	if (wired_status == TRUE || wifi_status == TRUE)
+	{
+		block_getstatus_response = g_timeout_add_seconds(INTERNET_STATUS_TIMEOUT,
+		                           send_updated_internet_status, NULL);
+	}
+
+	if (!wired_status && !wifi_status)
+		LSMessageReplyCustomError(sh, message,
+		                          "Error in checking online status for both wired and wifi interfaces",
+		                          WCA_API_ERROR_WIRED_WIFI_ONLINE);
+	else if (!wired_status)
+		LSMessageReplyCustomError(sh, message,
+		                          "Error in checking online status for wired interface",
+		                          WCA_API_ERROR_WIRED_ONLINE);
+	else if (!wifi_status)
+		LSMessageReplyCustomError(sh, message,
+		                          "Error in checking online status for wifi interface",
+		                          WCA_API_ERROR_WIFI_ONLINE);
+	else
+	{
+		goto exit;
+	}
+
+	goto cleanup;
+
+exit:
+	LSMessageReplySuccess(sh, message);
+
+cleanup:
+	return true;
+}
+
+/**
+ *  @brief Callback function registered with connman technology whenever any of its properties change
+ *
+ *  @param data User context data
+ *  @param property Name of the property which has changed
+ *  @param value Value of the changed property
+ */
+
+static void technology_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	connman_technology_t *technology = (connman_technology_t *)data;
+
+	if (NULL == technology)
+	{
+		return;
+	}
+
+	/* Need to send getstatus method to all com.webos.service.connectionmanager subscribers whenever the
+	   "powered" or "connected" state of the technology changes */
+
+	if (!g_strcmp0(property, "Powered") || !g_strcmp0(property, "Connected"))
+	{
+		if (manager) {
+			connman_service_t *connected_wifi_service = connman_manager_get_connected_service(manager->wifi_services);
+			if (connected_wifi_service)
+				connman_service_set_run_online_check(connected_wifi_service, TRUE);
+		}
+		connectionmanager_send_status_to_subscribers();
+	}
+}
+
+static void increment_counter_statistics(connman_service_t *service,
+        GVariant *home)
+{
+	connman_counter_data_t counter_data;
+
+	int service_state = connman_service_get_state(service->state);
+
+	if (!(service_state == CONNMAN_SERVICE_STATE_ONLINE ||
+	        service_state == CONNMAN_SERVICE_STATE_READY))
+	{
+		return;
+	}
+
+	connman_service_types type = service->type;
+
+	connman_counter_parse_counter_data(home, &counter_data);
+
+	counter_data_new[type].rx_bytes += counter_data.rx_bytes;
+	counter_data_new[type].tx_bytes += counter_data.tx_bytes;
+	counter_data_new[type].rx_packet += counter_data.rx_packet;
+	counter_data_new[type].tx_packet += counter_data.tx_packet;
+	counter_data_new[type].rx_errors += counter_data.rx_errors;
+	counter_data_new[type].tx_errors += counter_data.tx_errors;
+	counter_data_new[type].rx_dropped += counter_data.rx_dropped;
+	counter_data_new[type].tx_dropped += counter_data.tx_dropped;
+}
+
+static void counter_usage_callback(const gchar *path, GVariant *home,
+                                   GVariant *roaming, gpointer user_data)
+{
+	if (!g_variant_is_container(home))
+	{
+		return;
+	}
+
+	connman_service_t *service = connman_manager_find_service_by_path(
+	                                 manager->wired_services, path);
+
+	if (NULL == service)
+	{
+		service = connman_manager_find_service_by_path(manager->wifi_services, path);
+
+		if (NULL == service)
+		{
+			service = connman_manager_find_service_by_path(manager->cellular_services,
+			          path);
+		}
+	}
+
+	if (NULL == service)
+	{
+		return;
+	}
+
+	increment_counter_statistics(service, home);
+}
+
+static void counter_registered_callback(gpointer user_data)
+{
+	gchar *counter_path;
+
+	counter_path = connman_counter_get_path(counter);
+
+	if (!connman_manager_register_counter(manager, counter_path, COUNTER_ACCURACY,
+	                                      COUNTER_PERIOD))
+	{
+		WCALOG_CRITICAL(MSGID_WIFI_COUNTER_ERROR, 0,
+		                "Could not register our counter instance with connman; functionality will be limited!");
+		return;
+	}
+
+	memset(counter_data_old, 0, sizeof(counter_data_old));
+	memset(counter_data_new, 0, sizeof(counter_data_new));
+
+	connman_counter_set_usage_callback(counter, counter_usage_callback, NULL);
+
+}
+
+#define CALCULATE_DIFFERENCE(name) (counter_data_new[type].name? abs(counter_data_new[type].name - counter_data_old[type].name): 0)
+
+static void append_interface_data_activity(jvalue_ref *interface_stats,
+        connman_service_types type)
+{
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("rxPackets"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(rx_packet)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("rxBytes"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(rx_bytes)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("rxErrors"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(rx_errors)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("rxDropped"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(rx_dropped)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("txPackets"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(tx_packet)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("txBytes"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(tx_bytes)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("txErrors"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(tx_errors)));
+	jobject_put(*interface_stats, J_CSTR_TO_JVAL("txDropped"),
+	            jnumber_create_i32(CALCULATE_DIFFERENCE(rx_dropped)));
+}
+
+static void append_data_activity(jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(*reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+	jobject_put(*reply, J_CSTR_TO_JVAL("sampleInterval"),
+	            jnumber_create_i32(counter->timer->interval * 1000));
+
+	jvalue_ref wired_stats = jobject_create();
+	jvalue_ref wifi_stats = jobject_create();
+
+	append_interface_data_activity(&wired_stats, CONNMAN_SERVICE_TYPE_ETHERNET);
+	append_interface_data_activity(&wifi_stats, CONNMAN_SERVICE_TYPE_WIFI);
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("wired"), wired_stats);
+	jobject_put(*reply, J_CSTR_TO_JVAL("wifi"), wifi_stats);
+
+	jvalue_ref wan_stats = jobject_create();
+	append_interface_data_activity(&wan_stats, CONNMAN_SERVICE_TYPE_CELLULAR);
+	jobject_put(*reply, J_CSTR_TO_JVAL("wan"), wan_stats);
+
+	memcpy(counter_data_old, counter_data_new, sizeof(counter_data_old));
+	memset(counter_data_new, 0, sizeof(counter_data_new));
+}
+
+
+static void disable_counter(void)
+{
+	gchar *counter_path;
+
+	counter_path = connman_counter_get_path(counter);
+
+	if (!connman_manager_unregister_counter(manager, counter_path))
+	{
+		connman_counter_set_registered_callback(counter, NULL, NULL);
+		connman_counter_free(counter);
+		counter = NULL;
+	}
+
+	connman_counter_set_registered_callback(counter, NULL, NULL);
+	connman_counter_free(counter);
+	counter = NULL;
+
+}
+
+static gboolean notify_counter_statistics(void)
+{
+	if (counter->timer->timeout == 0)
+	{
+		return FALSE;
+	}
+
+	if (LSSubscriptionGetHandleSubscribersCount(pLsHandle,
+	        LUNA_CATEGORY_ROOT LUNA_METHOD_MONITORACTIVITY) == 0)
+	{
+		disable_counter();
+		return FALSE;
+	}
+
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	append_data_activity(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+		WCALOG_DEBUG("Sending payload %s", payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_MONITORACTIVITY, payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+
+static bool handle_monitor_activity_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	bool subscribed = false;
+	LSError lserror;
+	LSErrorInit(&lserror);
+	jvalue_ref reply = jobject_create();
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+		if (!connman_manager_is_manager_available(manager))
+		{
+			jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(false));
+			jobject_put(reply, J_CSTR_TO_JVAL("errorText"),
+			            jstring_create("Connman manager is not available"));
+			goto response;
+		}
+	}
+	else
+	{
+		LSMessageReplyCustomError(sh, message, "Subscription is mandatory for this API",
+		                          WCA_API_ERROR_SUBSCRIPTION_REQD);
+		goto cleanup;
+	}
+
+	if (NULL == counter)
+	{
+		counter = connman_counter_new(notify_counter_statistics);
+
+		if (NULL == counter)
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting counter",
+			                          WCA_API_ERROR_COUNTER);
+			goto cleanup;
+		}
+
+		connman_counter_set_registered_callback(counter, counter_registered_callback,
+		                                        NULL);
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+response:
+	{
+		jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+		                              DOMOPT_NOOPT, NULL);
+
+		if (!response_schema)
+		{
+			LSMessageReplyErrorUnknown(sh, message);
+			goto cleanup;
+		}
+
+		if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+		                    &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+cleanup:
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+static bool handle_set_technology_state_command(LSHandle *sh,
+        LSMessage *message, void *user_data)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsed_obj = 0;
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(ARRAY(enabled, string), ARRAY(disabled,
+	                                     string)))), &parsed_obj))
+	{
+		return true;
+	}
+
+	jvalue_ref enabled_obj = 0;
+	jvalue_ref disabled_obj = 0;
+	bool enabled_set = false;
+	bool disabled_set = false;
+	LSError lserror;
+	LSErrorInit(&lserror);
+	unsigned int n;
+	bool success = TRUE;
+	bool not_supported = FALSE;
+
+	enabled_set = jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("enabled"),
+	                                 &enabled_obj);
+	disabled_set = jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("disabled"),
+	                                  &disabled_obj);
+
+	if (!enabled_set && !disabled_set)
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		return true;
+	}
+
+	for (n = 0; n < jarray_size(enabled_obj); n++)
+	{
+		jvalue_ref tech_obj = jarray_get(enabled_obj, n);
+
+		raw_buffer name_buf = jstring_get(tech_obj);
+		char *tech_name = g_strdup(name_buf.m_str);
+		jstring_free_buffer(name_buf);
+
+		connman_technology_t *tech = connman_manager_find_technology_by_name(manager,
+		                             tech_name);
+		g_free(tech_name);
+
+		if (!tech)
+		{
+			success &= FALSE;
+			continue;
+		}
+
+		if (tech->powered)
+		{
+			continue;
+		}
+
+		success &= connman_technology_set_powered(tech, TRUE, &not_supported);
+	}
+
+	for (n = 0; n < jarray_size(disabled_obj); n++)
+	{
+		jvalue_ref tech_obj = jarray_get(disabled_obj, n);
+
+		raw_buffer name_buf = jstring_get(tech_obj);
+		char *tech_name = g_strdup(name_buf.m_str);
+		jstring_free_buffer(name_buf);
+
+		connman_technology_t *tech = connman_manager_find_technology_by_name(manager,
+		                             tech_name);
+		g_free(tech_name);
+
+		if (!tech)
+		{
+			success &= FALSE;
+			continue;
+		}
+
+		if (!tech->powered)
+		{
+			continue;
+		}
+
+		success &= connman_technology_set_powered(tech, FALSE, &not_supported);
+	}
+
+	jvalue_ref reply_obj = jobject_create();
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(success));
+
+	if (!success)
+	{
+		const char* error_string;
+		int error_no;
+
+		if (not_supported)
+		{
+			error_no = WCA_API_ERROR_SET_TECHNOLOGY_STATE_NOT_SUPPORTED;
+			error_string = "Setting technology state of one or more technologies not supported";
+		}
+		else
+		{
+			error_no = WCA_API_ERROR_FAILED_TO_ENABLE_DISABLE_TECHNOLOGIES;
+			error_string = "Failed to enable/disable one or more technologies";
+		}
+
+		jobject_put(reply_obj,
+		            J_CSTR_TO_JVAL("errorCode"),
+		            jnumber_create_i32(error_no));
+		jobject_put(reply_obj,
+		            J_CSTR_TO_JVAL("errorText"),
+		            jstring_create(error_string));
+	}
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (!jis_null(parsed_obj))
+	{
+		j_release(&parsed_obj);
+	}
+
+	if (!jis_null(reply_obj))
+	{
+		j_release(&reply_obj);
+	}
+
+	return true;
+}
+
+static bool handle_set_ethernet_tethering_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!ethernet_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsed_obj = 0;
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(state,
+	                                     string))  REQUIRED_1(state))), &parsed_obj))
+	{
+		return true;
+	}
+
+	jvalue_ref state_obj = 0;
+	gboolean enable_tethering = FALSE;
+
+	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("state"), &state_obj))
+	{
+		if (jstring_equal2(state_obj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_tethering = TRUE;
+		}
+		else if (jstring_equal2(state_obj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_tethering = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		if (enable_tethering && is_ethernet_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Ethernet tethering already enabled",
+			                          WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_ENABLED);
+			goto cleanup;
+		}
+		else if (!enable_tethering && !is_ethernet_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Ethernet tethering already disabled",
+			                          WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_DISABLED);
+			goto cleanup;
+		}
+
+		if (!set_ethernet_tethering_state(enable_tethering))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting ethernet tethering",
+			                          WCA_API_ERROR_ETHERNET_TETHERING_SET);
+			goto cleanup;
+		}
+
+		LSMessageReplySuccess(sh, message);
+		goto cleanup;
+	}
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+
+cleanup:
+
+	if (!jis_null(parsed_obj))
+	{
+		j_release(&parsed_obj);
+	}
+
+	return true;
+}
+
+static bool handle_set_proxy_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(method, string), PROP(url,
+	                                     string), ARRAY(servers, string), ARRAY(excludes, string), PROP(ssid, string)) REQUIRED_1(method))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0}, methodObj = {0}, urlObj = {0}, serversObj = {0}, excludesObj = {0};
+	proxyinfo_t proxyinfo = {0};
+	gchar *ssid = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
+	{
+		raw_buffer method_buf = jstring_get(methodObj);
+		proxyinfo.method = g_strdup(method_buf.m_str);
+		jstring_free_buffer(method_buf);
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("url"), &urlObj))
+	{
+		raw_buffer url_buf = jstring_get(urlObj);
+		proxyinfo.url = g_strdup(url_buf.m_str);
+		jstring_free_buffer(url_buf);
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("servers"), &serversObj))
+	{
+		int i, servers_arrsize = jarray_size(serversObj);
+		proxyinfo.servers = (GStrv) g_new0(GStrv, servers_arrsize + 1);
+
+		for (i = 0; i < servers_arrsize; i++)
+		{
+			raw_buffer servers_buf = jstring_get(jarray_get(serversObj, i));
+			proxyinfo.servers[i] = g_strdup(servers_buf.m_str);
+			jstring_free_buffer(servers_buf);
+		}
+
+		proxyinfo.servers[servers_arrsize] = NULL;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("excludes"), &excludesObj))
+	{
+		int i, excludes_arrsize = jarray_size(excludesObj);
+		proxyinfo.excludes = (GStrv) g_new0(GStrv, excludes_arrsize + 1);
+
+		for (i = 0; i < excludes_arrsize; i++)
+		{
+			raw_buffer excludes_buf = jstring_get(jarray_get(excludesObj, i));
+			proxyinfo.excludes[i] = g_strdup(excludes_buf.m_str);
+			jstring_free_buffer(excludes_buf);
+		}
+
+		proxyinfo.excludes[excludes_arrsize] = NULL;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+	}
+
+	if (!g_strcmp0(proxyinfo.method, "manual"))
+	{
+		if (NULL == proxyinfo.servers)
+			goto invalid_params;
+	}
+
+	connman_service_t *service = retrieve_service_by_ssid(ssid);
+
+	if (NULL != service)
+	{
+		if (connman_service_set_proxy(service, &proxyinfo))
+		{
+			LSMessageReplySuccess(sh, message);
+		}
+		else
+		{
+			LSMessageReplyErrorUnknown(sh, message);
+		}
+	}
+	else
+	{
+		LSMessageReplyCustomError(sh, message, "No connected network",
+		                          WCA_API_ERROR_NO_CONNECTED_NW);
+	}
+
+	goto exit;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+exit:
+	g_free(proxyinfo.method);
+	g_free(proxyinfo.url);
+	g_strfreev(proxyinfo.servers);
+	g_strfreev(proxyinfo.excludes);
+	g_free(ssid);
+	j_release(&parsedObj);
+	return true;
+}
+
+static bool handle_find_proxy_for_url_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(url, string), PROP(host,
+	                                     string)) REQUIRED_2(url,host))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	jvalue_ref urlObj = {0}, hostObj = {0};
+	gchar *url = NULL, *host = NULL, *proxy = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("url"), &urlObj))
+	{
+		raw_buffer url_buf = jstring_get(urlObj);
+		url = g_strdup(url_buf.m_str);
+		jstring_free_buffer(url_buf);
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("host"), &hostObj))
+	{
+		raw_buffer host_buf = jstring_get(hostObj);
+		host = g_strdup(host_buf.m_str);
+		jstring_free_buffer(host_buf);
+	}
+
+	pacrunner_client_t *client = pacrunner_client_new();
+
+	proxy = pacrunner_client_find_proxy_for_url(client, url, host);
+	if (NULL != proxy)
+	{
+		jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+		jobject_put(reply, J_CSTR_TO_JVAL("proxy"), jstring_create(proxy));
+
+		jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+		                              DOMOPT_NOOPT, NULL);
+
+		if (!response_schema)
+		{
+			LSMessageReplyErrorUnknown(sh, message);
+			goto cleanup;
+		}
+
+		if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+		                    &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+		goto cleanup;
+	}
+
+	LSMessageReplyCustomError(sh, message, "Error in finding proxy for url",
+									WCA_API_ERROR_PROXY_FIND_PROXY_FOR_URL_ERROR);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(url);
+	g_free(host);
+	g_free(proxy);
+	pacrunner_client_free(client);
+	j_release(&reply);
+	return true;
+}
+
+/**
+ * @brief com.webos.service.connectionmanager service method table
+ */
+
+static LSMethod connectionmanager_methods[] =
+{
+	{ LUNA_METHOD_GETSTATUS,            handle_get_status_command },
+	{ LUNA_METHOD_GETSTATUS2,           handle_get_status_command },
+	{ LUNA_METHOD_SETIPV4,              handle_set_ipv4_command },
+	{ LUNA_METHOD_SETDNS,               handle_set_dns_command },
+	{ LUNA_METHOD_SETSTATE,             handle_set_state_command },
+	{ LUNA_METHOD_GETINFO,              handle_get_info_command },
+	{ LUNA_METHOD_SETIPV6,              handle_set_ipv6_command },
+	{ LUNA_METHOD_MONITORACTIVITY,      handle_monitor_activity_command },
+	{ LUNA_METHOD_SETTECHNOLOGYSTATE,   handle_set_technology_state_command },
+	{ LUNA_METHOD_SETETHERNETTETHERING, handle_set_ethernet_tethering_command },
+	{ LUNA_METHOD_SETPROXY,             handle_set_proxy_command },
+	{ LUNA_METHOD_FINDPROXYFORURL,      handle_find_proxy_for_url_command },
+	{ },
+};
+
+/**
+ *  @brief Initialize the com.webos.service.connectionmanager service and register all provided
+ *  service method on the luna service bus.
+ *
+ *  @param mainloop Reference to the used glib mainloop object
+ *  @return 0 if service is initialized successfull. -1 otherwise.
+ */
+
+int initialize_connectionmanager_ls2_calls(GMainLoop *mainloop,
+        LSHandle **cm_handle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	pLsHandle = NULL;
+
+	if (!mainloop)
+	{
+		goto exit;
+	}
+
+	if (!LSRegister(CONNECTIONMANAGER_LUNA_SERVICE_NAME, &pLsHandle, &lserror))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_CM_LUNA_BUS_ERROR, lserror.message);
+		goto exit;
+	}
+
+	if (!LSRegisterCategory(pLsHandle, LUNA_CATEGORY_ROOT,
+	                        connectionmanager_methods,
+	                        NULL, NULL, &lserror))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_CM_METHODS_LUNA_ERROR, lserror.message);
+		goto exit;
+	}
+
+	if (!LSGmainAttach(pLsHandle, mainloop, &lserror))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_CM_GLOOP_ATTACH_ERROR, lserror.message);
+		goto exit;
+	}
+
+	*cm_handle = pLsHandle;
+
+	return 0;
+
+exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	if (pLsHandle)
+	{
+		LSErrorInit(&lserror);
+
+		if (!LSUnregister(pLsHandle, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	return -1;
+}
diff --git a/src/connectionmanager_service.h b/src/connectionmanager_service.h
new file mode 100644
index 0000000..da204ad
--- /dev/null
+++ b/src/connectionmanager_service.h
@@ -0,0 +1,62 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connectionmanager_service.h
+ *
+ */
+
+#ifndef _CONNECTIONMANAGER_SERVICE_H_
+#define _CONNECTIONMANAGER_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define CONNECTIONMANAGER_LUNA_SERVICE_NAME "com.webos.service.connectionmanager"
+
+#define LUNA_CATEGORY_ROOT                 "/"
+
+/**
+ * @name Luna Connectionmanager Method Names
+ * @{
+ */
+#define LUNA_METHOD_GETSTATUS             "getstatus"
+#define LUNA_METHOD_GETSTATUS2            "getStatus"
+#define LUNA_METHOD_SETIPV4               "setipv4"
+#define LUNA_METHOD_SETIPV6               "setipv6"
+#define LUNA_METHOD_SETDNS                "setdns"
+#define LUNA_METHOD_SETSTATE              "setstate"
+#define LUNA_METHOD_GETINFO               "getinfo"
+#define LUNA_METHOD_SETWOLWOWLSTATUS      "setwolwowlstatus"
+#define LUNA_METHOD_GETWOLWOWLSTATUS      "getwolwowlstatus"
+#define LUNA_METHOD_MONITORACTIVITY       "monitorActivity"
+#define LUNA_METHOD_SETTECHNOLOGYSTATE    "setTechnologyState"
+#define LUNA_METHOD_SETETHERNETTETHERING  "setEthernetTethering"
+#define LUNA_METHOD_SETPROXY              "setProxy"
+#define LUNA_METHOD_FINDPROXYFORURL       "findProxyForURL"
+
+enum ipadress_type
+{
+	IPADDRESS_TYPE_UNKNOWN = 0,
+	IPADDRESS_TYPE_IPV4 = 1,
+	IPADDRESS_TYPE_IPV6 = 2,
+};
+
+extern void connectionmanager_send_status_to_subscribers(void);
+extern int initialize_connectionmanager_ls2_calls(GMainLoop *mainloop,
+        LSHandle **cm_handle);
+extern void send_getinfo_to_subscribers(void);
+
+#endif /* _CONNECTIONMANAGER_SERVICE_H_ */
diff --git a/src/connman_agent.c b/src/connman_agent.c
new file mode 100644
index 0000000..240f295
--- /dev/null
+++ b/src/connman_agent.c
@@ -0,0 +1,254 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_agent.c
+ *
+ * @brief connman_agent implements a wrapper around the dbus net.connman.Agent interface
+ * which is used to communicate with the connman daemon in situations where input from the
+ * user (like entering a authentication password) is required.
+ */
+
+#include <string.h>
+
+#include "connman_agent.h"
+#include "logging.h"
+
+#define AGENT_DBUS_PATH         "/"
+#define AGENT_ERROR_CANCELED    "net.connman.Agent.Error.Canceled"
+
+struct connman_agent
+{
+	ConnmanInterfaceAgent *interface;
+	gchar *path;
+	connman_agent_registered_cb registered_cb;
+	gpointer registered_data;
+	connman_agent_request_input_cb request_input_cb;
+	gpointer request_input_data;
+	connman_agent_report_error_cb report_error_cb;
+	gpointer report_error_data;
+	guint bus_id;
+};
+
+static gboolean request_input_cb(ConnmanInterfaceAgent *interface,
+                                 GDBusMethodInvocation *invocation,
+                                 const gchar *path,
+                                 GVariant *fields,
+                                 gpointer user_data)
+{
+	connman_agent_t *agent = user_data;
+	GVariant *response = NULL;
+
+	if (agent->request_input_cb == NULL)
+	{
+		g_dbus_method_invocation_return_dbus_error(invocation, AGENT_ERROR_CANCELED,
+		        "No handler available");
+	}
+	else
+	{
+		response = agent->request_input_cb(fields, agent->request_input_data);
+		connman_interface_agent_complete_request_input(agent->interface, invocation,
+		        response);
+	}
+
+	return TRUE;
+}
+
+static gboolean report_error_cb(ConnmanInterfaceAgent *interface,
+                                GDBusMethodInvocation *invocation,
+                                const char *path,
+                                const char *error_message,
+                                gpointer user_data)
+{
+	connman_agent_t *agent = user_data;
+
+	if (agent->report_error_cb == NULL)
+	{
+		g_dbus_method_invocation_return_dbus_error(invocation, AGENT_ERROR_CANCELED,
+		        "No handler available");
+	}
+	else
+	{
+		agent->report_error_cb(error_message, agent->report_error_data);
+	}
+
+	return TRUE;
+}
+
+static void bus_acquired_cb(GDBusConnection *connection, const gchar *name,
+                            gpointer user_data)
+{
+	GError *error = NULL;
+	connman_agent_t *agent = user_data;
+
+	agent->path = g_strdup(AGENT_DBUS_PATH);
+	agent->interface = connman_interface_agent_skeleton_new();
+
+	g_signal_connect(agent->interface, "handle-request-input",
+	                 G_CALLBACK(request_input_cb), agent);
+	g_signal_connect(agent->interface, "handle-report-error",
+	                 G_CALLBACK(report_error_cb), agent);
+
+	error = NULL;
+
+	if (!g_dbus_interface_skeleton_export(G_DBUS_INTERFACE_SKELETON(
+	        agent->interface), connection,
+	                                      agent->path, &error))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_AGENT_INIT_ERROR, error->message);
+		g_error_free(error);
+	}
+
+	if (agent->registered_cb != NULL)
+	{
+		agent->registered_cb(agent->registered_data);
+	}
+
+	WCALOG_DEBUG("Agent successfully exported");
+}
+
+/**
+ * @brief Create a new agent instance. Currently connman is limited to only support one
+ * agent at the same time so it's only usefull to create one agent object. Creating more
+ * than one will not work (the registration of the agent will simply fail). When the agent
+ * object should not be used anymore it needs to be freed with the connman_agent_free
+ * method.
+ *
+ * @return New agent object.
+ */
+
+connman_agent_t *connman_agent_new(void)
+{
+	connman_agent_t *agent;
+
+	agent = g_new0(connman_agent_t, 1);
+
+	if (agent == NULL)
+	{
+		return NULL;
+	}
+
+	agent->bus_id = g_bus_own_name(G_BUS_TYPE_SYSTEM, "com.webos.service.wifi",
+	                               G_BUS_NAME_OWNER_FLAGS_NONE,
+	                               bus_acquired_cb, NULL, NULL, agent, NULL);
+
+	return agent;
+}
+
+/**
+ * @brief Free previously created agent object.
+ *
+ * @param agent Agent object which was created with connman_agent_new before.
+ */
+
+void connman_agent_free(connman_agent_t *agent)
+{
+	if (agent == NULL)
+	{
+		return;
+	}
+
+	g_bus_unown_name(agent->bus_id);
+
+	g_free(agent->path);
+
+	if (agent->interface)
+	{
+		g_object_unref(agent->interface);
+	}
+
+	g_free(agent);
+}
+
+/**
+ * @brief Return the dbus path the agent object is registered on. The memory the return
+ * string points to is still owned by the agent object.
+ *
+ * @param agent Agent object
+ */
+
+gchar *connman_agent_get_path(connman_agent_t *agent)
+{
+	if (agent == NULL)
+	{
+		return NULL;
+	}
+
+	return agent->path;
+}
+
+/**
+ * @brief Register a callback function for an agent object which is called once the agent
+ * is successfully registered with the connman daemon.
+ *
+ * @param agent Agent object
+ * @param cb Callback function
+ * @param user_data User data which is passed to the callback once its called.
+ */
+
+void connman_agent_set_registered_callback(connman_agent_t *agent,
+        connman_agent_registered_cb cb, gpointer user_data)
+{
+	if (agent == NULL)
+	{
+		return;
+	}
+
+	agent->registered_cb = cb;
+	agent->registered_data = user_data;
+}
+
+/**
+ * @brief Register a callback function for an agent object which is called once the agent
+ * receives and input request from the connman daemon.
+ *
+ * @param agent Agent object
+ * @param cb Callback function
+ * @param user_data User data which is passed to the callback once its called.
+ */
+
+void connman_agent_set_request_input_callback(connman_agent_t *agent,
+        connman_agent_request_input_cb cb, gpointer user_data)
+{
+	if (agent == NULL)
+	{
+		return;
+	}
+
+	agent->request_input_cb = cb;
+	agent->request_input_data = user_data;
+}
+
+/**
+ * @brief Register a callback function for an agent object which is called once the
+ * connman reports an error to the agent.
+ *
+ * @param agent Agent object
+ * @param cb Callback function
+ * @param user_data User data which is passed to the callback once its called.
+ */
+
+void connman_agent_set_report_error_callback(connman_agent_t *agent,
+        connman_agent_report_error_cb cb, gpointer user_data)
+{
+	if (agent == NULL)
+	{
+		return;
+	}
+
+	agent->report_error_cb = cb;
+	agent->report_error_data = user_data;
+}
diff --git a/src/connman_agent.h b/src/connman_agent.h
new file mode 100644
index 0000000..fab961d
--- /dev/null
+++ b/src/connman_agent.h
@@ -0,0 +1,49 @@
+/* @@@LICENSE
+*
+*      Copyright (c) 2012 Simon Busch <morphis@gravedo.de>
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* LICENSE@@@ */
+
+
+/**
+ * @file  connman_agent.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman agent
+ */
+
+#ifndef CONNMAN_AGENT_H_
+#define CONNMAN_AGENT_H_
+
+#include "connman_common.h"
+
+typedef struct connman_agent connman_agent_t;
+
+typedef GVariant *(*connman_agent_request_input_cb)(GVariant *fields,
+        gpointer user_data);
+typedef void (*connman_agent_report_error_cb)(const char *error_message,
+        gpointer user_data);
+typedef void (*connman_agent_registered_cb)(gpointer user_data);
+
+connman_agent_t *connman_agent_new(void);
+void connman_agent_free(connman_agent_t *agent);
+gchar *connman_agent_get_path(connman_agent_t *agent);
+void connman_agent_set_registered_callback(connman_agent_t *agent,
+        connman_agent_registered_cb cb, gpointer user_data);
+void connman_agent_set_request_input_callback(connman_agent_t *agent,
+        connman_agent_request_input_cb cb, gpointer user_data);
+void connman_agent_set_report_error_cb(connman_agent_t *agent,
+                                       connman_agent_report_error_cb cb, gpointer user_data);
+
+#endif
diff --git a/src/connman_common.h.in b/src/connman_common.h.in
new file mode 100644
index 0000000..42ac7c8
--- /dev/null
+++ b/src/connman_common.h.in
@@ -0,0 +1,42 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+
+#ifndef _CONNMAN_COMMON_H_
+#define _CONNMAN_COMMON_H_
+
+#include <gio/gio.h>
+#include <glib-object.h>
+
+#include "connman-interface.h"
+
+#define CONNMAN_WIFI_INTERFACE_NAME     "@WIFI_IFACE_NAME@"
+#define CONNMAN_WIRED_INTERFACE_NAME    "@WIRED_IFACE_NAME@"
+
+#define CONNMAN_SAVED_PROFILE_CONFIG_DIR	"@CONNMAN_CONFIG_DIR@"
+
+typedef enum {
+	CONNMAN_WFD_DEV_TYPE_SOURCE         = 0,
+	CONNMAN_WFD_DEV_TYPE_PRIMARY_SINK   = 1,
+	CONNMAN_WFD_DEV_TYPE_SECONDARY_SINK = 2,
+	CONNMAN_WFD_DEV_TYPE_DUAL           = 3,
+}connman_wfd_dev_type;
+
+typedef void (*connman_common_cb)(gpointer);
+typedef void (*connman_property_changed_cb)(gpointer , const gchar *, GVariant *);
+
+#endif /* _CONNMAN_COMMON_H_ */
+
diff --git a/src/connman_counter.c b/src/connman_counter.c
new file mode 100644
index 0000000..bb4587b
--- /dev/null
+++ b/src/connman_counter.c
@@ -0,0 +1,228 @@
+// Copyright (c) 2015-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_counter.c
+ *
+ * @brief Connman counter interface
+ * @brief connman_counter implements a wrapper around the dbus net.connman.Counter interface
+ */
+
+#include <string.h>
+
+#include "connman_counter.h"
+#include "logging.h"
+
+#define COUNTER_DBUS_PATH           "/"
+
+void connman_counter_parse_counter_data(GVariant *variant,
+                                        connman_counter_data_t *data)
+{
+	GVariantIter iter;
+	gchar *key;
+	GVariant *value;
+
+	if (!variant || !data)
+	{
+		return;
+	}
+
+	g_variant_iter_init(&iter, variant);
+
+	while (g_variant_iter_next(&iter, "{sv}", &key, &value))
+	{
+		if (g_strcmp0(key, "RX.Packets") == 0)
+		{
+			data->rx_packet = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "TX.Packets") == 0)
+		{
+			data->tx_packet = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "RX.Bytes") == 0)
+		{
+			data->rx_bytes = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "TX.Bytes") == 0)
+		{
+			data->tx_bytes = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "RX.Errors") == 0)
+		{
+			data->rx_errors = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "TX.Errors") == 0)
+		{
+			data->tx_errors = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "RX.Dropped") == 0)
+		{
+			data->rx_dropped = g_variant_get_uint32(value);
+		}
+		else if (g_strcmp0(key, "TX.Dropped") == 0)
+		{
+			data->tx_dropped = g_variant_get_uint32(value);
+		}
+
+		g_variant_unref(value);
+		g_free(key);
+	}
+}
+
+static gboolean usage_cb(ConnmanInterfaceAgent *interface,
+                         GDBusMethodInvocation *invocation,
+                         const gchar *path,
+                         GVariant *home,
+                         GVariant *roaming,
+                         gpointer user_data)
+{
+	connman_counter_t *counter = user_data;
+
+	if (NULL != counter && NULL != counter->usage_cb)
+	{
+		counter->usage_cb(path, home, roaming, counter->usage_data);
+	}
+
+	g_object_unref(invocation);
+	return TRUE;
+}
+
+static gboolean release_cb(ConnmanInterfaceAgent *interface,
+                           GDBusMethodInvocation *invocation,
+                           gpointer user_data)
+{
+	g_object_unref(invocation);
+	return TRUE;
+}
+
+static void bus_acquired_cb(GDBusConnection *connection, const gchar *name,
+                            gpointer user_data)
+{
+	GError *error = NULL;
+	connman_counter_t *counter = user_data;
+
+	counter->path = g_strdup(COUNTER_DBUS_PATH);
+	counter->interface = connman_interface_counter_skeleton_new();
+
+	g_signal_connect(counter->interface, "handle-usage", G_CALLBACK(usage_cb),
+	                 counter);
+	g_signal_connect(counter->interface, "handle-release", G_CALLBACK(release_cb),
+	                 counter);
+
+	error = NULL;
+
+	if (!g_dbus_interface_skeleton_export(G_DBUS_INTERFACE_SKELETON(
+	        counter->interface), connection,
+	                                      counter->path, &error))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_COUNTER_INIT_ERROR, error->message);
+		g_error_free(error);
+	}
+
+	if (counter->registered_cb != NULL)
+	{
+		counter->registered_cb(counter->registered_data);
+	}
+
+	WCALOG_INFO(MSGID_COUNTER_EXPORT_SUCCESS, 0, "Counter successfully exported");
+}
+
+connman_counter_t *connman_counter_new(GSourceFunc _counter_usage_send_func)
+{
+	connman_counter_t *counter;
+
+	counter = g_new0(connman_counter_t, 1);
+
+	if (counter == NULL)
+	{
+		return NULL;
+	}
+
+	counter->bus_id = g_bus_own_name(G_BUS_TYPE_SYSTEM,
+	                                 "com.webos.service.connectionmanager", G_BUS_NAME_OWNER_FLAGS_NONE,
+	                                 bus_acquired_cb, NULL, NULL, counter, NULL);
+
+	WCALOG_INFO(MSGID_CM_DATA_ACTIVITY, 0, "Initialize of the data usage timer.");
+	counter->timer = g_new(struct data_usage_timer_params, 1);
+	counter->timer->interval = 1;
+	counter->timer->timeout  = g_timeout_add_seconds(counter->timer->interval,
+	                           _counter_usage_send_func, NULL);
+
+	return counter;
+}
+
+void connman_counter_free(connman_counter_t *counter)
+{
+	if (counter == NULL)
+	{
+		return;
+	}
+
+	g_bus_unown_name(counter->bus_id);
+
+	if (counter->timer)
+	{
+		if (counter->timer->timeout > 0)
+		{
+			g_source_remove(counter->timer->timeout);
+		}
+
+		g_free(counter->timer);
+	}
+
+	g_free(counter->path);
+
+	if (counter->interface)
+	{
+		g_object_unref(counter->interface);
+	}
+
+	g_free(counter);
+}
+
+gchar *connman_counter_get_path(connman_counter_t *counter)
+{
+	if (counter == NULL)
+	{
+		return NULL;
+	}
+
+	return counter->path;
+}
+
+void connman_counter_set_registered_callback(connman_counter_t *counter,
+        connman_counter_registered_cb cb, gpointer user_data)
+{
+	if (counter == NULL)
+	{
+		return;
+	}
+
+	counter->registered_cb = cb;
+	counter->registered_data = user_data;
+}
+
+void connman_counter_set_usage_callback(connman_counter_t *counter,
+                                        connman_counter_usage_cb cb, gpointer user_data)
+{
+	if (counter == NULL)
+	{
+		return;
+	}
+
+	counter->usage_cb = cb;
+	counter->usage_data = user_data;
+}
diff --git a/src/connman_counter.h b/src/connman_counter.h
new file mode 100644
index 0000000..9f8f0c5
--- /dev/null
+++ b/src/connman_counter.h
@@ -0,0 +1,72 @@
+// Copyright (c) 2015-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connman_counter.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman counter
+ */
+
+#ifndef CONNMAN_COUNTER_H_
+#define CONNMAN_COUNTER_H_
+
+#include "connman_common.h"
+
+typedef void (*connman_counter_usage_cb)(const gchar *path, GVariant *home,
+        GVariant *roaming, gpointer user_data);
+typedef void (*connman_counter_registered_cb)(gpointer user_data);
+
+struct data_usage_timer_params
+{
+	int interval;
+	unsigned int timeout;
+};
+
+typedef struct connman_counter
+{
+	ConnmanInterfaceCounter *interface;
+	gchar *path;
+	connman_counter_registered_cb registered_cb;
+	gpointer registered_data;
+	connman_counter_usage_cb usage_cb;
+	gpointer usage_data;
+	guint bus_id;
+	struct data_usage_timer_params *timer;
+} connman_counter_t;
+
+typedef struct connman_counter_data
+{
+	guint rx_packet;
+	guint tx_packet;
+	guint rx_bytes;
+	guint tx_bytes;
+	guint rx_errors;
+	guint tx_errors;
+	guint tx_dropped;
+	guint rx_dropped;
+} connman_counter_data_t;
+
+void connman_counter_parse_counter_data(GVariant *variant,
+                                        connman_counter_data_t *data);
+connman_counter_t *connman_counter_new(GSourceFunc counter_usage_send_func);
+void connman_counter_free(connman_counter_t *counter);
+gchar *connman_counter_get_path(connman_counter_t *counter);
+void connman_counter_set_registered_callback(connman_counter_t *counter,
+        connman_counter_registered_cb cb, gpointer user_data);
+void connman_counter_set_usage_callback(connman_counter_t *counter,
+                                        connman_counter_usage_cb cb, gpointer user_data);
+
+#endif
diff --git a/src/connman_group.c b/src/connman_group.c
new file mode 100644
index 0000000..92cf9d6
--- /dev/null
+++ b/src/connman_group.c
@@ -0,0 +1,374 @@
+// Copyright (c) 2013-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_group.c
+ *
+ * @brief Connman group interface
+ *
+ */
+
+#include "connman_group.h"
+#include "connman_manager.h"
+#include "logging.h"
+#include "common.h"
+
+/**
+ * @brief Set the group's tethering property
+ *
+ * @param group Group object to operate on
+ * @param enable TRUE to enable tethering or FALSE to disable it
+ * @return TRUE if operation was successfull. FALSE otherwise.
+ */
+
+gboolean connman_group_set_tethering(connman_group_t *group, gboolean enable)
+{
+	if (NULL == group)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_group_call_set_property_sync(group->remote,
+	        "Tethering",
+	        g_variant_new_variant(g_variant_new_boolean(enable)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_SET_PROPERTY_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	group->tethering = enable;
+	return TRUE;
+}
+
+/**
+ * @brief Disconnect from a connman group
+ *
+ * @param group Group object to operate on
+ * @return TRUE if operation was successfull. FALSE otherwise.
+ */
+
+gboolean connman_group_disconnect(connman_group_t *group)
+{
+	if (NULL == group)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_group_call_disconnect_sync(group->remote, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_DISCONNECT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * @brief Invite a peer to join the specified group
+ *
+ * @param group Group to which the specified peer should be invited
+ * @param service Connman service object of the peer which should be invited.
+ * @return TRUE if operation was successfull. FALSE otherwise.
+ */
+
+gboolean connman_group_invite_peer(connman_group_t *group,
+                                   connman_service_t *service)
+{
+	if (NULL == group || NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_group_call_invite_sync(group->remote, service->path, NULL,
+	        &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_INVITE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * @brief Update a single property specified by it's key with a new value and clear
+ * the old one
+ *
+ * @param group Group to which the specified peer should be invited
+ * @param name Name of the property which was updated
+ * @param val Value of the updated property.
+ */
+
+static void __connman_group_update_property(connman_group_t *group,
+        const gchar *name, GVariant *val)
+{
+	if (!g_strcmp0(name, "Name"))
+	{
+		g_free(group->name);
+		group->name = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(name, "Passphrase"))
+	{
+		g_free(group->passphrase);
+		group->passphrase = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(name, "OwnerPath"))
+	{
+		g_free(group->group_owner);
+		group->group_owner = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(name, "Owner"))
+	{
+		group->is_group_owner = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(name, "Persistent"))
+	{
+		group->is_persistent = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(name, "Tethering"))
+	{
+		group->tethering = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(name, "Freq"))
+	{
+		group->freq = g_variant_get_uint32(val);
+	}
+	else if (!g_strcmp0(name, "LocalAddress"))
+	{
+		g_free(group->local_address);
+		group->local_address = g_variant_dup_string(val, NULL);
+	}
+}
+
+/**
+ * @brief Fetch the local address of the supplied group object.
+ *
+ * @param group Group to which the specified peer should be invited
+ * @return TRUE if operation was successfull. FALSE otherwise.
+ */
+
+gboolean connman_group_get_local_address(connman_group_t *group)
+{
+	if (NULL == group)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *properties;
+	gsize i;
+
+	connman_interface_group_call_get_properties_sync(group->remote, &properties,
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_GET_PROPERTIES_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		GVariant *val_v = g_variant_get_child_value(property, 1);
+		GVariant *val = g_variant_get_variant(val_v);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (!g_strcmp0(key, "LocalAddress"))
+		{
+			__connman_group_update_property(group, key, val);
+		}
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+		g_variant_unref(val_v);
+		g_variant_unref(val);
+	}
+
+	g_variant_unref(properties);
+	return TRUE;
+}
+
+static void property_changed_cb(ConnmanInterfaceTechnology *proxy,
+                                const gchar *property,
+                                GVariant *v, connman_group_t *group)
+{
+	GVariant *va = g_variant_get_child_value(v, 0);
+	__connman_group_update_property(group, property, va);
+
+	if (connman_update_callbacks->group_property_changed)
+	{
+		connman_update_callbacks->group_property_changed(group->path, property, va);
+	}
+
+	if (NULL != group->handle_property_change_fn)
+	{
+		(group->handle_property_change_fn)((gpointer) group, property, v);
+	}
+
+	if (NULL != manager->handle_groups_change_fn)
+	{
+		(manager->handle_groups_change_fn)((gpointer)manager, FALSE);
+	}
+
+	g_variant_unref(va);
+}
+
+/**
+ * @brief Register for group's "properties_changed" signal, calling the provided function
+ * whenever the callback function for the signal is called (see header for API details)
+ *
+ * @param group Group object the handler should be registered for
+ * @param func The handler function.
+ */
+
+void connman_group_register_property_changed_cb(connman_group_t *group,
+        connman_property_changed_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	group->handle_property_change_fn = func;
+}
+
+/**
+ * Create a new group instance and set its properties (see header for API details)
+ */
+
+/**
+ * @brief Create a new group instance and set its properties (see header for API details)
+ *
+ * @param variant Initial set of properties to initialize the group object with
+ * @return The new created group object
+ */
+
+connman_group_t *connman_group_new(GVariant *variant)
+{
+	if (NULL == variant)
+	{
+		return NULL;
+	}
+
+	connman_group_t *group = g_new0(connman_group_t, 1);
+
+	if (group == NULL)
+	{
+		return NULL;
+	}
+
+	GVariant *group_v = g_variant_get_child_value(variant, 0);
+	GVariant *properties;
+	gsize i;
+	GError *error = NULL;
+
+	group->path = g_variant_dup_string(group_v, NULL);
+
+	group->remote = connman_interface_group_proxy_new_for_bus_sync(
+	                    G_BUS_TYPE_SYSTEM,
+	                    G_DBUS_PROXY_FLAGS_NONE, "net.connman",
+	                    group->path, NULL, &error);
+	g_variant_unref(group_v);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_INIT_ERROR, error->message);
+		g_error_free(error);
+		g_free(group);
+		return NULL;
+	}
+
+	group->sighandler_id = g_signal_connect_data(G_OBJECT(group->remote),
+	                       "property-changed",
+	                       G_CALLBACK(property_changed_cb), group, NULL, 0);
+
+	properties = g_variant_get_child_value(variant, 1);
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		GVariant *val_v = g_variant_get_child_value(property, 1);
+		GVariant *val = g_variant_get_variant(val_v);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		__connman_group_update_property(group, key, val);
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+		g_variant_unref(val_v);
+		g_variant_unref(val);
+	}
+
+	g_variant_unref(properties);
+
+	return group;
+}
+
+/**
+ * @brief Free the group instance ( see header for API details)
+ *
+ * @param data Pointer to the group object to free
+ * @param user_data User context data
+ */
+
+void connman_group_free(gpointer data, gpointer user_data)
+{
+	connman_group_t *group = (connman_group_t *)data;
+
+	if (NULL == group)
+	{
+		return;
+	}
+
+	g_free(group->path);
+	g_free(group->name);
+	g_free(group->passphrase);
+	g_free(group->group_owner);
+	g_free(group->local_address);
+
+	if (group->sighandler_id)
+	{
+		g_signal_handler_disconnect(G_OBJECT(group->remote), group->sighandler_id);
+	}
+
+	group->handle_property_change_fn = NULL;
+	g_slist_free(group->peer_list);
+
+	g_object_unref(group->remote);
+
+	g_free(group);
+	group = NULL;
+
+}
diff --git a/src/connman_group.h b/src/connman_group.h
new file mode 100644
index 0000000..1a25216
--- /dev/null
+++ b/src/connman_group.h
@@ -0,0 +1,68 @@
+// Copyright (c) 2013-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connman_group.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman groups
+ *
+ */
+
+
+#ifndef CONNMAN_GROUP_H_
+#define CONNMAN_GROUP_H_
+
+#include <gio/gio.h>
+#include <glib-object.h>
+
+#include "connman_common.h"
+#include "connman_service.h"
+
+/**
+ * Local instance of a connman group
+ * Caches all required information for a group
+ */
+typedef struct connman_group
+{
+	ConnmanInterfaceGroup *remote;
+	gchar *path;
+	gchar *name;
+	gchar *passphrase;
+	gchar *group_owner;
+	gchar *local_address;
+	gboolean is_group_owner;
+	gboolean is_persistent;
+	gboolean tethering;
+	gint freq;
+	GSList *peer_list;
+	gulong sighandler_id;
+	connman_property_changed_cb     handle_property_change_fn;
+} connman_group_t;
+
+extern gboolean connman_group_set_tethering(connman_group_t *group,
+        gboolean state);
+extern gboolean connman_group_disconnect(connman_group_t *group);
+extern gboolean connman_group_invite_peer(connman_group_t *group,
+        connman_service_t *service);
+extern gboolean connman_group_get_local_address(connman_group_t *group);
+
+extern void connman_group_register_property_changed_cb(connman_group_t *group,
+        connman_property_changed_cb func);
+extern connman_group_t *connman_group_new(GVariant *variant);
+extern void connman_group_free(gpointer data, gpointer user_data);
+
+#endif /* CONNMAN_GROUP_H_ */
+
diff --git a/src/connman_manager.c b/src/connman_manager.c
new file mode 100644
index 0000000..c31095b
--- /dev/null
+++ b/src/connman_manager.c
@@ -0,0 +1,1995 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_manager.c
+ *
+ * @brief Connman manager interface
+ *
+ */
+
+#include "connman_manager.h"
+#include "logging.h"
+#include "connectionmanager_service.h"
+#include "utils.h"
+
+
+wca_support_connman_update_callbacks *connman_update_callbacks = { { NULL } };
+
+/**
+ * Retrieve all the properties of the given manager instance
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return A GVariant pointer containing manager properties, NULL if
+ *         the call to get properties fails
+ */
+
+GVariant *connman_manager_get_properties(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GError *error = NULL;
+	GVariant *ret;
+
+	connman_interface_manager_call_get_properties_sync(manager->remote,
+	        &ret, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_GET_PROPERTIES_ERROR, error->message);
+		g_error_free(error);
+		return NULL;
+	}
+
+	return ret;
+}
+
+/**
+ * Get the service in the manager's list matching the path.
+ *
+ * @param[IN]  manager A connman manager instance
+ * @param[IN]  path A path string to find.
+ * @param[IN]  saved A gboolean indicating if this is a saved network
+ *
+ * @return A service with the path matching the one in path, NULL if
+ *         no such service found
+ */
+
+static connman_service_t *find_service_from_path(connman_manager_t *manager,
+                                          const gchar* path,
+                                          gboolean saved)
+{
+	if (NULL == manager || NULL == path)
+	{
+		return NULL;
+	}
+
+	connman_service_t *service = NULL;
+
+	if (saved == TRUE)
+	{
+		service = connman_manager_find_service_by_path(manager->saved_services, path);
+	}
+	else
+	{
+		service = connman_manager_find_service_by_path(manager->wifi_services, path);
+
+		if (NULL != service)
+		{
+			return service;
+		}
+
+		service = connman_manager_find_service_by_path(manager->wired_services, path);
+
+		if (NULL != service)
+		{
+			return service;
+		}
+
+		service = connman_manager_find_service_by_path(manager->p2p_services, path);
+
+		if (NULL != service)
+		{
+			return service;
+		}
+
+		service = connman_manager_find_service_by_path(manager->bluetooth_services,
+		                                               path);
+
+		if (NULL != service)
+		{
+			return service;
+		}
+
+		service = connman_manager_find_service_by_path(manager->cellular_services,
+		                                               path);
+	}
+
+	return service;
+}
+
+/*
+ * Traverse through the manager's technologies list and return the technology
+ * matching the path provided
+ *
+ * @param[IN] manager A connman manager instance
+ * @param[IN] path Technology object path to compare
+ *
+ * @return Technology with matching path, NULL if matching technology not found
+ */
+
+static connman_technology_t *find_technology_by_path(connman_manager_t *manager,
+        gchar *path)
+{
+	if (NULL == manager || NULL == path)
+	{
+		return NULL;
+	}
+
+	GSList *iter = NULL;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *technology = (connman_technology_t *)(iter->data);
+
+		if (technology == NULL)
+		{
+			continue;
+		}
+
+		if (g_strcmp0(technology->path, path) == 0)
+		{
+			return technology;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Check if the given service's "Ethernet" properties matches system's wifi/wired interface
+ *
+ * @param[IN]  service_v GVariant listing service properties
+ *
+ * @return TRUE if the service is either on wifi/wired interface, FALSE otherwise
+ */
+
+static gboolean service_on_configured_iface(GVariant *service_v)
+{
+	if (NULL == service_v)
+	{
+		return FALSE;
+	}
+
+	GVariant *properties = g_variant_get_child_value(service_v, 1);
+	gsize i;
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (!g_strcmp0(key, "Ethernet"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+			gsize j;
+
+			for (j = 0; j < g_variant_n_children(va); j++)
+			{
+				GVariant *ethernet = g_variant_get_child_value(va, j);
+				GVariant *ekey_v = g_variant_get_child_value(ethernet, 0);
+				const gchar *ekey = g_variant_get_string(ekey_v, NULL);
+
+				if (!g_strcmp0(ekey, "Interface"))
+				{
+					GVariant *ifacev = g_variant_get_child_value(ethernet, 1);
+					GVariant *ifaceva = g_variant_get_variant(ifacev);
+					const gchar *iface = g_variant_get_string(ifaceva, NULL);
+
+					g_variant_unref(properties);
+					g_variant_unref(property);
+					g_variant_unref(key_v);
+					g_variant_unref(v);
+					g_variant_unref(va);
+					g_variant_unref(ethernet);
+					g_variant_unref(ekey_v);
+					g_variant_unref(ifacev);
+					g_variant_unref(ifaceva);
+
+					if (!g_strcmp0(iface, CONNMAN_WIFI_INTERFACE_NAME) ||
+					        !g_strcmp0(iface, CONNMAN_WIRED_INTERFACE_NAME))
+					{
+						return TRUE;
+					}
+					else
+					{
+						return FALSE;
+					}
+				}
+
+				g_variant_unref(ethernet);
+				g_variant_unref(ekey_v);
+			}
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
+		else if (!g_strcmp0(key, "Type"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+
+			const gchar *type = g_variant_get_string(va, NULL);
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+
+			if (!g_strcmp0(type, "Peer"))
+			{
+				g_variant_unref(properties);
+				g_variant_unref(property);
+				g_variant_unref(key_v);
+
+				return TRUE;
+			}
+			else if (!g_strcmp0(type, "cellular"))
+			{
+				g_variant_unref(properties);
+				g_variant_unref(property);
+				g_variant_unref(key_v);
+
+				return TRUE;
+			}
+			else if (!g_strcmp0(type, "bluetooth"))
+			{
+				g_variant_unref(properties);
+				g_variant_unref(property);
+				g_variant_unref(key_v);
+
+				return TRUE;
+			}
+
+		}
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+	}
+
+	g_variant_unref(properties);
+
+	return FALSE;
+}
+
+/**
+ * Add the given service to manager's wifi/wired list based on the type of service
+ *
+ * @param[IN] manager A connman manager instance
+ * @param[IN] service A service instance
+ * @param[IN}  saved A gboolean indicating if this is a saved network
+ */
+
+static void add_service_to_list(connman_manager_t *manager,
+                                connman_service_t *service, gboolean saved)
+{
+	if (saved == TRUE)
+	{
+		WCALOG_DEBUG("Adding saved service %s", service->path);
+		manager->saved_services = g_slist_append(manager->saved_services, service);
+	}
+	else
+	{
+		WCALOG_DEBUG("Adding service %s, type %d", service->path, service->type);
+
+		if (connman_service_type_wifi(service))
+		{
+			manager->wifi_services = g_slist_append(manager->wifi_services, service);
+		}
+		else if (connman_service_type_ethernet(service))
+		{
+			manager->wired_services = g_slist_append(manager->wired_services, service);
+		}
+		else if (connman_service_type_p2p(service))
+		{
+			manager->p2p_services = g_slist_append(manager->p2p_services, service);
+		}
+		else if (connman_service_type_wan(service))
+		{
+			manager->cellular_services = g_slist_append(manager->cellular_services,
+			                             service);
+		}
+		else if (connman_service_type_bluetooth(service))
+		{
+			manager->bluetooth_services = g_slist_append(manager->bluetooth_services,
+			                              service);
+		}
+	}
+}
+
+/**
+ * Process new service data from connman.
+ * Either update existing service or create new service.
+ *
+ * @param[IN] manager A connman manager instance
+ * @param[IN] service_v A gvariant with service properties and values to update.
+ * @param[IN] saved A gboolean indicating if this is a saved network
+ *
+ * @return A pointer to service if service was added or updated, NULL otherwise.
+ */
+static connman_service_t* update_or_add_service(connman_manager_t *manager,
+                                      GVariant *service_v,
+                                      gboolean saved)
+{
+	GVariant *path_v = g_variant_get_child_value(service_v, 0);
+	GVariant *properties = g_variant_get_child_value(service_v, 1);
+	const gchar *path = g_variant_get_string(path_v, NULL);
+	connman_service_t *service = NULL;
+
+	service = find_service_from_path(manager, path, saved);
+
+	if (NULL != service)
+	{
+		connman_service_update_properties(service, properties);
+	}
+	else
+	{
+		/* Only in case that the service was added as new one it contains all
+		 * properties and we can check wether it's on one of the supported
+		 * network interfaces. If the service is a cellular one we ignore the
+		 * interface check as the interface is just way to route data and not
+		 * the primary control point. */
+		if (saved || service_on_configured_iface(service_v) == TRUE)
+		{
+			service = connman_service_new(service_v);
+			add_service_to_list(manager, service, saved);
+		}
+	}
+
+	g_variant_unref(properties);
+	g_variant_unref(path_v);
+
+	return service;
+}
+
+/**
+ * Go through the list of services in the "services" parameter and if the service
+ * is already present in the manager's list , update its properties, and if not , add it
+ * as a new service.
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] services Properties of a new/existing service
+ * @param[IN}  saved A gboolean indicating if this is a saved network
+ * @param[OUT] service_type Flags ORing type of services updated
+ *
+ * @return TRUE only if any service is updated or added, return FALSE otherwise
+ */
+
+static gboolean connman_manager_update_services(connman_manager_t *manager,
+        GVariant *services, unsigned char *service_type, gboolean saved)
+{
+	if (NULL == manager || NULL == services)
+	{
+		return FALSE;
+	}
+
+	gsize i;
+	gboolean update_considered = FALSE;
+
+	for (i = 0; i < g_variant_n_children(services); i++)
+	{
+		GVariant *service_v = g_variant_get_child_value(services, i);
+		connman_service_t *service = update_or_add_service(manager, service_v, saved);
+		g_variant_unref(service_v);
+
+		if (!service)
+		{
+			continue;
+		}
+
+		update_considered = TRUE;
+
+		/* determine service type only if the supplied argument for storing it is non-NULL
+		 * (i.e not for saved networks) and when we're sure that something has changed
+		 * otherwise it doesn't make sense
+		 */
+		if (service_type)
+		{
+			switch (service->type)
+			{
+				case CONNMAN_SERVICE_TYPE_ETHERNET:
+					*service_type |= ETHERNET_SERVICES_CHANGED;
+					break;
+
+				case CONNMAN_SERVICE_TYPE_WIFI:
+					*service_type |= WIFI_SERVICES_CHANGED;
+					break;
+
+				case CONNMAN_SERVICE_TYPE_P2P:
+					*service_type |= P2P_SERVICES_CHANGED;
+					break;
+
+				case CONNMAN_SERVICE_TYPE_CELLULAR:
+					*service_type |= CELLULAR_SERVICES_CHANGED;
+					break;
+
+				case CONNMAN_SERVICE_TYPE_BLUETOOTH:
+					*service_type |= BLUETOOTH_SERVICES_CHANGED;
+					break;
+
+				default:
+					break;
+			}
+		}
+	}
+
+	return update_considered;
+}
+
+/**
+ * Remove services in the "services_removed" list from the given "service_list" list
+ *
+ * @param[IN] service_list Manager's wifi/wired list
+ * @param[IN] services_removed List of services removed
+ * @param[OUT] service_type Flags ORing type of services removed
+ *
+ * @return TRUE only if any service is removed from the list, FALSE otherwise
+ */
+
+static gboolean remove_services_from_list(GSList **service_list,
+        gchar **services_removed)
+{
+	GSList *iter, *remove_list = NULL;
+	gboolean ret = FALSE;
+	gchar **services_removed_iter = services_removed;
+
+	/* look for removed services */
+	while (NULL != *services_removed_iter)
+	{
+		for (iter = *service_list; NULL != iter; iter = iter->next)
+		{
+			connman_service_t *service = (connman_service_t *)(iter->data);
+
+			if (!g_strcmp0(service->path, *services_removed_iter))
+			{
+				WCALOG_DEBUG("Removing service : %s", service->name);
+				remove_list = g_slist_append(remove_list, service);
+				break;
+			}
+		}
+
+		services_removed_iter = services_removed_iter + 1;
+	}
+
+	/*
+	 * do the actual remove of services in an extra loop, so we don't
+	 * alter the list we're walking
+	 */
+	for (iter = remove_list; NULL != iter; iter = iter->next)
+	{
+		connman_service_t *service = (connman_service_t *)(iter->data);
+		*service_list = g_slist_delete_link(*service_list, g_slist_find(*service_list,
+		                                    service));
+		connman_service_free(service, NULL);
+		ret = TRUE;
+	}
+
+	g_slist_free(remove_list);
+	return ret;
+}
+
+/**
+ * Remove all the wifi services in the "services_removed" string array from the manager's wifi service list
+ * and thereafter removing wired services in "services_removed" from the manager's wired service list
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] services_removed List of services removed
+ *
+ * @return TRUE only if atleast one service is removed, else return FALSE
+ *
+ */
+
+static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
+        gchar **services_removed, unsigned char *service_type)
+{
+	if (NULL == manager || NULL == services_removed)
+	{
+		return FALSE;
+	}
+
+	gboolean wifi_services_removed = FALSE, wired_services_removed = FALSE,
+	         p2p_services_removed = FALSE, cellular_services_removed = FALSE,
+	         bluetooth_services_removed = FALSE;
+
+	wifi_services_removed = remove_services_from_list(&manager->wifi_services,
+	                        services_removed);
+	wired_services_removed = remove_services_from_list(&manager->wired_services,
+	                         services_removed);
+	p2p_services_removed = remove_services_from_list(&manager->p2p_services,
+	                       services_removed);
+	cellular_services_removed = remove_services_from_list(
+	                                &manager->cellular_services, services_removed);
+	bluetooth_services_removed = remove_services_from_list(
+	                                 &manager->bluetooth_services, services_removed);
+
+	if (wired_services_removed)
+	{
+		*service_type |= ETHERNET_SERVICES_CHANGED;
+	}
+
+	if (wifi_services_removed)
+	{
+		*service_type |= WIFI_SERVICES_CHANGED;
+	}
+
+	if (p2p_services_removed)
+	{
+		*service_type |= P2P_SERVICES_CHANGED;
+		// Refresh the peer list for all the groups as the removed service might be one of them
+		GSList *iter;
+
+		for (iter = manager->groups; NULL != iter; iter = iter->next)
+		{
+			connman_group_t *group = (connman_group_t *)(iter->data);
+			connman_manager_populate_group_peers(manager, group);
+		}
+	}
+
+	if (cellular_services_removed)
+	{
+		*service_type |= CELLULAR_SERVICES_CHANGED;
+	}
+
+	if (bluetooth_services_removed)
+	{
+		*service_type |= BLUETOOTH_SERVICES_CHANGED;
+	}
+
+	return (wifi_services_removed | wired_services_removed | p2p_services_removed |
+	        cellular_services_removed | bluetooth_services_removed);
+}
+
+/**
+ * Free the manager's services wifi and wired service list
+ *
+ * @param[IN]  manager A manager instance
+ *
+ */
+
+static void connman_manager_free_services(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	g_slist_foreach(manager->wifi_services, (GFunc) connman_service_free, NULL);
+	g_slist_free(manager->wifi_services);
+	manager->wifi_services = NULL;
+
+	g_slist_foreach(manager->wired_services, (GFunc) connman_service_free, NULL);
+	g_slist_free(manager->wired_services);
+	manager->wired_services = NULL;
+
+	g_slist_foreach(manager->p2p_services, (GFunc) connman_service_free, NULL);
+	g_slist_free(manager->p2p_services);
+	manager->p2p_services = NULL;
+
+	g_slist_foreach(manager->cellular_services, (GFunc) connman_service_free, NULL);
+	g_slist_free(manager->cellular_services);
+	manager->cellular_services = NULL;
+
+	g_slist_foreach(manager->bluetooth_services, (GFunc) connman_service_free,
+	                NULL);
+	g_slist_free(manager->bluetooth_services);
+	manager->bluetooth_services = NULL;
+
+	g_slist_foreach(manager->saved_services, (GFunc) connman_service_free, NULL);
+	g_slist_free(manager->saved_services);
+	manager->saved_services = NULL;
+}
+
+/**
+ * Free the manager's technologies list
+ *
+ * @param[IN]  manager A manager instance
+ *
+ */
+
+static void connman_manager_free_technologies(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	g_slist_foreach(manager->technologies, (GFunc) connman_technology_free, NULL);
+	g_slist_free(manager->technologies);
+	manager->technologies = NULL;
+}
+
+/**
+ * Free the manager's groups list
+ *
+ * @param[IN]  manager A manager instance
+ *
+ */
+
+static void connman_manager_free_groups(connman_manager_t *manager)
+
+{
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	g_slist_foreach(manager->groups, (GFunc) connman_group_free, NULL);
+	g_slist_free(manager->groups);
+	manager->groups = NULL;
+}
+
+/**
+ * Retrieve all the services for the manager by making a "GetServices" remote call
+ * and add them to its list
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return FALSE if the remote call fails
+ */
+
+static gboolean connman_manager_add_services(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *services;
+	gsize i;
+
+	connman_interface_manager_call_get_services_sync(manager->remote,
+	        &services, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_GET_SERVICES_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	if (connman_update_callbacks->services_changed)
+	{
+		connman_update_callbacks->services_changed(services, NULL);
+	}
+
+
+	for (i = 0; i < g_variant_n_children(services); i++)
+	{
+		GVariant *service_v = g_variant_get_child_value(services, i);
+		(void)update_or_add_service(manager, service_v, FALSE);
+		g_variant_unref(service_v);
+	}
+
+	g_variant_unref(services);
+
+	return TRUE;
+}
+
+/**
+ * Change passphrase of a network saved by connman i.e a network settings created by connman
+ * but currently network is out of range
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] service Saved service whose passphrase needs to be changed
+ * @param[IN] passphrase The new passphrase to be saved
+ *
+ */
+
+gboolean connman_manager_change_saved_passphrase(connman_manager_t *manager,
+        connman_service_t *service, const gchar *passphrase)
+{
+	if (NULL == manager || NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	GVariantBuilder *key_b;
+	GVariant *key_v;
+
+	key_b = g_variant_builder_new(G_VARIANT_TYPE("a{sv}"));
+	g_variant_builder_add(key_b, "{sv}", "Passphrase",
+	                      g_variant_new_string(passphrase));
+	key_v = g_variant_builder_end(key_b);
+	g_variant_builder_unref(key_b);
+
+
+	connman_interface_manager_call_change_saved_service_sync(manager->remote,
+	        service->identifier, key_v, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_CHANGE_SAVED_SERVICE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+
+/**
+ * Retrieve all the technologies for the manager by making a "GetTechnologies" remote call
+ * and add them to its list
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return FALSE if the remote call fails, TRUE otherwise
+ */
+
+static gboolean connman_manager_add_technologies(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *technologies;
+	gsize i;
+
+	connman_interface_manager_call_get_technologies_sync(manager->remote,
+	        &technologies, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_GET_TECHNOLOGIES_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	for (i = 0; i < g_variant_n_children(technologies); i++)
+	{
+		GVariant *technology_v = g_variant_get_child_value(technologies, i);
+		GVariant *path = g_variant_get_child_value(technology_v, 0);
+		connman_technology_t *technology = connman_technology_new(g_variant_get_string(path, NULL));
+
+		if (technology != NULL)
+		{
+			manager->technologies = g_slist_append(manager->technologies, technology);
+		}
+
+		g_variant_unref(path);
+		g_variant_unref(technology_v);
+	}
+
+	g_variant_unref(technologies);
+
+	return TRUE;
+}
+
+/*
+ * Traverse through the manager's groups list and return the group
+ * matching the path provided
+ *
+ * @param[IN] manager A connman manager instance
+ * @param[IN] path Group object path to compare
+ *
+ * @return Group with matching path, NULL if matching group not found
+ */
+
+static connman_group_t *find_group_by_path(connman_manager_t *manager,
+        const gchar *path)
+{
+	if (NULL == manager || NULL == path)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->groups; NULL != iter; iter = iter->next)
+	{
+		connman_group_t *group = (connman_group_t *)(iter->data);
+
+		if (!g_strcmp0(group->path, path))
+		{
+			return group;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * Populate the group's peers (see header for API details)
+ */
+gboolean connman_manager_populate_group_peers(connman_manager_t *manager,
+        connman_group_t *group)
+{
+	if (NULL == group)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *peers = NULL;
+	gsize i, j;
+
+	connman_interface_group_call_get_peers_sync(group->remote, &peers, NULL,
+	        &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_GET_PEERS_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_slist_free(group->peer_list);
+	group->peer_list = NULL;
+
+	for (i = 0; i < g_variant_n_children(peers); i++)
+	{
+		GVariant *peer_v = g_variant_get_child_value(peers, i);
+		GVariant *o = g_variant_get_child_value(peer_v, 0);
+		const gchar *path = g_variant_get_string(o, NULL);
+
+		connman_service_t *peer = NULL;
+		GSList *iter;
+		gboolean peer_added = FALSE;
+
+		for (iter = manager->p2p_services; NULL != iter; iter = iter->next)
+		{
+			peer = (connman_service_t *)(iter->data);
+
+			if (!g_strcmp0(peer->path, path))
+			{
+				group->peer_list = g_slist_append(group->peer_list, peer);
+				peer_added = TRUE;
+				break;
+			}
+		}
+
+		if (!peer_added)
+		{
+			g_variant_unref(peer_v);
+			g_variant_unref(o);
+
+			continue;
+		}
+
+		GVariant *properties = g_variant_get_child_value(peer_v, 1);
+
+		for (j = 0; j < g_variant_n_children(properties); j++)
+		{
+			GVariant *property = g_variant_get_child_value(properties, j);
+			GVariant *key_v = g_variant_get_child_value(property, 0);
+			GVariant *val_v = g_variant_get_child_value(property, 1);
+			GVariant *val = g_variant_get_variant(val_v);
+			const gchar *key = g_variant_get_string(key_v, NULL);
+
+			if (!g_strcmp0(key, "IPAddress"))
+			{
+				g_free(peer->ipinfo.ipv4.address);
+				peer->ipinfo.ipv4.address = g_variant_dup_string(val, NULL);
+			}
+
+			g_variant_unref(property);
+			g_variant_unref(key_v);
+			g_variant_unref(val_v);
+			g_variant_unref(val);
+		}
+
+		g_variant_unref(properties);
+		g_variant_unref(peer_v);
+		g_variant_unref(o);
+	}
+
+	g_variant_unref(peers);
+
+	return TRUE;
+}
+
+/**
+ * Retrieve all the groups for the manager by making a "GetGroups" remote call
+ * and add them to its list
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return FALSE if the remote call fails, TRUE otherwise
+ */
+
+static gboolean connman_manager_add_groups(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *groups;
+	gsize i;
+
+	connman_interface_manager_call_get_groups_sync(manager->remote,
+	        &groups, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_GET_GROUPS_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	for (i = 0; i < g_variant_n_children(groups); i++)
+	{
+		GVariant *group_v = g_variant_get_child_value(groups, i);
+		connman_group_t *group;
+
+		GVariant *o = g_variant_get_child_value(group_v, 0);
+		const gchar *path = g_variant_get_string(o, NULL);
+
+		if (connman_update_callbacks->group_added)
+		{
+			connman_update_callbacks->group_added(path, group_v);
+		}
+
+		if (!find_group_by_path(manager, path))
+		{
+			group = connman_group_new(group_v);
+			manager->groups = g_slist_append(manager->groups, group);
+			connman_manager_populate_group_peers(manager, group);
+		}
+
+		g_variant_unref(group_v);
+		g_variant_unref(o);
+
+	}
+
+	g_variant_unref(groups);
+
+	return TRUE;
+}
+
+/*
+ * Create a new group (see header for API details)
+ */
+
+connman_group_t *connman_manager_create_group(connman_manager_t *manager,
+        const gchar *ssid, const gchar *passphrase)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	gchar *group_path = NULL;
+
+	connman_interface_manager_call_create_group_sync(manager->remote,
+	        ssid, passphrase, &group_path, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_CREATE_GROUP_ERROR, error->message);
+		g_error_free(error);
+		return NULL;
+	}
+
+	WCALOG_DEBUG("New group (path : %s) added", group_path);
+
+	connman_manager_add_groups(manager);
+	connman_group_t *group = find_group_by_path(manager, group_path);
+
+	if (group_path != NULL)
+	{
+		g_free(group_path);
+	}
+
+	return group;
+}
+
+/*
+ * Get the number of connected station
+ */
+guint connman_manager_get_sta_count(connman_manager_t *manager)
+{
+	if (NULL == manager)
+		return FALSE;
+
+	GError *error = NULL;
+	guint sta_count = 0;
+
+	connman_interface_manager_call_get_sta_count_sync(manager->remote, &sta_count, NULL, &error);
+
+	if (error)
+	{
+		g_error_free(error);
+		return 0;
+	}
+
+	return sta_count;
+}
+
+/**
+ * Traverse through the given service list, comparing each service with the path provided
+ * returning the service with the matching path (See header for API details)
+ */
+
+connman_service_t *connman_manager_find_service_by_path(GSList *service_list,
+        const gchar *path)
+{
+	GSList *iter;
+
+	if (NULL == path)
+	{
+		/* Does not really help when accessing freed memory.*/
+		WCALOG_ERROR(MSGID_INVALID_STATE, 0, "Path is NULL, something is wrong!");
+		return NULL;
+	}
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		connman_service_t *service = (connman_service_t *)(iter->data);
+
+		if (!service->path)
+		{
+			continue;
+		}
+
+		if (!g_strcmp0(service->path, path))
+		{
+			return service;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Check if the manager is not in offline mode and available to
+ * enable network connections (see header for API details)
+ */
+
+gboolean connman_manager_is_manager_available(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	return !manager->offline;
+}
+
+
+/**
+ * Offlinemode on/off the given manager (see header for API details)
+ */
+
+gboolean connman_manager_set_offlinemode(connman_manager_t *manager,
+        gboolean state)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	/* don't set offlinemode again if we're already in the right offline state */
+	if (state == manager->offline)
+	{
+		return TRUE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_manager_call_set_property_sync(manager->remote,
+	        "OfflineMode",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_SET_OFFLINEMODE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	manager->offline = state;
+	return TRUE;
+}
+
+/**
+ * Enable/Disable wol/wowl the given manager (see header for API details)
+ */
+
+gboolean connman_manager_set_wol_wowl_mode(connman_manager_t *manager, gboolean state)
+{
+	if(NULL == manager)
+		return FALSE;
+
+	/* don't set again if we're already in the same state */
+	if (state == manager->wol_wowl)
+		return TRUE;
+
+	GError *error = NULL;
+
+	connman_interface_manager_call_set_property_sync(manager->remote,
+			"WOLWOWLMode",
+			g_variant_new_variant(g_variant_new_boolean(state)),
+			NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_SET_WOL_WOWL_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	manager->wol_wowl = state;
+
+	return TRUE;
+}
+
+static void enable_wol_status_for_quick_power_off_cb(bool success, void *user_data)
+{
+	WCALOG_INFO(MSGID_STATE_RECOVERY_INFO, 0, "Success in enabling wol status in quick power off case");
+}
+
+static void disable_wol_status_for_quick_power_off_cb(bool success, void *user_data)
+{
+	WCALOG_INFO(MSGID_STATE_RECOVERY_INFO, 0, "Success in disabling wol status in quick power off case");
+}
+
+/**
+ * Update manager's state by making remote call for get_properties
+ */
+
+static void connman_manager_update_state(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	gsize i;
+	GVariant *properties = connman_manager_get_properties(manager);
+
+	if (NULL == properties)
+	{
+		WCALOG_CRITICAL(MSGID_MANAGER_STATE_UPDATE_ERROR, 0,
+		                "Connman manager unavailable !!!");
+		return;
+	}
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		GVariant *v = g_variant_get_child_value(property, 1);
+		GVariant *va = g_variant_get_variant(v);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (connman_update_callbacks->manager_property_changed)
+		{
+			connman_update_callbacks->manager_property_changed(key, va);
+		}
+
+		if (!g_strcmp0(key, "State"))
+		{
+			g_free(manager->state);
+			manager->state = g_variant_dup_string(va, NULL);
+		}
+		else if (!g_strcmp0(key, "OfflineMode"))
+		{
+			manager->offline = g_variant_get_boolean(va);
+		}
+		else if (!g_strcmp0(key, "WOLWOWLMode"))
+		{
+			manager->wol_wowl = g_variant_get_boolean(va);
+
+#ifdef ENABLE_QUICK_WOL
+			if (manager->wol_wowl)
+				wca_support_enable_wol_status(enable_wol_status_for_quick_power_off_cb, NULL);
+			else
+				wca_support_disable_wol_status(disable_wol_status_for_quick_power_off_cb, NULL);
+#endif
+		}
+
+		g_variant_unref(v);
+		g_variant_unref(va);
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+	}
+
+	g_variant_unref(properties);
+}
+
+/**
+ * Check if the manager in online ( its state is set to 'online')
+ * (see header for API details)
+ */
+
+gboolean connman_manager_is_manager_online(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	connman_manager_update_state(manager);
+
+	if (!g_strcmp0(manager->state, "online"))
+	{
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+connman_technology_t *connman_manager_find_technology_by_name(
+    connman_manager_t *manager, const char *name)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *tech = (struct connman_technology *)(iter->data);
+
+		if (!tech)
+		{
+			continue;
+		}
+
+		if (g_strcmp0(name, tech->type) == 0)
+		{
+			return tech;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Go through the manager's technologies list and get the wifi one
+ * (see header for API details)
+ */
+
+connman_technology_t *connman_manager_find_wifi_technology(
+    connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *tech = (struct connman_technology *)(iter->data);
+
+		if (!tech)
+		{
+			continue;
+		}
+
+		if (g_strcmp0("wifi", tech->type) == 0)
+		{
+			return tech;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Go through the manager's technologies list and get the ethernet one
+ * (see header for API details)
+ */
+
+connman_technology_t *connman_manager_find_ethernet_technology(
+    connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *tech = (struct connman_technology *)(iter->data);
+
+		if (!tech)
+		{
+			continue;
+		}
+
+		if (g_strcmp0("ethernet", tech->type) == 0)
+		{
+			return tech;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Go through the manager's technologies list and get the cellular one
+ * (see header for API details)
+ */
+
+connman_technology_t *connman_manager_find_cellular_technology(
+    connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *tech = (struct connman_technology *)(iter->data);
+
+		if (!tech)
+		{
+			continue;
+		}
+
+		if (g_strcmp0("cellular", tech->type) == 0)
+		{
+			return tech;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Go through the manager's technologies list and get the bluetooth one
+ * (see header for API details)
+ */
+
+connman_technology_t *connman_manager_find_bluetooth_technology(
+    connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *tech = (struct connman_technology *)(iter->data);
+
+		if (!tech)
+		{
+			continue;
+		}
+
+		if (g_strcmp0("bluetooth", tech->type) == 0)
+		{
+			return tech;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Go through the manager's given services list and get the one which is in
+ * "ready" or "online" state (see header for API details)
+ */
+
+connman_service_t *connman_manager_get_connected_service(GSList *service_list)
+{
+	if (NULL == service_list)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+	connman_service_t *service = NULL, *connected_service = NULL;
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		service = (struct connman_service *)(iter->data);
+		int service_state = connman_service_get_state(service->state);
+
+		if(service_state == CONNMAN_SERVICE_STATE_ONLINE
+			|| service_state == CONNMAN_SERVICE_STATE_READY
+			|| service_state == CONNMAN_SERVICE_STATE_CONFIGURATION)
+		{
+			connected_service = service;
+			break;
+		}
+	}
+
+	if (connected_service != NULL)
+	{
+		GVariant *properties = connman_service_fetch_properties(connected_service);
+
+		if (NULL != properties)
+		{
+			connman_service_update_properties(connected_service, properties);
+			g_variant_unref(properties);
+			return connected_service;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Go through the manager's given service list and find the currently connecting service
+ * and return it.
+ */
+
+connman_service_t *connman_manager_get_connecting_service(GSList *service_list)
+{
+	GSList *iter;
+	connman_service_t *service = NULL;
+	int state;
+
+	if (!service_list)
+	{
+		return NULL;
+	}
+
+	for (iter = service_list; iter; iter = iter->next)
+	{
+		service = (connman_service_t *) iter->data;
+		state = connman_service_get_state(service->state);
+
+		if (state == CONNMAN_SERVICE_STATE_ASSOCIATION ||
+		        state == CONNMAN_SERVICE_STATE_CONFIGURATION)
+		{
+			return service;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Callback for manager's "property_changed" signal (see header for API details)
+ */
+
+static void
+property_changed_cb(ConnmanInterfaceManager *proxy, const gchar *property,
+                    GVariant *v,
+                    connman_manager_t      *manager)
+{
+	GVariant *va = g_variant_get_child_value(v, 0);
+	WCALOG_DEBUG("Manager property %s changed : %s", property,
+	             g_variant_get_string(va, NULL));
+
+	if (connman_update_callbacks->manager_property_changed)
+	{
+		connman_update_callbacks->manager_property_changed(property, va);
+	}
+
+	if (!g_strcmp0(property, "State"))
+	{
+		g_free(manager->state);
+		manager->state = g_variant_dup_string(va, NULL);
+	}
+	else if (!g_strcmp0(property, "OfflineMode"))
+	{
+		manager->offline = g_variant_get_boolean(va);
+	}
+
+	if (NULL != manager->handle_property_change_fn)
+	{
+		(manager->handle_property_change_fn)((gpointer)manager, property, v);
+	}
+
+	g_variant_unref(va);
+}
+
+
+/**
+ * Callback for manager's "technology_added" signal
+ */
+
+static void
+technology_added_cb(ConnmanInterfaceManager *proxy, gchar *path, GVariant *v,
+                    connman_manager_t      *manager)
+{
+	WCALOG_DEBUG("Technology %s added", path);
+
+	if (NULL == find_technology_by_path(manager, path))
+	{
+		connman_technology_t *technology = connman_technology_new(path);
+
+		if (technology != NULL)
+		{
+			WCALOG_INFO("DEBUG", 0, "Updating manager's technology list");
+			manager->technologies = g_slist_append(manager->technologies,
+			                                       technology);
+
+		}
+	}
+
+	if (connman_update_callbacks->technology_added)
+	{
+		connman_update_callbacks->technology_added(path, v);
+	}
+
+	if (NULL != manager->handle_technologies_change_fn)
+	{
+		(manager->handle_technologies_change_fn)(manager);
+	}
+}
+
+/**
+ * Callback for manager's "technology_removed" signal
+ */
+
+static void
+technology_removed_cb(ConnmanInterfaceManager *proxy, gchar *path,
+                      connman_manager_t      *manager)
+{
+	WCALOG_DEBUG("Technology removed");
+
+	if (connman_update_callbacks->technology_removed)
+	{
+		connman_update_callbacks->technology_removed(path);
+	}
+
+	connman_technology_t *technology = find_technology_by_path(manager, path);
+
+	if (NULL != technology)
+	{
+		manager->technologies = g_slist_remove_link(manager->technologies,
+		                        g_slist_find(manager->technologies, technology));
+		connman_technology_free(technology);
+	}
+
+	if (NULL != manager->handle_technologies_change_fn)
+	{
+		(manager->handle_technologies_change_fn)(manager);
+	}
+}
+
+/**
+ * Callback for manager's "group_added" signal
+ */
+
+static void
+group_added_cb(ConnmanInterfaceManager *proxy, gchar *path, GVariant *v,
+               connman_manager_t      *manager)
+{
+	WCALOG_DEBUG("Group %s added", path);
+
+	if (connman_update_callbacks->group_added)
+	{
+		connman_update_callbacks->group_added(path, v);
+	}
+
+	if (NULL == find_group_by_path(manager, path))
+	{
+		GVariant *group_v = g_variant_new("(o@a{sv})", path, v);
+		connman_group_t *group = connman_group_new(group_v);
+		connman_manager_populate_group_peers(manager, group);
+		WCALOG_DEBUG("Updating manager's group list");
+		manager->groups = g_slist_append(manager->groups, group);
+		connectionmanager_send_status_to_subscribers();
+		g_variant_unref(group_v);
+	}
+
+	if (NULL != manager->handle_groups_change_fn)
+	{
+		(manager->handle_groups_change_fn)((gpointer)manager, TRUE);
+	}
+}
+
+/**
+ * Callback for manager's "group_removed" signal
+ */
+
+static void
+group_removed_cb(ConnmanInterfaceManager *proxy, gchar *path,
+                 connman_manager_t      *manager)
+{
+	WCALOG_DEBUG("group %s removed", path);
+
+	if (connman_update_callbacks->group_removed)
+	{
+		connman_update_callbacks->group_removed(path);
+	}
+
+	connman_group_t *group = find_group_by_path(manager, path);
+
+	if (NULL != group)
+	{
+		manager->groups = g_slist_remove_link(manager->groups,
+		                                      g_slist_find(manager->groups, group));
+		connman_group_free(group, NULL);
+	}
+
+	if (NULL != manager->handle_groups_change_fn)
+	{
+		(manager->handle_groups_change_fn)((gpointer)manager, FALSE);
+	}
+}
+
+/**
+ * Callback for manager's "services_changed" signal
+ */
+
+static void
+services_changed_cb(ConnmanInterfaceManager *proxy, GVariant *services_added,
+                    gchar **services_removed, connman_manager_t *manager)
+{
+	WCALOG_DEBUG("Services_changed ");
+
+	if (connman_update_callbacks->services_changed)
+	{
+		connman_update_callbacks->services_changed(services_added, services_removed);
+	}
+
+	unsigned char service_type = 0;
+	gboolean update_status = connman_manager_update_services(manager,
+	                         services_added, &service_type, FALSE);
+	gboolean remove_status = connman_manager_remove_old_services(manager,
+	                         services_removed, &service_type);
+
+	if (update_status == TRUE || remove_status == TRUE)
+	{
+		if (NULL != manager->handle_services_change_fn)
+		{
+			(manager->handle_services_change_fn)(manager, service_type);
+		}
+	}
+}
+
+/**
+ * Callback for manager's "saved_services_changed" signal
+ */
+
+static void
+saved_services_changed_cb(ConnmanInterfaceManager *proxy,
+                          GVariant *saved_services_added,
+                          gchar **saved_services_removed, connman_manager_t *manager)
+{
+	WCALOG_DEBUG("Saved_services_changed ");
+
+	if (connman_update_callbacks->saved_services_changed)
+	{
+		connman_update_callbacks->saved_services_changed(saved_services_added,
+		        saved_services_removed);
+	}
+
+	connman_manager_update_services(manager, saved_services_added, NULL, TRUE);
+	remove_services_from_list(&manager->saved_services, saved_services_removed);
+}
+
+/**
+ * Register for manager's "properties_changed" signal, calling the provided function whenever the callback function
+ * for the signal is called (see header for API details)
+ */
+
+void connman_manager_register_property_changed_cb(connman_manager_t *manager,
+        connman_property_changed_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	manager->handle_property_change_fn = func;
+}
+
+/**
+ * Register for manager's "services_changed" signal, calling the provided function whenever the callback function
+ * for the signal is called (see header for API details)
+ */
+
+void connman_manager_register_services_changed_cb(connman_manager_t *manager,
+        connman_services_changed_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	manager->handle_services_change_fn = func;
+}
+
+/**
+ * Register for manager's "group_added" and "group_removed" signal, calling the provided function whenever the callback function
+ * for the signal is called (see header for API details)
+ */
+
+void connman_manager_register_groups_changed_cb(connman_manager_t *manager,
+        connman_groups_changed_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	manager->handle_groups_change_fn = func;
+}
+
+/**
+ * Register for manager's "technology_added" and "technology_removed" signal, calling the provided function whenever the callback function
+ * for the signal is called (see header for API details)
+ */
+
+void connman_manager_register_technologies_changed_cb(connman_manager_t
+        *manager, connman_technologies_changed_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	manager->handle_technologies_change_fn = func;
+}
+
+
+/**
+ * Register a agent instance on the specified dbus path with the manager
+ * (see header for API details)
+ **/
+
+gboolean connman_manager_register_agent(connman_manager_t *manager,
+                                        const gchar *path)
+{
+	GError *error = NULL;
+
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	connman_interface_manager_call_register_agent_sync(manager->remote,
+	        path, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_DEBUG("%s", error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	WCALOG_DEBUG("Registered agent successfully with connman");
+
+	return TRUE;
+}
+
+/**
+ * Unegister a agent instance on the specified dbus path from the manager
+ * (see header for API details)
+ **/
+
+gboolean connman_manager_unregister_agent(connman_manager_t *manager,
+        const gchar *path)
+{
+	GError *error;
+
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	connman_interface_manager_call_unregister_agent_sync(manager->remote,
+	        path, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_UNREGISTER_AGENT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+/**
+ * Register a counter instance on the specified dbus path with the manager
+ * (see header for API details)
+ **/
+
+gboolean connman_manager_register_counter(connman_manager_t *manager,
+        const gchar *path, guint accuracy, guint period)
+{
+	GError *error = NULL;
+
+	if (NULL == manager)
+	{
+		return FALSE;
+	}
+
+	connman_interface_manager_call_register_counter_sync(manager->remote,
+	        path, accuracy, period, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_INFO(MSGID_MANAGER_REGISTER_COUNTER_ERROR, 0, "%s", error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	WCALOG_INFO(MSGID_MANAGER_REGISTER_COUNTER_SUCCESS, 0,
+	            "Registered counter successfully with connman");
+
+	return TRUE;
+}
+
+gboolean connman_manager_unregister_counter(connman_manager_t *manager,
+        const gchar *path)
+{
+	GError *error = NULL;
+
+	if (NULL == manager || NULL == path)
+	{
+		return FALSE;
+	}
+
+	connman_interface_manager_call_unregister_counter_sync(manager->remote,
+	        path, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_UNREGISTER_COUNTER_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Initialize a new manager instance and update its services and technologies list
+ * (see header for API details)
+ */
+
+connman_manager_t *connman_manager_new(void)
+{
+	GError *error = NULL;
+	connman_manager_t *manager = g_new0(connman_manager_t, 1);
+
+	if (manager == NULL)
+	{
+		return NULL;
+	}
+
+	manager->technologies = NULL;
+
+	manager->remote = connman_interface_manager_proxy_new_for_bus_sync(
+	                      G_BUS_TYPE_SYSTEM,
+	                      G_DBUS_PROXY_FLAGS_NONE,
+	                      "net.connman", "/",
+	                      NULL,
+	                      &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_INIT_ERROR, error->message);
+		g_error_free(error);
+		g_free(manager);
+		return NULL;
+	}
+
+	g_signal_connect(G_OBJECT(manager->remote), "property-changed",
+	                 G_CALLBACK(property_changed_cb), manager);
+
+	g_signal_connect(G_OBJECT(manager->remote), "technology-added",
+	                 G_CALLBACK(technology_added_cb), manager);
+
+	g_signal_connect(G_OBJECT(manager->remote), "technology-removed",
+	                 G_CALLBACK(technology_removed_cb), manager);
+
+	g_signal_connect(G_OBJECT(manager->remote), "services-changed",
+	                 G_CALLBACK(services_changed_cb), manager);
+
+	g_signal_connect(G_OBJECT(manager->remote), "saved-services-changed",
+	                 G_CALLBACK(saved_services_changed_cb), manager);
+
+	g_signal_connect(G_OBJECT(manager->remote), "group-added",
+	                 G_CALLBACK(group_added_cb), manager);
+
+	g_signal_connect(G_OBJECT(manager->remote), "group-removed",
+	                 G_CALLBACK(group_removed_cb), manager);
+
+	connman_manager_update_state(manager);
+	connman_manager_add_technologies(manager);
+	connman_manager_add_services(manager);
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+
+	if ((NULL != technology) && technology->p2p)
+	{
+		connman_manager_add_groups(manager);
+	}
+
+	if (g_slist_length(manager->technologies) == 0)
+	{
+		WCALOG_ERROR(MSGID_MANAGER_NO_TECH_ERROR, 0 , "No technologies initialized");
+	}
+
+	if (g_slist_length(manager->wired_services) == 0)
+	{
+		WCALOG_ERROR(MSGID_MANAGER_NO_WIRED_ERROR, 0 , "No wired service found");
+	}
+
+	WCALOG_DEBUG("%d wifi services, %d technologies",
+	             g_slist_length(manager->wifi_services),
+	             g_slist_length(manager->technologies));
+
+	WCALOG_DEBUG("%d cellular services, %d technologies",
+	             g_slist_length(manager->cellular_services),
+	             g_slist_length(manager->technologies));
+
+	WCALOG_DEBUG("%d bluetooth services, %d technologies",
+	             g_slist_length(manager->bluetooth_services),
+	             g_slist_length(manager->technologies));
+
+	return manager;
+}
+
+/**
+ * Free the manager instance (see header for API details)
+ */
+
+void connman_manager_free(connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	connman_manager_free_services(manager);
+	connman_manager_free_technologies(manager);
+	connman_manager_free_groups(manager);
+
+	g_object_unref(manager->remote);
+
+	g_free(manager->state);
+	g_free(manager);
+	manager = NULL;
+}
+
+void set_wca_support_connman_update_callbacks(
+    wca_support_connman_update_callbacks *callbacks)
+{
+	if (callbacks)
+	{
+		connman_update_callbacks = callbacks;
+	}
+}
diff --git a/src/connman_manager.h b/src/connman_manager.h
new file mode 100644
index 0000000..aae53e9
--- /dev/null
+++ b/src/connman_manager.h
@@ -0,0 +1,353 @@
+// Copyright (c) 2013-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connman_manager.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman manager
+ *
+ */
+
+#ifndef CONNMAN_MANAGER_H_
+#define CONNMAN_MANAGER_H_
+
+#include <wca-support.h>
+
+#include "connman_common.h"
+#include "connman_service.h"
+#include "connman_technology.h"
+#include "connman_group.h"
+
+#define ETHERNET_SERVICES_CHANGED   1
+#define WIFI_SERVICES_CHANGED       2
+#define P2P_SERVICES_CHANGED        4
+#define CELLULAR_SERVICES_CHANGED   8
+#define BLUETOOTH_SERVICES_CHANGED  16
+
+/**
+ * Callback function for handling any changes in connman services
+ *
+ * @param[IN] gpointer Any data to pass to this function
+ * @param[OUT] unsigned char ORing of types of services changed
+ *             (see above for types of services)
+ */
+typedef void (*connman_services_changed_cb)(gpointer, unsigned char);
+
+typedef void (*connman_groups_changed_cb)(gpointer, gboolean);
+
+typedef void (*connman_technologies_changed_cb)(gpointer);
+
+extern wca_support_connman_update_callbacks *connman_update_callbacks;
+
+/**
+ * Local instance of a connman manager
+ *
+ * Stores all required information, including current services and technologies
+ */
+
+typedef struct connman_manager
+{
+	ConnmanInterfaceManager *remote;
+	gchar   *state;
+	GSList  *wifi_services;
+	GSList  *wired_services;
+	GSList  *p2p_services;
+	GSList  *cellular_services;
+	GSList  *bluetooth_services;
+	GSList  *saved_services;
+	GSList  *technologies;
+	GSList  *groups;
+	gboolean offline;
+	gboolean wol_wowl;
+	connman_property_changed_cb handle_property_change_fn;
+	connman_services_changed_cb handle_services_change_fn;
+	connman_groups_changed_cb   handle_groups_change_fn;
+	connman_technologies_changed_cb handle_technologies_change_fn;
+} connman_manager_t;
+
+/**
+ * Traverse through the given service list, comparing each service with the path provided
+ * returning the service with the matching path
+ *
+ * @param[IN] service_list Manager's wired / wifi service list
+ * @param[IN] path Service DBus object path to compare
+ *
+ * @return service with matching path, NULL if no matching service found
+ */
+
+extern connman_service_t *connman_manager_find_service_by_path(
+    GSList *service_list, const gchar *path);
+
+/**
+ * Check if the manager is NOT in offline mode, i.e available to enable network
+ * connections
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return TRUE if manager's "offlineMode" property is FALSE
+ */
+extern gboolean connman_manager_is_manager_available(connman_manager_t
+        *manager);
+
+/**
+ * Offlinemode on/off the given manager (see header for API details)
+ *
+ * @param[IN]  manager A manager instance
+ * @param[IN]  state TRUE to enable offline mode, FALSE otherwise
+ *
+ * @return TRUE if the offline mode was set successfully
+ */
+
+gboolean connman_manager_set_offlinemode(connman_manager_t *manager,
+        gboolean state);
+
+/**
+ * Enable/Disable the WOL/WOWL
+ *
+ * @param[IN]  technology A manager instance
+ * @param[IN]  state TRUE for enable WOL/WOWL, FALSE for off
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_manager_set_wol_wowl_mode(connman_manager_t *manager, gboolean state);
+
+/**
+ * Check if the manager's state is "online"
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return TRUE if manager's state is "online"
+ */
+extern gboolean connman_manager_is_manager_online(connman_manager_t *manager);
+
+extern connman_technology_t *connman_manager_find_technology_by_name(
+    connman_manager_t *manager, const char *name);
+
+/**
+ * Go through the manager's technologies list and get the technology with type "wifi"
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return Technology with type "wifi"
+ */
+extern connman_technology_t *connman_manager_find_wifi_technology(
+    connman_manager_t *manager);
+
+/**
+ * Go through the manager's technologies list and get the technology with type "wired"
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return Technology with type "wired"
+ */
+extern connman_technology_t *connman_manager_find_ethernet_technology(
+    connman_manager_t *manager);
+
+/**
+* Go through the manager's technologies list and get the technology with type "cellular"
+*
+* @param[IN]  manager A manager instance
+*
+* @return Technology with type "cellular"
+*/
+extern connman_technology_t *connman_manager_find_cellular_technology(
+    connman_manager_t *manager);
+
+/**
+* Go through the manager's technologies list and get the technology with type "bluetooth"
+*
+* @param[IN]  manager A manager instance
+*
+* @return Technology with type "bluetooth"
+*/
+extern connman_technology_t *connman_manager_find_bluetooth_technology(
+    connman_manager_t *manager);
+
+/**
+ * Go through the manager's given services list and get the one which is in "ready" or
+ * "online" state , i.e  one of the connected states.
+ *
+ * @param[IN]  service_list Manager's service list (wired of wifi)
+ *
+ * @return Service which is in one of the connected states
+ */
+extern connman_service_t *connman_manager_get_connected_service(
+    GSList *service_list);
+
+/**
+ * Go through the manager's given service list and find the currently connecting service
+ * and return it.
+ *
+ * @param[IN]  service_list Manager's service list (wired of wifi)
+ *
+ * @return Service which is currently connecting.
+ */
+extern connman_service_t *connman_manager_get_connecting_service(
+    GSList *service_list);
+
+/**
+ * Register for manager's "properties_changed" signal, calling the provided function whenever the callback function
+ * for the signal is called
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] func User function to register
+ */
+extern void connman_manager_register_property_changed_cb(
+    connman_manager_t *manager, connman_property_changed_cb func);
+
+/**
+ * Register for manager's state changed case, calling the provided function whenever the callback function
+ * for the signal is called
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] func User function to register
+ */
+extern void connman_manager_register_services_changed_cb(
+    connman_manager_t *manager, connman_services_changed_cb func);
+
+/**
+ * Register a agent instance on the specified dbus path with the manager
+ *
+ * @param[IN] DBus object path where the agents is available
+ *
+ * @return TRUE, if agent was successfully registered with the manager, FALSE otherwise.
+ **/
+extern gboolean connman_manager_register_agent(connman_manager_t *manager,
+        const gchar *path);
+
+/**
+ * Unegister a agent instance on the specified dbus path from the manager
+ *
+ * @param[IN] DBus object path where the agents is available
+ *
+ * @return TRUE, if agent was successfully unregistered from the manager, FALSE otherwise.
+ **/
+extern gboolean connman_manager_unregister_agent(connman_manager_t *manager,
+        const gchar *path);
+
+/**
+ * Register a counter instance on the specified dbus path with the manager
+ *
+ * @param[IN] DBus object path where the counter is available
+ * @param[IN] accurancy which is is specified in kilo-bytes and defines a threshold for counter updates.
+ * @param[IN] period value is in seconds
+ *
+ * @return TRUE, if counter was successfully registered with the manager, FALSE otherwise.
+ **/
+extern gboolean connman_manager_register_counter(connman_manager_t *manager,
+        const gchar *path, guint accuracy, guint period);
+
+/**
+ * Unegister a counter instance on the specified dbus path from the manager
+ *
+ * @param[IN] DBus object path where the agents is available
+ *
+ * @return TRUE, if counter was successfully unregistered from the manager, FALSE otherwise.
+ **/
+extern gboolean connman_manager_unregister_counter(connman_manager_t *manager,
+        const gchar *path);
+
+/**
+ * Create a new group
+ *
+ * @param [IN] manager A manager instance
+ * @param [IN] ssid Name of the new group
+ * @param [IN] passphrase Passphrase for the group
+ *
+ * @return TRUE, if the group creation was successful, FALSE otherwise.
+ **/
+
+extern connman_group_t *connman_manager_create_group(connman_manager_t *manager,
+        const gchar *ssid, const gchar *passphrase);
+
+/*
+ * Get the number of connected station
+ */
+extern guint connman_manager_get_sta_count(connman_manager_t *manager);
+
+/**
+ * Populate the group's peer_list field with all of the group's peers
+ *
+ * @param [IN] manager A manager instance
+ * @param [IN] group A group instance
+ *
+ * @return TRUE, if the group peers are correctly populated, FALSE otherwise.
+ **/
+
+extern gboolean connman_manager_populate_group_peers(connman_manager_t *manager,
+        connman_group_t *group);
+
+/**
+ * Register for manager's "GroupAdded" and "GroupRemoved" siganls, calling the provided function whenever the callback function
+ * for any of those signals is called
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] func User function to register
+ */
+
+extern void connman_manager_register_groups_changed_cb(connman_manager_t
+        *manager, connman_groups_changed_cb func);
+
+/**
+ * Register for manager's "TechnologyAdded" and "TechnologyRemoved" siganls, calling the provided function whenever the callback function
+ * for any of those signals is called
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] func User function to register
+ */
+
+extern void connman_manager_register_technologies_changed_cb(
+    connman_manager_t *manager, connman_technologies_changed_cb func);
+
+/**
+ * Change passphrase of a network saved by connman i.e a network settings created by connman
+ * but currently network is out of range
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] service Saved service whose passphrase needs to be changed
+ * @param[IN] passphrase The new passphrase to be saved
+ *
+ */
+
+extern gboolean connman_manager_change_saved_passphrase(
+    connman_manager_t *manager, connman_service_t *service,
+    const gchar *passphrase);
+
+/**
+ * Initialize a new manager instance and update its services and technologies list
+ */
+extern connman_manager_t *connman_manager_new(void);
+
+/**
+ * Free the manager instance
+ *
+ * @param[IN]  manager A manager instance
+ */
+extern void connman_manager_free(connman_manager_t *manager);
+
+/**
+ * Set the wca library functionpointers
+ *
+ * @param[IN] manager A manager instance
+ * @param[IN] service Saved service whose passphrase needs to be changed
+ * @param[IN] passphrase The new passphrase to be saved
+ *
+ */
+extern void set_wca_support_connman_update_callbacks(
+    wca_support_connman_update_callbacks *callbacks);
+
+#endif /* CONNMAN_MANAGER_H_ */
+
diff --git a/src/connman_service.c b/src/connman_service.c
new file mode 100644
index 0000000..3aeb41e
--- /dev/null
+++ b/src/connman_service.c
@@ -0,0 +1,1706 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_service.c
+ *
+ *   Connman service interface
+ *
+ */
+
+#include "connman_service.h"
+#include "connman_manager.h"
+#include "utils.h"
+#include "logging.h"
+#include "common.h"
+#include "connectionmanager_service.h"
+
+/* gdbus default timeout is 25 seconds */
+#define DBUS_CALL_TIMEOUT   (60 * 1000)
+
+/**
+ * Check if the type of the service is wifi (see header for API details)
+ */
+
+gboolean connman_service_type_wifi(connman_service_t *service)
+{
+	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_WIFI);
+}
+
+/**
+ * Check if the type of the service is ethernet (see header for API details)
+ */
+
+gboolean connman_service_type_ethernet(connman_service_t *service)
+{
+	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_ETHERNET);
+}
+
+/**
+ * Check if the type of the service is wifi (see header for API details)
+ */
+
+gboolean connman_service_type_p2p(connman_service_t *service)
+{
+	return (NULL != service) && (CONNMAN_SERVICE_TYPE_P2P == service->type);
+}
+
+/**
+* Check if the type of the service is wan (see header for API details)
+*/
+
+gboolean connman_service_type_wan(connman_service_t *service)
+{
+	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_CELLULAR);
+}
+
+/**
+* Check if the type of the service is bluetooth (see header for API details)
+*/
+
+gboolean connman_service_type_bluetooth(connman_service_t *service)
+{
+	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_BLUETOOTH);
+}
+
+/**
+ * @brief Gets hostroutes for the connman service
+ */
+
+gboolean connman_service_set_hostroutes(connman_service_t *service,
+                                        GStrv hostroutes)
+{
+	if (NULL == service || NULL == hostroutes)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "HostRoutes.Configuration",
+	        g_variant_new_variant(g_variant_new_strv((const gchar * const *)hostroutes,
+	                              g_strv_length(hostroutes))), NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_WAN_SET_HOSTROUTE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Map the service connection status to corresponding webos state
+ * (see header for API details)
+ */
+
+gchar *connman_service_get_webos_state(int connman_state)
+{
+	switch (connman_state)
+	{
+		case CONNMAN_SERVICE_STATE_DISCONNECT:
+		case CONNMAN_SERVICE_STATE_IDLE:
+			return "notAssociated";
+
+		case CONNMAN_SERVICE_STATE_ASSOCIATION:
+			return "associating";
+
+		case CONNMAN_SERVICE_STATE_CONFIGURATION:
+			return "associated";
+
+		case CONNMAN_SERVICE_STATE_READY:
+		case CONNMAN_SERVICE_STATE_ONLINE:
+			return "ipConfigured";
+
+		case CONNMAN_SERVICE_STATE_FAILURE:
+			return "ipFailed";
+
+		default:
+			break;
+	}
+
+	return "notAssociated";
+}
+
+/**
+ * Convert the connection state string to its enum value
+ * (see header for API details)
+ */
+
+int connman_service_get_state(const gchar *state)
+{
+	int result = CONNMAN_SERVICE_STATE_IDLE;
+
+	if (NULL == state)
+	{
+		return result;
+	}
+
+	if (!g_strcmp0(state, "idle"))
+	{
+		result = CONNMAN_SERVICE_STATE_IDLE;
+	}
+	else if (!g_strcmp0(state, "association"))
+	{
+		result = CONNMAN_SERVICE_STATE_ASSOCIATION;
+	}
+	else if (!g_strcmp0(state, "configuration"))
+	{
+		result = CONNMAN_SERVICE_STATE_CONFIGURATION;
+	}
+	else if (!g_strcmp0(state, "ready"))
+	{
+		result = CONNMAN_SERVICE_STATE_READY;
+	}
+	else if (!g_strcmp0(state, "online"))
+	{
+		result = CONNMAN_SERVICE_STATE_ONLINE;
+	}
+	else if (!g_strcmp0(state, "disconnect"))
+	{
+		result = CONNMAN_SERVICE_STATE_DISCONNECT;
+	}
+	else if (!g_strcmp0(state, "failure"))
+	{
+		result = CONNMAN_SERVICE_STATE_FAILURE;
+	}
+
+	return result;
+}
+
+/**
+ * @brief Unset the changed field for a specific category
+ *
+ * @param service Service object to operate on
+ * @param category Category which should not be marked as changed anymore
+ */
+
+void connman_service_unset_changed(connman_service_t *service,
+                                   unsigned int category)
+{
+	service->change_mask &= ~category;
+}
+
+/**
+ * @brief Set the changed field for a specific category
+ *
+ * @param service Service object to operate on
+ * @param category Category which should be marked as changed.
+ */
+
+void connman_service_set_changed(connman_service_t *service,
+                                 unsigned int category)
+{
+	service->change_mask |= category;
+}
+
+/**
+ * @brief Check if a specific category is marked as changed for the supplied service
+ * object
+ *
+ * @param service Service object to operate on
+ * @param category Category which should be checed
+ * @return TRUE if category is marked as changed. FALSE otherwise.
+ */
+
+gboolean connman_service_is_changed(connman_service_t *service,
+                                    unsigned int category)
+{
+	return (service->change_mask & category);
+}
+
+/**
+ * Asynchronous connect callback for a remote "connect" call
+ */
+static void connect_callback(GDBusConnection *connection, GAsyncResult *res,
+                             gpointer user_data)
+{
+	GError *error = NULL;
+	struct cb_data *cbd = user_data;
+	connman_service_t *service = cbd->user;
+	connman_service_connect_cb cb = cbd->cb;
+	gboolean ret = FALSE;
+
+	if (NULL == service->cancellable ||
+	        g_cancellable_is_cancelled(service->cancellable))
+	{
+		if (service->cancellable != NULL)
+		{
+			g_object_unref(service->cancellable);
+			service->cancellable = NULL;
+		}
+
+		if (cb != NULL)
+		{
+			cb(ret, cbd->data);
+		}
+
+		g_free(cbd);
+		return;
+	}
+
+	ret = connman_interface_service_call_connect_finish(service->remote, res,
+	        &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_CONNECT_ERROR, error->message);
+
+		/* If the error is "AlreadyConnected" its not an error */
+		if (NULL != g_strrstr(error->message, "AlreadyConnected"))
+		{
+			ret = TRUE;
+		}
+
+		g_error_free(error);
+	}
+
+	if (cb != NULL)
+	{
+		cb(ret, cbd->data);
+	}
+
+	g_free(cbd);
+
+	g_object_unref(service->cancellable);
+	service->cancellable = NULL;
+}
+
+/**
+ * Connect to a remote connman service (see header for API details)
+ */
+
+gboolean connman_service_connect(connman_service_t *service,
+                                 connman_service_connect_cb cb, gpointer user_data)
+{
+	struct cb_data *cbd;
+
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	service->disconnecting = FALSE;
+	cbd = cb_data_new(cb, user_data);
+	cbd->user = service;
+	service->cancellable = g_cancellable_new();
+
+	connman_interface_service_call_connect(service->remote, service->cancellable,
+	                                       (GAsyncReadyCallback) connect_callback, cbd);
+	return TRUE;
+}
+
+
+/**
+ * Disconnect from a remote connman service (see header for API details)
+ */
+
+gboolean connman_service_disconnect(connman_service_t *service)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	service->disconnecting = TRUE;
+	connman_interface_service_call_disconnect_sync(service->remote, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_DISCONNECT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Remove a remote connman service (see header for API details)
+ */
+
+gboolean connman_service_remove(connman_service_t *service)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	service->disconnecting = TRUE;
+	connman_interface_service_call_remove_sync(service->remote, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_REMOVE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Sets ipv6 properties for the connman service (see header for API details)
+ */
+
+gboolean connman_service_set_ipv6(connman_service_t *service, ipv6info_t *ipv6)
+{
+	if (NULL == service || NULL == ipv6)
+	{
+		return FALSE;
+	}
+
+	GVariantBuilder *ipv6_b;
+	GVariant *ipv6_v;
+
+	ipv6_b = g_variant_builder_new(G_VARIANT_TYPE("a{sv}"));
+
+	if (NULL != ipv6->method)
+	{
+		g_variant_builder_add(ipv6_b, "{sv}", "Method",
+		                      g_variant_new_string(ipv6->method));
+	}
+
+	if (NULL != ipv6->address)
+	{
+		g_variant_builder_add(ipv6_b, "{sv}", "Address",
+		                      g_variant_new_string(ipv6->address));
+	}
+
+	if (ipv6->prefix_length >= 0 && ipv6->prefix_length <= 128)
+	{
+		g_variant_builder_add(ipv6_b, "{sv}", "PrefixLength",
+		                      g_variant_new_byte(ipv6->prefix_length));
+	}
+
+	if (NULL != ipv6->gateway)
+	{
+		g_variant_builder_add(ipv6_b, "{sv}", "Gateway",
+		                      g_variant_new_string(ipv6->gateway));
+	}
+
+	ipv6_v = g_variant_builder_end(ipv6_b);
+	g_variant_builder_unref(ipv6_b);
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "IPv6.Configuration", g_variant_new_variant(ipv6_v), NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_SET_IPV6_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Sets ipv4 properties for the connman service (see header for API details)
+ */
+
+gboolean connman_service_set_ipv4(connman_service_t *service, ipv4info_t *ipv4)
+{
+	if (NULL == service || NULL == ipv4)
+	{
+		return FALSE;
+	}
+
+	GVariantBuilder *ipv4_b;
+	GVariant *ipv4_v;
+
+	ipv4_b = g_variant_builder_new(G_VARIANT_TYPE("a{sv}"));
+
+	if (NULL != ipv4->method)
+	{
+		g_variant_builder_add(ipv4_b, "{sv}", "Method",
+		                      g_variant_new_string(ipv4->method));
+	}
+
+	if (NULL != ipv4->address)
+	{
+		g_variant_builder_add(ipv4_b, "{sv}", "Address",
+		                      g_variant_new_string(ipv4->address));
+	}
+
+	if (NULL != ipv4->netmask)
+	{
+		g_variant_builder_add(ipv4_b, "{sv}", "Netmask",
+		                      g_variant_new_string(ipv4->netmask));
+	}
+
+	if (NULL != ipv4->gateway)
+	{
+		g_variant_builder_add(ipv4_b, "{sv}", "Gateway",
+		                      g_variant_new_string(ipv4->gateway));
+	}
+
+	ipv4_v = g_variant_builder_end(ipv4_b);
+	g_variant_builder_unref(ipv4_b);
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "IPv4.Configuration", g_variant_new_variant(ipv4_v), NULL, &error);
+	g_variant_unref(ipv4_v);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_SET_IPV4_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_service_set_proxy(connman_service_t *service, proxyinfo_t *proxyinfo)
+{
+	if (NULL == service || NULL == proxyinfo)
+	{
+		return FALSE;
+	}
+
+	GVariantBuilder *proxyinfo_b;
+	GVariant *proxyinfo_v;
+	GError *error = NULL;
+
+	proxyinfo_b = g_variant_builder_new(G_VARIANT_TYPE("a{sv}"));
+
+	if (NULL != proxyinfo->method)
+	{
+		g_variant_builder_add(proxyinfo_b, "{sv}", "Method",
+									g_variant_new_string(proxyinfo->method));
+	}
+
+	if (NULL != proxyinfo->url)
+	{
+		g_variant_builder_add(proxyinfo_b, "{sv}", "URL",
+									g_variant_new_string(proxyinfo->url));
+	}
+
+	if (NULL != proxyinfo->servers)
+	{
+		g_variant_builder_add(proxyinfo_b, "{sv}", "Servers",
+				g_variant_new_strv((const gchar * const *)proxyinfo->servers,
+					                              g_strv_length(proxyinfo->servers)));
+	}
+
+	if (NULL != proxyinfo->excludes)
+	{
+		g_variant_builder_add(proxyinfo_b, "{sv}", "Excludes",
+				g_variant_new_strv((const gchar * const *)proxyinfo->excludes,
+					                              g_strv_length(proxyinfo->excludes)));
+	}
+
+	proxyinfo_v = g_variant_builder_end(proxyinfo_b);
+	g_variant_builder_unref(proxyinfo_b);
+
+	connman_interface_service_call_set_property_sync(service->remote,
+		        "Proxy.Configuration", g_variant_new_variant(proxyinfo_v), NULL, &error);
+
+	g_variant_unref(proxyinfo_v);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_SET_PROXY_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+
+	return TRUE;
+}
+
+/**
+ * Sets nameservers for the connman service (see header for API details)
+ */
+
+gboolean connman_service_set_nameservers(connman_service_t *service, GStrv dns)
+{
+	if (NULL == service || NULL == dns)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "Nameservers.Configuration",
+	        g_variant_new_variant(g_variant_new_strv((const gchar * const *)dns,
+	                              g_strv_length(dns))), NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_SET_NAMESERVER_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Set auto-connect property for the given service (see header for API details)
+ */
+
+gboolean connman_service_set_autoconnect(connman_service_t *service,
+        gboolean value)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "AutoConnect",
+	        g_variant_new_variant(g_variant_new_boolean(value)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_AUTOCONNECT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_service_set_run_online_check(connman_service_t *service,
+        gboolean value)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "RunOnlineCheck",
+	        g_variant_new_variant(g_variant_new_boolean(value)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_RUN_ONLINE_CHECK_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_service_set_passphrase(connman_service_t *service,
+                                        gchar *passphrase)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_property_sync(service->remote,
+	        "Passphrase",
+	        g_variant_new_variant(g_variant_new_string(passphrase)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_PASSPHRASE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+gboolean compare_strv(gchar **first, gchar **second)
+{
+	guint i;
+	guint length1;
+	guint length2;
+
+	if (first == NULL && second == NULL)
+	{
+		return TRUE;
+	}
+
+	if (first == NULL || second == NULL)
+	{
+		return FALSE;
+	}
+
+	length1 = g_strv_length(first);
+	length2 = g_strv_length(second);
+
+	if (length1 != length2)
+	{
+		return FALSE;
+	}
+
+	for (i = 0; i < length1; i++)
+	{
+		if (g_strcmp0(first[i], second[i]) != 0)
+		{
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+/**
+ * Get all the network related information for a connected service (in online state)
+ * (see header for API details)
+ */
+
+gboolean connman_service_get_ipinfo(connman_service_t *service)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *properties;
+	gsize i;
+
+	connman_interface_service_call_get_properties_sync(service->remote, &properties,
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_GET_IPINFO_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (!g_strcmp0(key, "Ethernet"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+			gsize j;
+
+			for (j = 0; j < g_variant_n_children(va); j++)
+			{
+				GVariant *ethernet = g_variant_get_child_value(va, j);
+				GVariant *ekey_v = g_variant_get_child_value(ethernet, 0);
+				const gchar *ekey = g_variant_get_string(ekey_v, NULL);
+
+				if (!g_strcmp0(ekey, "Interface"))
+				{
+					GVariant *ifacev = g_variant_get_child_value(ethernet, 1);
+					GVariant *ifaceva = g_variant_get_variant(ifacev);
+
+					g_free(service->ipinfo.iface);
+					service->ipinfo.iface = g_variant_dup_string(ifaceva, NULL);
+
+					g_variant_unref(ifacev);
+					g_variant_unref(ifaceva);
+				}
+
+				g_variant_unref(ethernet);
+				g_variant_unref(ekey_v);
+			}
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
+
+		if (!g_strcmp0(key, "IPv6"))
+		{
+
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+			gsize j;
+
+			for (j = 0; j < g_variant_n_children(va); j++)
+			{
+				GVariant *ipv6 = g_variant_get_child_value(va, j);
+				GVariant *ikey_v = g_variant_get_child_value(ipv6, 0);
+				const gchar *ikey = g_variant_get_string(ikey_v, NULL);
+
+				if (!g_strcmp0(ikey, "Method"))
+				{
+					GVariant *methodv = g_variant_get_child_value(ipv6, 1);
+					GVariant *methodva = g_variant_get_variant(methodv);
+
+					g_free(service->ipinfo.ipv6.method);
+					service->ipinfo.ipv6.method = g_variant_dup_string(methodva, NULL);
+
+					g_variant_unref(methodv);
+					g_variant_unref(methodva);
+				}
+
+				if (!g_strcmp0(ikey, "PrefixLength"))
+				{
+					GVariant *prefix_lengthv = g_variant_get_child_value(ipv6, 1);
+					GVariant *prefix_lengthva = g_variant_get_variant(prefix_lengthv);
+					const char *prefix_length = g_variant_get_data(prefix_lengthva);
+
+					service->ipinfo.ipv6.prefix_length = *prefix_length;
+
+					g_variant_unref(prefix_lengthv);
+					g_variant_unref(prefix_lengthva);
+				}
+
+				if (!g_strcmp0(ikey, "Address"))
+				{
+					GVariant *addressv = g_variant_get_child_value(ipv6, 1);
+					GVariant *addressva = g_variant_get_variant(addressv);
+
+					g_free(service->ipinfo.ipv6.address);
+					service->ipinfo.ipv6.address = g_variant_dup_string(addressva, NULL);
+
+					g_variant_unref(addressv);
+					g_variant_unref(addressva);
+				}
+
+				if (!g_strcmp0(ikey, "Gateway"))
+				{
+					GVariant *gatewayv = g_variant_get_child_value(ipv6, 1);
+					GVariant *gatewayva = g_variant_get_variant(gatewayv);
+
+					g_free(service->ipinfo.ipv6.gateway);
+					service->ipinfo.ipv6.gateway = g_variant_dup_string(gatewayva, NULL);
+
+					g_variant_unref(gatewayv);
+					g_variant_unref(gatewayva);
+				}
+
+				g_variant_unref(ipv6);
+				g_variant_unref(ikey_v);
+			}
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+
+		}
+
+		if (!g_strcmp0(key, "IPv4"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+			gsize j;
+
+			for (j = 0; j < g_variant_n_children(va); j++)
+			{
+				GVariant *ipv4 = g_variant_get_child_value(va, j);
+				GVariant *ikey_v = g_variant_get_child_value(ipv4, 0);
+				const gchar *ikey = g_variant_get_string(ikey_v, NULL);
+
+				if (!g_strcmp0(ikey, "Method"))
+				{
+					GVariant *methodv = g_variant_get_child_value(ipv4, 1);
+					GVariant *methodva = g_variant_get_variant(methodv);
+
+					g_free(service->ipinfo.ipv4.method);
+					service->ipinfo.ipv4.method = g_variant_dup_string(methodva, NULL);
+
+					g_variant_unref(methodv);
+					g_variant_unref(methodva);
+				}
+
+				if (!g_strcmp0(ikey, "Netmask"))
+				{
+					GVariant *netmaskv = g_variant_get_child_value(ipv4, 1);
+					GVariant *netmaskva = g_variant_get_variant(netmaskv);
+
+					g_free(service->ipinfo.ipv4.netmask);
+					service->ipinfo.ipv4.netmask = g_variant_dup_string(netmaskva, NULL);
+
+					g_variant_unref(netmaskv);
+					g_variant_unref(netmaskva);
+				}
+
+				if (!g_strcmp0(ikey, "Address"))
+				{
+					GVariant *addressv = g_variant_get_child_value(ipv4, 1);
+					GVariant *addressva = g_variant_get_variant(addressv);
+
+					g_free(service->ipinfo.ipv4.address);
+					service->ipinfo.ipv4.address = g_variant_dup_string(addressva, NULL);
+
+					g_variant_unref(addressv);
+					g_variant_unref(addressva);
+				}
+
+				if (!g_strcmp0(ikey, "Gateway"))
+				{
+					GVariant *gatewayv = g_variant_get_child_value(ipv4, 1);
+					GVariant *gatewayva = g_variant_get_variant(gatewayv);
+
+					g_free(service->ipinfo.ipv4.gateway);
+					service->ipinfo.ipv4.gateway = g_variant_dup_string(gatewayva, NULL);
+
+					g_variant_unref(gatewayv);
+					g_variant_unref(gatewayva);
+				}
+
+				g_variant_unref(ipv4);
+				g_variant_unref(ikey_v);
+			}
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
+
+		if (!g_strcmp0(key, "Nameservers"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+
+			g_strfreev(service->ipinfo.dns);
+			service->ipinfo.dns = g_variant_dup_strv(va, NULL);
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
+
+		if (!g_strcmp0(key, "HostRoutes"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+
+			g_strfreev(service->hostroutes);
+			service->hostroutes = g_variant_dup_strv(va, NULL);
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+	}
+
+	g_variant_unref(properties);
+
+	return TRUE;
+}
+
+/**
+ * Get all the proxy related information for a connected service
+ * (see header for API details)
+ */
+
+gboolean connman_service_get_proxyinfo(connman_service_t *service)
+{
+
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *properties;
+	gsize i;
+
+	connman_interface_service_call_get_properties_sync(service->remote, &properties,
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_GET_IPINFO_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (!g_strcmp0(key, "Proxy"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+			gsize j;
+
+			for (j = 0; j < g_variant_n_children(va); j++)
+			{
+				GVariant *proxy = g_variant_get_child_value(va, j);
+				GVariant *pkey_v = g_variant_get_child_value(proxy, 0);
+				const gchar *pkey = g_variant_get_string(pkey_v, NULL);
+
+				if (!g_strcmp0(pkey, "Method"))
+				{
+					GVariant *methodv = g_variant_get_child_value(proxy, 1);
+					GVariant *methodva = g_variant_get_variant(methodv);
+
+					g_free(service->proxyinfo.method);
+					service->proxyinfo.method = g_variant_dup_string(methodva, NULL);
+
+					g_variant_unref(methodv);
+					g_variant_unref(methodva);
+				}
+
+				if (!g_strcmp0(pkey, "URL"))
+				{
+					GVariant *urlv = g_variant_get_child_value(proxy, 1);
+					GVariant *urlva = g_variant_get_variant(urlv);
+
+					g_free(service->proxyinfo.url);
+					service->proxyinfo.url = g_variant_dup_string(urlva, NULL);
+
+					g_variant_unref(urlv);
+					g_variant_unref(urlva);
+				}
+
+				if (!g_strcmp0(pkey, "Servers"))
+				{
+					GVariant *serversv = g_variant_get_child_value(proxy, 1);
+					GVariant *serversva = g_variant_get_child_value(serversv, 0);
+
+					g_strfreev(service->proxyinfo.servers);
+					service->proxyinfo.servers = g_variant_dup_strv(serversva, NULL);
+
+					g_variant_unref(serversv);
+					g_variant_unref(serversva);
+				}
+
+				if (!g_strcmp0(pkey, "Excludes"))
+				{
+					GVariant *excludesv = g_variant_get_child_value(proxy, 1);
+					GVariant *excludesva = g_variant_get_child_value(excludesv, 0);
+
+					g_strfreev(service->proxyinfo.excludes);
+					service->proxyinfo.excludes = g_variant_dup_strv(excludesva, NULL);
+
+					g_variant_unref(excludesv);
+					g_variant_unref(excludesva);
+				}
+
+				g_variant_unref(proxy);
+				g_variant_unref(pkey_v);
+			}
+
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+	}
+
+	g_variant_unref(properties);
+
+	return TRUE;
+}
+
+/**
+ * @brief Check service->state is changed
+ */
+
+static void connman_service_advance_state(connman_service_t *service,
+                                                 GVariant *v)
+{
+	if (service == NULL)
+	{
+		return;
+	}
+
+	const char* new_state = g_variant_get_string(v, NULL);
+
+	/* While disconnecting on dual-stack IP, service goes to ready and then
+	 * to disconnected.
+	 * Do not notify service state while disconnecting and in ready/online */
+	if (service->disconnecting &&
+	    g_strcmp0(new_state, "ready") &&
+	    g_strcmp0(new_state, "online"))
+	{
+		service->disconnecting = FALSE;
+		return;
+	}
+
+	if (g_strcmp0(service->state, new_state) != 0)
+	{
+		WCALOG_DEBUG("Service %s State changed to %s", service->path, new_state);
+		g_free(service->state);
+		service->state = g_strdup(new_state);
+
+		connman_service_set_changed(service,
+		                            CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS |
+		                            CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS);
+
+		if (NULL != service->handle_property_change_fn)
+		{
+			(service->handle_property_change_fn)((gpointer) service, "State", v);
+		}
+	}
+}
+
+
+/**
+ * @brief Check service->online is changed
+ */
+
+static void connman_service_advance_online_state(connman_service_t *service,
+        GVariant *va)
+{
+	if (service == NULL)
+	{
+		return;
+	}
+
+	gboolean old_online = service->online;
+	service->online = g_variant_get_boolean(va);
+
+	if (old_online != service->online)
+	{
+		WCALOG_DEBUG("Service %s Online changed to %s", service->path, service->online ? "yes" : "no");
+		connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+
+		if (NULL != service->handle_property_change_fn)
+		{
+			(service->handle_property_change_fn)((gpointer)service, "Online", va);
+		}
+		else if (connman_service_type_ethernet(service))
+			connectionmanager_send_status_to_subscribers();
+	}
+}
+
+/**
+ * Callback for service's "property_changed" signal
+ */
+
+static void
+property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
+                    GVariant *v,
+                    connman_service_t      *service)
+{
+	GVariant *va = g_variant_get_variant(v);
+	WCALOG_DEBUG("Property %s updated for service %s", property, service->name);
+
+	if (connman_update_callbacks->service_property_changed)
+	{
+		connman_update_callbacks->service_property_changed(service->path, property,
+		        va);
+	}
+
+	if (!g_strcmp0(property, "State"))
+	{
+		connman_service_advance_state(service, va);
+	}
+	else if (!g_strcmp0(property, "Strength"))
+	{
+		guchar strength = g_variant_get_byte(va);
+
+		if (strength != service->strength)
+		{
+			service->strength = strength;
+			connman_service_set_changed(service,
+			                            CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS);
+		}
+	}
+	else if (!g_strcmp0(property, "Online"))
+	{
+		connman_service_advance_online_state(service, va);
+	}
+	else if (!g_strcmp0(property, "RunOnlineCheck"))
+	{
+		if (service->online_checking != g_variant_get_boolean(va))
+		{
+			service->online_checking = g_variant_get_boolean(va);
+			connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+			connectionmanager_send_status_to_subscribers();
+		}
+	}
+	else if (!g_strcmp0(property, "AutoConnect"))
+	{
+		service->auto_connect = g_variant_get_boolean(va);
+	}
+	else if (!g_strcmp0(property, "Favorite"))
+	{
+		service->favorite = g_variant_get_boolean(va);
+	}
+	else if (!g_strcmp0(property, "Error"))
+	{
+		g_free(service->error);
+		service->error = g_variant_dup_string(va, NULL);
+	}
+	else if (!g_strcmp0(property, "P2PGONegRequested"))
+	{
+		int wpstype = g_variant_get_int32(va);
+
+		if (NULL != service->handle_p2p_request_fn)
+		{
+			service->handle_p2p_request_fn((gpointer)service, wpstype, NULL, NULL,
+			                               "P2PGONegRequested");
+		}
+	}
+	else if (!g_strcmp0(property, "P2PProvDiscRequestedPBC"))
+	{
+		if (NULL != service->handle_p2p_request_fn)
+		{
+			service->handle_p2p_request_fn((gpointer)service, WPS_PBC, NULL, NULL,
+			                               "P2PProvDiscRequestedPBC");
+		}
+	}
+	else if (!g_strcmp0(property, "P2PProvDiscRequestedEnterPin"))
+	{
+		if (NULL != service->handle_p2p_request_fn)
+		{
+			service->handle_p2p_request_fn((gpointer)service, WPS_KEYPAD, NULL, NULL,
+			                               "P2PProvDiscRequestedEnterPin");
+		}
+	}
+	else if (!g_strcmp0(property, "P2PProvDiscRequestedDisplayPin"))
+	{
+		const gchar *wpspin = g_variant_get_string(va, NULL);
+
+		if (NULL != service->handle_p2p_request_fn)
+		{
+			service->handle_p2p_request_fn((gpointer)service, WPS_DISPLAY, wpspin, NULL,
+			                               "P2PProvDiscRequestedDisplayPin");
+		}
+	}
+	else if (!g_strcmp0(property, "P2PInvitationReceived"))
+	{
+		const gchar *goaddr = g_variant_get_string(va, NULL);
+
+		if (NULL != service->handle_p2p_request_fn)
+		{
+			service->handle_p2p_request_fn((gpointer)service, 0, NULL, goaddr,
+			                               "P2PInvitationReceived");
+		}
+	}
+	else if (!g_strcmp0(property, "P2PPersistentReceived"))
+	{
+		const gchar *goaddr = g_variant_get_string(va, NULL);
+
+		if (NULL != service->handle_p2p_request_fn)
+		{
+			service->handle_p2p_request_fn((gpointer)service, 0, NULL, goaddr,
+			                               "P2PPersistentReceived");
+		}
+	}
+	else if (!g_strcmp0(property, "IPv6"))
+	{
+		connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+		connectionmanager_send_status_to_subscribers();
+	}
+	else if (!g_strcmp0(property, "Proxy"))
+	{
+		connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+		connectionmanager_send_status_to_subscribers();
+	}
+
+	g_variant_unref(va);
+}
+
+/**
+ * Register for service's property changed signal  (see header for API details)
+ */
+void connman_service_register_property_changed_cb(connman_service_t *service,
+        connman_property_changed_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	service->handle_property_change_fn = func;
+}
+
+/**
+ * Reject incoming P2P connection from another peer device (see header for API details)
+ */
+
+gboolean connman_service_reject_peer(connman_service_t *service)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_reject_peer_sync(service->remote, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_REJECT_PEER_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Register for incoming P2P requests  (see header for API details)
+ */
+void connman_service_register_p2p_requests_cb(connman_service_t *service,
+        connman_p2p_request_cb func)
+{
+	if (NULL == func)
+	{
+		return;
+	}
+
+	service->handle_p2p_request_fn = func;
+}
+
+/**
+ * Retrieve the list of properties for a service (see header for API details)
+ */
+GVariant *connman_service_fetch_properties(connman_service_t *service)
+{
+	GError *error = NULL;
+	GVariant *properties;
+
+	if (NULL == service)
+	{
+		return NULL;
+	}
+
+	connman_interface_service_call_get_properties_sync(service->remote, &properties,
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_FETCH_PROPERTIES_ERROR, error->message);
+		g_error_free(error);
+		return NULL;
+	}
+
+	return properties;
+}
+
+/**
+ * @brief Convert received and stored WiFi ssid again to valid utf8 after the system UI
+ * locale has changed.
+ *
+ * @param service Service object to do the conversion for.
+ */
+
+void connman_service_update_display_name(connman_service_t *service)
+{
+	if (!service || !service->ssid)
+	{
+		return;
+	}
+
+	g_free(service->display_name);
+
+	/* if ssid is UTF-8, do not covert using system UI locale */
+	if (g_utf8_validate((const gchar*)service->ssid, service->ssid_len, NULL) == TRUE) {
+		WCALOG_INFO("SSID_CONVERSION", 0, "SSID is pure UTF-8");
+		service->display_name = g_strdup(service->ssid);
+		return;
+	}
+
+	/* if ssid is non UTF-8, convert using system UI locale */
+	const char *system_locale = get_current_system_locale();
+	WCALOG_INFO("SSID_CONVERSION", 0, "Found a SSID which isn't pure UTF-8: Initiate SSID converting using %s...", system_locale);
+	service->display_name = convert_ssid_to_utf8(service->ssid, service->ssid_len,
+	                        system_locale);
+	WCALOG_INFO("SSID_CONVERSION", 0, "Convert result: service->ssid: %s --> service->display_name: %s", service->ssid, service->display_name);
+}
+
+/**
+ * Update service properties from the supplied variant  (see header for API details)
+ */
+
+void connman_service_update_properties(connman_service_t *service,
+                                       GVariant *properties)
+{
+	if (NULL == service || NULL == properties)
+	{
+		return;
+	}
+
+	WCALOG_DEBUG("Updating service %s", service->path);
+
+	gsize i;
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		GVariant *val_v = g_variant_get_child_value(property, 1);
+		GVariant *val = g_variant_get_variant(val_v);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (!g_strcmp0(key, "Name"))
+		{
+			char *name =  g_variant_dup_string(val, NULL);
+
+			if (g_strcmp0(name, service->name) != 0)
+			{
+				connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS |
+				                            CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS);
+			}
+
+			g_free(service->name);
+			service->name = name;
+		}
+		else if (!g_strcmp0(key, "WiFi.SSID") &&
+		         g_variant_is_of_type(val, G_VARIANT_TYPE_BYTESTRING))
+		{
+			const gchar *data = g_variant_get_data(val);
+			service->ssid_len = g_variant_get_size(val);
+			g_free(service->ssid);
+			service->ssid = g_new(gchar, service->ssid_len + 1);
+			g_strlcpy(service->ssid, data, service->ssid_len + 1);
+
+			connman_service_update_display_name(service);
+		}
+		else if (!g_strcmp0(key, "Type"))
+		{
+			const gchar *v = g_variant_get_string(val, NULL);
+
+			if (!g_strcmp0(v, "wifi"))
+			{
+				service->type = CONNMAN_SERVICE_TYPE_WIFI;
+			}
+			else if (!g_strcmp0(v, "ethernet"))
+			{
+				service->type = CONNMAN_SERVICE_TYPE_ETHERNET;
+			}
+			else if (!g_strcmp0(v, "Peer"))
+			{
+				service->type = CONNMAN_SERVICE_TYPE_P2P;
+			}
+			else if (!g_strcmp0(v, "cellular"))
+			{
+				service->type = CONNMAN_SERVICE_TYPE_CELLULAR;
+			}
+			else if (!g_strcmp0(v, "bluetooth"))
+			{
+				service->type = CONNMAN_SERVICE_TYPE_BLUETOOTH;
+			}
+		}
+		else if (!g_strcmp0(key, "State"))
+		{
+			connman_service_advance_state(service, val);
+
+			// TODO: this does not seem right. This method can be called for existing service as well.
+			// TODO: this is wifi specific. Move to wifi_service.c
+			// TODO: when merging with property_changed_cb use the code from there
+			// Only a hidden service gets added as a new service with "association" state
+			if (!g_strcmp0(service->state, "association"))
+			{
+				service->hidden = TRUE;
+			}
+		}
+		else if (!g_strcmp0(key, "Strength"))
+		{
+			guchar strength = g_variant_get_byte(val);
+
+			if (strength != service->strength)
+			{
+				service->strength = strength;
+				connman_service_set_changed(service,
+				                            CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS);
+			}
+		}
+		else if (!g_strcmp0(key, "Security"))
+		{
+			g_strfreev(service->security);
+			service->security = g_variant_dup_strv(val, NULL);
+		}
+		else if (!g_strcmp0(key, "AutoConnect"))
+		{
+			service->auto_connect = g_variant_get_boolean(val);
+		}
+		else if (!g_strcmp0(key, "Immutable"))
+		{
+			service->immutable = g_variant_get_boolean(val);
+		}
+		else if (!g_strcmp0(key, "Favorite"))
+		{
+			service->favorite = g_variant_get_boolean(val);
+		}
+		else if (!g_strcmp0(key, "Online"))
+		{
+			connman_service_advance_online_state(service, val);
+		}
+		else if (!g_strcmp0(key, "RunOnlineCheck"))
+		{
+			service->online_checking = g_variant_get_boolean(val);
+		}
+		else if (!g_strcmp0(key, "Address"))
+		{
+			g_free(service->address);
+			service->address = g_variant_dup_string(val, NULL);
+		}
+		else if (!g_strcmp0(key, "BSS"))
+		{
+			if (service->bss != NULL)
+			{
+				g_array_free(service->bss ,TRUE);
+				service->bss = NULL;
+			}
+
+			gsize len = g_variant_n_children(val);
+			gsize j;
+			GArray* array = g_array_sized_new(FALSE, FALSE, sizeof(bssinfo_t), len);
+
+			for (j = 0; j < len; j++)
+			{
+				/* FIXME: Remove the extra struct from connman response? */
+				GVariant *temp = g_variant_get_child_value(val, j);
+				GVariant *bss_entry = g_variant_get_child_value(temp, 0);
+				g_variant_unref(temp);
+
+				bssinfo_t bss_info;
+
+				GVariant *bss_v = g_variant_lookup_value(bss_entry, "Id", G_VARIANT_TYPE_STRING);
+				GVariant *signal_v = g_variant_lookup_value(bss_entry, "Signal", G_VARIANT_TYPE_INT32);
+				GVariant *frequency_v = g_variant_lookup_value(bss_entry, "Frequency", G_VARIANT_TYPE_INT32);
+				if (!bss_v || !signal_v  || !frequency_v)
+				{
+					WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Missing some fields in BSS section");
+				}
+
+				if (bss_v)
+				{
+					gsize length;
+					const char* bss = g_variant_get_string(bss_v, &length);
+
+					if (length > 17)
+					{
+						WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %i, truncting", length);
+					}
+
+					g_strlcpy(bss_info.bssid, bss, 18);
+					g_variant_unref(bss_v);
+				}
+				else
+				{
+					bss_info.bssid[0] = 0;
+				}
+
+				if (signal_v)
+				{
+					bss_info.signal = g_variant_get_int32(signal_v);
+					g_variant_unref(signal_v);
+				}
+				else
+				{
+					bss_info.signal = 0;
+				}
+
+				if (frequency_v)
+				{
+					bss_info.frequency = g_variant_get_int32(frequency_v);
+					g_variant_unref(frequency_v);
+				}
+				else
+				{
+					bss_info.frequency = 0;
+				}
+
+				g_variant_unref(bss_entry);
+				array = g_array_append_val(array, bss_info);
+			}
+
+			service->bss = array;
+		}
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+		g_variant_unref(val_v);
+		g_variant_unref(val);
+	}
+}
+
+gboolean connman_service_is_connected(connman_service_t *service)
+{
+	int state = connman_service_get_state(service->state);
+
+	return state == CONNMAN_SERVICE_STATE_ONLINE ||
+	       state == CONNMAN_SERVICE_STATE_READY;
+}
+
+gboolean connman_service_is_online(connman_service_t *service)
+{
+	int state = connman_service_get_state(service->state);
+
+	return state == CONNMAN_SERVICE_STATE_ONLINE;
+}
+
+/**
+ * Create a new connman service instance and set its properties  (see header for API details)
+ */
+
+connman_service_t *connman_service_new(GVariant *variant)
+{
+	if (NULL == variant)
+	{
+		return NULL;
+	}
+
+	connman_service_t *service = g_new0(connman_service_t, 1);
+
+	if (service == NULL)
+	{
+		return NULL;
+	}
+
+	GVariant *service_v = g_variant_get_child_value(variant, 0);
+	service->path = g_variant_dup_string(service_v, NULL);
+	service->identifier = strip_prefix(service->path, "/net/connman/service/");
+
+	GError *error = NULL;
+
+	service->remote = connman_interface_service_proxy_new_for_bus_sync(
+	                      G_BUS_TYPE_SYSTEM,
+	                      G_DBUS_PROXY_FLAGS_NONE,
+	                      "net.connman",
+	                      service->path,
+	                      NULL,
+	                      &error);
+
+	g_variant_unref(service_v);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_INIT_ERROR, error->message);
+		g_error_free(error);
+		g_free(service->path);
+		g_free(service);
+		return NULL;
+	}
+
+	g_dbus_proxy_set_default_timeout(service->remote, DBUS_CALL_TIMEOUT);
+
+	service->sighandler_id = g_signal_connect_data(G_OBJECT(service->remote),
+	                         "property-changed",
+	                         G_CALLBACK(property_changed_cb), service, NULL, 0);
+
+	GVariant *properties = g_variant_get_child_value(variant, 1);
+	connman_service_update_properties(service, properties);
+
+	g_variant_unref(properties);
+
+	WCALOG_DEBUG("connman_service_new name %s, path %s", service->name, service->path);
+
+	return service;
+}
+
+
+/**
+ * Free the connman service instance  (see header for API details)
+ */
+
+void connman_service_free(gpointer data, gpointer user_data)
+{
+	UNUSED(user_data);
+
+	connman_service_t *service = (connman_service_t *)data;
+
+	if (NULL != service->cancellable)
+	{
+		g_cancellable_cancel(service->cancellable);
+		/* The cancel callback will free service. */
+		return;
+	}
+
+	WCALOG_DEBUG("Service free name %s, path %s", service->name, service->path);
+
+	g_free(service->path);
+	service->path = NULL;
+
+	g_free(service->identifier);
+	service->identifier = NULL;
+
+	g_free(service->name);
+	service->name = NULL;
+
+	g_free(service->display_name);
+	service->display_name = NULL;
+
+	g_free(service->state);
+	service->state = NULL;
+
+	g_free(service->error);
+	service->error = NULL;
+
+	g_free(service->address);
+	service->address = NULL;
+
+	g_strfreev(service->security);
+	service->security = NULL;
+
+	g_free(service->ipinfo.iface);
+	g_free(service->ipinfo.ipv4.method);
+	g_free(service->ipinfo.ipv4.address);
+	g_free(service->ipinfo.ipv4.netmask);
+	g_free(service->ipinfo.ipv4.gateway);
+	g_free(service->ipinfo.ipv6.method);
+	g_free(service->ipinfo.ipv6.address);
+	g_free(service->ipinfo.ipv6.gateway);
+	g_strfreev(service->ipinfo.dns);
+
+	g_free(service->proxyinfo.method);
+	g_free(service->proxyinfo.url);
+	g_strfreev(service->proxyinfo.servers);
+	g_strfreev(service->proxyinfo.excludes);
+
+
+	g_strfreev(service->hostroutes);
+	service->hostroutes = NULL;
+
+	g_free(service->peer.address);
+	g_free(service->peer.service_discovery_response);
+
+	if (service->bss)
+	{
+		g_array_free(service->bss, TRUE);
+		service->bss = NULL;
+	}
+
+	g_free(service->ssid);
+	service->ssid = NULL;
+	service->ssid_len = 0;
+
+	if (service->sighandler_id)
+	{
+		g_signal_handler_disconnect(G_OBJECT(service->remote), service->sighandler_id);
+		service->sighandler_id = 0;
+	}
+
+	service->handle_property_change_fn = NULL;
+	service->handle_p2p_request_fn = NULL;
+
+	g_object_unref(service->remote);
+	service->remote = NULL;
+
+	g_free(service);
+}
+
diff --git a/src/connman_service.h b/src/connman_service.h
new file mode 100644
index 0000000..ce8d3aa
--- /dev/null
+++ b/src/connman_service.h
@@ -0,0 +1,469 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connman_service.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman services
+ *
+ */
+
+#ifndef CONNMAN_SERVICE_H_
+#define CONNMAN_SERVICE_H_
+
+#include "connman_common.h"
+
+typedef void (*connman_p2p_request_cb)(gpointer, const int, const gchar *,
+                                       const gchar *, const gchar *);
+
+/**
+ * IPv4 information structure for the service
+ *
+ * Includes method (dhcp/manual), ip address, netmask and gateway address
+ */
+typedef struct ipv4info
+{
+	gchar *method;
+	gchar *address;
+	gchar *netmask;
+	gchar *gateway;
+} ipv4info_t;
+
+/**
+ * IPv6 information structure for the service
+ *
+ * Includes method (auto/manual), ip address, prefix length and gateway address
+ */
+typedef struct ipv6info
+{
+	gchar *method;
+	gchar *address;
+	gint prefix_length;
+	gchar *gateway;
+} ipv6info_t;
+
+/**
+ * IP information for the service
+ *
+ * Includes interface name and dns server list along with IPv4 information
+ */
+typedef struct ipinfo
+{
+	gchar *iface;
+	ipv4info_t ipv4;
+	GStrv dns;
+	ipv6info_t ipv6;
+} ipinfo_t;
+
+/**
+ * Proxy information for the service
+ *
+ */
+typedef struct proxyinfo
+{
+	gchar *method;
+	gchar *url;
+	GStrv servers;
+	GStrv excludes;
+} proxyinfo_t;
+
+/**
+ * BSSinformation for the service
+ *
+ */
+typedef struct bssinfo
+{
+	gchar bssid[18]; /* "20:AA:4B:DB:C5:A8" */
+	gint signal;
+	gint frequency;
+} bssinfo_t;
+
+typedef struct peer
+{
+	gchar *address;
+	gboolean group_owner;
+	gboolean wfd_enabled;
+	gboolean wfd_sessionavail;
+	gboolean wfd_cpsupport;
+	guint16 config_method;
+	connman_wfd_dev_type wfd_devtype;
+	guint32 wfd_rtspport;
+	gchar *service_discovery_response;
+} peer_t;
+
+/**
+ * Local instance of a connman service
+ *
+ * Caches all the required information about a service
+ */
+
+/* com.webos.service.wifi/findnetworks */
+#define CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS    1
+/* com.webos.service.connectionmanager/getstatus */
+#define CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS       2
+
+typedef struct connman_service
+{
+	/** Remote instance */
+	ConnmanInterfaceService *remote;
+	gchar *path;
+	gchar *identifier;
+	gchar *name; /* Service name, can be null for hidden wifi networks */
+	gchar *display_name; /* Service display name, can be null for hidden wifi networks */
+	gchar *state;
+	gchar *error;
+	gchar *address;
+
+	guchar strength;
+	GStrv security;
+	gboolean auto_connect;
+	/* Set to true while service is disconnecting.
+	 * To handle intermediate state changes while disconnecting.
+	 **/
+	gboolean disconnecting;
+	gboolean immutable;
+	gboolean favorite;
+	gboolean hidden;
+	gboolean online;
+	gboolean online_checking;
+	gint type;
+	ipinfo_t ipinfo;
+	proxyinfo_t proxyinfo;
+	GStrv hostroutes;
+	gulong sighandler_id;
+	peer_t peer;
+
+	/**
+	 * Called on select properties only:
+	 * - Online
+	 * - State
+	 */
+	connman_property_changed_cb handle_property_change_fn;
+	connman_p2p_request_cb handle_p2p_request_fn;
+
+	/** Array of bssinfo */
+	GArray* bss;
+
+	/* this is a indicator for the connection manager status update wether something has
+	 * changed which needs to be send as update to the user */
+	gboolean is_changed;
+	unsigned int change_mask;
+
+	gchar *ssid; /* Wifi service ssid, can be null for hidden networks */
+	gsize ssid_len;
+	GCancellable *cancellable;
+} connman_service_t;
+
+/**
+ * Enum for service types
+ */
+typedef enum
+{
+	CONNMAN_SERVICE_TYPE_UNKNOWN = 0,
+	CONNMAN_SERVICE_TYPE_ETHERNET,
+	CONNMAN_SERVICE_TYPE_WIFI,
+	CONNMAN_SERVICE_TYPE_P2P,
+	CONNMAN_SERVICE_TYPE_CELLULAR,
+	CONNMAN_SERVICE_TYPE_BLUETOOTH,
+	CONNMAN_SERVICE_TYPE_MAX
+} connman_service_types;
+
+/**
+ * Enum for service states
+ */
+enum
+{
+	CONNMAN_SERVICE_STATE_UNKNOWN       = 0,
+	CONNMAN_SERVICE_STATE_IDLE,
+	CONNMAN_SERVICE_STATE_ASSOCIATION,
+	CONNMAN_SERVICE_STATE_CONFIGURATION,
+	CONNMAN_SERVICE_STATE_READY,
+	CONNMAN_SERVICE_STATE_ONLINE,
+	CONNMAN_SERVICE_STATE_DISCONNECT,
+	CONNMAN_SERVICE_STATE_FAILURE
+};
+
+#define WPS_DISPLAY 1
+#define WPS_PBC 4
+#define WPS_KEYPAD  5
+
+/**
+ * Callback function letting callers handle remote "connect" call responses
+ */
+typedef void (*connman_service_connect_cb)(gboolean success,
+        gpointer user_data);
+
+/**
+ * Check if the type of the service is wifi
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return TRUE if the service has "wifi" type
+ */
+extern gboolean connman_service_type_wifi(connman_service_t *service);
+
+/**
+ * Check if the type of the service is ethernet
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return TRUE if the service has "ethernet" type
+ */
+extern gboolean connman_service_type_ethernet(connman_service_t *service);
+
+/**
+ * Check if the type of the service is p2p
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return TRUE if the service has "Peer" type
+ */
+extern gboolean connman_service_type_p2p(connman_service_t *service);
+
+/**
+* Check if the type of the service is wan
+*
+* @param[IN]  service A service instance
+*
+* @return TRUE if the service has "wan" type
+*/
+extern gboolean connman_service_type_wan(connman_service_t *service);
+
+/**
+* Check if the type of the service is bluetooth
+*
+* @param[IN]  service A service instance
+*
+* @return TRUE if the service has "bluetooth" type
+*/
+extern gboolean connman_service_type_bluetooth(connman_service_t *service);
+
+/**
+ * Stringify the service connection status to corresponding webos state
+ * This function is required to send appropriate connection status to the webos world.
+ *
+ * @param[IN]  connman_state Enum representing service state
+ *
+ * @return String representing connection state in webos world.
+ */
+extern gchar *connman_service_get_webos_state(int connman_state);
+
+/**
+ * Convert the connection state string to its enum value
+ *
+ * @param[IN]  state String from service's "State" property
+ *
+ * @return Enum value
+ */
+extern int connman_service_get_state(const gchar *state);
+
+/**
+ * Connect to a remote connman service
+ *
+ * @param[IN]  service A service instance (to connect)
+ * @param[IN]  cb Callback called when connect call returns
+ * @param[IN]  user_data User data (if any) to pass with the callback function
+ *             See "connman_service_connect_cb" function pointer above
+ *
+ * @return FALSE if the connect call failed , TRUE otherwise
+ */
+extern gboolean connman_service_connect(connman_service_t *service,
+                                        connman_service_connect_cb cb, gpointer user_data);
+
+/**
+ * Disconnect from a remote connman service
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return FALSE if the disconnect call failed, TRUE otherwise
+ */
+extern gboolean connman_service_disconnect(connman_service_t *service);
+
+/**
+ * Reject incoming P2P connection from another peer device
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return FALSE if the disconnect call failed, TRUE otherwise
+ */
+extern gboolean connman_service_reject_peer(connman_service_t *service);
+
+/**
+ * remove a remote connman service
+ *
+ * @param[in]  service a service instance
+ *
+ * @return false if the remove call failed, true otherwise
+ */
+extern gboolean connman_service_remove(connman_service_t *service);
+
+
+/**
+ * @brief  Sets ipv4 properties for the connman service
+ *
+ * @param[IN]  service A service instance
+ * @param[IN]  ipv4 Ipv4 structure
+ *
+ * @return FALSE if the call to set "IPv4.Configuration" property failed, TRUE otherwise
+ */
+extern gboolean connman_service_set_ipv4(connman_service_t *service,
+        ipv4info_t *ipv4);
+
+/**
+ * @brief  Sets ipv6 properties for the connman service
+ *
+ * @param[IN]  service A service instance
+ * @param[IN]  ipv4 Ipv6 structure
+ *
+ * @return FALSE if the call to set "IPv6.Configuration" property failed, TRUE otherwise
+ */
+extern gboolean connman_service_set_ipv6(connman_service_t *service, ipv6info_t *ipv6);
+
+/**
+ * @brief  Sets proxy properties for the connman service
+ *
+ * @param[IN]  service A service instance
+ * @param[IN]  proxyinfo proxyinfo structure
+ *
+ * @return FALSE if the call to set "Proxy.Configuration" property failed, TRUE otherwise
+ */
+extern gboolean connman_service_set_proxy(connman_service_t *service,
+        proxyinfo_t *proxyinfo);
+
+/**
+ * @brief  Sets nameservers for the connman service
+ *
+ * @param[IN]  service A service instance
+ * @param[IN]  dns DNS server list
+ *
+ * @return FALSE if the call to set "Nameservers.Configuration" property failed, TRUE otherwise
+ */
+extern gboolean connman_service_set_nameservers(connman_service_t *service,
+        GStrv dns);
+
+/**
+ * Set the "autoconnect" flag for a service
+ *
+ * @param[IN]  service A service instance
+ * @param[IN]  value New autoconnet value (TRUE/FALSE)
+ *
+ * @return FALSE if the call to set "AutoConnect" property failed, TRUE otherwise
+ */
+extern gboolean connman_service_set_autoconnect(connman_service_t *service,
+        gboolean value);
+
+/**
+ * Get all the network related information for a connected service (in online state)
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return FALSE if the call to get properties failed, TRUE otherwise
+ */
+extern gboolean connman_service_get_ipinfo(connman_service_t *service);
+
+/**
+ * Get all the proxy related information for a connected service
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return FALSE if the call to get properties failed, TRUE otherwise
+ */
+extern gboolean connman_service_get_proxyinfo(connman_service_t *service);
+
+/**
+ * Retrieve the list of properties for a service
+ *
+ * @param[IN] service A service instance
+ *
+ * @return GVariant pointer listing service properties, NULL if the call to
+           get service properties failed
+ */
+
+extern GVariant *connman_service_fetch_properties(connman_service_t *service);
+
+/**
+ * Update service properties from the supplied variant
+ *
+ * @param[IN] service A service instance
+ * @param[IN] service_v GVariant structure listing service properties
+ */
+extern void connman_service_update_properties(connman_service_t *service,
+        GVariant *service_v);
+
+/**
+ * Register for service's property changed signal, calling the provided function whenever the callback function
+ * for the signal is called and either the service state or online flag has changed
+ *
+ * @param[IN] service A service instance
+ * @param[IN] func User function to register
+ *
+ */
+extern void connman_service_register_property_changed_cb(
+    connman_service_t *service, connman_property_changed_cb func);
+
+/**
+ * Register for incoming P2P requests, calling the provided function whenever the callback function
+ * for the signal is called
+ *
+ * @param[IN] service A service instance
+ * @param[IN] func User function to register
+ *
+ */
+extern void connman_service_register_p2p_requests_cb(connman_service_t *service,
+        connman_p2p_request_cb func);
+
+/**
+ * Gets hostroutes for the connman service
+ *
+ * @param[IN] service A service instance
+ * @param[IN] hostroutes Hostroutes
+ */
+gboolean connman_service_set_hostroutes(connman_service_t *service, GStrv hostroutes);
+
+/**
+ * Create a new connman service instance and set its properties
+ *
+ * @param[IN] variant List of properties for a new service
+ */
+extern connman_service_t *connman_service_new(GVariant *variant);
+
+/**
+ * Free the connman service instance
+ *
+ * @param[IN] data Pointer to the service to be freed
+ * @param[IN] user_data User data if any
+ */
+extern void connman_service_free(gpointer data, gpointer user_data);
+
+extern void connman_service_unset_changed(connman_service_t *service,
+        unsigned int category);
+extern void connman_service_set_changed(connman_service_t *service,
+                                        unsigned int category);
+extern gboolean connman_service_is_changed(connman_service_t *service,
+        unsigned int category);
+extern void connman_service_update_display_name(connman_service_t *service);
+
+
+extern gboolean connman_service_set_run_online_check(connman_service_t *service,
+        gboolean value);
+extern gboolean connman_service_set_passphrase(connman_service_t *service,
+        gchar *passphrase);
+
+extern gboolean connman_service_is_connected(connman_service_t *service);
+extern gboolean connman_service_is_online(connman_service_t *service);
+
+#endif /* CONNMAN_SERVICE_H_ */
+
diff --git a/src/connman_service_discovery.c b/src/connman_service_discovery.c
new file mode 100644
index 0000000..b2cd184
--- /dev/null
+++ b/src/connman_service_discovery.c
@@ -0,0 +1,232 @@
+// Copyright (c) 2013-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_service_discovery.c
+ *
+ * @brief Connman service discovery interface
+ *
+ */
+
+#include "connman_service_discovery.h"
+#include "connman_manager.h"
+#include "common.h"
+
+#include "logging.h"
+
+static ConnmanInterfaceServiceDiscovery *sd = NULL;
+
+static gboolean get_remote_service_discovery_object(void)
+{
+	if (sd == NULL)
+	{
+		GError *error = NULL;
+		sd = connman_interface_service_discovery_proxy_new_for_bus_sync(
+		         G_BUS_TYPE_SYSTEM,
+		         G_DBUS_PROXY_FLAGS_NONE,
+		         "net.connman", "/",
+		         NULL,
+		         &error);
+
+		if (error)
+		{
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+static void
+discovery_response_cb(ConnmanInterfaceManager *proxy, const gchar *address,
+                      const gint ref, const GVariant *tlv)
+{
+	connman_service_t *service = NULL;
+	GSList *listnode = NULL;
+	gchar *tlvstr = NULL, *tmpstr = NULL;
+
+	GVariantIter *iter;
+	guchar byte;
+	g_variant_get(tlv, "ay", &iter);
+	gsize tlvstr_len = g_variant_n_children(tlv) * 3;
+	tlvstr = g_new0(gchar, tlvstr_len);
+
+	while (g_variant_iter_loop(iter, "y", &byte))
+	{
+		if (!strlen(tlvstr))
+		{
+			snprintf(tlvstr, tlvstr_len, "0%x", byte);
+		}
+		else
+		{
+			tmpstr = g_strdup(tlvstr);
+			snprintf(tlvstr, tlvstr_len, "%s 0%x", tmpstr, byte);
+			g_free(tmpstr);
+		}
+	}
+
+	g_variant_iter_free(iter);
+	g_free(tlvstr);
+}
+
+gboolean connman_service_discovery_request(const connman_service_type type,
+        const gchar *address, const gint version, const gchar *description,
+        const gchar *query)
+{
+	if (NULL == address)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	if (!get_remote_service_discovery_object())
+	{
+		return FALSE;
+	}
+
+	switch (type)
+	{
+		case CONNMAN_SERVICE_TYPE_UPNP:
+			if (NULL == description)
+			{
+				return FALSE;
+			}
+
+			connman_interface_service_discovery_call_request_discover_upn_pservice_sync(sd,
+			        address,
+			        version, description, NULL, NULL, &error);
+			break;
+
+		case CONNMAN_SERVICE_TYPE_BONJOUR:
+			if (NULL == query)
+			{
+				return FALSE;
+			}
+
+			connman_interface_service_discovery_call_request_discover_bonjour_service_sync(
+			    sd, address,
+			    query, NULL, NULL, &error);
+			break;
+
+		default:
+			return FALSE;
+	}
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_DISCOVERY_REQUEST_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_signal_connect(G_OBJECT(sd), "discovery-response",
+	                 G_CALLBACK(discovery_response_cb), NULL);
+
+	return TRUE;
+}
+
+gboolean connman_service_discovery_register(const connman_service_type type,
+        const gchar *description, const gchar *query, const gchar *response)
+{
+	GError *error = NULL;
+
+	if (!get_remote_service_discovery_object())
+	{
+		return FALSE;
+	}
+
+	switch (type)
+	{
+		case CONNMAN_SERVICE_TYPE_UPNP:
+			if (NULL == description)
+			{
+				return FALSE;
+			}
+
+			connman_interface_service_discovery_call_register_upn_pservice_sync(sd,
+			        description, NULL, &error);
+			break;
+
+		case CONNMAN_SERVICE_TYPE_BONJOUR:
+			if (NULL == query)
+			{
+				return FALSE;
+			}
+
+			connman_interface_service_discovery_call_register_bonjour_service_sync(sd,
+			        query, response, NULL, &error);
+			break;
+
+		default:
+			return FALSE;
+	}
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_DISCOVERY_REGISTER_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_service_discovery_remove(const connman_service_type type,
+        const gchar *description, const gchar *query)
+{
+	GError *error = NULL;
+
+	if (!get_remote_service_discovery_object())
+	{
+		return FALSE;
+	}
+
+	switch (type)
+	{
+		case CONNMAN_SERVICE_TYPE_UPNP:
+			if (NULL == description)
+			{
+				return FALSE;
+			}
+
+			connman_interface_service_discovery_call_remove_upn_pservice_sync(sd,
+			        description, NULL, &error);
+			break;
+
+		case CONNMAN_SERVICE_TYPE_BONJOUR:
+			if (NULL == query)
+			{
+				return FALSE;
+			}
+
+			connman_interface_service_discovery_call_remove_bonjour_service_sync(sd, query,
+			        NULL, &error);
+			break;
+
+		default:
+			return FALSE;
+	}
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_DISCOVERY_REMOVE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
diff --git a/src/connman_service_discovery.h b/src/connman_service_discovery.h
new file mode 100644
index 0000000..45ed321
--- /dev/null
+++ b/src/connman_service_discovery.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2013-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connman_service_discovery.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman service discovery object
+ *
+ */
+
+#ifndef CONNMAN_SERVICE_DISCOVERY_H_
+#define CONNMAN_SERVICE_DISCOVERY_H_
+
+#include <gio/gio.h>
+#include <glib-object.h>
+
+#include "connman_common.h"
+
+typedef enum
+{
+	CONNMAN_SERVICE_TYPE_UPNP = 0,
+	CONNMAN_SERVICE_TYPE_BONJOUR
+} connman_service_type;
+
+extern gboolean connman_service_discovery_request(const connman_service_type
+        type, const gchar *address, const gint version, const gchar *description,
+        const gchar *query);
+extern gboolean connman_service_discovery_register(const connman_service_type
+        type, const gchar *description, const gchar *query, const gchar *response);
+extern gboolean connman_service_discovery_remove(const connman_service_type
+        type, const gchar *description, const gchar *query);
+
+#endif /* CONNMAN_SERVICE_DISCOVERY_H_ */
+
diff --git a/src/connman_technology.c b/src/connman_technology.c
new file mode 100644
index 0000000..651cd1a
--- /dev/null
+++ b/src/connman_technology.c
@@ -0,0 +1,1043 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file connman_technology.c
+ *
+ * @brief Connman technology interface
+ *
+ */
+
+#include "connman_technology.h"
+#include "connman_manager.h"
+#include "logging.h"
+
+/**
+ * Power on/off the given technology (see header for API details)
+ */
+
+gboolean connman_technology_set_powered(connman_technology_t *technology,
+                                        gboolean state, bool* not_supported)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	/* don't set power again if we're already in the right power state */
+	if (state == technology->powered)
+	{
+		return TRUE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "Powered",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_POWERED_ERROR, error->message);
+
+		/**
+		 * Match error message, connman does not return error codes.
+		 * error->code is always 36.
+		 */
+		if (g_strcmp0(error->message,
+		              "GDBus.Error:net.connman.Error.NotSupported: Not supported") == 0)
+		{
+			*not_supported = true;
+		}
+
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->powered = state;
+	return TRUE;
+}
+
+/**
+ * Enable/Disable tethering the given technology (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering(connman_technology_t
+        *technology, gboolean state)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "Tethering",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->tethering = state;
+	g_usleep(1000000);
+	return TRUE;
+}
+
+/**
+ * Set the name of ssid used in tethering (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering_identifier(
+    connman_technology_t *technology, const gchar *tethering_identifier)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "TetheringIdentifier",
+	        g_variant_new_variant(g_variant_new_string(tethering_identifier)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_free(technology->tethering_identifier);
+	technology->tethering_identifier = g_strdup(tethering_identifier);
+	return TRUE;
+}
+
+/**
+ * Set the name of ssid used in tethering (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering_passphrase(
+    connman_technology_t *technology, const gchar *tethering_passphrase)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "TetheringPassphrase",
+	        g_variant_new_variant(g_variant_new_string(tethering_passphrase)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_free(technology->tethering_passphrase);
+	technology->tethering_passphrase = g_strdup(tethering_passphrase);
+	return TRUE;
+}
+
+/**
+ * Cancel any active P2P connection (see header for API details)
+ */
+
+gboolean connman_technology_cancel_p2p(connman_technology_t *technology)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_cancel_p2_p_sync(technology->remote, NULL,
+	        &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_CANCEL_P2P_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Cancel any active WPS connection (see header for API details)
+ */
+
+gboolean connman_technology_cancel_wps(connman_technology_t *technology)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_cancel_wps_sync(technology->remote, NULL,
+	        &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_CANCEL_WPS_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Start WPS authentication (see header for API details)
+ */
+
+gboolean connman_technology_start_wps(connman_technology_t *technology,
+                                      const gchar *pin)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_start_wps_sync(technology->remote,
+	        pin, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_START_WPS_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Set RemovePersistentInfo value to delete stored profiles (see header for API details)
+ */
+
+gboolean connman_technology_delete_profile(connman_technology_t *technology,
+        const gchar *address)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "RemovePersistentInfo",
+	        g_variant_new_variant(g_variant_new_string(address)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_DELETE_PROFILE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Set MultiChannelShedMode value to specified mode (see header for API details)
+ */
+
+gboolean connman_technology_set_multi_channel_mode(connman_technology_t
+        *technology, const guint32 mode)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "MultiChannelSchedMode",
+	        g_variant_new_variant(g_variant_new_uint32(mode)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_MULTI_CHANNEL_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->multi_channel_mode = mode;
+	return TRUE;
+}
+/**
+ * Set P2P state (see header for API details)
+ */
+
+gboolean connman_technology_set_p2p(connman_technology_t *technology,
+                                    gboolean state)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "P2P",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_P2P_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->p2p = state;
+	return TRUE;
+}
+
+/**
+ * Set P2P identifier (see header for API details)
+ */
+
+gboolean connman_technology_set_p2p_identifier(connman_technology_t *technology,
+        const gchar *device_name)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "P2PIdentifier",
+	        g_variant_new_variant(g_variant_new_string(device_name)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_P2P_IDENTIFIER_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_free(technology->p2p_identifier);
+	technology->p2p_identifier = g_strdup(device_name);
+	return TRUE;
+}
+
+/**
+ * Set WFD state (see header for API details)
+ */
+
+gboolean connman_technology_set_wfd(connman_technology_t *technology,
+                                    gboolean state)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "WFD",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_WFD_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->wfd = state;
+	return TRUE;
+}
+
+/**
+ * Set WFDDevType (see header for API details)
+ */
+
+gboolean connman_technology_set_wfd_devtype(connman_technology_t *technology,
+        connman_wfd_dev_type devtype)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "WFDDevType",
+	        g_variant_new_variant(g_variant_new_uint16(devtype)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_WFD_DEVTYPE_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->wfd_devtype = devtype;
+	return TRUE;
+}
+
+/**
+ * Callback for the technology scan call after it finishes
+ */
+
+static void connman_technology_scan_callback(GObject *source_object,
+        GAsyncResult *res, gpointer user_data)
+{
+	connman_technology_t *technology = user_data;
+	ConnmanInterfaceTechnology *proxy = (ConnmanInterfaceTechnology *)
+	                                    source_object;
+	GError *error = NULL;
+
+	/* Print eror if any, no functional purpose */
+	connman_interface_technology_call_scan_finish(proxy, res, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SCAN_ERROR, error->message);
+		g_error_free(error);
+	}
+
+	//Check if technology has been removed.
+	technology->calls_pending -= 1;
+	if (technology->removed)
+	{
+		if (technology->calls_pending == 0)
+		{
+			WCALOG_DEBUG("Freeing removed technology after async call");
+			connman_technology_free(technology);
+		}
+		return;
+	}
+
+	if (technology->handle_after_scan_fn)
+	{
+		technology->handle_after_scan_fn(technology->after_scan_data);
+	}
+}
+
+/**
+ * Scan the network for available services asynchronously (see header for API details)
+ */
+
+gboolean connman_technology_scan_network(connman_technology_t *technology,
+        gboolean p2p)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	technology->calls_pending += 1;
+	connman_interface_technology_call_scan(technology->remote,
+	                                       NULL, connman_technology_scan_callback,
+	                                       (gpointer)technology);
+
+	return TRUE;
+}
+
+gboolean connman_technology_remove_saved_profiles(connman_technology_t
+        *technology, gchar *exception)
+{
+	GError *error = NULL;
+
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	connman_interface_technology_call_remove_saved_services_sync(technology->remote,
+	        exception, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SAVED_SERVICES_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_technology_set_listen_params(connman_technology_t *technology,
+        const gint32 period, const gint32 interval)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GVariantBuilder *listen_params_b;
+	GVariant *listen_params_v;
+	listen_params_b = g_variant_builder_new(G_VARIANT_TYPE("a{sv}"));
+	g_variant_builder_add(listen_params_b, "{sv}", "Period",
+	                      g_variant_new_int32(period));
+	g_variant_builder_add(listen_params_b, "{sv}", "Interval",
+	                      g_variant_new_int32(interval));
+	listen_params_v = g_variant_builder_end(listen_params_b);
+	g_variant_builder_unref(listen_params_b);
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "P2PListenParams",
+	        g_variant_new_variant(listen_params_v),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_LISTEM_PARAMS_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_technology_set_listen_channel(connman_technology_t *technology,
+        const guint32 listen_channel)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "P2PListenChannel",
+	        g_variant_new_variant(g_variant_new_uint32(listen_channel)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_LISTEM_CHANNEL_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+gboolean connman_technology_set_go_intent(connman_technology_t *technology, const guint32 go_intent)
+{
+	if(NULL == technology)
+		return FALSE;
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+			"P2PGOIntent",
+			g_variant_new_variant(g_variant_new_uint32(go_intent)),
+			NULL, &error);
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_GO_INTENT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Stores new property value.
+ */
+static void set_property_value(connman_technology_t *technology,
+                               const gchar * key,
+                               GVariant *val)
+{
+	if (!g_strcmp0(key, "Type"))
+	{
+		g_free(technology->type);
+		technology->type = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "Name"))
+	{
+		g_free(technology->name);
+		technology->name = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "Powered"))
+	{
+		technology->powered = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "Connected"))
+	{
+		technology->connected = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "P2P"))
+	{
+		technology->p2p = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "P2PIdentifier"))
+	{
+		g_free(technology->p2p_identifier);
+		technology->p2p_identifier = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "WFD"))
+	{
+		technology->wfd = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "P2PListen"))
+	{
+		technology->p2p_listen = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "P2PPersistent"))
+	{
+		technology->persistent_mode = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "LegacyScan"))
+	{
+		technology->legacy_scan = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "WFDDevType"))
+	{
+		technology->wfd_devtype = (connman_wfd_dev_type) g_variant_get_uint16(val);
+	}
+	else if (!g_strcmp0(key, "WFDSessionAvail"))
+	{
+		technology->wfd_sessionavail = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "WFDCPSupport"))
+	{
+		technology->wfd_cpsupport = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "WFDRtspPort"))
+	{
+		technology->wfd_rtspport = g_variant_get_uint32(val);
+	}
+	else if (!g_strcmp0(key, "MultiChannelSchedMode"))
+	{
+		technology->multi_channel_mode = g_variant_get_uint32(val);
+	}
+	else if (!g_strcmp0(key, "DiagnosticInfo"))
+	{
+		g_free(technology->diagnostic_info);
+		technology->diagnostic_info = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "Tethering"))
+	{
+		technology->tethering = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "TetheringIdentifier"))
+	{
+		g_free(technology->tethering_identifier);
+		technology->tethering_identifier = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "TetheringPassphrase"))
+	{
+		g_free(technology->tethering_passphrase);
+		technology->tethering_passphrase = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "CountryCode"))
+	{
+		g_free(technology->country_code);
+		technology->country_code = g_variant_dup_string(val, NULL);
+	}
+}
+
+/**
+ * Callback for technology's "property_changed" signal
+ */
+static void
+property_changed_cb(ConnmanInterfaceTechnology *proxy, const gchar *property,
+                    GVariant *v, gpointer user_data)
+{
+	connman_technology_t *technology = user_data;
+
+	WCALOG_DEBUG("Property %s updated for technology %s", property,
+	             technology->name);
+	GVariant *val = g_variant_get_variant(v);
+
+	set_property_value(technology, property, val);
+
+	/** Notify wca-support */
+	if (connman_update_callbacks->technology_property_changed)
+	{
+		connman_update_callbacks->technology_property_changed(technology->path,
+		                                                      property, val);
+	}
+
+	/** Notify internal handlers */
+	if (NULL != technology->handle_property_changed_fn)
+	{
+		(technology->handle_property_changed_fn)((gpointer)technology, property, v);
+	}
+
+	g_variant_unref(val);
+}
+
+/**
+ * Get all properties for a technology.
+ * Returns the returned GVariant or null if failed.
+ * The caller needs to release the result.
+ */
+
+static GVariant* connman_technology_get_properties(connman_technology_t *technology)
+{
+	if (NULL == technology)
+	{
+		return NULL;
+	}
+
+	GError *error = NULL;
+	GVariant *properties;
+	gsize i;
+
+	connman_interface_technology_call_get_properties_sync(technology->remote,
+	        &properties, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_GET_PROPERTIES_ERROR, error->message);
+		g_error_free(error);
+		return NULL;
+	}
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		GVariant *val_v = g_variant_get_child_value(property, 1);
+		GVariant *val = g_variant_get_variant(val_v);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		set_property_value(technology, key, val);
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+		g_variant_unref(val_v);
+		g_variant_unref(val);
+	}
+
+	return properties;
+}
+
+/**
+ * Get all properties for a technology (see header for API details)
+ */
+
+gboolean connman_technology_update_properties(connman_technology_t *technology)
+{
+	GVariant *properties = connman_technology_get_properties(technology);
+
+	if (NULL == properties)
+	{
+		return FALSE;
+	}
+
+	g_variant_unref(properties);
+	return TRUE;
+}
+
+/**
+ * Get all properties for a given interface for a technology (see header for API details)
+ */
+
+gboolean connman_technology_get_interface_properties(connman_technology_t
+        *technology, const gchar *interface,
+        connman_technology_interface_t *interface_properties)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariant *properties;
+	gsize i;
+
+	connman_interface_technology_call_get_interface_properties_sync(
+	    technology->remote, interface, &properties, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_GET_INTERFACE_PROPERTIES_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	for (i = 0; i < g_variant_n_children(properties); i++)
+	{
+		GVariant *property = g_variant_get_child_value(properties, i);
+		GVariant *key_v = g_variant_get_child_value(property, 0);
+		GVariant *val_v = g_variant_get_child_value(property, 1);
+		GVariant *val = g_variant_get_variant(val_v);
+		const gchar *key = g_variant_get_string(key_v, NULL);
+
+		if (!g_strcmp0(key, "WiFi.RSSI"))
+		{
+			interface_properties->rssi = g_variant_get_uint32(val);
+		}
+
+		else if (!g_strcmp0(key, "WiFi.LinkSpeed"))
+		{
+			interface_properties->link_speed = g_variant_get_uint32(val);
+		}
+
+		else if (!g_strcmp0(key, "WiFi.Frequency"))
+		{
+			interface_properties->frequency = g_variant_get_uint32(val);
+		}
+
+		else if (!g_strcmp0(key, "WiFi.Noise"))
+		{
+			interface_properties->noise = g_variant_get_uint32(val);
+		}
+
+		g_variant_unref(property);
+		g_variant_unref(key_v);
+		g_variant_unref(val_v);
+		g_variant_unref(val);
+	}
+
+	g_variant_unref(properties);
+	return TRUE;
+}
+
+/**
+ * Register for technology's "properties_changed" signal, calling the provided function whenever the callback function
+ * for the signal is called (see header for API details)
+ */
+
+void connman_technology_register_property_changed_cb(connman_technology_t
+        *technology, connman_property_changed_cb cb)
+{
+	if (!cb || !technology)
+	{
+		return;
+	}
+
+	technology->handle_property_changed_fn = cb;
+}
+
+/**
+ * Register a handler for the technology's "TetheringStaAuthorized" signal.
+ */
+void connman_technology_register_sta_authorized_cb(connman_technology_t
+        *technology, connman_common_cb cb, gpointer user_data)
+{
+	if (!cb || !technology)
+	{
+		return;
+	}
+
+	technology->handle_sta_authorized_fn = cb;
+	technology->sta_authorized_data = user_data;
+}
+
+static void tethering_sta_authorized_cb(ConnmanInterfaceTechnology *proxy,
+                                        gpointer user_data)
+{
+	connman_technology_t *technology = user_data;
+
+	if (technology->handle_sta_authorized_fn)
+	{
+		technology->handle_sta_authorized_fn(technology->sta_authorized_data);
+	}
+}
+
+/**
+ * Register a handler for the technology's "TetheringStaUnauthorized" signal.
+ */
+void connman_technology_register_sta_deauthorized_cb(connman_technology_t
+        *technology, connman_common_cb cb, gpointer user_data)
+{
+	if (!cb || !technology)
+	{
+		return;
+	}
+
+	technology->handle_sta_deauthorized_fn = cb;
+	technology->sta_deauthorized_data = user_data;
+}
+
+static void tethering_sta_deunauthorized_cb(ConnmanInterfaceTechnology *proxy,
+        gpointer user_data)
+{
+	connman_technology_t *technology = user_data;
+
+	if (technology->handle_sta_deauthorized_fn)
+	{
+		technology->handle_sta_deauthorized_fn(technology->sta_deauthorized_data);
+	}
+}
+
+/**
+ * Create a new technology instance and set its properties (see header for API details)
+ */
+
+connman_technology_t *connman_technology_new(const gchar* path)
+{
+	if (NULL == path)
+	{
+		return NULL;
+	}
+
+	connman_technology_t *technology = g_new0(connman_technology_t, 1);
+	GError *error = NULL;
+
+	technology->path = g_strdup(path);
+
+	technology->remote = connman_interface_technology_proxy_new_for_bus_sync(
+	                         G_BUS_TYPE_SYSTEM,
+	                         G_DBUS_PROXY_FLAGS_NONE,
+	                         "net.connman",
+	                         technology->path,
+	                         NULL,
+	                         &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_INIT_ERROR, error->message);
+		g_error_free(error);
+		goto error;
+	}
+
+	technology->property_changed_sighandler = g_signal_connect_data(G_OBJECT(
+	            technology->remote), "property-changed",
+	        G_CALLBACK(property_changed_cb), technology, NULL, 0);
+
+	technology->sta_authorized_sighandler = g_signal_connect_data(G_OBJECT(
+	        technology->remote), "tethering-sta-authorized",
+	                                        G_CALLBACK(tethering_sta_authorized_cb), technology, NULL, 0);
+	technology->sta_deauthorized_sighandler = g_signal_connect_data(G_OBJECT(
+	            technology->remote), "tethering-sta-deauthorized",
+	        G_CALLBACK(tethering_sta_deunauthorized_cb), technology, NULL, 0);
+
+	/* If connman has a change in it's properties while we process the data and
+	 * before we register the signals, we do not get the update.
+	 * So, we need to get all that information from connman again.
+	 */
+	GVariant* properties = connman_technology_get_properties(technology);
+
+	if (NULL == properties)
+	{
+		goto error;
+	}
+
+	if (connman_update_callbacks->technology_added)
+	{
+		connman_update_callbacks->technology_added(technology->path, properties);
+	}
+
+	g_variant_unref(properties);
+
+	return technology;
+
+error:
+	connman_technology_free(technology);
+	return NULL;
+}
+
+/**
+ * Free the technology instance ( see header for API details)
+ * Note that this method is partially re-enterable - callback handler might re-call it.
+ *
+ */
+
+void connman_technology_free(connman_technology_t *technology)
+{
+	if (NULL == technology)
+	{
+		return;
+	}
+
+	/** Remove signal handlers even if async calls are in progress */
+	if (technology->property_changed_sighandler)
+	{
+		g_signal_handler_disconnect(G_OBJECT(technology->remote),
+		                            technology->property_changed_sighandler);
+		technology->property_changed_sighandler = 0;
+	}
+
+	if (technology->sta_authorized_sighandler)
+	{
+		g_signal_handler_disconnect(G_OBJECT(technology->remote),
+		                            technology->sta_authorized_sighandler);
+		technology->sta_authorized_sighandler = 0;
+	}
+
+	if (technology->sta_deauthorized_sighandler)
+	{
+		g_signal_handler_disconnect(G_OBJECT(technology->remote),
+		                            technology->sta_deauthorized_sighandler);
+		technology->sta_deauthorized_sighandler = 0;
+	}
+
+	/* If async call to technology is in progress, scan callback will free the technology. */
+	if (technology->calls_pending > 0)
+	{
+		WCALOG_DEBUG("Not freeing removed technology - %d async calls in progress", technology->calls_pending);
+		technology->removed = true;
+		return;
+	}
+
+	g_free(technology->path);
+	technology->path = NULL;
+	g_free(technology->type);
+	technology->type = NULL;
+	g_free(technology->name);
+	technology->name = NULL;
+	g_free(technology->p2p_identifier);
+	g_free(technology->country_code);
+	g_free(technology->diagnostic_info);
+	g_free(technology->tethering_identifier);
+	g_free(technology->tethering_passphrase);
+
+	g_object_unref(technology->remote);
+	technology->remote = NULL;
+
+	g_free(technology);
+}
diff --git a/src/connman_technology.h b/src/connman_technology.h
new file mode 100644
index 0000000..3e44edf
--- /dev/null
+++ b/src/connman_technology.h
@@ -0,0 +1,404 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  connman_technology.h
+ *
+ * @brief Header file defining functions and data structures for interacting with connman technologies
+ *
+ */
+
+
+#ifndef CONNMAN_TECHNOLOGY_H_
+#define CONNMAN_TECHNOLOGY_H_
+
+#include <gio/gio.h>
+#include <glib-object.h>
+#include <stdbool.h>
+
+#include "connman_common.h"
+
+
+
+/**
+ * Local instance of a connman technology
+ * Caches all required information for a technology
+ */
+typedef struct connman_technology
+{
+	ConnmanInterfaceTechnology *remote;
+	gchar *type;
+	gchar *name;
+	gchar *path;
+	gchar *p2p_identifier;
+	gchar *country_code;
+	gchar *diagnostic_info;
+	gchar *tethering_identifier;
+	gchar *tethering_passphrase;
+	gboolean powered;
+	gboolean connected;
+	gboolean tethering;
+	gboolean p2p;
+	gboolean wfd;
+	gboolean p2p_listen;
+	gboolean persistent_mode;
+	gboolean wfd_sessionavail;
+	gboolean wfd_cpsupport;
+	gboolean legacy_scan;
+	connman_wfd_dev_type wfd_devtype;
+	guint32 wfd_rtspport;
+	guint32 multi_channel_mode;
+	gulong property_changed_sighandler;
+	connman_property_changed_cb handle_property_changed_fn;
+	gulong sta_authorized_sighandler;
+	connman_common_cb handle_sta_authorized_fn;
+	gpointer sta_authorized_data;
+	gulong sta_deauthorized_sighandler;
+	connman_common_cb handle_sta_deauthorized_fn;
+	gpointer sta_deauthorized_data;
+	connman_common_cb handle_after_scan_fn;
+	gpointer after_scan_data;
+
+	gboolean removed; /* If true, the technology has been removed and should be deleted when callbacks complete*/
+	gint32 calls_pending; /* Number of connman DBUS calls pending. */
+} connman_technology_t;
+
+
+/*
+ * Properties for a particular interface in a given technology
+ */
+typedef struct connman_technology_interface
+{
+	guint32 rssi;
+	guint32 link_speed;
+	guint32 frequency;
+	guint32 noise;
+} connman_technology_interface_t;
+
+
+/**
+ * Power on/off the given technology
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE for power on, FALSE for off
+ * @param[OUT] not_supported is set to true if changing power mode for this
+ *             technology is not supported by connman. Left as-is otherwise.
+ *             May be NULL, if don't care about supported,
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern int connman_technology_set_powered(connman_technology_t *technology,
+        gboolean state, bool* not_supported);
+
+/**
+ * Enable/Disable tethering the given technology
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE for power on, FALSE for off
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering(connman_technology_t
+        *technology, gboolean state);
+
+/**
+ * Set the name of ssid used in tethering
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  tethering_identifier of the tethering
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering_identifier(
+    connman_technology_t *technology, const gchar *tethering_identifier);
+
+/**
+ * Set the name of passphrase used in tethering
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  tethering_passphrase of the tethering
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering_passphrase(
+    connman_technology_t *technology, const gchar *tethering_passphrase);
+
+/**
+ * Enable/disable wifi-direct technology
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE to enable P2P, FALSE otherwise
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_p2p(connman_technology_t *technology,
+        gboolean state);
+
+/**
+ * Set the name of the device used in p2p communication
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  device_name Name of the device
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_p2p_identifier(connman_technology_t
+        *technology, const gchar *device_name);
+
+/**
+ * Enable/disable WiFi Display technology
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE to enable WFD, FALSE otherwise
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_wfd(connman_technology_t *technology,
+        gboolean state);
+
+/**
+ * Set the WFD device type
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  devtype Device type enum
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_wfd_devtype(connman_technology_t
+        *technology, connman_wfd_dev_type devtype);
+
+/**
+ * Set the WFD session available bit
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  sessionavail Session available bit
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_wfd_sessionavail(
+    connman_technology_t *technology, const gboolean sessionavail);
+
+/**
+ * Set the WFD cp support bit
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  cpsupport cp support bit
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_wfd_cpsupport(connman_technology_t
+        *technology, const gboolean cpsupport);
+
+/**
+ * Set the WFD rtsp port
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  rtspport RTSP Port value
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_wfd_rtspport(connman_technology_t
+        *technology, const guint32 rtspport);
+
+/**
+ * Enable/disable P2P listen state so that it can allow incoming connections
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE to enable listen state, FALSE otherwise
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_p2p_listen_state(
+    connman_technology_t *technology, gboolean state);
+
+/**
+ * Enable/disable P2P persistent mode so that it can make persistent connections
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE to enable listen state, FALSE otherwise
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_p2p_persistent_mode(
+    connman_technology_t *technology, gboolean state);
+
+/**
+ * Cancel any active P2P connection
+ *
+ * @param[IN]  technology A technology instance
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_cancel_p2p(connman_technology_t *technology);
+
+/**
+ * Start WPS authenticaiton
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  pin Pin for WPS-PIN mode
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_start_wps(connman_technology_t *technology,
+        const gchar *pin);
+
+/**
+ * Cancel any active WPS connection
+ *
+ * @param[IN]  technology A technology instance
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_cancel_wps(connman_technology_t *technology);
+
+/**
+ * Delete stored p2p profiles
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  address Address of peer
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_delete_profile(connman_technology_t
+        *technology, const gchar *address);
+
+/**
+ * Set multi channel scheduling mode
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  mode Either of 0/1/2
+ * (0 -> fair scheduling, 1 -> Favour STA, 2-> Favour P2P)
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_multi_channel_mode(
+    connman_technology_t *technology, const guint32 mode);
+
+/**
+ * Scan the network for available services
+ * This is usually called to scan all wifi APs whenever the list of APs is requested
+ *
+ * @param[IN]  technology A technology instance
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_scan_network(connman_technology_t
+        *technology, gboolean p2p);
+
+/**
+ * Set listen channel parameter for technology
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  channel number
+
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_listen_channel(connman_technology_t *technology,
+                                               const guint32 listen_channel);
+
+
+/**
+ * Set listen interval and period.
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  listen interval in ms
+ * @param[IN]  listen period in ms.
+
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_listen_params(connman_technology_t *technology,
+                                              const gint32 period,
+                                              const gint32 interval);
+
+/**
+ * Register for technology's "properties_changed" signal, calling the provided function whenever the callback function
+ * for the signal is called
+ *
+ * @param[IN] technology A technology instance
+ * @param[IN] func User function to register
+ *
+ */
+extern void connman_technology_register_property_changed_cb(
+    connman_technology_t *technology, connman_property_changed_cb func);
+
+/**
+ * @brief Register a handler for the technology's "TetheringStaAuthorized" signal.
+ *
+ * @param[IN] technology A technology instance
+ * @param[IN] cb Handler function to register.
+ * @param[IN] user_data User data passed with the callback when called.
+ */
+extern void connman_technology_register_sta_authorized_cb(
+    connman_technology_t *technology, connman_common_cb cb, gpointer user_data);
+
+/**
+ * @brief Register a handler for the technology's "TetheringStaDeauthorized" signal.
+ *
+ * @param[IN] technology A technology instance
+ * @param[IN] cb Handler function to register.
+ * @param[IN] user_data User data passed with the callback when called.
+ */
+extern void connman_technology_register_sta_deauthorized_cb(
+    connman_technology_t *technology, connman_common_cb cb, gpointer user_data);
+
+/**
+ * Fetch all the properties for a technology instance and save the new values
+ * in technology fields.
+ *
+ * @param[IN] technology A technology instance
+ *
+ */
+extern gboolean connman_technology_update_properties(connman_technology_t *technology);
+
+/**
+ * Fetch the properties for a particular interface of a technology instance
+ *
+ * @param[IN] technology A technology instance
+ * @param[IN] interface Name of the interface
+ * @param[OUT] interface_properties Populated connman_technology_interface_t struct for the interface
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_get_interface_properties(
+    connman_technology_t *technology, const gchar *interface,
+    connman_technology_interface_t *interface_properties);
+
+/**
+ * @brief Remove all saved services (marked as favorite) but not a single one handed as exception.
+ *
+ * @param technology A technology instance
+ * @param exception Single service not to remove
+ */
+extern gboolean connman_technology_remove_saved_profiles(connman_technology_t
+        *technology, gchar *exception);
+
+/**
+ * Create a new technology instance and set its properties
+ *
+ * @param[IN]  variant List of properties for a new technology
+ *
+ */
+extern connman_technology_t *connman_technology_new(const gchar* path);
+
+/**
+ * Free the connman technology instance
+ *
+ * @param[IN] data Pointer to the technology to be freed
+ */
+
+extern void connman_technology_free(connman_technology_t *technology);
+
+#endif /* CONNMAN_TECHNOLOGY_H_ */
+
diff --git a/src/errors.h b/src/errors.h
new file mode 100644
index 0000000..37521f5
--- /dev/null
+++ b/src/errors.h
@@ -0,0 +1,122 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef ERRORS_H_
+#define ERRORS_H_
+
+#define WCA_API_ERROR_NONE          0
+#define WCA_API_ERROR_UNKNOWN           1
+#define WCA_API_ERROR_MALFORMED_JSON        2
+#define WCA_API_ERROR_INVALID_PARAMETERS    3
+#define WCA_API_ERROR_CONNMAN_UNAVAILABLE   4
+#define WCA_API_ERROR_WIFI_TECH_UNAVAILABLE 5
+#define WCA_API_ERROR_CELLULAR_TECH_UNAVAILABLE 6
+#define WCA_API_ERROR_WIFI_SWITCHED_OFF     7
+#define WCA_API_ERROR_WAN_SWITCHED_OFF      8
+#define WCA_API_ERROR_SCHEMA_VALIDATION     9
+
+#define WCA_API_ERROR_INVALID_KEY       10
+#define WCA_API_ERROR_AUTH_FAILED       11
+#define WCA_API_ERROR_LOGIN_FAILED      12
+#define WCA_API_ERROR_CONNECT_FAILED        13
+#define WCA_API_ERROR_DHCP_FAILED       14
+#define WCA_API_ERROR_PIN_MISSING       15
+#define WCA_API_ERROR_OUT_OF_RANGE      16
+
+
+#define WCA_API_ERROR_INTERNAL          100
+#define WCA_API_ERROR_ALREADY_CONNECTING    101
+#define WCA_API_ERROR_NETWORK_NOT_FOUND     102
+#define WCA_API_ERROR_ALREADY_ENABLED       103
+#define WCA_API_ERROR_ALREADY_DISABLED      104
+#define WCA_API_ERROR_PROFILE_NOT_FOUND     105
+#define WCA_API_ERROR_NO_SERVICE_CONNECTING 106
+#define WCA_API_ERROR_DISCONNECT_FAILED     107
+#define WCA_API_ERROR_SCANNING          108
+#define WCA_API_ERROR_WPS_PIN           109
+#define WCA_API_ERROR_CANCEL_WPS        110
+#define WCA_API_ERROR_PEER_NOT_FOUND        111
+#define WCA_API_ERROR_MULTI_CHAN_SCHED_MODE 112
+#define WCA_API_ERROR_P2P_STATE_CHANGE      113
+#define WCA_API_ERROR_P2P_DISABLED      114
+#define WCA_API_ERROR_PERSISTENT_STATE      115
+#define WCA_API_ERROR_LISTEN_STATE      116
+#define WCA_API_ERROR_PEER_IN_ASSOC     117
+#define WCA_API_ERROR_NOT_CONNECTED     118
+#define WCA_API_ERROR_DISC_GROUP        119
+#define WCA_API_ERROR_NO_ACTIVE_GRP     120
+#define WCA_API_ERROR_GRP_NOT_FOUND     121
+#define WCA_API_ERROR_DEVICE_NAME_UNSET     122
+#define WCA_API_ERROR_WFD_STATE         123
+#define WCA_API_ERROR_DEVICETYPE_INVALID    124
+#define WCA_API_ERROR_DEVICETYPE        125
+#define WCA_API_ERROR_SESSION_AVAIL_BIT     126
+#define WCA_API_ERROR_CP_SUPPORT_BIT        127
+#define WCA_API_ERROR_RTSP_PORT         128
+#define WCA_API_ERROR_SUBSCRIPTION_REQD     129
+#define WCA_API_ERROR_FINDSERVICE       130
+#define WCA_API_ERROR_ADDSERVICE        131
+#define WCA_API_ERROR_DELETESERVICE     132
+#define WCA_API_ERROR_CANCEL_P2P_CONN       133
+#define WCA_API_ERROR_DELETING_PROFILE      134
+#define WCA_API_ERROR_LISTEN_PARAMS     135
+#define WCA_API_ERROR_NO_CONNECTED_NW       136
+#define WCA_API_ERROR_WIRED_WIFI_ONLINE     137
+#define WCA_API_ERROR_WIRED_ONLINE      138
+#define WCA_API_ERROR_WIFI_ONLINE       139
+#define WCA_API_ERROR_WIRED_NOT_CONNECTED   142
+#define WCA_API_ERROR_WIFI_NOT_CONNECTED    143
+#define WCA_API_ERROR_FAILED_TO_CONNECT     144
+#define WCA_API_ERROR_NOT_IMPLEMENTED       145
+#define WCA_API_ERROR_TETHERING_ENABLE_FAILED 146
+#define WCA_API_ERROR_TETHERING_DISABLE_FAILED 147
+#define WCA_API_ERROR_TETHERING_SSID_FAILED         148
+#define WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED   149
+#define WCA_API_ERROR_TETHERING_NO_SSID             150
+#define WCA_API_ERROR_TETHERING_NO_PASSPHRASE       151
+#define WCA_API_ERROR_TETHERING_SUPPORT_FAILED      152
+#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_SEC_TYPE          153
+#define WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED 154
+#define WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID  155
+#define WCA_API_ERROR_COUNTER                  156
+#define WCA_API_ERROR_TETHERING_RESTORE_WIFI_STATE_FAILED 157
+#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT 158
+#define WCA_API_ERROR_TETHERING_TIMEOUT_NO_NEGATIVE_VALUES 159
+#define WCA_API_ERROR_SET_PASSTHROUGH_PARAMS_FAILED  162
+#define WCA_API_ERROR_FAILED_TO_ENABLE_DISABLE_TECHNOLOGIES 163
+#define WCA_API_ERROR_FAILED_TO_SET_LISTEN_CHANNEL  164
+#define WCA_API_ERROR_ALREADY_CONNECTED 165
+#define WCA_API_ERROR_HOST_ROUTE_NOT_SET 166
+#define WCA_API_ERROR_ETHERNET_TECHNOLOGY_UNAVAILABLE 167
+#define WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_ENABLED 168
+#define WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_DISABLED 169
+#define WCA_API_ERROR_ETHERNET_TETHERING_SET 170
+#define WCA_API_ERROR_REJECT_PEER 171
+#define WCA_API_ERROR_LISTEN_PARAMS_INVALID_VALUES 172
+#define WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE  173
+#define WCA_API_ERROR_BLUETOOTH_SWITCHED_OFF            174
+#define WCA_API_ERROR_NO_SERVICE_CONNECTED              175
+#define WCA_API_ERROR_P2P_MULTIPLE_GROUPS_NOT_ALLOWED   176
+#define WCA_API_ERROR_P2P_PASSPHRASE_INVALID            177
+#define WCA_API_ERROR_WIFI_SCAN_INTERVAL_NEEDS_SUBSCRIPTION 178
+#define WCA_API_ERROR_WIFI_PASSPHRASE_INVALID  179
+#define WCA_API_ERROR_WIFI_SECURITY_TYPE_INVALID 180
+#define WCA_API_ERROR_SET_TECHNOLOGY_STATE_NOT_SUPPORTED 181
+
+#define WCA_API_ERROR_PROXY_FIND_PROXY_FOR_URL_ERROR    205
+#define WCA_API_ERROR_FAILED_TO_SET_GO_INTENT           206
+
+#endif /* ERRORS_H_ */
diff --git a/src/json_utils.c b/src/json_utils.c
new file mode 100644
index 0000000..a35880d
--- /dev/null
+++ b/src/json_utils.c
@@ -0,0 +1,334 @@
+// Copyright (c) 2016-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+
+#include <pbnjson/c/jtypes.h>
+#include "json_utils.h"
+
+static char* convert_jobject_to_native_valist(jvalue_ref json, va_list *valist)
+{
+	jvalue_ref valueObj;
+	JsonValueType type;
+	const char* key;
+	void *destination;
+	gboolean mandatory;
+	ConversionResultFlags json_error;
+	int64_t int_value;
+
+	while (true)
+	{
+		type = va_arg(*valist, JsonValueType);
+
+		if (type == json_object_end)
+		{
+			//Object finished, return success
+			break;
+		}
+
+		// This is field, get base params
+		key = va_arg(*valist, char*);
+		destination = va_arg(*valist, void*);
+		mandatory = va_arg(*valist, gboolean);
+
+		if (!key)
+		{
+			return g_strdup("Key is null");
+		}
+
+		if (!destination)
+		{
+			return g_strdup("Destination pointer is null");
+		}
+
+		valueObj = jobject_get(json, j_cstr_to_buffer(key));
+
+		if (!jis_valid(valueObj))
+		{
+			if (!mandatory)
+				continue;
+			else
+			{
+				return g_strdup_printf("Mandatory field %s missing", key);
+			}
+		}
+
+		// Ok, now we have a non-null value and need to parse it
+		switch (type)
+		{
+			case json_type_jvalue_ref:
+				*((jvalue_ref*)destination) = valueObj;
+				break;
+			case json_type_jvalue_ref_array:
+				if (!jis_array(valueObj))
+				{
+					return g_strdup_printf("Field %s not an array", key);
+				}
+
+				*((jvalue_ref*)destination) = valueObj;
+				break;
+			case json_type_jvalue_ref_object:
+				if (!jis_object(valueObj))
+				{
+					return g_strdup_printf("Field %s not a object", key);
+				}
+
+				*((jvalue_ref*)destination) = valueObj;
+				break;
+			case json_type_string:
+				if (!jis_string(valueObj))
+				{
+					return g_strdup_printf("Field %s not a string", key);
+				}
+
+				*((const char**)destination) = jstring_get_fast(valueObj).m_str;
+				break;
+			case json_type_boolean:
+				if (!jis_boolean(valueObj))
+				{
+					return g_strdup_printf("Field %s is not a boolean", key);
+				}
+
+				jboolean_get(valueObj, (bool*)destination);
+				break;
+			case json_type_uint8:
+				if (!jis_number(valueObj))
+				{
+					return g_strdup_printf("Field %s not a number", key);
+				}
+
+				json_error = jnumber_get_i64(valueObj, &int_value);
+				if (json_error || int_value < 0 || int_value >= (2<<8))
+				{
+					return g_strdup_printf("Field %s number of out range of uint8", key);
+				}
+
+				*((guint8*)destination) = (guint8)int_value;
+				break;
+			case json_type_uint16:
+				if (!jis_number(valueObj))
+				{
+					return g_strdup_printf("Field %s not a number", key);
+				}
+
+				json_error = jnumber_get_i64(valueObj, &int_value);
+				if (json_error || int_value < 0 || int_value >= (2<<16))
+				{
+					return g_strdup_printf("Field %s number of out range of uint16", key);
+				}
+
+				*((guint16*)destination) = (guint16)int_value;
+				break;
+			case json_type_uint32:
+				if (!jis_number(valueObj))
+				{
+					return g_strdup_printf("Field %s not a number", key);
+				}
+
+				json_error = jnumber_get_i64(valueObj, &int_value);
+				if (json_error || int_value < 0 || int_value >= (((guint64)2)<<32))
+				{
+					return g_strdup_printf(
+							"Field %s number of out range of uint32",
+							key);
+				}
+
+				*((guint32*)destination) = (guint32)int_value;
+				break;
+			case json_type_int32:
+				if (!jis_number(valueObj))
+				{
+					return g_strdup_printf("Field %s not a number", key);
+				}
+
+				gint32 int32_value;
+				json_error = jnumber_get_i32(valueObj, &int32_value);
+				if (json_error)
+				{
+					return g_strdup_printf("Field %s number of out range of int32", key);
+				}
+
+				*((gint32*)destination) = int32_value;
+				break;
+			default:
+				//TODO: not implemented subobjects and arrays
+				return g_strdup_printf("Invalid or unsupported type %i", type);
+
+		}
+	}
+
+	return NULL;
+}
+
+char* generate_jobject_from_native_valist(jvalue_ref* result, va_list* valist)
+{
+	JsonValueType type;
+	const char* key;
+	const char* str_value;
+	bool bool_value;
+	guint8 u8_value;
+	guint16 u16_value;
+	guint32 u32_value;
+	gint32 i32_value;
+	bool need_to_add;
+
+	jvalue_ref obj = jobject_create();
+	jvalue_ref sub_obj = NULL;
+
+	while (true)
+	{
+		type = va_arg(*valist, JsonValueType);
+
+		if (type == json_object_end)
+		{
+			break;
+		}
+
+		// This is a field, get base params
+		key = va_arg(*valist, char*);
+
+		if (!key)
+		{
+			j_release(&obj);
+			return g_strdup("Key is null");
+		}
+
+		switch (type)
+		{
+			case json_type_jvalue_ref_array:
+				sub_obj = va_arg(*valist, jvalue_ref);
+				if (!jis_array(sub_obj ))
+				{
+					j_release(&obj);
+					return g_strdup_printf("Field %s not an array", key);
+				}
+				need_to_add = va_arg(*valist, int);
+				break;
+			case json_type_jvalue_ref_object:
+				sub_obj = va_arg(*valist, jvalue_ref);
+				if (!jis_object(sub_obj))
+				{
+					j_release(&obj);
+					return g_strdup_printf("Field %s not a object", key);
+				}
+				need_to_add = va_arg(*valist, int);
+				break;
+			case json_type_jvalue_ref:
+				sub_obj = va_arg(*valist, jvalue_ref);
+				if (!jis_valid(sub_obj))
+				{
+					j_release(&obj);
+					return g_strdup_printf("Field %s not a jvalue", key);
+				}
+				need_to_add = va_arg(*valist, int);
+				break;
+			case json_type_string:
+				str_value = va_arg(*valist, const char*);
+				need_to_add = va_arg(*valist, int);
+
+				if (need_to_add)
+				{
+					sub_obj = jstring_create(str_value);
+				}
+				break;
+			case json_type_boolean:
+				bool_value = va_arg(*valist, int); // args smaller than int are promoted to int
+				need_to_add = va_arg(*valist, int);
+
+				if (need_to_add)
+				{
+					sub_obj = jboolean_create(bool_value);
+				}
+				break;
+			case json_type_uint8:
+				u8_value = va_arg(*valist, int); // args smaller than int are promoted to int
+				need_to_add = va_arg(*valist, int);
+
+				if (need_to_add)
+				{
+					sub_obj = jnumber_create_i32(u8_value);
+				}
+				break;
+			case json_type_uint16:
+				u16_value = va_arg(*valist, int); // args smaller than int are promoted to int
+				need_to_add = va_arg(*valist, int);
+
+				if (need_to_add)
+				{
+					sub_obj = jnumber_create_i32(u16_value);
+				}
+				break;
+			case json_type_uint32:
+				u32_value = va_arg(*valist, guint32);
+				need_to_add = va_arg(*valist, int);
+
+				if (need_to_add)
+				{
+					sub_obj = jnumber_create_i64(u32_value);
+				}
+				break;
+			case json_type_int32:
+				i32_value = va_arg(*valist, gint32);
+				need_to_add = va_arg(*valist, int);
+
+				if (need_to_add)
+				{
+					sub_obj = jnumber_create_i32(i32_value);
+				}
+				break;
+			default:
+				//TODO: not implemented subobjects and arrays
+				j_release(&obj);
+				return g_strdup_printf("Invalid or unsupported type %i", type);
+		}
+
+		if (need_to_add)
+		{
+			if (!jobject_put(obj, jstring_create(key), sub_obj))
+			{
+				return g_strdup_printf("Not failed to add json object for field %s, invalid joson object?", key);
+			}
+		}
+	}
+
+	*result = obj;
+
+	return NULL;
+}
+
+
+char* json_convert_to_native_valist(jvalue_ref json, va_list *valist)
+{
+	JsonValueType type = va_arg(*valist, JsonValueType);
+
+	if (type == json_object_start)
+	{
+		return convert_jobject_to_native_valist(json, valist);
+	}
+
+	return g_strdup("Invalid params list");
+}
+
+char* json_generate_from_native_valist(jvalue_ref* result, va_list* valist)
+{
+	JsonValueType type = va_arg(*valist, JsonValueType);
+
+	if (type == json_object_start)
+	{
+		return generate_jobject_from_native_valist(result, valist);
+	}
+
+	return g_strdup("Invalid params list");
+}
diff --git a/src/json_utils.h b/src/json_utils.h
new file mode 100644
index 0000000..db91017
--- /dev/null
+++ b/src/json_utils.h
@@ -0,0 +1,74 @@
+// Copyright (c) 2014-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+
+
+#ifndef JSONUTILS_H
+#define JSONUTILS_H
+
+#include <luna-service2/lunaservice.h>
+#include <pbnjson.h>
+
+// Build a schema as a const char * string without any execution overhead
+#define SCHEMA_ANY                              "{}"
+#define SCHEMA_1(param)                         "{\"type\":\"object\",\"properties\":{" param "},\"additionalProperties\":false}" // Ex: SCHEMA_1(REQUIRED(age,integer))
+
+#define PROPS_1(p1)                             ",\"properties\":{" p1 "}"
+#define PROPS_2(p1, p2)                         ",\"properties\":{" p1 "," p2 "}"
+#define PROPS_3(p1, p2, p3)                     ",\"properties\":{" p1 "," p2 "," p3 "}"
+#define PROPS_4(p1, p2, p3, p4)                 ",\"properties\":{" p1 "," p2 "," p3 "," p4 "}"
+#define PROPS_5(p1, p2, p3, p4, p5)             ",\"properties\":{" p1 "," p2 "," p3 "," p4 "," p5 "}"
+#define PROPS_6(p1, p2, p3, p4, p5, p6)         ",\"properties\":{" p1 "," p2 "," p3 "," p4 "," p5 "," p6 "}"
+#define PROPS_7(p1, p2, p3, p4, p5, p6, p7)     ",\"properties\":{" p1 "," p2 "," p3 "," p4 "," p5 "," p6 "," p7 "}"
+#define REQUIRED_1(p1)                          ",\"required\":[\"" #p1 "\"]"
+#define REQUIRED_2(p1, p2)                      ",\"required\":[\"" #p1 "\",\"" #p2 "\"]"
+#define REQUIRED_4(p1, p2, p3, p4)          ",\"required\":[\"" #p1 "\",\"" #p2 "\",\"" #p3 "\",\"" #p4 "\"]"
+#define REQUIRED_5(p1, p2, p3, p4, p5)          ",\"required\":[\"" #p1 "\",\"" #p2 "\",\"" #p3 "\",\"" #p4 "\",\"" #p5 "\"]"
+#define STRICT_SCHEMA(attributes)               "{\"type\":\"object\"" attributes ",\"additionalProperties\":false}"
+#define RELAXED_SCHEMA(attributes)              "{\"type\":\"object\"" attributes ",\"additionalProperties\":true}"
+
+// Macros to use in place of the parameters in the SCHEMA_xxx macros above
+#define PROP(name, type) "\"" #name "\":{\"type\":\"" #type "\"}"
+#define ARRAY(name, type) "\"" #name "\":{\"type\":\"array\", \"items\":{\"type\":\"" #type "\"}}"
+#define OBJARRAY(name, objschema)                 "\"" #name "\":{\"type\":\"array\", \"items\": " objschema "}"
+#define OBJSCHEMA_1(param)                         "{\"type\":\"object\",\"properties\":{" param "}}"
+#define OBJSCHEMA_2(p1, p2)                        "{\"type\":\"object\",\"properties\":{" p1 "," p2 "}}"
+#define OBJSCHEMA_3(p1, p2, p3)                    "{\"type\":\"object\",\"properties\":{" p1 "," p2 ", " p3 "}}"
+#define OBJSCHEMA_4(p1, p2, p3, p4)                "{\"type\":\"object\",\"properties\":{" p1 "," p2 ", " p3 ", " p4 "}}"
+#define OBJECT(name, objschema) "\"" #name "\":" objschema
+
+/* Enum for parsing to C types*/
+typedef enum {
+	json_type_boolean,
+	json_type_int32,
+	json_type_uint8,
+	json_type_uint16,
+	json_type_uint32,
+	json_type_string,
+	json_type_jvalue_ref,
+	json_type_jvalue_ref_object,
+	json_type_jvalue_ref_array,
+
+	json_object_start,
+	json_object_end,
+	json_array_start,
+	json_array_end,
+} JsonValueType;
+
+extern char* json_convert_to_native_valist(jvalue_ref json, va_list* list);
+extern char* json_generate_from_native_valist(jvalue_ref* result, va_list* list);
+
+#endif // JSONUTILS_H
diff --git a/src/logging.h b/src/logging.h
new file mode 100644
index 0000000..a105e0f
--- /dev/null
+++ b/src/logging.h
@@ -0,0 +1,266 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <PmLogLib.h>
+
+extern PmLogContext gLogContext;
+
+/* Logging for webos-connman-adapter context ********
+ * The parameters needed are
+ * msgid - unique message id
+ * kvcount - count for key-value pairs
+ * ... - key-value pairs and free text. key-value pairs are formed using PMLOGKS or PMLOGKFV
+ * e.g.)
+ * WCALOG_CRITICAL(msgid, 2, PMLOGKS("key1", "value1"), PMLOGKFV("key2", "%d", value2), "free text message");
+ **********************************************/
+#define WCALOG_CRITICAL(msgid, kvcount, ...) \
+        PmLogCritical(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define WCALOG_ERROR(msgid, kvcount, ...) \
+        PmLogError(gLogContext, msgid, kvcount,##__VA_ARGS__)
+
+#define WCALOG_WARNING(msgid, kvcount, ...) \
+        PmLogWarning(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define WCALOG_INFO(msgid, kvcount, ...) \
+        PmLogInfo(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define WCALOG_DEBUG(...) \
+        PmLogDebug(gLogContext, ##__VA_ARGS__)
+
+#define WCALOG_ESCAPED_ERRMSG(msgid, errmsg) \
+    do { \
+    gchar *escaped_errtext = g_strescape(errmsg, NULL); \
+    WCALOG_ERROR(msgid, 1, PMLOGKS("Error", escaped_errtext), ""); \
+    g_free(escaped_errtext); \
+    } while(0)
+
+#define WCALOG_ADDR_INFOMSG(msgid, name, addr) \
+    do { \
+    gchar straddr[16]; \
+    snprintf(straddr, 16, "%p", addr); \
+    WCALOG_INFO(msgid, 1, PMLOGKS(name, straddr), ""); \
+    } while(0)
+
+/** list of MSGID's */
+
+/** common ones */
+#define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
+#define MSGID_CM_SRVC_REGISTER_FAIL                     "WIFI_CM_REGISTER_FAIL"
+#define MSGID_WAN_SRVC_REGISTER_FAIL                    "WAN_SRVC_REGISTER_FAIL"
+#define MSGID_PAN_SRVC_REGISTER_FAIL                    "PAN_SRVC_REGISTER_FAIL"
+
+#define MSGID_WAN_SRVC_ALLOC_FAIL                       "WAN_SRVC_ALLOC_FAIL"
+#define MSGID_INVALID_STATE                             "INVALID_STATE"
+
+/** main.c */
+#define MSGID_WCA_STARTING                              "WCA_STARTING"
+#define MSGID_WCA_SUPPORT_FAIL                          "WCA_SUPPORT_FAIL"
+
+/** connman_agent.c */
+#define MSGID_AGENT_INIT_ERROR                          "AGENT_INIT_ERR"
+
+/** connman_counter.c */
+#define MSGID_COUNTER_INIT_ERROR                        "COUNTER_INIT_ERR"
+#define MSGID_COUNTER_EXPORT_SUCCESS                    "COUNTER_EXPORT_SUCCESS"
+#define MSGID_CM_DATA_ACTIVITY                          "CM_DATA_ACTIVITY"
+
+/** connman_group.c */
+#define MSGID_GROUP_SET_PROPERTY_ERROR                  "GRP_SET_PROPERTY_ERR"
+#define MSGID_GROUP_DISCONNECT_ERROR                    "GRP_DISCONNECT_ERR"
+#define MSGID_GROUP_INVITE_ERROR                        "GRP_INVITE_ERR"
+#define MSGID_GROUP_GET_PROPERTIES_ERROR                "GRP_GET_PROPERTIES_ERR"
+#define MSGID_GROUP_INIT_ERROR                          "GRP_INIT_ERR"
+
+/** connman_manager.c */
+#define MSGID_MANAGER_GET_PROPERTIES_ERROR              "MGR_GET_PROPERTIES_ERR"
+#define MSGID_MANAGER_GET_SERVICES_ERROR                "MGR_GET_SERVICES_ERR"
+#define MSGID_MANAGER_GET_SAVED_SERVICES_ERROR          "MGR_GET_SAVED_SERVICES_ERR"
+#define MSGID_MANAGER_GET_TECHNOLOGIES_ERROR            "MGR_GET_TECHNOLOGIES_ERR"
+#define MSGID_MANAGER_GET_PEERS_ERROR                   "MGR_GET_PEERS_ERR"
+#define MSGID_MANAGER_GET_GROUPS_ERROR                  "MGR_GET_GROUPS_ERR"
+#define MSGID_MANAGER_CREATE_GROUP_ERROR                "MGR_CREATE_GROUP_ERR"
+#define MSGID_MANAGER_STATUS_CHECK                      "MGR_STATUS_CHECK"
+#define MSGID_MANAGER_UNREGISTER_AGENT_ERROR            "MGR_UNREGISTER_AGENT_ERR"
+#define MSGID_MANAGER_UNREGISTER_COUNTER_ERROR          "MGR_UNREGISTER_COUNTER_ERR"
+#define MSGID_MANAGER_STATE_UPDATE_ERROR                "MGR_STATE_UPDATE_ERR"
+#define MSGID_MANAGER_INIT_ERROR                        "MGR_INIT_ERR"
+#define MSGID_MANAGER_NO_TECH_ERROR                     "MGR_NO_TECH_ERR"
+#define MSGID_MANAGER_NO_WIRED_ERROR                    "MGR_NO_WIRED_ERR"
+#define MSGID_MANAGER_SET_OFFLINEMODE_ERROR             "MGR_SET_OFFLINEMOE_ERR"
+#define MSGID_MANAGER_REGISTER_COUNTER_ERROR            "MGR_REGISTER_COUNTER_ERROR"
+#define MSGID_MANAGER_REGISTER_COUNTER_SUCCESS          "MGR_REGISTER_COUNTER_SUCCESS"
+#define MSGID_MANAGER_CHANGE_SAVED_SERVICE_ERROR        "MGR_CHANGE_SAVED_SERVICE_ERROR"
+#define MSGID_MANAGER_FIELDS_ERROR                      "MGR_FIELDS_ERROR"
+#define MSGID_MANAGER_SET_WOL_WOWL_ERROR                "MGR_SET_WOL_WOWL_ERR"
+
+/** connman_service.c */
+#define MSGID_SERVICE_CONNECT_ERROR                     "SRVC_CONNECT_ERR"
+#define MSGID_SERVICE_DISCONNECT_ERROR                  "SRVC_DISCONNECT_ERR"
+#define MSGID_SERVICE_REMOVE_ERROR                      "SRVC_REMOVE_ERR"
+#define MSGID_SERVICE_SET_IPV4_ERROR                    "SRVC_SET_IPV4_ERR"
+#define MSGID_SERVICE_SET_IPV6_ERROR                    "SRVC_SET_IPV6_ERR"
+#define MSGID_SERVICE_SET_NAMESERVER_ERROR              "SRVC_SET_NAMESERVER_ERR"
+#define MSGID_SERVICE_AUTOCONNECT_ERROR                 "SRVC_AUTOCONNECT_ERR"
+#define MSGID_SERVICE_GET_IPINFO_ERROR                  "SRVC_GET_IPINFO_ERR"
+#define MSGID_SERVICE_FETCH_PROPERTIES_ERROR            "SRVC_FETCH_PROPERTIES_ERR"
+#define MSGID_SERVICE_INIT_ERROR                        "SRVC_INIT_ERR"
+#define MSGID_SERVICE_RUN_ONLINE_CHECK_ERROR            "SRVC_RUN_ONLINE_CHECK_ERROR"
+#define MSGID_SERVICE_PASSPHRASE_ERROR          "SRVC_PASSPHRASE_ERR"
+#define MSGID_SERVICE_REJECT_PEER_ERROR                 "SRVC_REJECT_PEER_ERR"
+#define MSGID_SERVICE_SET_PROXY_ERROR                    "SRVC_SET_PROXY_ERR"
+
+/** connman_service_discovery.c */
+#define MSGID_SERVICE_DISCOVERY_REQUEST_ERROR           "SRVC_DISC_REQUEST_ERR"
+#define MSGID_SERVICE_DISCOVERY_REGISTER_ERROR          "SRVC_DISC_REGISTER_ERR"
+#define MSGID_SERVICE_DISCOVERY_REMOVE_ERROR            "SRVC_DISC_REMOVE_ERR"
+
+/** connman_technology.c */
+#define MSGID_TECHNOLOGY_SET_POWERED_ERROR              "TECH_SET_POWERED_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_ERROR            "TECH_SET_TETHERING_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR "TECH_SET_TETHERING_IDENTI_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR "TECH_SET_TETHERING_PASSPH_ERR"
+#define MSGID_TECHNOLOGY_CANCEL_P2P_ERROR               "TECH_CANCEL_P2P_ERR"
+#define MSGID_TECHNOLOGY_CANCEL_WPS_ERROR               "TECH_CANCEL_WPS_ERR"
+#define MSGID_TECHNOLOGY_START_WPS_ERROR                "TECH_START_WPS_ERR"
+#define MSGID_TECHNOLOGY_SET_COUNTRY_CODE_ERROR         "TECH_SET_COUNTRY_CODE_ERR"
+#define MSGID_TECHNOLOGY_DELETE_PROFILE_ERROR           "TECH_DELETE_PROFILE_ERR"
+#define MSGID_TECHNOLOGY_SET_MULTI_CHANNEL_ERROR        "TECH_SET_MULTI_CHANNEL_ERR"
+#define MSGID_TECHNOLOGY_SET_P2P_ERROR                  "TECH_SET_P2P_ERR"
+#define MSGID_TECHNOLOGY_SET_P2P_IDENTIFIER_ERROR       "TECH_SET_IDENTIFIER_ERR"
+#define MSGID_TECHNOLOGY_SET_WFD_ERROR                  "TECH_SET_WFD_ERR"
+#define MSGID_TECHNOLOGY_SET_WFD_DEVTYPE_ERROR          "TECH_SET_WFD_DEVTYPE_ERR"
+#define MSGID_TECHNOLOGY_SET_WFD_SESSION_ERROR          "TECH_SET_WFD_SESSION_ERR"
+#define MSGID_TECHNOLOGY_SET_WFD_CPSUPPORT_ERROR        "TECH_SET_WFD_CPSUPPORT_ERR"
+#define MSGID_TECHNOLOGY_SET_WFD_RTSPPORT_ERROR         "TECH_SET_WFD_RTSPSUPPORT_ERR"
+#define MSGID_TECHNOLOGY_SET_P2P_LISTEN_ERROR           "TECH_SET_P2P_LISTEN_ERR"
+#define MSGID_TECHNOLOGY_SET_P2P_PERSISTENT_ERROR       "TECH_SET_P2P_PERSISTENT_ERR"
+#define MSGID_TECHNOLOGY_SET_LEGACY_SCAN_ERROR          "TECH_SET_LEGACY_SCAN_ERR"
+#define MSGID_TECHNOLOGY_SCAN_ERROR                     "TECH_SCAN_ERR"
+#define MSGID_TECHNOLOGY_INIT_ERROR                     "TECH_INIT_ERR"
+#define MSGID_TECHNOLOGY_SAVED_SERVICES_ERROR           "TECH_SAVED_SERVICES_ERROR"
+#define MSGID_TECHNOLOGY_SET_LISTEM_PARAMS_ERROR        "TECH_SET_LISTEM_PARAMS_ERROR"
+#define MSGID_TECHNOLOGY_SET_LISTEM_CHANNEL_ERROR       "TECH_SET_LISTEM_CHANNEL_ERROR"
+#define MSGID_TECHNOLOGY_GET_PROPERTIES_ERROR           "TECH_GET_PROPERTIES_ERR"
+#define MSGID_TECHNOLOGY_GET_INTERFACE_PROPERTIES_ERROR "TECH_GET_INTERFACE_PROPERTIES_ERR"
+#define MSGID_TECHNOLOGY_SET_GO_INTENT_ERROR            "TECH_SET_GO_INTENT_ERR"
+
+/** connectionmanager_service.c */
+#define MSGID_WIFI_MAC_ADDR_ERROR                       "WIFI_MAC_ADDR_ERR"
+#define MSGID_WIRED_MAC_ADDR_ERROR                      "WIRED_MAC_ADDR_ERR"
+#define MSGID_CM_LUNA_BUS_ERROR                         "CM_LUNA_BUS_ERR"
+#define MSGID_CM_METHODS_LUNA_ERROR                     "CM_METADATA_LUNA_ERR"
+#define MSGID_CM_GLOOP_ATTACH_ERROR                     "CM_GLOOP_ATTACH_ERR"
+#define MSGID_CONNECTION_INFO                           "CONNECTION_INFO"
+#define MSGID_CM_ONLINE_CHECK_INFO                      "CM_RUN_ONLINE_CHECK_INFO"
+#define MSGID_CM_GET_MAC_INFO                           "CM_GET_MAC_INFO"
+
+/** wifi_service.c */
+#define MSGID_WIFI_CONNECT_HIDDEN_SERVICE               "WIFI_CONNECT_HIDDEN_SERVICE"
+#define MSGID_WIFI_CONNECT_SERVICE                      "WIFI_CONNECT_SERVICE"
+#define MSGID_WIFI_DISCONNECT_SERVICE                   "WIFI_DISCONNECT_SERVICE"
+#define MSGID_WIFI_AGENT_ERROR                          "WIFI_AGENT_ERR"
+#define MSGID_WIFI_COUNTER_ERROR                        "WIFI_COUNTER_ERR"
+#define MSGID_WIFI_LUNA_BUS_ERROR                       "WIFI_LUNA_BUS_ERR"
+#define MSGID_WIFI_METHODS_LUNA_ERROR                   "WIFI_METHODS_LUNA_ERR"
+#define MSGID_WIFI_GLOOP_ATTACH_ERROR                   "WIFI_GLOOP_ATTACH_ERR"
+#define MSGID_WIFI_FACTORY_MODE_ERROR                   "WIFI_FACTORY_MODE_ERR"
+#define MSGID_WIFI_SKIPPING_FETCH_PROPERTIES            "WIFI_SKIPPING_FETCH_PROPERTIES"
+#define MSGID_WIFI_SERVICE_NOT_EXIST                    "WIFI_SERVICE_NOT_EXIST"
+#define MSGID_WIFI_CONFIG_INOTIFY_WATCH_ERR             "WIFI_CONFIG_INOTIFY_WATCH_ERR"
+#define MSGID_WIFI_SUBSCRIPTIONCANCEL_LUNA_ERROR        "WIFI_SUBSCRIPTIONCANCEL_LUNA_ERROR"
+
+/** Wifi Scan errors */
+#define MSGID_WIFI_SCAN_CALLBACK_NOT_RUNNING            "WIFI_SCAN_CALLBACK_NOT_RUNNING"
+#define MSGID_WIFI_SCAN_ADD_INTERVAL_STATE_MISMATCH     "WIFI_SCAN_ADD_INTERVAL_STATE_MISMATCH"
+#define MSGID_WIFI_SCAN_ADD_INTERVAL_INVALID_PARAMS     "WIFI_SCAN_ADD_INTERVAL_INVALID_PARAMS"
+#define MSGID_WIFI_SCAN_START_ALREADY_STARTED           "WIFI_SCAN_START_ALREADY_STARTED"
+#define MSGID_WIFI_SCAN_STOP_ALREADY_STOPPED            "WIFI_SCAN_STOP_ALREADY_STOPPED"
+#define MSGID_WIFI_SCAN_REMOVE_INVERVAL_NOT_FOUND       "WIFI_SCAN_REMOVE_INVERVAL_NOT_FOUND"
+
+/** wifi_p2p_service.c */
+#define MSGID_P2P_CONNECT_PEER                          "P2P_CONNECT_PEER"
+#define MSGID_P2P_DISCONNECT_PEER                       "P2P_DISCONNECT_PEER"
+#define MSGID_P2P_INVITE_PEER                           "P2P_INVITE_PEER"
+#define MSGID_P2P_DISCONNECT_GROUP                      "P2P_DISCONNECT_GRP"
+#define MSGID_P2P_SET_TETHERING                         "P2P_SET_TETHERING"
+#define MSGID_P2P_DELETE_PROFILE                        "P2P_DELETE_PROFILE"
+#define MSGID_P2P_METHODS_LUNA_ERROR                    "P2P_METHODS_LUNA_ERR"
+#define MSGID_SETTINGS_SERVICE_REG_ERROR                "SETTINGS_SRVC_REG_ERR"
+
+/* lunaservice_utils.c */
+#define MSGID_LUNA_CREATE_JSON_FAILED                   "LUNA_CREATE_JSON_FAILED"
+#define MSGID_LUNA_SEND_FAILED                          "LUNA_SEND_FAILED"
+
+/** wifi_tethering_service. */
+#define MSGID_TETHERING_METHODS_LUNA_ERROR              "TETHERING_METHODS_LUNA_ERR"
+
+/** wifi_setting.c */
+#define MSGID_SETTING_LPAPP_GET_ERROR                   "SETTING_LPAPP_GET_ERR"
+#define MSGID_SETTING_LPAPP_COPY_ERROR                  "SETTING_LPAPP_COPY_ERR"
+#define MSGID_SETTING_LPAPP_REMOVE_ERROR                "SETTING_LPAPP_REMOVE_ERR"
+#define MSGID_SETTING_LPAPP_SET_ERROR                   "SETTING_LPAPP_SET_ERR"
+
+/** pan_service.c */
+#define MSGID_PAN_LUNA_BUS_ERROR                       "PAN_LUNA_BUS_ERR"
+#define MSGID_PAN_METHODS_LUNA_ERROR                   "PAN_METHODS_LUNA_ERR"
+#define MSGID_PAN_GLOOP_ATTACH_ERROR                   "PAN_GLOOP_ATTACH_ERR"
+#define MSGID_PAN_CONNECT_SERVICE_ERROR                "PAN_CONNECT_SERVICE_ERROR"
+#define MSGID_PAN_SKIPPING_FETCH_PROPERTIES            "PAN_SKIPPING_FETCH_PROPERTIES"
+#define MSGID_PAN_SERVICE_NOT_EXIST                    "PAN_SERVICE_NOT_EXIST"
+
+/** country_code.c */
+#define MSGID_COUNTRY_CODE_INFO                         "COUNTRY_CODE_INFO"
+#define MSGID_COUNTRY_CODE_FAILED                       "COUNTRY_CODE_FAILED"
+
+/** nyx.c */
+#define MSGID_NYX_INIT_ERROR                            "NYX_INIT_ERROR"
+#define MSGID_NYX_DEVICE_OPEN_ERROR                     "NYX_DEVICE_OPEN_ERROR"
+#define MSGID_NYX_DEVICE_CLOSE_ERROR                    "NYX_DEVICE_CLOSE_ERROR"
+#define MSGID_NYX_DEINIT_ERROR                          "NYX_DEINIT_ERROR"
+
+/** Wan info codes **/
+#define MSGID_WAN_CONNECT_INFO                          "WAN_CONNECT_INFO"
+#define MSGID_WAN_DISCONNECT_INFO                       "WAN_DISCONNECT_INFO"
+#define MSGID_WAN_SET_HOSTROUTE_ERROR                   "WAN_SET_HOSTROUTE_ERR"
+
+/** json_utils.c **/
+#define MSGID_JSON_KEY_NULL                             "JSON_KEY_NULL"
+#define MSGID_JSON_DEST_NULL                            "JSON_DEST_NULL"
+#define MSGID_JSON_INVALID_TYPE                         "JSON_INVALID_TYPE"
+#define MSGID_JSON_NOT_A_NUMEBR                         "JSON_NOT_A_NUMEBR"
+#define MSGID_JSON_NOT_A_STRING                         "JSON_NOT_A_STRING"
+#define MSGID_JSON_NOT_A_OBJECT                         "JSON_NOT_A_OBJECT"
+#define MSGID_JSON_NOT_AN_ARRAY                         "JSON_NOT_AN_ARRAY"
+#define MSGID_JSON_MANDATORY_FIELD_MISSING              "JSON_MANDATORY_FIELD_MISSING"
+#define MSGID_JSON_NUMBER_OUT_OF_RANGE                  "JSON_NUMBER_OUT_OF_RANGE"
+
+/** pacrunner_client.c **/
+#define MSGID_PACRUNNER_CLIENT_INIT_ERROR					"MGR_PACRUNNER_CLIENT_INIT_ERR"
+#define MSGID_PACRUNNER_CLIENT_FINDPROXYFORURL_ERROR    "MGR_PACRUNNER_CLIENT_FINDPROXYFORURL_ERR"
+
+/** state_recovery.c **/
+#define MSGID_STATE_RECOVERY_INFO                  "STATE_RECOVERY_INFO"
+
+/** list of logkey ID's */
+
+#define ERRTEXT         "Error"
+#define FUNC            "Function"
+
+#endif // __LOGGING_H__
diff --git a/src/lunaservice_utils.c b/src/lunaservice_utils.c
new file mode 100644
index 0000000..eb44cd5
--- /dev/null
+++ b/src/lunaservice_utils.c
@@ -0,0 +1,485 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file lunaservice_utils.c
+ *
+ * @brief Convenience functions for sending luna error messages
+ *
+ */
+
+#include "lunaservice_utils.h"
+#include "logging.h"
+#include "errors.h"
+
+luna_service_request_t *luna_service_request_new(LSHandle *handle,
+        LSMessage *message)
+{
+	luna_service_request_t *req = NULL;
+
+	req = g_new0(luna_service_request_t, 1);
+	req->handle = handle;
+	req->message = message;
+
+	LSMessageRef(message);
+
+	return req;
+}
+
+void luna_service_request_free(luna_service_request_t *service_req)
+{
+	if (service_req->message)
+	{
+		LSMessageUnref(service_req->message);
+	}
+
+	g_free(service_req);
+}
+
+void
+LSMessageReplyErrorUnknown(LSHandle *sh, LSMessage *message)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	char *jsonMessage;
+	jsonMessage =
+	    g_strdup_printf("{\"returnValue\":false,\"errorText\":\"Unknown error\",\"errorCode\":%d}",
+	                    WCA_API_ERROR_UNKNOWN);
+
+	bool retVal = LSMessageReply(sh, message, jsonMessage, &lserror);
+
+	if (!retVal)
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(jsonMessage);
+}
+
+void
+LSMessageReplyErrorInvalidParams(LSHandle *sh, LSMessage *message)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	char *jsonMessage;
+	jsonMessage =
+	    g_strdup_printf("{\"returnValue\":false,\"errorText\":\"Invalid parameters\",\"errorCode\":%d}",
+	                    WCA_API_ERROR_INVALID_PARAMETERS);
+
+	bool retVal = LSMessageReply(sh, message, jsonMessage, &lserror);
+
+	if (!retVal)
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(jsonMessage);
+}
+
+void
+LSMessageReplyErrorBadJSON(LSHandle *sh, LSMessage *message)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	char *jsonMessage;
+	jsonMessage =
+	    g_strdup_printf("{\"returnValue\":false,\"errorText\":\"Malformed json\",\"errorCode\":%d}",
+	                    WCA_API_ERROR_MALFORMED_JSON);
+
+	bool retVal = LSMessageReply(sh, message, jsonMessage, &lserror);
+
+	if (!retVal)
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(jsonMessage);
+}
+
+void
+LSMessageReplyCustomError(LSHandle *sh, LSMessage *message,
+                          const char *errormsg, unsigned int error_code)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	char *errorString;
+
+	errorString =
+	    g_strdup_printf("{\"returnValue\":false,\"errorText\":\"%s\",\"errorCode\":%d}",
+	                    errormsg, error_code);
+
+	bool retVal = LSMessageReply(sh, message, errorString, NULL);
+
+	if (!retVal)
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(errorString);
+}
+
+void
+LSMessageReplyCustomErrorWithSubscription(LSHandle *sh, LSMessage *message,
+        const char *errormsg, unsigned int error_code, bool subscribed)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	char *errorString;
+
+	if (subscribed)
+	{
+		errorString =
+		    g_strdup_printf("{\"returnValue\":false,\"errorText\":\"%s\",\"errorCode\":%d, \"subscribed\":true}",
+		                    errormsg, error_code);
+	}
+	else
+	{
+		errorString =
+		    g_strdup_printf("{\"returnValue\":false,\"errorText\":\"%s\",\"errorCode\":%d}",
+		                    errormsg, error_code);
+	}
+
+	bool retVal = LSMessageReply(sh, message, errorString, NULL);
+
+	if (!retVal)
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(errorString);
+}
+
+void
+LSMessageReplySuccess(LSHandle *sh, LSMessage *message)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	bool retVal = LSMessageReply(sh, message, "{\"returnValue\":true}",
+	                             NULL);
+
+	if (!retVal)
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+}
+
+bool LSMessageValidateSchema(LSHandle *sh, LSMessage *message,
+                             raw_buffer schema, jvalue_ref *parsedObj)
+{
+	bool ret = false;
+	jschema_ref input_schema = jschema_parse(schema, DOMOPT_NOOPT, NULL);
+
+	if (!input_schema)
+	{
+		return false;
+	}
+
+	JSchemaInfo schemaInfo;
+	jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+	*parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)),
+	                        DOMOPT_NOOPT, &schemaInfo);
+
+	if (jis_null(*parsedObj))
+	{
+		input_schema = jschema_parse(j_cstr_to_buffer(SCHEMA_ANY), DOMOPT_NOOPT, NULL);
+		jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+		*parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)),
+		                        DOMOPT_NOOPT, &schemaInfo);
+
+		if (jis_null(*parsedObj))
+		{
+			LSMessageReplyErrorBadJSON(sh, message);
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Could not validate json message against schema",
+			                          WCA_API_ERROR_SCHEMA_VALIDATION);
+			j_release(parsedObj);
+		}
+	}
+	else
+	{
+		ret = true;
+	}
+
+	jschema_release(&input_schema);
+	return ret;
+}
+
+static bool LSMessageParseToNative_valist(LSMessage *message, jvalue_ref *parsedObj, va_list args)
+{
+	char* error;
+	JSchemaInfo schemaInfo;
+	jschema_info_init(&schemaInfo, jschema_all(), NULL, NULL);
+	*parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)),
+	                        DOMOPT_NOOPT, &schemaInfo);
+
+	if (jis_null(*parsedObj))
+	{
+		LSMessageReplyErrorBadJSON(LSMessageGetConnection(message), message);
+		return false;
+	}
+
+	error = json_convert_to_native_valist(*parsedObj, &args);
+
+	if (error)
+	{
+		char* error_msg = g_strdup_printf("Could not validate json message against schema: %s", error);
+
+		LSMessageReplyCustomError(LSMessageGetConnection(message),
+		                          message,
+		                          error_msg,
+		                          WCA_API_ERROR_SCHEMA_VALIDATION);
+		j_release(parsedObj);
+		g_free(error);
+		g_free(error_msg);
+		*parsedObj = NULL;
+	}
+
+	return error == NULL;
+}
+
+/**
+ * Parse luna message to JSON and store fields to C variables.
+ * Returns false and sends error message back to caller
+ * if failed to parse or mandatory variables are missing or numeric fields
+ * do not fit in specified data types (eg negative value for signed data).
+ *
+ * The parsed values are valid as long as the the parsed jvalue_ref is valid.
+ *
+ * Usage:
+ * bool boolVar;
+ * const char* stringVar;
+ * jvalue_ref jvalue;
+ *	LSMessageParseToNative(message, &jvalue,
+ *		json_object_start,
+ *		json_type_boolean, "boolParam", &boolVar, TRUE // Mandatory
+ *		json_type_string, "stringParam", &const, FALSE, // Optional
+ *		...
+ *		json_object_start);
+ *
+ *   //Use the variables
+ *
+ *   j_release(jvalue);  // String variables are no longer valid after this.
+ *
+ * The json_object_start/json_object_end are delimiters,
+ * used to validate parameters structure.
+ *
+ *
+ */
+bool LSMessageParseToNative(LSMessage *message,
+                            jvalue_ref *parsedObj, ...)
+{
+	bool result;
+	va_list args;
+
+	va_start(args, parsedObj);
+	result = LSMessageParseToNative_valist(message, parsedObj, args);
+	va_end(args);
+
+	return result;
+}
+
+
+/**
+ * Call LSMessageParseToNative and then add to subscription list if subscribed.
+ * This parses the message to json only once, compared to
+ * regular LSMessageIsSubscription + LSSubscriptionProcess that would parse it 3
+ * times.
+ */
+bool LSMessageParseToNativeWithSubscription(LSMessage *message,
+                                            jvalue_ref *parsedObj, ...)
+{
+	bool result;
+	va_list args;
+
+	va_start(args, parsedObj);
+	result = LSMessageParseToNative_valist(message, parsedObj, args);
+	va_end(args);
+
+	if (result)
+	{
+		jvalue_ref subscribeObj;
+		bool subscribed = FALSE;
+
+		if (jobject_get_exists(*parsedObj, J_CSTR_TO_BUF("subscribe"), &subscribeObj))
+		{
+			jboolean_get(subscribeObj, &subscribed);
+		}
+
+		if (subscribed)
+		{
+			LSError lserror;
+			LSErrorInit(&lserror);
+
+			const char *key = LSMessageGetKind(message);
+			if (!LSSubscriptionAdd(LSMessageGetConnection(message), key, message, &lserror))
+			{
+				LSErrorPrint(&lserror, stderr);
+				LSErrorFree(&lserror);
+				LSMessageReplyErrorUnknown(LSMessageGetConnection(message), message);
+
+				j_release(parsedObj);
+				*parsedObj = NULL;
+				result = false;
+			}
+		}
+	}
+
+	return result;
+}
+
+/*
+ * Same as LSMessageParseToNative but works on already parsed jvalue.
+ */
+bool LSMessageParseFragmentToNative(LSMessage *message,
+                                    jvalue_ref parsedObj, ...)
+{
+	char* error;
+	va_list args;
+
+	va_start(args, parsedObj);
+	error = json_convert_to_native_valist(parsedObj, &args);
+	va_end(args);
+
+	if (error)
+	{
+		char* error_msg = g_strdup_printf("Could not validate json message against schema: %s", error);
+
+		LSMessageReplyCustomError(LSMessageGetConnection(message),
+		                          message,
+		                          error_msg,
+		                          WCA_API_ERROR_SCHEMA_VALIDATION);
+		g_free(error);
+		g_free(error_msg);
+	}
+
+	return error == NULL;
+}
+
+/**
+ * Create reply message and send to caller.
+ * Sends an error message to caller if failed to create requested message.
+ *
+ * Usage:
+ *	LSMessageReplySuccessWithData(message,
+ *		json_object_start,
+ *		json_type_boolean, "boolParam", true,
+ *		json_type_string, "stringParam", "stringValue", true,
+ *		json_type_string, "int", intVariable, intVariable != NULL,
+ *		...
+ *		json_object_end);
+ *
+ * The json_object_start/json_object_end are delimiters,
+ * used to validate parameters structure.
+ *
+ */
+
+void LSMessageReplySuccessWithData(LSMessage *message, ...)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	jvalue_ref replyObj = 0;
+	char* error;
+	va_list args;
+
+
+	va_start(args, message);
+	error = json_generate_from_native_valist(&replyObj, &args);
+	va_end(args);
+
+	if (error)
+	{
+		WCALOG_ERROR(MSGID_LUNA_CREATE_JSON_FAILED, 0, "Failed to create JSON response: %s", error);
+		LSMessageReplyErrorUnknown(LSMessageGetConnection(message), message);
+		g_free(error);
+		return;
+	}
+
+	/* Set returnValue=true if the caller has not already done so. */
+	jobject_put(replyObj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	if (!LSMessageRespond(message,
+	                    jvalue_tostring(replyObj, jschema_all()),
+	                    &lserror))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_LUNA_SEND_FAILED, lserror.message);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&replyObj);
+}
+
+/**
+ * Same as LSMessageReplySuccessWithData, but compares response to previous reply
+ * and does not send reply if contents equal.
+ * And replaces previous reply with the new reply.
+ */
+void LSMessageReplySuccessWithDataNoDuplicates(LSMessage *message, char** previous_reply, ...)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	jvalue_ref replyObj = 0;
+	char* error;
+	va_list args;
+
+	va_start(args, message);
+	error = json_generate_from_native_valist(&replyObj, &args);
+	va_end(args);
+
+	if (error)
+	{
+		WCALOG_ERROR(MSGID_LUNA_CREATE_JSON_FAILED, 0, "Failed to create JSON response: %s", error);
+		LSMessageReplyErrorUnknown(LSMessageGetConnection(message), message);
+		g_free(error);
+		return;
+	}
+
+	/* Set returnValue=true if the caller has not already done so. */
+	jobject_put(replyObj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	const char* reply_string = jvalue_tostring(replyObj, jschema_all());
+
+	if (previous_reply && *previous_reply && g_strcmp0(*previous_reply, reply_string) == 0)
+	{
+		// Duplicate response
+		return;
+	}
+
+	if (!LSMessageRespond(message,
+	                      reply_string,
+	                      &lserror))
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_LUNA_SEND_FAILED, lserror.message);
+		LSErrorFree(&lserror);
+	}
+
+	if (previous_reply)
+	{
+		g_free(*previous_reply);
+		*previous_reply = g_strdup(reply_string);
+	}
+
+	j_release(&replyObj);
+}
diff --git a/src/lunaservice_utils.h b/src/lunaservice_utils.h
new file mode 100644
index 0000000..4207bf2
--- /dev/null
+++ b/src/lunaservice_utils.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file lunaservice_utils.h
+ *
+ * @brief Header file defining convenience functions for sending luna error messages
+ *
+ */
+
+
+#ifndef __LUNASERVICE_UTILS_H__
+#define __LUNASERVICE_UTILS_H__
+
+#include <luna-service2/lunaservice.h>
+#include "json_utils.h"
+
+typedef struct luna_service_request
+{
+	LSHandle *handle;
+	LSMessage *message;
+	void *user_data;
+} luna_service_request_t;
+
+extern luna_service_request_t *luna_service_request_new(LSHandle *handle,
+        LSMessage *message);
+extern void luna_service_request_free(luna_service_request_t *service_req);
+
+extern void LSMessageReplyErrorUnknown(LSHandle *sh, LSMessage *message);
+extern void LSMessageReplyErrorInvalidParams(LSHandle *sh, LSMessage *message);
+extern void LSMessageReplyErrorBadJSON(LSHandle *sh, LSMessage *message);
+extern void LSMessageReplyCustomError(LSHandle *sh, LSMessage *message,
+                                      const char *errormsg, unsigned int error_code);
+extern void LSMessageReplySuccess(LSHandle *sh, LSMessage *message);
+extern bool LSMessageValidateSchema(LSHandle *sh, LSMessage *message,
+                                    raw_buffer schema, jvalue_ref *parsedObj);
+extern void LSMessageReplyCustomErrorWithSubscription(LSHandle *sh,
+                                                      LSMessage *message,
+                                                      const char *errormsg,
+                                                      unsigned int error_code,
+                                                      bool subscribed);
+
+extern bool LSMessageParseToNative(LSMessage *message,
+                                   jvalue_ref *parsedObj, ...);
+
+extern bool LSMessageParseFragmentToNative(LSMessage *message,
+                                           jvalue_ref parsedObj, ...);
+extern bool LSMessageParseToNativeWithSubscription(LSMessage *message,
+                                            jvalue_ref *parsedObj, ...);
+
+extern void LSMessageReplySuccessWithData(LSMessage *message, ...);
+extern void LSMessageReplySuccessWithDataNoDuplicates(LSMessage *message, char** previous_reply, ...);
+
+#endif //__LUNASERVICE_UTILS_H__
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 0000000..0c998b5
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,132 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  main.c
+ *
+ */
+
+
+#include <stdio.h>
+#include <unistd.h>
+#include <signal.h>
+#include <glib.h>
+#include <pthread.h>
+#include <stdbool.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <luna-service2/lunaservice.h>
+#include <wca-support.h>
+#include <nyx/common/nyx_core.h>
+
+#include "connman_manager.h"
+#include "logging.h"
+#include "wifi_service.h"
+#include "wifi_setting.h"
+#include "wan_service.h"
+#include "pan_service.h"
+#include "connectionmanager_service.h"
+#include "nyx.h"
+
+static GMainLoop *mainloop = NULL;
+
+int initialize_wifi_ls2_calls();
+
+/**
+ * Our PmLogLib logging context
+ */
+PmLogContext gLogContext;
+
+static const char *const kLogContextName = "webos-connman-adapter";
+
+void
+term_handler(int signal)
+{
+	g_main_loop_quit(mainloop);
+}
+
+int
+main(int argc, char **argv)
+{
+	LSHandle *wifi_handle, *wan_handle, *cm_handle, *pan_handle;
+	signal(SIGTERM, term_handler);
+	signal(SIGINT, term_handler);
+
+	mainloop = g_main_loop_new(NULL, FALSE);
+
+	(void) PmLogGetContext(kLogContextName, &gLogContext);
+
+	WCALOG_DEBUG("Starting webos-connman-adapter");
+
+	if (!init_nyx())
+	{
+		WCALOG_ERROR(MSGID_WIFI_SRVC_REGISTER_FAIL, 0,
+		             "Error in initializing nyx");
+		return -1;
+	}
+
+	if (initialize_wifi_ls2_calls(mainloop, &wifi_handle) < 0)
+	{
+		WCALOG_ERROR(MSGID_WIFI_SRVC_REGISTER_FAIL, 0,
+		             "Error in initializing com.webos.service.wifi service");
+		return -1;
+	}
+
+	if (initialize_wan_ls2_calls(mainloop, &wan_handle) < 0)
+	{
+		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
+		             "Error in initializing com.webos.service.wan service");
+		return -1;
+	}
+
+	if (initialize_pan_ls2_calls(mainloop, &pan_handle) < 0)
+	{
+		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
+		             "Error in initializing com.webos.serivce.pan service");
+		return -1;
+	}
+
+	if (initialize_connectionmanager_ls2_calls(mainloop, &cm_handle) < 0)
+	{
+		WCALOG_ERROR(MSGID_CM_SRVC_REGISTER_FAIL, 0,
+		             "Error in initializing com.webos.service.connectionmanager service");
+		return -1;
+	}
+
+	wca_support_connman_update_callbacks wca_support_library_cb = { 0 };
+
+	if (wca_support_init(wifi_handle, cm_handle, wan_handle,
+	                     &wca_support_library_cb, NULL, &gLogContext) < 0)
+	{
+		WCALOG_ERROR(MSGID_WCA_SUPPORT_FAIL, 0,
+		             "Failed to initialize webOS connman adapter support library");
+		return -1;
+	}
+
+	set_wca_support_connman_update_callbacks(&wca_support_library_cb);
+
+	g_main_loop_run(mainloop);
+
+	wca_support_release();
+
+	remove_config_inotify_watch();
+
+	g_main_loop_unref(mainloop);
+
+	release_nyx();
+
+	return 0;
+}
diff --git a/src/nyx.c b/src/nyx.c
new file mode 100644
index 0000000..380e8c8
--- /dev/null
+++ b/src/nyx.c
@@ -0,0 +1,85 @@
+// Copyright (c) 2016-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include <glib.h>
+#include <string.h>
+#include <nyx/nyx_module.h>
+#include <nyx/client/nyx_device_info.h>
+
+#include "nyx.h"
+#include "logging.h"
+
+static nyx_device_handle_t device_main = NULL;
+
+bool init_nyx()
+{
+	if (nyx_init() != NYX_ERROR_NONE)
+	{
+		WCALOG_ERROR(MSGID_NYX_INIT_ERROR, 0, "Error in nyx_init");
+		return false;
+	}
+
+	if (nyx_device_open(NYX_DEVICE_DEVICE_INFO, "Main", &device_main) != NYX_ERROR_NONE)
+	{
+		WCALOG_ERROR(MSGID_NYX_DEVICE_OPEN_ERROR, 0, "Error in nyx_device_open");
+		return false;
+	}
+
+	return true;
+}
+
+void release_nyx()
+{
+	if (device_main)
+	{
+		if (nyx_device_close(device_main) != NYX_ERROR_NONE)
+		{
+			WCALOG_ERROR(MSGID_NYX_DEVICE_CLOSE_ERROR, 0, "Error while closing nyx device");
+		}
+		device_main = 0;
+	}
+
+	if (nyx_deinit() != NYX_ERROR_NONE)
+	{
+		WCALOG_ERROR(MSGID_NYX_DEINIT_ERROR, 0, "Error in nyx_deinit");
+	}
+}
+
+static bool retrieve_nyx_data(nyx_device_info_type_t type, char* buffer, size_t buffer_size)
+{
+	nyx_error_t error;
+	const char* nyx_buffer = NULL;
+
+	error = nyx_device_info_query(device_main, type, &nyx_buffer);
+
+	if (error != NYX_ERROR_NONE)
+	{
+		return false;
+	}
+
+	g_strlcpy(buffer, nyx_buffer, buffer_size);
+	return true;
+}
+
+bool retrieve_wired_mac_address(char* buffer, size_t buffer_size)
+{
+	return retrieve_nyx_data(NYX_DEVICE_INFO_WIRED_ADDR, buffer, buffer_size);
+}
+
+bool retrieve_wifi_mac_address(char* buffer, size_t buffer_size)
+{
+	return retrieve_nyx_data(NYX_DEVICE_INFO_WIFI_ADDR, buffer, buffer_size);
+}
\ No newline at end of file
diff --git a/src/nyx.h b/src/nyx.h
new file mode 100644
index 0000000..8269cd1
--- /dev/null
+++ b/src/nyx.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2016-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef _NYX_H_
+#define _NYX_H_
+
+#include <stdbool.h>
+
+#define UNUSED(x) (void)(x)
+
+#define MAC_ADDR_STRING_LEN 32
+
+extern bool init_nyx();
+
+extern void release_nyx();
+
+extern bool retrieve_wired_mac_address(char* buffer, size_t buffer_size);
+
+extern bool retrieve_wifi_mac_address(char* buffer, size_t buffer_size);
+
+#endif /* _NYX_H_ */
diff --git a/src/pacrunner_client.c b/src/pacrunner_client.c
new file mode 100644
index 0000000..3621755
--- /dev/null
+++ b/src/pacrunner_client.c
@@ -0,0 +1,101 @@
+// Copyright (c) 2016-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file pacrunner_client.c
+ *
+ * @brief pacrunner client interface
+ *
+ */
+
+#include "pacrunner_client.h"
+#include "utils.h"
+#include "logging.h"
+
+
+gchar *pacrunner_client_find_proxy_for_url(pacrunner_client_t *client,
+		const gchar *url, const gchar *host)
+{
+	if (NULL == client)
+	{
+		return NULL;
+	}
+
+	GError *error = NULL;
+	gchar *proxy;
+
+	pacrunner_interface_client_call_find_proxy_for_url_sync(client->remote,
+				url, host, &proxy, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_PACRUNNER_CLIENT_FINDPROXYFORURL_ERROR, error->message);
+		g_error_free(error);
+		return NULL;
+	}
+
+	return proxy;
+}
+
+/**
+ * Initialize a new client instance
+ * (see header for API details)
+ */
+
+pacrunner_client_t *pacrunner_client_new(void)
+{
+	GError *error = NULL;
+	pacrunner_client_t *client = g_new0(pacrunner_client_t, 1);
+
+	if (client == NULL)
+	{
+		return NULL;
+	}
+
+	client->remote = pacrunner_interface_client_proxy_new_for_bus_sync(
+						G_BUS_TYPE_SYSTEM,
+						G_DBUS_PROXY_FLAGS_NONE,
+						"org.pacrunner", "/org/pacrunner/client",
+						NULL,
+						&error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_PACRUNNER_CLIENT_INIT_ERROR, error->message);
+		g_error_free(error);
+		g_free(client);
+		return NULL;
+	}
+
+	return client;
+}
+
+/**
+ * Free the client instance (see header for API details)
+ */
+
+void pacrunner_client_free(pacrunner_client_t *client)
+{
+
+	if (NULL == client)
+	{
+		return;
+	}
+
+	g_object_unref(client->remote);
+	g_free(client);
+	client = NULL;
+}
diff --git a/src/pacrunner_client.h b/src/pacrunner_client.h
new file mode 100644
index 0000000..ac42db3
--- /dev/null
+++ b/src/pacrunner_client.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2016-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  pacrunner_client.h
+ *
+ * @brief Header file defining functions and data structures for interacting with pacrunner client
+ *
+ */
+
+#ifndef PACRUNNER_CLIENT_H_
+#define PACRUNNER_CLIENT_H_
+
+#include <gio/gio.h>
+#include <glib-object.h>
+
+#include "pacrunner-interface.h"
+
+/**
+ * Local instance of a pacrunner client
+ *
+ * Stores all required information
+ */
+
+typedef struct pacrunner_client
+{
+	PacrunnerInterfaceClient *remote;
+} pacrunner_client_t;
+
+extern gchar *pacrunner_client_find_proxy_for_url(pacrunner_client_t *client,
+		const gchar *url, const gchar *host);
+/**
+ * Initialize a new manager instance
+ */
+extern pacrunner_client_t *pacrunner_client_new(void);
+
+/**
+ * Free the client instance
+ *
+ * @param[IN]  client A client instance
+ */
+extern void pacrunner_client_free(pacrunner_client_t *client);
+
+#endif /* PACRUNNER_CLIENT_H_ */
diff --git a/src/pan_service.c b/src/pan_service.c
new file mode 100644
index 0000000..60a2574
--- /dev/null
+++ b/src/pan_service.c
@@ -0,0 +1,1066 @@
+// Copyright (c) 2014-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  pan_service.c
+ *
+ * @brief Implements all of com.webos.service.pan service methods using connman APIs
+ * in the backend.
+ */
+
+#include <glib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <pbnjson.h>
+
+#include "pan_service.h"
+#include "connman_manager.h"
+#include "lunaservice_utils.h"
+#include "connman_common.h"
+#include "connman_service.h"
+#include "common.h"
+#include "logging.h"
+#include "utils.h"
+#include "errors.h"
+#include "connectionmanager_service.h"
+
+//#define NAP_WITHOUT_COLON_ADDRESS_LENGTH 12
+#define PAN_MAC_ADDRESS_LENGTH 17
+
+static LSHandle *pLsHandle;
+
+luna_service_request_t *current_connect_req;
+
+/**
+ *  @brief Callback function registered with connman technology whenever any of its properties change
+ *
+ *
+ *  @param data
+ *  @param property
+ *  @param value
+ */
+
+static void technology_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	connman_technology_t *technology = (connman_technology_t *)data;
+
+	if (NULL == technology)
+	{
+		return;
+	}
+
+	connman_technology_t *bluetooth_technology =
+	    connman_manager_find_bluetooth_technology(manager);
+
+	if (technology != bluetooth_technology)
+	{
+		return;
+	}
+
+	if (g_strcmp0(property, "Powered") == 0 ||
+	        g_strcmp0(property, "Connected") == 0)
+	{
+		connectionmanager_send_status_to_subscribers();
+		send_pan_connection_status_to_subscribers();
+	}
+	else if (g_strcmp0(property, "Tethering") == 0)
+	{
+		send_pan_connection_status_to_subscribers();
+		connectionmanager_send_status_to_subscribers();
+	}
+}
+
+/**
+ *  @brief Callback function registered with connected bluetooth service whenever any of its properties change
+ *
+ *
+ *  @param data
+ *  @param property
+ *  @param value
+ */
+
+static void service_changed_cb(gpointer user_data, const gchar *name,
+                               GVariant *value)
+{
+	connectionmanager_send_status_to_subscribers();
+}
+
+/**
+ *  @brief Add details about the connected service
+ *
+ *  @param reply
+ *  @param connected_service
+ *
+ */
+
+/**
+ *  @brief Sets the bluetooth technologies tethering state
+ *
+ *  @param state
+ */
+
+static gboolean set_bluetooth_tethering(bool state)
+{
+	if (state == is_bluetooth_tethering())
+	{
+		return FALSE;
+	}
+
+	connman_technology_t *bluetooth_tech =
+	    connman_manager_find_bluetooth_technology(manager);
+
+	if (!bluetooth_tech)
+	{
+		return FALSE;
+	}
+
+	if (!is_bluetooth_powered() && state)
+	{
+		// we need to have Bluetooth powered otherwise we can't start tethering
+		connman_technology_set_powered(bluetooth_tech, TRUE, NULL);
+
+		// FIXME this should go away once we switch to asynchronous variant of
+		// connman_technology_set_powered method
+		g_usleep(2000000);
+	}
+
+	if (state)
+	{
+		connman_service_t *connected_service = connman_manager_get_connected_service(
+		        manager->bluetooth_services);
+
+		if (connected_service)
+		{
+			connman_service_disconnect(connected_service);
+		}
+	}
+
+	return connman_technology_set_tethering(bluetooth_tech, state);
+}
+
+static void add_connected_network_status(jvalue_ref *reply,
+        connman_service_t *connected_service)
+{
+	if (NULL == reply || NULL == connected_service)
+	{
+		return;
+	}
+
+	int connman_state = 0;
+	jobject_put(*reply, J_CSTR_TO_JVAL("status"),
+	            jstring_create("connectionStateChanged"));
+
+	jvalue_ref network_info = jobject_create();
+
+	/* Fill in details about the service NAP*/
+	if (connected_service->display_name != NULL)
+	{
+		jobject_put(network_info, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(connected_service->display_name));
+	}
+	else
+	{
+		jobject_put(network_info, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(connected_service->name));
+	}
+
+	if (connected_service->address != NULL)
+	{
+		jobject_put(network_info, J_CSTR_TO_JVAL("address"),
+		            jstring_create(connected_service->address));
+	}
+
+	if (connected_service->state != NULL)
+	{
+		connman_state = connman_service_get_state(connected_service->state);
+	}
+
+	/* Fill in ip information only for a service which is online (fully connected) */
+	if (connman_state == CONNMAN_SERVICE_STATE_ONLINE
+	        || connman_state == CONNMAN_SERVICE_STATE_READY)
+	{
+		connman_service_get_ipinfo(connected_service);
+		jvalue_ref ip_info = jobject_create();
+
+		if (connected_service->ipinfo.iface)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("interface"),
+			            jstring_create(connected_service->ipinfo.iface));
+		}
+
+		if (connected_service->ipinfo.ipv4.address)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("ip"),
+			            jstring_create(connected_service->ipinfo.ipv4.address));
+		}
+
+		if (connected_service->ipinfo.ipv4.netmask)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("subnet"),
+			            jstring_create(connected_service->ipinfo.ipv4.netmask));
+		}
+
+		if (connected_service->ipinfo.ipv4.gateway)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("gateway"),
+			            jstring_create(connected_service->ipinfo.ipv4.gateway));
+		}
+
+		if (connected_service->ipinfo.dns != NULL)
+		{
+			gsize i;
+			char dns_str[16];
+
+			for (i = 0; i < g_strv_length(connected_service->ipinfo.dns); i++)
+			{
+				g_snprintf(dns_str, 16, "dns%d", i + 1);
+				jobject_put(ip_info, jstring_create(dns_str),
+				            jstring_create(connected_service->ipinfo.dns[i]));
+			}
+		}
+
+		if (connected_service->ipinfo.ipv4.method)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("method"),
+			            jstring_create(connected_service->ipinfo.ipv4.method));
+		}
+
+		jobject_put(network_info, J_CSTR_TO_JVAL("ipInfo"), ip_info);
+	}
+
+	jobject_put(*reply,  J_CSTR_TO_JVAL("networkInfo"), network_info);
+
+}
+
+/**
+ * @brief Fill in information about the NAP
+ *
+ * @param status json status object to fill with the service status
+ */
+
+void append_nap_info(jvalue_ref *status)
+{
+	if (NULL == status)
+	{
+		return;
+	}
+
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+	        manager->bluetooth_services);
+
+	if (NULL == connected_service)
+	{
+		return;
+	}
+
+	jvalue_ref nap_info = jobject_create();
+
+	if (connected_service->address != NULL)
+	{
+		jobject_put(nap_info, J_CSTR_TO_JVAL("address"),
+		            jstring_create(connected_service->address));
+	}
+
+	/* Fill in details about the service NAP*/
+	if (connected_service->display_name != NULL)
+	{
+		jobject_put(nap_info, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(connected_service->display_name));
+	}
+	else
+	{
+		jobject_put(nap_info, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(connected_service->name));
+	}
+
+	jobject_put(*status, J_CSTR_TO_JVAL("nap"), nap_info);
+}
+
+/**
+ * @brief Fill in all status information to be sent with 'getStatus' method
+ */
+
+static void append_pan_status(jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("tetheringEnabled"),
+	            jboolean_create(is_bluetooth_tethering()));
+
+	gboolean powered = is_bluetooth_powered();
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("status"),
+	            jstring_create(powered ? "serviceEnabled" : "serviceDisabled"));
+
+	/* Get the service which is connecting or already in connected state */
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+	        manager->bluetooth_services);
+
+	if (connected_service != NULL)
+	{
+		add_connected_network_status(reply, connected_service);
+	}
+}
+
+void send_pan_connection_status_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	append_pan_status(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+
+		WCALOG_DEBUG("Sending payload : %s", payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_PAN_GETSTATUS, payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+static gboolean compare_address(char *first, char *second)
+{
+	gboolean ret;
+	char *first_address, *second_address;
+
+	first_address = g_ascii_strup(first, PAN_MAC_ADDRESS_LENGTH);
+	second_address = g_ascii_strup(second, PAN_MAC_ADDRESS_LENGTH);
+
+	if (!g_strcmp0(first_address, second_address))
+	{
+		ret = TRUE;
+	}
+	else
+	{
+		ret = FALSE;
+	}
+
+	g_free(first_address);
+	g_free(second_address);
+
+	return ret;
+}
+
+static void current_connect_req_free()
+{
+	luna_service_request_free(current_connect_req);
+	current_connect_req = NULL;
+
+}
+
+/**
+ * When the user requests a connection to a network and the connection establishment
+ * process fails we don't immediately report this to the user but waiting until the
+ * service object enters the failure state in order to analyze why things went wrong.
+
+ * By doing this we can provide a appropiate error message to the user an not simply
+ * failing with a common error message.
+ *
+ * Currently we're handling all known errors connman returns. See method error2string
+ * in src/service.c of the connman source tree for all currently handled errors.
+ */
+
+static void handle_failed_connection_request(gpointer user_data)
+{
+	const char *error_message = "Unknown error";
+	unsigned int error_code = WCA_API_ERROR_UNKNOWN;
+
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	if (NULL == current_connect_req)
+	{
+		return;
+	}
+
+	connman_service_t *service = current_connect_req->user_data;
+
+	if (NULL == service || NULL == g_slist_find(manager->bluetooth_services, service))
+	{
+		goto reply;
+	}
+
+	if (NULL == service->path)
+	{
+		WCALOG_INFO(MSGID_PAN_SKIPPING_FETCH_PROPERTIES, 0,
+		            "Skipping fetch properties");
+		goto reply;
+	}
+
+	if (NULL == connman_manager_find_service_by_path(manager->bluetooth_services,
+	        service->path))
+	{
+		WCALOG_INFO(MSGID_PAN_SERVICE_NOT_EXIST, 0, "Service %s doesn't exist",
+		            service->name);
+		goto reply;
+	}
+
+	GVariant *properties = connman_service_fetch_properties(service);
+
+	if (NULL == properties)
+	{
+		goto reply;
+	}
+
+	connman_service_update_properties(service, properties);
+	g_variant_unref(properties);
+
+	if (g_strcmp0(service->error, "connect-failed") == 0)
+	{
+		error_message = "Could not establish a connection to NAP";
+		error_code = WCA_API_ERROR_CONNECT_FAILED;
+	}
+	else if (g_strcmp0(service->error, "dhcp-failed") == 0)
+	{
+		error_message = "Could not retrieve a valid IP address by using DHCP";
+		error_code = WCA_API_ERROR_DHCP_FAILED;
+	}
+
+reply:
+
+	LSMessageReplyCustomError(current_connect_req->handle,
+	                          current_connect_req->message,
+	                          error_message, error_code);
+
+	current_connect_req_free();
+}
+
+static void service_connect_callback(gboolean success, gpointer user_data)
+{
+	UNUSED(user_data);
+
+	if (!current_connect_req)
+	{
+		// Something is wrong. It should have been there. There is no luna call to respond to. Log an error.
+		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_CONNECT_SERVICE_ERROR,
+		                      "Missing connect request on connect callback!");
+		return;
+	}
+
+	luna_service_request_t *service_req = current_connect_req;
+
+	/* if the connection could not be established we're waiting for the service to switch
+	 * it's state to failure until we report the failed connection request to the user */
+	if (!success)
+	{
+		g_timeout_add_seconds(2, handle_failed_connection_request, NULL);
+		return;
+	}
+
+	LSMessageReplySuccess(service_req->handle, service_req->message);
+
+	current_connect_req_free();
+}
+
+/**
+ *  @brief Connect to a PAN server with the given target MAC adress
+ *
+ *  @param address the remote device address
+ */
+
+static void connect_pan_with_address(char *address,
+                                     luna_service_request_t *service_req)
+{
+	GSList *nap;
+	gboolean found_service = FALSE;
+	connman_service_t *service = NULL;
+
+	connman_technology_t *bluetooth_tech =
+	    connman_manager_find_bluetooth_technology(manager);
+
+	if (NULL == address || NULL == bluetooth_tech)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Internal error", WCA_API_ERROR_INTERNAL);
+		goto cleanup;
+	}
+
+	if (current_connect_req)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Already connecting to a network", WCA_API_ERROR_ALREADY_CONNECTING);
+		goto cleanup;
+	}
+
+	for (nap = manager->bluetooth_services; NULL != nap ; nap = nap->next)
+	{
+		service = (connman_service_t *)(nap->data);
+
+		/* Service's address or User input's address would be uppercase letters or lowercase letters.
+		 * So, this converts these to uppercase letters to compare whether these are same or not. */
+		if (compare_address(service->address, address))
+		{
+			found_service = TRUE;
+			break;
+		}
+	}
+
+	if (!found_service)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Network not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
+		goto cleanup;
+	}
+
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+			manager->bluetooth_services);
+
+	if (NULL != connected_service && (connected_service == service))
+	{
+		/* Already connected so connection was successful */
+		LSMessageReplySuccess(service_req->handle, service_req->message);
+		WCALOG_DEBUG("Already connected with network");
+		goto cleanup;
+	}
+
+	service_req->user_data = service;
+	current_connect_req = service_req;
+
+	if (!connman_service_connect(service, service_connect_callback, service_req))
+	{
+		current_connect_req = NULL;
+		LSMessageReplyErrorUnknown(service_req->handle, service_req->message);
+		goto cleanup;
+	}
+
+	goto exit;
+
+cleanup:
+	luna_service_request_free(service_req);
+exit:
+	return;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_pan com.webos.pan
+@{
+@section com_webos_pan_connect
+
+Connects to the remote Bluethooth device which is a NAP role.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+address | Yes | String | Address of discovered Bluetooth NAP device
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@}
+*/
+//->End of API documentation comment block
+static bool handle_pan_connect_command(LSHandle *sh, LSMessage *message,
+                                       void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!bluetooth_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_bluetooth_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "Bluetooth switched off",
+		                          WCA_API_ERROR_BLUETOOTH_SWITCHED_OFF);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(address,
+	                                     string)) REQUIRED_1(address))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref addressObj = {0};
+	char *address;
+	luna_service_request_t *service_req;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	service_req = luna_service_request_new(sh, message);
+	connect_pan_with_address(address, service_req);
+
+	g_free(address);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_pan com.webos.pan
+@{
+@section com_webos_pan_disconnect
+
+Disconnects the remote Bluethooth device which is a NAP role.
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@}
+*/
+//->End of API documentation comment block
+static bool handle_pan_disconnect_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!bluetooth_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_bluetooth_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "Bluetooth switched off",
+		                          WCA_API_ERROR_BLUETOOTH_SWITCHED_OFF);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(address,
+	                                     string)) REQUIRED_1(address))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref addressObj = {0};
+	char *address;
+	connman_service_t *connected_service;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto exit;
+	}
+
+	connected_service = connman_manager_get_connected_service(
+	                        manager->bluetooth_services);
+
+	if (!connected_service || !compare_address(connected_service->address, address))
+	{
+		LSMessageReplyCustomError(sh, message, "No service is connected",
+		                          WCA_API_ERROR_NO_SERVICE_CONNECTED);
+		goto cleanup;
+	}
+
+	if (!connman_service_disconnect(connected_service))
+	{
+		LSMessageReplyCustomError(sh, message,
+		                          "Failed to disconnect the connected service",
+		                          WCA_API_ERROR_DISCONNECT_FAILED);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+
+cleanup:
+	g_free(address);
+exit:
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_pan com.webos.pan
+@{
+@section com_webos_pan_get_status
+
+Gets the current status of pan connection on the system.
+
+Callers can subscribe to this method to be notified of any changes
+in the pan connection status.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subscribe to this method
+
+@par Returns(Call)
+
+All optional fields are absent if PAN is not connected
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+networkInfo | No | Object | A single object describing the current connection
+tetheringEnabled | Yes | Boolean | Indicates if PAN tethering is enabled or not
+
+@par "networkInfo" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ipInfo | Yes | Object | See below
+
+@par "ipInfo" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+interface | Yes | String |
+ip | Yes | String | IP Address
+subnet | Yes | String | Subnet mask value
+gateway | Yes | String |IP Address of network gateway
+dns | Yes | Array of String | List of DNS server IP addresses
+
+@par Returns(Subscription)
+
+As for a successful call
+@}
+*/
+//->End of API documentation comment block
+static bool handle_pan_get_status_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!bluetooth_technology_status_check_with_subscription(sh, message,
+	        subscribed))
+	{
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	append_pan_status(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	if (!jis_null(parsedObj))
+	{
+		j_release(&parsedObj);
+	}
+
+	if (!jis_null(reply))
+	{
+		j_release(&reply);
+	}
+
+	return true;
+}
+
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_service_pan com.webos.service.pan/setTethering
+@{
+@section com_webos_service_pan_setTethering setTethering
+
+Set tethering state.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+enabled | Yes | boolean | enable / disable tethering
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_pan_set_tethering_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(enabled,
+	                                     boolean)) REQUIRED_1(enabled))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref enabledObj = {0};
+	gboolean enable_tethering = FALSE;
+
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!bluetooth_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
+	{
+		jboolean_get(enabledObj, &enable_tethering);
+
+		if (enable_tethering && is_bluetooth_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Already Enabled",
+			                          WCA_API_ERROR_ALREADY_ENABLED);
+			goto cleanup;
+		}
+		else if (!enable_tethering && !is_bluetooth_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Already Disabled",
+			                          WCA_API_ERROR_ALREADY_DISABLED);
+			goto cleanup;
+		}
+	}
+
+	if (!set_bluetooth_tethering(enable_tethering))
+	{
+		if (enable_tethering)
+		{
+			LSMessageReplyCustomError(sh, message, "Failed to enable tethering mode",
+			                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message, "Failed to disable tethering mode",
+			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
+		}
+
+		goto cleanup;
+	}
+	else
+	{
+		LSMessageReplySuccess(sh, message);
+	}
+
+
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+/**
+ * com.webos.service.pan service Luna Method Table
+ */
+
+static LSMethod pan_methods[] =
+{
+	{ LUNA_METHOD_PAN_CONNECT,                 handle_pan_connect_command },
+	{ LUNA_METHOD_PAN_DISCONNECT,              handle_pan_disconnect_command },
+	{ LUNA_METHOD_PAN_GETSTATUS,               handle_pan_get_status_command },
+	{ LUNA_METHOD_PAN_SETTETHERING,            handle_pan_set_tethering_command },
+	{},
+};
+
+int initialize_pan_ls2_calls(GMainLoop *mainloop, LSHandle **pan_handle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	pLsHandle = NULL;
+
+	if (NULL == mainloop)
+	{
+		goto Exit;
+	}
+
+	if (LSRegister(PAN_LUNA_SERVICE_NAME, &pLsHandle, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_LUNA_BUS_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_ROOT, pan_methods, NULL, NULL,
+	                       &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_METHODS_LUNA_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	if (LSGmainAttach(pLsHandle, mainloop, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_GLOOP_ATTACH_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	*pan_handle = pLsHandle;
+
+	return 0;
+
+Exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	if (pLsHandle)
+	{
+		LSErrorInit(&lserror);
+
+		if (LSUnregister(pLsHandle, &lserror) == false)
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	return -1;
+}
+
+void check_and_initialize_bluetooth_technology(void)
+{
+	connman_technology_t *technology = connman_manager_find_bluetooth_technology(
+	                                       manager);
+
+	if (!technology)
+	{
+		return;
+	}
+
+	connman_technology_register_property_changed_cb(technology,
+	        technology_property_changed_callback);
+
+	/* Register property change callback for all connected bluetooth services */
+	GSList *iter;
+
+	for (iter = manager->bluetooth_services; iter != NULL; iter = iter->next)
+	{
+		connman_service_t *service = iter->data;
+
+		if (!connman_service_is_connected(service))
+		{
+			continue;
+		}
+
+		connman_service_register_property_changed_cb(service, service_changed_cb);
+	}
+}
diff --git a/src/pan_service.h b/src/pan_service.h
new file mode 100644
index 0000000..9b88bf3
--- /dev/null
+++ b/src/pan_service.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2014-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  pan_service.h
+ *
+ */
+
+#ifndef _PAN_SERVICE_H_
+#define _PAN_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define PAN_LUNA_SERVICE_NAME "com.webos.service.pan"
+
+
+#define LUNA_CATEGORY_ROOT               "/"
+
+/**
+ * @name Luna PAN Method Names
+ * @{
+ */
+
+#define LUNA_METHOD_PAN_CONNECT          "connect"
+#define LUNA_METHOD_PAN_DISCONNECT       "disconnect"
+#define LUNA_METHOD_PAN_GETSTATUS        "getStatus"
+#define LUNA_METHOD_PAN_SETTETHERING     "setTethering"
+
+extern void append_nap_info(jvalue_ref *status);
+extern void send_pan_connection_status_to_subscribers(void);
+extern int initialize_pan_ls2_calls(GMainLoop *mainloop,
+                                    LSHandle **pan_handle);
+extern void check_and_initialize_bluetooth_technology(void);
+
+#endif /* _PAN_SERVICE_H_ */
diff --git a/src/utils.c b/src/utils.c
new file mode 100644
index 0000000..b26b778
--- /dev/null
+++ b/src/utils.c
@@ -0,0 +1,190 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include <glib.h>
+#include <string.h>
+
+#include "utils.h"
+
+struct language_encodings
+{
+	const char *language;
+	const char *encoding1;
+	const char *encoding2;
+	const char *encoding3;
+};
+
+static struct language_encodings encodings[] =
+{
+	{ "ko-KR", "EUC-KR", "ISO-2022-KR", "JOHAB" },
+	{ "zh-Hans-CN", "EUC-CN", "GB2312", "GB18030" },
+	{ "ja-JP", "EUC-JP", "SHIFT-JIS", NULL },
+	{ NULL, NULL, NULL, NULL }
+};
+
+static struct language_encodings *get_encodings_for_language(const char *lang)
+{
+	int n;
+
+	if (lang == NULL)
+	{
+		return NULL;
+	}
+
+	for (n = 0; encodings[n].language != NULL; n++)
+	{
+		if (g_strcmp0(encodings[n].language, lang) == 0)
+		{
+			return &encodings[n];
+		}
+	}
+
+	return NULL;
+}
+
+char *convert_ssid_to_utf8(const gchar *ssid, gsize ssid_len,
+                           const gchar *system_locale)
+{
+	struct language_encodings *laenc;
+	const char *encoding1 = NULL;
+	const char *encoding2 = NULL;
+	const char *encoding3 = NULL;
+	char *converted_ssid = NULL;
+
+	if (ssid == NULL || ssid_len == 0)
+	{
+		return NULL;
+	}
+
+	laenc = get_encodings_for_language(system_locale);
+
+	if (laenc == NULL)
+	{
+		encoding1 = "iso-8859-1";
+		encoding2 = "windows-1251";
+		encoding3 = NULL;
+	}
+	else
+	{
+		encoding1 = laenc->encoding1;
+		encoding2 = laenc->encoding2;
+		encoding3 = laenc->encoding3;
+	}
+
+	converted_ssid = g_convert(ssid, ssid_len, "UTF-8", encoding1,
+	                           NULL, NULL, NULL);
+
+	if (!converted_ssid && encoding2)
+	{
+		converted_ssid = g_convert(ssid, ssid_len, "UTF-8", encoding2,
+		                           NULL, NULL, NULL);
+	}
+
+	if (!converted_ssid && encoding3)
+	{
+		converted_ssid = g_convert(ssid, ssid_len, "UTF-8", encoding3,
+		                           NULL, NULL, NULL);
+	}
+
+	if (!converted_ssid)
+		converted_ssid = g_convert_with_fallback(ssid, ssid_len,
+		                 "UTF-8", encoding1, "?",
+		                 NULL, NULL, NULL);
+
+	return converted_ssid;
+}
+
+char *strip_prefix(const char *str, const char *prefix)
+{
+	if (!str || !prefix)
+	{
+		return NULL;
+	}
+
+	size_t prefix_len = strlen(prefix);
+	size_t str_len = strlen(str);
+
+	if (str_len < prefix_len)
+	{
+		return NULL;
+	}
+
+	if (strncmp(str, prefix, prefix_len) != 0)
+	{
+		return NULL;
+	}
+
+	size_t result_len = str_len - prefix_len;
+	char *result = g_new0(char, result_len + 1);
+	strncpy(result, str + prefix_len , result_len);
+
+	return result;
+}
+
+static bool is_xstring(const char* string)
+{
+	if (!string)
+	{
+		return false;
+	}
+
+	size_t len = strlen(string);
+	size_t i;
+
+	for (i = 0; i < len; i++)
+	{
+		if (!g_ascii_isxdigit(string[i]))
+		{
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool is_valid_wifi_passphrase(const char* passphrase, const char* security)
+{
+	if  (!passphrase || !security)
+	{
+		return false;
+	}
+
+	bool is_hex = is_xstring(passphrase);
+	size_t len = strlen(passphrase);
+
+	if (g_strcmp0(security, "wep") == 0)
+	{
+		/* valid passphrases are 5 or 13 chars
+		 * if in hex - also 10 or 26 chars.
+		 * */
+		return ((len == 5 || len == 13) ||
+		        (is_hex && (len == 10 || len == 26)));
+	}
+	else if (g_strcmp0(security, "psk") == 0)
+	{
+		/* valid passphrases are 8 .. 63 chars
+		 * if in hex - 64 chars.
+		 * */
+		return (len >= 8 && (len <= 63 || (is_hex && len == 64)));
+	}
+	else
+	{
+		/**
+		 * Don't know how to validate other security types.
+		 */
+		return true;
+	}
+}
diff --git a/src/utils.h b/src/utils.h
new file mode 100644
index 0000000..51b26b8
--- /dev/null
+++ b/src/utils.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UTILS_H_
+#define UTILS_H_
+
+#include <stdbool.h>
+
+#define UNUSED(x) (void)(x)
+
+struct cb_data
+{
+	void *cb;
+	void *data;
+	void *user;
+};
+
+static inline struct cb_data *cb_data_new(void *cb, void *data)
+{
+	struct cb_data *ret;
+
+	ret = g_new0(struct cb_data, 1);
+	ret->cb = cb;
+	ret->data = data;
+	ret->user = NULL;
+
+	return ret;
+}
+
+char *convert_ssid_to_utf8(const gchar *ssid, gsize ssid_len,
+                           const gchar *system_locale);
+
+char *strip_prefix(const char *str, const char *prefix);
+
+bool is_valid_wifi_passphrase(const char* passphrase, const char* security);
+
+#endif
diff --git a/src/wan_service.c b/src/wan_service.c
new file mode 100644
index 0000000..2468a33
--- /dev/null
+++ b/src/wan_service.c
@@ -0,0 +1,996 @@
+// Copyright (c) 2013-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include <glib.h>
+#include <stdbool.h>
+#include <time.h>
+#include <string.h>
+#include <pbnjson.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <linux/if.h>
+
+#include "wan_service.h"
+#include "connman_manager.h"
+#include "connman_agent.h"
+#include "connman_service.h"
+#include "lunaservice_utils.h"
+#include "common.h"
+#include "connectionmanager_service.h"
+#include "logging.h"
+#include "errors.h"
+
+static LSHandle *pLsHandle;
+
+extern connman_manager_t *manager;
+extern connman_agent_t *agent;
+
+static void service_changed_cb(gpointer user_data, const gchar *name,
+                               GVariant *value)
+{
+	connectionmanager_send_status_to_subscribers();
+}
+
+static void retrieve_wan_context(jvalue_ref context_obj,
+                                 connman_service_t *service)
+{
+	jvalue_ref ipv4_obj, ipv6_obj, dns_obj, hosts_obj;
+	int i;
+
+	jobject_put(context_obj, J_CSTR_TO_JVAL("name"), jstring_create(service->name));
+	jobject_put(context_obj, J_CSTR_TO_JVAL("connected"),
+	            jboolean_create(connman_service_is_connected(service)));
+	jobject_put(context_obj, J_CSTR_TO_JVAL("onInternet"),
+	            jboolean_create(connman_service_is_online(service)));
+
+	if (service->ipinfo.iface)
+	{
+		jobject_put(context_obj, J_CSTR_TO_JVAL("interface"),
+		            jstring_create(service->ipinfo.iface));
+	}
+
+	ipv4_obj = jobject_create();
+
+	if (service->ipinfo.ipv4.address)
+	{
+		jobject_put(ipv4_obj, J_CSTR_TO_JVAL("address"),
+		            jstring_create(service->ipinfo.ipv4.address));
+	}
+
+	if (service->ipinfo.ipv4.netmask)
+	{
+		jobject_put(ipv4_obj, J_CSTR_TO_JVAL("subnet"),
+		            jstring_create(service->ipinfo.ipv4.netmask));
+	}
+
+	if (service->ipinfo.ipv4.gateway)
+	{
+		jobject_put(ipv4_obj, J_CSTR_TO_JVAL("gateway"),
+		            jstring_create(service->ipinfo.ipv4.gateway));
+	}
+
+	if (jobject_size(ipv4_obj) > 0)
+	{
+		jobject_put(context_obj, J_CSTR_TO_JVAL("ipv4"), ipv4_obj);
+	}
+	else
+	{
+		j_release(&ipv4_obj);
+	}
+
+	ipv6_obj = jobject_create();
+
+	if (service->ipinfo.ipv6.address)
+	{
+		jobject_put(ipv6_obj, J_CSTR_TO_JVAL("address"),
+		            jstring_create(service->ipinfo.ipv6.address));
+	}
+
+	if (service->ipinfo.ipv6.prefix_length > 0)
+	{
+		jobject_put(ipv6_obj, J_CSTR_TO_JVAL("prefixLength"),
+		            jnumber_create_i32(service->ipinfo.ipv6.prefix_length));
+	}
+
+	if (service->ipinfo.ipv6.gateway)
+	{
+		jobject_put(ipv6_obj, J_CSTR_TO_JVAL("gateway"),
+		            jstring_create(service->ipinfo.ipv6.gateway));
+	}
+
+	if (jobject_size(ipv6_obj) > 0)
+	{
+		jobject_put(context_obj, J_CSTR_TO_JVAL("ipv6"), ipv6_obj);
+	}
+	else
+	{
+		j_release(&ipv6_obj);
+	}
+
+	dns_obj = jarray_create(NULL);
+
+	if (service->ipinfo.dns)
+	{
+		for (i = 0; i < g_strv_length(service->ipinfo.dns); i++)
+		{
+			jarray_append(dns_obj, jstring_create(service->ipinfo.dns[i]));
+		}
+	}
+
+	jobject_put(context_obj, J_CSTR_TO_JVAL("dns"), dns_obj);
+
+	hosts_obj = jarray_create(NULL);
+
+	for (i = 0; i < g_strv_length(service->hostroutes); i++)
+	{
+		jarray_append(hosts_obj, jstring_create(service->hostroutes[i]));
+	}
+
+	jobject_put(context_obj, J_CSTR_TO_JVAL("hosts"), hosts_obj);
+
+}
+static void append_context(jvalue_ref contexts_obj, connman_service_t *service)
+{
+	if (!jis_array(contexts_obj))
+	{
+		return;
+	}
+
+	jvalue_ref context_obj = jobject_create();
+
+	retrieve_wan_context(context_obj, service);
+
+	jarray_append(contexts_obj, context_obj);
+}
+
+void append_wan_status(jvalue_ref reply_obj)
+{
+	GSList *iter;
+	connman_service_t *service = NULL;
+	bool connected = false;
+	bool online = false;
+	jvalue_ref connected_contexts_obj;
+
+	if (!reply_obj)
+	{
+		return;
+	}
+
+	connected_contexts_obj = jarray_create(NULL);
+
+	for (iter = manager->cellular_services; NULL != iter; iter = iter->next)
+	{
+		service = (connman_service_t *)(iter->data);
+
+		if (!connman_service_is_connected(service))
+		{
+			continue;
+		}
+
+		connected = TRUE;
+
+		if (connman_service_is_online(service))
+		{
+			online = true;
+		}
+
+		connman_service_get_ipinfo(service);
+
+		append_context(connected_contexts_obj, service);
+	}
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("onInternet"), jboolean_create(online));
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("connected"), jboolean_create(connected));
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("connectedContexts"),
+	            connected_contexts_obj);
+}
+
+void send_wan_connection_status_to_subscribers()
+{
+	jvalue_ref reply = jobject_create();
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	append_wan_status(reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_WAN_GETSTATUS, payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+static void append_contexts(jvalue_ref reply_obj)
+{
+	connman_service_t *service;
+	GSList *iter;
+
+	jvalue_ref contexts_obj = jarray_create(NULL);
+
+	for (iter = manager->cellular_services; NULL != iter; iter = iter->next)
+	{
+		service = (connman_service_t *) iter->data;
+
+		connman_service_get_ipinfo(service);
+
+		append_context(contexts_obj, service);
+	}
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("contexts"), contexts_obj);
+}
+
+void send_wan_contexts_update_to_subscribers()
+{
+	jvalue_ref reply_obj = jobject_create();
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	append_contexts(reply_obj);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply_obj, response_schema);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_WAN_GETCONTEXTS, payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply_obj);
+}
+
+static void service_connect_callback(gboolean success, gpointer user_data)
+{
+	luna_service_request_t *service_req = user_data;
+	connman_service_t *service = service_req->user_data;
+
+	if (!success)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Failed to connect cellular service", WCA_API_ERROR_FAILED_TO_CONNECT);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(service_req->handle, service_req->message);
+
+	connman_service_register_property_changed_cb(service, service_changed_cb);
+
+cleanup:
+	luna_service_request_free(service_req);
+}
+
+
+static void connect_wan_service(const char *name,
+                                luna_service_request_t *service_req)
+{
+	GSList *iter;
+	gboolean found_service = FALSE;
+	connman_service_t *service = NULL;
+
+	if (!name)
+	{
+		LSMessageReplyErrorInvalidParams(service_req->handle, service_req->message);
+		goto cleanup;
+	}
+
+	for (iter = manager->cellular_services; NULL != iter ; iter = iter->next)
+	{
+		service = (connman_service_t *) iter->data;
+
+		if (g_strcmp0(service->name, name) == 0)
+		{
+			WCALOG_INFO(MSGID_WAN_CONNECT_INFO, 0, "Connecting to cellular service %s",
+			            service->name);
+			found_service = TRUE;
+			break;
+		}
+	}
+
+	if (!found_service)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Cellular service not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
+		goto cleanup;
+	}
+
+	service_req->user_data = service;
+
+	if (!connman_service_connect(service, service_connect_callback, service_req))
+	{
+		LSMessageReplyErrorUnknown(service_req->handle, service_req->message);
+		goto cleanup;
+	}
+
+	return;
+
+cleanup:
+	luna_service_request_free(service_req);
+}
+
+
+static void disconnect_wan_service(const char *name, LSHandle *handle,
+                                   LSMessage *message)
+{
+	GSList *iter;
+	gboolean found_service = FALSE;
+	connman_service_t *service = NULL;
+
+	if (!name)
+	{
+		LSMessageReplyErrorInvalidParams(handle, message);
+		return;
+	}
+
+	/* Look up for the service with the given type */
+	for (iter = manager->cellular_services; NULL != iter ; iter = iter->next)
+	{
+		service = (connman_service_t *) iter->data;
+
+		if (g_strcmp0(service->name, name) == 0)
+		{
+			WCALOG_INFO(MSGID_WAN_DISCONNECT_INFO, 0,
+			            "Disconnecting from cellular service %s", service->name);
+			found_service = TRUE;
+			break;
+		}
+	}
+
+	if (!found_service)
+	{
+		LSMessageReplyCustomError(handle, message,
+		                          "Cellular service not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
+		return;
+	}
+
+	if (!connman_service_disconnect(service))
+	{
+		LSMessageReplyErrorUnknown(handle, message);
+		return;
+	}
+
+	LSMessageReplySuccess(handle, message);
+}
+
+static void technology_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	connman_technology_t *technology = (connman_technology_t *)data;
+
+	if (NULL == technology)
+	{
+		return;
+	}
+
+	WCALOG_DEBUG("WAN technology: property [%s] changed", property);
+
+	if ((technology == connman_manager_find_cellular_technology(manager)) &&
+	        (g_strcmp0(property, "Powered") == 0 || g_strcmp0(property, "Connected") == 0))
+	{
+		send_wan_connection_status_to_subscribers();
+		connectionmanager_send_status_to_subscribers();
+	}
+}
+
+/**
+ * @brief The connect method connects to a single context which is specified by its name.
+ *
+ * @param name Name of the context to connect to.
+ */
+
+static bool handle_wan_connect_command(LSHandle *sh, LSMessage *message,
+                                       void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!cellular_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_cellular_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "WAN switched off",
+		                          WCA_API_ERROR_WAN_SWITCHED_OFF);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsed_obj = 0;
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(name, string))  REQUIRED_1(name))),
+	                             &parsed_obj))
+	{
+		return true;
+	}
+
+	luna_service_request_t *service_req;
+	jvalue_ref name_obj = 0;
+	char *name = NULL;
+
+	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
+	{
+		raw_buffer name_buf = jstring_get(name_obj);
+		name = g_strdup(name_buf.m_str);
+		jstring_free_buffer(name_buf);
+	}
+
+	if (name == NULL || strlen(name) == 0)
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	service_req = luna_service_request_new(sh, message);
+
+	connect_wan_service(name, service_req);
+
+cleanup:
+
+	if (!jis_null(parsed_obj))
+	{
+		j_release(&parsed_obj);
+	}
+
+	g_free(name);
+
+	return true;
+}
+
+/**
+ * @brief The disconnect method disconnects a single context which is specified by its name.
+ *
+ * @param name Name of the context to disconnect
+ */
+
+static bool handle_wan_disconnect_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!cellular_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_cellular_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "WAN switched off",
+		                          WCA_API_ERROR_WAN_SWITCHED_OFF);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsed_obj = 0;
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(name, string))  REQUIRED_1(name))),
+	                             &parsed_obj))
+	{
+		return true;
+	}
+
+	jvalue_ref name_obj = 0;
+	char *name = NULL;
+
+	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
+	{
+		raw_buffer name_buf = jstring_get(name_obj);
+		name = g_strdup(name_buf.m_str);
+		jstring_free_buffer(name_buf);
+	}
+
+	if (name == NULL || strlen(name) == 0)
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	disconnect_wan_service(name, sh, message);
+
+cleanup:
+
+	if (!jis_null(parsed_obj))
+	{
+		j_release(&parsed_obj);
+	}
+
+	g_free(name);
+
+	return true;
+}
+
+/**
+ * @brief Reports the current WAN status to the caller.
+ *
+ * @param subscribe To be notified of any status changes, set subscribe to true
+ */
+
+static bool handle_wan_get_status_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	jvalue_ref parsedObj = {0};
+
+	if (!LSMessageValidateSchema(sh, message,
+                                     j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+                return true;
+	}
+
+	jvalue_ref reply_obj = 0;
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	reply_obj = jobject_create();
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!cellular_technology_status_check_with_subscription(sh, message,
+		subscribed))
+	{
+		goto cleanup;
+	}
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("subscribed"),
+	            jboolean_create(subscribed));
+
+	append_wan_status(reply_obj);
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, jschema_all()),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply_obj);
+	j_release(&parsedObj);
+
+	return true;
+}
+
+/**
+ * @brief  Lists all available contexts
+ *
+ * @param subscribe To be notified of any status changes, set subscribe to true
+ */
+
+static bool handle_wan_get_contexts_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	jvalue_ref parsedObj = {0};
+
+	if (!LSMessageValidateSchema(sh, message,
+                                     j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+                return true;
+	}
+
+	jvalue_ref reply_obj = 0;
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	reply_obj = jobject_create();
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!cellular_technology_status_check_with_subscription(sh, message,
+	        subscribed))
+	{
+		goto cleanup;
+	}
+
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("subscribed"),
+	            jboolean_create(subscribed));
+
+	append_contexts(reply_obj);
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, jschema_all()),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply_obj);
+	j_release(&parsedObj);
+
+	return true;
+}
+
+/**
+ * @brief  Get information of a given context
+ *
+ * @param name name of the context
+ */
+
+static bool handle_wan_get_context_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!cellular_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsed_obj = 0;
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(name, string)) REQUIRED_1(name))),
+	                             &parsed_obj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply_obj = 0;
+	jvalue_ref name_obj = 0;
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool found_service = FALSE;
+	GSList *iter;
+	char *name = NULL;
+	connman_service_t *service = NULL;
+
+	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
+	{
+		raw_buffer name_buf = jstring_get(name_obj);
+		name = g_strdup(name_buf.m_str);
+		jstring_free_buffer(name_buf);
+	}
+
+	reply_obj = jobject_create();
+
+	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	for (iter = manager->cellular_services; NULL != iter; iter = iter->next)
+	{
+		service = (connman_service_t *) iter->data;
+
+		if (g_strcmp0(service->name, name) == 0)
+		{
+			connman_service_get_ipinfo(service);
+			jvalue_ref wan_context_obj = jobject_create();
+			retrieve_wan_context(wan_context_obj, service);
+			jobject_put(reply_obj, J_CSTR_TO_JVAL("contextInfo"), wan_context_obj);
+			found_service = TRUE;
+			break;
+		}
+	}
+
+	if (!found_service)
+	{
+		LSMessageReplyCustomError(sh, message, "Cellular service not found",
+		                          WCA_API_ERROR_NETWORK_NOT_FOUND);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, jschema_all()),
+                            &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+cleanup:
+
+	if (!jis_null(reply_obj))
+	{
+		j_release(&reply_obj);
+	}
+
+	if (!jis_null(parsed_obj))
+	{
+		j_release(&parsed_obj);
+	}
+
+	g_free(name);
+
+	return true;
+}
+
+/**
+ * @brief  Set static host routing for a given context
+ *
+ * @param name  name of the context
+ * @param hosts an array of host IP address to setup static route
+ */
+
+static bool handle_set_hostroutes_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!cellular_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_cellular_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "WAN switched off",
+		                          WCA_API_ERROR_WAN_SWITCHED_OFF);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsed_obj = 0;
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(ARRAY(hosts, string), PROP(name, string))
+	                                     REQUIRED_2(name, hosts))), &parsed_obj))
+	{
+		return true;
+	}
+
+	GStrv hosts = NULL;
+	jvalue_ref name_obj = 0;
+	jvalue_ref hosts_obj = 0;
+	char *name = NULL;
+	GSList *iter;
+	gboolean found_service = false;
+	connman_service_t *service = NULL;
+
+	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
+	{
+		raw_buffer name_buf = jstring_get(name_obj);
+		name = g_strdup(name_buf.m_str);
+		jstring_free_buffer(name_buf);
+	}
+
+	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("hosts"), &hosts_obj))
+	{
+		int i, host_arrsize = jarray_size(hosts_obj);
+		hosts = (GStrv) g_new0(GStrv, host_arrsize + 1);
+
+		for (i = 0; i < host_arrsize; i++)
+		{
+			raw_buffer host_buf = jstring_get(jarray_get(hosts_obj, i));
+			hosts[i] = g_strdup(host_buf.m_str);
+			jstring_free_buffer(host_buf);
+
+			if (!(is_valid_ipaddress(hosts[i]) || is_valid_ipv6address(hosts[i])))
+			{
+				LSMessageReplyErrorInvalidParams(sh, message);
+				goto cleanup;
+			}
+		}
+	}
+
+	/* Look up for the service with the given type */
+	for (iter = manager->cellular_services; NULL != iter ; iter = iter->next)
+	{
+		service = (connman_service_t *) iter->data;
+
+		if (g_strcmp0(service->name, name) == 0)
+		{
+			WCALOG_DEBUG("Setting host route for service %s", service->name);
+			found_service = true;
+			break;
+		}
+	}
+
+	if (!found_service)
+	{
+		LSMessageReplyCustomError(sh, message,
+		                          "Cellular service not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
+		goto cleanup;
+	}
+
+	if (connman_service_set_hostroutes(service, hosts))
+	{
+		LSMessageReplySuccess(sh, message);
+	}
+	else
+	{
+		LSMessageReplyCustomError(sh, message, "Hosts could not be set as static route",
+		                          WCA_API_ERROR_HOST_ROUTE_NOT_SET);
+	}
+
+cleanup:
+
+	if (!jis_null(parsed_obj))
+	{
+		j_release(&parsed_obj);
+	}
+
+	g_free(name);
+	g_strfreev(hosts);
+
+	return true;
+}
+
+static LSMethod wan_methods[] =
+{
+	{ LUNA_METHOD_WAN_CONNECT,       handle_wan_connect_command },
+	{ LUNA_METHOD_WAN_DISCONNECT,    handle_wan_disconnect_command },
+	{ LUNA_METHOD_WAN_GETSTATUS,     handle_wan_get_status_command },
+	{ LUNA_METHOD_WAN_GETCONTEXTS,   handle_wan_get_contexts_command },
+	{ LUNA_METHOD_WAN_GETCONTEXT,    handle_wan_get_context_command },
+	{ LUNA_METHOD_WAN_SETHOSTROUTES, handle_set_hostroutes_command },
+	{ },
+};
+
+int initialize_wan_ls2_calls(GMainLoop *mainloop, LSHandle **wan_handle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	pLsHandle = NULL;
+
+	if (NULL == mainloop)
+	{
+		goto Exit;
+	}
+
+	if (LSRegister(WAN_LUNA_SERVICE_NAME, &pLsHandle, &lserror) == false)
+	{
+		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
+		             "LSRegister() returned error");
+		goto Exit;
+	}
+
+	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_ROOT, wan_methods, NULL, NULL,
+	                       &lserror) == false)
+	{
+		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
+		             "LSRegisterCategory() returned error");
+		goto Exit;
+	}
+
+	if (LSGmainAttach(pLsHandle, mainloop, &lserror) == false)
+	{
+		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
+		             "LSGmainAttach() returned error");
+		goto Exit;
+	}
+
+	*wan_handle = pLsHandle;
+
+	return 0;
+
+Exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	if (pLsHandle)
+	{
+		LSErrorInit(&lserror);
+
+		if (LSUnregister(pLsHandle, &lserror) == false)
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	return -1;
+}
+
+void check_and_initialize_cellular_technology(void)
+{
+	connman_technology_t *technology = connman_manager_find_cellular_technology(
+	                                       manager);
+
+	if (!technology)
+	{
+		return;
+	}
+
+	connman_technology_register_property_changed_cb(technology,
+	        technology_property_changed_callback);
+
+	/* Register property change callback for all connected cellular services */
+	GSList *iter;
+
+	for (iter = manager->cellular_services; iter != NULL; iter = iter->next)
+	{
+		connman_service_t *service = iter->data;
+
+		if (!connman_service_is_connected(service))
+		{
+			continue;
+		}
+
+		connman_service_register_property_changed_cb(service, service_changed_cb);
+	}
+}
diff --git a/src/wan_service.h b/src/wan_service.h
new file mode 100644
index 0000000..d94595d
--- /dev/null
+++ b/src/wan_service.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef _WAN_SERVICE_H_
+#define _WAN_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define WAN_LUNA_SERVICE_NAME "com.webos.service.wan"
+
+#define LUNA_CATEGORY_ROOT            "/"
+
+#define LUNA_METHOD_WAN_CONNECT       "connect"
+#define LUNA_METHOD_WAN_DISCONNECT    "disconnect"
+#define LUNA_METHOD_WAN_GETSTATUS     "getStatus"
+#define LUNA_METHOD_WAN_GETCONTEXTS   "getContexts"
+#define LUNA_METHOD_WAN_GETCONTEXT    "getContext"
+#define LUNA_METHOD_WAN_SETHOSTROUTES "setHostRoutes"
+
+extern void check_and_initialize_cellular_technology(void);
+extern void send_wan_connection_status_to_subscribers(void);
+extern void send_wan_contexts_update_to_subscribers(void);
+extern void append_wan_status(jvalue_ref reply_obj);
+extern int initialize_wan_ls2_calls(GMainLoop *mainloop, LSHandle **wan_handle);
+
+#endif /* _WAN_SERVICE_H_ */
diff --git a/src/wifi_profile.c b/src/wifi_profile.c
new file mode 100644
index 0000000..929fd90
--- /dev/null
+++ b/src/wifi_profile.c
@@ -0,0 +1,310 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_profile.c
+ *
+ * @brief Functions for manipulating wifi profile list
+ *
+ */
+
+#include <glib.h>
+
+#include "wifi_profile.h"
+#include "wifi_setting.h"
+#include "logging.h"
+
+static GSList *wifi_profile_list = NULL;
+static guint gprofile_id = 777; //! First assigned profile ID
+
+extern gboolean remove_network_config(const char *ssid, const char *security);
+
+/**
+ * @brief Search all wifi profiles to match the given profile Id.
+ */
+
+wifi_profile_t *get_profile_by_id(guint profile_id)
+{
+	GSList *iter;
+
+	for (iter = wifi_profile_list; NULL != iter; iter = iter->next)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(iter->data);
+
+		if (profile->profile_id == profile_id)
+		{
+			return profile;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * @brief Lookup wifi profile with given ssid
+ */
+
+wifi_profile_t *get_profile_by_ssid(gchar *ssid)
+{
+	if (NULL == ssid)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = wifi_profile_list; NULL != iter; iter = iter->next)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(iter->data);
+
+		if (!g_strcmp0(profile->ssid, ssid))
+		{
+			return profile;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * @brief Lookup wifi profile with given ssid and security
+ */
+
+wifi_profile_t *get_profile_by_ssid_security(gchar *ssid,  gchar *security)
+{
+	if (NULL == ssid)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+	int n = 0;
+
+	for (iter = wifi_profile_list; NULL != iter; iter = iter->next)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(iter->data);
+
+		if (!g_strcmp0(profile->ssid, ssid))
+		{
+			if (profile->security != NULL)
+			{
+				for (n = 0; n < g_strv_length(profile->security); n++)
+					if (!g_strcmp0(profile->security[n], security))
+					{
+						return profile;
+					}
+			}
+			else
+			{
+				return profile;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * @brief Create a new profile
+ *
+ * For open networks we only need to add its ssid and generate a profile ID
+ * However more fields to be added when supporting secured wifi networks.
+ */
+wifi_profile_t *create_new_profile(gchar *ssid, GStrv security, gboolean hidden,
+                                   gboolean configured)
+{
+	if (NULL == ssid)
+	{
+		return NULL;
+	}
+
+	WCALOG_DEBUG("Create profile %s", ssid);
+
+	wifi_profile_t *new_profile = g_new0(wifi_profile_t, 1);
+
+	if (NULL == new_profile)
+	{
+		return NULL;
+	}
+
+	new_profile->profile_id = gprofile_id++;
+	new_profile->ssid = g_strdup(ssid);
+	new_profile->hidden = hidden;
+	new_profile->configured = configured;
+
+	if (NULL != security)
+	{
+		gsize i, num_elems = g_strv_length(security);
+		new_profile->security = (GStrv) g_new0(GStrv, num_elems + 1);
+
+		for (i = 0; i < num_elems; i++)
+		{
+			new_profile->security[i] = g_strdup(security[i]);
+		}
+
+		new_profile->security[num_elems] = NULL;
+	}
+
+	wifi_profile_list = g_slist_append(wifi_profile_list, (gpointer)new_profile);
+	/* Store wifi profiles */
+	store_wifi_setting(WIFI_PROFILELIST_SETTING, NULL);
+
+	return new_profile;
+}
+
+/**
+ * @brief Delete a wifi profile
+ */
+
+void delete_profile(wifi_profile_t *profile)
+{
+	if (NULL == profile)
+	{
+		return;
+	}
+
+	/* Delete the link from the list */
+	GSList *node = g_slist_find(wifi_profile_list, profile);
+
+	if (NULL != node)
+	{
+		wifi_profile_list = g_slist_delete_link(wifi_profile_list,
+		                                        g_slist_find(wifi_profile_list, profile));
+	}
+
+	WCALOG_DEBUG("Delete profile %s", profile->ssid);
+
+	if (profile->configured)
+	{
+		remove_network_config(profile->ssid, profile->security[0]);
+	}
+
+	g_free(profile->ssid);
+	g_strfreev(profile->security);
+	g_free(profile);
+	profile = NULL;
+	store_wifi_setting(WIFI_PROFILELIST_SETTING, NULL);
+}
+
+/**
+ * @brief Delete all profiles but not the one specified with the supplied ID
+ * @param id ID of the profile not to delete
+ */
+void delete_all_profiles_except_one(guint id)
+{
+	GSList *iter, *delete_profiles = NULL;
+
+	for (iter = wifi_profile_list; NULL != iter; iter = iter->next)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(iter->data);
+
+		if (profile->profile_id != id)
+		{
+			delete_profiles = g_slist_prepend(delete_profiles, (gpointer) profile);
+		}
+	}
+
+	for (iter = delete_profiles; iter != NULL; iter = iter->next)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(iter->data);
+		delete_profile(profile);
+	}
+
+	g_slist_free(delete_profiles);
+}
+
+/**
+ * @brief Return TRUE if profile list is empty
+ */
+
+gboolean profile_list_is_empty(void)
+{
+	return (0 == g_slist_length(wifi_profile_list));
+}
+
+/**
+ * @brief Traverse the profile list and get the one after the supplied profile
+ */
+
+wifi_profile_t *get_next_profile(wifi_profile_t *curr_profile)
+{
+	// Return first profile (if present), if NULL argument is passed
+	if (NULL == curr_profile)
+	{
+		if (NULL != wifi_profile_list)
+		{
+			return (wifi_profile_t *)(wifi_profile_list->data);
+		}
+		else
+		{
+			return NULL;
+		}
+	}
+
+	GSList *node = g_slist_find(wifi_profile_list, curr_profile);
+
+	if (node != NULL && node->next != NULL)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(node->next->data);
+		return profile;
+	}
+
+	return NULL;
+}
+
+/**
+ * @brief Move the supplied profile to top of the list
+ * This is useful to prioritize a profile to be the first one in the list
+ */
+
+void move_profile_to_head(wifi_profile_t *profile)
+{
+	if (NULL == profile)
+	{
+		return;
+	}
+
+	GSList *node = g_slist_find(wifi_profile_list, profile);
+
+	if (NULL != node)
+	{
+		/* If the given profile is already the head, return */
+		if (node == wifi_profile_list)
+		{
+			return;
+		}
+
+		/* Delete the link from the list */
+		wifi_profile_list = g_slist_delete_link(wifi_profile_list,
+		                                        g_slist_find(wifi_profile_list, profile));
+		/* Then add it to start of the list */
+		wifi_profile_list = g_slist_prepend(wifi_profile_list, profile);
+	}
+
+	store_wifi_setting(WIFI_PROFILELIST_SETTING, NULL);
+}
+
+/**
+ * @brief Load the stored wifi profiles (from luna-prefs)
+ */
+
+void init_wifi_profile_list(void)
+{
+	load_wifi_setting(WIFI_PROFILELIST_SETTING, NULL);
+	return;
+}
+
+
diff --git a/src/wifi_profile.h b/src/wifi_profile.h
new file mode 100644
index 0000000..8421e94
--- /dev/null
+++ b/src/wifi_profile.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_profile.h
+ *
+ */
+
+
+#ifndef _WIFI_PROFILE_H_
+#define _WIFI_PROFILE_H_
+
+#include <glib-object.h>
+
+typedef struct wifi_profile
+{
+	guint profile_id;
+	gchar *ssid;
+	gboolean hidden;
+	GStrv security;
+	gboolean configured;
+} wifi_profile_t;
+
+extern void init_wifi_profile_list(void);
+extern wifi_profile_t *get_profile_by_id(guint profile_id);
+extern wifi_profile_t *get_profile_by_ssid(gchar *ssid);
+extern wifi_profile_t *get_profile_by_ssid_security(gchar *ssid,
+        gchar *security);
+extern wifi_profile_t *create_new_profile(gchar *ssid, GStrv security,
+        gboolean hidden, gboolean configured);
+extern void delete_profile(wifi_profile_t *profile);
+extern void delete_all_profiles_except_one(guint id);
+extern gboolean profile_list_is_empty(void);
+extern wifi_profile_t *get_next_profile(wifi_profile_t *curr_profile);
+extern void move_profile_to_head(wifi_profile_t *new_head);
+
+#endif /* _WIFI_PROFILE_H_ */
diff --git a/src/wifi_scan.c b/src/wifi_scan.c
new file mode 100644
index 0000000..3d1bb5c
--- /dev/null
+++ b/src/wifi_scan.c
@@ -0,0 +1,413 @@
+// Copyright (c) 2015-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_scan.c
+ *
+ * @brief Functions for scanning wifi.
+ *
+ */
+
+#include "wifi_scan.h"
+#include "logging.h"
+#include "utils.h"
+
+#define MIN_SCAN_INTERVAL 1000
+
+typedef struct scan_subscriber_data
+{
+	char* subscriber;
+	/* Interval in ms*/
+	guint interval;
+	/* time for next result */
+	gint64 next_result;
+} scan_subscriber_data_t;
+
+
+static connman_technology_t *wifi_tech = NULL;
+static GArray* scan_subscribers = NULL;
+static guint scan_timeout_source = 0;
+static guint current_scan_interval = 0;
+static gint64 scan_time = 0;
+static gboolean scan_running = FALSE;
+static gboolean scan_is_p2p = FALSE;
+
+static gboolean regular_scan_pending = FALSE;
+static gboolean p2p_scan_pending = FALSE;
+
+wifi_scan_callback_t scan_done_callback_fn = NULL;
+gpointer scan_done_callback_data = NULL;
+
+static guint compute_scan_interval(void)
+{
+	guint min = 0;
+
+	guint length = scan_subscribers->len;
+	guint i;
+	for (i = 0; i < length; i++)
+	{
+		scan_subscriber_data_t* data = &g_array_index(scan_subscribers,
+		                                              scan_subscriber_data_t,
+		                                              i);
+		if (min == 0 || min > data->interval)
+		{
+			min = data->interval;
+		}
+	}
+
+	return min;
+}
+
+void scan_done_callback(gpointer user_data)
+{
+	UNUSED(user_data);
+
+	WCALOG_DEBUG("wifi_scan: Scan done callback");
+
+	if (!scan_running)
+	{
+		WCALOG_INFO(MSGID_WIFI_SCAN_CALLBACK_NOT_RUNNING, 0,
+		            "wifi_scan: Received scan done callback, but no scan running");
+		return;
+	}
+
+	scan_running = FALSE;
+
+	if (p2p_scan_pending)
+	{
+		wifi_scan_now_p2p();
+	}
+	else if (regular_scan_pending)
+	{
+		wifi_scan_now();
+	}
+	else if (scan_done_callback_fn)
+	{
+		//Clear before calling. To prevent clearing callback set in done func.
+		wifi_scan_callback_t fn = scan_done_callback_fn;
+		gpointer data = scan_done_callback_data;
+		scan_done_callback_fn = NULL;
+		scan_done_callback_data = NULL;
+
+		fn(data);
+	}
+}
+
+gboolean wifi_scan_now_p2p(void)
+{
+	gboolean result;
+
+	if (scan_running && scan_is_p2p)
+	{
+		result = true;
+	}
+	else if (scan_running && !scan_is_p2p)
+	{
+		p2p_scan_pending = true;
+		result = true;
+	}
+	else if (!wifi_tech)
+	{
+		return false;
+	}
+	else
+	{
+		WCALOG_DEBUG("wifi_scan: Scanning p2p");
+
+		wifi_tech->handle_after_scan_fn = scan_done_callback;
+		wifi_tech->after_scan_data = NULL;
+		result = connman_technology_scan_network(wifi_tech, true);
+
+		if (result)
+		{
+			scan_running = true;
+			p2p_scan_pending = false;
+		}
+
+		scan_time = g_get_monotonic_time() / 1000;
+	}
+
+	return result;
+}
+
+gboolean wifi_scan_now(void)
+{
+	gboolean result;
+
+	if (scan_running && !scan_is_p2p)
+	{
+		result = true;
+	}
+	else if (scan_running && scan_is_p2p)
+	{
+		regular_scan_pending = true;
+		result = true;
+	}
+	else if (!wifi_tech)
+	{
+		return false;
+	}
+	else
+	{
+		WCALOG_DEBUG("wifi_scan: Scanning wifi");
+
+		wifi_tech->handle_after_scan_fn = scan_done_callback;
+		wifi_tech->after_scan_data = NULL;
+
+		result = connman_technology_scan_network(wifi_tech, FALSE);
+
+		if (result)
+		{
+			scan_running = TRUE;
+			regular_scan_pending = FALSE;
+		}
+
+		scan_time = g_get_monotonic_time() / 1000;
+	}
+
+	return result;
+}
+
+gboolean wifi_scan_is_scanning()
+{
+	return scan_running;
+}
+
+
+void wifi_scan_execute_when_scan_done(wifi_scan_callback_t callback, gpointer user_data)
+{
+	if (scan_running)
+	{
+		scan_done_callback_fn = callback;
+		scan_done_callback_data = user_data;
+	}
+	else
+	{
+		callback(user_data);
+	}
+}
+
+static gboolean scan_timeout_cb(gpointer user_data)
+{
+	UNUSED(user_data);
+
+	scan_timeout_source = 0;
+
+	gboolean scan_started = wifi_scan_now();
+
+	if (!scan_started)
+	{
+		WCALOG_DEBUG("wifi_scan: Failed to start scan");
+	}
+
+	// Schedule new scan.
+	if (current_scan_interval != 0)
+	{
+		scan_timeout_source = g_timeout_add_full(G_PRIORITY_DEFAULT,
+		                                         current_scan_interval,
+		                                         scan_timeout_cb, NULL, NULL);
+	}
+
+	return FALSE;
+}
+
+gboolean wifi_scan_add_interval(const char* source, guint interval_ms)
+{
+	WCALOG_DEBUG("wifi_scan: Add scan interval, %s, %d", source, interval_ms);
+
+	if (interval_ms <= 0 || source == NULL)
+	{
+		WCALOG_ERROR(MSGID_WIFI_SCAN_ADD_INTERVAL_INVALID_PARAMS, 0,
+		             "wifi_scan: Add scan interval: invalid parameters");
+		return false;
+	}
+
+	if (scan_subscribers == NULL)
+	{
+		scan_subscribers = g_array_new(false, false, sizeof(scan_subscriber_data_t));
+	}
+
+	gint64 cur_time = g_get_monotonic_time() / 1000;
+
+	scan_subscriber_data_t data;
+	data.interval = interval_ms;
+	data.subscriber = g_strdup(source);
+	data.next_result = cur_time;
+	scan_subscribers = g_array_append_val(scan_subscribers, data);
+
+	guint new_interval = compute_scan_interval();
+	WCALOG_DEBUG("wifi_scan: Compute scan interval = %d", new_interval);
+
+	if (new_interval == 0)
+	{
+		return FALSE;
+	}
+
+	// Reschedule timeout based on new interval.
+	if (current_scan_interval == 0 || new_interval < current_scan_interval)
+	{
+		if (scan_timeout_source)
+		{
+			g_source_remove(scan_timeout_source);
+		}
+
+		current_scan_interval = new_interval;
+		scan_timeout_source = g_timeout_add_full(G_PRIORITY_DEFAULT,
+		                                         current_scan_interval,
+		                                         scan_timeout_cb, NULL, NULL);
+	}
+
+	if (scan_time == 0 || cur_time > scan_time + MIN_SCAN_INTERVAL)
+	{
+		return wifi_scan_now();
+	}
+	else
+	{
+		return TRUE;
+	}
+}
+
+gboolean wifi_scan_check_and_reset_interval(const char* source)
+{
+	gint64 curtime = g_get_monotonic_time() / 1000;
+
+	// Using simple lookup here.
+	// Should use hashmap if number of subscribers goes over 20.
+	guint length = scan_subscribers->len;
+	guint i;
+	for (i = 0; i < length; i++)
+	{
+		scan_subscriber_data_t* data = &g_array_index(scan_subscribers,
+		                                              scan_subscriber_data_t,
+		                                              i);
+
+		// Subsctract a bit to compensate for time intervals not being millisecond accurate.
+
+		if (!g_strcmp0(data->subscriber, source) &&
+				data->next_result < curtime + current_scan_interval - 100)
+		{
+			data->next_result = curtime + data->interval;
+			WCALOG_INFO("DEBUG", 0, "wifi_scan: Interval OK %s", source);
+			return true;
+		}
+	}
+
+	WCALOG_INFO("DEBUG", 0, "wifi_scan: Interval skip %s", source);
+	return false;
+}
+
+gboolean wifi_scan_remove_interval(const char* source)
+{
+	WCALOG_DEBUG("wifi_scan: Remove scan interval %s", source);
+	gboolean found = FALSE;
+	guint new_interval;
+	guint length = scan_subscribers ? scan_subscribers->len : 0;
+	guint i;
+	for (i = 0; i < length; i++)
+	{
+		scan_subscriber_data_t* data = &g_array_index(scan_subscribers,
+		                                              scan_subscriber_data_t,
+		                                              i);
+
+		if (!g_strcmp0(data->subscriber, source))
+		{
+			g_free(data->subscriber);
+			data->subscriber = NULL;
+			scan_subscribers = g_array_remove_index_fast(scan_subscribers, i);
+			found = TRUE;
+			i--;
+			length--;
+		}
+	}
+
+	if (!found)
+	{
+		WCALOG_INFO(MSGID_WIFI_SCAN_REMOVE_INVERVAL_NOT_FOUND, 0,
+		            "wifi_scan: Remove inverval, interval not found, id: %s", source);
+		return FALSE;
+	}
+
+	new_interval = compute_scan_interval();
+	WCALOG_DEBUG("wifi_scan: Compute scan interval = %d", new_interval);
+
+	if (scan_timeout_source == 0)
+	{
+		current_scan_interval = new_interval;
+		return TRUE;
+	}
+
+	if (new_interval == 0)
+	{
+		g_source_remove(scan_timeout_source);
+		scan_timeout_source = 0;
+	}
+	else if (new_interval > current_scan_interval)
+	{
+		// Extend already running timeout.
+		gint64 curtime = g_get_monotonic_time() / 1000;
+		guint transient_interval = (guint)MAX(1, scan_time + new_interval - curtime);
+
+		g_source_remove(scan_timeout_source);
+		scan_timeout_source = g_timeout_add_full(G_PRIORITY_DEFAULT,
+		                                         transient_interval,
+		                                         scan_timeout_cb, NULL, NULL);
+	}
+
+	current_scan_interval = new_interval;
+
+	return TRUE;
+}
+
+void wifi_scan_stop(void)
+{
+	WCALOG_DEBUG("wifi_scan: stop");
+
+	wifi_tech = NULL;
+
+	if (scan_timeout_source != 0)
+	{
+		g_source_remove(scan_timeout_source);
+		scan_timeout_source = 0;
+	}
+
+	scan_running = FALSE;
+
+	scan_done_callback_fn = NULL;
+	scan_done_callback_data = NULL;
+}
+
+void wifi_scan_start(connman_technology_t* _wifi_tech)
+{
+	WCALOG_DEBUG("wifi_scan: start");
+
+	if (wifi_tech)
+	{
+		WCALOG_INFO(MSGID_WIFI_SCAN_START_ALREADY_STARTED, 0,
+		             "wifi_scan: Scan start: already started");
+	}
+
+	wifi_tech = _wifi_tech;
+
+	if (scan_subscribers == NULL)
+	{
+		scan_subscribers = g_array_new(false, false, sizeof(scan_subscriber_data_t));
+	}
+
+	if (current_scan_interval > 0 && scan_timeout_source == 0)
+	{
+		scan_timeout_cb(NULL);
+	}
+}
diff --git a/src/wifi_scan.h b/src/wifi_scan.h
new file mode 100644
index 0000000..28927a3
--- /dev/null
+++ b/src/wifi_scan.h
@@ -0,0 +1,80 @@
+// Copyright (c) 2015-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_scan.h
+ *
+ * @brief Functions for scanning wifi.
+ * It manages various scan intervals set up subscriptions to findNetworks and
+ * issues periodic scan requests.
+ */
+
+#include "lunaservice_utils.h"
+#include "connman_manager.h"
+
+typedef void (*wifi_scan_callback_t)(gpointer user_data);
+
+/**
+ * Is scan running.
+ */
+extern gboolean wifi_scan_is_scanning(void);
+
+/**
+ * Executes callback when scan done, or right away if no active scan running.
+ */
+extern void wifi_scan_execute_when_scan_done(wifi_scan_callback_t callback, gpointer user_data);
+
+/**
+ * Starts a fresh scan, or does nothing if scan already running.
+ * Returns success/error.
+ */
+extern gboolean wifi_scan_now(void);
+
+/**
+ * Starts a fresh scan, or queues a new scan if regular scan is already running.
+ * Returns success/error.
+ */
+extern gboolean wifi_scan_now_p2p(void);
+
+/**
+ * Adds scheduled peridic scan with specified interval.
+ * The source variable can be used to cancel schaduled scan with remove_interval.
+ */
+extern gboolean wifi_scan_add_interval(const char* source, guint interval_ms);
+
+/*
+ * Removes scheduled scan.
+ */
+extern gboolean wifi_scan_remove_interval(const char* source);
+
+/**
+ * Returns true if interval has elapsed for the scan source.
+ * If returns true, resets the interval counter.
+ * TODO: not used right now.
+ */
+extern gboolean wifi_scan_check_and_reset_interval(const char* source);
+
+/**
+ * Starts all scan operations.
+ */
+void wifi_scan_start(connman_technology_t* _wifi_tech);
+
+/**
+ * Stops all scan operations. Consider started scan is failed.
+ * Drop any pending callbacks.
+ */
+extern void wifi_scan_stop(void);
+
diff --git a/src/wifi_service.c b/src/wifi_service.c
new file mode 100644
index 0000000..09191a6
--- /dev/null
+++ b/src/wifi_service.c
@@ -0,0 +1,4364 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_service.c
+ *
+ * @brief Implements all of the com.webos.service.wifi methods using connman APIs
+ * in the backend
+ */
+
+/**
+@page com_webos_wifi com.webos.wifi
+
+@brief Manages connections to Wireless Networks
+
+Each call has a standard return in the case of a failure, as follows:
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | False to inidicate an error
+errorCode | Yes | Integer | Error code
+errorText | Yes | String | Error description
+
+@{
+@}
+*/
+
+#include <glib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <pbnjson.h>
+
+#include <wca-support.h>
+
+#include "wifi_service.h"
+#include "wifi_profile.h"
+#include "wifi_setting.h"
+#include "wifi_scan.h"
+#include "connman_manager.h"
+#include "connman_agent.h"
+#include "lunaservice_utils.h"
+#include "utils.h"
+#include "common.h"
+#include "connectionmanager_service.h"
+#include "logging.h"
+#include "wifi_tethering_service.h"
+#include "wan_service.h"
+#include "pan_service.h"
+#include "errors.h"
+#include "nyx.h"
+
+/* Range for converting signal strength to signal bars */
+#define MID_SIGNAL_RANGE_LOW    55
+#define MID_SIGNAL_RANGE_HIGH   65
+
+/* Schedule a scan every 15 seconds */
+#define WIFI_DEFAULT_SCAN_INTERVAL   15000
+
+#define MAX_PREFIX_LENGTH   128
+
+static LSHandle *pLsHandle;
+
+connman_manager_t *manager = NULL;
+connman_agent_t *agent = NULL;
+
+/* Default scan interval. Used if no interval specified. */
+static gint findnetworks_default_scan_interval = WIFI_DEFAULT_SCAN_INTERVAL;
+
+static guint signal_polling_timeout_source = 0;
+
+static char* wifi_getstatus_prev_response = NULL;
+
+luna_service_request_t *current_connect_req;
+typedef struct current_service_data
+{
+	connman_service_t *service;
+	connection_settings_t *settings;
+} current_service_data_t;
+
+
+static gboolean check_wifi_services_for_updates(void);
+
+connection_settings_t *connection_settings_new(void)
+{
+	connection_settings_t *settings = NULL;
+
+	settings = g_new0(connection_settings_t, 1);
+
+	return settings;
+}
+
+static void connection_settings_free(connection_settings_t *settings)
+{
+	g_free(settings->passkey);
+	g_free(settings->ssid);
+	g_free(settings->wpspin);
+	g_free(settings->identity);
+	g_free(settings->eap_type);
+	g_free(settings->ca_cert_file);
+	g_free(settings->client_cert_file);
+	g_free(settings->private_key_file);
+	g_free(settings->private_key_passphrase);
+	g_free(settings->phase2);
+	g_free(settings->passphrase);
+
+	g_free(settings);
+}
+
+static void connect_req_free(luna_service_request_t *request)
+{
+	current_service_data_t *service_data = request->user_data;
+
+	if (service_data)
+	{
+		connection_settings_t *settings = service_data->settings;
+
+		if (settings)
+		{
+			connection_settings_free(settings);
+		}
+
+		g_free(service_data);
+	}
+
+	luna_service_request_free(request);
+}
+
+static void current_connect_req_free()
+{
+	connect_req_free(current_connect_req);
+	current_connect_req = NULL;
+}
+
+/**
+ * Compare the signal strengths of services and sort the list based on decreasing
+ * signal strength. However the hidden service (if any) will always be put at the end of the list.
+ */
+
+static gint compare_signal_strength(connman_service_t *service1,
+                                    connman_service_t *service2)
+{
+	if (service2->name == NULL)
+	{
+		return -1;    // let the hidden service be added to the list
+	}
+		// after all non-hidden services
+	else if (service1->name == NULL)
+	{
+		return 1;    // insert non-hidden service2 before hidden service1
+	}
+
+	return (service2->strength - service1->strength);
+}
+
+/**
+ *  @brief Sets the wifi technologies powered state
+ *
+ *  @param state
+ */
+
+static gboolean set_wifi_powered_state(bool state)
+{
+	/* if scan is still scheduled abort it */
+	if (state == FALSE)
+	{
+		wifi_scan_stop();
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (wifi_tech)
+	{
+		return connman_technology_set_powered(wifi_tech, state, NULL);
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+
+/**
+ * Convert signal strength to signal bars
+ *
+ * @param[IN] strength Signal strength
+ *
+ * @return Mapped signal strength in bars
+ */
+
+static int signal_strength_to_bars(int strength)
+{
+	if (strength > 0 && strength < MID_SIGNAL_RANGE_LOW)
+	{
+		return 1;
+	}
+	else if (strength >= MID_SIGNAL_RANGE_LOW && strength < MID_SIGNAL_RANGE_HIGH)
+	{
+		return 2;
+	}
+	else if (strength >= MID_SIGNAL_RANGE_HIGH)
+	{
+		return 3;
+	}
+
+	return 0;
+}
+
+/**
+ *  @brief Add details about the connected service
+ *
+ *  @param reply
+ *  @param connected_service
+ *
+ */
+
+static void add_connected_network_status(jvalue_ref *reply,
+        connman_service_t *connected_service)
+{
+	if (NULL == reply || NULL == connected_service)
+	{
+		return;
+	}
+	int connman_state = 0;
+
+	jvalue_ref network_info = jobject_create();
+
+	/* Fill in details about the service access point */
+	if (connected_service->display_name != NULL)
+	{
+		jobject_put(network_info, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(connected_service->display_name));
+	}
+	else
+	{
+		jobject_put(network_info, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(connected_service->name));
+	}
+
+	jobject_put(network_info, J_CSTR_TO_JVAL("ssid"),
+	            jstring_create(connected_service->name));
+
+	wifi_profile_t *profile = NULL;
+
+	if (connected_service->security != NULL)
+	{
+		profile = get_profile_by_ssid_security(connected_service->name,
+		                                       connected_service->security[0]);
+	}
+
+	if (NULL != profile)
+	{
+		jobject_put(network_info, J_CSTR_TO_JVAL("profileId"),
+		            jnumber_create_i32(profile->profile_id));
+	}
+
+	if (connected_service->state != NULL)
+	{
+		connman_state = connman_service_get_state(connected_service->state);
+		jobject_put(network_info, J_CSTR_TO_JVAL("connectState"),
+		            jstring_create(connman_service_get_webos_state(connman_state)));
+	}
+
+	jobject_put(network_info, J_CSTR_TO_JVAL("signalBars"),
+	            jnumber_create_i32(signal_strength_to_bars(connected_service->strength)));
+	jobject_put(network_info, J_CSTR_TO_JVAL("signalLevel"),
+	            jnumber_create_i32(connected_service->strength));
+
+	jobject_put(*reply,  J_CSTR_TO_JVAL("networkInfo"), network_info);
+
+	/* Fill in ip information only for a service which is online (fully connected) */
+	if (connman_state == CONNMAN_SERVICE_STATE_ONLINE
+	        || connman_state == CONNMAN_SERVICE_STATE_READY)
+	{
+		connman_service_get_ipinfo(connected_service);
+		jvalue_ref ip_info = jobject_create();
+
+		if (connected_service->ipinfo.iface)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("interface"),
+			            jstring_create(connected_service->ipinfo.iface));
+		}
+
+		if (connected_service->ipinfo.ipv4.address)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("ip"),
+			            jstring_create(connected_service->ipinfo.ipv4.address));
+		}
+
+		if (connected_service->ipinfo.ipv4.netmask)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("subnet"),
+			            jstring_create(connected_service->ipinfo.ipv4.netmask));
+		}
+
+		if (connected_service->ipinfo.ipv4.gateway)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("gateway"),
+			            jstring_create(connected_service->ipinfo.ipv4.gateway));
+		}
+
+		if (connected_service->ipinfo.dns != NULL)
+		{
+			gsize i;
+			char dns_str[16];
+
+			for (i = 0; i < g_strv_length(connected_service->ipinfo.dns); i++)
+			{
+				g_snprintf(dns_str, 16, "dns%d", i + 1);
+				jobject_put(ip_info, jstring_create(dns_str),
+				            jstring_create(connected_service->ipinfo.dns[i]));
+			}
+		}
+
+		if (connected_service->ipinfo.ipv4.method)
+		{
+			jobject_put(ip_info, J_CSTR_TO_JVAL("method"),
+			            jstring_create(connected_service->ipinfo.ipv4.method));
+		}
+
+		if (NULL != connected_service->ipinfo.ipv6.address)
+		{
+			jvalue_ref connected_ipv6_status = jobject_create();
+
+			jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("ip"),
+			            jstring_create(connected_service->ipinfo.ipv6.address));
+
+			if (connected_service->ipinfo.ipv6.prefix_length >= 0 &&
+			        connected_service->ipinfo.ipv6.prefix_length <= MAX_PREFIX_LENGTH)
+			{
+				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("prefixLength"),
+				            jnumber_create_i32(connected_service->ipinfo.ipv6.prefix_length));
+			}
+
+			if (NULL != connected_service->ipinfo.ipv6.gateway)
+			{
+				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("gateway"),
+				            jstring_create(connected_service->ipinfo.ipv6.gateway));
+			}
+
+			if (NULL != connected_service->ipinfo.ipv6.method)
+			{
+				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("method"),
+				            jstring_create(connected_service->ipinfo.ipv6.method));
+			}
+
+			jobject_put(ip_info, J_CSTR_TO_JVAL("ipv6"), connected_ipv6_status);
+		}
+
+		jobject_put(*reply,  J_CSTR_TO_JVAL("ipInfo"), ip_info);
+	}
+}
+
+
+/**
+ * @brief Fill in all status information to be sent with 'getstatus' method
+ */
+
+static void create_wifi_getstatus_response(jvalue_ref *reply, bool subscribed)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(*reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("wakeOnWlan"), jstring_create("disabled"));
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("tetheringEnabled"),
+	            jboolean_create(is_wifi_tethering()));
+
+	gboolean powered = is_wifi_powered() && !is_wifi_tethering();
+
+	/* Get the service which is connecting or already in connected state */
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+			manager->wifi_services);
+
+	const char* status;
+
+	if (connected_service != NULL)
+	{
+		status = "connectionStateChanged";
+	}
+	else if (powered)
+	{
+		status = "serviceEnabled";
+	}
+	else
+	{
+		status = "serviceDisabled";
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("status"), jstring_create(status));
+
+	if (connected_service != NULL)
+	{
+		add_connected_network_status(reply, connected_service);
+	}
+}
+
+static void wifi_send_status_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	create_wifi_getstatus_response(&reply, true);
+
+	const char *payload = jvalue_tostring(reply, jschema_all());
+
+	/*
+	 * Do not send identical responses back.
+	 * Check if the payload is different from previous payload.
+	 * Note this is executed also when there are no subscribers, keeping
+	 * prev_response always up to date with current situation.
+	 **/
+	if (g_strcmp0(payload, wifi_getstatus_prev_response) != 0)
+	{
+		g_free(wifi_getstatus_prev_response);
+		wifi_getstatus_prev_response = g_strdup(payload);
+
+		WCALOG_DEBUG("Sending payload : %s", payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		// com.webos.service.wifi/getstatus
+		if (!LSSubscriptionReply(pLsHandle,
+		                        LUNA_CATEGORY_ROOT LUNA_METHOD_GETSTATUS,
+		                        payload,
+		                        &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		// com.webos.service.wifi/getStatus
+		if (!LSSubscriptionReply(pLsHandle,
+		                        LUNA_CATEGORY_ROOT LUNA_METHOD_GETSTATUS2,
+		                        payload,
+		                        &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	j_release(&reply);
+
+	connectionmanager_send_status_to_subscribers();
+}
+
+/**
+ * Timer callback method to delete profile.
+ * @param - user_data - service path, owned by the callback method.
+ */
+static gboolean delete_profile_if_not_connected(gpointer user_data)
+{
+	char* service_path = (char*) user_data;
+
+	if (NULL == manager)
+	{
+		goto cleanup;
+	}
+
+	connman_service_t *service = connman_manager_find_service_by_path(
+			manager->wifi_services,
+			service_path);
+
+	if (NULL == service)
+	{
+		WCALOG_INFO(MSGID_WIFI_SERVICE_NOT_EXIST, 0, "Service %s doesn't exist",
+		            service_path);
+		goto cleanup;
+	}
+
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+	        manager->wifi_services);
+
+	if (NULL != connected_service || (connected_service != service))
+	{
+		wifi_profile_t *profile = get_profile_by_ssid_security(service->name,
+		                          service->security[0]);
+
+		if (NULL != profile)
+		{
+			delete_profile(profile);
+		}
+
+		connman_service_remove(service);
+		connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+		if(wifi_tech)
+			connman_technology_remove_saved_profiles(wifi_tech, "all");
+	}
+
+cleanup:
+	g_free(user_data);
+	return FALSE;
+}
+
+/**
+ * When the user requests a connection to a network and the connection establishment
+ * process fails we don't immediately report this to the user but waiting until the
+ * service object enters the failure state in order to analyze why things went wrong.
+
+ * By doing this we can provide a appropiate error message to the user an not simply
+ * failing with a common error message.
+ *
+ * Currently we're handling all known errors connman returns. See method error2string
+ * in src/service.c of the connman source tree for all currently handled errors.
+ */
+
+static void handle_failed_connection_request(gpointer user_data)
+{
+	const char *error_message = "Unknown error";
+	unsigned int error_code = WCA_API_ERROR_UNKNOWN;
+
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	if (NULL == current_connect_req)
+	{
+		return;
+	}
+
+	current_service_data_t *service_data = current_connect_req->user_data;
+
+	if (NULL == service_data)
+	{
+		goto cleanup;
+	}
+
+	connman_service_t *service = service_data->service;
+	connection_settings_t *settings = service_data->settings;
+
+	if (NULL == service || NULL == g_slist_find(manager->wifi_services, service))
+	{
+		LSMessageReplyCustomError(current_connect_req->handle,
+		                          current_connect_req->message,
+		                          error_message, error_code);
+		goto cleanup;
+	}
+
+	if (NULL == service->path)
+	{
+		WCALOG_INFO(MSGID_WIFI_SKIPPING_FETCH_PROPERTIES, 0,
+		            "Skipping fetch properties");
+		goto cleanup;
+	}
+
+	if (NULL == connman_manager_find_service_by_path(manager->wifi_services,
+	        service->path))
+	{
+		WCALOG_INFO(MSGID_WIFI_SERVICE_NOT_EXIST, 0, "Service %s doesn't exist",
+		            service->name);
+		LSMessageReplyCustomError(current_connect_req->handle,
+		                          current_connect_req->message,
+		                          error_message, error_code);
+		goto cleanup;
+	}
+
+	GVariant *properties = connman_service_fetch_properties(service);
+
+	if (NULL == properties)
+	{
+		goto cleanup;
+	}
+
+	connman_service_update_properties(service, properties);
+	g_variant_unref(properties);
+
+	if (g_strcmp0(service->error, "invalid-key") == 0)
+	{
+		error_message = "The supplied password is incorrect";
+		error_code = WCA_API_ERROR_INVALID_KEY;
+	}
+	else if (g_strcmp0(service->error, "auth-failed") == 0)
+	{
+		error_message = "Authentication with access point failed";
+		error_code = WCA_API_ERROR_AUTH_FAILED;
+	}
+	else if (g_strcmp0(service->error, "login-failed") == 0)
+	{
+		error_message = "Login failed";
+		error_code = WCA_API_ERROR_LOGIN_FAILED;
+	}
+	else if (g_strcmp0(service->error, "connect-failed") == 0)
+	{
+		error_message = "Could not establish a connection to access point";
+		error_code = WCA_API_ERROR_CONNECT_FAILED;
+	}
+	else if (g_strcmp0(service->error, "dhcp-failed") == 0)
+	{
+		error_message = "Could not retrieve a valid IP address by using DHCP";
+		error_code = WCA_API_ERROR_DHCP_FAILED;
+	}
+	else if (g_strcmp0(service->error, "pin-missing") == 0)
+	{
+		error_message = "PIN is missing";
+		error_code = WCA_API_ERROR_PIN_MISSING;
+	}
+	else if (g_strcmp0(service->error, "out-of-range") == 0)
+	{
+		error_message = "Out of range";
+		error_code = WCA_API_ERROR_OUT_OF_RANGE;
+	}
+
+	LSMessageReplyCustomError(current_connect_req->handle,
+	                          current_connect_req->message,
+	                          error_message, error_code);
+
+	if (settings && !settings->store)
+	{
+		// In case of enterprise networks we always create a profile (even before connecting to it),
+		// so in case the connection fails, we should delete the profile and the corresponding config file
+		// Give it 2 sec for service to auto-connect
+		char* service_name = g_strdup(service->path);
+		g_timeout_add_seconds(5, delete_profile_if_not_connected, service_name);
+	}
+
+#ifndef ENABLE_SINGLE_PROFILE
+
+	if (settings && settings->store)
+	{
+		store_network_config(settings, service->security[0]);
+	}
+
+#endif
+cleanup:
+
+	if (current_connect_req != NULL)
+	{
+		current_connect_req_free();
+	}
+}
+
+/**
+ * @brief Remove a single service per SSID or all other services which don't
+ *        match the SSID but are marked as autoconnectable or as favorite.
+ *
+ * @param ssid
+ * @param others
+ */
+static void remove_service_or_all_other(const gchar *ssid, gboolean others)
+{
+	GSList *ap = NULL;
+
+	/* Look up for any existing service with ssid same as this profile*/
+	for (ap = manager->wifi_services; ap; ap = ap->next)
+	{
+		connman_service_t *service = (connman_service_t *)(ap->data);
+
+		if ((others == FALSE && !g_strcmp0(service->name, ssid)) ||
+		        (others == TRUE  &&  g_strcmp0(service->name, ssid)))
+		{
+			if (service->state == NULL)
+			{
+				continue;
+			}
+
+			if (!service->favorite && !service->auto_connect)
+			{
+				continue;
+			}
+
+			/* We can't really change immutable services this way so don't try it */
+			if (service->immutable)
+			{
+				continue;
+			}
+
+			/* Deleting profile for this ssid, so set autoconnect property for this
+			   service to FALSE so that connman doesn't autoconnect to this service next time */
+			connman_service_set_autoconnect(service, FALSE);
+
+			/* Remove the service from connman (will disconnect it first if connected) */
+			connman_service_remove(service);
+
+			WCALOG_ADDR_INFOMSG(MSGID_WIFI_DISCONNECT_SERVICE, "Service", service);
+		}
+	}
+}
+
+/**
+ *  @brief Callback function registered with connman service whenever any of its properties change
+ *
+ *
+ *  @param data
+ *  @param property
+ *  @param value
+ */
+
+static void service_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	if (!g_strcmp0(property, "State"))
+	{
+		connman_service_t *service = (connman_service_t *)data;
+
+		if (NULL == service)
+		{
+			return;
+		}
+
+		WCALOG_INFO(MSGID_WIFI_CONNECT_SERVICE,2,PMLOGKS("Service", service->name),PMLOGKS("state changed to",service->state),"");
+
+		bool is_wifi_service = (CONNMAN_SERVICE_TYPE_WIFI == service->type);
+
+		if (is_wifi_service && check_wifi_services_for_updates())
+		{
+			send_findnetworks_status_to_subscribers();
+		}
+
+		send_getnetworks_status_to_subscribers();
+
+		int service_state = connman_service_get_state(service->state);
+
+		switch (service_state)
+		{
+			case  CONNMAN_SERVICE_STATE_CONFIGURATION:
+				break;
+
+			case  CONNMAN_SERVICE_STATE_READY:
+			case  CONNMAN_SERVICE_STATE_ONLINE:
+				wifi_send_status_to_subscribers();
+				connman_service_set_autoconnect(service, TRUE);
+				break;
+
+			case CONNMAN_SERVICE_STATE_IDLE:
+				wifi_send_status_to_subscribers();
+				return;
+
+			case CONNMAN_SERVICE_STATE_FAILURE:
+
+				/* When the service object the state has changed for is not the one we're
+				 * currently connecting to then we do nothing here. */
+				if (!current_connect_req)
+				{
+					return;
+				}
+
+				current_service_data_t *service_data = current_connect_req->user_data;
+
+				if (service_data)
+				{
+					connman_service_t *curr_service = service_data->service;
+
+					// In case of hidden networks the original service never matches with the new service added
+					if (service != curr_service)
+					{
+						service_data->service = service;
+					}
+				}
+
+				handle_failed_connection_request(NULL);
+				return;
+
+			default:
+				return;
+		}
+
+		if (NULL == service->name)
+		{
+			// Hidden network.
+			return;
+		}
+
+		wifi_profile_t *profile = NULL;
+
+		if (service->security != NULL)
+		{
+			profile = get_profile_by_ssid_security(service->name, service->security[0]);
+		}
+
+		if (NULL != profile)
+		{
+			/* If profile already exists, move it to top of the list */
+			move_profile_to_head(profile);
+		}
+		else
+		{
+			/* Else, create a new profile */
+			if (service->security == NULL)
+			{
+				profile = create_new_profile(service->name, NULL, service->hidden, FALSE);
+			}
+			else
+			{
+				profile = create_new_profile(service->name, service->security, service->hidden,
+				                             FALSE);
+			}
+		}
+
+#ifdef ENABLE_SINGLE_PROFILE
+
+		if (profile && is_wifi_service)
+		{
+			/* TODO: Only wifi profiles should be removed?
+			   Check with requirements and possibly update.
+			*/
+
+			/* Remove adapter stored services */
+			remove_service_or_all_other(profile->ssid, TRUE);
+
+			/* Remove all services connman has reported to adapter */
+			delete_all_profiles_except_one(profile->profile_id);
+
+			/* Ask connman to remove profiles it has in it's config files */
+			connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+			if (wifi_tech)
+			{
+				connman_technology_remove_saved_profiles(wifi_tech, service->identifier);
+			}
+		}
+
+#endif
+		/* Unset agent callback as we no longer have any valid input for connman available */
+		connman_agent_set_request_input_callback(agent, NULL, NULL);
+	}
+	else if (!g_strcmp0(property, "Online"))
+	{
+		connman_service_t *service = (connman_service_t *)data;
+
+		if (NULL == service)
+		{
+			return;
+		}
+
+		WCALOG_INFO(MSGID_WIFI_CONNECT_SERVICE,2,PMLOGKS("Service", service->name),PMLOGKS("online flag changed to",service->online?"TRUE":"FALSE"),"");
+		wifi_send_status_to_subscribers();
+		send_findnetworks_status_to_subscribers();
+	}
+}
+
+/**  @brief Add details about the given service representing a wifi access point
+ *
+ *  @param service
+ *  @param network
+ *
+ */
+
+static bool add_service(connman_service_t *service, jvalue_ref *network,
+                        gboolean available)
+{
+	if (NULL == service || NULL == network || NULL == service->name)
+	{
+		/* Service->name is null for hidden wifi networks. Do not include those */
+		return false;
+	}
+
+	bool supported = true;
+
+	if (service->display_name)
+	{
+		jobject_put(*network, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(service->display_name));
+	}
+	else
+	{
+		jobject_put(*network, J_CSTR_TO_JVAL("displayName"),
+		            jstring_create(service->name));
+	}
+
+	jobject_put(*network, J_CSTR_TO_JVAL("ssid"), jstring_create(service->name));
+
+	wifi_profile_t *profile = NULL;
+
+	if (service->security != NULL)
+	{
+		profile = get_profile_by_ssid_security(service->name, service->security[0]);
+	}
+
+	if (NULL != profile)
+	{
+		jobject_put(*network, J_CSTR_TO_JVAL("profileId"),
+		            jnumber_create_i32(profile->profile_id));
+	}
+
+	if (available == TRUE)
+	{
+		if ((service->security != NULL) && g_strv_length(service->security))
+		{
+			gsize i;
+			jvalue_ref security_list = jarray_create(NULL);
+
+			for (i = 0; i < g_strv_length(service->security); i++)
+			{
+				jarray_append(security_list, jstring_create(service->security[i]));
+			}
+
+			jobject_put(*network, J_CSTR_TO_JVAL("availableSecurityTypes"), security_list);
+		}
+
+		if (service->strength != NULL)
+		{
+			jobject_put(*network, J_CSTR_TO_JVAL("signalBars"),
+			            jnumber_create_i32(signal_strength_to_bars(service->strength)));
+			jobject_put(*network, J_CSTR_TO_JVAL("signalLevel"),
+			            jnumber_create_i32(service->strength));
+		}
+
+		//Add BSS
+		if (service->bss != NULL)
+		{
+			jvalue_ref bss_array = jarray_create(NULL);
+			guint length = service->bss->len;
+			guint j;
+			for (j = 0; j < length; j++)
+			{
+				bssinfo_t* bss_info = &g_array_index(service->bss, bssinfo_t, j);
+				jvalue_ref bss_val = jobject_create();
+
+				jobject_put(bss_val, J_CSTR_TO_JVAL("bssid"),
+				            jstring_create(bss_info->bssid));
+				jobject_put(bss_val, J_CSTR_TO_JVAL("signal"),
+				            jnumber_create_i32(bss_info->signal));
+				jobject_put(bss_val, J_CSTR_TO_JVAL("frequency"),
+				            jnumber_create_i32(bss_info->frequency));
+
+				jarray_append(bss_array, bss_val);
+			}
+
+			jobject_put(*network, J_CSTR_TO_JVAL("bssInfo"), bss_array);
+		}
+	}
+
+	jobject_put(*network, J_CSTR_TO_JVAL("supported"), jboolean_create(supported));
+
+	jobject_put(*network, J_CSTR_TO_JVAL("available"), jboolean_create(available));
+
+	if (service->state != NULL)
+	{
+		if (connman_service_get_state(service->state) != CONNMAN_SERVICE_STATE_IDLE)
+		{
+			jobject_put(*network, J_CSTR_TO_JVAL("connectState"),
+			            jstring_create(connman_service_get_webos_state(connman_service_get_state(
+			                               service->state))));
+			/* Register for 'PropertyChanged' signal for this service to update its connection status */
+			/* The hidden services, once connected, get added as a new service in "association" state */
+			connman_service_register_property_changed_cb(service,
+			        service_property_changed_callback);
+		}
+	}
+
+	return true;
+}
+
+static void add_service_from_profile(wifi_profile_t *profile,
+                                     jvalue_ref *network)
+{
+	if (NULL == profile || NULL == network)
+	{
+		return;
+	}
+
+	gboolean supported = TRUE;
+
+	jobject_put(*network, J_CSTR_TO_JVAL("ssid"), jstring_create(profile->ssid));
+
+	jobject_put(*network, J_CSTR_TO_JVAL("profileId"),
+	            jnumber_create_i32(profile->profile_id));
+
+	if ((profile->security != NULL) && g_strv_length(profile->security))
+	{
+		gsize i;
+		jvalue_ref security_list = jarray_create(NULL);
+
+		for (i = 0; i < g_strv_length(profile->security); i++)
+		{
+			jarray_append(security_list, jstring_create(profile->security[i]));
+		}
+
+		jobject_put(*network, J_CSTR_TO_JVAL("availableSecurityTypes"), security_list);
+	}
+
+	jobject_put(*network, J_CSTR_TO_JVAL("supported"), jboolean_create(supported));
+
+	jobject_put(*network, J_CSTR_TO_JVAL("available"), jboolean_create(false));
+}
+
+
+/**
+ * @brief Check if a profile is present in the saved_services list,
+ * return TRUE if its present, FALSE otherwise
+ */
+static gboolean find_saved_service_by_profile(wifi_profile_t *profile)
+{
+	GSList *ap;
+
+	for (ap = manager->saved_services; NULL != ap ; ap = ap->next)
+	{
+		connman_service_t *service = (connman_service_t *)(ap->data);
+
+		if (NULL == service->name)
+		{
+			continue;
+		}
+
+		if (g_strcmp0(service->name, profile->ssid) != 0)
+		{
+			continue;
+		}
+
+		if (service->security[0] != NULL &&
+		        g_strcmp0(service->security[0], profile->security[0]) != 0)
+		{
+			continue;
+		}
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+/**
+ *  @brief Populate information about all the found networks
+ *
+ *  @param reply
+ *  @param show_saved_nw
+ *
+ */
+
+static void populate_wifi_networks(jvalue_ref *reply, gboolean show_saved_nw)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jvalue_ref network_list = jarray_create(NULL);
+
+	manager->wifi_services = g_slist_sort(manager->wifi_services, (GCompareFunc) compare_signal_strength);
+
+	GSList *ap;
+
+	/* Go through the manager's services list and fill in details
+	 * for each one of them */
+	for (ap = manager->wifi_services; NULL != ap ; ap = ap->next)
+	{
+		connman_service_t *service = (connman_service_t *)(ap->data);
+
+		jvalue_ref network = jobject_create();
+
+		if (add_service(service, &network, TRUE))
+		{
+			jvalue_ref network_list_j = jobject_create();
+			jobject_put(network_list_j, J_CSTR_TO_JVAL("networkInfo"), network);
+			jarray_append(network_list, network_list_j);
+		}
+		else
+		{
+			j_release(&network);
+		}
+	}
+
+	// Populate out of range networks only if saved flag is TRUE
+	if (show_saved_nw == TRUE)
+	{
+		wifi_profile_t *profile = NULL;
+
+		/* Go through the manager's saved services list and if its a wifi service
+		   not in the wifi_services list, then list the service as not available */
+		for (ap = manager->saved_services; NULL != ap ; ap = ap->next)
+		{
+			connman_service_t *service = (connman_service_t *)(ap->data);
+			jvalue_ref network;
+
+			/* Consider only wifi services */
+			if (service->type != CONNMAN_SERVICE_TYPE_WIFI)
+			{
+				continue;
+			}
+
+			/** Skip services already present in wifi - we do not want duplicate
+			 *  services */
+			if (NULL != connman_manager_find_service_by_path(
+			        manager->wifi_services,
+			        service->path))
+			{
+				continue;
+			}
+
+			network = jobject_create();
+
+			if (add_service(service, &network, FALSE))
+			{
+				jvalue_ref network_list_j = jobject_create();
+				jobject_put(network_list_j, J_CSTR_TO_JVAL("networkInfo"), network);
+				jarray_append(network_list, network_list_j);
+			}
+			else
+			{
+				j_release(&network);
+			}
+		}
+
+		profile = NULL;
+
+		/** Add services that are not in connman saved services list but are
+		 * in adapter's profile list.
+		 */
+		while (NULL != (profile = get_next_profile(profile)))
+		{
+			if (!profile->configured)
+			{
+				continue;
+			}
+
+			if (find_saved_service_by_profile(profile) == FALSE)
+			{
+				jvalue_ref network = jobject_create();
+				add_service_from_profile(profile, &network);
+
+				jvalue_ref network_list_j = jobject_create();
+				jobject_put(network_list_j, J_CSTR_TO_JVAL("networkInfo"), network);
+				jarray_append(network_list, network_list_j);
+			}
+		}
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("foundNetworks"), network_list);
+}
+
+
+GVariant *agent_request_input_callback(GVariant *fields, gpointer data)
+{
+	connection_settings_t *settings = data;
+	GVariant *response = NULL;
+	GVariantBuilder *vabuilder;
+	GVariantIter iter;
+	gchar *key;
+	GVariant *value;
+
+	if (!g_variant_is_container(fields))
+	{
+		connection_settings_free(settings);
+		return NULL;
+	}
+
+	vabuilder = g_variant_builder_new((const GVariantType *)"a{sv}");
+
+	g_variant_iter_init(&iter, fields);
+
+	while (g_variant_iter_next(&iter, "{sv}", &key, &value))
+	{
+		if (!strncmp(key, "Name", 10))
+		{
+			if (NULL != settings->ssid)
+			{
+				g_variant_builder_add(vabuilder, "{sv}", "Name",
+				                      g_variant_new("s", settings->ssid));
+			}
+		}
+		else if (!strncmp(key, "Passphrase", 10))
+		{
+			/* FIXME we're ignoring the other fields here as we're only connecting to
+			 * psk secured networks at the moment */
+			if (NULL != settings->passkey)
+			{
+				g_variant_builder_add(vabuilder, "{sv}", "Passphrase",
+				                      g_variant_new("s", settings->passkey));
+			}
+		}
+		else if (!strncmp(key, "WPS", 10))
+		{
+			if (settings->wpsmode)
+			{
+				if (settings->wpspin != NULL)
+				{
+					g_variant_builder_add(vabuilder, "{sv}", "WPS",
+					                      g_variant_new("s", settings->wpspin));
+				}
+			}
+		}
+
+		g_variant_unref(value);
+		g_free(key);
+	}
+
+	response = g_variant_builder_end(vabuilder);
+	g_variant_builder_unref(vabuilder);
+
+	//  connection_settings_free(settings);
+
+	connman_agent_set_request_input_callback(agent, NULL, NULL);
+	return response;
+}
+
+static void service_connect_callback(gboolean success, gpointer user_data)
+{
+	UNUSED(user_data);
+
+	if (!current_connect_req)
+	{
+		// Something is wrong. It should have been there. There is no luna call to respond to. Log an error.
+		WCALOG_ESCAPED_ERRMSG(MSGID_WIFI_CONNECT_SERVICE,
+		                      "Missing connect request on connect callback!");
+		return;
+	}
+
+	luna_service_request_t *service_req = current_connect_req;
+
+	/* if the connection could not be established we're waiting for the service to switch
+	 * it's state to failure until we report the failed connection request to the user */
+	if (!success)
+	{
+		g_timeout_add_seconds(2, handle_failed_connection_request, NULL);
+		return;
+	}
+
+	LSMessageReplySuccess(service_req->handle, service_req->message);
+
+	current_connect_req_free();
+}
+
+bool check_service_security(connman_service_t *service, const char *security)
+{
+	int n = 0;
+
+	if (!service->security || !security)
+	{
+		return false;
+	}
+
+	for (n = 0; n < g_strv_length(service->security); n++)
+		if (!g_strcmp0(service->security[n], security))
+		{
+			return true;
+		}
+
+	return false;
+}
+
+void connect_after_scan_cb(gpointer user_data)
+{
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!wifi_tech || !current_connect_req)
+	{
+		return;
+	}
+
+	current_service_data_t *service_data = current_connect_req->user_data;
+	connman_service_t *service = NULL;
+
+	if (service_data)
+	{
+		service = service_data->service;
+	}
+
+	if (!wifi_tech || !service)
+	{
+		goto error;
+	}
+
+	if (!connman_service_connect(service, service_connect_callback, NULL))
+	{
+		LSMessageReplyErrorUnknown(current_connect_req->handle,
+		                           current_connect_req->message);
+		goto cleanup;
+	}
+
+	return;
+
+error:
+	LSMessageReplyCustomError(current_connect_req->handle,
+	                          current_connect_req->message,
+	                          "Internal error", WCA_API_ERROR_INTERNAL);
+cleanup:
+	current_connect_req_free();
+}
+
+/**
+ *  @brief Connect to a access point with the given ssid
+ *
+ *  @param ssid
+ */
+
+static void connect_wifi_with_ssid(const char *ssid, wifi_profile_t *profile,
+                                   jvalue_ref req_object, luna_service_request_t *service_req)
+{
+	jvalue_ref security_obj = NULL;
+	jvalue_ref simple_security_obj = NULL;
+	jvalue_ref enterprise_security_obj = NULL;
+	jvalue_ref passkey_obj = NULL;
+	jvalue_ref hidden_obj = NULL;
+	jvalue_ref wps_obj = NULL;
+	jvalue_ref wpspin_obj = NULL;
+	jvalue_ref type_obj = NULL;
+	jvalue_ref store_profile_obj = NULL;
+	jvalue_ref identity_obj = NULL;
+	jvalue_ref eap_type_obj = NULL;
+	jvalue_ref ca_cert_file_obj = NULL;
+	jvalue_ref client_cert_file_obj = NULL;
+	jvalue_ref private_key_file_obj = NULL;
+	jvalue_ref private_key_passphrase_obj = NULL;
+	jvalue_ref phase2_obj = NULL;
+	jvalue_ref passphrase_obj = NULL;
+	jvalue_ref fast_provisioning_obj = NULL;
+	jvalue_ref pac_file_obj = NULL;
+
+
+	raw_buffer passkey_buf, wpspin_buf;
+	GSList *ap;
+	gboolean found_service = FALSE;
+	connection_settings_t *settings = NULL;
+	connman_service_t *service = NULL;
+	bool hidden = false, store_profile = false;
+	gchar *security = NULL;
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (NULL == ssid || NULL == wifi_tech)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Internal error", WCA_API_ERROR_INTERNAL);
+		goto cleanup;
+	}
+
+	if (current_connect_req)
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Already connecting to a network", WCA_API_ERROR_ALREADY_CONNECTING);
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(req_object, J_CSTR_TO_BUF("wasCreatedWithJoinOther"),
+	                       &hidden_obj))
+	{
+		jboolean_get(hidden_obj, &hidden);
+	}
+
+	if (jobject_get_exists(req_object, J_CSTR_TO_BUF("storeProfile"),
+	                       &store_profile_obj))
+	{
+		jboolean_get(store_profile_obj, &store_profile);
+	}
+
+	if (jobject_get_exists(req_object, J_CSTR_TO_BUF("security"), &security_obj))
+	{
+		if (jobject_get_exists(security_obj, J_CSTR_TO_BUF("securityType"), &type_obj))
+		{
+			raw_buffer type_buf = jstring_get(type_obj);
+			security = strdup(type_buf.m_str);
+			jstring_free_buffer(type_buf);
+
+			if (g_strcmp0(security, "none") &&
+					g_strcmp0(security, "wep") &&
+					g_strcmp0(security, "psk") &&
+					g_strcmp0(security, "ieee8021x"))
+			{
+				LSMessageReplyCustomError(service_req->handle, service_req->message,
+				                          "Invalid securityType",
+				                          WCA_API_ERROR_WIFI_SECURITY_TYPE_INVALID);
+				goto cleanup;
+			}
+		}
+	}
+	else if (profile != NULL && profile->security != NULL)
+	{
+		security = strdup(profile->security[0]);
+	}
+
+	if (security == NULL)
+	{
+		security = strdup("none");
+	}
+
+	/* Look up for the service with the given ssid */
+	for (ap = manager->wifi_services; NULL != ap ; ap = ap->next)
+	{
+		service = (connman_service_t *)(ap->data);
+
+		if (NULL == service->name)
+		{
+			if (hidden)
+			{
+				if (check_service_security(service, security))
+				{
+					found_service = TRUE;
+				}
+			}
+		}
+
+		if (found_service || (!g_strcmp0(service->name, ssid) &&
+		                      check_service_security(service, security)))
+		{
+			connman_service_t *connected_service = connman_manager_get_connected_service(
+			        manager->wifi_services);
+			wifi_profile_t *current_connected_profile = NULL;
+
+			if (NULL == service->name)
+			{
+				WCALOG_INFO(MSGID_WIFI_CONNECT_HIDDEN_SERVICE, 0, "");
+			}
+			else
+			{
+				/* For the case that the hidden network name the user specified matches
+				 * with one of the known networks we need to validate that the security
+				 * for matches for both */
+				if (hidden && !check_service_security(service, security))
+				{
+					continue;
+				}
+				else if (hidden && check_service_security(service, security))
+				{
+					/* If user input is same with the current service,
+					 * return the error msg before connecting to same network */
+					if (connected_service)
+					{
+						current_connected_profile = get_profile_by_ssid(connected_service->name);
+
+						if ((NULL != current_connected_profile) &&
+						        !g_strcmp0(ssid, connected_service->name))
+						{
+							WCALOG_DEBUG("Already connected via hidden network");
+							LSMessageReplyCustomError(service_req->handle, service_req->message,
+							                          "Already connected via hidden network", WCA_API_ERROR_ALREADY_CONNECTED);
+							goto cleanup;
+						}
+					}
+				}
+
+				WCALOG_ADDR_INFOMSG(MSGID_WIFI_CONNECT_SERVICE, "Service", service);
+			}
+
+			found_service = TRUE;
+
+			/* For the connection to hidden network, User input has higher priority
+			 * than status of connected service. So ignore former condition */
+			if (NULL != connected_service && (connected_service == service))
+			{
+				/* Already connected so connection was successful */
+				LSMessageReplySuccess(service_req->handle, service_req->message);
+				WCALOG_DEBUG("Already connected with network");
+				goto cleanup;
+			}
+
+			/* Register for 'PropertyChanged' signal for this service to update its connection status */
+			connman_service_register_property_changed_cb(service,
+			        service_property_changed_callback);
+			break;
+		}
+	}
+
+
+	if (jobject_get_exists(req_object, J_CSTR_TO_BUF("security"), &security_obj))
+	{
+		settings = connection_settings_new();
+		if (NULL == settings)
+			goto cleanup;
+
+		settings->ssid = strdup(ssid);
+
+		/* parse security parameters and set connection settings accordingly */
+		if (jobject_get_exists(security_obj, J_CSTR_TO_BUF("simpleSecurity"),
+		                       &simple_security_obj) &&
+		        jobject_get_exists(simple_security_obj, J_CSTR_TO_BUF("passKey"), &passkey_obj))
+		{
+			passkey_buf = jstring_get(passkey_obj);
+			settings->passkey = strdup(passkey_buf.m_str);
+			jstring_free_buffer(passkey_buf);
+
+			if (!is_valid_wifi_passphrase(settings->passkey, security))
+			{
+				LSMessageReplyCustomError(service_req->handle, service_req->message,
+				                          "Passphrase doesn't match the requirements",
+				                          WCA_API_ERROR_WIFI_PASSPHRASE_INVALID);
+				goto cleanup;
+			}
+		}
+		else if (jobject_get_exists(security_obj, J_CSTR_TO_BUF("enterpriseSecurity"),
+		                            &enterprise_security_obj))
+		{
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("eapType"),
+			                       &eap_type_obj))
+			{
+				raw_buffer eap_type_buf = jstring_get(eap_type_obj);
+				settings->eap_type = g_strdup(eap_type_buf.m_str);
+				jstring_free_buffer(eap_type_buf);
+
+				if (g_strcmp0(settings->eap_type, "peap") &&
+				        g_strcmp0(settings->eap_type, "ttls") && g_strcmp0(settings->eap_type, "tls"))
+				{
+					LSMessageReplyCustomError(service_req->handle, service_req->message,
+					                          "Invalid eapType", WCA_API_ERROR_INVALID_PARAMETERS);
+					goto cleanup;
+				}
+			}
+			else
+			{
+				LSMessageReplyErrorInvalidParams(service_req->handle, service_req->message);
+				goto cleanup;
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("identity"),
+			                       &identity_obj))
+			{
+				raw_buffer identity_buf = jstring_get(identity_obj);
+				settings->identity = g_strdup(identity_buf.m_str);
+				jstring_free_buffer(identity_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("caCertFile"),
+			                       &ca_cert_file_obj))
+			{
+				raw_buffer ca_cert_file_buf = jstring_get(ca_cert_file_obj);
+				settings->ca_cert_file = g_strdup(ca_cert_file_buf.m_str);
+				jstring_free_buffer(ca_cert_file_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("clientCertFile"),
+			                       &client_cert_file_obj))
+			{
+				raw_buffer client_cert_file_buf = jstring_get(client_cert_file_obj);
+				settings->client_cert_file = g_strdup(client_cert_file_buf.m_str);
+				jstring_free_buffer(client_cert_file_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("privateKeyFile"),
+			                       &private_key_file_obj))
+			{
+				raw_buffer private_key_file_buf = jstring_get(private_key_file_obj);
+				settings->private_key_file = g_strdup(private_key_file_buf.m_str);
+				jstring_free_buffer(private_key_file_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj,
+			                       J_CSTR_TO_BUF("privateKeyPassphrase"), &private_key_passphrase_obj))
+			{
+				raw_buffer private_key_passphrase_buf = jstring_get(private_key_passphrase_obj);
+				settings->private_key_passphrase = g_strdup(private_key_passphrase_buf.m_str);
+				jstring_free_buffer(private_key_passphrase_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("phase2"),
+			                       &phase2_obj))
+			{
+				raw_buffer phase2_buf = jstring_get(phase2_obj);
+				settings->phase2 = g_strdup(phase2_buf.m_str);
+				jstring_free_buffer(phase2_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("passphrase"),
+			                       &passphrase_obj))
+			{
+				raw_buffer passphrase_buf = jstring_get(passphrase_obj);
+				settings->passphrase = g_strdup(passphrase_buf.m_str);
+				jstring_free_buffer(passphrase_buf);
+			}
+
+			if (jobject_get_exists(enterprise_security_obj,
+			                       J_CSTR_TO_BUF("fastProvisioning"), &fast_provisioning_obj))
+			{
+				LSMessageReplyCustomError(service_req->handle, service_req->message,
+				                          "This option is not implemented", WCA_API_ERROR_NOT_IMPLEMENTED);
+				goto cleanup;
+			}
+
+			if (jobject_get_exists(enterprise_security_obj, J_CSTR_TO_BUF("pacFile"),
+			                       &pac_file_obj))
+			{
+				LSMessageReplyCustomError(service_req->handle, service_req->message,
+				                          "This option is not implemented", WCA_API_ERROR_NOT_IMPLEMENTED);
+				goto cleanup;
+			}
+		}
+		else if (jobject_get_exists(security_obj, J_CSTR_TO_BUF("wps"), &wps_obj))
+		{
+			jboolean_get(wps_obj, &settings->wpsmode);
+
+			if (jobject_get_exists(security_obj, J_CSTR_TO_BUF("wpsPin"), &wpspin_obj))
+			{
+				if (!jis_string(wpspin_obj))
+				{
+					LSMessageReplyErrorInvalidParams(service_req->handle, service_req->message);
+					goto cleanup;
+				}
+
+				wpspin_buf = jstring_get(wpspin_obj);
+				settings->wpspin = strdup(wpspin_buf.m_str);
+				jstring_free_buffer(wpspin_buf);
+			}
+			else
+			{
+				settings->wpspin = strdup("");
+			}
+		}
+		else
+		{
+			LSMessageReplyErrorInvalidParams(service_req->handle, service_req->message);
+			goto cleanup;
+		}
+
+		WCALOG_DEBUG("Setup for connecting with secured network");
+
+		if (!g_strcmp0(security, WIFI_ENTERPRISE_SECURITY_TYPE))
+		{
+			if (found_service)
+			{
+				settings->store = FALSE; // ignore "storeProfile" field for enterprise networks
+				store_network_config(settings, security);
+			}
+		}
+		else
+		{
+			connman_agent_set_request_input_callback(agent, agent_request_input_callback,
+			        settings);
+		}
+	}
+	else //open network
+	{
+		settings = connection_settings_new();
+		if (NULL == settings)
+			goto cleanup;
+
+		settings->ssid = strdup(ssid);
+
+		if (hidden) //unsecure hidden network
+		{
+			connman_agent_set_request_input_callback(agent, agent_request_input_callback,
+			        settings);
+		}
+	}
+
+	if (settings && store_profile)
+	{
+		settings->store = true;
+	}
+
+	if (settings && hidden)
+	{
+		settings->hidden = true;
+	}
+
+	if (!found_service)
+	{
+#ifndef ENABLE_SINGLE_PROFILE
+
+		if (settings && settings->store)
+		{
+			store_network_config(settings, security);
+		}
+
+#endif
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Network not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
+		goto cleanup;
+	}
+
+	current_service_data_t *service_data;
+	service_data = g_new0(current_service_data_t, 1);
+	service_data->service = service;
+
+	if (settings)
+	{
+		service_data->settings = settings;
+	}
+
+	service_req->user_data = service_data;
+
+	current_connect_req = service_req;
+
+	/* If we're going to connect to a hidden network and a scan is already running we
+	 * have to wait until the scan has finished as connman needs to issue another one
+	 * for the hidden network to be able to connect it */
+
+	if (hidden)
+	{
+		wifi_scan_execute_when_scan_done(connect_after_scan_cb, NULL);
+	}
+	else if (!connman_service_connect(service, service_connect_callback,
+	                                  service_req))
+	{
+		current_connect_req = NULL;
+		LSMessageReplyErrorUnknown(service_req->handle, service_req->message);
+		goto cleanup;
+	}
+
+	goto exit;
+
+cleanup:
+
+	connect_req_free(service_req);
+
+	if (settings)
+	{
+		connection_settings_free(settings);
+	}
+
+exit:
+	g_free(security);
+	return;
+}
+
+/**
+ *  @brief Callback function registered with connman manager whenever any of its properties change
+ *
+ *
+ *  @param data
+ *  @param property
+ *  @param value
+ */
+
+static void manager_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	/* Send getstatus method to all is subscribers whenever manager's state changes */
+	if (!g_strcmp0(property, "State"))
+	{
+		connectionmanager_send_status_to_subscribers();
+	}
+}
+
+/**
+ * @brief Check all wifi services if we have to send an update to all subscribers of the
+ * com.webos.service.wifi/findnetworks API method
+ *
+ * @return TRUE if an update should be send. FALSE otherwise.
+ */
+
+static gboolean check_wifi_services_for_updates(void)
+{
+	GSList *ap;
+
+	for (ap = manager->wifi_services; NULL != ap ; ap = ap->next)
+	{
+		connman_service_t *service = (connman_service_t *)(ap->data);
+
+		if (connman_service_is_changed(service,
+		                               CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS))
+		{
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+/**
+ * @brief Mark all wifi services as unchanged for the findnetworks category
+ */
+
+static void mark_all_wifi_services_as_unchanged(void)
+{
+	GSList *ap;
+
+	for (ap = manager->wifi_services; NULL != ap ; ap = ap->next)
+	{
+		connman_service_t *service = (connman_service_t *)(ap->data);
+		connman_service_unset_changed(service,
+		                              CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS);
+	}
+}
+
+/**
+ *  @brief Callback function registered with connman manager whenever any of its services change
+ *  This would happen whenever any existing service is changed/deleted, or a new service is added
+ *
+ *  @param data
+ */
+
+static void manager_services_changed_callback(gpointer data,
+        unsigned char service_type)
+{
+	if ((service_type & WIFI_SERVICES_CHANGED) && check_wifi_services_for_updates())
+	{
+		/* Send the latest WiFi network list to subscribers of 'findnetworks'/'getNetworks' method */
+		send_findnetworks_status_to_subscribers();
+		send_getnetworks_status_to_subscribers();
+
+		/* We processed the update for the changed wifi networks so mark them as unchanged
+		 * again */
+		mark_all_wifi_services_as_unchanged();
+	}
+
+	if (service_type & ETHERNET_SERVICES_CHANGED)
+	{
+		connectionmanager_send_status_to_subscribers();
+	}
+
+	if (service_type & CELLULAR_SERVICES_CHANGED)
+	{
+		connectionmanager_send_status_to_subscribers();
+		send_wan_connection_status_to_subscribers();
+		send_wan_contexts_update_to_subscribers();
+	}
+
+	if (service_type & BLUETOOTH_SERVICES_CHANGED)
+	{
+		connectionmanager_send_status_to_subscribers();
+	}
+}
+
+void send_getnetworks_status_to_subscribers()
+{
+	jvalue_ref getNetworks_reply = jobject_create();
+	jobject_put(getNetworks_reply, J_CSTR_TO_JVAL("subscribed"),
+	            jboolean_create(true));
+	jobject_put(getNetworks_reply, J_CSTR_TO_JVAL("returnValue"),
+	            jboolean_create(true));
+	populate_wifi_networks(&getNetworks_reply, TRUE);
+
+	const char *getNetworks_payload = jvalue_tostring(getNetworks_reply, jschema_all());
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_GETNETWORKS,
+	                        getNetworks_payload,
+	                        &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&getNetworks_reply);
+}
+
+void send_findnetworks_status_to_subscribers()
+{
+	jvalue_ref findnetworks_reply = jobject_create();
+	jobject_put(findnetworks_reply, J_CSTR_TO_JVAL("subscribed"),
+	            jboolean_create(true));
+	jobject_put(findnetworks_reply, J_CSTR_TO_JVAL("returnValue"),
+	            jboolean_create(true));
+	populate_wifi_networks(&findnetworks_reply, FALSE);
+
+	const char *findnetworks_payload = jvalue_tostring(findnetworks_reply, jschema_all());
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_FINDNETWORKS,
+	                        findnetworks_payload,
+	                        &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&findnetworks_reply);
+}
+
+static int convert_frequency_to_channel(int freq)
+{
+	if (freq >= 2412 && freq <= 2484)
+	{
+		return (freq - 2412) / 5 + 1;
+	}
+	else if (freq >= 5170 && freq <= 5825)
+	{
+		return (freq - 5170) / 5 + 34;
+	}
+	else
+	{
+		return -1;
+	}
+}
+
+#define add_diagnostic_info_field(reply, info, name) ({ \
+    if(info) { \
+        gchar **value_str = g_strsplit(g_strstrip(info), ":", 2); \
+        if(value_str) { \
+            jobject_put(*reply, J_CSTR_TO_JVAL(name), jstring_create(g_strstrip(value_str[1]))); \
+            g_strfreev(value_str); \
+        } \
+    }\
+})
+
+/**
+ * Populate the wifi diagnostics information
+ * Split the technology->diagnostic_info variable if available and add all the values to an existing json object
+ * Or get the interface properties for the wifi interface "wlan0"
+ *
+ * @param technoolgy A technology instance
+ * @param reply The json object which needs to be updated
+ */
+
+static gboolean make_wifi_diagnostics_payload(connman_technology_t *technology,
+        jvalue_ref *reply)
+{
+	jobject_put(*reply, J_CSTR_TO_JVAL("ssid"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("macAddress"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("Power off"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("amac"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("hi_op"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("ipAddress"), jstring_create("N/A"));
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("version"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("ccode"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("ccodeRev"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("channel"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("MCS"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("MIMO"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("rate"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("RSSI"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("noise"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("txpwr"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("NSS"), jstring_create("N/A"));
+	jobject_put(*reply, J_CSTR_TO_JVAL("BW"), jstring_create("N/A"));
+
+	if (technology->diagnostic_info)
+	{
+		gchar **split_str = g_strsplit(g_strstrip(technology->diagnostic_info),
+		                               "\n\t\t", 13);
+
+		if(split_str)
+		{
+			int i;
+			int diagnostic_len = g_strv_length(split_str);
+
+			for (i = 1; i < diagnostic_len; i++)
+			{
+				if (i == 1)
+				{
+					add_diagnostic_info_field(reply, split_str[1], "version");
+				}
+				else if (i == 2)
+				{
+					add_diagnostic_info_field(reply, split_str[2], "ccode");
+				}
+				else if (i == 3)
+				{
+					add_diagnostic_info_field(reply, split_str[3], "ccodeRev");
+				}
+				else if (i == 4)
+				{
+					add_diagnostic_info_field(reply, split_str[4], "channel");
+				}
+				else if (i == 5)
+				{
+					add_diagnostic_info_field(reply, split_str[5], "MCS");
+				}
+				else if (i == 6)
+				{
+					add_diagnostic_info_field(reply, split_str[6], "MIMO");
+				}
+				else if (i == 7)
+				{
+					add_diagnostic_info_field(reply, split_str[7], "rate");
+				}
+				else if (i == 8)
+				{
+					add_diagnostic_info_field(reply, split_str[8], "RSSI");
+				}
+				else if (i == 9)
+				{
+					add_diagnostic_info_field(reply, split_str[9], "noise");
+				}
+				else if (i == 10)
+				{
+					add_diagnostic_info_field(reply, split_str[10], "txpwr");
+				}
+				else if (i == 11)
+				{
+					add_diagnostic_info_field(reply, split_str[11], "NSS");
+				}
+				else if(i == 12)
+				{
+					add_diagnostic_info_field(reply, split_str[12], "BW");
+				}
+			}
+
+			g_strfreev(split_str);
+		}
+	}
+	else
+	{
+		connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
+		        manager);
+		connman_technology_interface_t interface_properties;
+
+		if (connman_technology_get_interface_properties(wifi_technology,
+		        CONNMAN_WIFI_INTERFACE_NAME, &interface_properties) == TRUE)
+		{
+			gchar *rssi = g_strdup_printf("%ddbm", interface_properties.rssi);
+			jobject_put(*reply, J_CSTR_TO_JVAL("RSSI"), jstring_create(rssi));
+			g_free(rssi);
+
+			jobject_put(*reply, J_CSTR_TO_JVAL("linkSpeed"),
+			            jnumber_create_i32(interface_properties.link_speed));
+
+			if (interface_properties.link_speed < 6 ||
+			        interface_properties.link_speed == 11)
+			{
+				jobject_put(*reply, J_CSTR_TO_JVAL("txpwr"), jstring_create("17 dBm"));
+			}
+			else
+			{
+				jobject_put(*reply, J_CSTR_TO_JVAL("txpwr"), jstring_create("14 dBm"));
+			}
+
+			int ch = convert_frequency_to_channel(interface_properties.frequency);
+
+			if (ch > 0)
+			{
+				gchar *channel =  g_strdup_printf("%d", ch);
+				jobject_put(*reply, J_CSTR_TO_JVAL("channel"), jstring_create(channel));
+				g_free(channel);
+			}
+		}
+	}
+
+	if (is_wifi_powered())
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("Power on"));
+	}
+
+	gchar wifi_mac_address[MAC_ADDR_STRING_LEN];
+
+	if (retrieve_wifi_mac_address(wifi_mac_address, MAC_ADDR_STRING_LEN))
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("macAddress"),
+		            jstring_create(wifi_mac_address));
+	}
+
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+	        manager->wifi_services);
+
+	if (connected_service != NULL)
+	{
+		if (connected_service->name != NULL)
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("ssid"),
+			            jstring_create(connected_service->name));
+		}
+
+		int wifi_state = connman_service_get_state(connected_service->state);
+
+		if (wifi_state == CONNMAN_SERVICE_STATE_ONLINE ||
+		        wifi_state == CONNMAN_SERVICE_STATE_READY)
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("CONNECTED"));
+
+			if (connected_service->ipinfo.ipv4.address)
+			{
+				jobject_put(*reply, J_CSTR_TO_JVAL("ipAddress"),
+				            jstring_create(connected_service->ipinfo.ipv4.address));
+			}
+		}
+		else if (wifi_state == CONNMAN_SERVICE_STATE_ASSOCIATION ||
+		         wifi_state == CONNMAN_SERVICE_STATE_CONFIGURATION)
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("CONNECTING"));
+		}
+
+		if (connected_service->hidden)
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("hi_op"), jstring_create("Hidden"));
+		}
+		else
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("hi_op"), jstring_create("Open"));
+		}
+
+		if (connected_service->address != NULL)
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("amac"),
+			            jstring_create(connected_service->address));
+		}
+
+	}
+
+	return TRUE;
+}
+
+
+static void send_wifi_diagnostics_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
+	        manager);
+
+	if (make_wifi_diagnostics_payload(wifi_technology, &reply) == TRUE)
+	{
+		jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+		                              DOMOPT_NOOPT, NULL);
+
+		if (response_schema)
+		{
+			const char *payload = jvalue_tostring(reply, response_schema);
+			LSError lserror;
+			LSErrorInit(&lserror);
+
+			if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_GET_WIFI_DIAGNOSTICS,
+                                                 payload,
+			                         &lserror))
+			{
+				LSErrorPrint(&lserror, stderr);
+				LSErrorFree(&lserror);
+			}
+
+			jschema_release(&response_schema);
+		}
+	}
+
+	j_release(&reply);
+}
+
+static gboolean signal_polling_cb(gpointer user_data)
+{
+	connman_service_t *connected_service = connman_manager_get_connected_service(
+	        manager->wifi_services);
+
+	if (!is_wifi_powered() || NULL == connected_service)
+	{
+		g_source_remove(signal_polling_timeout_source);
+		signal_polling_timeout_source = 0;
+
+		return FALSE;
+	}
+
+	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
+	        manager);
+	connman_technology_interface_t interface_properties;
+
+	if (connman_technology_get_interface_properties(wifi_technology,
+	        CONNMAN_WIFI_INTERFACE_NAME, &interface_properties) == TRUE)
+	{
+
+		guchar old_strength = connected_service->strength;
+		connected_service->strength = interface_properties.rssi + 120;
+
+		if (old_strength != connected_service->strength)
+		{
+			send_wifi_diagnostics_to_subscribers();
+		}
+
+		if (signal_strength_to_bars(old_strength) != signal_strength_to_bars(
+		            connected_service->strength))
+		{
+			wifi_send_status_to_subscribers();
+			send_findnetworks_status_to_subscribers();
+			send_getnetworks_status_to_subscribers();
+		}
+	}
+
+	return TRUE;
+}
+
+static void start_signal_polling()
+{
+	// start signal polling only if there are subscribers for "getwifidiagnositcs" and
+	// the wifi technology interface doesn't support diagnostic info
+	if ((LSSubscriptionGetHandleSubscribersCount(pLsHandle,
+	        LUNA_CATEGORY_ROOT LUNA_METHOD_GET_WIFI_DIAGNOSTICS) == 0)
+	        && (LSSubscriptionGetHandleSubscribersCount(pLsHandle,
+	                LUNA_CATEGORY_ROOT LUNA_METHOD_GET_WIFI_DIAGNOSTICS) == 0))
+	{
+		return;
+	}
+
+	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
+	        manager);
+
+	if (!wifi_technology->diagnostic_info && 0 == signal_polling_timeout_source)
+	{
+		signal_polling_timeout_source = g_timeout_add_seconds(3, signal_polling_cb,
+		                                NULL);
+	}
+}
+
+static void stop_signal_polling()
+{
+	if (0 < signal_polling_timeout_source)
+	{
+		g_source_remove(signal_polling_timeout_source);
+		signal_polling_timeout_source = 0;
+	}
+}
+
+
+/**
+ *  @brief Callback function registered with connman technology whenever any of its properties change
+ *
+ *
+ *  @param data
+ *  @param property
+ *  @param value
+ */
+
+static void technology_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	connman_technology_t *technology = (connman_technology_t *)data;
+
+	if (NULL == technology)
+	{
+		return;
+	}
+
+	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
+	        manager);
+
+	/* Need to send getstatus method to all its subscribers whenever the "powered" state for
+	   WiFi technology changes and "powered" / "connected" state for ethernet technology changes */
+	if (technology == wifi_technology)
+	{
+		if (!g_strcmp0(property, "Powered") || !g_strcmp0(property, "Connected"))
+		{
+			wifi_send_status_to_subscribers();
+
+			if (wifi_technology->powered)
+			{
+				wifi_scan_start(technology);
+			}
+			else
+			{
+				wifi_scan_stop();
+			}
+
+			if (wifi_technology->connected)
+			{
+				start_signal_polling();
+			}
+			else
+			{
+				stop_signal_polling();
+			}
+
+			/** Force update to get new Diagnostic Info and send to subscribers */
+			connman_technology_update_properties(technology);
+
+		}
+
+		if (g_strcmp0(property, "Tethering") == 0 ||
+		    g_strcmp0(property, "TetheringIdentifier") == 0 ||
+		    g_strcmp0(property, "TetheringPassphrase") == 0)
+		{
+			send_tethering_state_to_subscribers();
+			connectionmanager_send_status_to_subscribers();
+			wifi_send_status_to_subscribers();
+		}
+
+		if(g_strcmp0(property, "StaCount") == 0) {
+			send_sta_count_to_subscribers();
+		}
+
+		if (!g_strcmp0(property, "DiagnosticInfo"))
+		{
+			send_wifi_diagnostics_to_subscribers();
+		}
+	}
+	else if (technology == connman_manager_find_ethernet_technology(manager))
+	{
+		if (!g_strcmp0(property, "Powered") || !g_strcmp0(property, "Connected"))
+		{
+			connectionmanager_send_status_to_subscribers();
+		}
+	}
+}
+
+static void support_configure_country_code_cb(bool success, void *user_data)
+{
+	if (success)
+	{
+		WCALOG_INFO(MSGID_COUNTRY_CODE_INFO, 0, "Success in setting country code");
+	}
+	else
+	{
+		WCALOG_ERROR(MSGID_COUNTRY_CODE_FAILED, 0, "Failed to set country code");
+	}
+}
+
+static void check_and_initialize_ethernet_technology(void)
+{
+
+	connman_technology_t *technology = connman_manager_find_ethernet_technology(
+			manager);
+
+	if (technology)
+	{
+		connman_technology_register_property_changed_cb(technology,
+		                                                technology_property_changed_callback);
+	}
+}
+
+static void check_and_initialize_wifi_technology(void)
+{
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	/** TODO: this needs to be done only when wifi technology is changed:
+	 * The method is called whenever technology list changes.
+	 * */
+
+	if (technology)
+	{
+		connman_technology_register_property_changed_cb(technology,
+		        technology_property_changed_callback);
+
+		if (technology->powered)
+		{
+			wifi_scan_start(technology);
+		}
+		else
+		{
+			wifi_scan_stop();
+		}
+	}
+	else
+	{
+		/* Technology removed */
+		wifi_scan_stop();
+	}
+
+	send_getinfo_to_subscribers();
+}
+
+/* Most likely this callback will be called when wifi dongle is added/removed */
+static void manager_technologies_changed_callback(gpointer data)
+{
+	check_and_initialize_wifi_technology();
+	check_and_initialize_cellular_technology();
+	check_and_initialize_bluetooth_technology();
+	check_and_initialize_ethernet_technology();
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_setstate setstate
+
+Enable or Disable WIFI support
+
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+state | Yes | String | "enabled" or "disabled" to control WIFI accordingly
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(state, string)) REQUIRED_1(state))),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref stateObj = {0};
+	gboolean enable_wifi = FALSE;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("state"), &stateObj))
+	{
+		if (jstring_equal2(stateObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_wifi = TRUE;
+		}
+		else if (jstring_equal2(stateObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_wifi = FALSE;
+
+		}
+		else
+		{
+			goto invalid_params;
+		}
+	}
+	else
+	{
+		goto invalid_params;
+	}
+
+	/*
+	 *  Check if we are enabling an already enabled service,
+	 *  or disabling an already disabled service
+	 */
+
+	if (enable_wifi && is_wifi_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "Already Enabled",
+		                          WCA_API_ERROR_ALREADY_ENABLED);
+		goto cleanup;
+	}
+	else if (!enable_wifi && !is_wifi_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "Already Disabled",
+		                          WCA_API_ERROR_ALREADY_DISABLED);
+		goto cleanup;
+	}
+
+	set_wifi_powered_state(enable_wifi);
+
+	LSMessageReplySuccess(sh, message);
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_connect connect
+
+@par To Connect to open, hidden or secure networks
+
+Connects to the given ssid , which can be an open network (requiring
+no passphrase i.e no 'security' field in its argument), hidden
+(requiring 'wasCreatedWithJoinOther' field set to true in its argument),
+or secure networks (authenticating with provided passphrase).
+
+Note: webos-connman-adapter only supports simple security using psk,
+it doesn't support "enterprise" security.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | SSID of desired network
+wasCreatedWithJoinOther | Yes | String | Set True for a hidden network
+security | Only for secure networks | Object | Security information for establishing a connection
+
+@par "security" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+securityType | Yes | String | Connection type, e.g. wpa-personal, wep, or psk
+simpleSecurity | Yes | Object | Connection information for a simple connection
+
+@par "simpleSecurity" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+passKey | Yes | String | Passkey for connection to network
+
+@par To connect to wps enabled networks:
+
+Connects to the given ssid with wps setup, for WPS-PBC mode or WPS-PIN mode with
+pin to be entered at AP, you just need to set the "wps" field set to true, for
+WPS-PIN mode where pin needs to be entered on the device, you need to also enter
+the "wpspin" value
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | SSID of desired network
+security | Yes | Object | Security information for establishing a connection
+
+@par "security" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+wps | Yes | Boolean | true to enable wps mode
+wpspin | No | String | WPS PIN if using WPS-PIN mode
+
+@par To connect to a known profile
+
+Connects to an AP using its profileId which is listed in 'getprofilelist' method.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+profileId | Yes | Integer | Name of desired profile
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+static bool handle_connect_command(LSHandle *sh, LSMessage *message,
+                                   void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_wifi_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "WiFi switched off",
+		                          WCA_API_ERROR_WIFI_SWITCHED_OFF);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(ssid, string),
+	                                     PROP(profileId, integer), PROP(wasCreatedWithJoinOther, boolean),
+	                                     PROP(storeProfile, boolean),
+	                                     OBJECT(security, OBJSCHEMA_4(PROP(securityType, string), OBJECT(simpleSecurity,
+	                                             OBJSCHEMA_1(PROP(passKey, string))),
+	                                             PROP(wps, boolean), PROP(wpsPin, string)))))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0};
+	jvalue_ref profileIdObj = {0};
+	char *ssid;
+	wifi_profile_t *profile = NULL;
+	luna_service_request_t *service_req;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+	}
+	else if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("profileId"),
+	                            &profileIdObj))
+	{
+		int profile_id = 0;
+		jnumber_get_i32(profileIdObj, &profile_id);
+		profile = get_profile_by_id(profile_id);
+
+		if (NULL == profile)
+		{
+			LSMessageReplyCustomError(sh, message, "Profile not found",
+			                          WCA_API_ERROR_PROFILE_NOT_FOUND);
+			goto cleanup;
+		}
+
+		ssid = g_strdup(profile->ssid);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	service_req = luna_service_request_new(sh, message);
+
+	connect_wifi_with_ssid(ssid, profile, parsedObj, service_req);
+
+	g_free(ssid);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_cancel
+
+Cancel an currently ongoing connection attempt.
+
+Callers can cancel and previously initiated connection attempt with calling this method. Internally
+the wifi service will figure out the currently connecting service and cancel the attempt.
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_cancel_command(LSHandle *handle, LSMessage *message,
+                                  void *user_data)
+{
+	connman_service_t *connecting_service;
+
+	if (!connman_status_check(manager, handle, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(handle, message))
+	{
+		return true;
+	}
+
+	connecting_service = connman_manager_get_connecting_service(
+	                         manager->wifi_services);
+
+	if (!connecting_service)
+	{
+		LSMessageReplyCustomError(handle, message, "No service is connecting currently",
+		                          WCA_API_ERROR_NO_SERVICE_CONNECTING);
+		return true;
+	}
+
+	if (!connman_service_disconnect(connecting_service))
+	{
+		LSMessageReplyCustomError(handle, message,
+		                          "Failed to disconnect currently connecting service",
+		                          WCA_API_ERROR_DISCONNECT_FAILED);
+		return true;
+	}
+
+	LSMessageReplySuccess(handle, message);
+
+	return true;
+}
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_findnetworks
+
+List all available wifi access points found in the area.
+
+Callers can subscribe to this method to be notified of any changes. If a
+caller subscribes to further results he has to unsubscribe once it doesn't
+need fresh results any more. Once more than one client is subscribed a
+scan for available wifi networks is scheduled every 30 seconds until no
+client is subscribed anymore.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subcribe to changes
+interval | No | Number | Number of seconds to use as scan interval
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+foundNetworks | Yes | Array of Objects | List of networkInfo objects
+
+@par "networkInfo" Object
+
+Each entry in the "foundNetworks" array is of the form "networkInfo":{...}
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | SSID of discovered AP
+availableSecurityTypes | Yes | Array of String | List of supported security mechanisms
+signalBars | Yes | Integer | Coarse indication of signal strength
+signalLevel | Yes | Integer | Fine indication of signal strength
+
+@par Returns(Subscription)
+
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_findnetworks_command(LSHandle *sh, LSMessage *message,
+                                        void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(subscribe, boolean), PROP(interval,
+	                                     number)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	jvalue_ref intervalObj = 0;
+	bool subscribed = false;
+	gint interval = findnetworks_default_scan_interval;
+	gboolean result;
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!is_wifi_powered())
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message, "WiFi switched off",
+		        WCA_API_ERROR_WIFI_SWITCHED_OFF, subscribed);
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interval"), &intervalObj))
+	{
+		jnumber_get_i32(intervalObj, &interval);
+
+		if (interval <= 0)
+		{
+			LSMessageReplyErrorInvalidParams(sh, message);
+			goto cleanup;
+		}
+
+		/**If not subscribed, set default interval value. */
+		if (!subscribed)
+		{
+			findnetworks_default_scan_interval = interval;
+		}
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (NULL == wifi_tech)
+	{
+		LSMessageReplyCustomError(sh, message, "WiFi technology unavailable",
+		                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
+		goto cleanup;
+	}
+
+	if (subscribed)
+	{
+		result = wifi_scan_add_interval(LSMessageGetUniqueToken(message),
+		                                (guint) interval);
+	}
+	else
+	{
+		result = wifi_scan_now();
+	}
+
+	if (!result)
+	{
+		LSMessageReplyCustomError(sh, message, "Error in scanning network",
+		                          WCA_API_ERROR_SCANNING);
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	populate_wifi_networks(&reply, FALSE);
+
+	LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()), &lserror);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+static bool handle_scan_command(LSHandle *sh, LSMessage *message,
+                                void *user_data)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_wifi_powered())
+	{
+		LSMessageReplyCustomError(sh, message, "WiFi switched off",
+		                          WCA_API_ERROR_WIFI_SWITCHED_OFF);
+		return true;
+	}
+
+	if (!wifi_scan_now())
+	{
+		LSMessageReplyCustomError(sh, message, "Error in scanning network",
+		                          WCA_API_ERROR_SCANNING);
+		return true;
+	}
+
+	LSMessageReplySuccess(sh, message);
+	return true;
+}
+
+static bool handle_get_networks_command(LSHandle *sh, LSMessage *message,
+                                        void *user_data)
+{
+	jvalue_ref replyObj = 0;
+	bool subscribed = false;
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	replyObj = jobject_create();
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!is_wifi_powered())
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message, "WiFi switched off",
+		        WCA_API_ERROR_WIFI_SWITCHED_OFF, subscribed);
+		goto cleanup;
+	}
+
+	jobject_put(replyObj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(replyObj, J_CSTR_TO_JVAL("subscribed"),
+	            jboolean_create(subscribed));
+
+	populate_wifi_networks(&replyObj, TRUE);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(replyObj, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	if (replyObj)
+	{
+		j_release(&replyObj);
+	}
+
+	return true;
+}
+
+static bool handle_change_network_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(profileId, integer), PROP(passKey,
+	                                     string)) REQUIRED_2(profileId, passKey))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0}, passKeyObj = {0};
+	int profile_id = 0;
+	gchar *passKey = NULL;
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("profileId"), &profileIdObj))
+	{
+		jnumber_get_i32(profileIdObj, &profile_id);
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("passKey"), &passKeyObj))
+	{
+		raw_buffer passKey_buf = jstring_get(passKeyObj);
+		passKey = g_strdup(passKey_buf.m_str);
+		jstring_free_buffer(passKey_buf);
+	}
+
+	wifi_profile_t *profile = get_profile_by_id(profile_id);
+
+	if (NULL == profile)
+	{
+		LSMessageReplyCustomError(sh, message, "Profile not found",
+		                          WCA_API_ERROR_PROFILE_NOT_FOUND);
+		goto cleanup;
+	}
+
+	if (!is_valid_wifi_passphrase(passKey, profile->security[0]))
+	{
+		LSMessageReplyCustomError(sh, message,
+		                          "Passphrase doesn't match the requirements",
+		                          WCA_API_ERROR_WIFI_PASSPHRASE_INVALID);
+		goto cleanup;
+	}
+
+	if (profile->configured)
+	{
+		// for out of range configured but not provisioned networks
+		change_network_passphrase(profile->ssid, profile->security[0], passKey);
+	}
+	else
+	{
+		GSList *ap = NULL;
+
+		for (ap = manager->saved_services; NULL != ap ; ap = ap->next)
+		{
+			connman_service_t *service = (connman_service_t *)(ap->data);
+
+			if (g_strcmp0(service->name, profile->ssid) ||
+			        check_service_security(service, profile->security))
+			{
+				continue;
+			}
+
+			gboolean ret = FALSE;
+
+			if (service->type == CONNMAN_SERVICE_TYPE_WIFI &&
+			        NULL == connman_manager_find_service_by_path(manager->wifi_services,
+			                service->path))
+			{
+				// for out of range but not provisioned by a .config file networks
+				ret = connman_manager_change_saved_passphrase(manager, service, passKey);
+			}
+			else
+			{
+				// for currently available but not provisioned by a .config networks
+				ret = connman_service_set_passphrase(service, passKey);
+			}
+
+			if (!ret)
+			{
+				LSMessageReplyErrorUnknown(sh, message);
+				goto cleanup;
+			}
+
+			goto out;
+
+		}
+	}
+
+out:
+	LSMessageReplySuccess(sh, message);
+
+cleanup:
+	g_free(passKey);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_getstatus getstatus
+
+Gets the current status of wifi connection on the system.
+
+Callers can subscribe to this method to be notified of any changes
+in the wifi connection status.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subscribe to this method
+
+@par Returns(Call)
+
+All optional fields are absent if WIFI is not connected
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+wakeOnWlan | No | String | provided for backwards compatibility and always set to "disabled"
+status | No | String | Set to "connectedStateChanged" for backwards compatibility
+networkInfo | No | Object | A single object describing the current connection
+
+@par "networkInfo" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | SSID of AP
+connectState | Yes | String | One of {notAssociated, associating, associated, ipConfigured, ipFailed}
+signalBars | Yes | Integer | Coarse indication of signal strength (1..3)
+signalLevel | Yes | Integer | Absolute indication of signal strength
+ipInfo | Yes | Object | See below
+
+@par "ipInfo" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+interface | Yes | String |
+ip | Yes | String | IP Address
+subnet | Yes | String | Subnet mask value
+gateway | Yes | String |IP Address of network gateway
+dns | Yes | Array of String | List of DNS server IP addresses
+
+@par Returns(Subscription)
+
+As for a successful call
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_status_command(LSHandle *sh, LSMessage *message,
+                                      void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	create_wifi_getstatus_response(&reply, subscribed);
+
+	LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()),
+	                    &lserror);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+static void add_wifi_profile(jvalue_ref *profile_j, wifi_profile_t *profile)
+{
+	jvalue_ref profile_details_j = jobject_create();
+	jobject_put(profile_details_j, J_CSTR_TO_JVAL("ssid"),
+	            jstring_create(profile->ssid));
+	jobject_put(profile_details_j, J_CSTR_TO_JVAL("profileId"),
+	            jnumber_create_i32(profile->profile_id));
+
+	if (profile->hidden)
+	{
+		jobject_put(profile_details_j, J_CSTR_TO_JVAL("wasCreatedWithJoinOther"),
+		            jboolean_create(profile->hidden));
+	}
+
+	if (profile->security != NULL)
+	{
+		jvalue_ref security = jobject_create();
+		jvalue_ref security_list = jarray_create(NULL);
+		int i;
+
+		for (i = 0; i < g_strv_length(profile->security); i++)
+		{
+			jarray_append(security_list, jstring_create(profile->security[i]));
+		}
+
+		jobject_put(security, J_CSTR_TO_JVAL("securityType"), security_list);
+		jobject_put(profile_details_j, J_CSTR_TO_JVAL("security"), security);
+	}
+
+	jobject_put(*profile_j, J_CSTR_TO_JVAL("wifiProfile"), profile_details_j);
+}
+
+static void add_wifi_profile_list(jvalue_ref *reply)
+{
+	if (profile_list_is_empty())
+	{
+		return;
+	}
+
+	jvalue_ref profile_list_j = jarray_create(NULL);
+
+	wifi_profile_t *profile = NULL;
+
+	while (NULL != (profile = get_next_profile(profile)))
+	{
+		jvalue_ref profile_j = jobject_create();
+		add_wifi_profile(&profile_j, profile);
+		jarray_append(profile_list_j, profile_j);
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("profileList"), profile_list_j);
+}
+
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_getprofilelist getprofilelist
+
+Lists all the stored wifi profiles on the system.
+
+@Note If the wifi AP is an open network with no security, it
+      won't list the "security" field.
+
+@par Parameters
+
+None
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+profileList | yes | Array of Object | Array of wifiProfile objects
+
+@par "wifiProfile" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | yes | String | SSID associated with the profile
+profileId | yes | String | ID string naming the profile (can be used with connect method)
+security | no | Object | Contains a "securityType" object, which is an Array of String
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_profilelist_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (profile_list_is_empty())
+	{
+		LSMessageReplyCustomError(sh, message, "Profile not found",
+		                          WCA_API_ERROR_PROFILE_NOT_FOUND);
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	add_wifi_profile_list(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_getprofile getprofile
+
+Lists the profile with the given profile ID on the system.
+
+@Note As in getprofilelist, even here the open networks won't list
+      the "security" field.
+
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+profileId | yes | Integer | Name of profile required
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+wifiProfile | yes | Object | A "wifiProfile" object as described for the getprofilelist method
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_profile_command(LSHandle *sh, LSMessage *message,
+                                       void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(profileId,
+	                                     integer)) REQUIRED_1(profileId))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	jvalue_ref reply = jobject_create();
+	int profile_id = 0;
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("profileId"), &profileIdObj))
+	{
+		jnumber_get_i32(profileIdObj, &profile_id);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	wifi_profile_t *profile = get_profile_by_id(profile_id);
+
+	if (NULL == profile)
+	{
+		LSMessageReplyCustomError(sh, message, "Profile not found",
+		                          WCA_API_ERROR_PROFILE_NOT_FOUND);
+		goto cleanup;
+	}
+	else
+	{
+		jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+		add_wifi_profile(&reply, profile);
+	}
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_deleteprofile deleteprofile
+
+Deletes the profile with the given profile ID
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+profileId | Yes | Integer | Name of profile to be deleted
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_delete_profile_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(profileId,
+	                                     integer)) REQUIRED_1(profileId))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	int profile_id = 0;
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("profileId"), &profileIdObj))
+	{
+		jnumber_get_i32(profileIdObj, &profile_id);
+	}
+	else
+	{
+
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	wifi_profile_t *profile = get_profile_by_id(profile_id);
+
+	if (NULL == profile)
+	{
+		LSMessageReplyCustomError(sh, message, "Profile not found",
+		                          WCA_API_ERROR_PROFILE_NOT_FOUND);
+		goto cleanup;
+	}
+	else
+	{
+		remove_service_or_all_other(profile->ssid, FALSE);
+		delete_profile(profile);
+		LSMessageReplySuccess(sh, message);
+	}
+
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+
+gint generate_new_wpspin(void)
+{
+	FILE *f = fopen("/dev/urandom", "rb");
+
+	if (f == NULL)
+	{
+		return -1;
+	}
+
+	//Generate 7 random digits
+	gint pin = 0;
+	int count = 0;
+
+	do
+	{
+		count = fread(&pin, sizeof(pin), 1, f);
+	}
+	while(count == -1 || pin < 0);
+
+	pin %= 10000000;
+	pin *= 10;
+
+	fclose(f);
+
+	// Append checksum digit in the end
+
+	unsigned int tmppin =  pin / 10;
+	unsigned int accum = 0;
+
+	while (tmppin)
+	{
+		accum += 3 * (tmppin % 10);
+		tmppin /= 10;
+		accum += tmppin % 10;
+		tmppin /= 10;
+	}
+
+	pin += ((10 - accum % 10) % 10);
+
+	return pin;
+}
+
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_createwpspin createwpspin
+
+Generates an 8 digit random wps pin
+
+@par Parameters
+
+None
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | yes | Boolean | True
+wpspin | yes | String | 8 digit random wps pin number
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_create_wpspin_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	gint wpspin = generate_new_wpspin();
+
+	if (wpspin < 0)
+	{
+		goto error;
+	}
+
+	char wpspin_str[9];
+	snprintf(wpspin_str, 9, "%08i", wpspin);
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("wpspin"), jstring_create(wpspin_str));
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+	goto cleanup;
+error:
+	LSMessageReplyCustomError(sh, message, "Error in generating wps pin",
+	                          WCA_API_ERROR_WPS_PIN);
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi/p2p
+@{
+@section com_webos_wifi_startwps startwps
+
+Start WPS authentication process. If no wpsPin argument is supplied
+the WPS-PBC method will be used, else it will be WPS-PIN method.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+wpsPin | No | String | Pin for WPS-PIN mode
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_start_wps_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(wpsPin, string)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref wpsPinObj = NULL;
+	char *wpspin = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wpsPin"), &wpsPinObj))
+	{
+		raw_buffer address_buf = jstring_get(wpsPinObj);
+		wpspin = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		wpspin = g_strdup("");
+	}
+
+	if (!connman_technology_start_wps(connman_manager_find_wifi_technology(manager),
+	                                  wpspin))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(wpspin);
+	j_release(&parsedObj);
+	return true;
+}
+
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_cancelwps cancelwps
+
+Cancel any ongoing WPS connection.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+None
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_cancel_wps_command(LSHandle *sh, LSMessage *message,
+                                      void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+
+	if (!connman_technology_cancel_wps(technology))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in cancelling WPS connection",
+		                          WCA_API_ERROR_CANCEL_WPS);
+		return true;
+	}
+
+	LSMessageReplySuccess(sh, message);
+	return true;
+}
+
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_setmultichannelschedmode setmultichannelschedmode
+
+Set the multi channel scheduling mode for wifi technology
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+mode | Yes | Integer | 0 for fair, 1 for sta, 2 for p2p
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_multichannel_sched_mode_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(mode, integer)) REQUIRED_1(mode))),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref modeObj = NULL;
+	gint32 mode = 0;
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("mode"), &modeObj))
+	{
+		jnumber_get_i32(modeObj, &mode);
+
+		if (mode != technology->multi_channel_mode &&
+		        !connman_technology_set_multi_channel_mode(technology, mode))
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Error in changing multi channel sched mode",
+			                          WCA_API_ERROR_MULTI_CHAN_SCHED_MODE);
+			goto cleanup;
+		}
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_getmultichannelschedmode getmultichannelschedmode
+
+Get the multi channel scheduling mode for wifi technology
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+None
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+mode | Yes | Integer | 0 for fair, 1 for sta, 2 for p2p
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_multichannel_sched_mode_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("mode"),
+	            jnumber_create_i32(technology->multi_channel_mode));
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_getwifidiagnostics getwifidiagnostics
+
+Get the wifi diagnostic information from the driver.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+None
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+version | Yes | String | Version info
+ccode | Yes | String | Country code
+ccodeRev | Yes | String | Country code revision
+channel | Yes | String | Channel
+MCS | Yes | String | MCS
+MIMO | Yes | String | MIMO
+rate | Yes | String | Rate
+RSSI | Yes | String | RSSI
+noise | Yes | String | Noise level
+txpwr | Yes | String | Txpwr
+
+@par Returns(Subscription)
+
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_wifi_diagnostics_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	bool subscribed = false;
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!is_wifi_powered())
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message, "WiFi switched off",
+		        WCA_API_ERROR_WIFI_SWITCHED_OFF, subscribed);
+		goto cleanup;
+	}
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	connman_technology_update_properties(technology);
+
+	make_wifi_diagnostics_payload(technology, &reply);
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+static void handle_luna_subscription_cancel(LSHandle *sh, LSMessage *message, void *ctx)
+{
+	const char *category = LSMessageGetCategory(message);
+	const char *method = LSMessageGetMethod(message);
+
+	// check for findnetworks
+	if (!g_strcmp0(category, LUNA_CATEGORY_ROOT) &&
+	    !g_strcmp0(method, LUNA_METHOD_FINDNETWORKS))
+	{
+		wifi_scan_remove_interval(LSMessageGetUniqueToken(message));
+	}
+}
+
+static void set_passthrough_params_cb(bool success, jvalue_ref params,
+                                      void *user_data)
+{
+	luna_service_request_t *service_req = (luna_service_request_t *) user_data;
+	LSHandle *sh = NULL;
+	LSMessage *message = NULL;
+
+	if (service_req)
+	{
+		sh = service_req->handle;
+		message = service_req->message;
+	}
+
+	if (success)
+	{
+		if (params)
+		{
+			jvalue_ref reply = jobject_create();
+			LSError lserror;
+			LSErrorInit(&lserror);
+			jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+			jobject_put(reply,  J_CSTR_TO_JVAL("params"), params);
+			jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+			                              DOMOPT_NOOPT, NULL);
+
+			if (response_schema)
+			{
+				if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+				                    &lserror))
+				{
+					LSErrorPrint(&lserror, stderr);
+					LSErrorFree(&lserror);
+				}
+
+				jschema_release(&response_schema);
+			}
+			else
+			{
+				LSMessageReplyErrorUnknown(sh, message);
+			}
+
+			if (LSErrorIsSet(&lserror))
+			{
+				LSErrorPrint(&lserror, stderr);
+				LSErrorFree(&lserror);
+			}
+
+			j_release(&reply);
+		}
+		else
+		{
+			LSMessageReplySuccess(sh, message);
+		}
+	}
+	else
+		LSMessageReplyCustomError(sh, message,
+		                          "Error in setting passthrough parameters",
+		                          WCA_API_ERROR_SET_PASSTHROUGH_PARAMS_FAILED);
+
+	if (service_req)
+	{
+		luna_service_request_free(service_req);
+	}
+}
+
+static bool handle_set_passthrough_params_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_ANY),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref paramsObj = {0};
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("params"), &paramsObj))
+	{
+		luna_service_request_t *service_req = luna_service_request_new(sh, message);
+
+		if (wca_support_wifi_set_passthrough_params(paramsObj,
+		        set_passthrough_params_cb, service_req))
+			LSMessageReplyCustomError(sh, message,
+			                          "Error in setting passthrough parameters",
+			                          WCA_API_ERROR_SET_PASSTHROUGH_PARAMS_FAILED);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+	}
+
+	j_release(&parsedObj);
+	return true;
+}
+
+static void agent_registered_callback(gpointer user_data)
+{
+	gchar *agent_path;
+
+	agent_path = connman_agent_get_path(agent);
+
+	if (!connman_manager_register_agent(manager, agent_path))
+	{
+		WCALOG_CRITICAL(MSGID_WIFI_AGENT_ERROR, 0,
+		                "Could not register our agent instance with connman; functionality will be limited!");
+	}
+}
+
+static void connman_service_stopped(GDBusConnection *conn, const gchar *name,
+                                    const gchar *name_owner, gpointer user_data)
+{
+	WCALOG_DEBUG("connman service disappeared from the bus");
+
+	/* if scan is still scheduled abort it */
+	wifi_scan_stop();
+
+	/* if signal_poll is still scheduled abort it */
+	if (signal_polling_timeout_source > 0)
+	{
+		stop_signal_polling();
+	}
+
+	if (agent != NULL)
+	{
+		connman_agent_free(agent);
+		agent = NULL;
+	}
+
+	if (manager != NULL)
+	{
+		connman_manager_free(manager);
+		manager = NULL;
+	}
+}
+
+static void connman_service_started(GDBusConnection *conn, const gchar *name,
+                                    const gchar *name_owner, gpointer user_data)
+{
+	WCALOG_DEBUG("connman service appeared on the bus");
+
+#ifndef ENABLE_SINGLE_PROFILE
+	sync_network_configs_with_profiles();
+
+	if (create_config_inotify_watch() == FALSE)
+	{
+		WCALOG_ERROR(MSGID_WIFI_CONFIG_INOTIFY_WATCH_ERR, 0,
+		             "Failed to set inotify watch for wifi config files");
+	}
+
+#endif
+
+	/* We just need one manager instance that stays throughout the lifetime
+	 * of this daemon. Only its technologies and services lists are updated
+	 * whenever the corresponding signals are received */
+	manager = connman_manager_new();
+
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	agent = connman_agent_new();
+
+	if (NULL == agent)
+	{
+		connman_manager_free(manager);
+		manager = NULL;
+		return;
+	}
+
+	connman_agent_set_registered_callback(agent, agent_registered_callback, NULL);
+
+	/* Register for manager's "PropertyChanged" and "ServicesChanged" signals for sending 'getstatus' and 'findnetworks'
+	   methods to their subscribers */
+	connman_manager_register_property_changed_cb(manager,
+	        manager_property_changed_callback);
+	connman_manager_register_services_changed_cb(manager,
+	        manager_services_changed_callback);
+	connman_manager_register_technologies_changed_cb(manager,
+	        manager_technologies_changed_callback);
+
+	check_and_initialize_wifi_technology();
+	check_and_initialize_ethernet_technology();
+	check_and_initialize_cellular_technology();
+	check_and_initialize_bluetooth_technology();
+
+	connectionmanager_send_status_to_subscribers();
+}
+
+/**
+ * @brief When the system UI locale has changed we need to adjust the displayed name of
+ * all wifi service objects.
+ */
+
+void wifi_service_local_has_changed()
+{
+	GSList *ap;
+
+	if (NULL == manager)
+	{
+		return;
+	}
+
+	for (ap = manager->wifi_services; NULL != ap ; ap = ap->next)
+	{
+		connman_service_t *service = (connman_service_t *)(ap->data);
+		connman_service_update_display_name(service);
+	}
+}
+
+/**
+ * com.webos.service.wifi service Luna Method Table
+ */
+
+static LSMethod wifi_methods[] =
+{
+	{ LUNA_METHOD_GETPROFILELIST,   handle_get_profilelist_command },
+	{ LUNA_METHOD_GETPROFILE,       handle_get_profile_command },
+	{ LUNA_METHOD_SETSTATE,     handle_set_state_command },
+	{ LUNA_METHOD_CONNECT,      handle_connect_command },
+	{ LUNA_METHOD_CANCEL,       handle_cancel_command },
+	{ LUNA_METHOD_FINDNETWORKS,     handle_findnetworks_command },
+	{ LUNA_METHOD_SCAN,         handle_scan_command },
+	{ LUNA_METHOD_GETNETWORKS,      handle_get_networks_command },
+	{ LUNA_METHOD_CHANGENETWORK,    handle_change_network_command },
+	{ LUNA_METHOD_DELETEPROFILE,    handle_delete_profile_command },
+	{ LUNA_METHOD_GETSTATUS,        handle_get_status_command },
+	{ LUNA_METHOD_CREATEWPSPIN,         handle_create_wpspin_command },
+	{ LUNA_METHOD_STARTWPS,     handle_start_wps_command },
+	{ LUNA_METHOD_CANCELWPS,        handle_cancel_wps_command },
+	{ LUNA_METHOD_SET_MCHANNSCHED_MODE, handle_set_multichannel_sched_mode_command },
+	{ LUNA_METHOD_GET_MCHANNSCHED_MODE, handle_get_multichannel_sched_mode_command },
+	{ LUNA_METHOD_GET_WIFI_DIAGNOSTICS, handle_get_wifi_diagnostics_command },
+	{ LUNA_METHOD_SET_PASSTHROUGH_PARAMS, handle_set_passthrough_params_command },
+	{ },
+};
+
+/**
+ *  @brief Initialize com.webos.service.wifi service and all of its methods
+ *  Also initialize a manager instance
+ */
+
+int initialize_wifi_ls2_calls(GMainLoop *mainloop , LSHandle **wifi_handle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+	pLsHandle       = NULL;
+
+	if (NULL == mainloop)
+	{
+		goto Exit;
+	}
+
+	if (LSRegister(WIFI_LUNA_SERVICE_NAME, &pLsHandle, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_WIFI_LUNA_BUS_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_ROOT, wifi_methods, NULL, NULL,
+	                       &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_WIFI_METHODS_LUNA_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	if (LSGmainAttach(pLsHandle, mainloop, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_WIFI_GLOOP_ATTACH_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	if (LSSubscriptionSetCancelFunction(pLsHandle, handle_luna_subscription_cancel, NULL, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_WIFI_SUBSCRIPTIONCANCEL_LUNA_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	g_type_init();
+
+	g_bus_watch_name(G_BUS_TYPE_SYSTEM, "net.connman",
+	                 G_BUS_NAME_WATCHER_FLAGS_NONE, connman_service_started, connman_service_stopped,
+	                 NULL, NULL);
+
+	retrieve_system_locale_info(pLsHandle);
+
+	init_wifi_profile_list();
+
+	*wifi_handle = pLsHandle;
+
+	return 0;
+
+Exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	if (pLsHandle)
+	{
+		LSErrorInit(&lserror);
+
+		if (LSUnregister(pLsHandle, &lserror) == false)
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	return -1;
+}
diff --git a/src/wifi_service.h b/src/wifi_service.h
new file mode 100644
index 0000000..ac23a90
--- /dev/null
+++ b/src/wifi_service.h
@@ -0,0 +1,85 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_service.h
+ *
+ */
+
+
+#ifndef _WIFI_SERVICE_H_
+#define _WIFI_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define WIFI_LUNA_SERVICE_NAME "com.webos.service.wifi"
+
+#define LUNA_CATEGORY_ROOT                  "/"
+
+/**
+ * @name Luna WiFi Method Names
+ * @{
+ */
+#define LUNA_METHOD_CONNECT                 "connect"
+#define LUNA_METHOD_CANCEL                  "cancel"
+#define LUNA_METHOD_FINDNETWORKS            "findnetworks"
+#define LUNA_METHOD_SCAN                    "scan"
+#define LUNA_METHOD_GETNETWORKS             "getNetworks"
+#define LUNA_METHOD_CHANGENETWORK           "changeNetwork"
+#define LUNA_METHOD_DELETEPROFILE           "deleteprofile"
+#define LUNA_METHOD_GETPROFILE              "getprofile"
+#define LUNA_METHOD_GETPROFILELIST          "getprofilelist"
+#define LUNA_METHOD_GETSTATUS               "getstatus"
+#define LUNA_METHOD_SETSTATE                "setstate"
+#define LUNA_METHOD_CREATEWPSPIN            "createwpspin"
+#define LUNA_METHOD_STARTWPS                "startwps"
+#define LUNA_METHOD_CANCELWPS               "cancelwps"
+#define LUNA_METHOD_SET_MCHANNSCHED_MODE    "setmultichannelschedmode"
+#define LUNA_METHOD_GET_MCHANNSCHED_MODE    "getmultichannelschedmode"
+#define LUNA_METHOD_GET_WIFI_DIAGNOSTICS    "getwifidiagnostics"
+#define LUNA_METHOD_SET_PASSTHROUGH_PARAMS  "setPassthroughParams"
+
+
+#define WIFI_ENTERPRISE_SECURITY_TYPE       "ieee8021x"
+
+typedef struct connection_settings
+{
+	char *passkey;
+	char *ssid;
+	bool wpsmode;
+	char *wpspin;
+	bool hidden;
+	bool store;
+	char *identity;
+	char *eap_type;
+	char *ca_cert_file;
+	char *client_cert_file;
+	char *private_key_file;
+	char *private_key_passphrase;
+	char *phase2;
+	char *passphrase;
+} connection_settings_t;
+
+extern int initialize_wifi_ls2_calls(GMainLoop *mainloop,
+                                     LSHandle **wifi_handle);
+extern connection_settings_t *connection_settings_new(void);
+extern GVariant *agent_request_input_callback(GVariant *fields, gpointer data);
+extern gint generate_new_wpspin(void);
+extern void wifi_service_local_has_changed();
+extern void send_getnetworks_status_to_subscribers();
+extern void send_findnetworks_status_to_subscribers();
+
+#endif /* _WIFI_SERVICE_H_ */
diff --git a/src/wifi_setting.c b/src/wifi_setting.c
new file mode 100644
index 0000000..cff6843
--- /dev/null
+++ b/src/wifi_setting.c
@@ -0,0 +1,1331 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_setting.c
+ *
+ * @brief Functions for storing/loading wifi settings & profiles from luna-prefs
+ *
+ */
+
+#include <glib.h>
+#include <glib/gstdio.h>
+#include <openssl/blowfish.h>
+#include <lunaprefs.h>
+#include <pbnjson.h>
+#include <sys/inotify.h>
+
+#include "wifi_setting.h"
+#include "wifi_profile.h"
+#include "connman_common.h"
+#include "logging.h"
+
+/**
+ * WiFi setting keys used to identify settings stored in luna-prefs database.
+ * THE SEQUENCE MUST MATCH THE VALUES OF WIFI SETTINGS DEFINED IN wifi_setting.h
+ */
+static const char *SettingKey[] =
+{
+	"Null-DO-NOT-USE", /**< Marker used to indicate the start of setting keys */
+
+	"profileList", /**< Setting key for profile list */
+
+	"Last-DO-NOT-USE" /**< Marker used to indicate the end of setting keys */
+};
+
+/**
+ * @brief Encrypt the given input using the supplied key
+ * The encrypt /decrypt functions are useful for storing wifi profiles
+ * which may contain secret passwords / passphrases
+ */
+
+static char *wifi_setting_encrypt(const char *input_str, const char *key)
+{
+	BF_KEY *pBfKey = g_new0(BF_KEY, 1);
+	gchar *b64str = NULL;
+	char *result = NULL;
+	long len;
+	char *output_str = NULL;
+	unsigned char ivec[8] = {0};
+	int num = 0;
+
+	if (pBfKey == NULL)
+	{
+		goto Exit;
+	}
+
+	if (!input_str || !key || !strlen(input_str) || !strlen(key))
+	{
+		goto Exit;
+	}
+
+	BF_set_key(pBfKey, strlen(key), (const unsigned char *)(key));
+
+	len = strlen(input_str);
+
+	output_str = g_new0(char, len + 1);
+
+	if (!output_str)
+	{
+		goto Exit;
+	}
+
+	memset(output_str, 0, len + 1);
+
+	BF_cfb64_encrypt((const unsigned char *)(input_str),
+	                 (unsigned char *)(output_str),
+	                 len, pBfKey, ivec, &num, BF_ENCRYPT);
+
+	b64str = g_base64_encode((const guchar *)(output_str), len);
+
+	if (b64str)
+	{
+		result = strdup(b64str);
+		g_free(b64str);
+	}
+
+Exit:
+	g_free(output_str);
+	g_free(pBfKey);
+	return result;
+}
+
+/**
+ * @brief Decrypt the given input using the supplied key
+ * The encrypt /decrypt functions are useful for storing wifi profiles
+ * which may contain secret passwords / passphrases
+ */
+
+
+static char *wifi_setting_decrypt(const char *input_str, const char *key)
+{
+	BF_KEY *pBfKey = g_new0(BF_KEY, 1);
+	char *result = NULL;
+	long len = 0;
+	guchar *b64str = NULL;
+	char *output_str = NULL;
+	unsigned char ivec[8] = {0};
+	int num = 0;
+
+	if (pBfKey == NULL)
+	{
+		goto Exit;
+	}
+
+	if (!input_str || !key || !strlen(input_str) || !strlen(key))
+	{
+		goto Exit;
+	}
+
+	BF_set_key(pBfKey, strlen(key), (const unsigned char *)key);
+
+
+	b64str = g_base64_decode((const gchar *)(input_str), (gsize *)(&len));
+
+	if (b64str)
+	{
+		output_str = g_new0(char, len + 1);
+
+		if (!output_str)
+		{
+			g_free(b64str);
+			goto Exit;
+		}
+
+		memset(output_str, 0, len + 1);
+
+		BF_cfb64_encrypt((const unsigned char *)(b64str), (unsigned char *)(output_str),
+		                 len, pBfKey, ivec, &num, BF_DECRYPT);
+
+		result = strdup(output_str);
+
+		g_free(output_str);
+		g_free(b64str);
+	}
+
+Exit:
+	g_free(pBfKey);
+	return result;
+}
+
+
+static gboolean populate_wifi_profile(jvalue_ref profileObj)
+{
+	gboolean ret = FALSE;
+	jvalue_ref wifiProfileObj, ssidObj, securityListObj, hiddenObj, configuredObj;
+
+	if (jobject_get_exists(profileObj, J_CSTR_TO_BUF("wifiProfile"),
+	                       &wifiProfileObj))
+	{
+		raw_buffer enc_profile_buf = jstring_get(wifiProfileObj);
+		gchar *enc_profile = g_strdup(enc_profile_buf.m_str);
+		jstring_free_buffer(enc_profile_buf);
+		gchar *dec_profile = wifi_setting_decrypt(enc_profile, WIFI_LUNA_PREFS_ID);
+
+		jvalue_ref parsedObj = {0};
+		jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT,
+		                           NULL);
+
+		if (!input_schema)
+		{
+			goto Exit;
+		}
+
+		JSchemaInfo schemaInfo;
+		jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+		parsedObj = jdom_parse(j_cstr_to_buffer(dec_profile), DOMOPT_NOOPT,
+		                       &schemaInfo);
+		jschema_release(&input_schema);
+
+		if (jis_null(parsedObj))
+		{
+			goto Exit;
+		}
+
+		gchar *ssid = NULL;
+		GStrv security = NULL;
+
+		if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+		{
+			raw_buffer ssid_buf = jstring_get(ssidObj);
+			ssid = g_strdup(ssid_buf.m_str);
+			jstring_free_buffer(ssid_buf);
+			ret = TRUE;
+		}
+		else
+		{
+			WCALOG_DEBUG("ssid object not found");
+		}
+
+		bool hidden = false;
+		bool configured = false;
+
+		if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("security"), &securityListObj))
+		{
+			ssize_t i, num_elems = jarray_size(securityListObj);
+			security = (GStrv) g_new0(GStrv, num_elems + 1);
+
+			for (i = 0; i < num_elems; i++)
+			{
+				jvalue_ref securityObj = jarray_get(securityListObj, i);
+				raw_buffer security_buf = jstring_get(securityObj);
+				security[i] = g_strdup(security_buf.m_str);
+				jstring_free_buffer(security_buf);
+			}
+
+			security[num_elems] = NULL;
+		}
+
+		if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wasCreatedWithJoinOther"),
+		                       &hiddenObj))
+		{
+			jboolean_get(hiddenObj, &hidden);
+		}
+
+		if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("configured"), &configuredObj))
+		{
+			jboolean_get(configuredObj, &configured);
+		}
+
+		// Converting bool to gboolean as create_new_profile expects gboolean
+		if ((security != NULL &&
+		        NULL == get_profile_by_ssid_security(ssid, security[0])) ||
+		        ((security == NULL && NULL == get_profile_by_ssid(ssid))))
+		{
+			create_new_profile(ssid, security, hidden ? TRUE : FALSE,
+			                   configured ? TRUE : FALSE);
+		}
+
+		g_strfreev(security);
+		g_free(ssid);
+Exit:
+		j_release(&parsedObj);
+		g_free(dec_profile);
+		g_free(enc_profile);
+	}
+
+	return ret;
+}
+
+/**
+ * @brief Get the values of given settings from luna-prefs
+ *
+ * The param data can be supplied for copying the values of settings
+ * (Not required for WIFI_PROFILELIST_SETTING since this function
+ * will update the wifi profile list itself
+ */
+
+gboolean load_wifi_setting(wifi_setting_type_t setting, void *data)
+{
+	LPErr lpErr = LP_ERR_NONE;
+	LPAppHandle handle;
+	char *setting_value = NULL;
+	gboolean ret = FALSE;
+
+	lpErr = LPAppGetHandle(WIFI_LUNA_PREFS_ID, &handle);
+
+	if (lpErr)
+	{
+		WCALOG_ERROR(MSGID_SETTING_LPAPP_GET_ERROR, 1, PMLOGKS("PrefsId",
+		             WIFI_LUNA_PREFS_ID), "");
+		goto Exit;
+	}
+
+	lpErr = LPAppCopyValue(handle, SettingKey[setting], &setting_value);
+	(void) LPAppFreeHandle(handle, false);
+
+	if (lpErr)
+	{
+		WCALOG_ERROR(MSGID_SETTING_LPAPP_COPY_ERROR, 1, PMLOGKS("Key",
+		             SettingKey[setting]), "");
+		goto Exit;
+	}
+
+
+	switch (setting)
+	{
+		case WIFI_PROFILELIST_SETTING:
+		{
+			jvalue_ref parsedObj = {0};
+			jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT,
+			                           NULL);
+
+			if (!input_schema)
+			{
+				goto Exit;
+			}
+
+			JSchemaInfo schemaInfo;
+			jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+			parsedObj = jdom_parse(j_cstr_to_buffer(setting_value), DOMOPT_NOOPT,
+			                       &schemaInfo);
+			jschema_release(&input_schema);
+
+			if (jis_null(parsedObj))
+			{
+				goto Exit;
+			}
+
+			jvalue_ref profileListObj = {0};
+
+			if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("profileList"),
+			                       &profileListObj))
+			{
+				if (!jis_array(profileListObj))
+				{
+					goto Exit_Case;
+				}
+
+				ssize_t i, num_elems = jarray_size(profileListObj);
+
+				for (i = 0; i < num_elems; i++)
+				{
+					jvalue_ref profileObj = jarray_get(profileListObj, i);
+
+					// Parse json strings to create profiles and append them to profile list
+					if (populate_wifi_profile(profileObj) == FALSE)
+					{
+						goto Exit_Case;
+					}
+				}
+
+				ret = TRUE;
+			}
+
+Exit_Case:
+			j_release(&parsedObj);
+		}
+
+		default:
+			break;
+	}
+
+Exit:
+	g_free(setting_value);
+	return ret;
+}
+
+static void add_wifi_profile(jvalue_ref *profile_j, wifi_profile_t *profile)
+{
+	jobject_put(*profile_j, J_CSTR_TO_JVAL("ssid"), jstring_create(profile->ssid));
+	jobject_put(*profile_j, J_CSTR_TO_JVAL("profileId"),
+	            jnumber_create_i32(profile->profile_id));
+
+	if (profile->hidden)
+	{
+		jobject_put(*profile_j, J_CSTR_TO_JVAL("wasCreatedWithJoinOther"),
+		            jboolean_create(profile->hidden));
+	}
+
+	if (profile->configured)
+	{
+		jobject_put(*profile_j, J_CSTR_TO_JVAL("configured"),
+		            jboolean_create(profile->configured));
+	}
+
+	if (profile->security != NULL)
+	{
+		jvalue_ref security_list = jarray_create(NULL);
+		gsize i;
+
+		for (i = 0; i < g_strv_length(profile->security); i++)
+		{
+			jarray_append(security_list, jstring_create(profile->security[i]));
+		}
+
+		jobject_put(*profile_j, J_CSTR_TO_JVAL("security"), security_list);
+	}
+}
+
+static gchar *add_wifi_profile_list(void)
+{
+	if (profile_list_is_empty())
+	{
+		return NULL;
+	}
+
+	gchar *profile_list_str = NULL;
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		jvalue_ref profilelist_j = jobject_create();
+		jvalue_ref profilelist_arr_j = jarray_create(NULL);
+
+		wifi_profile_t *profile = get_next_profile(NULL);
+
+		while (NULL != profile)
+		{
+			jvalue_ref profileinfo_j = jobject_create();
+			jvalue_ref profile_j = jobject_create();
+			add_wifi_profile(&profile_j, profile);
+			const gchar *profile_str = jvalue_tostring(profile_j, response_schema);
+			gchar *enc_profile_str = wifi_setting_encrypt(profile_str, WIFI_LUNA_PREFS_ID);
+			j_release(&profile_j);
+			jobject_put(profileinfo_j, J_CSTR_TO_JVAL("wifiProfile"),
+			            jstring_create(enc_profile_str));
+			jarray_append(profilelist_arr_j, profileinfo_j);
+			profile = get_next_profile(profile);
+			g_free(enc_profile_str);
+		}
+
+		jobject_put(profilelist_j, J_CSTR_TO_JVAL("profileList"), profilelist_arr_j);
+		profile_list_str = g_strdup(jvalue_tostring(profilelist_j, response_schema));
+		jschema_release(&response_schema);
+		j_release(&profilelist_j);
+	}
+
+	return profile_list_str;
+}
+
+/**
+ * @brief Set the values of given settings in luna-prefs
+ *
+ * The param data can be supplied for providing the values of settings
+ * (Not required for WIFI_PROFILELIST_SETTING since this function
+ * will fetch from wifi profile list itself
+ */
+
+gboolean store_wifi_setting(wifi_setting_type_t setting, void *data)
+{
+	LPErr lpErr = LP_ERR_NONE;
+	LPAppHandle handle;
+	gboolean ret = FALSE;
+
+	lpErr = LPAppGetHandle(WIFI_LUNA_PREFS_ID, &handle);
+
+	if (lpErr)
+	{
+		WCALOG_ERROR(MSGID_SETTING_LPAPP_GET_ERROR, 1, PMLOGKS("PrefsId",
+		             WIFI_LUNA_PREFS_ID), "");
+		return FALSE;
+	}
+
+	switch (setting)
+	{
+		case WIFI_PROFILELIST_SETTING:
+		{
+			/* Convert list of profiles to json string for storing */
+			lpErr = LPAppRemoveValue(handle, SettingKey[setting]);
+
+			if (lpErr && (lpErr != LP_ERR_NO_SUCH_KEY))
+			{
+				WCALOG_ERROR(MSGID_SETTING_LPAPP_REMOVE_ERROR, 1, PMLOGKS("Key",
+				             SettingKey[setting]), "");
+				goto Exit;
+			}
+
+			char *profile_list_str = add_wifi_profile_list();
+
+			if (NULL == profile_list_str)
+			{
+				WCALOG_DEBUG("No wifi profiles found");
+				goto Exit;
+			}
+
+			lpErr = LPAppSetValue(handle, SettingKey[setting], profile_list_str);
+			g_free(profile_list_str);
+
+			if (lpErr)
+			{
+				WCALOG_ERROR(MSGID_SETTING_LPAPP_SET_ERROR, 1, PMLOGKS("Key",
+				             SettingKey[setting]), "");
+				goto Exit;
+			}
+
+			ret = TRUE;
+			break;
+		}
+
+		default:
+			break;
+	}
+
+Exit:
+	(void) LPAppFreeHandle(handle, true);
+	return ret;
+}
+
+static gboolean store_config(GKeyFile *keyfile, char *pathname)
+{
+	gchar *data = NULL;
+	gsize length = 0;
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	if (length > 0)
+	{
+		FILE *fp;
+		fp = g_fopen(pathname, "w");
+
+		if (fp == NULL)
+		{
+			return FALSE;
+		}
+
+		fprintf(fp, "%s", data);
+		fclose(fp);
+	}
+
+	g_free(data);
+
+	return TRUE;
+}
+
+static GKeyFile *load_config(const char *pathname)
+{
+	GKeyFile *keyfile = NULL;
+	GError *error = NULL;
+
+	keyfile = g_key_file_new();
+
+	if (!g_key_file_load_from_file(keyfile, pathname, 0, &error))
+	{
+		g_clear_error(&error);
+
+		g_key_file_free(keyfile);
+		keyfile = NULL;
+	}
+
+	return keyfile;
+}
+
+static gchar *build_config_path(const char *ssid, const char *security)
+{
+	return g_strdup_printf("%s/wifi_%s_%s.config", CONNMAN_SAVED_PROFILE_CONFIG_DIR,
+	                       ssid, security);
+}
+
+
+gboolean store_enterprise_network_config_entries(GKeyFile *keyfile,
+        const gchar *config_group, connection_settings_t *settings)
+{
+	if (settings->eap_type != NULL)
+	{
+		g_key_file_set_string(keyfile, config_group, "Type", "wifi");
+		g_key_file_set_string(keyfile, config_group, "Name", settings->ssid);
+		g_key_file_set_string(keyfile, config_group, "Security", "ieee8021x");
+		g_key_file_set_string(keyfile, config_group, "EAP", settings->eap_type);
+	}
+	else
+	{
+		return FALSE;
+	}
+
+	if (settings->identity != NULL && strlen(settings->identity) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "Identity", settings->identity);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "Identity", NULL);
+	}
+
+	if (settings->ca_cert_file != NULL && strlen(settings->ca_cert_file) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "CACertFile",
+		                      settings->ca_cert_file);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "CACertFile", NULL);
+	}
+
+	if (settings->client_cert_file != NULL &&
+	        strlen(settings->client_cert_file) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "ClientCertFile",
+		                      settings->client_cert_file);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "ClientCertFile", NULL);
+	}
+
+	if (settings->private_key_file != NULL &&
+	        strlen(settings->private_key_file) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "PrivateKeyFile",
+		                      settings->private_key_file);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "PrivateKeyFile", NULL);
+	}
+
+	if (settings->private_key_passphrase != NULL &&
+	        strlen(settings->private_key_passphrase) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "PrivateKeyPassphrase",
+		                      settings->private_key_passphrase);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "PrivateKeyPassphrase", NULL);
+	}
+
+	if (settings->phase2 != NULL && strlen(settings->phase2) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "Phase2", settings->phase2);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "Phase2", NULL);
+	}
+
+	if (settings->passphrase != NULL && strlen(settings->passphrase) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "Passphrase",
+		                      settings->passphrase);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "Passphrase", NULL);
+	}
+
+	return TRUE;
+}
+
+
+gboolean store_network_config(connection_settings_t *settings,
+                              const char *security)
+{
+	gchar *pathname = NULL, *config_group = NULL;
+	GKeyFile *keyfile = g_key_file_new();
+	gboolean ret = FALSE;
+
+	if (NULL == settings->ssid || NULL == security)
+	{
+		g_key_file_free(keyfile);
+		return FALSE;
+	}
+
+	config_group = g_strdup_printf("service_%s", settings->ssid);
+
+	pathname = build_config_path(settings->ssid, security);
+
+	if (pathname == NULL)
+	{
+		goto cleanup;
+	}
+
+	g_key_file_set_string(keyfile, config_group, "Type", "wifi");
+	g_key_file_set_string(keyfile, config_group, "Name", settings->ssid);
+
+	if (settings->passkey != NULL && strlen(settings->passkey) > 0)
+	{
+		g_key_file_set_string(keyfile, config_group, "Passphrase", settings->passkey);
+		g_key_file_set_string(keyfile, config_group, "Security", security);
+	}
+	else
+	{
+		g_key_file_remove_key(keyfile, config_group, "Passphrase", NULL);
+	}
+
+	if (settings->hidden)
+	{
+		g_key_file_set_boolean(keyfile, config_group, "Hidden", TRUE);
+	}
+
+	if (!g_strcmp0(security, WIFI_ENTERPRISE_SECURITY_TYPE))
+	{
+		if (store_enterprise_network_config_entries(keyfile, config_group,
+		        settings) == FALSE)
+		{
+			goto cleanup;
+		}
+	}
+
+	GStrv security_type = (GStrv) g_new0(GStrv, 2);
+	security_type[0] = g_strdup(security);
+	security_type[1] = NULL;
+
+	wifi_profile_t *profile = get_profile_by_ssid_security(settings->ssid,
+	                          security);
+
+	if (NULL != profile)
+	{
+		delete_profile(profile);
+	}
+
+	create_new_profile(settings->ssid, security_type, settings->hidden, TRUE);
+
+	ret = store_config(keyfile, pathname);
+
+	send_getnetworks_status_to_subscribers();
+
+	g_free(security_type);
+
+cleanup:
+	g_free(pathname);
+	g_free(config_group);
+	g_key_file_free(keyfile);
+	return ret;
+}
+
+gboolean remove_network_config(const char *ssid, const char *security)
+{
+	gchar *pathname = NULL;
+	gboolean ret = FALSE;
+
+	pathname = build_config_path(ssid, security);
+
+	if (pathname == NULL)
+	{
+		return FALSE;
+	}
+
+	ret = (g_unlink(pathname) == 0);
+
+	g_free(pathname);
+
+	return ret;
+}
+
+gboolean change_network_passphrase(const char *ssid, const char *security,
+                                   const char *passphrase)
+{
+	gchar *pathname = NULL, *config_group = NULL;
+	GKeyFile *keyfile = NULL;
+	gboolean ret = FALSE;
+
+	if (NULL == ssid || NULL == security || NULL == passphrase)
+	{
+		return FALSE;
+	}
+
+	pathname = build_config_path(ssid, security);
+
+	if (pathname == NULL)
+	{
+		return FALSE;
+	}
+
+	keyfile = load_config(pathname);
+
+	if (keyfile == NULL)
+	{
+		return FALSE;
+	}
+
+	config_group = g_strdup_printf("service_%s", ssid);
+
+	g_key_file_set_string(keyfile, config_group, "Passphrase", passphrase);
+
+	ret = store_config(keyfile, pathname);
+
+	g_free(pathname);
+	g_free(config_group);
+	return ret;
+}
+
+gboolean change_network_ipv4(const char *ssid, const char *security,
+                             const char *address, const char *netmask, const char *gateway)
+{
+	gchar *pathname = NULL, *config_group = NULL;
+	GKeyFile *keyfile = NULL;
+	gboolean ret = FALSE;
+
+	if (NULL == ssid || NULL == security || NULL == address || NULL == netmask ||
+	        NULL == gateway)
+	{
+		return FALSE;
+	}
+
+	pathname = build_config_path(ssid, security);
+
+	if (pathname == NULL)
+	{
+		return FALSE;
+	}
+
+	keyfile = load_config(pathname);
+
+	if (keyfile == NULL)
+	{
+		return FALSE;
+	}
+
+	config_group = g_strdup_printf("service_%s", ssid);
+
+	gchar *ipv4str = g_strdup_printf("%s/%s/%s", address, netmask, gateway);
+	g_key_file_set_string(keyfile, config_group, "IPv4", ipv4str);
+
+	ret = store_config(keyfile, pathname);
+
+	g_free(ipv4str);
+	g_free(pathname);
+	g_free(config_group);
+	return ret;
+}
+
+
+gboolean change_network_ipv6(const char *ssid, const char *security,
+                             const char *address, const char *prefixLen, const char *gateway)
+{
+	gchar *pathname = NULL, *config_group = NULL;
+	GKeyFile *keyfile = NULL;
+	gboolean ret = FALSE;
+
+	if (NULL == ssid || NULL == security || NULL == address || NULL == prefixLen ||
+	        NULL == gateway)
+	{
+		return FALSE;
+	}
+
+	pathname = build_config_path(ssid, security);
+
+	if (pathname == NULL)
+	{
+		return FALSE;
+	}
+
+	keyfile = load_config(pathname);
+
+	if (keyfile == NULL)
+	{
+		return FALSE;
+	}
+
+	config_group = g_strdup_printf("service_%s", ssid);
+
+	gchar *ipv6str = g_strdup_printf("%s/%s/%s", address, prefixLen, gateway);
+	g_key_file_set_string(keyfile, config_group, "IPv6", ipv6str);
+
+	ret = store_config(keyfile, pathname);
+
+	g_free(ipv6str);
+	g_free(pathname);
+	g_free(config_group);
+	return ret;
+}
+
+gboolean change_network_dns(const char *ssid, const char *security,
+                            const GStrv *dns)
+{
+	gchar *pathname = NULL, *config_group = NULL;
+	GKeyFile *keyfile = NULL;
+	gboolean ret = FALSE;
+
+	if (NULL == ssid || NULL == security || NULL == dns)
+	{
+		return FALSE;
+	}
+
+	pathname = build_config_path(ssid, security);
+
+	if (pathname == NULL)
+	{
+		return FALSE;
+	}
+
+	keyfile = load_config(pathname);
+
+	if (keyfile == NULL)
+	{
+		return FALSE;
+	}
+
+	config_group = g_strdup_printf("service_%s", ssid);
+
+	gsize i, num_elems = g_strv_length(dns);
+	gchar *dnsstr = g_strnfill(16 * (num_elems + 1), 0);
+
+	for (i = 0; i < num_elems; i++)
+	{
+		dnsstr = strcat(dnsstr, dns[i]);
+
+		if (i < (num_elems - 1))
+		{
+			dnsstr = strcat(dnsstr, ",");
+		}
+	}
+
+	g_key_file_set_string(keyfile, config_group, "Nameservers", dnsstr);
+
+	ret = store_config(keyfile, pathname);
+
+	g_free(dnsstr);
+	g_free(pathname);
+	g_free(config_group);
+	return ret;
+}
+
+gboolean change_network_remove_entry(const char *ssid, const char *security,
+                                     const char *key)
+{
+	gchar *pathname = NULL, *config_group = NULL;
+	GKeyFile *keyfile = NULL;
+	gboolean ret = FALSE;
+
+	if (NULL == ssid || NULL == security || NULL == key)
+	{
+		return FALSE;
+	}
+
+	pathname = build_config_path(ssid, security);
+
+	if (pathname == NULL)
+	{
+		return FALSE;
+	}
+
+	keyfile = load_config(pathname);
+
+	if (keyfile == NULL)
+	{
+		return FALSE;
+	}
+
+	config_group = g_strdup_printf("service_%s", ssid);
+
+	g_key_file_remove_key(keyfile, config_group, key, NULL);
+
+	ret = store_config(keyfile, pathname);
+
+	g_free(pathname);
+	g_free(config_group);
+	return ret;
+
+}
+
+/**
+ * @brief For a given .config file, check if there is a profile present, if not create it
+ */
+
+gboolean check_profile_or_create(const char *file, gchar **pathname)
+{
+	GKeyFile *keyfile = NULL;
+	char **groups;
+	int i;
+	gboolean ret = FALSE;
+
+	keyfile = load_config(file);
+
+	if (keyfile == NULL)
+	{
+		return FALSE;
+	}
+
+	groups = g_key_file_get_groups(keyfile, NULL);
+
+	for (i = 0; groups[i] != NULL; i++)
+	{
+		char *ident, *type, *ssid, *security;
+		gboolean hidden = FALSE, security_found = FALSE;
+
+		if (g_str_has_prefix(groups[i], "service_") == FALSE)
+		{
+			continue;
+		}
+
+		ident = groups[i] + 8;
+
+		if (strlen(ident) < 1)
+		{
+			continue;
+		}
+
+		// Read the type, ssid, security and hidden flag for this config file
+		type = g_key_file_get_string(keyfile, groups[i], "Type", NULL);
+
+		if (type == NULL || g_strcmp0(type, "wifi") != 0)
+		{
+			continue;
+		}
+
+		ssid = g_key_file_get_string(keyfile, groups[i], "Name", NULL);
+
+		if (ssid == NULL || g_strcmp0(ssid, ident) != 0)
+		{
+			continue;
+		}
+
+		security = g_key_file_get_string(keyfile, groups[i], "Security", NULL);
+
+		if (security == NULL)
+		{
+			security = g_strdup("none");
+		}
+		else
+		{
+			security_found = TRUE;
+		}
+
+		hidden = g_key_file_get_boolean(keyfile, groups[i], "Hidden", NULL);
+
+		// This is the pathname of the config file with the format wifi_<SSID>_<security>.config
+		*pathname = build_config_path(ssid, security);
+
+		// Check if there is wifi profile already for this config file, else create one
+		wifi_profile_t *profile = get_profile_by_ssid_security(ssid, security);
+
+		if (profile == NULL)
+		{
+			gchar *security_type[2];
+			security_type[0] = security;
+			security_type[1] = NULL;
+			create_new_profile(ssid, security_type, hidden, TRUE);
+		}
+
+		g_free(security);
+
+		// Found a valid service_* entry, so skipping other service_* entries, if any
+		ret = TRUE;
+		break;
+	}
+
+	g_strfreev(groups);
+	return ret;
+}
+
+/**
+ * @brief Delete all configured profiles with no corresponding config file
+ */
+void delete_invalid_configured_profiles(void)
+{
+	GSList *iter = NULL;
+	GSList *delete_profiles = NULL;
+
+	wifi_profile_t *profile = NULL;
+
+	while (NULL != (profile = get_next_profile(profile)))
+	{
+		if (profile->configured == FALSE)
+		{
+			continue;
+		}
+		else
+		{
+			gchar *pathname = build_config_path(profile->ssid, profile->security[0]);
+
+			if (!pathname)
+			{
+				continue;
+			}
+
+			// if the corresponding .config file doesnt exist, delete the profile
+			if (g_file_test(pathname, G_FILE_TEST_EXISTS) == FALSE)
+			{
+				delete_profiles = g_slist_prepend(delete_profiles, (gpointer) profile);
+			}
+
+			g_free(pathname);
+		}
+	}
+
+	for (iter = delete_profiles; iter != NULL; iter = iter->next)
+	{
+		wifi_profile_t *profile = (wifi_profile_t *)(iter->data);
+		delete_profile(profile);
+	}
+
+	g_slist_free(delete_profiles);
+}
+
+
+typedef struct rename_files
+{
+	gchar *oldpath;
+	gchar *newpath;
+} rename_files_t;
+
+/**
+ * @brief Check all .config files under CONNMAN_SAVED_PROFILE_CONFIG_DIR folder, and if a config file
+ * is found with no corresponding profile, create one, however if a configured profile is found with
+ * no .config file, delete the profile
+ */
+void sync_network_configs_with_profiles(void)
+{
+	GDir *dir;
+	const gchar *file;
+	GSList *rename_files_list = NULL;
+
+	dir = g_dir_open(CONNMAN_SAVED_PROFILE_CONFIG_DIR, 0, NULL);
+
+	if (!dir)
+	{
+		return;
+	}
+
+	while ((file = g_dir_read_name(dir)) != NULL)
+	{
+		if (g_str_has_suffix(file, ".config") == FALSE)
+		{
+			continue;
+		}
+
+		gchar *config_pathname = NULL;
+		gchar *abs_filename = g_strdup_printf("%s/%s", CONNMAN_SAVED_PROFILE_CONFIG_DIR,
+		                                      file);
+
+		if (check_profile_or_create(abs_filename, &config_pathname) == FALSE)
+		{
+			g_free(abs_filename);
+			continue;
+		}
+
+		if (config_pathname == NULL)
+		{
+			break;
+		}
+
+		// If the name of the config file doesn't match the wifi_<SSID>_<security>.config
+		// format that we want, rename the file later
+		if (g_strcmp0(abs_filename, config_pathname) != 0)
+		{
+			rename_files_t *fileptrs = g_new0(rename_files_t, 1);
+			fileptrs->oldpath = abs_filename;
+			fileptrs->newpath = config_pathname;
+			rename_files_list = g_slist_prepend(rename_files_list, (gpointer) fileptrs);
+		}
+		else
+		{
+			g_free(config_pathname);
+			g_free(abs_filename);
+		}
+	}
+
+	g_dir_close(dir);
+
+	GSList *iter = rename_files_list;
+
+	while (iter != NULL)
+	{
+		rename_files_t *fileptrs = (rename_files_t *)(iter->data);
+		g_rename(fileptrs->oldpath, fileptrs->newpath);
+		g_free(fileptrs->oldpath);
+		g_free(fileptrs->newpath);
+		iter = iter->next;
+		g_free(fileptrs);
+	}
+
+	delete_invalid_configured_profiles();
+	g_slist_free(rename_files_list);
+}
+
+
+/**
+ * @brief Callback function for any modifications to CONNMAN_SAVED_PROFILE_CONFIG_DIR folder
+ */
+static gboolean inotify_data(GIOChannel *channel, GIOCondition cond,
+                             gpointer user_data)
+{
+	char buffer[256];
+	char *next_event;
+	gsize bytes_read;
+	GIOStatus status;
+
+	if (cond & (G_IO_NVAL | G_IO_ERR | G_IO_HUP))
+	{
+		return FALSE;
+	}
+
+	status = g_io_channel_read_chars(channel, buffer,
+	                                 sizeof(buffer) - 1, &bytes_read, NULL);
+
+	switch (status)
+	{
+		case G_IO_STATUS_NORMAL:
+			break;
+
+		case G_IO_STATUS_AGAIN:
+			return TRUE;
+
+		default:
+			WCALOG_DEBUG("Reading from inotify channel failed");
+			return FALSE;
+	}
+
+	next_event = buffer;
+
+	while (bytes_read > 0)
+	{
+		struct inotify_event *event;
+		gchar *file;
+		gsize len;
+
+		event = (struct inotify_event *) next_event;
+
+		if (event->len)
+		{
+			file = next_event + sizeof(struct inotify_event);
+		}
+		else
+		{
+			continue;
+		}
+
+		len = sizeof(struct inotify_event) + event->len;
+
+		/* check if inotify_event block fit */
+		if (len > bytes_read)
+		{
+			break;
+		}
+
+		next_event += len;
+		bytes_read -= len;
+
+		WCALOG_DEBUG("New event found for file %s, event mask : %lx", file,
+		             event->mask);
+
+		if (event->mask & IN_CREATE || event->mask & IN_MOVED_TO ||
+		        event->mask & IN_MODIFY)
+		{
+			if (g_str_has_suffix(file, ".config") == FALSE)
+			{
+				continue;
+			}
+
+			gchar *config_pathname = NULL;
+			gchar *abs_filename = g_strdup_printf("%s/%s", CONNMAN_SAVED_PROFILE_CONFIG_DIR,
+			                                      file);
+			if (check_profile_or_create(abs_filename, &config_pathname) == TRUE)
+			{
+				if (g_strcmp0(abs_filename, config_pathname) != 0)
+				{
+					g_rename(abs_filename, config_pathname);
+				}
+				g_free(config_pathname);
+			}
+
+			g_free(abs_filename);
+		}
+
+		if (event->mask & IN_DELETE || event->mask & IN_MOVED_FROM ||
+		        event->mask & IN_MODIFY)
+		{
+			delete_invalid_configured_profiles();
+		}
+	}
+
+	return TRUE;
+}
+
+
+int wd = 0;
+GIOChannel *channel = NULL;
+uint watch = 0;
+
+/**
+ * @brief Create a watch for any new file created/modified/deleted/moved in CONNMAN_SAVED_PROFILE_CONFIG_DIR folder
+ */
+gboolean create_config_inotify_watch(void)
+{
+	int fd;
+
+	fd = inotify_init();
+
+	if (fd < 0)
+	{
+		return FALSE;
+	}
+
+	wd = inotify_add_watch(fd, CONNMAN_SAVED_PROFILE_CONFIG_DIR,
+	                       IN_MODIFY | IN_CREATE | IN_DELETE |
+	                       IN_MOVED_TO | IN_MOVED_FROM);
+
+	if (wd < 0)
+	{
+		close(fd);
+		return FALSE;
+	}
+
+	channel = g_io_channel_unix_new(fd);
+
+	if (channel == NULL)
+	{
+		inotify_rm_watch(fd, wd);
+		close(fd);
+		return FALSE;
+	}
+
+	g_io_channel_set_close_on_unref(channel, TRUE);
+	g_io_channel_set_encoding(channel, NULL, NULL);
+	g_io_channel_set_buffered(channel, FALSE);
+
+	watch = g_io_add_watch(channel,
+	                       G_IO_IN | G_IO_HUP | G_IO_NVAL | G_IO_ERR,
+	                       inotify_data, NULL);
+
+	return TRUE;
+}
+
+void remove_config_inotify_watch(void)
+{
+	int fd;
+
+	if (channel == NULL)
+	{
+		return;
+	}
+
+	if (watch > 0)
+	{
+		g_source_remove(watch);
+	}
+
+	fd = g_io_channel_unix_get_fd(channel);
+
+	if (wd >= 0)
+	{
+		inotify_rm_watch(fd, wd);
+	}
+
+	g_io_channel_unref(channel);
+}
diff --git a/src/wifi_setting.h b/src/wifi_setting.h
new file mode 100644
index 0000000..4823f83
--- /dev/null
+++ b/src/wifi_setting.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_setting.h
+ *
+ */
+
+
+#ifndef _WIFI_SETTING_H_
+#define _WIFI_SETTING_H_
+
+#include "wifi_service.h"
+
+#define WIFI_LUNA_PREFS_ID          WIFI_LUNA_SERVICE_NAME
+
+typedef enum
+{
+	WIFI_NULL_SETTING,
+	WIFI_PROFILELIST_SETTING,
+	WIFI_LAST_SETTING,
+} wifi_setting_type_t;
+
+extern gboolean load_wifi_setting(wifi_setting_type_t setting, void *data);
+extern gboolean store_wifi_setting(wifi_setting_type_t setting, void *data);
+
+extern gboolean store_network_config(connection_settings_t *settings,
+                              const char *security);
+extern gboolean change_network_passphrase(const char *ssid, const char *security,
+                                         const char *passphrase);
+extern gboolean create_config_inotify_watch(void);
+extern void sync_network_configs_with_profiles(void);
+extern gboolean change_network_ipv4(const char *ssid, const char *security,
+                                    const char *address, const char *netmask, const char *gateway);
+extern gboolean change_network_ipv6(const char *ssid, const char *security,
+                                    const char *address, const char *prefixLen, const char *gateway);
+extern gboolean change_network_remove_entry(const char *ssid, const char *security, const char *key);
+extern void remove_config_inotify_watch(void);
+
+
+#endif /* _WIFI_SETTING_H_ */
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
new file mode 100644
index 0000000..a0c3ffd
--- /dev/null
+++ b/src/wifi_tethering_service.c
@@ -0,0 +1,892 @@
+// Copyright (c) 2014-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_tethering_service.c
+ *
+ * @brief Implements the com.webos.service.wifi/tethering service API with using connman in the backend.
+ */
+
+/**
+ *  @brief Initialize com.webos.service.wifi/p2p service and all of its methods
+ */
+
+#include <glib.h>
+#include <stdbool.h>
+#include <string.h>
+
+#include <wca-support.h>
+
+#include "wifi_tethering_service.h"
+#include "wifi_service.h"
+#include "connman_manager.h"
+#include "lunaservice_utils.h"
+#include "connman_common.h"
+#include "common.h"
+#include "logging.h"
+#include "errors.h"
+
+#define WIFI_STATUS_TIMEOUT     1
+#define WIFI_TETHERING_USED_RX_BYTES_TRESHOLD(x)        5000*x
+
+LSHandle *tetheringpLSHandle = NULL;
+
+static gboolean previous_wifi_legacy_powered = FALSE;
+
+static guint wifi_tethering_timeout = 5;
+static guint wifi_tethering_timeout_source = 0;
+static guint wifi_tethering_client_count = 0;
+
+void start_tethering_timeout(void);
+
+static void support_tethering_disabled_cb(bool success, void *user_data)
+{
+	LSMessage *message = user_data;
+	LSHandle *handle = 0;
+
+	if (message)
+	{
+		handle = LSMessageGetConnection(message);
+	}
+
+	if (!success)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message,
+			                          "Failed to disable tethering mode through support library",
+			                          WCA_API_ERROR_TETHERING_SUPPORT_FAILED);
+
+		return;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!wifi_tech)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message, "WiFi technology unavailable",
+			                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
+
+		return;
+	}
+
+	if (!connman_technology_set_tethering(wifi_tech, FALSE))
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message, "Failed to disable tethering mode",
+			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
+
+		return;
+	}
+
+
+	if (!previous_wifi_legacy_powered &&
+	        !connman_technology_set_powered(wifi_tech, FALSE, NULL))
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message,
+			                          "Failed to restore WiFi state after disbling tethering",
+			                          WCA_API_ERROR_TETHERING_RESTORE_WIFI_STATE_FAILED);
+
+		return;
+	}
+
+	LSMessageReplySuccess(handle, message);
+}
+
+static void support_tethering_disabled_after_failure_cb(bool success,
+        void *user_data)
+{
+	(void) success;
+
+	LSMessage *message = user_data;
+
+	if (!message)
+	{
+		return;
+	}
+
+	LSHandle *handle = LSMessageGetConnection(message);
+
+	LSMessageReplyCustomError(handle, message, "Failed to enable tethering mode",
+	                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
+}
+
+static void support_tethering_enabled_cb(bool success, void *user_data)
+{
+	LSMessage *message = user_data;
+	LSHandle *handle = 0;
+
+	if (message)
+	{
+		handle = LSMessageGetConnection(message);
+	}
+
+	if (!success)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message,
+			                          "Failed to enable tethering mode through support library",
+			                          WCA_API_ERROR_TETHERING_SUPPORT_FAILED);
+
+		return;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!wifi_tech)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message, "WiFi technology unavailable",
+			                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
+
+		return;
+	}
+
+	if (!connman_technology_set_tethering(wifi_tech, TRUE))
+	{
+		/* disable tethering support again */
+		wca_support_wifi_disable_tethering(support_tethering_disabled_after_failure_cb,
+		                                   message);
+		return;
+	}
+
+	wifi_tethering_client_count = 0;
+	start_tethering_timeout();
+
+	if (message)
+	{
+		LSMessageReplySuccess(handle, message);
+	}
+}
+
+/**
+ *  @brief Sets the wifi technologies tethering state
+ *
+ *  @param state
+ */
+
+gboolean set_wifi_tethering(bool state, LSMessage *message)
+{
+	if (state == is_wifi_tethering())
+	{
+		return false;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!is_wifi_powered() && state)
+	{
+		previous_wifi_legacy_powered = FALSE;
+
+		// we need to have WiFI powered otherwise we can't start tethering
+		connman_technology_set_powered(wifi_tech, TRUE, NULL);
+
+		// FIXME this should go away once we switch to asynchronous variant of
+		// connman_technology_set_powered method
+		g_usleep(2000000);
+	}
+	else if (is_wifi_powered() && state)
+	{
+		previous_wifi_legacy_powered = TRUE;
+	}
+
+	if (state)
+	{
+		connman_service_t *connected_service = connman_manager_get_connected_service(
+		        manager->wifi_services);
+
+		if (connected_service)
+		{
+			connman_service_disconnect(connected_service);
+		}
+
+		wca_support_wifi_enable_tethering(support_tethering_enabled_cb, message);
+	}
+	else
+	{
+		wca_support_wifi_disable_tethering(support_tethering_disabled_cb, message);
+	}
+
+	return TRUE;
+}
+
+static void send_tethering_state(jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("enabled"),
+	            jboolean_create(is_wifi_tethering()));
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (NULL != wifi_tech->tethering_identifier)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("ssid"),
+		            jstring_create(wifi_tech->tethering_identifier));
+	}
+
+	if (NULL != wifi_tech->tethering_identifier)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("securityType"),
+		            jstring_create((NULL != wifi_tech->tethering_passphrase)
+		                           && (strlen(wifi_tech->tethering_passphrase) != 0) ? "psk" : "open"));
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("timeout"),
+	            jnumber_create_i32(wifi_tethering_timeout));
+}
+
+void send_tethering_state_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	send_tethering_state(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+		WCALOG_DEBUG("Sending payload : %s", payload);
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(tetheringpLSHandle, "/tethering/getState",
+		                        payload,
+		                        &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+
+}
+
+static void send_sta_count(jvalue_ref *reply)
+{
+	if(NULL == reply)
+		return;
+
+	unsigned int sta_count = connman_manager_get_sta_count(manager);
+	jobject_put(*reply, J_CSTR_TO_JVAL("stationCount"), jnumber_create_i32(sta_count));
+}
+
+void send_sta_count_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	send_sta_count(&reply);
+
+	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+	if(response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+		WCALOG_DEBUG("Sending payload : %s",payload);
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(tetheringpLSHandle, "/tethering/getStationCount", payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+static gboolean tethering_timeout_cb(gpointer user_data)
+{
+	WCALOG_DEBUG("WiFi tethering timeout occured. Disable tethering.");
+
+	set_wifi_tethering(FALSE, 0);
+
+	wifi_tethering_timeout_source = 0;
+
+	return FALSE;
+}
+
+static void sta_authorized_cb(gpointer user_data)
+{
+	wifi_tethering_client_count++;
+
+	// If timer is no longer active we don't have anything to do here
+	if (wifi_tethering_timeout_source == 0)
+	{
+		return;
+	}
+
+	WCALOG_DEBUG("Got new WiFi tethering client");
+
+	// Now that we have a client connected to our AP we can stop
+	// the timeout.
+	if (wifi_tethering_timeout_source != 0)
+	{
+		WCALOG_DEBUG("Abort running tethering timer");
+		g_source_remove(wifi_tethering_timeout_source);
+		wifi_tethering_timeout_source = 0;
+	}
+}
+
+static void sta_deauthorized_cb(gpointer user_data)
+{
+	wifi_tethering_client_count--;
+
+	WCALOG_DEBUG("WiFi tethering client disconnected");
+
+	if (wifi_tethering_client_count > 0)
+	{
+		WCALOG_DEBUG("Not restarting timeout as we have %d clients left",
+		             wifi_tethering_client_count);
+		return;
+	}
+
+	start_tethering_timeout();
+}
+
+void start_tethering_timeout(void)
+{
+	if (wifi_tethering_timeout == 0 || wifi_tethering_timeout_source != 0)
+	{
+		return;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	WCALOG_DEBUG("Setting WiFi tethering timeout to %d minutes",
+	             wifi_tethering_timeout);
+
+	// Make sure our handler gets registered with the WiFi technology
+	// to get known when a new STA connects
+	connman_technology_register_sta_authorized_cb(wifi_tech, sta_authorized_cb,
+	        NULL);
+	connman_technology_register_sta_deauthorized_cb(wifi_tech, sta_deauthorized_cb,
+	        NULL);
+
+	wifi_tethering_timeout_source = g_timeout_add_seconds(wifi_tethering_timeout *
+	                                60,
+	                                tethering_timeout_cb, NULL);
+}
+
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_service_wifi com.webos.service.wifi/tethering/setState
+@{
+@section com_webos_service_wifi_tethering_setstate setState
+
+Set tethering state.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+enabled | No | boolean | enable / disable tethering
+ssid | No | String | The tethering broadcasted identifier
+passPhrase | No | String | The tethering connection passphrase
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(enabled, boolean),
+	                                     PROP(ssid, string), PROP(passPhrase, string), PROP(securityType, string),
+	                                     PROP(timeout, integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref enabledObj = {0}, ssidObj = {0}, passPhraseObj = {0}, securityTypeObj
+	                                       = {0}, timeoutObj = {0};
+	gboolean enable_tethering = FALSE, invalidArg = TRUE;
+	gchar *ssid = NULL, *passphrase = NULL;
+	int timeout = 0;
+	gboolean is_open = FALSE;
+	gboolean state_set = FALSE;
+
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change SSID while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_SSID_FAILED);
+			goto cleanup;
+		}
+
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+
+		if (NULL == ssid)
+		{
+			goto invalid_params;
+		}
+
+		invalidArg = FALSE;
+
+		if (!connman_technology_set_tethering_identifier(
+		            connman_manager_find_wifi_technology(manager), ssid))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering SSID",
+			                          WCA_API_ERROR_TETHERING_SSID_FAILED);
+			goto cleanup;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("securityType"),
+	                       &securityTypeObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change securityType while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_SEC_TYPE);
+			goto cleanup;
+		}
+
+		if (jstring_equal2(securityTypeObj, J_CSTR_TO_BUF("open")))
+		{
+			is_open = TRUE;
+		}
+		else if (jstring_equal2(securityTypeObj, J_CSTR_TO_BUF("psk")))
+		{
+			is_open = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		if (is_open &&
+		        !connman_technology_set_tethering_passphrase(
+		            connman_manager_find_wifi_technology(manager), ""))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering passphrase",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
+			goto cleanup;
+		}
+
+		invalidArg = FALSE;
+	}
+
+	if (!is_open &&
+	        jobject_get_exists(parsedObj, J_CSTR_TO_BUF("passPhrase"), &passPhraseObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change passphrase while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
+			goto cleanup;
+		}
+
+		raw_buffer passphrase_buf = jstring_get(passPhraseObj);
+		passphrase = g_strdup(passphrase_buf.m_str);
+		jstring_free_buffer(passphrase_buf);
+
+		if (NULL == passphrase)
+		{
+			goto invalid_params;
+		}
+
+		if (!is_open && (!passphrase || strlen(passphrase) == 0))
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "No passphrase set but required for security type psk",
+			                          WCA_API_ERROR_TETHERING_NO_PASSPHRASE);
+			goto cleanup;
+		}
+
+		int passphrase_length = strlen(passphrase);
+
+		if (!is_open && (passphrase_length < 8 || passphrase_length > 63))
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Passphrase doesn't match the requirements",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID);
+			goto cleanup;
+		}
+
+		if (is_open && passphrase != NULL && strlen(passphrase) > 0)
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "With security typen open specifying a passphrase is not possible",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED);
+			goto cleanup;
+		}
+
+		invalidArg = FALSE;
+
+		if (!is_open &&
+		        !connman_technology_set_tethering_passphrase(
+		            connman_manager_find_wifi_technology(manager), passphrase))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering passphrase",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
+			goto cleanup;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("timeout"), &timeoutObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change timeout while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT);
+			goto cleanup;
+		}
+
+		jnumber_get_i32(timeoutObj, &timeout);
+
+		if (timeout < 0)
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Negative values are not allowed for the timeout",
+			                          WCA_API_ERROR_TETHERING_TIMEOUT_NO_NEGATIVE_VALUES);
+			goto cleanup;
+		}
+
+		wifi_tethering_timeout = timeout;
+
+		invalidArg = FALSE;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
+	{
+		jboolean_get(enabledObj, &enable_tethering);
+
+		if (enable_tethering && is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Already Enabled",
+			                          WCA_API_ERROR_ALREADY_ENABLED);
+			goto cleanup;
+		}
+		else if (!enable_tethering && !is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Already Disabled",
+			                          WCA_API_ERROR_ALREADY_DISABLED);
+			goto cleanup;
+		}
+
+		state_set = TRUE;
+		invalidArg = FALSE;
+	}
+
+	if (invalidArg == TRUE)
+	{
+		goto invalid_params;
+	}
+
+	if (state_set && !set_wifi_tethering(enable_tethering, message))
+	{
+		if (enable_tethering)
+		{
+			LSMessageReplyCustomError(sh, message, "Failed to enable tethering mode",
+			                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message, "Failed to disable tethering mode",
+			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
+		}
+
+		goto cleanup;
+	}
+	else
+	{
+		LSMessageReplySuccess(sh, message);
+	}
+
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+
+cleanup:
+	g_free(ssid);
+	g_free(passphrase);
+	j_release(&parsedObj);
+	return true;
+}
+
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_wifi com.webos.wifi/gettethering
+@{
+@page com_webos_service_wifi com.webos.service.wifi/tethering/getState
+@{
+@section com_webos_service_wifi_tethering_getstate getState
+
+Get current tethering state.
+
+@par Parameters
+subscribe | No | boolean | Subscribe for updates
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+state | No | boolean | enable / disable tethering
+ssid | No | String | The tethering broadcasted identifier
+passPhrase | No | String |  The tethering connection passphrase
+securityType | No | String |  The tethering securityType
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+subscribed | No | Boolean | True when successfully subscribed. False when unsubscribed or subscription was not possible.
+
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_get_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	send_tethering_state(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+
+	return true;
+}
+
+static bool handle_get_station_count_command(LSHandle *sh, LSMessage *message, void* context)
+{
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	jvalue_ref parsedObj = {0};
+	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		j_release(&reply);
+		return true;
+	}
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if(!connman_status_check_with_subscription(manager, sh, message, subscribed))
+		goto cleanup;
+
+	if(!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+		goto cleanup;
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	send_sta_count(&reply);
+
+	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+	if(!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh,message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema), &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+	j_release(&parsedObj);
+	j_release(&reply);
+
+	return true;
+}
+
+/**
+ * com.webos.service.wifi/tethering service Luna Method Table
+ */
+
+static LSMethod wifi_tethering_methods[] =
+{
+	{ LUNA_METHOD_TETHERING_SETSTATE,              handle_set_state_command },
+	{ LUNA_METHOD_TETHERING_GETSTATE,              handle_get_state_command },
+	{ LUNA_METHOD_TETHERING_GETSTACOUNT,           handle_get_station_count_command },
+	{},
+};
+
+int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,
+                                        LSHandle *pLsHandle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (NULL == mainloop)
+	{
+		goto Exit;
+	}
+
+	tetheringpLSHandle = pLsHandle;
+
+	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_TETHERING,
+	                       wifi_tethering_methods, NULL,
+	                       NULL, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TETHERING_METHODS_LUNA_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	return 0;
+Exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	return -1;
+}
diff --git a/src/wifi_tethering_service.h b/src/wifi_tethering_service.h
new file mode 100644
index 0000000..97ab40d
--- /dev/null
+++ b/src/wifi_tethering_service.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2014-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_tethering_service.h
+ *
+ */
+
+#ifndef _WIFI_TETHERING_SERVICE_H_
+#define _WIFI_TETHERING_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define LUNA_CATEGORY_TETHERING              "/tethering"
+
+/**
+ * @name Luna WiFi tethering Method Names
+ * @{
+ */
+
+#define LUNA_METHOD_TETHERING_SETSTATE       "setState"
+#define LUNA_METHOD_TETHERING_GETSTATE       "getState"
+#define LUNA_METHOD_TETHERING_GETSTACOUNT    "getStationCount"
+
+extern void send_tethering_state_to_subscribers(void);
+extern void send_sta_count_to_subscribers(void);
+extern int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,
+        LSHandle *pLsHandle);
+
+#endif /* _WIFI_TETHERING_SERVICE_H_ */
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
new file mode 100644
index 0000000..d387b0d
--- /dev/null
+++ b/tests/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(test-ssid-conversion test-ssid-conversion.c
+            ${CMAKE_SOURCE_DIR}/src/utils.c)
+target_link_libraries(test-ssid-conversion ${GLIB2_LDFLAGS})
diff --git a/tests/test-ssid-conversion.c b/tests/test-ssid-conversion.c
new file mode 100644
index 0000000..ef9a8f4
--- /dev/null
+++ b/tests/test-ssid-conversion.c
@@ -0,0 +1,155 @@
+// Copyright (c) 2012-2018 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include <glib.h>
+#include <locale.h>
+#include <string.h>
+
+#include "utils.h"
+
+#define SYSTEM_LOCALE_US "en-US"
+#define SYSTEM_LOCALE_KR "ko-KR"
+
+#define SSID_UTF_8_ENCODED_LEN 12
+
+const char ssid_utf8_encoded[SSID_UTF_8_ENCODED_LEN] =
+{
+	0x4d, 0x59, 0x5f, 0x54, 0x45, 0x53, 0x54, 0x5f,
+	0x53, 0x53, 0x49, 0x44
+};
+
+#define SSID_ENC_KR_ENCODED_LEN 6
+
+const char ssid_enc_kr_encoded[SSID_ENC_KR_ENCODED_LEN] =
+{
+	0xb3, 0xb2, 0xbc, 0xf6, 0xc7, 0xf6
+};
+
+#define SSID_ENC_KR_CONVERTED_LEN 9
+
+const char ssid_enc_kr_converted[SSID_ENC_KR_CONVERTED_LEN] =
+{
+	0xeb, 0x82, 0xa8, 0xec, 0x88, 0x98, 0xed, 0x98,
+	0x84
+};
+
+/**
+ * @brief Check if the convert_ssid_to_utf8 method still works as it should with passing
+ * invalid parameters.
+ */
+
+static void test_with_invalid_arguments(void)
+{
+	char *result = NULL;
+
+	result = convert_ssid_to_utf8(NULL, 0, NULL);
+	g_assert(result == NULL);
+
+	g_free(result);
+
+	result = convert_ssid_to_utf8(NULL, 10, SYSTEM_LOCALE_US);
+	g_assert(result == NULL);
+
+	g_free(result);
+
+	result = convert_ssid_to_utf8("test", 0, SYSTEM_LOCALE_US);
+	g_assert(result == NULL);
+
+	g_free(result);
+
+	result = convert_ssid_to_utf8("test", 3, SYSTEM_LOCALE_US);
+	g_assert(result != NULL);
+
+	g_free(result);
+
+	result = convert_ssid_to_utf8("test", 10, SYSTEM_LOCALE_US);
+	g_assert(result != NULL);
+
+	g_free(result);
+
+	result = convert_ssid_to_utf8("test", 4, SYSTEM_LOCALE_US);
+	g_assert(result != NULL);
+
+	g_free(result);
+}
+
+/**
+ * @brief. Check if the convert_ssid_to_utf8 method returns valid UTF-8 when it's filled
+ * with already valid UTF-8 data.
+ */
+
+static void test_with_valid_utf8(void)
+{
+	char *result = NULL;
+
+	result = convert_ssid_to_utf8(ssid_utf8_encoded, SSID_UTF_8_ENCODED_LEN,
+	                              SYSTEM_LOCALE_US);
+	g_assert(result != NULL);
+	g_assert(g_utf8_validate(result, -1, NULL) == TRUE);
+	g_assert(strncmp(ssid_utf8_encoded, result, SSID_UTF_8_ENCODED_LEN) == 0);
+
+	g_free(result);
+
+	result = convert_ssid_to_utf8(ssid_utf8_encoded, SSID_UTF_8_ENCODED_LEN, NULL);
+	g_assert(result != NULL);
+	g_assert(g_utf8_validate(result, -1, NULL) == TRUE);
+	g_assert(strncmp(ssid_utf8_encoded, result, SSID_UTF_8_ENCODED_LEN) == 0);
+
+	g_free(result);
+}
+
+/**
+ * @brief Check if convert_ssid_to_utf8 method can handle EUC-KR encoded input data
+ * correctly and returns what it is expected for.
+ */
+
+static void test_with_enc_kr(void)
+{
+	char *result = NULL;
+
+	g_assert(g_utf8_validate(ssid_enc_kr_encoded, -1, NULL) == FALSE);
+
+	result = convert_ssid_to_utf8(ssid_enc_kr_encoded, SSID_ENC_KR_ENCODED_LEN,
+	                              SYSTEM_LOCALE_KR);
+	g_assert(result != NULL);
+	g_assert(strncmp(ssid_enc_kr_converted, result,
+	                 SSID_ENC_KR_CONVERTED_LEN) == 0);
+
+	g_free(result);
+
+
+	result = convert_ssid_to_utf8(ssid_enc_kr_encoded, SSID_ENC_KR_ENCODED_LEN,
+	                              SYSTEM_LOCALE_US);
+	g_assert(result != NULL);
+	g_assert(strncmp(ssid_enc_kr_converted, result,
+	                 SSID_ENC_KR_CONVERTED_LEN) != 0);
+
+	g_free(result);
+}
+
+int main(int argc, char **argv)
+{
+	g_test_init(&argc, &argv, NULL);
+
+	g_test_add_func("/convert_ssid_to_utf8/invalid_arguments",
+	                test_with_invalid_arguments);
+	g_test_add_func("/convert_ssid_to_utf8/with_valid_utf8",
+	                test_with_valid_utf8);
+	g_test_add_func("/convert_ssid_to_utf8/with_enc_kr",
+	                test_with_enc_kr);
+
+	return g_test_run();
+}

commit 477f7cd75b99c7695a2a5aff3314228fad77829f
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Mon Jul 22 17:57:41 2019 +0530

    Removing support for setEthernetTethering API
    
    :Release Notes:
    Removing setEthernetTethering API implementation for
    connectionmanager service.
    
    :Detailed Notes:
    Add changes to remove EthernetTethering API for connectionmanager
    service. Since its not required for OSE.
    
    :Testing Performed:
    Build successfully.
    Verified test cases QO-512, QO-3707.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-83200] [OSE Service Name Check]
                 "com.webos.service.connectionmanager"/setEthernetTethering
    
    Change-Id: I44ee4cf0a1a1b9c2eff892de4e6243d8a067db8a

diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index 931ba3d..6a343ac 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -8,7 +8,6 @@
         "com.webos.service.connectionmanager/getUserStatus",
         "com.webos.service.connectionmanager/monitorActivity",
         "com.webos.service.connectionmanager/setdns",
-        "com.webos.service.connectionmanager/setEthernetTethering",
         "com.webos.service.connectionmanager/setipv4",
         "com.webos.service.connectionmanager/setipv6",
         "com.webos.service.connectionmanager/setProxy",
@@ -48,7 +47,6 @@
         "com.webos.service.connectionmanager/getUserStatus",
         "com.webos.service.connectionmanager/monitorActivity",
         "com.webos.service.connectionmanager/setdns",
-        "com.webos.service.connectionmanager/setEthernetTethering",
         "com.webos.service.connectionmanager/setipv4",
         "com.webos.service.connectionmanager/setipv6",
         "com.webos.service.connectionmanager/setProxy",
diff --git a/src/common.c b/src/common.c
index a7e4421..126f93f 100644
--- a/src/common.c
+++ b/src/common.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -319,25 +319,6 @@ const gchar *get_current_system_locale()
 	return current_system_locale;
 }
 
-gboolean ethernet_technology_status_check(LSHandle *sh, LSMessage *message)
-{
-	if (NULL == connman_manager_find_ethernet_technology(manager))
-	{
-		LSMessageReplyCustomError(sh, message, "Ethernet technology unavailable",
-		                          WCA_API_ERROR_ETHERNET_TECHNOLOGY_UNAVAILABLE);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-gboolean is_ethernet_tethering(void)
-{
-	connman_technology_t *technology = connman_manager_find_ethernet_technology(
-	                                       manager);
-	return (NULL != technology) && technology->tethering;
-}
-
 /**
  *  @brief Check wether the bluetooth technology is powered (the "Powered" property has the
  *  value true).
diff --git a/src/common.h b/src/common.h
index bd1ae22..11596b4 100644
--- a/src/common.h
+++ b/src/common.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -41,7 +41,6 @@ extern gboolean set_wifi_powered_status(gboolean state);
 extern const gchar *get_current_system_locale();
 extern void retrieve_system_locale_info(LSHandle *handle);
 extern void set_cellular_powered_status(gboolean state);
-extern gboolean is_ethernet_tethering(void);
 extern gboolean is_bluetooth_powered(void);
 extern gboolean is_bluetooth_tethering(void);
 extern bool is_valid_ipv6address(char *ipAddress);
@@ -50,7 +49,6 @@ extern gboolean bluetooth_technology_status_check(LSHandle *sh,
         LSMessage *message);
 extern gboolean bluetooth_technology_status_check_with_subscription(
     LSHandle *sh, LSMessage *message, bool subscribed);
-extern gboolean ethernet_technology_status_check(LSHandle *sh, LSMessage *message);
 
 #endif /* _COMMON_H_ */
 
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 30df74c..913651c 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -116,12 +116,6 @@ static bool is_caller_using_new_interface(LSMessage *message)
 	return (g_strcmp0(name, "com.webos.service.connectionmanager") == 0);
 }
 
-static gboolean set_ethernet_tethering_state(bool state)
-{
-	return connman_technology_set_tethering(
-	           connman_manager_find_ethernet_technology(manager), state);
-}
-
 /**
  * @brief Fill in information about the system's connection status
  *
@@ -2487,78 +2481,6 @@ cleanup:
 	return true;
 }
 
-static bool handle_set_ethernet_tethering_command(LSHandle *sh,
-        LSMessage *message, void *context)
-{
-	if (!ethernet_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsed_obj = 0;
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(state,
-	                                     string))  REQUIRED_1(state))), &parsed_obj))
-	{
-		return true;
-	}
-
-	jvalue_ref state_obj = 0;
-	gboolean enable_tethering = FALSE;
-
-	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("state"), &state_obj))
-	{
-		if (jstring_equal2(state_obj, J_CSTR_TO_BUF("enabled")))
-		{
-			enable_tethering = TRUE;
-		}
-		else if (jstring_equal2(state_obj, J_CSTR_TO_BUF("disabled")))
-		{
-			enable_tethering = FALSE;
-		}
-		else
-		{
-			goto invalid_params;
-		}
-
-		if (enable_tethering && is_ethernet_tethering())
-		{
-			LSMessageReplyCustomError(sh, message, "Ethernet tethering already enabled",
-			                          WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_ENABLED);
-			goto cleanup;
-		}
-		else if (!enable_tethering && !is_ethernet_tethering())
-		{
-			LSMessageReplyCustomError(sh, message, "Ethernet tethering already disabled",
-			                          WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_DISABLED);
-			goto cleanup;
-		}
-
-		if (!set_ethernet_tethering_state(enable_tethering))
-		{
-			LSMessageReplyCustomError(sh, message, "Error in setting ethernet tethering",
-			                          WCA_API_ERROR_ETHERNET_TETHERING_SET);
-			goto cleanup;
-		}
-
-		LSMessageReplySuccess(sh, message);
-		goto cleanup;
-	}
-
-invalid_params:
-	LSMessageReplyErrorInvalidParams(sh, message);
-
-cleanup:
-
-	if (!jis_null(parsed_obj))
-	{
-		j_release(&parsed_obj);
-	}
-
-	return true;
-}
-
 static bool handle_set_proxy_command(LSHandle *sh,
         LSMessage *message, void *context)
 {
@@ -2764,7 +2686,6 @@ static LSMethod connectionmanager_methods[] =
 	{ LUNA_METHOD_SETIPV6,              handle_set_ipv6_command },
 	{ LUNA_METHOD_MONITORACTIVITY,      handle_monitor_activity_command },
 	{ LUNA_METHOD_SETTECHNOLOGYSTATE,   handle_set_technology_state_command },
-	{ LUNA_METHOD_SETETHERNETTETHERING, handle_set_ethernet_tethering_command },
 	{ LUNA_METHOD_SETPROXY,             handle_set_proxy_command },
 	{ LUNA_METHOD_FINDPROXYFORURL,      handle_find_proxy_for_url_command },
 	{ },
diff --git a/src/connectionmanager_service.h b/src/connectionmanager_service.h
index da204ad..8a78fb8 100644
--- a/src/connectionmanager_service.h
+++ b/src/connectionmanager_service.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -43,7 +43,6 @@
 #define LUNA_METHOD_GETWOLWOWLSTATUS      "getwolwowlstatus"
 #define LUNA_METHOD_MONITORACTIVITY       "monitorActivity"
 #define LUNA_METHOD_SETTECHNOLOGYSTATE    "setTechnologyState"
-#define LUNA_METHOD_SETETHERNETTETHERING  "setEthernetTethering"
 #define LUNA_METHOD_SETPROXY              "setProxy"
 #define LUNA_METHOD_FINDPROXYFORURL       "findProxyForURL"
 
diff --git a/src/errors.h b/src/errors.h
index 37521f5..41edc42 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -100,10 +100,6 @@
 #define WCA_API_ERROR_FAILED_TO_SET_LISTEN_CHANNEL  164
 #define WCA_API_ERROR_ALREADY_CONNECTED 165
 #define WCA_API_ERROR_HOST_ROUTE_NOT_SET 166
-#define WCA_API_ERROR_ETHERNET_TECHNOLOGY_UNAVAILABLE 167
-#define WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_ENABLED 168
-#define WCA_API_ERROR_ETHERNET_TETHERING_ALREADY_DISABLED 169
-#define WCA_API_ERROR_ETHERNET_TETHERING_SET 170
 #define WCA_API_ERROR_REJECT_PEER 171
 #define WCA_API_ERROR_LISTEN_PARAMS_INVALID_VALUES 172
 #define WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE  173

commit 1babacfd9743f473ead6cb4c895826df5f476791
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Tue Jul 23 17:30:47 2019 +0530

    Removing support for com.webos.service.wan service
    
    :Release Notes:
    Removing com.webos.service.wan service implementation for OSE.
    
    :Detailed Notes:
    Add changes to remove com.webos.service.wan service.
    Since its not required for OSE.
    
    :Testing Performed:
    Build successfully.
    Verified test cases QO-512, QO-3707.
    
    :QA Notes:
    Relates with depends on http://gpro.lge.com/#/c/249142 and
    http://gpro.lge.com/#/c/249143/
    
    :Issues Addressed:
    [PLAT-83205] [OSE Service Name Check] "com.webos.service.wan"
    
    Change-Id: Ib6fa940276138d155ab029cd0e584fa9f81a98d6

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c95aaea..ee85578 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2018 LG Electronics, Inc.
+# Copyright (c) 2012-2019 LG Electronics, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -136,7 +136,6 @@ file(GLOB SOURCE_FILES
     src/wifi_service.c
     src/wifi_setting.c
     src/wifi_scan.c
-    src/wan_service.c
     src/pan_service.c
     src/state_recovery.c
     ${GDBUS_IF_DIR}/connman-interface.c
diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index 6a343ac..91035c4 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -13,12 +13,6 @@
         "com.webos.service.connectionmanager/setProxy",
         "com.webos.service.connectionmanager/setstate",
         "com.webos.service.connectionmanager/setTechnologyState",
-        "com.webos.service.wan/connect",
-        "com.webos.service.wan/disconnect",
-        "com.webos.service.wan/getStatus",
-        "com.webos.service.wan/getContexts",
-        "com.webos.service.wan/getContext",
-        "com.webos.service.wan/setHostRoutes",
         "com.webos.service.wifi/cancel",
         "com.webos.service.wifi/cancelwps",
         "com.webos.service.wifi/changeNetwork",
@@ -52,12 +46,6 @@
         "com.webos.service.connectionmanager/setProxy",
         "com.webos.service.connectionmanager/setstate",
         "com.webos.service.connectionmanager/setTechnologyState",
-        "com.webos.service.wan/connect",
-        "com.webos.service.wan/disconnect",
-        "com.webos.service.wan/getStatus",
-        "com.webos.service.wan/getContexts",
-        "com.webos.service.wan/getContext",
-        "com.webos.service.wan/setHostRoutes",
         "com.webos.service.wifi/cancel",
         "com.webos.service.wifi/cancelwps",
         "com.webos.service.wifi/changeNetwork",
@@ -86,9 +74,6 @@
         "com.webos.service.connectionmanager/getUserStatus",
         "com.webos.service.connectionmanager/getwolwowlstatus",
         "com.webos.service.connectionmanager/monitorActivity",
-        "com.webos.service.wan/getStatus",
-        "com.webos.service.wan/getContexts",
-        "com.webos.service.wan/getContext",
         "com.webos.service.wifi/getstatus",
         "com.webos.service.wifi/getwifidiagnostics"
     ]
diff --git a/files/sysbus/webos-connman-adapter.perm.json b/files/sysbus/webos-connman-adapter.perm.json
index 03a838a..b823bc0 100644
--- a/files/sysbus/webos-connman-adapter.perm.json
+++ b/files/sysbus/webos-connman-adapter.perm.json
@@ -9,11 +9,6 @@
         "devices",
         "networking.internal"
     ],
-    "com.webos.service.wan": [
-        "settings",
-        "devices",
-        "networking.internal"
-    ],
     "com.webos.service.pan": [
         "settings",
         "devices",
diff --git a/files/sysbus/webos-connman-adapter.role.json.in b/files/sysbus/webos-connman-adapter.role.json.in
index 270216a..6fede3a 100644
--- a/files/sysbus/webos-connman-adapter.role.json.in
+++ b/files/sysbus/webos-connman-adapter.role.json.in
@@ -1,7 +1,7 @@
 {
     "exeName":"@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter",
     "type":"regular",
-    "allowedNames":["com.webos.service.wifi", "com.webos.service.connectionmanager", "com.webos.service.wan", "com.webos.service.pan"],
+    "allowedNames":["com.webos.service.wifi", "com.webos.service.connectionmanager", "com.webos.service.pan"],
     "permissions": [
         {
             "service":"com.webos.service.wifi",
@@ -18,13 +18,6 @@
                         "com.webos.service.wifi",
                         "com.webos.service.config"]
         },
-        {
-            "service":"com.webos.service.wan",
-            "outbound":["com.webos.service.pdm",
-                        "com.webos.settingsservice",
-                        "com.webos.service.wifi",
-                        "com.webos.service.config"]
-        },
         {
             "service":"com.webos.service.pan",
             "outbound":["com.webos.service.pdm",
diff --git a/files/sysbus/webos-connman-adapter.service.in b/files/sysbus/webos-connman-adapter.service.in
index caa8971..569fc75 100644
--- a/files/sysbus/webos-connman-adapter.service.in
+++ b/files/sysbus/webos-connman-adapter.service.in
@@ -1,4 +1,4 @@
 [D-BUS Service]
-Name=com.webos.service.wifi;com.webos.service.wan;com.webos.service.connectionmanager;com.webos.service.pan
+Name=com.webos.service.wifi;com.webos.service.connectionmanager;com.webos.service.pan
 Exec="@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter
 Type=static
diff --git a/src/common.c b/src/common.c
index 126f93f..4e9ade3 100644
--- a/src/common.c
+++ b/src/common.c
@@ -150,65 +150,6 @@ gboolean set_wifi_powered_status(gboolean state)
 	return FALSE;
 }
 
-void set_cellular_powered_status(gboolean state)
-{
-	connman_technology_t *cellular_tech = connman_manager_find_cellular_technology(
-	        manager);
-
-	if (!cellular_tech)
-	{
-		return;
-	}
-
-	connman_technology_set_powered(cellular_tech, state, NULL);
-}
-
-/**
-*  @brief Returns true if wan technology is powered on
-*
-*/
-
-gboolean is_cellular_powered(void)
-{
-	connman_technology_t *technology = connman_manager_find_cellular_technology(
-	                                       manager);
-	return (NULL != technology) && technology->powered;
-}
-
-/**
-*  @brief Check if the wan technology is available
-*   Send an error luna message if its not available
-*
-*  @param sh
-*  @param message
-*/
-
-gboolean cellular_technology_status_check(LSHandle *sh, LSMessage *message)
-{
-	if (NULL == connman_manager_find_cellular_technology(manager))
-	{
-		LSMessageReplyCustomError(sh, message, "Cellular technology unavailable",
-		                          WCA_API_ERROR_CELLULAR_TECH_UNAVAILABLE);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-gboolean cellular_technology_status_check_with_subscription(LSHandle *sh,
-        LSMessage *message, bool subscribed)
-{
-	if (NULL == connman_manager_find_cellular_technology(manager))
-	{
-		LSMessageReplyCustomErrorWithSubscription(sh, message,
-		        "Cellular technology unavailable",
-		        WCA_API_ERROR_CELLULAR_TECH_UNAVAILABLE, subscribed);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
 bool is_valid_ipv6address(char *ipAddress)
 {
 	unsigned char ipv6_addr[sizeof(struct in6_addr)];
diff --git a/src/common.h b/src/common.h
index 11596b4..4b0e172 100644
--- a/src/common.h
+++ b/src/common.h
@@ -29,10 +29,7 @@ extern gboolean connman_status_check(connman_manager_t *manager, LSHandle *sh,
                                      LSMessage *message);
 extern gboolean is_wifi_powered(void);
 extern gboolean is_wifi_tethering(void);
-extern gboolean is_cellular_powered(void);
 extern gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message);
-extern gboolean cellular_technology_status_check(LSHandle *sh,
-        LSMessage *message);
 extern gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
                                                         LSMessage *message, bool subscribed);
 extern gboolean connman_status_check_with_subscription(connman_manager_t *manager,
@@ -40,7 +37,6 @@ extern gboolean connman_status_check_with_subscription(connman_manager_t *manage
 extern gboolean set_wifi_powered_status(gboolean state);
 extern const gchar *get_current_system_locale();
 extern void retrieve_system_locale_info(LSHandle *handle);
-extern void set_cellular_powered_status(gboolean state);
 extern gboolean is_bluetooth_powered(void);
 extern gboolean is_bluetooth_tethering(void);
 extern bool is_valid_ipv6address(char *ipAddress);
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 913651c..3083766 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -57,7 +57,6 @@ errorText | Yes | String | Error description
 #include "utils.h"
 #include "nyx.h"
 #include "pacrunner_client.h"
-#include "wan_service.h"
 #include "pan_service.h"
 #include "wifi_setting.h"
 
@@ -77,8 +76,6 @@ gboolean wifi_online_checking_status = FALSE;
 gboolean wired_connected = FALSE;
 gboolean wifi_connected = FALSE;
 gboolean p2p_connected = FALSE;
-gboolean cellular_powered = FALSE;
-gboolean wan_connected = FALSE;
 gboolean pan_connected = FALSE;
 guint block_getstatus_response = 0;
 gboolean old_wifi_tethering = FALSE;
@@ -526,29 +523,6 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed,
 
 	if (with_new_interface)
 	{
-		jvalue_ref cellular_obj = jobject_create();
-		gboolean cellular_enabled = is_cellular_powered();
-
-		jobject_put(cellular_obj, J_CSTR_TO_JVAL("enabled"),
-		            jboolean_create(cellular_enabled));
-		jobject_put(*reply, J_CSTR_TO_JVAL("cellular"), cellular_obj);
-
-		jvalue_ref wan_obj = jobject_create();
-
-		if (cellular_enabled)
-		{
-			append_wan_status(wan_obj);
-		}
-		else
-		{
-			jvalue_ref connected_contexts_obj = jarray_create(NULL);
-			jobject_put(wan_obj, J_CSTR_TO_JVAL("connected"), jboolean_create(false));
-			jobject_put(wan_obj, J_CSTR_TO_JVAL("connectedContexts"),
-			            connected_contexts_obj);
-		}
-
-		jobject_put(*reply, J_CSTR_TO_JVAL("wan"), wan_obj);
-
 		jvalue_ref connected_pan_status = jobject_create();
 		jvalue_ref disconnected_pan_status = jobject_create();
 		jobject_put(disconnected_pan_status, J_CSTR_TO_JVAL("state"),
@@ -709,12 +683,6 @@ static gboolean check_update_is_needed(void)
 
 	p2p_connected = (connected_p2p_service != NULL && manager->groups != NULL);
 
-	if (cellular_powered != is_cellular_powered())
-	{
-		cellular_powered = is_cellular_powered();
-		needed = TRUE;
-	}
-
 	connman_service_t *connected_pan_service =
 	    connman_manager_get_connected_service(manager->bluetooth_services);
 
@@ -725,36 +693,6 @@ static gboolean check_update_is_needed(void)
 
 	pan_connected = (connected_pan_service != NULL);
 
-
-	GSList *iter;
-	guint num_connected = 0;
-
-	for (iter = manager->cellular_services; iter != NULL; iter = iter->next)
-	{
-		connman_service_t *service = iter->data;
-
-		if (!connman_service_is_connected(service))
-		{
-			continue;
-		}
-
-		num_connected++;
-
-		if (check_service_for_update(service, wan_connected || (num_connected > 0)))
-		{
-			needed = TRUE;
-		}
-	}
-
-	gboolean new_wan_connected = (num_connected > 0);
-
-	if (wan_connected != new_wan_connected)
-	{
-		needed = TRUE;
-	}
-
-	wan_connected = new_wan_connected;
-
 	WCALOG_INFO(MSGID_CONNECTION_INFO, 0, "needed: %d",needed);
 
 	return needed;
@@ -836,7 +774,7 @@ void connectionmanager_send_status_to_subscribers(void)
 	jvalue_ref reply = jobject_create();
 	jvalue_ref reply_deprecated = jobject_create();
 	append_connection_status(&reply, true, true);
-	// Same but without mentioning WAN and PAN as we don't support it on the
+	// Same but without mentioning PAN as we don't support it on the
 	// com.webos.service.connectionmanager service face
 	append_connection_status(&reply_deprecated, true, false);
 
@@ -2088,11 +2026,6 @@ static void counter_usage_callback(const gchar *path, GVariant *home,
 	{
 		service = connman_manager_find_service_by_path(manager->wifi_services, path);
 
-		if (NULL == service)
-		{
-			service = connman_manager_find_service_by_path(manager->cellular_services,
-			          path);
-		}
 	}
 
 	if (NULL == service)
@@ -2168,10 +2101,6 @@ static void append_data_activity(jvalue_ref *reply)
 	jobject_put(*reply, J_CSTR_TO_JVAL("wired"), wired_stats);
 	jobject_put(*reply, J_CSTR_TO_JVAL("wifi"), wifi_stats);
 
-	jvalue_ref wan_stats = jobject_create();
-	append_interface_data_activity(&wan_stats, CONNMAN_SERVICE_TYPE_CELLULAR);
-	jobject_put(*reply, J_CSTR_TO_JVAL("wan"), wan_stats);
-
 	memcpy(counter_data_old, counter_data_new, sizeof(counter_data_old));
 	memset(counter_data_new, 0, sizeof(counter_data_new));
 }
diff --git a/src/connman_manager.c b/src/connman_manager.c
index c31095b..866de33 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -112,14 +112,6 @@ static connman_service_t *find_service_from_path(connman_manager_t *manager,
 
 		service = connman_manager_find_service_by_path(manager->bluetooth_services,
 		                                               path);
-
-		if (NULL != service)
-		{
-			return service;
-		}
-
-		service = connman_manager_find_service_by_path(manager->cellular_services,
-		                                               path);
 	}
 
 	return service;
@@ -251,14 +243,6 @@ static gboolean service_on_configured_iface(GVariant *service_v)
 
 				return TRUE;
 			}
-			else if (!g_strcmp0(type, "cellular"))
-			{
-				g_variant_unref(properties);
-				g_variant_unref(property);
-				g_variant_unref(key_v);
-
-				return TRUE;
-			}
 			else if (!g_strcmp0(type, "bluetooth"))
 			{
 				g_variant_unref(properties);
@@ -311,11 +295,6 @@ static void add_service_to_list(connman_manager_t *manager,
 		{
 			manager->p2p_services = g_slist_append(manager->p2p_services, service);
 		}
-		else if (connman_service_type_wan(service))
-		{
-			manager->cellular_services = g_slist_append(manager->cellular_services,
-			                             service);
-		}
 		else if (connman_service_type_bluetooth(service))
 		{
 			manager->bluetooth_services = g_slist_append(manager->bluetooth_services,
@@ -353,9 +332,7 @@ static connman_service_t* update_or_add_service(connman_manager_t *manager,
 	{
 		/* Only in case that the service was added as new one it contains all
 		 * properties and we can check wether it's on one of the supported
-		 * network interfaces. If the service is a cellular one we ignore the
-		 * interface check as the interface is just way to route data and not
-		 * the primary control point. */
+		 * network interfaces. */
 		if (saved || service_on_configured_iface(service_v) == TRUE)
 		{
 			service = connman_service_new(service_v);
@@ -426,10 +403,6 @@ static gboolean connman_manager_update_services(connman_manager_t *manager,
 					*service_type |= P2P_SERVICES_CHANGED;
 					break;
 
-				case CONNMAN_SERVICE_TYPE_CELLULAR:
-					*service_type |= CELLULAR_SERVICES_CHANGED;
-					break;
-
 				case CONNMAN_SERVICE_TYPE_BLUETOOTH:
 					*service_type |= BLUETOOTH_SERVICES_CHANGED;
 					break;
@@ -515,7 +488,7 @@ static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
 	}
 
 	gboolean wifi_services_removed = FALSE, wired_services_removed = FALSE,
-	         p2p_services_removed = FALSE, cellular_services_removed = FALSE,
+	         p2p_services_removed = FALSE,
 	         bluetooth_services_removed = FALSE;
 
 	wifi_services_removed = remove_services_from_list(&manager->wifi_services,
@@ -524,8 +497,6 @@ static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
 	                         services_removed);
 	p2p_services_removed = remove_services_from_list(&manager->p2p_services,
 	                       services_removed);
-	cellular_services_removed = remove_services_from_list(
-	                                &manager->cellular_services, services_removed);
 	bluetooth_services_removed = remove_services_from_list(
 	                                 &manager->bluetooth_services, services_removed);
 
@@ -552,18 +523,13 @@ static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
 		}
 	}
 
-	if (cellular_services_removed)
-	{
-		*service_type |= CELLULAR_SERVICES_CHANGED;
-	}
-
 	if (bluetooth_services_removed)
 	{
 		*service_type |= BLUETOOTH_SERVICES_CHANGED;
 	}
 
 	return (wifi_services_removed | wired_services_removed | p2p_services_removed |
-	        cellular_services_removed | bluetooth_services_removed);
+	        bluetooth_services_removed);
 }
 
 /**
@@ -592,10 +558,6 @@ static void connman_manager_free_services(connman_manager_t *manager)
 	g_slist_free(manager->p2p_services);
 	manager->p2p_services = NULL;
 
-	g_slist_foreach(manager->cellular_services, (GFunc) connman_service_free, NULL);
-	g_slist_free(manager->cellular_services);
-	manager->cellular_services = NULL;
-
 	g_slist_foreach(manager->bluetooth_services, (GFunc) connman_service_free,
 	                NULL);
 	g_slist_free(manager->bluetooth_services);
@@ -1340,39 +1302,6 @@ connman_technology_t *connman_manager_find_ethernet_technology(
 	return NULL;
 }
 
-/**
- * Go through the manager's technologies list and get the cellular one
- * (see header for API details)
- */
-
-connman_technology_t *connman_manager_find_cellular_technology(
-    connman_manager_t *manager)
-{
-	if (NULL == manager)
-	{
-		return NULL;
-	}
-
-	GSList *iter;
-
-	for (iter = manager->technologies; NULL != iter; iter = iter->next)
-	{
-		connman_technology_t *tech = (struct connman_technology *)(iter->data);
-
-		if (!tech)
-		{
-			continue;
-		}
-
-		if (g_strcmp0("cellular", tech->type) == 0)
-		{
-			return tech;
-		}
-	}
-
-	return NULL;
-}
-
 /**
  * Go through the manager's technologies list and get the bluetooth one
  * (see header for API details)
@@ -1952,10 +1881,6 @@ connman_manager_t *connman_manager_new(void)
 	             g_slist_length(manager->wifi_services),
 	             g_slist_length(manager->technologies));
 
-	WCALOG_DEBUG("%d cellular services, %d technologies",
-	             g_slist_length(manager->cellular_services),
-	             g_slist_length(manager->technologies));
-
 	WCALOG_DEBUG("%d bluetooth services, %d technologies",
 	             g_slist_length(manager->bluetooth_services),
 	             g_slist_length(manager->technologies));
diff --git a/src/connman_manager.h b/src/connman_manager.h
index aae53e9..7c20501 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2018 LG Electronics, Inc.
+// Copyright (c) 2013-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -34,7 +34,6 @@
 #define ETHERNET_SERVICES_CHANGED   1
 #define WIFI_SERVICES_CHANGED       2
 #define P2P_SERVICES_CHANGED        4
-#define CELLULAR_SERVICES_CHANGED   8
 #define BLUETOOTH_SERVICES_CHANGED  16
 
 /**
@@ -65,7 +64,6 @@ typedef struct connman_manager
 	GSList  *wifi_services;
 	GSList  *wired_services;
 	GSList  *p2p_services;
-	GSList  *cellular_services;
 	GSList  *bluetooth_services;
 	GSList  *saved_services;
 	GSList  *technologies;
@@ -156,16 +154,6 @@ extern connman_technology_t *connman_manager_find_wifi_technology(
 extern connman_technology_t *connman_manager_find_ethernet_technology(
     connman_manager_t *manager);
 
-/**
-* Go through the manager's technologies list and get the technology with type "cellular"
-*
-* @param[IN]  manager A manager instance
-*
-* @return Technology with type "cellular"
-*/
-extern connman_technology_t *connman_manager_find_cellular_technology(
-    connman_manager_t *manager);
-
 /**
 * Go through the manager's technologies list and get the technology with type "bluetooth"
 *
diff --git a/src/connman_service.c b/src/connman_service.c
index 3aeb41e..504403e 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -58,15 +58,6 @@ gboolean connman_service_type_p2p(connman_service_t *service)
 	return (NULL != service) && (CONNMAN_SERVICE_TYPE_P2P == service->type);
 }
 
-/**
-* Check if the type of the service is wan (see header for API details)
-*/
-
-gboolean connman_service_type_wan(connman_service_t *service)
-{
-	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_CELLULAR);
-}
-
 /**
 * Check if the type of the service is bluetooth (see header for API details)
 */
@@ -76,35 +67,6 @@ gboolean connman_service_type_bluetooth(connman_service_t *service)
 	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_BLUETOOTH);
 }
 
-/**
- * @brief Gets hostroutes for the connman service
- */
-
-gboolean connman_service_set_hostroutes(connman_service_t *service,
-                                        GStrv hostroutes)
-{
-	if (NULL == service || NULL == hostroutes)
-	{
-		return FALSE;
-	}
-
-	GError *error = NULL;
-
-	connman_interface_service_call_set_property_sync(service->remote,
-	        "HostRoutes.Configuration",
-	        g_variant_new_variant(g_variant_new_strv((const gchar * const *)hostroutes,
-	                              g_strv_length(hostroutes))), NULL, &error);
-
-	if (error)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_WAN_SET_HOSTROUTE_ERROR, error->message);
-		g_error_free(error);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
 /**
  * Map the service connection status to corresponding webos state
  * (see header for API details)
@@ -889,18 +851,6 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 			g_variant_unref(va);
 		}
 
-		if (!g_strcmp0(key, "HostRoutes"))
-		{
-			GVariant *v = g_variant_get_child_value(property, 1);
-			GVariant *va = g_variant_get_child_value(v, 0);
-
-			g_strfreev(service->hostroutes);
-			service->hostroutes = g_variant_dup_strv(va, NULL);
-
-			g_variant_unref(v);
-			g_variant_unref(va);
-		}
-
 		g_variant_unref(property);
 		g_variant_unref(key_v);
 	}
@@ -1395,10 +1345,6 @@ void connman_service_update_properties(connman_service_t *service,
 			{
 				service->type = CONNMAN_SERVICE_TYPE_P2P;
 			}
-			else if (!g_strcmp0(v, "cellular"))
-			{
-				service->type = CONNMAN_SERVICE_TYPE_CELLULAR;
-			}
 			else if (!g_strcmp0(v, "bluetooth"))
 			{
 				service->type = CONNMAN_SERVICE_TYPE_BLUETOOTH;
@@ -1673,9 +1619,6 @@ void connman_service_free(gpointer data, gpointer user_data)
 	g_strfreev(service->proxyinfo.excludes);
 
 
-	g_strfreev(service->hostroutes);
-	service->hostroutes = NULL;
-
 	g_free(service->peer.address);
 	g_free(service->peer.service_discovery_response);
 
diff --git a/src/connman_service.h b/src/connman_service.h
index ce8d3aa..a73319b 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -142,7 +142,6 @@ typedef struct connman_service
 	gint type;
 	ipinfo_t ipinfo;
 	proxyinfo_t proxyinfo;
-	GStrv hostroutes;
 	gulong sighandler_id;
 	peer_t peer;
 
@@ -176,7 +175,6 @@ typedef enum
 	CONNMAN_SERVICE_TYPE_ETHERNET,
 	CONNMAN_SERVICE_TYPE_WIFI,
 	CONNMAN_SERVICE_TYPE_P2P,
-	CONNMAN_SERVICE_TYPE_CELLULAR,
 	CONNMAN_SERVICE_TYPE_BLUETOOTH,
 	CONNMAN_SERVICE_TYPE_MAX
 } connman_service_types;
@@ -233,15 +231,6 @@ extern gboolean connman_service_type_ethernet(connman_service_t *service);
  */
 extern gboolean connman_service_type_p2p(connman_service_t *service);
 
-/**
-* Check if the type of the service is wan
-*
-* @param[IN]  service A service instance
-*
-* @return TRUE if the service has "wan" type
-*/
-extern gboolean connman_service_type_wan(connman_service_t *service);
-
 /**
 * Check if the type of the service is bluetooth
 *
@@ -425,14 +414,6 @@ extern void connman_service_register_property_changed_cb(
 extern void connman_service_register_p2p_requests_cb(connman_service_t *service,
         connman_p2p_request_cb func);
 
-/**
- * Gets hostroutes for the connman service
- *
- * @param[IN] service A service instance
- * @param[IN] hostroutes Hostroutes
- */
-gboolean connman_service_set_hostroutes(connman_service_t *service, GStrv hostroutes);
-
 /**
  * Create a new connman service instance and set its properties
  *
diff --git a/src/errors.h b/src/errors.h
index 41edc42..e1de27d 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -23,9 +23,7 @@
 #define WCA_API_ERROR_INVALID_PARAMETERS    3
 #define WCA_API_ERROR_CONNMAN_UNAVAILABLE   4
 #define WCA_API_ERROR_WIFI_TECH_UNAVAILABLE 5
-#define WCA_API_ERROR_CELLULAR_TECH_UNAVAILABLE 6
 #define WCA_API_ERROR_WIFI_SWITCHED_OFF     7
-#define WCA_API_ERROR_WAN_SWITCHED_OFF      8
 #define WCA_API_ERROR_SCHEMA_VALIDATION     9
 
 #define WCA_API_ERROR_INVALID_KEY       10
@@ -99,7 +97,6 @@
 #define WCA_API_ERROR_FAILED_TO_ENABLE_DISABLE_TECHNOLOGIES 163
 #define WCA_API_ERROR_FAILED_TO_SET_LISTEN_CHANNEL  164
 #define WCA_API_ERROR_ALREADY_CONNECTED 165
-#define WCA_API_ERROR_HOST_ROUTE_NOT_SET 166
 #define WCA_API_ERROR_REJECT_PEER 171
 #define WCA_API_ERROR_LISTEN_PARAMS_INVALID_VALUES 172
 #define WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE  173
diff --git a/src/logging.h b/src/logging.h
index a105e0f..c6f6185 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -63,10 +63,8 @@ extern PmLogContext gLogContext;
 /** common ones */
 #define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
 #define MSGID_CM_SRVC_REGISTER_FAIL                     "WIFI_CM_REGISTER_FAIL"
-#define MSGID_WAN_SRVC_REGISTER_FAIL                    "WAN_SRVC_REGISTER_FAIL"
 #define MSGID_PAN_SRVC_REGISTER_FAIL                    "PAN_SRVC_REGISTER_FAIL"
 
-#define MSGID_WAN_SRVC_ALLOC_FAIL                       "WAN_SRVC_ALLOC_FAIL"
 #define MSGID_INVALID_STATE                             "INVALID_STATE"
 
 /** main.c */
@@ -235,11 +233,6 @@ extern PmLogContext gLogContext;
 #define MSGID_NYX_DEVICE_CLOSE_ERROR                    "NYX_DEVICE_CLOSE_ERROR"
 #define MSGID_NYX_DEINIT_ERROR                          "NYX_DEINIT_ERROR"
 
-/** Wan info codes **/
-#define MSGID_WAN_CONNECT_INFO                          "WAN_CONNECT_INFO"
-#define MSGID_WAN_DISCONNECT_INFO                       "WAN_DISCONNECT_INFO"
-#define MSGID_WAN_SET_HOSTROUTE_ERROR                   "WAN_SET_HOSTROUTE_ERR"
-
 /** json_utils.c **/
 #define MSGID_JSON_KEY_NULL                             "JSON_KEY_NULL"
 #define MSGID_JSON_DEST_NULL                            "JSON_DEST_NULL"
diff --git a/src/main.c b/src/main.c
index 0c998b5..c34538f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -36,7 +36,6 @@
 #include "logging.h"
 #include "wifi_service.h"
 #include "wifi_setting.h"
-#include "wan_service.h"
 #include "pan_service.h"
 #include "connectionmanager_service.h"
 #include "nyx.h"
@@ -61,7 +60,7 @@ term_handler(int signal)
 int
 main(int argc, char **argv)
 {
-	LSHandle *wifi_handle, *wan_handle, *cm_handle, *pan_handle;
+	LSHandle *wifi_handle, *cm_handle, *pan_handle;
 	signal(SIGTERM, term_handler);
 	signal(SIGINT, term_handler);
 
@@ -85,16 +84,9 @@ main(int argc, char **argv)
 		return -1;
 	}
 
-	if (initialize_wan_ls2_calls(mainloop, &wan_handle) < 0)
-	{
-		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
-		             "Error in initializing com.webos.service.wan service");
-		return -1;
-	}
-
 	if (initialize_pan_ls2_calls(mainloop, &pan_handle) < 0)
 	{
-		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
+		WCALOG_ERROR(MSGID_PAN_SRVC_REGISTER_FAIL, 0,
 		             "Error in initializing com.webos.serivce.pan service");
 		return -1;
 	}
@@ -108,7 +100,7 @@ main(int argc, char **argv)
 
 	wca_support_connman_update_callbacks wca_support_library_cb = { 0 };
 
-	if (wca_support_init(wifi_handle, cm_handle, wan_handle,
+	if (wca_support_init(wifi_handle, cm_handle,
 	                     &wca_support_library_cb, NULL, &gLogContext) < 0)
 	{
 		WCALOG_ERROR(MSGID_WCA_SUPPORT_FAIL, 0,
diff --git a/src/wan_service.c b/src/wan_service.c
deleted file mode 100644
index 2468a33..0000000
--- a/src/wan_service.c
+++ /dev/null
@@ -1,996 +0,0 @@
-// Copyright (c) 2013-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-#include <glib.h>
-#include <stdbool.h>
-#include <time.h>
-#include <string.h>
-#include <pbnjson.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <linux/if.h>
-
-#include "wan_service.h"
-#include "connman_manager.h"
-#include "connman_agent.h"
-#include "connman_service.h"
-#include "lunaservice_utils.h"
-#include "common.h"
-#include "connectionmanager_service.h"
-#include "logging.h"
-#include "errors.h"
-
-static LSHandle *pLsHandle;
-
-extern connman_manager_t *manager;
-extern connman_agent_t *agent;
-
-static void service_changed_cb(gpointer user_data, const gchar *name,
-                               GVariant *value)
-{
-	connectionmanager_send_status_to_subscribers();
-}
-
-static void retrieve_wan_context(jvalue_ref context_obj,
-                                 connman_service_t *service)
-{
-	jvalue_ref ipv4_obj, ipv6_obj, dns_obj, hosts_obj;
-	int i;
-
-	jobject_put(context_obj, J_CSTR_TO_JVAL("name"), jstring_create(service->name));
-	jobject_put(context_obj, J_CSTR_TO_JVAL("connected"),
-	            jboolean_create(connman_service_is_connected(service)));
-	jobject_put(context_obj, J_CSTR_TO_JVAL("onInternet"),
-	            jboolean_create(connman_service_is_online(service)));
-
-	if (service->ipinfo.iface)
-	{
-		jobject_put(context_obj, J_CSTR_TO_JVAL("interface"),
-		            jstring_create(service->ipinfo.iface));
-	}
-
-	ipv4_obj = jobject_create();
-
-	if (service->ipinfo.ipv4.address)
-	{
-		jobject_put(ipv4_obj, J_CSTR_TO_JVAL("address"),
-		            jstring_create(service->ipinfo.ipv4.address));
-	}
-
-	if (service->ipinfo.ipv4.netmask)
-	{
-		jobject_put(ipv4_obj, J_CSTR_TO_JVAL("subnet"),
-		            jstring_create(service->ipinfo.ipv4.netmask));
-	}
-
-	if (service->ipinfo.ipv4.gateway)
-	{
-		jobject_put(ipv4_obj, J_CSTR_TO_JVAL("gateway"),
-		            jstring_create(service->ipinfo.ipv4.gateway));
-	}
-
-	if (jobject_size(ipv4_obj) > 0)
-	{
-		jobject_put(context_obj, J_CSTR_TO_JVAL("ipv4"), ipv4_obj);
-	}
-	else
-	{
-		j_release(&ipv4_obj);
-	}
-
-	ipv6_obj = jobject_create();
-
-	if (service->ipinfo.ipv6.address)
-	{
-		jobject_put(ipv6_obj, J_CSTR_TO_JVAL("address"),
-		            jstring_create(service->ipinfo.ipv6.address));
-	}
-
-	if (service->ipinfo.ipv6.prefix_length > 0)
-	{
-		jobject_put(ipv6_obj, J_CSTR_TO_JVAL("prefixLength"),
-		            jnumber_create_i32(service->ipinfo.ipv6.prefix_length));
-	}
-
-	if (service->ipinfo.ipv6.gateway)
-	{
-		jobject_put(ipv6_obj, J_CSTR_TO_JVAL("gateway"),
-		            jstring_create(service->ipinfo.ipv6.gateway));
-	}
-
-	if (jobject_size(ipv6_obj) > 0)
-	{
-		jobject_put(context_obj, J_CSTR_TO_JVAL("ipv6"), ipv6_obj);
-	}
-	else
-	{
-		j_release(&ipv6_obj);
-	}
-
-	dns_obj = jarray_create(NULL);
-
-	if (service->ipinfo.dns)
-	{
-		for (i = 0; i < g_strv_length(service->ipinfo.dns); i++)
-		{
-			jarray_append(dns_obj, jstring_create(service->ipinfo.dns[i]));
-		}
-	}
-
-	jobject_put(context_obj, J_CSTR_TO_JVAL("dns"), dns_obj);
-
-	hosts_obj = jarray_create(NULL);
-
-	for (i = 0; i < g_strv_length(service->hostroutes); i++)
-	{
-		jarray_append(hosts_obj, jstring_create(service->hostroutes[i]));
-	}
-
-	jobject_put(context_obj, J_CSTR_TO_JVAL("hosts"), hosts_obj);
-
-}
-static void append_context(jvalue_ref contexts_obj, connman_service_t *service)
-{
-	if (!jis_array(contexts_obj))
-	{
-		return;
-	}
-
-	jvalue_ref context_obj = jobject_create();
-
-	retrieve_wan_context(context_obj, service);
-
-	jarray_append(contexts_obj, context_obj);
-}
-
-void append_wan_status(jvalue_ref reply_obj)
-{
-	GSList *iter;
-	connman_service_t *service = NULL;
-	bool connected = false;
-	bool online = false;
-	jvalue_ref connected_contexts_obj;
-
-	if (!reply_obj)
-	{
-		return;
-	}
-
-	connected_contexts_obj = jarray_create(NULL);
-
-	for (iter = manager->cellular_services; NULL != iter; iter = iter->next)
-	{
-		service = (connman_service_t *)(iter->data);
-
-		if (!connman_service_is_connected(service))
-		{
-			continue;
-		}
-
-		connected = TRUE;
-
-		if (connman_service_is_online(service))
-		{
-			online = true;
-		}
-
-		connman_service_get_ipinfo(service);
-
-		append_context(connected_contexts_obj, service);
-	}
-
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("onInternet"), jboolean_create(online));
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("connected"), jboolean_create(connected));
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("connectedContexts"),
-	            connected_contexts_obj);
-}
-
-void send_wan_connection_status_to_subscribers()
-{
-	jvalue_ref reply = jobject_create();
-
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
-
-	append_wan_status(reply);
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (response_schema)
-	{
-		const char *payload = jvalue_tostring(reply, response_schema);
-
-		LSError lserror;
-		LSErrorInit(&lserror);
-
-		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_WAN_GETSTATUS, payload, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-
-		jschema_release(&response_schema);
-	}
-
-	j_release(&reply);
-}
-
-static void append_contexts(jvalue_ref reply_obj)
-{
-	connman_service_t *service;
-	GSList *iter;
-
-	jvalue_ref contexts_obj = jarray_create(NULL);
-
-	for (iter = manager->cellular_services; NULL != iter; iter = iter->next)
-	{
-		service = (connman_service_t *) iter->data;
-
-		connman_service_get_ipinfo(service);
-
-		append_context(contexts_obj, service);
-	}
-
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("contexts"), contexts_obj);
-}
-
-void send_wan_contexts_update_to_subscribers()
-{
-	jvalue_ref reply_obj = jobject_create();
-
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
-
-	append_contexts(reply_obj);
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (response_schema)
-	{
-		const char *payload = jvalue_tostring(reply_obj, response_schema);
-
-		LSError lserror;
-		LSErrorInit(&lserror);
-
-		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_WAN_GETCONTEXTS, payload, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-
-		jschema_release(&response_schema);
-	}
-
-	j_release(&reply_obj);
-}
-
-static void service_connect_callback(gboolean success, gpointer user_data)
-{
-	luna_service_request_t *service_req = user_data;
-	connman_service_t *service = service_req->user_data;
-
-	if (!success)
-	{
-		LSMessageReplyCustomError(service_req->handle, service_req->message,
-		                          "Failed to connect cellular service", WCA_API_ERROR_FAILED_TO_CONNECT);
-		goto cleanup;
-	}
-
-	LSMessageReplySuccess(service_req->handle, service_req->message);
-
-	connman_service_register_property_changed_cb(service, service_changed_cb);
-
-cleanup:
-	luna_service_request_free(service_req);
-}
-
-
-static void connect_wan_service(const char *name,
-                                luna_service_request_t *service_req)
-{
-	GSList *iter;
-	gboolean found_service = FALSE;
-	connman_service_t *service = NULL;
-
-	if (!name)
-	{
-		LSMessageReplyErrorInvalidParams(service_req->handle, service_req->message);
-		goto cleanup;
-	}
-
-	for (iter = manager->cellular_services; NULL != iter ; iter = iter->next)
-	{
-		service = (connman_service_t *) iter->data;
-
-		if (g_strcmp0(service->name, name) == 0)
-		{
-			WCALOG_INFO(MSGID_WAN_CONNECT_INFO, 0, "Connecting to cellular service %s",
-			            service->name);
-			found_service = TRUE;
-			break;
-		}
-	}
-
-	if (!found_service)
-	{
-		LSMessageReplyCustomError(service_req->handle, service_req->message,
-		                          "Cellular service not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
-		goto cleanup;
-	}
-
-	service_req->user_data = service;
-
-	if (!connman_service_connect(service, service_connect_callback, service_req))
-	{
-		LSMessageReplyErrorUnknown(service_req->handle, service_req->message);
-		goto cleanup;
-	}
-
-	return;
-
-cleanup:
-	luna_service_request_free(service_req);
-}
-
-
-static void disconnect_wan_service(const char *name, LSHandle *handle,
-                                   LSMessage *message)
-{
-	GSList *iter;
-	gboolean found_service = FALSE;
-	connman_service_t *service = NULL;
-
-	if (!name)
-	{
-		LSMessageReplyErrorInvalidParams(handle, message);
-		return;
-	}
-
-	/* Look up for the service with the given type */
-	for (iter = manager->cellular_services; NULL != iter ; iter = iter->next)
-	{
-		service = (connman_service_t *) iter->data;
-
-		if (g_strcmp0(service->name, name) == 0)
-		{
-			WCALOG_INFO(MSGID_WAN_DISCONNECT_INFO, 0,
-			            "Disconnecting from cellular service %s", service->name);
-			found_service = TRUE;
-			break;
-		}
-	}
-
-	if (!found_service)
-	{
-		LSMessageReplyCustomError(handle, message,
-		                          "Cellular service not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
-		return;
-	}
-
-	if (!connman_service_disconnect(service))
-	{
-		LSMessageReplyErrorUnknown(handle, message);
-		return;
-	}
-
-	LSMessageReplySuccess(handle, message);
-}
-
-static void technology_property_changed_callback(gpointer data,
-        const gchar *property, GVariant *value)
-{
-	connman_technology_t *technology = (connman_technology_t *)data;
-
-	if (NULL == technology)
-	{
-		return;
-	}
-
-	WCALOG_DEBUG("WAN technology: property [%s] changed", property);
-
-	if ((technology == connman_manager_find_cellular_technology(manager)) &&
-	        (g_strcmp0(property, "Powered") == 0 || g_strcmp0(property, "Connected") == 0))
-	{
-		send_wan_connection_status_to_subscribers();
-		connectionmanager_send_status_to_subscribers();
-	}
-}
-
-/**
- * @brief The connect method connects to a single context which is specified by its name.
- *
- * @param name Name of the context to connect to.
- */
-
-static bool handle_wan_connect_command(LSHandle *sh, LSMessage *message,
-                                       void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!cellular_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (!is_cellular_powered())
-	{
-		LSMessageReplyCustomError(sh, message, "WAN switched off",
-		                          WCA_API_ERROR_WAN_SWITCHED_OFF);
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsed_obj = 0;
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(name, string))  REQUIRED_1(name))),
-	                             &parsed_obj))
-	{
-		return true;
-	}
-
-	luna_service_request_t *service_req;
-	jvalue_ref name_obj = 0;
-	char *name = NULL;
-
-	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
-	{
-		raw_buffer name_buf = jstring_get(name_obj);
-		name = g_strdup(name_buf.m_str);
-		jstring_free_buffer(name_buf);
-	}
-
-	if (name == NULL || strlen(name) == 0)
-	{
-		LSMessageReplyErrorInvalidParams(sh, message);
-		goto cleanup;
-	}
-
-	service_req = luna_service_request_new(sh, message);
-
-	connect_wan_service(name, service_req);
-
-cleanup:
-
-	if (!jis_null(parsed_obj))
-	{
-		j_release(&parsed_obj);
-	}
-
-	g_free(name);
-
-	return true;
-}
-
-/**
- * @brief The disconnect method disconnects a single context which is specified by its name.
- *
- * @param name Name of the context to disconnect
- */
-
-static bool handle_wan_disconnect_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!cellular_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (!is_cellular_powered())
-	{
-		LSMessageReplyCustomError(sh, message, "WAN switched off",
-		                          WCA_API_ERROR_WAN_SWITCHED_OFF);
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsed_obj = 0;
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(name, string))  REQUIRED_1(name))),
-	                             &parsed_obj))
-	{
-		return true;
-	}
-
-	jvalue_ref name_obj = 0;
-	char *name = NULL;
-
-	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
-	{
-		raw_buffer name_buf = jstring_get(name_obj);
-		name = g_strdup(name_buf.m_str);
-		jstring_free_buffer(name_buf);
-	}
-
-	if (name == NULL || strlen(name) == 0)
-	{
-		LSMessageReplyErrorInvalidParams(sh, message);
-		goto cleanup;
-	}
-
-	disconnect_wan_service(name, sh, message);
-
-cleanup:
-
-	if (!jis_null(parsed_obj))
-	{
-		j_release(&parsed_obj);
-	}
-
-	g_free(name);
-
-	return true;
-}
-
-/**
- * @brief Reports the current WAN status to the caller.
- *
- * @param subscribe To be notified of any status changes, set subscribe to true
- */
-
-static bool handle_wan_get_status_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	jvalue_ref parsedObj = {0};
-
-	if (!LSMessageValidateSchema(sh, message,
-                                     j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
-	{
-                return true;
-	}
-
-	jvalue_ref reply_obj = 0;
-	LSError lserror;
-	LSErrorInit(&lserror);
-	bool subscribed = false;
-
-	reply_obj = jobject_create();
-
-	if (LSMessageIsSubscription(message))
-	{
-		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	if (!cellular_technology_status_check_with_subscription(sh, message,
-		subscribed))
-	{
-		goto cleanup;
-	}
-
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("subscribed"),
-	            jboolean_create(subscribed));
-
-	append_wan_status(reply_obj);
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, jschema_all()),
-	                    &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-cleanup:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	j_release(&reply_obj);
-	j_release(&parsedObj);
-
-	return true;
-}
-
-/**
- * @brief  Lists all available contexts
- *
- * @param subscribe To be notified of any status changes, set subscribe to true
- */
-
-static bool handle_wan_get_contexts_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	jvalue_ref parsedObj = {0};
-
-	if (!LSMessageValidateSchema(sh, message,
-                                     j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
-	{
-                return true;
-	}
-
-	jvalue_ref reply_obj = 0;
-	LSError lserror;
-	LSErrorInit(&lserror);
-	bool subscribed = false;
-
-	reply_obj = jobject_create();
-
-	if (LSMessageIsSubscription(message))
-	{
-		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	if (!cellular_technology_status_check_with_subscription(sh, message,
-	        subscribed))
-	{
-		goto cleanup;
-	}
-
-
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("subscribed"),
-	            jboolean_create(subscribed));
-
-	append_contexts(reply_obj);
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, jschema_all()),
-	                    &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-cleanup:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	j_release(&reply_obj);
-	j_release(&parsedObj);
-
-	return true;
-}
-
-/**
- * @brief  Get information of a given context
- *
- * @param name name of the context
- */
-
-static bool handle_wan_get_context_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!cellular_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsed_obj = 0;
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(name, string)) REQUIRED_1(name))),
-	                             &parsed_obj))
-	{
-		return true;
-	}
-
-	jvalue_ref reply_obj = 0;
-	jvalue_ref name_obj = 0;
-	LSError lserror;
-	LSErrorInit(&lserror);
-	bool found_service = FALSE;
-	GSList *iter;
-	char *name = NULL;
-	connman_service_t *service = NULL;
-
-	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
-	{
-		raw_buffer name_buf = jstring_get(name_obj);
-		name = g_strdup(name_buf.m_str);
-		jstring_free_buffer(name_buf);
-	}
-
-	reply_obj = jobject_create();
-
-	jobject_put(reply_obj, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-
-	for (iter = manager->cellular_services; NULL != iter; iter = iter->next)
-	{
-		service = (connman_service_t *) iter->data;
-
-		if (g_strcmp0(service->name, name) == 0)
-		{
-			connman_service_get_ipinfo(service);
-			jvalue_ref wan_context_obj = jobject_create();
-			retrieve_wan_context(wan_context_obj, service);
-			jobject_put(reply_obj, J_CSTR_TO_JVAL("contextInfo"), wan_context_obj);
-			found_service = TRUE;
-			break;
-		}
-	}
-
-	if (!found_service)
-	{
-		LSMessageReplyCustomError(sh, message, "Cellular service not found",
-		                          WCA_API_ERROR_NETWORK_NOT_FOUND);
-		goto cleanup;
-	}
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply_obj, jschema_all()),
-                            &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-cleanup:
-
-	if (!jis_null(reply_obj))
-	{
-		j_release(&reply_obj);
-	}
-
-	if (!jis_null(parsed_obj))
-	{
-		j_release(&parsed_obj);
-	}
-
-	g_free(name);
-
-	return true;
-}
-
-/**
- * @brief  Set static host routing for a given context
- *
- * @param name  name of the context
- * @param hosts an array of host IP address to setup static route
- */
-
-static bool handle_set_hostroutes_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!cellular_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (!is_cellular_powered())
-	{
-		LSMessageReplyCustomError(sh, message, "WAN switched off",
-		                          WCA_API_ERROR_WAN_SWITCHED_OFF);
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsed_obj = 0;
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(ARRAY(hosts, string), PROP(name, string))
-	                                     REQUIRED_2(name, hosts))), &parsed_obj))
-	{
-		return true;
-	}
-
-	GStrv hosts = NULL;
-	jvalue_ref name_obj = 0;
-	jvalue_ref hosts_obj = 0;
-	char *name = NULL;
-	GSList *iter;
-	gboolean found_service = false;
-	connman_service_t *service = NULL;
-
-	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("name"), &name_obj))
-	{
-		raw_buffer name_buf = jstring_get(name_obj);
-		name = g_strdup(name_buf.m_str);
-		jstring_free_buffer(name_buf);
-	}
-
-	if (jobject_get_exists(parsed_obj, J_CSTR_TO_BUF("hosts"), &hosts_obj))
-	{
-		int i, host_arrsize = jarray_size(hosts_obj);
-		hosts = (GStrv) g_new0(GStrv, host_arrsize + 1);
-
-		for (i = 0; i < host_arrsize; i++)
-		{
-			raw_buffer host_buf = jstring_get(jarray_get(hosts_obj, i));
-			hosts[i] = g_strdup(host_buf.m_str);
-			jstring_free_buffer(host_buf);
-
-			if (!(is_valid_ipaddress(hosts[i]) || is_valid_ipv6address(hosts[i])))
-			{
-				LSMessageReplyErrorInvalidParams(sh, message);
-				goto cleanup;
-			}
-		}
-	}
-
-	/* Look up for the service with the given type */
-	for (iter = manager->cellular_services; NULL != iter ; iter = iter->next)
-	{
-		service = (connman_service_t *) iter->data;
-
-		if (g_strcmp0(service->name, name) == 0)
-		{
-			WCALOG_DEBUG("Setting host route for service %s", service->name);
-			found_service = true;
-			break;
-		}
-	}
-
-	if (!found_service)
-	{
-		LSMessageReplyCustomError(sh, message,
-		                          "Cellular service not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
-		goto cleanup;
-	}
-
-	if (connman_service_set_hostroutes(service, hosts))
-	{
-		LSMessageReplySuccess(sh, message);
-	}
-	else
-	{
-		LSMessageReplyCustomError(sh, message, "Hosts could not be set as static route",
-		                          WCA_API_ERROR_HOST_ROUTE_NOT_SET);
-	}
-
-cleanup:
-
-	if (!jis_null(parsed_obj))
-	{
-		j_release(&parsed_obj);
-	}
-
-	g_free(name);
-	g_strfreev(hosts);
-
-	return true;
-}
-
-static LSMethod wan_methods[] =
-{
-	{ LUNA_METHOD_WAN_CONNECT,       handle_wan_connect_command },
-	{ LUNA_METHOD_WAN_DISCONNECT,    handle_wan_disconnect_command },
-	{ LUNA_METHOD_WAN_GETSTATUS,     handle_wan_get_status_command },
-	{ LUNA_METHOD_WAN_GETCONTEXTS,   handle_wan_get_contexts_command },
-	{ LUNA_METHOD_WAN_GETCONTEXT,    handle_wan_get_context_command },
-	{ LUNA_METHOD_WAN_SETHOSTROUTES, handle_set_hostroutes_command },
-	{ },
-};
-
-int initialize_wan_ls2_calls(GMainLoop *mainloop, LSHandle **wan_handle)
-{
-	LSError lserror;
-	LSErrorInit(&lserror);
-	pLsHandle = NULL;
-
-	if (NULL == mainloop)
-	{
-		goto Exit;
-	}
-
-	if (LSRegister(WAN_LUNA_SERVICE_NAME, &pLsHandle, &lserror) == false)
-	{
-		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
-		             "LSRegister() returned error");
-		goto Exit;
-	}
-
-	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_ROOT, wan_methods, NULL, NULL,
-	                       &lserror) == false)
-	{
-		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
-		             "LSRegisterCategory() returned error");
-		goto Exit;
-	}
-
-	if (LSGmainAttach(pLsHandle, mainloop, &lserror) == false)
-	{
-		WCALOG_ERROR(MSGID_WAN_SRVC_REGISTER_FAIL, 0,
-		             "LSGmainAttach() returned error");
-		goto Exit;
-	}
-
-	*wan_handle = pLsHandle;
-
-	return 0;
-
-Exit:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	if (pLsHandle)
-	{
-		LSErrorInit(&lserror);
-
-		if (LSUnregister(pLsHandle, &lserror) == false)
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	return -1;
-}
-
-void check_and_initialize_cellular_technology(void)
-{
-	connman_technology_t *technology = connman_manager_find_cellular_technology(
-	                                       manager);
-
-	if (!technology)
-	{
-		return;
-	}
-
-	connman_technology_register_property_changed_cb(technology,
-	        technology_property_changed_callback);
-
-	/* Register property change callback for all connected cellular services */
-	GSList *iter;
-
-	for (iter = manager->cellular_services; iter != NULL; iter = iter->next)
-	{
-		connman_service_t *service = iter->data;
-
-		if (!connman_service_is_connected(service))
-		{
-			continue;
-		}
-
-		connman_service_register_property_changed_cb(service, service_changed_cb);
-	}
-}
diff --git a/src/wan_service.h b/src/wan_service.h
deleted file mode 100644
index d94595d..0000000
--- a/src/wan_service.h
+++ /dev/null
@@ -1,39 +0,0 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-#ifndef _WAN_SERVICE_H_
-#define _WAN_SERVICE_H_
-
-#include <luna-service2/lunaservice.h>
-
-#define WAN_LUNA_SERVICE_NAME "com.webos.service.wan"
-
-#define LUNA_CATEGORY_ROOT            "/"
-
-#define LUNA_METHOD_WAN_CONNECT       "connect"
-#define LUNA_METHOD_WAN_DISCONNECT    "disconnect"
-#define LUNA_METHOD_WAN_GETSTATUS     "getStatus"
-#define LUNA_METHOD_WAN_GETCONTEXTS   "getContexts"
-#define LUNA_METHOD_WAN_GETCONTEXT    "getContext"
-#define LUNA_METHOD_WAN_SETHOSTROUTES "setHostRoutes"
-
-extern void check_and_initialize_cellular_technology(void);
-extern void send_wan_connection_status_to_subscribers(void);
-extern void send_wan_contexts_update_to_subscribers(void);
-extern void append_wan_status(jvalue_ref reply_obj);
-extern int initialize_wan_ls2_calls(GMainLoop *mainloop, LSHandle **wan_handle);
-
-#endif /* _WAN_SERVICE_H_ */
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 09191a6..da24047 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -57,7 +57,6 @@ errorText | Yes | String | Error description
 #include "connectionmanager_service.h"
 #include "logging.h"
 #include "wifi_tethering_service.h"
-#include "wan_service.h"
 #include "pan_service.h"
 #include "errors.h"
 #include "nyx.h"
@@ -1793,13 +1792,6 @@ static void manager_services_changed_callback(gpointer data,
 		connectionmanager_send_status_to_subscribers();
 	}
 
-	if (service_type & CELLULAR_SERVICES_CHANGED)
-	{
-		connectionmanager_send_status_to_subscribers();
-		send_wan_connection_status_to_subscribers();
-		send_wan_contexts_update_to_subscribers();
-	}
-
 	if (service_type & BLUETOOTH_SERVICES_CHANGED)
 	{
 		connectionmanager_send_status_to_subscribers();
@@ -2326,7 +2318,6 @@ static void check_and_initialize_wifi_technology(void)
 static void manager_technologies_changed_callback(gpointer data)
 {
 	check_and_initialize_wifi_technology();
-	check_and_initialize_cellular_technology();
 	check_and_initialize_bluetooth_technology();
 	check_and_initialize_ethernet_technology();
 }
@@ -4232,7 +4223,6 @@ static void connman_service_started(GDBusConnection *conn, const gchar *name,
 
 	check_and_initialize_wifi_technology();
 	check_and_initialize_ethernet_technology();
-	check_and_initialize_cellular_technology();
 	check_and_initialize_bluetooth_technology();
 
 	connectionmanager_send_status_to_subscribers();

commit 8f31bd62d591dc378183b71ba1775aa1894dda4a
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Wed Jul 24 12:10:23 2019 +0530

    Removing support for com.webos.service.pan service
    
    :Release Notes:
    Removing com.webos.service.pan service implementation for OSE.
    
    :Detailed Notes:
    Add changes to remove com.webos.service.pan service.
    Since its not required for OSE.
    
    :Testing Performed:
    Build successfully.
    Verified test cases QO-512, QO-3707.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-83245] [OSE Service Name Check]
                    "com.webos.service.pan"/setTethering
    
    Change-Id: If82a78cd6babdab476630824b5b6ba837e203672

diff --git a/CMakeLists.txt b/CMakeLists.txt
index ee85578..90988f1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -86,8 +86,8 @@ set(GDBUS_IF_DIR ${WEBOS_BINARY_CONFIGURED_DIR}/src)
 
 file (MAKE_DIRECTORY ${GDBUS_IF_DIR})
 
-execute_process(COMMAND ${GDBUS_CODEGEN_EXECUTABLE} --c-namespace ConnmanInterface --generate-c-code 
-			${GDBUS_IF_DIR}/connman-interface --interface-prefix net.connman. 
+execute_process(COMMAND ${GDBUS_CODEGEN_EXECUTABLE} --c-namespace ConnmanInterface --generate-c-code
+			${GDBUS_IF_DIR}/connman-interface --interface-prefix net.connman.
 			${CMAKE_CURRENT_SOURCE_DIR}/files/xml/connman.xml
 			RESULT_VARIABLE codegen_failed)
 if(codegen_failed)
@@ -136,7 +136,6 @@ file(GLOB SOURCE_FILES
     src/wifi_service.c
     src/wifi_setting.c
     src/wifi_scan.c
-    src/pan_service.c
     src/state_recovery.c
     ${GDBUS_IF_DIR}/connman-interface.c
     ${GDBUS_IF_DIR}/pacrunner-interface.c)
diff --git a/files/sysbus/webos-connman-adapter.perm.json b/files/sysbus/webos-connman-adapter.perm.json
index b823bc0..19ee494 100644
--- a/files/sysbus/webos-connman-adapter.perm.json
+++ b/files/sysbus/webos-connman-adapter.perm.json
@@ -8,10 +8,5 @@
         "settings",
         "devices",
         "networking.internal"
-    ],
-    "com.webos.service.pan": [
-        "settings",
-        "devices",
-        "networking.internal"
     ]
 }
diff --git a/files/sysbus/webos-connman-adapter.role.json.in b/files/sysbus/webos-connman-adapter.role.json.in
index 6fede3a..6613e56 100644
--- a/files/sysbus/webos-connman-adapter.role.json.in
+++ b/files/sysbus/webos-connman-adapter.role.json.in
@@ -1,7 +1,7 @@
 {
     "exeName":"@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter",
     "type":"regular",
-    "allowedNames":["com.webos.service.wifi", "com.webos.service.connectionmanager", "com.webos.service.pan"],
+    "allowedNames":["com.webos.service.wifi", "com.webos.service.connectionmanager"],
     "permissions": [
         {
             "service":"com.webos.service.wifi",
@@ -17,13 +17,6 @@
                         "com.webos.settingsservice",
                         "com.webos.service.wifi",
                         "com.webos.service.config"]
-        },
-        {
-            "service":"com.webos.service.pan",
-            "outbound":["com.webos.service.pdm",
-                        "com.webos.settingsservice",
-                        "com.webos.service.wifi",
-                        "com.webos.service.config"]
         }
     ]
 }
diff --git a/files/sysbus/webos-connman-adapter.service.in b/files/sysbus/webos-connman-adapter.service.in
index 569fc75..da323a1 100644
--- a/files/sysbus/webos-connman-adapter.service.in
+++ b/files/sysbus/webos-connman-adapter.service.in
@@ -1,4 +1,4 @@
 [D-BUS Service]
-Name=com.webos.service.wifi;com.webos.service.connectionmanager;com.webos.service.pan
+Name=com.webos.service.wifi;com.webos.service.connectionmanager
 Exec="@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter
 Type=static
diff --git a/src/common.c b/src/common.c
index 4e9ade3..cd48350 100644
--- a/src/common.c
+++ b/src/common.c
@@ -260,64 +260,3 @@ const gchar *get_current_system_locale()
 	return current_system_locale;
 }
 
-/**
- *  @brief Check wether the bluetooth technology is powered (the "Powered" property has the
- *  value true).
- *
- *  @return Returns true if bluetooth technology is powered on
- */
-
-gboolean is_bluetooth_powered(void)
-{
-	connman_technology_t *technology = connman_manager_find_bluetooth_technology(
-	                                       manager);
-	return (NULL != technology) && technology->powered;
-}
-
-/**
- *  @brief Check wether the bluetooth technology is currently tethering (the "Tethering"
- *         property has the value true)
- *
- * @return Returns true if bluetooth technology is currently tethering, false otherwise.
- */
-gboolean is_bluetooth_tethering(void)
-{
-	connman_technology_t *technology = connman_manager_find_bluetooth_technology(
-	                                       manager);
-	return (NULL != technology) && technology->tethering;
-}
-
-/**
- *  @brief Check if the bluetooth technology is available. If the technology is not available
- *  an error message is send to the supplied luna message handle.
- *
- *  @param sh Luna śervice handle
- *  @param message Luna message handle
- *  @return TRUE if bluetooth technology is available, FALSE otherwise.
- */
-
-gboolean bluetooth_technology_status_check(LSHandle *sh, LSMessage *message)
-{
-	if (NULL == connman_manager_find_bluetooth_technology(manager))
-	{
-		LSMessageReplyCustomError(sh, message, "Bluetooth technology unavailable",
-		                          WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-gboolean bluetooth_technology_status_check_with_subscription(LSHandle *sh,
-        LSMessage *message, bool subscribed)
-{
-	if (NULL == connman_manager_find_bluetooth_technology(manager))
-	{
-		LSMessageReplyCustomErrorWithSubscription(sh, message,
-		        "Bluetooth technology unavailable",
-		        WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE, subscribed);
-		return FALSE;
-	}
-
-	return TRUE;
-}
diff --git a/src/common.h b/src/common.h
index 4b0e172..cf90e86 100644
--- a/src/common.h
+++ b/src/common.h
@@ -37,14 +37,8 @@ extern gboolean connman_status_check_with_subscription(connman_manager_t *manage
 extern gboolean set_wifi_powered_status(gboolean state);
 extern const gchar *get_current_system_locale();
 extern void retrieve_system_locale_info(LSHandle *handle);
-extern gboolean is_bluetooth_powered(void);
-extern gboolean is_bluetooth_tethering(void);
 extern bool is_valid_ipv6address(char *ipAddress);
 extern bool is_valid_ipaddress(char *ipAddress);
-extern gboolean bluetooth_technology_status_check(LSHandle *sh,
-        LSMessage *message);
-extern gboolean bluetooth_technology_status_check_with_subscription(
-    LSHandle *sh, LSMessage *message, bool subscribed);
 
 #endif /* _COMMON_H_ */
 
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 3083766..6581c65 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -57,7 +57,6 @@ errorText | Yes | String | Error description
 #include "utils.h"
 #include "nyx.h"
 #include "pacrunner_client.h"
-#include "pan_service.h"
 #include "wifi_setting.h"
 
 #define COUNTER_ACCURACY    10
@@ -76,10 +75,8 @@ gboolean wifi_online_checking_status = FALSE;
 gboolean wired_connected = FALSE;
 gboolean wifi_connected = FALSE;
 gboolean p2p_connected = FALSE;
-gboolean pan_connected = FALSE;
 guint block_getstatus_response = 0;
 gboolean old_wifi_tethering = FALSE;
-gboolean old_pan_tethering = FALSE;
 gboolean wired_plugged = FALSE;
 
 char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
@@ -89,30 +86,6 @@ static void getinfo_update(void);
 
 #define IS_WIRED_PLUGGED() g_slist_length(manager->wired_services)
 
-static bool is_caller_using_new_interface(LSMessage *message)
-{
-	if (!message)
-	{
-		return false;
-	}
-
-	LSHandle *handle = LSMessageGetConnection(message);
-
-	if (!handle)
-	{
-		return false;
-	}
-
-	const char *name = LSHandleGetName(handle);
-
-	if (!name)
-	{
-		return false;
-	}
-
-	return (g_strcmp0(name, "com.webos.service.connectionmanager") == 0);
-}
-
 /**
  * @brief Fill in information about the system's connection status
  *
@@ -423,8 +396,7 @@ static void append_p2p_connection_status(jvalue_ref *status,
  * @param reply JSON object where we will append the connection status to.
  */
 
-static void append_connection_status(jvalue_ref *reply, bool subscribed,
-                                     bool with_new_interface)
+static void append_connection_status(jvalue_ref *reply, bool subscribed)
 {
 	if (NULL == reply)
 	{
@@ -520,38 +492,6 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed,
 		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), disconnected_p2p_status);
 		j_release(&connected_p2p_status);
 	}
-
-	if (with_new_interface)
-	{
-		jvalue_ref connected_pan_status = jobject_create();
-		jvalue_ref disconnected_pan_status = jobject_create();
-		jobject_put(disconnected_pan_status, J_CSTR_TO_JVAL("state"),
-		            jstring_create("disconnected"));
-		jobject_put(disconnected_pan_status, J_CSTR_TO_JVAL("tetheringEnabled"),
-		            jboolean_create(is_bluetooth_tethering()));
-
-		connman_service_t *connected_pan_service =
-		    connman_manager_get_connected_service(manager->bluetooth_services);
-
-		if (NULL != connected_pan_service)
-		{
-			append_nap_info(&connected_pan_status);
-			update_connection_status(connected_pan_service, &connected_pan_status);
-
-			// When we're connected to a PAN service we can't have tethering enabled
-			jobject_put(connected_pan_status, J_CSTR_TO_JVAL("tetheringEnabled"),
-			            jboolean_create(false));
-
-			jobject_put(*reply, J_CSTR_TO_JVAL("bluetooth"), connected_pan_status);
-			j_release(&disconnected_pan_status);
-		}
-		else
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("bluetooth"), disconnected_pan_status);
-			j_release(&connected_pan_status);
-		}
-
-	}
 }
 
 /**
@@ -621,12 +561,6 @@ static gboolean check_update_is_needed(void)
 		needed = TRUE;
 	}
 
-	if (old_pan_tethering != is_bluetooth_tethering())
-	{
-		old_pan_tethering = is_bluetooth_tethering();
-		needed = TRUE;
-	}
-
 	gboolean old_online_status = online_status;
 
 	online_status = connman_manager_is_manager_online(manager);
@@ -683,16 +617,6 @@ static gboolean check_update_is_needed(void)
 
 	p2p_connected = (connected_p2p_service != NULL && manager->groups != NULL);
 
-	connman_service_t *connected_pan_service =
-	    connman_manager_get_connected_service(manager->bluetooth_services);
-
-	if (check_service_for_update(connected_pan_service, pan_connected))
-	{
-		needed = TRUE;
-	}
-
-	pan_connected = (connected_pan_service != NULL);
-
 	WCALOG_INFO(MSGID_CONNECTION_INFO, 0, "needed: %d",needed);
 
 	return needed;
@@ -773,10 +697,8 @@ void connectionmanager_send_status_to_subscribers(void)
 
 	jvalue_ref reply = jobject_create();
 	jvalue_ref reply_deprecated = jobject_create();
-	append_connection_status(&reply, true, true);
-	// Same but without mentioning PAN as we don't support it on the
-	// com.webos.service.connectionmanager service face
-	append_connection_status(&reply_deprecated, true, false);
+	append_connection_status(&reply, true);
+	append_connection_status(&reply_deprecated, true);
 
 	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
 	                              DOMOPT_NOOPT, NULL);
@@ -945,8 +867,7 @@ static bool handle_get_status_command(LSHandle *sh, LSMessage *message,
 		}
 	}
 
-	append_connection_status(&reply, subscribed,
-	                         is_caller_using_new_interface(message));
+	append_connection_status(&reply, subscribed);
 
 	response_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
 
diff --git a/src/connman_manager.c b/src/connman_manager.c
index 866de33..a72aa01 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -105,13 +105,6 @@ static connman_service_t *find_service_from_path(connman_manager_t *manager,
 
 		service = connman_manager_find_service_by_path(manager->p2p_services, path);
 
-		if (NULL != service)
-		{
-			return service;
-		}
-
-		service = connman_manager_find_service_by_path(manager->bluetooth_services,
-		                                               path);
 	}
 
 	return service;
@@ -243,15 +236,6 @@ static gboolean service_on_configured_iface(GVariant *service_v)
 
 				return TRUE;
 			}
-			else if (!g_strcmp0(type, "bluetooth"))
-			{
-				g_variant_unref(properties);
-				g_variant_unref(property);
-				g_variant_unref(key_v);
-
-				return TRUE;
-			}
-
 		}
 
 		g_variant_unref(property);
@@ -295,11 +279,6 @@ static void add_service_to_list(connman_manager_t *manager,
 		{
 			manager->p2p_services = g_slist_append(manager->p2p_services, service);
 		}
-		else if (connman_service_type_bluetooth(service))
-		{
-			manager->bluetooth_services = g_slist_append(manager->bluetooth_services,
-			                              service);
-		}
 	}
 }
 
@@ -403,10 +382,6 @@ static gboolean connman_manager_update_services(connman_manager_t *manager,
 					*service_type |= P2P_SERVICES_CHANGED;
 					break;
 
-				case CONNMAN_SERVICE_TYPE_BLUETOOTH:
-					*service_type |= BLUETOOTH_SERVICES_CHANGED;
-					break;
-
 				default:
 					break;
 			}
@@ -488,8 +463,7 @@ static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
 	}
 
 	gboolean wifi_services_removed = FALSE, wired_services_removed = FALSE,
-	         p2p_services_removed = FALSE,
-	         bluetooth_services_removed = FALSE;
+	         p2p_services_removed = FALSE;
 
 	wifi_services_removed = remove_services_from_list(&manager->wifi_services,
 	                        services_removed);
@@ -497,8 +471,6 @@ static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
 	                         services_removed);
 	p2p_services_removed = remove_services_from_list(&manager->p2p_services,
 	                       services_removed);
-	bluetooth_services_removed = remove_services_from_list(
-	                                 &manager->bluetooth_services, services_removed);
 
 	if (wired_services_removed)
 	{
@@ -523,13 +495,7 @@ static gboolean connman_manager_remove_old_services(connman_manager_t *manager,
 		}
 	}
 
-	if (bluetooth_services_removed)
-	{
-		*service_type |= BLUETOOTH_SERVICES_CHANGED;
-	}
-
-	return (wifi_services_removed | wired_services_removed | p2p_services_removed |
-	        bluetooth_services_removed);
+	return (wifi_services_removed | wired_services_removed | p2p_services_removed);
 }
 
 /**
@@ -558,11 +524,6 @@ static void connman_manager_free_services(connman_manager_t *manager)
 	g_slist_free(manager->p2p_services);
 	manager->p2p_services = NULL;
 
-	g_slist_foreach(manager->bluetooth_services, (GFunc) connman_service_free,
-	                NULL);
-	g_slist_free(manager->bluetooth_services);
-	manager->bluetooth_services = NULL;
-
 	g_slist_foreach(manager->saved_services, (GFunc) connman_service_free, NULL);
 	g_slist_free(manager->saved_services);
 	manager->saved_services = NULL;
@@ -1302,39 +1263,6 @@ connman_technology_t *connman_manager_find_ethernet_technology(
 	return NULL;
 }
 
-/**
- * Go through the manager's technologies list and get the bluetooth one
- * (see header for API details)
- */
-
-connman_technology_t *connman_manager_find_bluetooth_technology(
-    connman_manager_t *manager)
-{
-	if (NULL == manager)
-	{
-		return NULL;
-	}
-
-	GSList *iter;
-
-	for (iter = manager->technologies; NULL != iter; iter = iter->next)
-	{
-		connman_technology_t *tech = (struct connman_technology *)(iter->data);
-
-		if (!tech)
-		{
-			continue;
-		}
-
-		if (g_strcmp0("bluetooth", tech->type) == 0)
-		{
-			return tech;
-		}
-	}
-
-	return NULL;
-}
-
 /**
  * Go through the manager's given services list and get the one which is in
  * "ready" or "online" state (see header for API details)
@@ -1881,10 +1809,6 @@ connman_manager_t *connman_manager_new(void)
 	             g_slist_length(manager->wifi_services),
 	             g_slist_length(manager->technologies));
 
-	WCALOG_DEBUG("%d bluetooth services, %d technologies",
-	             g_slist_length(manager->bluetooth_services),
-	             g_slist_length(manager->technologies));
-
 	return manager;
 }
 
diff --git a/src/connman_manager.h b/src/connman_manager.h
index 7c20501..fbf8507 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -34,7 +34,6 @@
 #define ETHERNET_SERVICES_CHANGED   1
 #define WIFI_SERVICES_CHANGED       2
 #define P2P_SERVICES_CHANGED        4
-#define BLUETOOTH_SERVICES_CHANGED  16
 
 /**
  * Callback function for handling any changes in connman services
@@ -64,7 +63,6 @@ typedef struct connman_manager
 	GSList  *wifi_services;
 	GSList  *wired_services;
 	GSList  *p2p_services;
-	GSList  *bluetooth_services;
 	GSList  *saved_services;
 	GSList  *technologies;
 	GSList  *groups;
@@ -154,16 +152,6 @@ extern connman_technology_t *connman_manager_find_wifi_technology(
 extern connman_technology_t *connman_manager_find_ethernet_technology(
     connman_manager_t *manager);
 
-/**
-* Go through the manager's technologies list and get the technology with type "bluetooth"
-*
-* @param[IN]  manager A manager instance
-*
-* @return Technology with type "bluetooth"
-*/
-extern connman_technology_t *connman_manager_find_bluetooth_technology(
-    connman_manager_t *manager);
-
 /**
  * Go through the manager's given services list and get the one which is in "ready" or
  * "online" state , i.e  one of the connected states.
diff --git a/src/connman_service.c b/src/connman_service.c
index 504403e..4be3eb2 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -58,15 +58,6 @@ gboolean connman_service_type_p2p(connman_service_t *service)
 	return (NULL != service) && (CONNMAN_SERVICE_TYPE_P2P == service->type);
 }
 
-/**
-* Check if the type of the service is bluetooth (see header for API details)
-*/
-
-gboolean connman_service_type_bluetooth(connman_service_t *service)
-{
-	return (NULL != service) && (service->type == CONNMAN_SERVICE_TYPE_BLUETOOTH);
-}
-
 /**
  * Map the service connection status to corresponding webos state
  * (see header for API details)
@@ -1345,10 +1336,6 @@ void connman_service_update_properties(connman_service_t *service,
 			{
 				service->type = CONNMAN_SERVICE_TYPE_P2P;
 			}
-			else if (!g_strcmp0(v, "bluetooth"))
-			{
-				service->type = CONNMAN_SERVICE_TYPE_BLUETOOTH;
-			}
 		}
 		else if (!g_strcmp0(key, "State"))
 		{
diff --git a/src/connman_service.h b/src/connman_service.h
index a73319b..a72f992 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -175,7 +175,6 @@ typedef enum
 	CONNMAN_SERVICE_TYPE_ETHERNET,
 	CONNMAN_SERVICE_TYPE_WIFI,
 	CONNMAN_SERVICE_TYPE_P2P,
-	CONNMAN_SERVICE_TYPE_BLUETOOTH,
 	CONNMAN_SERVICE_TYPE_MAX
 } connman_service_types;
 
@@ -231,15 +230,6 @@ extern gboolean connman_service_type_ethernet(connman_service_t *service);
  */
 extern gboolean connman_service_type_p2p(connman_service_t *service);
 
-/**
-* Check if the type of the service is bluetooth
-*
-* @param[IN]  service A service instance
-*
-* @return TRUE if the service has "bluetooth" type
-*/
-extern gboolean connman_service_type_bluetooth(connman_service_t *service);
-
 /**
  * Stringify the service connection status to corresponding webos state
  * This function is required to send appropriate connection status to the webos world.
diff --git a/src/errors.h b/src/errors.h
index e1de27d..a37bb24 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -99,8 +99,6 @@
 #define WCA_API_ERROR_ALREADY_CONNECTED 165
 #define WCA_API_ERROR_REJECT_PEER 171
 #define WCA_API_ERROR_LISTEN_PARAMS_INVALID_VALUES 172
-#define WCA_API_ERROR_BLUETOOTH_TECHNOLOGY_UNAVAILABLE  173
-#define WCA_API_ERROR_BLUETOOTH_SWITCHED_OFF            174
 #define WCA_API_ERROR_NO_SERVICE_CONNECTED              175
 #define WCA_API_ERROR_P2P_MULTIPLE_GROUPS_NOT_ALLOWED   176
 #define WCA_API_ERROR_P2P_PASSPHRASE_INVALID            177
diff --git a/src/logging.h b/src/logging.h
index c6f6185..463269e 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -63,7 +63,6 @@ extern PmLogContext gLogContext;
 /** common ones */
 #define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
 #define MSGID_CM_SRVC_REGISTER_FAIL                     "WIFI_CM_REGISTER_FAIL"
-#define MSGID_PAN_SRVC_REGISTER_FAIL                    "PAN_SRVC_REGISTER_FAIL"
 
 #define MSGID_INVALID_STATE                             "INVALID_STATE"
 
@@ -215,14 +214,6 @@ extern PmLogContext gLogContext;
 #define MSGID_SETTING_LPAPP_REMOVE_ERROR                "SETTING_LPAPP_REMOVE_ERR"
 #define MSGID_SETTING_LPAPP_SET_ERROR                   "SETTING_LPAPP_SET_ERR"
 
-/** pan_service.c */
-#define MSGID_PAN_LUNA_BUS_ERROR                       "PAN_LUNA_BUS_ERR"
-#define MSGID_PAN_METHODS_LUNA_ERROR                   "PAN_METHODS_LUNA_ERR"
-#define MSGID_PAN_GLOOP_ATTACH_ERROR                   "PAN_GLOOP_ATTACH_ERR"
-#define MSGID_PAN_CONNECT_SERVICE_ERROR                "PAN_CONNECT_SERVICE_ERROR"
-#define MSGID_PAN_SKIPPING_FETCH_PROPERTIES            "PAN_SKIPPING_FETCH_PROPERTIES"
-#define MSGID_PAN_SERVICE_NOT_EXIST                    "PAN_SERVICE_NOT_EXIST"
-
 /** country_code.c */
 #define MSGID_COUNTRY_CODE_INFO                         "COUNTRY_CODE_INFO"
 #define MSGID_COUNTRY_CODE_FAILED                       "COUNTRY_CODE_FAILED"
diff --git a/src/main.c b/src/main.c
index c34538f..71c9687 100644
--- a/src/main.c
+++ b/src/main.c
@@ -36,7 +36,6 @@
 #include "logging.h"
 #include "wifi_service.h"
 #include "wifi_setting.h"
-#include "pan_service.h"
 #include "connectionmanager_service.h"
 #include "nyx.h"
 
@@ -60,7 +59,7 @@ term_handler(int signal)
 int
 main(int argc, char **argv)
 {
-	LSHandle *wifi_handle, *cm_handle, *pan_handle;
+	LSHandle *wifi_handle, *cm_handle;
 	signal(SIGTERM, term_handler);
 	signal(SIGINT, term_handler);
 
@@ -84,13 +83,6 @@ main(int argc, char **argv)
 		return -1;
 	}
 
-	if (initialize_pan_ls2_calls(mainloop, &pan_handle) < 0)
-	{
-		WCALOG_ERROR(MSGID_PAN_SRVC_REGISTER_FAIL, 0,
-		             "Error in initializing com.webos.serivce.pan service");
-		return -1;
-	}
-
 	if (initialize_connectionmanager_ls2_calls(mainloop, &cm_handle) < 0)
 	{
 		WCALOG_ERROR(MSGID_CM_SRVC_REGISTER_FAIL, 0,
diff --git a/src/pan_service.c b/src/pan_service.c
deleted file mode 100644
index 60a2574..0000000
--- a/src/pan_service.c
+++ /dev/null
@@ -1,1066 +0,0 @@
-// Copyright (c) 2014-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-/**
- * @file  pan_service.c
- *
- * @brief Implements all of com.webos.service.pan service methods using connman APIs
- * in the backend.
- */
-
-#include <glib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <pbnjson.h>
-
-#include "pan_service.h"
-#include "connman_manager.h"
-#include "lunaservice_utils.h"
-#include "connman_common.h"
-#include "connman_service.h"
-#include "common.h"
-#include "logging.h"
-#include "utils.h"
-#include "errors.h"
-#include "connectionmanager_service.h"
-
-//#define NAP_WITHOUT_COLON_ADDRESS_LENGTH 12
-#define PAN_MAC_ADDRESS_LENGTH 17
-
-static LSHandle *pLsHandle;
-
-luna_service_request_t *current_connect_req;
-
-/**
- *  @brief Callback function registered with connman technology whenever any of its properties change
- *
- *
- *  @param data
- *  @param property
- *  @param value
- */
-
-static void technology_property_changed_callback(gpointer data,
-        const gchar *property, GVariant *value)
-{
-	connman_technology_t *technology = (connman_technology_t *)data;
-
-	if (NULL == technology)
-	{
-		return;
-	}
-
-	connman_technology_t *bluetooth_technology =
-	    connman_manager_find_bluetooth_technology(manager);
-
-	if (technology != bluetooth_technology)
-	{
-		return;
-	}
-
-	if (g_strcmp0(property, "Powered") == 0 ||
-	        g_strcmp0(property, "Connected") == 0)
-	{
-		connectionmanager_send_status_to_subscribers();
-		send_pan_connection_status_to_subscribers();
-	}
-	else if (g_strcmp0(property, "Tethering") == 0)
-	{
-		send_pan_connection_status_to_subscribers();
-		connectionmanager_send_status_to_subscribers();
-	}
-}
-
-/**
- *  @brief Callback function registered with connected bluetooth service whenever any of its properties change
- *
- *
- *  @param data
- *  @param property
- *  @param value
- */
-
-static void service_changed_cb(gpointer user_data, const gchar *name,
-                               GVariant *value)
-{
-	connectionmanager_send_status_to_subscribers();
-}
-
-/**
- *  @brief Add details about the connected service
- *
- *  @param reply
- *  @param connected_service
- *
- */
-
-/**
- *  @brief Sets the bluetooth technologies tethering state
- *
- *  @param state
- */
-
-static gboolean set_bluetooth_tethering(bool state)
-{
-	if (state == is_bluetooth_tethering())
-	{
-		return FALSE;
-	}
-
-	connman_technology_t *bluetooth_tech =
-	    connman_manager_find_bluetooth_technology(manager);
-
-	if (!bluetooth_tech)
-	{
-		return FALSE;
-	}
-
-	if (!is_bluetooth_powered() && state)
-	{
-		// we need to have Bluetooth powered otherwise we can't start tethering
-		connman_technology_set_powered(bluetooth_tech, TRUE, NULL);
-
-		// FIXME this should go away once we switch to asynchronous variant of
-		// connman_technology_set_powered method
-		g_usleep(2000000);
-	}
-
-	if (state)
-	{
-		connman_service_t *connected_service = connman_manager_get_connected_service(
-		        manager->bluetooth_services);
-
-		if (connected_service)
-		{
-			connman_service_disconnect(connected_service);
-		}
-	}
-
-	return connman_technology_set_tethering(bluetooth_tech, state);
-}
-
-static void add_connected_network_status(jvalue_ref *reply,
-        connman_service_t *connected_service)
-{
-	if (NULL == reply || NULL == connected_service)
-	{
-		return;
-	}
-
-	int connman_state = 0;
-	jobject_put(*reply, J_CSTR_TO_JVAL("status"),
-	            jstring_create("connectionStateChanged"));
-
-	jvalue_ref network_info = jobject_create();
-
-	/* Fill in details about the service NAP*/
-	if (connected_service->display_name != NULL)
-	{
-		jobject_put(network_info, J_CSTR_TO_JVAL("displayName"),
-		            jstring_create(connected_service->display_name));
-	}
-	else
-	{
-		jobject_put(network_info, J_CSTR_TO_JVAL("displayName"),
-		            jstring_create(connected_service->name));
-	}
-
-	if (connected_service->address != NULL)
-	{
-		jobject_put(network_info, J_CSTR_TO_JVAL("address"),
-		            jstring_create(connected_service->address));
-	}
-
-	if (connected_service->state != NULL)
-	{
-		connman_state = connman_service_get_state(connected_service->state);
-	}
-
-	/* Fill in ip information only for a service which is online (fully connected) */
-	if (connman_state == CONNMAN_SERVICE_STATE_ONLINE
-	        || connman_state == CONNMAN_SERVICE_STATE_READY)
-	{
-		connman_service_get_ipinfo(connected_service);
-		jvalue_ref ip_info = jobject_create();
-
-		if (connected_service->ipinfo.iface)
-		{
-			jobject_put(ip_info, J_CSTR_TO_JVAL("interface"),
-			            jstring_create(connected_service->ipinfo.iface));
-		}
-
-		if (connected_service->ipinfo.ipv4.address)
-		{
-			jobject_put(ip_info, J_CSTR_TO_JVAL("ip"),
-			            jstring_create(connected_service->ipinfo.ipv4.address));
-		}
-
-		if (connected_service->ipinfo.ipv4.netmask)
-		{
-			jobject_put(ip_info, J_CSTR_TO_JVAL("subnet"),
-			            jstring_create(connected_service->ipinfo.ipv4.netmask));
-		}
-
-		if (connected_service->ipinfo.ipv4.gateway)
-		{
-			jobject_put(ip_info, J_CSTR_TO_JVAL("gateway"),
-			            jstring_create(connected_service->ipinfo.ipv4.gateway));
-		}
-
-		if (connected_service->ipinfo.dns != NULL)
-		{
-			gsize i;
-			char dns_str[16];
-
-			for (i = 0; i < g_strv_length(connected_service->ipinfo.dns); i++)
-			{
-				g_snprintf(dns_str, 16, "dns%d", i + 1);
-				jobject_put(ip_info, jstring_create(dns_str),
-				            jstring_create(connected_service->ipinfo.dns[i]));
-			}
-		}
-
-		if (connected_service->ipinfo.ipv4.method)
-		{
-			jobject_put(ip_info, J_CSTR_TO_JVAL("method"),
-			            jstring_create(connected_service->ipinfo.ipv4.method));
-		}
-
-		jobject_put(network_info, J_CSTR_TO_JVAL("ipInfo"), ip_info);
-	}
-
-	jobject_put(*reply,  J_CSTR_TO_JVAL("networkInfo"), network_info);
-
-}
-
-/**
- * @brief Fill in information about the NAP
- *
- * @param status json status object to fill with the service status
- */
-
-void append_nap_info(jvalue_ref *status)
-{
-	if (NULL == status)
-	{
-		return;
-	}
-
-	connman_service_t *connected_service = connman_manager_get_connected_service(
-	        manager->bluetooth_services);
-
-	if (NULL == connected_service)
-	{
-		return;
-	}
-
-	jvalue_ref nap_info = jobject_create();
-
-	if (connected_service->address != NULL)
-	{
-		jobject_put(nap_info, J_CSTR_TO_JVAL("address"),
-		            jstring_create(connected_service->address));
-	}
-
-	/* Fill in details about the service NAP*/
-	if (connected_service->display_name != NULL)
-	{
-		jobject_put(nap_info, J_CSTR_TO_JVAL("displayName"),
-		            jstring_create(connected_service->display_name));
-	}
-	else
-	{
-		jobject_put(nap_info, J_CSTR_TO_JVAL("displayName"),
-		            jstring_create(connected_service->name));
-	}
-
-	jobject_put(*status, J_CSTR_TO_JVAL("nap"), nap_info);
-}
-
-/**
- * @brief Fill in all status information to be sent with 'getStatus' method
- */
-
-static void append_pan_status(jvalue_ref *reply)
-{
-	if (NULL == reply)
-	{
-		return;
-	}
-
-	jobject_put(*reply, J_CSTR_TO_JVAL("tetheringEnabled"),
-	            jboolean_create(is_bluetooth_tethering()));
-
-	gboolean powered = is_bluetooth_powered();
-
-	jobject_put(*reply, J_CSTR_TO_JVAL("status"),
-	            jstring_create(powered ? "serviceEnabled" : "serviceDisabled"));
-
-	/* Get the service which is connecting or already in connected state */
-	connman_service_t *connected_service = connman_manager_get_connected_service(
-	        manager->bluetooth_services);
-
-	if (connected_service != NULL)
-	{
-		add_connected_network_status(reply, connected_service);
-	}
-}
-
-void send_pan_connection_status_to_subscribers(void)
-{
-	jvalue_ref reply = jobject_create();
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-
-	append_pan_status(&reply);
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (response_schema)
-	{
-		const char *payload = jvalue_tostring(reply, response_schema);
-
-		WCALOG_DEBUG("Sending payload : %s", payload);
-
-		LSError lserror;
-		LSErrorInit(&lserror);
-
-		if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_PAN_GETSTATUS, payload, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-
-		jschema_release(&response_schema);
-	}
-
-	j_release(&reply);
-}
-
-static gboolean compare_address(char *first, char *second)
-{
-	gboolean ret;
-	char *first_address, *second_address;
-
-	first_address = g_ascii_strup(first, PAN_MAC_ADDRESS_LENGTH);
-	second_address = g_ascii_strup(second, PAN_MAC_ADDRESS_LENGTH);
-
-	if (!g_strcmp0(first_address, second_address))
-	{
-		ret = TRUE;
-	}
-	else
-	{
-		ret = FALSE;
-	}
-
-	g_free(first_address);
-	g_free(second_address);
-
-	return ret;
-}
-
-static void current_connect_req_free()
-{
-	luna_service_request_free(current_connect_req);
-	current_connect_req = NULL;
-
-}
-
-/**
- * When the user requests a connection to a network and the connection establishment
- * process fails we don't immediately report this to the user but waiting until the
- * service object enters the failure state in order to analyze why things went wrong.
-
- * By doing this we can provide a appropiate error message to the user an not simply
- * failing with a common error message.
- *
- * Currently we're handling all known errors connman returns. See method error2string
- * in src/service.c of the connman source tree for all currently handled errors.
- */
-
-static void handle_failed_connection_request(gpointer user_data)
-{
-	const char *error_message = "Unknown error";
-	unsigned int error_code = WCA_API_ERROR_UNKNOWN;
-
-	if (NULL == manager)
-	{
-		return;
-	}
-
-	if (NULL == current_connect_req)
-	{
-		return;
-	}
-
-	connman_service_t *service = current_connect_req->user_data;
-
-	if (NULL == service || NULL == g_slist_find(manager->bluetooth_services, service))
-	{
-		goto reply;
-	}
-
-	if (NULL == service->path)
-	{
-		WCALOG_INFO(MSGID_PAN_SKIPPING_FETCH_PROPERTIES, 0,
-		            "Skipping fetch properties");
-		goto reply;
-	}
-
-	if (NULL == connman_manager_find_service_by_path(manager->bluetooth_services,
-	        service->path))
-	{
-		WCALOG_INFO(MSGID_PAN_SERVICE_NOT_EXIST, 0, "Service %s doesn't exist",
-		            service->name);
-		goto reply;
-	}
-
-	GVariant *properties = connman_service_fetch_properties(service);
-
-	if (NULL == properties)
-	{
-		goto reply;
-	}
-
-	connman_service_update_properties(service, properties);
-	g_variant_unref(properties);
-
-	if (g_strcmp0(service->error, "connect-failed") == 0)
-	{
-		error_message = "Could not establish a connection to NAP";
-		error_code = WCA_API_ERROR_CONNECT_FAILED;
-	}
-	else if (g_strcmp0(service->error, "dhcp-failed") == 0)
-	{
-		error_message = "Could not retrieve a valid IP address by using DHCP";
-		error_code = WCA_API_ERROR_DHCP_FAILED;
-	}
-
-reply:
-
-	LSMessageReplyCustomError(current_connect_req->handle,
-	                          current_connect_req->message,
-	                          error_message, error_code);
-
-	current_connect_req_free();
-}
-
-static void service_connect_callback(gboolean success, gpointer user_data)
-{
-	UNUSED(user_data);
-
-	if (!current_connect_req)
-	{
-		// Something is wrong. It should have been there. There is no luna call to respond to. Log an error.
-		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_CONNECT_SERVICE_ERROR,
-		                      "Missing connect request on connect callback!");
-		return;
-	}
-
-	luna_service_request_t *service_req = current_connect_req;
-
-	/* if the connection could not be established we're waiting for the service to switch
-	 * it's state to failure until we report the failed connection request to the user */
-	if (!success)
-	{
-		g_timeout_add_seconds(2, handle_failed_connection_request, NULL);
-		return;
-	}
-
-	LSMessageReplySuccess(service_req->handle, service_req->message);
-
-	current_connect_req_free();
-}
-
-/**
- *  @brief Connect to a PAN server with the given target MAC adress
- *
- *  @param address the remote device address
- */
-
-static void connect_pan_with_address(char *address,
-                                     luna_service_request_t *service_req)
-{
-	GSList *nap;
-	gboolean found_service = FALSE;
-	connman_service_t *service = NULL;
-
-	connman_technology_t *bluetooth_tech =
-	    connman_manager_find_bluetooth_technology(manager);
-
-	if (NULL == address || NULL == bluetooth_tech)
-	{
-		LSMessageReplyCustomError(service_req->handle, service_req->message,
-		                          "Internal error", WCA_API_ERROR_INTERNAL);
-		goto cleanup;
-	}
-
-	if (current_connect_req)
-	{
-		LSMessageReplyCustomError(service_req->handle, service_req->message,
-		                          "Already connecting to a network", WCA_API_ERROR_ALREADY_CONNECTING);
-		goto cleanup;
-	}
-
-	for (nap = manager->bluetooth_services; NULL != nap ; nap = nap->next)
-	{
-		service = (connman_service_t *)(nap->data);
-
-		/* Service's address or User input's address would be uppercase letters or lowercase letters.
-		 * So, this converts these to uppercase letters to compare whether these are same or not. */
-		if (compare_address(service->address, address))
-		{
-			found_service = TRUE;
-			break;
-		}
-	}
-
-	if (!found_service)
-	{
-		LSMessageReplyCustomError(service_req->handle, service_req->message,
-		                          "Network not found", WCA_API_ERROR_NETWORK_NOT_FOUND);
-		goto cleanup;
-	}
-
-	connman_service_t *connected_service = connman_manager_get_connected_service(
-			manager->bluetooth_services);
-
-	if (NULL != connected_service && (connected_service == service))
-	{
-		/* Already connected so connection was successful */
-		LSMessageReplySuccess(service_req->handle, service_req->message);
-		WCALOG_DEBUG("Already connected with network");
-		goto cleanup;
-	}
-
-	service_req->user_data = service;
-	current_connect_req = service_req;
-
-	if (!connman_service_connect(service, service_connect_callback, service_req))
-	{
-		current_connect_req = NULL;
-		LSMessageReplyErrorUnknown(service_req->handle, service_req->message);
-		goto cleanup;
-	}
-
-	goto exit;
-
-cleanup:
-	luna_service_request_free(service_req);
-exit:
-	return;
-}
-
-//->Start of API documentation comment block
-/**
-@page com_webos_pan com.webos.pan
-@{
-@section com_webos_pan_connect
-
-Connects to the remote Bluethooth device which is a NAP role.
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-address | Yes | String | Address of discovered Bluetooth NAP device
-
-@par Returns(Call)
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | yes | Boolean | True
-
-@}
-*/
-//->End of API documentation comment block
-static bool handle_pan_connect_command(LSHandle *sh, LSMessage *message,
-                                       void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!bluetooth_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (!is_bluetooth_powered())
-	{
-		LSMessageReplyCustomError(sh, message, "Bluetooth switched off",
-		                          WCA_API_ERROR_BLUETOOTH_SWITCHED_OFF);
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(address,
-	                                     string)) REQUIRED_1(address))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref addressObj = {0};
-	char *address;
-	luna_service_request_t *service_req;
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
-	{
-		raw_buffer address_buf = jstring_get(addressObj);
-		address = g_strdup(address_buf.m_str);
-		jstring_free_buffer(address_buf);
-	}
-	else
-	{
-		LSMessageReplyErrorInvalidParams(sh, message);
-		goto cleanup;
-	}
-
-	service_req = luna_service_request_new(sh, message);
-	connect_pan_with_address(address, service_req);
-
-	g_free(address);
-cleanup:
-	j_release(&parsedObj);
-	return true;
-}
-
-//->Start of API documentation comment block
-/**
-@page com_webos_pan com.webos.pan
-@{
-@section com_webos_pan_disconnect
-
-Disconnects the remote Bluethooth device which is a NAP role.
-
-@par Returns(Call)
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | yes | Boolean | True
-
-@}
-*/
-//->End of API documentation comment block
-static bool handle_pan_disconnect_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!bluetooth_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (!is_bluetooth_powered())
-	{
-		LSMessageReplyCustomError(sh, message, "Bluetooth switched off",
-		                          WCA_API_ERROR_BLUETOOTH_SWITCHED_OFF);
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(address,
-	                                     string)) REQUIRED_1(address))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref addressObj = {0};
-	char *address;
-	connman_service_t *connected_service;
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
-	{
-		raw_buffer address_buf = jstring_get(addressObj);
-		address = g_strdup(address_buf.m_str);
-		jstring_free_buffer(address_buf);
-	}
-	else
-	{
-		LSMessageReplyErrorInvalidParams(sh, message);
-		goto exit;
-	}
-
-	connected_service = connman_manager_get_connected_service(
-	                        manager->bluetooth_services);
-
-	if (!connected_service || !compare_address(connected_service->address, address))
-	{
-		LSMessageReplyCustomError(sh, message, "No service is connected",
-		                          WCA_API_ERROR_NO_SERVICE_CONNECTED);
-		goto cleanup;
-	}
-
-	if (!connman_service_disconnect(connected_service))
-	{
-		LSMessageReplyCustomError(sh, message,
-		                          "Failed to disconnect the connected service",
-		                          WCA_API_ERROR_DISCONNECT_FAILED);
-		goto cleanup;
-	}
-
-	LSMessageReplySuccess(sh, message);
-
-cleanup:
-	g_free(address);
-exit:
-	j_release(&parsedObj);
-	return true;
-}
-
-//->Start of API documentation comment block
-/**
-@page com_webos_pan com.webos.pan
-@{
-@section com_webos_pan_get_status
-
-Gets the current status of pan connection on the system.
-
-Callers can subscribe to this method to be notified of any changes
-in the pan connection status.
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-subscribe | No | Boolean | true to subscribe to this method
-
-@par Returns(Call)
-
-All optional fields are absent if PAN is not connected
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | yes | Boolean | True
-networkInfo | No | Object | A single object describing the current connection
-tetheringEnabled | Yes | Boolean | Indicates if PAN tethering is enabled or not
-
-@par "networkInfo" Object
-
-Name | Required | Type | Description
------|--------|------|----------
-ipInfo | Yes | Object | See below
-
-@par "ipInfo" Object
-
-Name | Required | Type | Description
------|--------|------|----------
-interface | Yes | String |
-ip | Yes | String | IP Address
-subnet | Yes | String | Subnet mask value
-gateway | Yes | String |IP Address of network gateway
-dns | Yes | Array of String | List of DNS server IP addresses
-
-@par Returns(Subscription)
-
-As for a successful call
-@}
-*/
-//->End of API documentation comment block
-static bool handle_pan_get_status_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref reply = jobject_create();
-	LSError lserror;
-	LSErrorInit(&lserror);
-	bool subscribed = false;
-
-	if (LSMessageIsSubscription(message))
-	{
-		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	if (!bluetooth_technology_status_check_with_subscription(sh, message,
-	        subscribed))
-	{
-		goto cleanup;
-	}
-
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
-
-	append_pan_status(&reply);
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (!response_schema)
-	{
-		LSMessageReplyErrorUnknown(sh, message);
-		goto cleanup;
-	}
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
-	                    &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	jschema_release(&response_schema);
-
-cleanup:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	if (!jis_null(parsedObj))
-	{
-		j_release(&parsedObj);
-	}
-
-	if (!jis_null(reply))
-	{
-		j_release(&reply);
-	}
-
-	return true;
-}
-
-/////////////////////////////////////////////////////////////////
-//                                                             //
-//            Start of API documentation comment block         //
-//                                                             //
-/////////////////////////////////////////////////////////////////
-/**
-@page com_webos_service_pan com.webos.service.pan/setTethering
-@{
-@section com_webos_service_pan_setTethering setTethering
-
-Set tethering state.
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-enabled | Yes | boolean | enable / disable tethering
-
-@par Returns(Call) for all forms
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | Yes | Boolean | True, if call was successful. False otherwise.
-errorText | No | String | Error text when call was not successful.
-errorCode | No | Integer | Error code when call was not successful.
-
-@par Returns(Subscription)
-Not applicable.
-
-@}
-*/
-/////////////////////////////////////////////////////////////////
-//                                                             //
-//            End of API documentation comment block           //
-//                                                             //
-/////////////////////////////////////////////////////////////////
-
-static bool handle_pan_set_tethering_command(LSHandle *sh, LSMessage *message,
-        void *context)
-{
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(enabled,
-	                                     boolean)) REQUIRED_1(enabled))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref enabledObj = {0};
-	gboolean enable_tethering = FALSE;
-
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!bluetooth_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
-	{
-		jboolean_get(enabledObj, &enable_tethering);
-
-		if (enable_tethering && is_bluetooth_tethering())
-		{
-			LSMessageReplyCustomError(sh, message, "Already Enabled",
-			                          WCA_API_ERROR_ALREADY_ENABLED);
-			goto cleanup;
-		}
-		else if (!enable_tethering && !is_bluetooth_tethering())
-		{
-			LSMessageReplyCustomError(sh, message, "Already Disabled",
-			                          WCA_API_ERROR_ALREADY_DISABLED);
-			goto cleanup;
-		}
-	}
-
-	if (!set_bluetooth_tethering(enable_tethering))
-	{
-		if (enable_tethering)
-		{
-			LSMessageReplyCustomError(sh, message, "Failed to enable tethering mode",
-			                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
-		}
-		else
-		{
-			LSMessageReplyCustomError(sh, message, "Failed to disable tethering mode",
-			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
-		}
-
-		goto cleanup;
-	}
-	else
-	{
-		LSMessageReplySuccess(sh, message);
-	}
-
-
-cleanup:
-	j_release(&parsedObj);
-	return true;
-}
-
-/**
- * com.webos.service.pan service Luna Method Table
- */
-
-static LSMethod pan_methods[] =
-{
-	{ LUNA_METHOD_PAN_CONNECT,                 handle_pan_connect_command },
-	{ LUNA_METHOD_PAN_DISCONNECT,              handle_pan_disconnect_command },
-	{ LUNA_METHOD_PAN_GETSTATUS,               handle_pan_get_status_command },
-	{ LUNA_METHOD_PAN_SETTETHERING,            handle_pan_set_tethering_command },
-	{},
-};
-
-int initialize_pan_ls2_calls(GMainLoop *mainloop, LSHandle **pan_handle)
-{
-	LSError lserror;
-	LSErrorInit(&lserror);
-	pLsHandle = NULL;
-
-	if (NULL == mainloop)
-	{
-		goto Exit;
-	}
-
-	if (LSRegister(PAN_LUNA_SERVICE_NAME, &pLsHandle, &lserror) == false)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_LUNA_BUS_ERROR, lserror.message);
-		goto Exit;
-	}
-
-	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_ROOT, pan_methods, NULL, NULL,
-	                       &lserror) == false)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_METHODS_LUNA_ERROR, lserror.message);
-		goto Exit;
-	}
-
-	if (LSGmainAttach(pLsHandle, mainloop, &lserror) == false)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_PAN_GLOOP_ATTACH_ERROR, lserror.message);
-		goto Exit;
-	}
-
-	*pan_handle = pLsHandle;
-
-	return 0;
-
-Exit:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	if (pLsHandle)
-	{
-		LSErrorInit(&lserror);
-
-		if (LSUnregister(pLsHandle, &lserror) == false)
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	return -1;
-}
-
-void check_and_initialize_bluetooth_technology(void)
-{
-	connman_technology_t *technology = connman_manager_find_bluetooth_technology(
-	                                       manager);
-
-	if (!technology)
-	{
-		return;
-	}
-
-	connman_technology_register_property_changed_cb(technology,
-	        technology_property_changed_callback);
-
-	/* Register property change callback for all connected bluetooth services */
-	GSList *iter;
-
-	for (iter = manager->bluetooth_services; iter != NULL; iter = iter->next)
-	{
-		connman_service_t *service = iter->data;
-
-		if (!connman_service_is_connected(service))
-		{
-			continue;
-		}
-
-		connman_service_register_property_changed_cb(service, service_changed_cb);
-	}
-}
diff --git a/src/pan_service.h b/src/pan_service.h
deleted file mode 100644
index 9b88bf3..0000000
--- a/src/pan_service.h
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright (c) 2014-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-/**
- * @file  pan_service.h
- *
- */
-
-#ifndef _PAN_SERVICE_H_
-#define _PAN_SERVICE_H_
-
-#include <luna-service2/lunaservice.h>
-
-#define PAN_LUNA_SERVICE_NAME "com.webos.service.pan"
-
-
-#define LUNA_CATEGORY_ROOT               "/"
-
-/**
- * @name Luna PAN Method Names
- * @{
- */
-
-#define LUNA_METHOD_PAN_CONNECT          "connect"
-#define LUNA_METHOD_PAN_DISCONNECT       "disconnect"
-#define LUNA_METHOD_PAN_GETSTATUS        "getStatus"
-#define LUNA_METHOD_PAN_SETTETHERING     "setTethering"
-
-extern void append_nap_info(jvalue_ref *status);
-extern void send_pan_connection_status_to_subscribers(void);
-extern int initialize_pan_ls2_calls(GMainLoop *mainloop,
-                                    LSHandle **pan_handle);
-extern void check_and_initialize_bluetooth_technology(void);
-
-#endif /* _PAN_SERVICE_H_ */
diff --git a/src/wifi_service.c b/src/wifi_service.c
index da24047..2955162 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -57,7 +57,6 @@ errorText | Yes | String | Error description
 #include "connectionmanager_service.h"
 #include "logging.h"
 #include "wifi_tethering_service.h"
-#include "pan_service.h"
 #include "errors.h"
 #include "nyx.h"
 
@@ -1792,10 +1791,6 @@ static void manager_services_changed_callback(gpointer data,
 		connectionmanager_send_status_to_subscribers();
 	}
 
-	if (service_type & BLUETOOTH_SERVICES_CHANGED)
-	{
-		connectionmanager_send_status_to_subscribers();
-	}
 }
 
 void send_getnetworks_status_to_subscribers()
@@ -2318,7 +2313,6 @@ static void check_and_initialize_wifi_technology(void)
 static void manager_technologies_changed_callback(gpointer data)
 {
 	check_and_initialize_wifi_technology();
-	check_and_initialize_bluetooth_technology();
 	check_and_initialize_ethernet_technology();
 }
 
@@ -4223,7 +4217,6 @@ static void connman_service_started(GDBusConnection *conn, const gchar *name,
 
 	check_and_initialize_wifi_technology();
 	check_and_initialize_ethernet_technology();
-	check_and_initialize_bluetooth_technology();
 
 	connectionmanager_send_status_to_subscribers();
 }

commit aa41a3c11a828855084f1481a6f455ac81c854ec
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Wed Jul 24 15:51:21 2019 +0530

    Removing unsupported wifi service APIs
    
    :Release Notes:
    Removing implementation of unsupported APIs for com.webos.service.wifi
    service.
    
    :Detailed Notes:
    Add changes to remove below APIs for com.webos.service.wifi service.
    Since its not required for OSE.
    "setmultichannelschedmode"
    "setPassthroughParams"
    "getmultichannelschedmode"
    "getwifidiagnostics"
    "tethering/setState"
    "tethering/getState"
    
    :Testing Performed:
    Build successfully.
    Verified test cases QO-512, QO-3707.
    
    :QA Notes:
    Relates with depends on http://gpro.lge.com/#/c/249300 and
    http://gpro.lge.com/#/c/249301/
    
    :Issues Addressed:
    [PLAT-83251] [ OSE Service Name Check] : "com.webos.service.wifi"
    
    Change-Id: I979db98e200e1d6afeeaab5091cc9dcee1800951

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 90988f1..bc3c45c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -131,7 +131,6 @@ file(GLOB SOURCE_FILES
     src/nyx.c
     src/pacrunner_client.c
     src/utils.c
-    src/wifi_tethering_service.c
     src/wifi_profile.c
     src/wifi_service.c
     src/wifi_setting.c
diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index 91035c4..ddf3652 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -20,15 +20,11 @@
         "com.webos.service.wifi/createwpspin",
         "com.webos.service.wifi/deleteprofile",
         "com.webos.service.wifi/findnetworks",
-        "com.webos.service.wifi/getmultichannelschedmode",
         "com.webos.service.wifi/getNetworks",
         "com.webos.service.wifi/getprofile",
         "com.webos.service.wifi/getprofilelist",
         "com.webos.service.wifi/getstatus",
-        "com.webos.service.wifi/getwifidiagnostics",
         "com.webos.service.wifi/scan",
-        "com.webos.service.wifi/setmultichannelschedmode",
-        "com.webos.service.wifi/setPassthroughParams",
         "com.webos.service.wifi/setstate",
         "com.webos.service.wifi/startwps"
     ],
@@ -53,15 +49,11 @@
         "com.webos.service.wifi/createwpspin",
         "com.webos.service.wifi/deleteprofile",
         "com.webos.service.wifi/findnetworks",
-        "com.webos.service.wifi/getmultichannelschedmode",
         "com.webos.service.wifi/getNetworks",
         "com.webos.service.wifi/getprofile",
         "com.webos.service.wifi/getprofilelist",
         "com.webos.service.wifi/getstatus",
-        "com.webos.service.wifi/getwifidiagnostics",
         "com.webos.service.wifi/scan",
-        "com.webos.service.wifi/setmultichannelschedmode",
-        "com.webos.service.wifi/setPassthroughParams",
         "com.webos.service.wifi/setstate",
         "com.webos.service.wifi/startwps"
     ],
@@ -74,7 +66,6 @@
         "com.webos.service.connectionmanager/getUserStatus",
         "com.webos.service.connectionmanager/getwolwowlstatus",
         "com.webos.service.connectionmanager/monitorActivity",
-        "com.webos.service.wifi/getstatus",
-        "com.webos.service.wifi/getwifidiagnostics"
+        "com.webos.service.wifi/getstatus"
     ]
 }
diff --git a/files/xml/connman.xml b/files/xml/connman.xml
index 54d2e1d..f7d60c5 100644
--- a/files/xml/connman.xml
+++ b/files/xml/connman.xml
@@ -1,6 +1,6 @@
 <!-- LICENSE@@@
 
-Copyright (c) 2013 LG Electronics, Inc.
+Copyright (c) 2013-2019 LG Electronics, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -130,8 +130,6 @@ limitations under the License.
 			<arg type="v"/>
 		</signal>
 		<signal name="WPSFailed"/>
-		<signal name="TetheringStaAuthorized"/>
-		<signal name="TetheringStaDeauthorized"/>
 	</interface>
 	<interface name="net.connman.Service">
 		<method name="GetProperties">
diff --git a/src/common.c b/src/common.c
index cd48350..8b72fb1 100644
--- a/src/common.c
+++ b/src/common.c
@@ -84,19 +84,6 @@ gboolean is_wifi_powered(void)
 	return (NULL != technology) && technology->powered;
 }
 
-/**
- *  @brief Check wether the wifi technology is currently tethering (the "Tethering"
- *         property has the value true)
- *
- * @return Returns true if wifi technology is currently tethering, false otherwise.
- */
-gboolean is_wifi_tethering(void)
-{
-	connman_technology_t *technology = connman_manager_find_wifi_technology(
-	                                       manager);
-	return (NULL != technology) && technology->tethering;
-}
-
 /**
  *  @brief Check if the wifi technology is available. If the technology is not available
  *  an error message is send to the supplied luna message handle.
diff --git a/src/common.h b/src/common.h
index cf90e86..c1d2e7f 100644
--- a/src/common.h
+++ b/src/common.h
@@ -28,7 +28,6 @@ extern connman_agent_t *agent;
 extern gboolean connman_status_check(connman_manager_t *manager, LSHandle *sh,
                                      LSMessage *message);
 extern gboolean is_wifi_powered(void);
-extern gboolean is_wifi_tethering(void);
 extern gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message);
 extern gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
                                                         LSMessage *message, bool subscribed);
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 6581c65..fc47020 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -76,7 +76,6 @@ gboolean wired_connected = FALSE;
 gboolean wifi_connected = FALSE;
 gboolean p2p_connected = FALSE;
 guint block_getstatus_response = 0;
-gboolean old_wifi_tethering = FALSE;
 gboolean wired_plugged = FALSE;
 
 char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
@@ -423,8 +422,6 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	            jstring_create("disconnected"));
 	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("state"),
 	            jstring_create("disconnected"));
-	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
-	            jboolean_create(is_wifi_tethering()));
 	jobject_put(disconnected_p2p_status, J_CSTR_TO_JVAL("state"),
 	            jstring_create("disconnected"));
 
@@ -460,10 +457,6 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	{
 		update_connection_status(connected_wifi_service, &connected_wifi_status);
 
-		// When we're connected to a WiFi service we can't have tethering enabled
-		jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
-		            jboolean_create(false));
-
 		jobject_put(*reply, J_CSTR_TO_JVAL("wifi"), connected_wifi_status);
 		j_release(&disconnected_wifi_status);
 	}
@@ -555,12 +548,6 @@ static gboolean check_update_is_needed(void)
 		return FALSE;
 	}
 
-	if (old_wifi_tethering != is_wifi_tethering())
-	{
-		old_wifi_tethering = is_wifi_tethering();
-		needed = TRUE;
-	}
-
 	gboolean old_online_status = online_status;
 
 	online_status = connman_manager_is_manager_online(manager);
@@ -1497,11 +1484,6 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 		}
 		else
 		{
-			if (enable_offline && is_wifi_tethering())
-			{
-				set_wifi_tethering(!enable_offline);
-			}
-
 			connman_manager_set_offlinemode(manager, enable_offline);
 		}
 
diff --git a/src/connman_group.c b/src/connman_group.c
index 92cf9d6..6a26cc8 100644
--- a/src/connman_group.c
+++ b/src/connman_group.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2018 LG Electronics, Inc.
+// Copyright (c) 2013-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -26,39 +26,6 @@
 #include "logging.h"
 #include "common.h"
 
-/**
- * @brief Set the group's tethering property
- *
- * @param group Group object to operate on
- * @param enable TRUE to enable tethering or FALSE to disable it
- * @return TRUE if operation was successfull. FALSE otherwise.
- */
-
-gboolean connman_group_set_tethering(connman_group_t *group, gboolean enable)
-{
-	if (NULL == group)
-	{
-		return FALSE;
-	}
-
-	GError *error = NULL;
-
-	connman_interface_group_call_set_property_sync(group->remote,
-	        "Tethering",
-	        g_variant_new_variant(g_variant_new_boolean(enable)),
-	        NULL, &error);
-
-	if (error)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_SET_PROPERTY_ERROR, error->message);
-		g_error_free(error);
-		return FALSE;
-	}
-
-	group->tethering = enable;
-	return TRUE;
-}
-
 /**
  * @brief Disconnect from a connman group
  *
@@ -153,10 +120,6 @@ static void __connman_group_update_property(connman_group_t *group,
 	{
 		group->is_persistent = g_variant_get_boolean(val);
 	}
-	else if (!g_strcmp0(name, "Tethering"))
-	{
-		group->tethering = g_variant_get_boolean(val);
-	}
 	else if (!g_strcmp0(name, "Freq"))
 	{
 		group->freq = g_variant_get_uint32(val);
diff --git a/src/connman_group.h b/src/connman_group.h
index 1a25216..5ef62dd 100644
--- a/src/connman_group.h
+++ b/src/connman_group.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2018 LG Electronics, Inc.
+// Copyright (c) 2013-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -45,15 +45,12 @@ typedef struct connman_group
 	gchar *local_address;
 	gboolean is_group_owner;
 	gboolean is_persistent;
-	gboolean tethering;
 	gint freq;
 	GSList *peer_list;
 	gulong sighandler_id;
 	connman_property_changed_cb     handle_property_change_fn;
 } connman_group_t;
 
-extern gboolean connman_group_set_tethering(connman_group_t *group,
-        gboolean state);
 extern gboolean connman_group_disconnect(connman_group_t *group);
 extern gboolean connman_group_invite_peer(connman_group_t *group,
         connman_service_t *service);
diff --git a/src/connman_manager.c b/src/connman_manager.c
index a72aa01..f7b6223 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -932,28 +932,6 @@ connman_group_t *connman_manager_create_group(connman_manager_t *manager,
 	return group;
 }
 
-/*
- * Get the number of connected station
- */
-guint connman_manager_get_sta_count(connman_manager_t *manager)
-{
-	if (NULL == manager)
-		return FALSE;
-
-	GError *error = NULL;
-	guint sta_count = 0;
-
-	connman_interface_manager_call_get_sta_count_sync(manager->remote, &sta_count, NULL, &error);
-
-	if (error)
-	{
-		g_error_free(error);
-		return 0;
-	}
-
-	return sta_count;
-}
-
 /**
  * Traverse through the given service list, comparing each service with the path provided
  * returning the service with the matching path (See header for API details)
diff --git a/src/connman_manager.h b/src/connman_manager.h
index fbf8507..1226d58 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -249,11 +249,6 @@ extern gboolean connman_manager_unregister_counter(connman_manager_t *manager,
 extern connman_group_t *connman_manager_create_group(connman_manager_t *manager,
         const gchar *ssid, const gchar *passphrase);
 
-/*
- * Get the number of connected station
- */
-extern guint connman_manager_get_sta_count(connman_manager_t *manager);
-
 /**
  * Populate the group's peer_list field with all of the group's peers
  *
diff --git a/src/connman_technology.c b/src/connman_technology.c
index 651cd1a..4fdd52d 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -72,101 +72,6 @@ gboolean connman_technology_set_powered(connman_technology_t *technology,
 	return TRUE;
 }
 
-/**
- * Enable/Disable tethering the given technology (see header for API details)
- */
-
-extern gboolean connman_technology_set_tethering(connman_technology_t
-        *technology, gboolean state)
-{
-	if (NULL == technology)
-	{
-		return FALSE;
-	}
-
-	GError *error = NULL;
-
-	connman_interface_technology_call_set_property_sync(technology->remote,
-	        "Tethering",
-	        g_variant_new_variant(g_variant_new_boolean(state)),
-	        NULL, &error);
-
-	if (error)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_ERROR, error->message);
-		g_error_free(error);
-		return FALSE;
-	}
-
-	technology->tethering = state;
-	g_usleep(1000000);
-	return TRUE;
-}
-
-/**
- * Set the name of ssid used in tethering (see header for API details)
- */
-
-extern gboolean connman_technology_set_tethering_identifier(
-    connman_technology_t *technology, const gchar *tethering_identifier)
-{
-	if (NULL == technology)
-	{
-		return FALSE;
-	}
-
-	GError *error = NULL;
-
-	connman_interface_technology_call_set_property_sync(technology->remote,
-	        "TetheringIdentifier",
-	        g_variant_new_variant(g_variant_new_string(tethering_identifier)),
-	        NULL, &error);
-
-	if (error)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR,
-		                      error->message);
-		g_error_free(error);
-		return FALSE;
-	}
-
-	g_free(technology->tethering_identifier);
-	technology->tethering_identifier = g_strdup(tethering_identifier);
-	return TRUE;
-}
-
-/**
- * Set the name of ssid used in tethering (see header for API details)
- */
-
-extern gboolean connman_technology_set_tethering_passphrase(
-    connman_technology_t *technology, const gchar *tethering_passphrase)
-{
-	if (NULL == technology)
-	{
-		return FALSE;
-	}
-
-	GError *error = NULL;
-
-	connman_interface_technology_call_set_property_sync(technology->remote,
-	        "TetheringPassphrase",
-	        g_variant_new_variant(g_variant_new_string(tethering_passphrase)),
-	        NULL, &error);
-
-	if (error)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR,
-		                      error->message);
-		g_error_free(error);
-		return FALSE;
-	}
-
-	g_free(technology->tethering_passphrase);
-	technology->tethering_passphrase = g_strdup(tethering_passphrase);
-	return TRUE;
-}
-
 /**
  * Cancel any active P2P connection (see header for API details)
  */
@@ -275,35 +180,6 @@ gboolean connman_technology_delete_profile(connman_technology_t *technology,
 	return TRUE;
 }
 
-/**
- * Set MultiChannelShedMode value to specified mode (see header for API details)
- */
-
-gboolean connman_technology_set_multi_channel_mode(connman_technology_t
-        *technology, const guint32 mode)
-{
-	if (NULL == technology)
-	{
-		return FALSE;
-	}
-
-	GError *error = NULL;
-
-	connman_interface_technology_call_set_property_sync(technology->remote,
-	        "MultiChannelSchedMode",
-	        g_variant_new_variant(g_variant_new_uint32(mode)),
-	        NULL, &error);
-
-	if (error)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_MULTI_CHANNEL_ERROR, error->message);
-		g_error_free(error);
-		return FALSE;
-	}
-
-	technology->multi_channel_mode = mode;
-	return TRUE;
-}
 /**
  * Set P2P state (see header for API details)
  */
@@ -656,29 +532,6 @@ static void set_property_value(connman_technology_t *technology,
 	{
 		technology->wfd_rtspport = g_variant_get_uint32(val);
 	}
-	else if (!g_strcmp0(key, "MultiChannelSchedMode"))
-	{
-		technology->multi_channel_mode = g_variant_get_uint32(val);
-	}
-	else if (!g_strcmp0(key, "DiagnosticInfo"))
-	{
-		g_free(technology->diagnostic_info);
-		technology->diagnostic_info = g_variant_dup_string(val, NULL);
-	}
-	else if (!g_strcmp0(key, "Tethering"))
-	{
-		technology->tethering = g_variant_get_boolean(val);
-	}
-	else if (!g_strcmp0(key, "TetheringIdentifier"))
-	{
-		g_free(technology->tethering_identifier);
-		technology->tethering_identifier = g_variant_dup_string(val, NULL);
-	}
-	else if (!g_strcmp0(key, "TetheringPassphrase"))
-	{
-		g_free(technology->tethering_passphrase);
-		technology->tethering_passphrase = g_variant_dup_string(val, NULL);
-	}
 	else if (!g_strcmp0(key, "CountryCode"))
 	{
 		g_free(technology->country_code);
@@ -862,58 +715,6 @@ void connman_technology_register_property_changed_cb(connman_technology_t
 	technology->handle_property_changed_fn = cb;
 }
 
-/**
- * Register a handler for the technology's "TetheringStaAuthorized" signal.
- */
-void connman_technology_register_sta_authorized_cb(connman_technology_t
-        *technology, connman_common_cb cb, gpointer user_data)
-{
-	if (!cb || !technology)
-	{
-		return;
-	}
-
-	technology->handle_sta_authorized_fn = cb;
-	technology->sta_authorized_data = user_data;
-}
-
-static void tethering_sta_authorized_cb(ConnmanInterfaceTechnology *proxy,
-                                        gpointer user_data)
-{
-	connman_technology_t *technology = user_data;
-
-	if (technology->handle_sta_authorized_fn)
-	{
-		technology->handle_sta_authorized_fn(technology->sta_authorized_data);
-	}
-}
-
-/**
- * Register a handler for the technology's "TetheringStaUnauthorized" signal.
- */
-void connman_technology_register_sta_deauthorized_cb(connman_technology_t
-        *technology, connman_common_cb cb, gpointer user_data)
-{
-	if (!cb || !technology)
-	{
-		return;
-	}
-
-	technology->handle_sta_deauthorized_fn = cb;
-	technology->sta_deauthorized_data = user_data;
-}
-
-static void tethering_sta_deunauthorized_cb(ConnmanInterfaceTechnology *proxy,
-        gpointer user_data)
-{
-	connman_technology_t *technology = user_data;
-
-	if (technology->handle_sta_deauthorized_fn)
-	{
-		technology->handle_sta_deauthorized_fn(technology->sta_deauthorized_data);
-	}
-}
-
 /**
  * Create a new technology instance and set its properties (see header for API details)
  */
@@ -949,13 +750,6 @@ connman_technology_t *connman_technology_new(const gchar* path)
 	            technology->remote), "property-changed",
 	        G_CALLBACK(property_changed_cb), technology, NULL, 0);
 
-	technology->sta_authorized_sighandler = g_signal_connect_data(G_OBJECT(
-	        technology->remote), "tethering-sta-authorized",
-	                                        G_CALLBACK(tethering_sta_authorized_cb), technology, NULL, 0);
-	technology->sta_deauthorized_sighandler = g_signal_connect_data(G_OBJECT(
-	            technology->remote), "tethering-sta-deauthorized",
-	        G_CALLBACK(tethering_sta_deunauthorized_cb), technology, NULL, 0);
-
 	/* If connman has a change in it's properties while we process the data and
 	 * before we register the signals, we do not get the update.
 	 * So, we need to get all that information from connman again.
@@ -1002,20 +796,6 @@ void connman_technology_free(connman_technology_t *technology)
 		technology->property_changed_sighandler = 0;
 	}
 
-	if (technology->sta_authorized_sighandler)
-	{
-		g_signal_handler_disconnect(G_OBJECT(technology->remote),
-		                            technology->sta_authorized_sighandler);
-		technology->sta_authorized_sighandler = 0;
-	}
-
-	if (technology->sta_deauthorized_sighandler)
-	{
-		g_signal_handler_disconnect(G_OBJECT(technology->remote),
-		                            technology->sta_deauthorized_sighandler);
-		technology->sta_deauthorized_sighandler = 0;
-	}
-
 	/* If async call to technology is in progress, scan callback will free the technology. */
 	if (technology->calls_pending > 0)
 	{
@@ -1032,9 +812,6 @@ void connman_technology_free(connman_technology_t *technology)
 	technology->name = NULL;
 	g_free(technology->p2p_identifier);
 	g_free(technology->country_code);
-	g_free(technology->diagnostic_info);
-	g_free(technology->tethering_identifier);
-	g_free(technology->tethering_passphrase);
 
 	g_object_unref(technology->remote);
 	technology->remote = NULL;
diff --git a/src/connman_technology.h b/src/connman_technology.h
index 3e44edf..521d13e 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -45,12 +45,8 @@ typedef struct connman_technology
 	gchar *path;
 	gchar *p2p_identifier;
 	gchar *country_code;
-	gchar *diagnostic_info;
-	gchar *tethering_identifier;
-	gchar *tethering_passphrase;
 	gboolean powered;
 	gboolean connected;
-	gboolean tethering;
 	gboolean p2p;
 	gboolean wfd;
 	gboolean p2p_listen;
@@ -60,15 +56,8 @@ typedef struct connman_technology
 	gboolean legacy_scan;
 	connman_wfd_dev_type wfd_devtype;
 	guint32 wfd_rtspport;
-	guint32 multi_channel_mode;
 	gulong property_changed_sighandler;
 	connman_property_changed_cb handle_property_changed_fn;
-	gulong sta_authorized_sighandler;
-	connman_common_cb handle_sta_authorized_fn;
-	gpointer sta_authorized_data;
-	gulong sta_deauthorized_sighandler;
-	connman_common_cb handle_sta_deauthorized_fn;
-	gpointer sta_deauthorized_data;
 	connman_common_cb handle_after_scan_fn;
 	gpointer after_scan_data;
 
@@ -103,39 +92,6 @@ typedef struct connman_technology_interface
 extern int connman_technology_set_powered(connman_technology_t *technology,
         gboolean state, bool* not_supported);
 
-/**
- * Enable/Disable tethering the given technology
- *
- * @param[IN]  technology A technology instance
- * @param[IN]  state TRUE for power on, FALSE for off
- *
- * @return FALSE for any error, TRUE otherwise
- */
-extern gboolean connman_technology_set_tethering(connman_technology_t
-        *technology, gboolean state);
-
-/**
- * Set the name of ssid used in tethering
- *
- * @param[IN]  technology A technology instance
- * @param[IN]  tethering_identifier of the tethering
- *
- * @return FALSE for any error, TRUE otherwise
- */
-extern gboolean connman_technology_set_tethering_identifier(
-    connman_technology_t *technology, const gchar *tethering_identifier);
-
-/**
- * Set the name of passphrase used in tethering
- *
- * @param[IN]  technology A technology instance
- * @param[IN]  tethering_passphrase of the tethering
- *
- * @return FALSE for any error, TRUE otherwise
- */
-extern gboolean connman_technology_set_tethering_passphrase(
-    connman_technology_t *technology, const gchar *tethering_passphrase);
-
 /**
  * Enable/disable wifi-direct technology
  *
@@ -275,17 +231,6 @@ extern gboolean connman_technology_cancel_wps(connman_technology_t *technology);
 extern gboolean connman_technology_delete_profile(connman_technology_t
         *technology, const gchar *address);
 
-/**
- * Set multi channel scheduling mode
- *
- * @param[IN]  technology A technology instance
- * @param[IN]  mode Either of 0/1/2
- * (0 -> fair scheduling, 1 -> Favour STA, 2-> Favour P2P)
- * @return FALSE for any error, TRUE otherwise
- */
-extern gboolean connman_technology_set_multi_channel_mode(
-    connman_technology_t *technology, const guint32 mode);
-
 /**
  * Scan the network for available services
  * This is usually called to scan all wifi APs whenever the list of APs is requested
@@ -333,26 +278,6 @@ extern gboolean connman_technology_set_listen_params(connman_technology_t *techn
 extern void connman_technology_register_property_changed_cb(
     connman_technology_t *technology, connman_property_changed_cb func);
 
-/**
- * @brief Register a handler for the technology's "TetheringStaAuthorized" signal.
- *
- * @param[IN] technology A technology instance
- * @param[IN] cb Handler function to register.
- * @param[IN] user_data User data passed with the callback when called.
- */
-extern void connman_technology_register_sta_authorized_cb(
-    connman_technology_t *technology, connman_common_cb cb, gpointer user_data);
-
-/**
- * @brief Register a handler for the technology's "TetheringStaDeauthorized" signal.
- *
- * @param[IN] technology A technology instance
- * @param[IN] cb Handler function to register.
- * @param[IN] user_data User data passed with the callback when called.
- */
-extern void connman_technology_register_sta_deauthorized_cb(
-    connman_technology_t *technology, connman_common_cb cb, gpointer user_data);
-
 /**
  * Fetch all the properties for a technology instance and save the new values
  * in technology fields.
diff --git a/src/errors.h b/src/errors.h
index a37bb24..c29c5c0 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -47,7 +47,6 @@
 #define WCA_API_ERROR_WPS_PIN           109
 #define WCA_API_ERROR_CANCEL_WPS        110
 #define WCA_API_ERROR_PEER_NOT_FOUND        111
-#define WCA_API_ERROR_MULTI_CHAN_SCHED_MODE 112
 #define WCA_API_ERROR_P2P_STATE_CHANGE      113
 #define WCA_API_ERROR_P2P_DISABLED      114
 #define WCA_API_ERROR_PERSISTENT_STATE      115
@@ -79,21 +78,7 @@
 #define WCA_API_ERROR_WIFI_NOT_CONNECTED    143
 #define WCA_API_ERROR_FAILED_TO_CONNECT     144
 #define WCA_API_ERROR_NOT_IMPLEMENTED       145
-#define WCA_API_ERROR_TETHERING_ENABLE_FAILED 146
-#define WCA_API_ERROR_TETHERING_DISABLE_FAILED 147
-#define WCA_API_ERROR_TETHERING_SSID_FAILED         148
-#define WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED   149
-#define WCA_API_ERROR_TETHERING_NO_SSID             150
-#define WCA_API_ERROR_TETHERING_NO_PASSPHRASE       151
-#define WCA_API_ERROR_TETHERING_SUPPORT_FAILED      152
-#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_SEC_TYPE          153
-#define WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED 154
-#define WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID  155
 #define WCA_API_ERROR_COUNTER                  156
-#define WCA_API_ERROR_TETHERING_RESTORE_WIFI_STATE_FAILED 157
-#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT 158
-#define WCA_API_ERROR_TETHERING_TIMEOUT_NO_NEGATIVE_VALUES 159
-#define WCA_API_ERROR_SET_PASSTHROUGH_PARAMS_FAILED  162
 #define WCA_API_ERROR_FAILED_TO_ENABLE_DISABLE_TECHNOLOGIES 163
 #define WCA_API_ERROR_FAILED_TO_SET_LISTEN_CHANNEL  164
 #define WCA_API_ERROR_ALREADY_CONNECTED 165
diff --git a/src/logging.h b/src/logging.h
index 463269e..a49773e 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -130,15 +130,11 @@ extern PmLogContext gLogContext;
 
 /** connman_technology.c */
 #define MSGID_TECHNOLOGY_SET_POWERED_ERROR              "TECH_SET_POWERED_ERR"
-#define MSGID_TECHNOLOGY_SET_TETHERING_ERROR            "TECH_SET_TETHERING_ERR"
-#define MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR "TECH_SET_TETHERING_IDENTI_ERR"
-#define MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR "TECH_SET_TETHERING_PASSPH_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_P2P_ERROR               "TECH_CANCEL_P2P_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_WPS_ERROR               "TECH_CANCEL_WPS_ERR"
 #define MSGID_TECHNOLOGY_START_WPS_ERROR                "TECH_START_WPS_ERR"
 #define MSGID_TECHNOLOGY_SET_COUNTRY_CODE_ERROR         "TECH_SET_COUNTRY_CODE_ERR"
 #define MSGID_TECHNOLOGY_DELETE_PROFILE_ERROR           "TECH_DELETE_PROFILE_ERR"
-#define MSGID_TECHNOLOGY_SET_MULTI_CHANNEL_ERROR        "TECH_SET_MULTI_CHANNEL_ERR"
 #define MSGID_TECHNOLOGY_SET_P2P_ERROR                  "TECH_SET_P2P_ERR"
 #define MSGID_TECHNOLOGY_SET_P2P_IDENTIFIER_ERROR       "TECH_SET_IDENTIFIER_ERR"
 #define MSGID_TECHNOLOGY_SET_WFD_ERROR                  "TECH_SET_WFD_ERR"
@@ -196,7 +192,6 @@ extern PmLogContext gLogContext;
 #define MSGID_P2P_DISCONNECT_PEER                       "P2P_DISCONNECT_PEER"
 #define MSGID_P2P_INVITE_PEER                           "P2P_INVITE_PEER"
 #define MSGID_P2P_DISCONNECT_GROUP                      "P2P_DISCONNECT_GRP"
-#define MSGID_P2P_SET_TETHERING                         "P2P_SET_TETHERING"
 #define MSGID_P2P_DELETE_PROFILE                        "P2P_DELETE_PROFILE"
 #define MSGID_P2P_METHODS_LUNA_ERROR                    "P2P_METHODS_LUNA_ERR"
 #define MSGID_SETTINGS_SERVICE_REG_ERROR                "SETTINGS_SRVC_REG_ERR"
@@ -205,9 +200,6 @@ extern PmLogContext gLogContext;
 #define MSGID_LUNA_CREATE_JSON_FAILED                   "LUNA_CREATE_JSON_FAILED"
 #define MSGID_LUNA_SEND_FAILED                          "LUNA_SEND_FAILED"
 
-/** wifi_tethering_service. */
-#define MSGID_TETHERING_METHODS_LUNA_ERROR              "TETHERING_METHODS_LUNA_ERR"
-
 /** wifi_setting.c */
 #define MSGID_SETTING_LPAPP_GET_ERROR                   "SETTING_LPAPP_GET_ERR"
 #define MSGID_SETTING_LPAPP_COPY_ERROR                  "SETTING_LPAPP_COPY_ERR"
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 2955162..163f491 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -56,7 +56,6 @@ errorText | Yes | String | Error description
 #include "common.h"
 #include "connectionmanager_service.h"
 #include "logging.h"
-#include "wifi_tethering_service.h"
 #include "errors.h"
 #include "nyx.h"
 
@@ -377,10 +376,7 @@ static void create_wifi_getstatus_response(jvalue_ref *reply, bool subscribed)
 
 	jobject_put(*reply, J_CSTR_TO_JVAL("wakeOnWlan"), jstring_create("disabled"));
 
-	jobject_put(*reply, J_CSTR_TO_JVAL("tetheringEnabled"),
-	            jboolean_create(is_wifi_tethering()));
-
-	gboolean powered = is_wifi_powered() && !is_wifi_tethering();
+	gboolean powered = is_wifi_powered();
 
 	/* Get the service which is connecting or already in connected state */
 	connman_service_t *connected_service = connman_manager_get_connected_service(
@@ -1841,265 +1837,6 @@ void send_findnetworks_status_to_subscribers()
 	j_release(&findnetworks_reply);
 }
 
-static int convert_frequency_to_channel(int freq)
-{
-	if (freq >= 2412 && freq <= 2484)
-	{
-		return (freq - 2412) / 5 + 1;
-	}
-	else if (freq >= 5170 && freq <= 5825)
-	{
-		return (freq - 5170) / 5 + 34;
-	}
-	else
-	{
-		return -1;
-	}
-}
-
-#define add_diagnostic_info_field(reply, info, name) ({ \
-    if(info) { \
-        gchar **value_str = g_strsplit(g_strstrip(info), ":", 2); \
-        if(value_str) { \
-            jobject_put(*reply, J_CSTR_TO_JVAL(name), jstring_create(g_strstrip(value_str[1]))); \
-            g_strfreev(value_str); \
-        } \
-    }\
-})
-
-/**
- * Populate the wifi diagnostics information
- * Split the technology->diagnostic_info variable if available and add all the values to an existing json object
- * Or get the interface properties for the wifi interface "wlan0"
- *
- * @param technoolgy A technology instance
- * @param reply The json object which needs to be updated
- */
-
-static gboolean make_wifi_diagnostics_payload(connman_technology_t *technology,
-        jvalue_ref *reply)
-{
-	jobject_put(*reply, J_CSTR_TO_JVAL("ssid"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("macAddress"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("Power off"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("amac"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("hi_op"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("ipAddress"), jstring_create("N/A"));
-
-	jobject_put(*reply, J_CSTR_TO_JVAL("version"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("ccode"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("ccodeRev"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("channel"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("MCS"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("MIMO"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("rate"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("RSSI"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("noise"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("txpwr"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("NSS"), jstring_create("N/A"));
-	jobject_put(*reply, J_CSTR_TO_JVAL("BW"), jstring_create("N/A"));
-
-	if (technology->diagnostic_info)
-	{
-		gchar **split_str = g_strsplit(g_strstrip(technology->diagnostic_info),
-		                               "\n\t\t", 13);
-
-		if(split_str)
-		{
-			int i;
-			int diagnostic_len = g_strv_length(split_str);
-
-			for (i = 1; i < diagnostic_len; i++)
-			{
-				if (i == 1)
-				{
-					add_diagnostic_info_field(reply, split_str[1], "version");
-				}
-				else if (i == 2)
-				{
-					add_diagnostic_info_field(reply, split_str[2], "ccode");
-				}
-				else if (i == 3)
-				{
-					add_diagnostic_info_field(reply, split_str[3], "ccodeRev");
-				}
-				else if (i == 4)
-				{
-					add_diagnostic_info_field(reply, split_str[4], "channel");
-				}
-				else if (i == 5)
-				{
-					add_diagnostic_info_field(reply, split_str[5], "MCS");
-				}
-				else if (i == 6)
-				{
-					add_diagnostic_info_field(reply, split_str[6], "MIMO");
-				}
-				else if (i == 7)
-				{
-					add_diagnostic_info_field(reply, split_str[7], "rate");
-				}
-				else if (i == 8)
-				{
-					add_diagnostic_info_field(reply, split_str[8], "RSSI");
-				}
-				else if (i == 9)
-				{
-					add_diagnostic_info_field(reply, split_str[9], "noise");
-				}
-				else if (i == 10)
-				{
-					add_diagnostic_info_field(reply, split_str[10], "txpwr");
-				}
-				else if (i == 11)
-				{
-					add_diagnostic_info_field(reply, split_str[11], "NSS");
-				}
-				else if(i == 12)
-				{
-					add_diagnostic_info_field(reply, split_str[12], "BW");
-				}
-			}
-
-			g_strfreev(split_str);
-		}
-	}
-	else
-	{
-		connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
-		        manager);
-		connman_technology_interface_t interface_properties;
-
-		if (connman_technology_get_interface_properties(wifi_technology,
-		        CONNMAN_WIFI_INTERFACE_NAME, &interface_properties) == TRUE)
-		{
-			gchar *rssi = g_strdup_printf("%ddbm", interface_properties.rssi);
-			jobject_put(*reply, J_CSTR_TO_JVAL("RSSI"), jstring_create(rssi));
-			g_free(rssi);
-
-			jobject_put(*reply, J_CSTR_TO_JVAL("linkSpeed"),
-			            jnumber_create_i32(interface_properties.link_speed));
-
-			if (interface_properties.link_speed < 6 ||
-			        interface_properties.link_speed == 11)
-			{
-				jobject_put(*reply, J_CSTR_TO_JVAL("txpwr"), jstring_create("17 dBm"));
-			}
-			else
-			{
-				jobject_put(*reply, J_CSTR_TO_JVAL("txpwr"), jstring_create("14 dBm"));
-			}
-
-			int ch = convert_frequency_to_channel(interface_properties.frequency);
-
-			if (ch > 0)
-			{
-				gchar *channel =  g_strdup_printf("%d", ch);
-				jobject_put(*reply, J_CSTR_TO_JVAL("channel"), jstring_create(channel));
-				g_free(channel);
-			}
-		}
-	}
-
-	if (is_wifi_powered())
-	{
-		jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("Power on"));
-	}
-
-	gchar wifi_mac_address[MAC_ADDR_STRING_LEN];
-
-	if (retrieve_wifi_mac_address(wifi_mac_address, MAC_ADDR_STRING_LEN))
-	{
-		jobject_put(*reply, J_CSTR_TO_JVAL("macAddress"),
-		            jstring_create(wifi_mac_address));
-	}
-
-	connman_service_t *connected_service = connman_manager_get_connected_service(
-	        manager->wifi_services);
-
-	if (connected_service != NULL)
-	{
-		if (connected_service->name != NULL)
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("ssid"),
-			            jstring_create(connected_service->name));
-		}
-
-		int wifi_state = connman_service_get_state(connected_service->state);
-
-		if (wifi_state == CONNMAN_SERVICE_STATE_ONLINE ||
-		        wifi_state == CONNMAN_SERVICE_STATE_READY)
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("CONNECTED"));
-
-			if (connected_service->ipinfo.ipv4.address)
-			{
-				jobject_put(*reply, J_CSTR_TO_JVAL("ipAddress"),
-				            jstring_create(connected_service->ipinfo.ipv4.address));
-			}
-		}
-		else if (wifi_state == CONNMAN_SERVICE_STATE_ASSOCIATION ||
-		         wifi_state == CONNMAN_SERVICE_STATE_CONFIGURATION)
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("state"), jstring_create("CONNECTING"));
-		}
-
-		if (connected_service->hidden)
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("hi_op"), jstring_create("Hidden"));
-		}
-		else
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("hi_op"), jstring_create("Open"));
-		}
-
-		if (connected_service->address != NULL)
-		{
-			jobject_put(*reply, J_CSTR_TO_JVAL("amac"),
-			            jstring_create(connected_service->address));
-		}
-
-	}
-
-	return TRUE;
-}
-
-
-static void send_wifi_diagnostics_to_subscribers(void)
-{
-	jvalue_ref reply = jobject_create();
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-
-	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
-	        manager);
-
-	if (make_wifi_diagnostics_payload(wifi_technology, &reply) == TRUE)
-	{
-		jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-		                              DOMOPT_NOOPT, NULL);
-
-		if (response_schema)
-		{
-			const char *payload = jvalue_tostring(reply, response_schema);
-			LSError lserror;
-			LSErrorInit(&lserror);
-
-			if (!LSSubscriptionReply(pLsHandle, LUNA_CATEGORY_ROOT LUNA_METHOD_GET_WIFI_DIAGNOSTICS,
-                                                 payload,
-			                         &lserror))
-			{
-				LSErrorPrint(&lserror, stderr);
-				LSErrorFree(&lserror);
-			}
-
-			jschema_release(&response_schema);
-		}
-	}
-
-	j_release(&reply);
-}
-
 static gboolean signal_polling_cb(gpointer user_data)
 {
 	connman_service_t *connected_service = connman_manager_get_connected_service(
@@ -2124,11 +1861,6 @@ static gboolean signal_polling_cb(gpointer user_data)
 		guchar old_strength = connected_service->strength;
 		connected_service->strength = interface_properties.rssi + 120;
 
-		if (old_strength != connected_service->strength)
-		{
-			send_wifi_diagnostics_to_subscribers();
-		}
-
 		if (signal_strength_to_bars(old_strength) != signal_strength_to_bars(
 		            connected_service->strength))
 		{
@@ -2143,20 +1875,10 @@ static gboolean signal_polling_cb(gpointer user_data)
 
 static void start_signal_polling()
 {
-	// start signal polling only if there are subscribers for "getwifidiagnositcs" and
-	// the wifi technology interface doesn't support diagnostic info
-	if ((LSSubscriptionGetHandleSubscribersCount(pLsHandle,
-	        LUNA_CATEGORY_ROOT LUNA_METHOD_GET_WIFI_DIAGNOSTICS) == 0)
-	        && (LSSubscriptionGetHandleSubscribersCount(pLsHandle,
-	                LUNA_CATEGORY_ROOT LUNA_METHOD_GET_WIFI_DIAGNOSTICS) == 0))
-	{
-		return;
-	}
-
 	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
 	        manager);
 
-	if (!wifi_technology->diagnostic_info && 0 == signal_polling_timeout_source)
+	if (0 == signal_polling_timeout_source)
 	{
 		signal_polling_timeout_source = g_timeout_add_seconds(3, signal_polling_cb,
 		                                NULL);
@@ -2226,23 +1948,6 @@ static void technology_property_changed_callback(gpointer data,
 
 		}
 
-		if (g_strcmp0(property, "Tethering") == 0 ||
-		    g_strcmp0(property, "TetheringIdentifier") == 0 ||
-		    g_strcmp0(property, "TetheringPassphrase") == 0)
-		{
-			send_tethering_state_to_subscribers();
-			connectionmanager_send_status_to_subscribers();
-			wifi_send_status_to_subscribers();
-		}
-
-		if(g_strcmp0(property, "StaCount") == 0) {
-			send_sta_count_to_subscribers();
-		}
-
-		if (!g_strcmp0(property, "DiagnosticInfo"))
-		{
-			send_wifi_diagnostics_to_subscribers();
-		}
 	}
 	else if (technology == connman_manager_find_ethernet_technology(manager))
 	{
@@ -3736,289 +3441,6 @@ static bool handle_cancel_wps_command(LSHandle *sh, LSMessage *message,
 	return true;
 }
 
-
-
-//->Start of API documentation comment block
-/**
-@page com_webos_wifi com.webos.wifi
-@{
-@section com_webos_wifi_setmultichannelschedmode setmultichannelschedmode
-
-Set the multi channel scheduling mode for wifi technology
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-mode | Yes | Integer | 0 for fair, 1 for sta, 2 for p2p
-
-@par Returns(Call) for all forms
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | Yes | Boolean | True
-
-@par Returns(Subscription)
-
-Not applicable.
-
-@}
-*/
-//->End of API documentation comment block
-
-static bool handle_set_multichannel_sched_mode_command(LSHandle *sh,
-        LSMessage *message, void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!wifi_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(mode, integer)) REQUIRED_1(mode))),
-	                             &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref modeObj = NULL;
-	gint32 mode = 0;
-
-	connman_technology_t *technology = connman_manager_find_wifi_technology(
-	                                       manager);
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("mode"), &modeObj))
-	{
-		jnumber_get_i32(modeObj, &mode);
-
-		if (mode != technology->multi_channel_mode &&
-		        !connman_technology_set_multi_channel_mode(technology, mode))
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Error in changing multi channel sched mode",
-			                          WCA_API_ERROR_MULTI_CHAN_SCHED_MODE);
-			goto cleanup;
-		}
-	}
-	else
-	{
-		LSMessageReplyErrorInvalidParams(sh, message);
-		goto cleanup;
-	}
-
-	LSMessageReplySuccess(sh, message);
-cleanup:
-	j_release(&parsedObj);
-	return true;
-}
-
-//->Start of API documentation comment block
-/**
-@page com_webos_wifi com.webos.wifi
-@{
-@section com_webos_wifi_getmultichannelschedmode getmultichannelschedmode
-
-Get the multi channel scheduling mode for wifi technology
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-None
-
-@par Returns(Call) for all forms
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | Yes | Boolean | True
-mode | Yes | Integer | 0 for fair, 1 for sta, 2 for p2p
-
-@par Returns(Subscription)
-
-Not applicable.
-
-@}
-*/
-//->End of API documentation comment block
-
-static bool handle_get_multichannel_sched_mode_command(LSHandle *sh,
-        LSMessage *message, void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!wifi_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	jvalue_ref reply = jobject_create();
-	LSError lserror;
-	LSErrorInit(&lserror);
-
-	connman_technology_t *technology = connman_manager_find_wifi_technology(
-	                                       manager);
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("mode"),
-	            jnumber_create_i32(technology->multi_channel_mode));
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (!response_schema)
-	{
-		LSMessageReplyErrorUnknown(sh, message);
-		goto cleanup;
-	}
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
-	                    &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	jschema_release(&response_schema);
-
-cleanup:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	j_release(&reply);
-	return true;
-}
-
-//->Start of API documentation comment block
-/**
-@page com_webos_wifi com.webos.wifi
-@{
-@section com_webos_wifi_getwifidiagnostics getwifidiagnostics
-
-Get the wifi diagnostic information from the driver.
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-None
-
-@par Returns(Call) for all forms
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | Yes | Boolean | True
-version | Yes | String | Version info
-ccode | Yes | String | Country code
-ccodeRev | Yes | String | Country code revision
-channel | Yes | String | Channel
-MCS | Yes | String | MCS
-MIMO | Yes | String | MIMO
-rate | Yes | String | Rate
-RSSI | Yes | String | RSSI
-noise | Yes | String | Noise level
-txpwr | Yes | String | Txpwr
-
-@par Returns(Subscription)
-
-As for a successful call
-
-@}
-*/
-//->End of API documentation comment block
-
-static bool handle_get_wifi_diagnostics_command(LSHandle *sh,
-        LSMessage *message, void *context)
-{
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref reply = jobject_create();
-	bool subscribed = false;
-	LSError lserror;
-	LSErrorInit(&lserror);
-
-	if (LSMessageIsSubscription(message))
-	{
-		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	if (!is_wifi_powered())
-	{
-		LSMessageReplyCustomErrorWithSubscription(sh, message, "WiFi switched off",
-		        WCA_API_ERROR_WIFI_SWITCHED_OFF, subscribed);
-		goto cleanup;
-	}
-
-	connman_technology_t *technology = connman_manager_find_wifi_technology(
-	                                       manager);
-	connman_technology_update_properties(technology);
-
-	make_wifi_diagnostics_payload(technology, &reply);
-
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (!response_schema)
-	{
-		LSMessageReplyErrorUnknown(sh, message);
-		goto cleanup;
-	}
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
-	                    &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	jschema_release(&response_schema);
-cleanup:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	j_release(&reply);
-	return true;
-}
-
 static void handle_luna_subscription_cancel(LSHandle *sh, LSMessage *message, void *ctx)
 {
 	const char *category = LSMessageGetCategory(message);
@@ -4032,103 +3454,6 @@ static void handle_luna_subscription_cancel(LSHandle *sh, LSMessage *message, vo
 	}
 }
 
-static void set_passthrough_params_cb(bool success, jvalue_ref params,
-                                      void *user_data)
-{
-	luna_service_request_t *service_req = (luna_service_request_t *) user_data;
-	LSHandle *sh = NULL;
-	LSMessage *message = NULL;
-
-	if (service_req)
-	{
-		sh = service_req->handle;
-		message = service_req->message;
-	}
-
-	if (success)
-	{
-		if (params)
-		{
-			jvalue_ref reply = jobject_create();
-			LSError lserror;
-			LSErrorInit(&lserror);
-			jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-			jobject_put(reply,  J_CSTR_TO_JVAL("params"), params);
-			jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-			                              DOMOPT_NOOPT, NULL);
-
-			if (response_schema)
-			{
-				if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
-				                    &lserror))
-				{
-					LSErrorPrint(&lserror, stderr);
-					LSErrorFree(&lserror);
-				}
-
-				jschema_release(&response_schema);
-			}
-			else
-			{
-				LSMessageReplyErrorUnknown(sh, message);
-			}
-
-			if (LSErrorIsSet(&lserror))
-			{
-				LSErrorPrint(&lserror, stderr);
-				LSErrorFree(&lserror);
-			}
-
-			j_release(&reply);
-		}
-		else
-		{
-			LSMessageReplySuccess(sh, message);
-		}
-	}
-	else
-		LSMessageReplyCustomError(sh, message,
-		                          "Error in setting passthrough parameters",
-		                          WCA_API_ERROR_SET_PASSTHROUGH_PARAMS_FAILED);
-
-	if (service_req)
-	{
-		luna_service_request_free(service_req);
-	}
-}
-
-static bool handle_set_passthrough_params_command(LSHandle *sh,
-        LSMessage *message, void *context)
-{
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_ANY),
-	                             &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref paramsObj = {0};
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("params"), &paramsObj))
-	{
-		luna_service_request_t *service_req = luna_service_request_new(sh, message);
-
-		if (wca_support_wifi_set_passthrough_params(paramsObj,
-		        set_passthrough_params_cb, service_req))
-			LSMessageReplyCustomError(sh, message,
-			                          "Error in setting passthrough parameters",
-			                          WCA_API_ERROR_SET_PASSTHROUGH_PARAMS_FAILED);
-	}
-	else
-	{
-		LSMessageReplyErrorInvalidParams(sh, message);
-	}
-
-	j_release(&parsedObj);
-	return true;
-}
-
 static void agent_registered_callback(gpointer user_data)
 {
 	gchar *agent_path;
@@ -4262,10 +3587,6 @@ static LSMethod wifi_methods[] =
 	{ LUNA_METHOD_CREATEWPSPIN,         handle_create_wpspin_command },
 	{ LUNA_METHOD_STARTWPS,     handle_start_wps_command },
 	{ LUNA_METHOD_CANCELWPS,        handle_cancel_wps_command },
-	{ LUNA_METHOD_SET_MCHANNSCHED_MODE, handle_set_multichannel_sched_mode_command },
-	{ LUNA_METHOD_GET_MCHANNSCHED_MODE, handle_get_multichannel_sched_mode_command },
-	{ LUNA_METHOD_GET_WIFI_DIAGNOSTICS, handle_get_wifi_diagnostics_command },
-	{ LUNA_METHOD_SET_PASSTHROUGH_PARAMS, handle_set_passthrough_params_command },
 	{ },
 };
 
diff --git a/src/wifi_service.h b/src/wifi_service.h
index ac23a90..b51d7db 100644
--- a/src/wifi_service.h
+++ b/src/wifi_service.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -47,10 +47,6 @@
 #define LUNA_METHOD_CREATEWPSPIN            "createwpspin"
 #define LUNA_METHOD_STARTWPS                "startwps"
 #define LUNA_METHOD_CANCELWPS               "cancelwps"
-#define LUNA_METHOD_SET_MCHANNSCHED_MODE    "setmultichannelschedmode"
-#define LUNA_METHOD_GET_MCHANNSCHED_MODE    "getmultichannelschedmode"
-#define LUNA_METHOD_GET_WIFI_DIAGNOSTICS    "getwifidiagnostics"
-#define LUNA_METHOD_SET_PASSTHROUGH_PARAMS  "setPassthroughParams"
 
 
 #define WIFI_ENTERPRISE_SECURITY_TYPE       "ieee8021x"
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
deleted file mode 100644
index a0c3ffd..0000000
--- a/src/wifi_tethering_service.c
+++ /dev/null
@@ -1,892 +0,0 @@
-// Copyright (c) 2014-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-/**
- * @file  wifi_tethering_service.c
- *
- * @brief Implements the com.webos.service.wifi/tethering service API with using connman in the backend.
- */
-
-/**
- *  @brief Initialize com.webos.service.wifi/p2p service and all of its methods
- */
-
-#include <glib.h>
-#include <stdbool.h>
-#include <string.h>
-
-#include <wca-support.h>
-
-#include "wifi_tethering_service.h"
-#include "wifi_service.h"
-#include "connman_manager.h"
-#include "lunaservice_utils.h"
-#include "connman_common.h"
-#include "common.h"
-#include "logging.h"
-#include "errors.h"
-
-#define WIFI_STATUS_TIMEOUT     1
-#define WIFI_TETHERING_USED_RX_BYTES_TRESHOLD(x)        5000*x
-
-LSHandle *tetheringpLSHandle = NULL;
-
-static gboolean previous_wifi_legacy_powered = FALSE;
-
-static guint wifi_tethering_timeout = 5;
-static guint wifi_tethering_timeout_source = 0;
-static guint wifi_tethering_client_count = 0;
-
-void start_tethering_timeout(void);
-
-static void support_tethering_disabled_cb(bool success, void *user_data)
-{
-	LSMessage *message = user_data;
-	LSHandle *handle = 0;
-
-	if (message)
-	{
-		handle = LSMessageGetConnection(message);
-	}
-
-	if (!success)
-	{
-		if (message)
-			LSMessageReplyCustomError(handle, message,
-			                          "Failed to disable tethering mode through support library",
-			                          WCA_API_ERROR_TETHERING_SUPPORT_FAILED);
-
-		return;
-	}
-
-	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
-
-	if (!wifi_tech)
-	{
-		if (message)
-			LSMessageReplyCustomError(handle, message, "WiFi technology unavailable",
-			                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
-
-		return;
-	}
-
-	if (!connman_technology_set_tethering(wifi_tech, FALSE))
-	{
-		if (message)
-			LSMessageReplyCustomError(handle, message, "Failed to disable tethering mode",
-			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
-
-		return;
-	}
-
-
-	if (!previous_wifi_legacy_powered &&
-	        !connman_technology_set_powered(wifi_tech, FALSE, NULL))
-	{
-		if (message)
-			LSMessageReplyCustomError(handle, message,
-			                          "Failed to restore WiFi state after disbling tethering",
-			                          WCA_API_ERROR_TETHERING_RESTORE_WIFI_STATE_FAILED);
-
-		return;
-	}
-
-	LSMessageReplySuccess(handle, message);
-}
-
-static void support_tethering_disabled_after_failure_cb(bool success,
-        void *user_data)
-{
-	(void) success;
-
-	LSMessage *message = user_data;
-
-	if (!message)
-	{
-		return;
-	}
-
-	LSHandle *handle = LSMessageGetConnection(message);
-
-	LSMessageReplyCustomError(handle, message, "Failed to enable tethering mode",
-	                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
-}
-
-static void support_tethering_enabled_cb(bool success, void *user_data)
-{
-	LSMessage *message = user_data;
-	LSHandle *handle = 0;
-
-	if (message)
-	{
-		handle = LSMessageGetConnection(message);
-	}
-
-	if (!success)
-	{
-		if (message)
-			LSMessageReplyCustomError(handle, message,
-			                          "Failed to enable tethering mode through support library",
-			                          WCA_API_ERROR_TETHERING_SUPPORT_FAILED);
-
-		return;
-	}
-
-	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
-
-	if (!wifi_tech)
-	{
-		if (message)
-			LSMessageReplyCustomError(handle, message, "WiFi technology unavailable",
-			                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
-
-		return;
-	}
-
-	if (!connman_technology_set_tethering(wifi_tech, TRUE))
-	{
-		/* disable tethering support again */
-		wca_support_wifi_disable_tethering(support_tethering_disabled_after_failure_cb,
-		                                   message);
-		return;
-	}
-
-	wifi_tethering_client_count = 0;
-	start_tethering_timeout();
-
-	if (message)
-	{
-		LSMessageReplySuccess(handle, message);
-	}
-}
-
-/**
- *  @brief Sets the wifi technologies tethering state
- *
- *  @param state
- */
-
-gboolean set_wifi_tethering(bool state, LSMessage *message)
-{
-	if (state == is_wifi_tethering())
-	{
-		return false;
-	}
-
-	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
-
-	if (!is_wifi_powered() && state)
-	{
-		previous_wifi_legacy_powered = FALSE;
-
-		// we need to have WiFI powered otherwise we can't start tethering
-		connman_technology_set_powered(wifi_tech, TRUE, NULL);
-
-		// FIXME this should go away once we switch to asynchronous variant of
-		// connman_technology_set_powered method
-		g_usleep(2000000);
-	}
-	else if (is_wifi_powered() && state)
-	{
-		previous_wifi_legacy_powered = TRUE;
-	}
-
-	if (state)
-	{
-		connman_service_t *connected_service = connman_manager_get_connected_service(
-		        manager->wifi_services);
-
-		if (connected_service)
-		{
-			connman_service_disconnect(connected_service);
-		}
-
-		wca_support_wifi_enable_tethering(support_tethering_enabled_cb, message);
-	}
-	else
-	{
-		wca_support_wifi_disable_tethering(support_tethering_disabled_cb, message);
-	}
-
-	return TRUE;
-}
-
-static void send_tethering_state(jvalue_ref *reply)
-{
-	if (NULL == reply)
-	{
-		return;
-	}
-
-	jobject_put(*reply, J_CSTR_TO_JVAL("enabled"),
-	            jboolean_create(is_wifi_tethering()));
-
-	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
-
-	if (NULL != wifi_tech->tethering_identifier)
-	{
-		jobject_put(*reply, J_CSTR_TO_JVAL("ssid"),
-		            jstring_create(wifi_tech->tethering_identifier));
-	}
-
-	if (NULL != wifi_tech->tethering_identifier)
-	{
-		jobject_put(*reply, J_CSTR_TO_JVAL("securityType"),
-		            jstring_create((NULL != wifi_tech->tethering_passphrase)
-		                           && (strlen(wifi_tech->tethering_passphrase) != 0) ? "psk" : "open"));
-	}
-
-	jobject_put(*reply, J_CSTR_TO_JVAL("timeout"),
-	            jnumber_create_i32(wifi_tethering_timeout));
-}
-
-void send_tethering_state_to_subscribers(void)
-{
-	jvalue_ref reply = jobject_create();
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
-
-	send_tethering_state(&reply);
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (response_schema)
-	{
-		const char *payload = jvalue_tostring(reply, response_schema);
-		WCALOG_DEBUG("Sending payload : %s", payload);
-		LSError lserror;
-		LSErrorInit(&lserror);
-
-		if (!LSSubscriptionReply(tetheringpLSHandle, "/tethering/getState",
-		                        payload,
-		                        &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-
-		jschema_release(&response_schema);
-	}
-
-	j_release(&reply);
-
-}
-
-static void send_sta_count(jvalue_ref *reply)
-{
-	if(NULL == reply)
-		return;
-
-	unsigned int sta_count = connman_manager_get_sta_count(manager);
-	jobject_put(*reply, J_CSTR_TO_JVAL("stationCount"), jnumber_create_i32(sta_count));
-}
-
-void send_sta_count_to_subscribers(void)
-{
-	jvalue_ref reply = jobject_create();
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
-
-	send_sta_count(&reply);
-
-	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
-	if(response_schema)
-	{
-		const char *payload = jvalue_tostring(reply, response_schema);
-		WCALOG_DEBUG("Sending payload : %s",payload);
-		LSError lserror;
-		LSErrorInit(&lserror);
-
-		if (!LSSubscriptionReply(tetheringpLSHandle, "/tethering/getStationCount", payload, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-
-		jschema_release(&response_schema);
-	}
-
-	j_release(&reply);
-}
-
-static gboolean tethering_timeout_cb(gpointer user_data)
-{
-	WCALOG_DEBUG("WiFi tethering timeout occured. Disable tethering.");
-
-	set_wifi_tethering(FALSE, 0);
-
-	wifi_tethering_timeout_source = 0;
-
-	return FALSE;
-}
-
-static void sta_authorized_cb(gpointer user_data)
-{
-	wifi_tethering_client_count++;
-
-	// If timer is no longer active we don't have anything to do here
-	if (wifi_tethering_timeout_source == 0)
-	{
-		return;
-	}
-
-	WCALOG_DEBUG("Got new WiFi tethering client");
-
-	// Now that we have a client connected to our AP we can stop
-	// the timeout.
-	if (wifi_tethering_timeout_source != 0)
-	{
-		WCALOG_DEBUG("Abort running tethering timer");
-		g_source_remove(wifi_tethering_timeout_source);
-		wifi_tethering_timeout_source = 0;
-	}
-}
-
-static void sta_deauthorized_cb(gpointer user_data)
-{
-	wifi_tethering_client_count--;
-
-	WCALOG_DEBUG("WiFi tethering client disconnected");
-
-	if (wifi_tethering_client_count > 0)
-	{
-		WCALOG_DEBUG("Not restarting timeout as we have %d clients left",
-		             wifi_tethering_client_count);
-		return;
-	}
-
-	start_tethering_timeout();
-}
-
-void start_tethering_timeout(void)
-{
-	if (wifi_tethering_timeout == 0 || wifi_tethering_timeout_source != 0)
-	{
-		return;
-	}
-
-	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
-
-	WCALOG_DEBUG("Setting WiFi tethering timeout to %d minutes",
-	             wifi_tethering_timeout);
-
-	// Make sure our handler gets registered with the WiFi technology
-	// to get known when a new STA connects
-	connman_technology_register_sta_authorized_cb(wifi_tech, sta_authorized_cb,
-	        NULL);
-	connman_technology_register_sta_deauthorized_cb(wifi_tech, sta_deauthorized_cb,
-	        NULL);
-
-	wifi_tethering_timeout_source = g_timeout_add_seconds(wifi_tethering_timeout *
-	                                60,
-	                                tethering_timeout_cb, NULL);
-}
-
-/////////////////////////////////////////////////////////////////
-//                                                             //
-//            Start of API documentation comment block         //
-//                                                             //
-/////////////////////////////////////////////////////////////////
-/**
-@page com_webos_service_wifi com.webos.service.wifi/tethering/setState
-@{
-@section com_webos_service_wifi_tethering_setstate setState
-
-Set tethering state.
-
-@par Parameters
-
-Name | Required | Type | Description
------|--------|------|----------
-enabled | No | boolean | enable / disable tethering
-ssid | No | String | The tethering broadcasted identifier
-passPhrase | No | String | The tethering connection passphrase
-
-@par Returns(Call) for all forms
-
-Name | Required | Type | Description
------|--------|------|----------
-returnValue | Yes | Boolean | True, if call was successful. False otherwise.
-errorText | No | String | Error text when call was not successful.
-errorCode | No | Integer | Error code when call was not successful.
-
-@par Returns(Subscription)
-Not applicable.
-
-@}
-*/
-/////////////////////////////////////////////////////////////////
-//                                                             //
-//            End of API documentation comment block           //
-//                                                             //
-/////////////////////////////////////////////////////////////////
-
-static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
-                                     void *context)
-{
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(enabled, boolean),
-	                                     PROP(ssid, string), PROP(passPhrase, string), PROP(securityType, string),
-	                                     PROP(timeout, integer)))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref enabledObj = {0}, ssidObj = {0}, passPhraseObj = {0}, securityTypeObj
-	                                       = {0}, timeoutObj = {0};
-	gboolean enable_tethering = FALSE, invalidArg = TRUE;
-	gchar *ssid = NULL, *passphrase = NULL;
-	int timeout = 0;
-	gboolean is_open = FALSE;
-	gboolean state_set = FALSE;
-
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	if (!wifi_technology_status_check(sh, message))
-	{
-		return true;
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
-	{
-		if (is_wifi_tethering())
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Not allowed to change SSID while tethering is enabled",
-			                          WCA_API_ERROR_TETHERING_SSID_FAILED);
-			goto cleanup;
-		}
-
-		raw_buffer ssid_buf = jstring_get(ssidObj);
-		ssid = g_strdup(ssid_buf.m_str);
-		jstring_free_buffer(ssid_buf);
-
-		if (NULL == ssid)
-		{
-			goto invalid_params;
-		}
-
-		invalidArg = FALSE;
-
-		if (!connman_technology_set_tethering_identifier(
-		            connman_manager_find_wifi_technology(manager), ssid))
-		{
-			LSMessageReplyCustomError(sh, message, "Error in setting tethering SSID",
-			                          WCA_API_ERROR_TETHERING_SSID_FAILED);
-			goto cleanup;
-		}
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("securityType"),
-	                       &securityTypeObj))
-	{
-		if (is_wifi_tethering())
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Not allowed to change securityType while tethering is enabled",
-			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_SEC_TYPE);
-			goto cleanup;
-		}
-
-		if (jstring_equal2(securityTypeObj, J_CSTR_TO_BUF("open")))
-		{
-			is_open = TRUE;
-		}
-		else if (jstring_equal2(securityTypeObj, J_CSTR_TO_BUF("psk")))
-		{
-			is_open = FALSE;
-		}
-		else
-		{
-			goto invalid_params;
-		}
-
-		if (is_open &&
-		        !connman_technology_set_tethering_passphrase(
-		            connman_manager_find_wifi_technology(manager), ""))
-		{
-			LSMessageReplyCustomError(sh, message, "Error in setting tethering passphrase",
-			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
-			goto cleanup;
-		}
-
-		invalidArg = FALSE;
-	}
-
-	if (!is_open &&
-	        jobject_get_exists(parsedObj, J_CSTR_TO_BUF("passPhrase"), &passPhraseObj))
-	{
-		if (is_wifi_tethering())
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Not allowed to change passphrase while tethering is enabled",
-			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
-			goto cleanup;
-		}
-
-		raw_buffer passphrase_buf = jstring_get(passPhraseObj);
-		passphrase = g_strdup(passphrase_buf.m_str);
-		jstring_free_buffer(passphrase_buf);
-
-		if (NULL == passphrase)
-		{
-			goto invalid_params;
-		}
-
-		if (!is_open && (!passphrase || strlen(passphrase) == 0))
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "No passphrase set but required for security type psk",
-			                          WCA_API_ERROR_TETHERING_NO_PASSPHRASE);
-			goto cleanup;
-		}
-
-		int passphrase_length = strlen(passphrase);
-
-		if (!is_open && (passphrase_length < 8 || passphrase_length > 63))
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Passphrase doesn't match the requirements",
-			                          WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID);
-			goto cleanup;
-		}
-
-		if (is_open && passphrase != NULL && strlen(passphrase) > 0)
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "With security typen open specifying a passphrase is not possible",
-			                          WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED);
-			goto cleanup;
-		}
-
-		invalidArg = FALSE;
-
-		if (!is_open &&
-		        !connman_technology_set_tethering_passphrase(
-		            connman_manager_find_wifi_technology(manager), passphrase))
-		{
-			LSMessageReplyCustomError(sh, message, "Error in setting tethering passphrase",
-			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
-			goto cleanup;
-		}
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("timeout"), &timeoutObj))
-	{
-		if (is_wifi_tethering())
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Not allowed to change timeout while tethering is enabled",
-			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT);
-			goto cleanup;
-		}
-
-		jnumber_get_i32(timeoutObj, &timeout);
-
-		if (timeout < 0)
-		{
-			LSMessageReplyCustomError(sh, message,
-			                          "Negative values are not allowed for the timeout",
-			                          WCA_API_ERROR_TETHERING_TIMEOUT_NO_NEGATIVE_VALUES);
-			goto cleanup;
-		}
-
-		wifi_tethering_timeout = timeout;
-
-		invalidArg = FALSE;
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
-	{
-		jboolean_get(enabledObj, &enable_tethering);
-
-		if (enable_tethering && is_wifi_tethering())
-		{
-			LSMessageReplyCustomError(sh, message, "Already Enabled",
-			                          WCA_API_ERROR_ALREADY_ENABLED);
-			goto cleanup;
-		}
-		else if (!enable_tethering && !is_wifi_tethering())
-		{
-			LSMessageReplyCustomError(sh, message, "Already Disabled",
-			                          WCA_API_ERROR_ALREADY_DISABLED);
-			goto cleanup;
-		}
-
-		state_set = TRUE;
-		invalidArg = FALSE;
-	}
-
-	if (invalidArg == TRUE)
-	{
-		goto invalid_params;
-	}
-
-	if (state_set && !set_wifi_tethering(enable_tethering, message))
-	{
-		if (enable_tethering)
-		{
-			LSMessageReplyCustomError(sh, message, "Failed to enable tethering mode",
-			                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
-		}
-		else
-		{
-			LSMessageReplyCustomError(sh, message, "Failed to disable tethering mode",
-			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
-		}
-
-		goto cleanup;
-	}
-	else
-	{
-		LSMessageReplySuccess(sh, message);
-	}
-
-	goto cleanup;
-
-invalid_params:
-	LSMessageReplyErrorInvalidParams(sh, message);
-
-cleanup:
-	g_free(ssid);
-	g_free(passphrase);
-	j_release(&parsedObj);
-	return true;
-}
-
-/////////////////////////////////////////////////////////////////
-//                                                             //
-//            Start of API documentation comment block         //
-//                                                             //
-/////////////////////////////////////////////////////////////////
-/**
-@page com_webos_wifi com.webos.wifi/gettethering
-@{
-@page com_webos_service_wifi com.webos.service.wifi/tethering/getState
-@{
-@section com_webos_service_wifi_tethering_getstate getState
-
-Get current tethering state.
-
-@par Parameters
-subscribe | No | boolean | Subscribe for updates
-
-@par Returns(Call) for all forms
-
-Name | Required | Type | Description
------|--------|------|----------
-state | No | boolean | enable / disable tethering
-ssid | No | String | The tethering broadcasted identifier
-passPhrase | No | String |  The tethering connection passphrase
-securityType | No | String |  The tethering securityType
-returnValue | Yes | Boolean | True, if call was successful. False otherwise.
-errorText | No | String | Error text when call was not successful.
-errorCode | No | Integer | Error code when call was not successful.
-
-@par Returns(Subscription)
-subscribed | No | Boolean | True when successfully subscribed. False when unsubscribed or subscription was not possible.
-
-Not applicable.
-
-@}
-*/
-/////////////////////////////////////////////////////////////////
-//                                                             //
-//            End of API documentation comment block           //
-//                                                             //
-/////////////////////////////////////////////////////////////////
-
-static bool handle_get_state_command(LSHandle *sh, LSMessage *message,
-                                     void *context)
-{
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
-	{
-		return true;
-	}
-
-	jvalue_ref reply = jobject_create();
-	LSError lserror;
-	LSErrorInit(&lserror);
-	bool subscribed = false;
-
-	if (LSMessageIsSubscription(message))
-	{
-		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
-	{
-		goto cleanup;
-	}
-
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
-
-	send_tethering_state(&reply);
-
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
-
-	if (!response_schema)
-	{
-		LSMessageReplyErrorUnknown(sh, message);
-		goto cleanup;
-	}
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
-	                    &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	jschema_release(&response_schema);
-cleanup:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	j_release(&parsedObj);
-	j_release(&reply);
-
-	return true;
-}
-
-static bool handle_get_station_count_command(LSHandle *sh, LSMessage *message, void* context)
-{
-	jvalue_ref reply = jobject_create();
-	LSError lserror;
-	LSErrorInit(&lserror);
-	bool subscribed = false;
-
-	jvalue_ref parsedObj = {0};
-	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
-	{
-		j_release(&reply);
-		return true;
-	}
-
-	if (LSMessageIsSubscription(message))
-	{
-		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
-		{
-			LSErrorPrint(&lserror, stderr);
-			LSErrorFree(&lserror);
-		}
-	}
-
-	if(!connman_status_check_with_subscription(manager, sh, message, subscribed))
-		goto cleanup;
-
-	if(!wifi_technology_status_check_with_subscription(sh, message, subscribed))
-		goto cleanup;
-
-	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
-	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
-
-	send_sta_count(&reply);
-
-	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
-	if(!response_schema)
-	{
-		LSMessageReplyErrorUnknown(sh,message);
-		goto cleanup;
-	}
-
-	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema), &lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	jschema_release(&response_schema);
-cleanup:
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-	j_release(&parsedObj);
-	j_release(&reply);
-
-	return true;
-}
-
-/**
- * com.webos.service.wifi/tethering service Luna Method Table
- */
-
-static LSMethod wifi_tethering_methods[] =
-{
-	{ LUNA_METHOD_TETHERING_SETSTATE,              handle_set_state_command },
-	{ LUNA_METHOD_TETHERING_GETSTATE,              handle_get_state_command },
-	{ LUNA_METHOD_TETHERING_GETSTACOUNT,           handle_get_station_count_command },
-	{},
-};
-
-int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,
-                                        LSHandle *pLsHandle)
-{
-	LSError lserror;
-	LSErrorInit(&lserror);
-
-	if (NULL == mainloop)
-	{
-		goto Exit;
-	}
-
-	tetheringpLSHandle = pLsHandle;
-
-	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_TETHERING,
-	                       wifi_tethering_methods, NULL,
-	                       NULL, &lserror) == false)
-	{
-		WCALOG_ESCAPED_ERRMSG(MSGID_TETHERING_METHODS_LUNA_ERROR, lserror.message);
-		goto Exit;
-	}
-
-	return 0;
-Exit:
-
-	if (LSErrorIsSet(&lserror))
-	{
-		LSErrorPrint(&lserror, stderr);
-		LSErrorFree(&lserror);
-	}
-
-	return -1;
-}
diff --git a/src/wifi_tethering_service.h b/src/wifi_tethering_service.h
deleted file mode 100644
index 97ab40d..0000000
--- a/src/wifi_tethering_service.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright (c) 2014-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-/**
- * @file  wifi_tethering_service.h
- *
- */
-
-#ifndef _WIFI_TETHERING_SERVICE_H_
-#define _WIFI_TETHERING_SERVICE_H_
-
-#include <luna-service2/lunaservice.h>
-
-#define LUNA_CATEGORY_TETHERING              "/tethering"
-
-/**
- * @name Luna WiFi tethering Method Names
- * @{
- */
-
-#define LUNA_METHOD_TETHERING_SETSTATE       "setState"
-#define LUNA_METHOD_TETHERING_GETSTATE       "getState"
-#define LUNA_METHOD_TETHERING_GETSTACOUNT    "getStationCount"
-
-extern void send_tethering_state_to_subscribers(void);
-extern void send_sta_count_to_subscribers(void);
-extern int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,
-        LSHandle *pLsHandle);
-
-#endif /* _WIFI_TETHERING_SERVICE_H_ */

commit fad951df0a5592ad077b632f4f1c13697c56793c
Merge: bd55d9c aa41a3c
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Wed Jul 31 19:15:13 2019 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I76d6446a97916cbcc915bb2a5925daa761d92e60

commit 5ad9a50da901eb839f5595a4973ca26084e397a7
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Mon Aug 26 12:16:30 2019 +0530

    Fix issues occur with continuous connect calls
    
    :Release Notes:
    Fixed issues when continuously connecting with wrong/correct password.
    
    :Detailed Notes:
    Below issues observed when continuously connecting with
    wrong/correct password.
    
    1. An error message "The supplied password is incorrect", displayed
       when entered correct password. Because, sometimes, the response
       of previous dbus call comes late as a luna response. So we
       adjusted an optimal value of 120sec from  60sec as dbus timeout
       in webos-connman-adapter.
    2. For the scenario when we get connect failure, a callback
       for deleting the profile will be called only after 5 seconds in
       webos-connman-adapter. So, it was deleting the profile which was
       created for the next connect request. Because we are not
       validating    whether profile exists or not. So added changes,
       by calling delete_profile_if_not_connected() only if profile is
       created.
    3. When we trigger find network, the scan takes some time. When we
       call connect immediately after find networks, the network won't
       be available, so at that time, an error message "Unknown error"
       replied to luna call. So we added changes to call connect for
       connman after scan done.
    
    :Testing Performed:
    Build successfully.
    Executed test case QO-4339
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-84682] "errorText":"The supplied password is incorrect is not
                  displaying when password is entered wrong.
    
    Change-Id: Icaf665f76afa2ef98384b68a233286f6d7700f88

diff --git a/src/connman_service.c b/src/connman_service.c
index 4be3eb2..9026589 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -29,7 +29,7 @@
 #include "connectionmanager_service.h"
 
 /* gdbus default timeout is 25 seconds */
-#define DBUS_CALL_TIMEOUT   (60 * 1000)
+#define DBUS_CALL_TIMEOUT   (120 * 1000)
 
 /**
  * Check if the type of the service is wifi (see header for API details)
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 163f491..7252dbb 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -87,6 +87,11 @@ typedef struct current_service_data
 	connection_settings_t *settings;
 } current_service_data_t;
 
+typedef struct profile_info
+{
+       guint profile_id;
+       char *service_path;
+} profile_info_t;
 
 static gboolean check_wifi_services_for_updates(void);
 
@@ -460,7 +465,11 @@ static void wifi_send_status_to_subscribers(void)
  */
 static gboolean delete_profile_if_not_connected(gpointer user_data)
 {
-	char* service_path = (char*) user_data;
+	profile_info_t* failed_connection_profile_info = (profile_info_t*) user_data;
+	if(!failed_connection_profile_info && !failed_connection_profile_info->service_path)
+	{
+		return FALSE;
+	}
 
 	if (NULL == manager)
 	{
@@ -469,12 +478,12 @@ static gboolean delete_profile_if_not_connected(gpointer user_data)
 
 	connman_service_t *service = connman_manager_find_service_by_path(
 			manager->wifi_services,
-			service_path);
+			failed_connection_profile_info->service_path);
 
 	if (NULL == service)
 	{
 		WCALOG_INFO(MSGID_WIFI_SERVICE_NOT_EXIST, 0, "Service %s doesn't exist",
-		            service_path);
+		            failed_connection_profile_info->service_path);
 		goto cleanup;
 	}
 
@@ -486,7 +495,7 @@ static gboolean delete_profile_if_not_connected(gpointer user_data)
 		wifi_profile_t *profile = get_profile_by_ssid_security(service->name,
 		                          service->security[0]);
 
-		if (NULL != profile)
+		if (NULL != profile && (failed_connection_profile_info->profile_id == profile->profile_id))
 		{
 			delete_profile(profile);
 		}
@@ -498,6 +507,8 @@ static gboolean delete_profile_if_not_connected(gpointer user_data)
 	}
 
 cleanup:
+	g_free(failed_connection_profile_info->service_path);
+	failed_connection_profile_info->service_path = NULL;
 	g_free(user_data);
 	return FALSE;
 }
@@ -514,19 +525,19 @@ cleanup:
  * in src/service.c of the connman source tree for all currently handled errors.
  */
 
-static void handle_failed_connection_request(gpointer user_data)
+static gboolean handle_failed_connection_request(gpointer user_data)
 {
 	const char *error_message = "Unknown error";
 	unsigned int error_code = WCA_API_ERROR_UNKNOWN;
 
 	if (NULL == manager)
 	{
-		return;
+		return FALSE;
 	}
 
 	if (NULL == current_connect_req)
 	{
-		return;
+		return FALSE;
 	}
 
 	current_service_data_t *service_data = current_connect_req->user_data;
@@ -620,8 +631,16 @@ static void handle_failed_connection_request(gpointer user_data)
 		// In case of enterprise networks we always create a profile (even before connecting to it),
 		// so in case the connection fails, we should delete the profile and the corresponding config file
 		// Give it 2 sec for service to auto-connect
-		char* service_name = g_strdup(service->path);
-		g_timeout_add_seconds(5, delete_profile_if_not_connected, service_name);
+		wifi_profile_t *profile = get_profile_by_ssid_security(service->name,
+		                          service->security[0]);
+		if (profile) {
+			WCALOG_DEBUG(MSGID_WIFI_CONNECT_SERVICE, "profile present for failed connection so delete it after 5sec");
+			profile_info_t* failed_connection_profile_info = g_new0(profile_info_t, 1);
+			failed_connection_profile_info->service_path = g_strdup(service->path);
+			failed_connection_profile_info->profile_id = profile->profile_id;
+			g_timeout_add_seconds(5, delete_profile_if_not_connected, failed_connection_profile_info);
+		} else
+			connman_service_remove(service);
 	}
 
 #ifndef ENABLE_SINGLE_PROFILE
@@ -638,6 +657,7 @@ cleanup:
 	{
 		current_connect_req_free();
 	}
+	return FALSE;
 }
 
 /**
@@ -1673,17 +1693,8 @@ static void connect_wifi_with_ssid(const char *ssid, wifi_profile_t *profile,
 	 * have to wait until the scan has finished as connman needs to issue another one
 	 * for the hidden network to be able to connect it */
 
-	if (hidden)
-	{
-		wifi_scan_execute_when_scan_done(connect_after_scan_cb, NULL);
-	}
-	else if (!connman_service_connect(service, service_connect_callback,
-	                                  service_req))
-	{
-		current_connect_req = NULL;
-		LSMessageReplyErrorUnknown(service_req->handle, service_req->message);
-		goto cleanup;
-	}
+	// Connect after scan is done
+	wifi_scan_execute_when_scan_done(connect_after_scan_cb, NULL);
 
 	goto exit;
 

commit f6160b36d114b387004d5d878b8049565c6698f4
Merge: fad951d 5ad9a50
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Tue Sep 3 16:18:37 2019 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I3acd5ff02a9ad98a9741d13b7f0d695ee65b90c8

commit c6cbf2a8b67c173493fe3b23f141572ebfe02264
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Wed Sep 11 17:29:11 2019 +0530

    Fix coverity issues
    
    :Release Notes:
    Fix coverity issues
    
    :Detailed Notes:
    Fixing dereference after null check
    
    :Testing Performed:
    Build successfully.
    Ethernet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-85775] 258594 Dereference after null check (webos-connman-adapter)
    
    Change-Id: Id2f57dd1a95c0446cca4f5eb2d0415224df10081

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 7252dbb..e94fbe6 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -466,7 +466,7 @@ static void wifi_send_status_to_subscribers(void)
 static gboolean delete_profile_if_not_connected(gpointer user_data)
 {
 	profile_info_t* failed_connection_profile_info = (profile_info_t*) user_data;
-	if(!failed_connection_profile_info && !failed_connection_profile_info->service_path)
+	if((!failed_connection_profile_info) || !(failed_connection_profile_info->service_path))
 	{
 		return FALSE;
 	}

commit 8a9118f9e95a5ab02243db8914fc69a846a1a913
Merge: f6160b3 c6cbf2a
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Wed Sep 11 19:52:20 2019 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I5cff59f802dabf67cc535ea1c7947232a7957046

commit 295b907911abdd8e41a11b83e26b104ba4f2ed0b
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon Sep 23 17:27:49 2019 +0900

    Restore tethering service APIs
    
    :Release Notes:
    Restore implementation of tethering service APIs
    
    :Detailed Notes:
    This commit restores implementation of tethering service APIs
    to support SoftAP (Software Enabled Access Point) feature in
    OSE. Below APIs for com.webos.service.wifi service are restored.
    - "tethering/setState"
    - "tethering/getState"
    - "tethering/getStationCount"
    
    This commit has dependency with
    - http://gpro.lge.com/#/c/256433/
    - http://gpro.lge.com/#/c/256436/
    
    :Testing Performed:
    Build successfully.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-86154] Integrate SoftAP implementation to OSE
    
    Change-Id: I3c1fe25c02787d655b252c4486188721d2a7b985

diff --git a/CMakeLists.txt b/CMakeLists.txt
index bc3c45c..90988f1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -131,6 +131,7 @@ file(GLOB SOURCE_FILES
     src/nyx.c
     src/pacrunner_client.c
     src/utils.c
+    src/wifi_tethering_service.c
     src/wifi_profile.c
     src/wifi_service.c
     src/wifi_setting.c
diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index ddf3652..9ff2c2b 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -26,7 +26,10 @@
         "com.webos.service.wifi/getstatus",
         "com.webos.service.wifi/scan",
         "com.webos.service.wifi/setstate",
-        "com.webos.service.wifi/startwps"
+        "com.webos.service.wifi/startwps",
+        "com.webos.service.wifi/tethering/setState",
+        "com.webos.service.wifi/tethering/getState",
+        "com.webos.service.wifi/tethering/getStationCount"
     ],
     "networking": [
         "com.webos.service.connectionmanager/checkinternetstatus",
diff --git a/files/xml/connman.xml b/files/xml/connman.xml
index f7d60c5..54d2e1d 100644
--- a/files/xml/connman.xml
+++ b/files/xml/connman.xml
@@ -1,6 +1,6 @@
 <!-- LICENSE@@@
 
-Copyright (c) 2013-2019 LG Electronics, Inc.
+Copyright (c) 2013 LG Electronics, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -130,6 +130,8 @@ limitations under the License.
 			<arg type="v"/>
 		</signal>
 		<signal name="WPSFailed"/>
+		<signal name="TetheringStaAuthorized"/>
+		<signal name="TetheringStaDeauthorized"/>
 	</interface>
 	<interface name="net.connman.Service">
 		<method name="GetProperties">
diff --git a/src/common.c b/src/common.c
index 8b72fb1..cd48350 100644
--- a/src/common.c
+++ b/src/common.c
@@ -84,6 +84,19 @@ gboolean is_wifi_powered(void)
 	return (NULL != technology) && technology->powered;
 }
 
+/**
+ *  @brief Check wether the wifi technology is currently tethering (the "Tethering"
+ *         property has the value true)
+ *
+ * @return Returns true if wifi technology is currently tethering, false otherwise.
+ */
+gboolean is_wifi_tethering(void)
+{
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	return (NULL != technology) && technology->tethering;
+}
+
 /**
  *  @brief Check if the wifi technology is available. If the technology is not available
  *  an error message is send to the supplied luna message handle.
diff --git a/src/common.h b/src/common.h
index c1d2e7f..cf90e86 100644
--- a/src/common.h
+++ b/src/common.h
@@ -28,6 +28,7 @@ extern connman_agent_t *agent;
 extern gboolean connman_status_check(connman_manager_t *manager, LSHandle *sh,
                                      LSMessage *message);
 extern gboolean is_wifi_powered(void);
+extern gboolean is_wifi_tethering(void);
 extern gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message);
 extern gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
                                                         LSMessage *message, bool subscribed);
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index fc47020..6581c65 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -76,6 +76,7 @@ gboolean wired_connected = FALSE;
 gboolean wifi_connected = FALSE;
 gboolean p2p_connected = FALSE;
 guint block_getstatus_response = 0;
+gboolean old_wifi_tethering = FALSE;
 gboolean wired_plugged = FALSE;
 
 char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
@@ -422,6 +423,8 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	            jstring_create("disconnected"));
 	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("state"),
 	            jstring_create("disconnected"));
+	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
+	            jboolean_create(is_wifi_tethering()));
 	jobject_put(disconnected_p2p_status, J_CSTR_TO_JVAL("state"),
 	            jstring_create("disconnected"));
 
@@ -457,6 +460,10 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	{
 		update_connection_status(connected_wifi_service, &connected_wifi_status);
 
+		// When we're connected to a WiFi service we can't have tethering enabled
+		jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
+		            jboolean_create(false));
+
 		jobject_put(*reply, J_CSTR_TO_JVAL("wifi"), connected_wifi_status);
 		j_release(&disconnected_wifi_status);
 	}
@@ -548,6 +555,12 @@ static gboolean check_update_is_needed(void)
 		return FALSE;
 	}
 
+	if (old_wifi_tethering != is_wifi_tethering())
+	{
+		old_wifi_tethering = is_wifi_tethering();
+		needed = TRUE;
+	}
+
 	gboolean old_online_status = online_status;
 
 	online_status = connman_manager_is_manager_online(manager);
@@ -1484,6 +1497,11 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 		}
 		else
 		{
+			if (enable_offline && is_wifi_tethering())
+			{
+				set_wifi_tethering(!enable_offline);
+			}
+
 			connman_manager_set_offlinemode(manager, enable_offline);
 		}
 
diff --git a/src/connman_group.c b/src/connman_group.c
index 6a26cc8..1b97775 100644
--- a/src/connman_group.c
+++ b/src/connman_group.c
@@ -26,6 +26,39 @@
 #include "logging.h"
 #include "common.h"
 
+/**
+ * @brief Set the group's tethering property
+ *
+ * @param group Group object to operate on
+ * @param enable TRUE to enable tethering or FALSE to disable it
+ * @return TRUE if operation was successfull. FALSE otherwise.
+ */
+
+gboolean connman_group_set_tethering(connman_group_t *group, gboolean enable)
+{
+	if (NULL == group)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_group_call_set_property_sync(group->remote,
+	        "Tethering",
+	        g_variant_new_variant(g_variant_new_boolean(enable)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_GROUP_SET_PROPERTY_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	group->tethering = enable;
+	return TRUE;
+}
+
 /**
  * @brief Disconnect from a connman group
  *
@@ -120,6 +153,10 @@ static void __connman_group_update_property(connman_group_t *group,
 	{
 		group->is_persistent = g_variant_get_boolean(val);
 	}
+	else if (!g_strcmp0(name, "Tethering"))
+	{
+		group->tethering = g_variant_get_boolean(val);
+	}
 	else if (!g_strcmp0(name, "Freq"))
 	{
 		group->freq = g_variant_get_uint32(val);
diff --git a/src/connman_group.h b/src/connman_group.h
index 5ef62dd..c5880ec 100644
--- a/src/connman_group.h
+++ b/src/connman_group.h
@@ -45,12 +45,15 @@ typedef struct connman_group
 	gchar *local_address;
 	gboolean is_group_owner;
 	gboolean is_persistent;
+	gboolean tethering;
 	gint freq;
 	GSList *peer_list;
 	gulong sighandler_id;
 	connman_property_changed_cb     handle_property_change_fn;
 } connman_group_t;
 
+extern gboolean connman_group_set_tethering(connman_group_t *group,
+        gboolean state);
 extern gboolean connman_group_disconnect(connman_group_t *group);
 extern gboolean connman_group_invite_peer(connman_group_t *group,
         connman_service_t *service);
diff --git a/src/connman_manager.c b/src/connman_manager.c
index f7b6223..a72aa01 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -932,6 +932,28 @@ connman_group_t *connman_manager_create_group(connman_manager_t *manager,
 	return group;
 }
 
+/*
+ * Get the number of connected station
+ */
+guint connman_manager_get_sta_count(connman_manager_t *manager)
+{
+	if (NULL == manager)
+		return FALSE;
+
+	GError *error = NULL;
+	guint sta_count = 0;
+
+	connman_interface_manager_call_get_sta_count_sync(manager->remote, &sta_count, NULL, &error);
+
+	if (error)
+	{
+		g_error_free(error);
+		return 0;
+	}
+
+	return sta_count;
+}
+
 /**
  * Traverse through the given service list, comparing each service with the path provided
  * returning the service with the matching path (See header for API details)
diff --git a/src/connman_manager.h b/src/connman_manager.h
index 1226d58..fbf8507 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -249,6 +249,11 @@ extern gboolean connman_manager_unregister_counter(connman_manager_t *manager,
 extern connman_group_t *connman_manager_create_group(connman_manager_t *manager,
         const gchar *ssid, const gchar *passphrase);
 
+/*
+ * Get the number of connected station
+ */
+extern guint connman_manager_get_sta_count(connman_manager_t *manager);
+
 /**
  * Populate the group's peer_list field with all of the group's peers
  *
diff --git a/src/connman_technology.c b/src/connman_technology.c
index 4fdd52d..db34da2 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -72,6 +72,101 @@ gboolean connman_technology_set_powered(connman_technology_t *technology,
 	return TRUE;
 }
 
+/**
+ * Enable/Disable tethering the given technology (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering(connman_technology_t
+        *technology, gboolean state)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "Tethering",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->tethering = state;
+	g_usleep(1000000);
+	return TRUE;
+}
+
+/**
+ * Set the name of ssid used in tethering (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering_identifier(
+    connman_technology_t *technology, const gchar *tethering_identifier)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "TetheringIdentifier",
+	        g_variant_new_variant(g_variant_new_string(tethering_identifier)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_free(technology->tethering_identifier);
+	technology->tethering_identifier = g_strdup(tethering_identifier);
+	return TRUE;
+}
+
+/**
+ * Set the name of ssid used in tethering (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering_passphrase(
+    connman_technology_t *technology, const gchar *tethering_passphrase)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "TetheringPassphrase",
+	        g_variant_new_variant(g_variant_new_string(tethering_passphrase)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_free(technology->tethering_passphrase);
+	technology->tethering_passphrase = g_strdup(tethering_passphrase);
+	return TRUE;
+}
+
 /**
  * Cancel any active P2P connection (see header for API details)
  */
@@ -532,6 +627,20 @@ static void set_property_value(connman_technology_t *technology,
 	{
 		technology->wfd_rtspport = g_variant_get_uint32(val);
 	}
+	else if (!g_strcmp0(key, "Tethering"))
+	{
+		technology->tethering = g_variant_get_boolean(val);
+	}
+	else if (!g_strcmp0(key, "TetheringIdentifier"))
+	{
+		g_free(technology->tethering_identifier);
+		technology->tethering_identifier = g_variant_dup_string(val, NULL);
+	}
+	else if (!g_strcmp0(key, "TetheringPassphrase"))
+	{
+		g_free(technology->tethering_passphrase);
+		technology->tethering_passphrase = g_variant_dup_string(val, NULL);
+	}
 	else if (!g_strcmp0(key, "CountryCode"))
 	{
 		g_free(technology->country_code);
@@ -715,6 +824,58 @@ void connman_technology_register_property_changed_cb(connman_technology_t
 	technology->handle_property_changed_fn = cb;
 }
 
+/**
+ * Register a handler for the technology's "TetheringStaAuthorized" signal.
+ */
+void connman_technology_register_sta_authorized_cb(connman_technology_t
+        *technology, connman_common_cb cb, gpointer user_data)
+{
+	if (!cb || !technology)
+	{
+		return;
+	}
+
+	technology->handle_sta_authorized_fn = cb;
+	technology->sta_authorized_data = user_data;
+}
+
+static void tethering_sta_authorized_cb(ConnmanInterfaceTechnology *proxy,
+                                        gpointer user_data)
+{
+	connman_technology_t *technology = user_data;
+
+	if (technology->handle_sta_authorized_fn)
+	{
+		technology->handle_sta_authorized_fn(technology->sta_authorized_data);
+	}
+}
+
+/**
+ * Register a handler for the technology's "TetheringStaUnauthorized" signal.
+ */
+void connman_technology_register_sta_deauthorized_cb(connman_technology_t
+        *technology, connman_common_cb cb, gpointer user_data)
+{
+	if (!cb || !technology)
+	{
+		return;
+	}
+
+	technology->handle_sta_deauthorized_fn = cb;
+	technology->sta_deauthorized_data = user_data;
+}
+
+static void tethering_sta_deunauthorized_cb(ConnmanInterfaceTechnology *proxy,
+        gpointer user_data)
+{
+	connman_technology_t *technology = user_data;
+
+	if (technology->handle_sta_deauthorized_fn)
+	{
+		technology->handle_sta_deauthorized_fn(technology->sta_deauthorized_data);
+	}
+}
+
 /**
  * Create a new technology instance and set its properties (see header for API details)
  */
@@ -750,6 +911,13 @@ connman_technology_t *connman_technology_new(const gchar* path)
 	            technology->remote), "property-changed",
 	        G_CALLBACK(property_changed_cb), technology, NULL, 0);
 
+	technology->sta_authorized_sighandler = g_signal_connect_data(G_OBJECT(
+	        technology->remote), "tethering-sta-authorized",
+	                                        G_CALLBACK(tethering_sta_authorized_cb), technology, NULL, 0);
+	technology->sta_deauthorized_sighandler = g_signal_connect_data(G_OBJECT(
+	            technology->remote), "tethering-sta-deauthorized",
+	        G_CALLBACK(tethering_sta_deunauthorized_cb), technology, NULL, 0);
+
 	/* If connman has a change in it's properties while we process the data and
 	 * before we register the signals, we do not get the update.
 	 * So, we need to get all that information from connman again.
@@ -796,6 +964,20 @@ void connman_technology_free(connman_technology_t *technology)
 		technology->property_changed_sighandler = 0;
 	}
 
+	if (technology->sta_authorized_sighandler)
+	{
+		g_signal_handler_disconnect(G_OBJECT(technology->remote),
+		                            technology->sta_authorized_sighandler);
+		technology->sta_authorized_sighandler = 0;
+	}
+
+	if (technology->sta_deauthorized_sighandler)
+	{
+		g_signal_handler_disconnect(G_OBJECT(technology->remote),
+		                            technology->sta_deauthorized_sighandler);
+		technology->sta_deauthorized_sighandler = 0;
+	}
+
 	/* If async call to technology is in progress, scan callback will free the technology. */
 	if (technology->calls_pending > 0)
 	{
@@ -812,6 +994,8 @@ void connman_technology_free(connman_technology_t *technology)
 	technology->name = NULL;
 	g_free(technology->p2p_identifier);
 	g_free(technology->country_code);
+	g_free(technology->tethering_identifier);
+	g_free(technology->tethering_passphrase);
 
 	g_object_unref(technology->remote);
 	technology->remote = NULL;
diff --git a/src/connman_technology.h b/src/connman_technology.h
index 521d13e..e1e0e35 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -45,8 +45,11 @@ typedef struct connman_technology
 	gchar *path;
 	gchar *p2p_identifier;
 	gchar *country_code;
+	gchar *tethering_identifier;
+	gchar *tethering_passphrase;
 	gboolean powered;
 	gboolean connected;
+	gboolean tethering;
 	gboolean p2p;
 	gboolean wfd;
 	gboolean p2p_listen;
@@ -58,6 +61,12 @@ typedef struct connman_technology
 	guint32 wfd_rtspport;
 	gulong property_changed_sighandler;
 	connman_property_changed_cb handle_property_changed_fn;
+	gulong sta_authorized_sighandler;
+	connman_common_cb handle_sta_authorized_fn;
+	gpointer sta_authorized_data;
+	gulong sta_deauthorized_sighandler;
+	connman_common_cb handle_sta_deauthorized_fn;
+	gpointer sta_deauthorized_data;
 	connman_common_cb handle_after_scan_fn;
 	gpointer after_scan_data;
 
@@ -92,6 +101,39 @@ typedef struct connman_technology_interface
 extern int connman_technology_set_powered(connman_technology_t *technology,
         gboolean state, bool* not_supported);
 
+/**
+ * Enable/Disable tethering the given technology
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  state TRUE for power on, FALSE for off
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering(connman_technology_t
+        *technology, gboolean state);
+
+/**
+ * Set the name of ssid used in tethering
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  tethering_identifier of the tethering
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering_identifier(
+    connman_technology_t *technology, const gchar *tethering_identifier);
+
+/**
+ * Set the name of passphrase used in tethering
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  tethering_passphrase of the tethering
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering_passphrase(
+    connman_technology_t *technology, const gchar *tethering_passphrase);
+
 /**
  * Enable/disable wifi-direct technology
  *
@@ -278,6 +320,26 @@ extern gboolean connman_technology_set_listen_params(connman_technology_t *techn
 extern void connman_technology_register_property_changed_cb(
     connman_technology_t *technology, connman_property_changed_cb func);
 
+/**
+ * @brief Register a handler for the technology's "TetheringStaAuthorized" signal.
+ *
+ * @param[IN] technology A technology instance
+ * @param[IN] cb Handler function to register.
+ * @param[IN] user_data User data passed with the callback when called.
+ */
+extern void connman_technology_register_sta_authorized_cb(
+    connman_technology_t *technology, connman_common_cb cb, gpointer user_data);
+
+/**
+ * @brief Register a handler for the technology's "TetheringStaDeauthorized" signal.
+ *
+ * @param[IN] technology A technology instance
+ * @param[IN] cb Handler function to register.
+ * @param[IN] user_data User data passed with the callback when called.
+ */
+extern void connman_technology_register_sta_deauthorized_cb(
+    connman_technology_t *technology, connman_common_cb cb, gpointer user_data);
+
 /**
  * Fetch all the properties for a technology instance and save the new values
  * in technology fields.
diff --git a/src/errors.h b/src/errors.h
index c29c5c0..2c242c0 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -78,7 +78,20 @@
 #define WCA_API_ERROR_WIFI_NOT_CONNECTED    143
 #define WCA_API_ERROR_FAILED_TO_CONNECT     144
 #define WCA_API_ERROR_NOT_IMPLEMENTED       145
+#define WCA_API_ERROR_TETHERING_ENABLE_FAILED 146
+#define WCA_API_ERROR_TETHERING_DISABLE_FAILED 147
+#define WCA_API_ERROR_TETHERING_SSID_FAILED         148
+#define WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED   149
+#define WCA_API_ERROR_TETHERING_NO_SSID             150
+#define WCA_API_ERROR_TETHERING_NO_PASSPHRASE       151
+#define WCA_API_ERROR_TETHERING_SUPPORT_FAILED      152
+#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_SEC_TYPE          153
+#define WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED 154
+#define WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID  155
 #define WCA_API_ERROR_COUNTER                  156
+#define WCA_API_ERROR_TETHERING_RESTORE_WIFI_STATE_FAILED 157
+#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT 158
+#define WCA_API_ERROR_TETHERING_TIMEOUT_NO_NEGATIVE_VALUES 159
 #define WCA_API_ERROR_FAILED_TO_ENABLE_DISABLE_TECHNOLOGIES 163
 #define WCA_API_ERROR_FAILED_TO_SET_LISTEN_CHANNEL  164
 #define WCA_API_ERROR_ALREADY_CONNECTED 165
diff --git a/src/logging.h b/src/logging.h
index a49773e..1a0f899 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -130,6 +130,9 @@ extern PmLogContext gLogContext;
 
 /** connman_technology.c */
 #define MSGID_TECHNOLOGY_SET_POWERED_ERROR              "TECH_SET_POWERED_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_ERROR            "TECH_SET_TETHERING_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR "TECH_SET_TETHERING_IDENTI_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR "TECH_SET_TETHERING_PASSPH_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_P2P_ERROR               "TECH_CANCEL_P2P_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_WPS_ERROR               "TECH_CANCEL_WPS_ERR"
 #define MSGID_TECHNOLOGY_START_WPS_ERROR                "TECH_START_WPS_ERR"
@@ -192,6 +195,7 @@ extern PmLogContext gLogContext;
 #define MSGID_P2P_DISCONNECT_PEER                       "P2P_DISCONNECT_PEER"
 #define MSGID_P2P_INVITE_PEER                           "P2P_INVITE_PEER"
 #define MSGID_P2P_DISCONNECT_GROUP                      "P2P_DISCONNECT_GRP"
+#define MSGID_P2P_SET_TETHERING                         "P2P_SET_TETHERING"
 #define MSGID_P2P_DELETE_PROFILE                        "P2P_DELETE_PROFILE"
 #define MSGID_P2P_METHODS_LUNA_ERROR                    "P2P_METHODS_LUNA_ERR"
 #define MSGID_SETTINGS_SERVICE_REG_ERROR                "SETTINGS_SRVC_REG_ERR"
@@ -200,6 +204,9 @@ extern PmLogContext gLogContext;
 #define MSGID_LUNA_CREATE_JSON_FAILED                   "LUNA_CREATE_JSON_FAILED"
 #define MSGID_LUNA_SEND_FAILED                          "LUNA_SEND_FAILED"
 
+/** wifi_tethering_service. */
+#define MSGID_TETHERING_METHODS_LUNA_ERROR              "TETHERING_METHODS_LUNA_ERR"
+
 /** wifi_setting.c */
 #define MSGID_SETTING_LPAPP_GET_ERROR                   "SETTING_LPAPP_GET_ERR"
 #define MSGID_SETTING_LPAPP_COPY_ERROR                  "SETTING_LPAPP_COPY_ERR"
diff --git a/src/wifi_service.c b/src/wifi_service.c
index e94fbe6..7a863fb 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -56,6 +56,7 @@ errorText | Yes | String | Error description
 #include "common.h"
 #include "connectionmanager_service.h"
 #include "logging.h"
+#include "wifi_tethering_service.h"
 #include "errors.h"
 #include "nyx.h"
 
@@ -381,7 +382,10 @@ static void create_wifi_getstatus_response(jvalue_ref *reply, bool subscribed)
 
 	jobject_put(*reply, J_CSTR_TO_JVAL("wakeOnWlan"), jstring_create("disabled"));
 
-	gboolean powered = is_wifi_powered();
+	jobject_put(*reply, J_CSTR_TO_JVAL("tetheringEnabled"),
+	            jboolean_create(is_wifi_tethering()));
+
+	gboolean powered = is_wifi_powered() && !is_wifi_tethering();
 
 	/* Get the service which is connecting or already in connected state */
 	connman_service_t *connected_service = connman_manager_get_connected_service(
@@ -1848,6 +1852,22 @@ void send_findnetworks_status_to_subscribers()
 	j_release(&findnetworks_reply);
 }
 
+static int convert_frequency_to_channel(int freq)
+{
+	if (freq >= 2412 && freq <= 2484)
+	{
+		return (freq - 2412) / 5 + 1;
+	}
+	else if (freq >= 5170 && freq <= 5825)
+	{
+		return (freq - 5170) / 5 + 34;
+	}
+	else
+	{
+		return -1;
+	}
+}
+
 static gboolean signal_polling_cb(gpointer user_data)
 {
 	connman_service_t *connected_service = connman_manager_get_connected_service(
@@ -1959,6 +1979,18 @@ static void technology_property_changed_callback(gpointer data,
 
 		}
 
+		if (g_strcmp0(property, "Tethering") == 0 ||
+		    g_strcmp0(property, "TetheringIdentifier") == 0 ||
+		    g_strcmp0(property, "TetheringPassphrase") == 0)
+		{
+			send_tethering_state_to_subscribers();
+			connectionmanager_send_status_to_subscribers();
+			wifi_send_status_to_subscribers();
+		}
+
+		if(g_strcmp0(property, "StaCount") == 0) {
+			send_sta_count_to_subscribers();
+		}
 	}
 	else if (technology == connman_manager_find_ethernet_technology(manager))
 	{
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
new file mode 100644
index 0000000..58b600c
--- /dev/null
+++ b/src/wifi_tethering_service.c
@@ -0,0 +1,892 @@
+// Copyright (c) 2014-2019 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_tethering_service.c
+ *
+ * @brief Implements the com.webos.service.wifi/tethering service API with using connman in the backend.
+ */
+
+/**
+ *  @brief Initialize com.webos.service.wifi/p2p service and all of its methods
+ */
+
+#include <glib.h>
+#include <stdbool.h>
+#include <string.h>
+
+#include <wca-support.h>
+
+#include "wifi_tethering_service.h"
+#include "wifi_service.h"
+#include "connman_manager.h"
+#include "lunaservice_utils.h"
+#include "connman_common.h"
+#include "common.h"
+#include "logging.h"
+#include "errors.h"
+
+#define WIFI_STATUS_TIMEOUT     1
+#define WIFI_TETHERING_USED_RX_BYTES_TRESHOLD(x)        5000*x
+
+LSHandle *tetheringpLSHandle = NULL;
+
+static gboolean previous_wifi_legacy_powered = FALSE;
+
+static guint wifi_tethering_timeout = 5;
+static guint wifi_tethering_timeout_source = 0;
+static guint wifi_tethering_client_count = 0;
+
+void start_tethering_timeout(void);
+
+static void support_tethering_disabled_cb(bool success, void *user_data)
+{
+	LSMessage *message = user_data;
+	LSHandle *handle = 0;
+
+	if (message)
+	{
+		handle = LSMessageGetConnection(message);
+	}
+
+	if (!success)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message,
+			                          "Failed to disable tethering mode through support library",
+			                          WCA_API_ERROR_TETHERING_SUPPORT_FAILED);
+
+		return;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!wifi_tech)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message, "WiFi technology unavailable",
+			                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
+
+		return;
+	}
+
+	if (!connman_technology_set_tethering(wifi_tech, FALSE))
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message, "Failed to disable tethering mode",
+			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
+
+		return;
+	}
+
+
+	if (!previous_wifi_legacy_powered &&
+	        !connman_technology_set_powered(wifi_tech, FALSE, NULL))
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message,
+			                          "Failed to restore WiFi state after disbling tethering",
+			                          WCA_API_ERROR_TETHERING_RESTORE_WIFI_STATE_FAILED);
+
+		return;
+	}
+
+	LSMessageReplySuccess(handle, message);
+}
+
+static void support_tethering_disabled_after_failure_cb(bool success,
+        void *user_data)
+{
+	(void) success;
+
+	LSMessage *message = user_data;
+
+	if (!message)
+	{
+		return;
+	}
+
+	LSHandle *handle = LSMessageGetConnection(message);
+
+	LSMessageReplyCustomError(handle, message, "Failed to enable tethering mode",
+	                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
+}
+
+static void support_tethering_enabled_cb(bool success, void *user_data)
+{
+	LSMessage *message = user_data;
+	LSHandle *handle = 0;
+
+	if (message)
+	{
+		handle = LSMessageGetConnection(message);
+	}
+
+	if (!success)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message,
+			                          "Failed to enable tethering mode through support library",
+			                          WCA_API_ERROR_TETHERING_SUPPORT_FAILED);
+
+		return;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!wifi_tech)
+	{
+		if (message)
+			LSMessageReplyCustomError(handle, message, "WiFi technology unavailable",
+			                          WCA_API_ERROR_WIFI_TECH_UNAVAILABLE);
+
+		return;
+	}
+
+	if (!connman_technology_set_tethering(wifi_tech, TRUE))
+	{
+		/* disable tethering support again */
+		wca_support_wifi_disable_tethering(support_tethering_disabled_after_failure_cb,
+		                                   message);
+		return;
+	}
+
+	wifi_tethering_client_count = 0;
+	start_tethering_timeout();
+
+	if (message)
+	{
+		LSMessageReplySuccess(handle, message);
+	}
+}
+
+/**
+ *  @brief Sets the wifi technologies tethering state
+ *
+ *  @param state
+ */
+
+gboolean set_wifi_tethering(bool state, LSMessage *message)
+{
+	if (state == is_wifi_tethering())
+	{
+		return false;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (!is_wifi_powered() && state)
+	{
+		previous_wifi_legacy_powered = FALSE;
+
+		// we need to have WiFI powered otherwise we can't start tethering
+		connman_technology_set_powered(wifi_tech, TRUE, NULL);
+
+		// FIXME this should go away once we switch to asynchronous variant of
+		// connman_technology_set_powered method
+		g_usleep(2000000);
+	}
+	else if (is_wifi_powered() && state)
+	{
+		previous_wifi_legacy_powered = TRUE;
+	}
+
+	if (state)
+	{
+		connman_service_t *connected_service = connman_manager_get_connected_service(
+		        manager->wifi_services);
+
+		if (connected_service)
+		{
+			connman_service_disconnect(connected_service);
+		}
+
+		wca_support_wifi_enable_tethering(support_tethering_enabled_cb, message);
+	}
+	else
+	{
+		wca_support_wifi_disable_tethering(support_tethering_disabled_cb, message);
+	}
+
+	return TRUE;
+}
+
+static void send_tethering_state(jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("enabled"),
+	            jboolean_create(is_wifi_tethering()));
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	if (NULL != wifi_tech->tethering_identifier)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("ssid"),
+		            jstring_create(wifi_tech->tethering_identifier));
+	}
+
+	if (NULL != wifi_tech->tethering_identifier)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("securityType"),
+		            jstring_create((NULL != wifi_tech->tethering_passphrase)
+		                           && (strlen(wifi_tech->tethering_passphrase) != 0) ? "psk" : "open"));
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("timeout"),
+	            jnumber_create_i32(wifi_tethering_timeout));
+}
+
+void send_tethering_state_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	send_tethering_state(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+		WCALOG_DEBUG("Sending payload : %s", payload);
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(tetheringpLSHandle, "/tethering/getState",
+		                        payload,
+		                        &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+
+}
+
+static void send_sta_count(jvalue_ref *reply)
+{
+	if(NULL == reply)
+		return;
+
+	unsigned int sta_count = connman_manager_get_sta_count(manager);
+	jobject_put(*reply, J_CSTR_TO_JVAL("stationCount"), jnumber_create_i32(sta_count));
+}
+
+void send_sta_count_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	send_sta_count(&reply);
+
+	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+	if(response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+		WCALOG_DEBUG("Sending payload : %s",payload);
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(tetheringpLSHandle, "/tethering/getStationCount", payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+static gboolean tethering_timeout_cb(gpointer user_data)
+{
+	WCALOG_DEBUG("WiFi tethering timeout occured. Disable tethering.");
+
+	set_wifi_tethering(FALSE, 0);
+
+	wifi_tethering_timeout_source = 0;
+
+	return FALSE;
+}
+
+static void sta_authorized_cb(gpointer user_data)
+{
+	wifi_tethering_client_count++;
+
+	// If timer is no longer active we don't have anything to do here
+	if (wifi_tethering_timeout_source == 0)
+	{
+		return;
+	}
+
+	WCALOG_DEBUG("Got new WiFi tethering client");
+
+	// Now that we have a client connected to our AP we can stop
+	// the timeout.
+	if (wifi_tethering_timeout_source != 0)
+	{
+		WCALOG_DEBUG("Abort running tethering timer");
+		g_source_remove(wifi_tethering_timeout_source);
+		wifi_tethering_timeout_source = 0;
+	}
+}
+
+static void sta_deauthorized_cb(gpointer user_data)
+{
+	wifi_tethering_client_count--;
+
+	WCALOG_DEBUG("WiFi tethering client disconnected");
+
+	if (wifi_tethering_client_count > 0)
+	{
+		WCALOG_DEBUG("Not restarting timeout as we have %d clients left",
+		             wifi_tethering_client_count);
+		return;
+	}
+
+	start_tethering_timeout();
+}
+
+void start_tethering_timeout(void)
+{
+	if (wifi_tethering_timeout == 0 || wifi_tethering_timeout_source != 0)
+	{
+		return;
+	}
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	WCALOG_DEBUG("Setting WiFi tethering timeout to %d minutes",
+	             wifi_tethering_timeout);
+
+	// Make sure our handler gets registered with the WiFi technology
+	// to get known when a new STA connects
+	connman_technology_register_sta_authorized_cb(wifi_tech, sta_authorized_cb,
+	        NULL);
+	connman_technology_register_sta_deauthorized_cb(wifi_tech, sta_deauthorized_cb,
+	        NULL);
+
+	wifi_tethering_timeout_source = g_timeout_add_seconds(wifi_tethering_timeout *
+	                                60,
+	                                tethering_timeout_cb, NULL);
+}
+
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_service_wifi com.webos.service.wifi/tethering/setState
+@{
+@section com_webos_service_wifi_tethering_setstate setState
+
+Set tethering state.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+enabled | No | boolean | enable / disable tethering
+ssid | No | String | The tethering broadcasted identifier
+passPhrase | No | String | The tethering connection passphrase
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(enabled, boolean),
+	                                     PROP(ssid, string), PROP(passPhrase, string), PROP(securityType, string),
+	                                     PROP(timeout, integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref enabledObj = {0}, ssidObj = {0}, passPhraseObj = {0}, securityTypeObj
+	                                       = {0}, timeoutObj = {0};
+	gboolean enable_tethering = FALSE, invalidArg = TRUE;
+	gchar *ssid = NULL, *passphrase = NULL;
+	int timeout = 0;
+	gboolean is_open = FALSE;
+	gboolean state_set = FALSE;
+
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change SSID while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_SSID_FAILED);
+			goto cleanup;
+		}
+
+		raw_buffer ssid_buf = jstring_get(ssidObj);
+		ssid = g_strdup(ssid_buf.m_str);
+		jstring_free_buffer(ssid_buf);
+
+		if (NULL == ssid)
+		{
+			goto invalid_params;
+		}
+
+		invalidArg = FALSE;
+
+		if (!connman_technology_set_tethering_identifier(
+		            connman_manager_find_wifi_technology(manager), ssid))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering SSID",
+			                          WCA_API_ERROR_TETHERING_SSID_FAILED);
+			goto cleanup;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("securityType"),
+	                       &securityTypeObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change securityType while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_SEC_TYPE);
+			goto cleanup;
+		}
+
+		if (jstring_equal2(securityTypeObj, J_CSTR_TO_BUF("open")))
+		{
+			is_open = TRUE;
+		}
+		else if (jstring_equal2(securityTypeObj, J_CSTR_TO_BUF("psk")))
+		{
+			is_open = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		if (is_open &&
+		        !connman_technology_set_tethering_passphrase(
+		            connman_manager_find_wifi_technology(manager), ""))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering passphrase",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
+			goto cleanup;
+		}
+
+		invalidArg = FALSE;
+	}
+
+	if (!is_open &&
+	        jobject_get_exists(parsedObj, J_CSTR_TO_BUF("passPhrase"), &passPhraseObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change passphrase while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
+			goto cleanup;
+		}
+
+		raw_buffer passphrase_buf = jstring_get(passPhraseObj);
+		passphrase = g_strdup(passphrase_buf.m_str);
+		jstring_free_buffer(passphrase_buf);
+
+		if (NULL == passphrase)
+		{
+			goto invalid_params;
+		}
+
+		if (!is_open && (!passphrase || strlen(passphrase) == 0))
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "No passphrase set but required for security type psk",
+			                          WCA_API_ERROR_TETHERING_NO_PASSPHRASE);
+			goto cleanup;
+		}
+
+		int passphrase_length = strlen(passphrase);
+
+		if (!is_open && (passphrase_length < 8 || passphrase_length > 63))
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Passphrase doesn't match the requirements",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID);
+			goto cleanup;
+		}
+
+		if (is_open && passphrase != NULL && strlen(passphrase) > 0)
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "With security typen open specifying a passphrase is not possible",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED);
+			goto cleanup;
+		}
+
+		invalidArg = FALSE;
+
+		if (!is_open &&
+		        !connman_technology_set_tethering_passphrase(
+		            connman_manager_find_wifi_technology(manager), passphrase))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering passphrase",
+			                          WCA_API_ERROR_TETHERING_PASSPHRASE_FAILED);
+			goto cleanup;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("timeout"), &timeoutObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change timeout while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT);
+			goto cleanup;
+		}
+
+		jnumber_get_i32(timeoutObj, &timeout);
+
+		if (timeout < 0)
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Negative values are not allowed for the timeout",
+			                          WCA_API_ERROR_TETHERING_TIMEOUT_NO_NEGATIVE_VALUES);
+			goto cleanup;
+		}
+
+		wifi_tethering_timeout = timeout;
+
+		invalidArg = FALSE;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
+	{
+		jboolean_get(enabledObj, &enable_tethering);
+
+		if (enable_tethering && is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Already Enabled",
+			                          WCA_API_ERROR_ALREADY_ENABLED);
+			goto cleanup;
+		}
+		else if (!enable_tethering && !is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message, "Already Disabled",
+			                          WCA_API_ERROR_ALREADY_DISABLED);
+			goto cleanup;
+		}
+
+		state_set = TRUE;
+		invalidArg = FALSE;
+	}
+
+	if (invalidArg == TRUE)
+	{
+		goto invalid_params;
+	}
+
+	if (state_set && !set_wifi_tethering(enable_tethering, message))
+	{
+		if (enable_tethering)
+		{
+			LSMessageReplyCustomError(sh, message, "Failed to enable tethering mode",
+			                          WCA_API_ERROR_TETHERING_ENABLE_FAILED);
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message, "Failed to disable tethering mode",
+			                          WCA_API_ERROR_TETHERING_DISABLE_FAILED);
+		}
+
+		goto cleanup;
+	}
+	else
+	{
+		LSMessageReplySuccess(sh, message);
+	}
+
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+
+cleanup:
+	g_free(ssid);
+	g_free(passphrase);
+	j_release(&parsedObj);
+	return true;
+}
+
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_wifi com.webos.wifi/gettethering
+@{
+@page com_webos_service_wifi com.webos.service.wifi/tethering/getState
+@{
+@section com_webos_service_wifi_tethering_getstate getState
+
+Get current tethering state.
+
+@par Parameters
+subscribe | No | boolean | Subscribe for updates
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+state | No | boolean | enable / disable tethering
+ssid | No | String | The tethering broadcasted identifier
+passPhrase | No | String |  The tethering connection passphrase
+securityType | No | String |  The tethering securityType
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+subscribed | No | Boolean | True when successfully subscribed. False when unsubscribed or subscription was not possible.
+
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_get_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	send_tethering_state(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+
+	return true;
+}
+
+static bool handle_get_station_count_command(LSHandle *sh, LSMessage *message, void* context)
+{
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+
+	jvalue_ref parsedObj = {0};
+	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		j_release(&reply);
+		return true;
+	}
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if(!connman_status_check_with_subscription(manager, sh, message, subscribed))
+		goto cleanup;
+
+	if(!wifi_technology_status_check_with_subscription(sh, message, subscribed))
+		goto cleanup;
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	send_sta_count(&reply);
+
+	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+	if(!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh,message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema), &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+	j_release(&parsedObj);
+	j_release(&reply);
+
+	return true;
+}
+
+/**
+ * com.webos.service.wifi/tethering service Luna Method Table
+ */
+
+static LSMethod wifi_tethering_methods[] =
+{
+	{ LUNA_METHOD_TETHERING_SETSTATE,              handle_set_state_command },
+	{ LUNA_METHOD_TETHERING_GETSTATE,              handle_get_state_command },
+	{ LUNA_METHOD_TETHERING_GETSTACOUNT,           handle_get_station_count_command },
+	{},
+};
+
+int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,
+                                        LSHandle *pLsHandle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (NULL == mainloop)
+	{
+		goto Exit;
+	}
+
+	tetheringpLSHandle = pLsHandle;
+
+	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_TETHERING,
+	                       wifi_tethering_methods, NULL,
+	                       NULL, &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TETHERING_METHODS_LUNA_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	return 0;
+Exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	return -1;
+}
diff --git a/src/wifi_tethering_service.h b/src/wifi_tethering_service.h
new file mode 100644
index 0000000..dd46347
--- /dev/null
+++ b/src/wifi_tethering_service.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2014-2019 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+/**
+ * @file  wifi_tethering_service.h
+ *
+ */
+
+#ifndef _WIFI_TETHERING_SERVICE_H_
+#define _WIFI_TETHERING_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define LUNA_CATEGORY_TETHERING              "/tethering"
+
+/**
+ * @name Luna WiFi tethering Method Names
+ * @{
+ */
+
+#define LUNA_METHOD_TETHERING_SETSTATE       "setState"
+#define LUNA_METHOD_TETHERING_GETSTATE       "getState"
+#define LUNA_METHOD_TETHERING_GETSTACOUNT    "getStationCount"
+
+extern void send_tethering_state_to_subscribers(void);
+extern void send_sta_count_to_subscribers(void);
+extern int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,
+        LSHandle *pLsHandle);
+
+#endif /* _WIFI_TETHERING_SERVICE_H_ */

commit 603ecd1774b9012d8344341125f8e72916997d40
Author: Sungho shin <sungho1.shin@lge.com>
Date:   Tue Jun 11 15:47:11 2019 +0900

    Add com.webos.service.wifi/tethering category
    
    :Release Notes:
    Add com.webos.service.wifi/tethering category
    
    :Detailed Notes:
    Add com.webos.service.wifi/tethering category
    
    :Testing Performed:
    Build successfully.
    It works fine as expected.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-79663] Implement softap in webOS OSE
    
    Change-Id: I1f7ca923ce40e6b9d4f16f2f4f968d1f3ab20849

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 7a863fb..ee551d2 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -3684,6 +3684,8 @@ int initialize_wifi_ls2_calls(GMainLoop *mainloop , LSHandle **wifi_handle)
 
 	init_wifi_profile_list();
 
+	initialize_wifi_tethering_ls2_calls(mainloop, pLsHandle);
+
 	*wifi_handle = pLsHandle;
 
 	return 0;

commit bfad4b51cd3730b1c7661d9071c7724bfdb8c92a
Author: Sungho shin <sungho1.shin@lge.com>
Date:   Thu Jun 13 15:31:19 2019 +0900

    Add support for WiFi tethering channel
    
    :Release Notes:
    Add support for WiFi tethering channel
    
    :Detailed Notes:
    This commit adds 'channel' property to get/set WiFi tethering
    channel in setState and getState methods of com.webos.service.wifi/
    tethering.
    
    :Testing Performed:
    - Build tested.
    - Tested /tethering/setState works as expected.
    - Tested /tethering/getState works as expected.
    - See PLAT-79667 for luna methods used in testing.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-79667] Implement LS2 API for softap channel setting.
    
    Change-Id: Ic63ed622237ce9da80eef96d1c522c03894da656

diff --git a/src/connman_technology.c b/src/connman_technology.c
index db34da2..d2dfbbf 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -167,6 +167,36 @@ extern gboolean connman_technology_set_tethering_passphrase(
 	return TRUE;
 }
 
+/**
+ * Set MultiChannelShedMode value to specified mode (see header for API details)
+ */
+
+gboolean connman_technology_set_tethering_channel(connman_technology_t
+        *technology, const guint32 channel)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "TetheringChannel",
+	        g_variant_new_variant(g_variant_new_uint32(channel)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_CHANNEL_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->tethering_channel = channel;
+	return TRUE;
+}
+
 /**
  * Cancel any active P2P connection (see header for API details)
  */
@@ -641,6 +671,10 @@ static void set_property_value(connman_technology_t *technology,
 		g_free(technology->tethering_passphrase);
 		technology->tethering_passphrase = g_variant_dup_string(val, NULL);
 	}
+	else if (!g_strcmp0(key, "TetheringChannel"))
+	{
+		technology->tethering_channel = g_variant_get_uint32(val);
+	}
 	else if (!g_strcmp0(key, "CountryCode"))
 	{
 		g_free(technology->country_code);
diff --git a/src/connman_technology.h b/src/connman_technology.h
index e1e0e35..1aea8f5 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -59,6 +59,7 @@ typedef struct connman_technology
 	gboolean legacy_scan;
 	connman_wfd_dev_type wfd_devtype;
 	guint32 wfd_rtspport;
+	guint32 tethering_channel;
 	gulong property_changed_sighandler;
 	connman_property_changed_cb handle_property_changed_fn;
 	gulong sta_authorized_sighandler;
@@ -134,6 +135,17 @@ extern gboolean connman_technology_set_tethering_identifier(
 extern gboolean connman_technology_set_tethering_passphrase(
     connman_technology_t *technology, const gchar *tethering_passphrase);
 
+/**
+ * Set the channel used in tethering
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  channel of the tethering
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering_channel(
+	connman_technology_t*technology, const guint32 channel);
+
 /**
  * Enable/disable wifi-direct technology
  *
diff --git a/src/errors.h b/src/errors.h
index 2c242c0..c0427dc 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -107,5 +107,7 @@
 
 #define WCA_API_ERROR_PROXY_FIND_PROXY_FOR_URL_ERROR    205
 #define WCA_API_ERROR_FAILED_TO_SET_GO_INTENT           206
+#define WCA_API_ERROR_TETHERING_CHANNEL_FAILED   207
+#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_CHANNEL 208
 
 #endif /* ERRORS_H_ */
diff --git a/src/logging.h b/src/logging.h
index 1a0f899..fcce5fb 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -133,6 +133,7 @@ extern PmLogContext gLogContext;
 #define MSGID_TECHNOLOGY_SET_TETHERING_ERROR            "TECH_SET_TETHERING_ERR"
 #define MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR "TECH_SET_TETHERING_IDENTI_ERR"
 #define MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR "TECH_SET_TETHERING_PASSPH_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_CHANNEL_ERROR    "TECH_SET_TETHERING_CHANNEL_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_P2P_ERROR               "TECH_CANCEL_P2P_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_WPS_ERROR               "TECH_CANCEL_WPS_ERR"
 #define MSGID_TECHNOLOGY_START_WPS_ERROR                "TECH_START_WPS_ERR"
diff --git a/src/wifi_service.c b/src/wifi_service.c
index ee551d2..e957b98 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1981,7 +1981,8 @@ static void technology_property_changed_callback(gpointer data,
 
 		if (g_strcmp0(property, "Tethering") == 0 ||
 		    g_strcmp0(property, "TetheringIdentifier") == 0 ||
-		    g_strcmp0(property, "TetheringPassphrase") == 0)
+		    g_strcmp0(property, "TetheringPassphrase") == 0 ||
+		    g_strcmp0(property, "TetheringChannel") == 0)
 		{
 			send_tethering_state_to_subscribers();
 			connectionmanager_send_status_to_subscribers();
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 58b600c..905f409 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -249,6 +249,17 @@ static void send_tethering_state(jvalue_ref *reply)
 		                           && (strlen(wifi_tech->tethering_passphrase) != 0) ? "psk" : "open"));
 	}
 
+	if (wifi_tech->tethering_channel == 0)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("channel"),
+		            jnumber_create_i32(1));
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("channel"),
+		            jnumber_create_i32(wifi_tech->tethering_channel));
+	}
+
 	jobject_put(*reply, J_CSTR_TO_JVAL("timeout"),
 	            jnumber_create_i32(wifi_tethering_timeout));
 }
@@ -441,18 +452,19 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
 	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(enabled, boolean),
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_6(PROP(enabled, boolean),
 	                                     PROP(ssid, string), PROP(passPhrase, string), PROP(securityType, string),
-	                                     PROP(timeout, integer)))), &parsedObj))
+	                                     PROP(timeout, integer), PROP(channel, integer)))), &parsedObj))
 	{
 		return true;
 	}
 
 	jvalue_ref enabledObj = {0}, ssidObj = {0}, passPhraseObj = {0}, securityTypeObj
-	                                       = {0}, timeoutObj = {0};
+	                                       = {0}, timeoutObj = {0}, channelObj = {0};
 	gboolean enable_tethering = FALSE, invalidArg = TRUE;
 	gchar *ssid = NULL, *passphrase = NULL;
 	int timeout = 0;
+	guint32 channel = 0;
 	gboolean is_open = FALSE;
 	gboolean state_set = FALSE;
 
@@ -615,6 +627,29 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 		invalidArg = FALSE;
 	}
 
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("channel"), &channelObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change channel while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_TIMEOUT);
+			goto cleanup;
+		}
+
+		jnumber_get_i32(channelObj, &channel);
+
+		if (!connman_technology_set_tethering_channel(
+		            connman_manager_find_wifi_technology(manager), channel))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering Channel",
+										WCA_API_ERROR_TETHERING_CHANNEL_FAILED);
+			goto cleanup;
+		}
+
+		invalidArg = FALSE;
+	}
+
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
 	{
 		jboolean_get(enabledObj, &enable_tethering);

commit 04e60499671db7dfd94767b523ec06f27b4a5732
Author: Sungho shin <sungho1.shin@lge.com>
Date:   Mon Jun 17 14:57:52 2019 +0900

    Add support for WiFi country code
    
    :Release Notes:
    Add support for WiFi country code
    
    :Detailed Notes:
    This commit adds getCountryCode and setCountryCode methods in
    com.webos.service.wifi to get/set WiFi country code.
    
    :Testing Performed:
    - Build tested.
    - Tested /getCountryCode works as expected.
    - Tested /setCountryCode works as expected.
    - See PLAT-79670 for luna methods used in testing.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-79670] Implement LS2 API for wifi country code setting
    
    Change-Id: I92309be7f5bec10759d8a07173510a9ec37ded08

diff --git a/src/errors.h b/src/errors.h
index c0427dc..07fb07f 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -109,5 +109,6 @@
 #define WCA_API_ERROR_FAILED_TO_SET_GO_INTENT           206
 #define WCA_API_ERROR_TETHERING_CHANNEL_FAILED   207
 #define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_CHANNEL 208
+#define WCA_API_ERROR_WIFI_SET_COUNTRY_CODE_FAILED 209
 
 #endif /* ERRORS_H_ */
diff --git a/src/wifi_service.c b/src/wifi_service.c
index e957b98..c65388f 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -69,6 +69,8 @@ errorText | Yes | String | Error description
 
 #define MAX_PREFIX_LENGTH   128
 
+#define MAX_COUNTRY_CODE_LENGTH 2
+
 static LSHandle *pLsHandle;
 
 connman_manager_t *manager = NULL;
@@ -3498,6 +3500,226 @@ static void handle_luna_subscription_cancel(LSHandle *sh, LSMessage *message, vo
 	}
 }
 
+static bool set_country_code(const char* countryCode)
+{
+	FILE *fp = NULL;
+	char *command = NULL;
+	command = g_strdup_printf("iw reg set %s", countryCode);
+
+	fp = popen(command, "r");
+	if (NULL == fp)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_setCountryCode setCountryCode
+
+Set the country code for wifi technology
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+countryCode | Yes | String | The ISO/IEC alpha2 country code for the country in which this device is currently operating
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_country_code_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(countryCode, string)) REQUIRED_1(countryCode))),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref countryCodeObj = NULL;
+	char *countryCode = NULL;
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("countryCode"), &countryCodeObj))
+	{
+		raw_buffer countryCode_buf = jstring_get(countryCodeObj);
+		countryCode = g_strdup(countryCode_buf.m_str);
+		jstring_free_buffer(countryCode_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (!set_country_code(countryCode))
+	{
+		LSMessageReplyCustomError(sh, message,
+		                          "Error in setting WiFi country code",
+		                          WCA_API_ERROR_WIFI_SET_COUNTRY_CODE_FAILED);
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(countryCode);
+	j_release(&parsedObj);
+	return true;
+}
+
+static bool get_country_code()
+{
+	FILE *fp = NULL;
+	char countryCodeBuff[MAX_COUNTRY_CODE_LENGTH];
+	size_t readSize = 0;
+	char *command = NULL;
+	command = g_strdup_printf("iw reg get | awk '/^country/{print $2}' | cut -c 1-2");
+
+	fp = popen(command, "r");
+	if (NULL == fp)
+	{
+		return false;
+	}
+
+	readSize = fread((void*)countryCodeBuff, sizeof(char), MAX_COUNTRY_CODE_LENGTH, fp);
+	if (0 == readSize)
+	{
+		g_free(command);
+		pclose(fp);
+		return false;
+	}
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(manager);
+
+	if (NULL == technology)
+		return false;
+
+	if (NULL != technology->country_code)
+		g_free(technology->country_code);
+
+	technology->country_code = g_strndup(countryCodeBuff, MAX_COUNTRY_CODE_LENGTH);
+
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi com.webos.wifi
+@{
+@section com_webos_wifi_getCountryCode getCountryCode
+
+Gets the current WiFi country code
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+None
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+countryCode | Yes | String | The ISO/IEC alpha2 country code for the country in which this device is currently operating
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_country_code_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+
+
+	if (get_country_code() && NULL != technology->country_code)
+	{
+		jobject_put(reply, J_CSTR_TO_JVAL("countryCode"),
+				jstring_create(technology->country_code));
+	}
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
 static void agent_registered_callback(gpointer user_data)
 {
 	gchar *agent_path;
@@ -3631,6 +3853,8 @@ static LSMethod wifi_methods[] =
 	{ LUNA_METHOD_CREATEWPSPIN,         handle_create_wpspin_command },
 	{ LUNA_METHOD_STARTWPS,     handle_start_wps_command },
 	{ LUNA_METHOD_CANCELWPS,        handle_cancel_wps_command },
+	{ LUNA_METHOD_SET_COUNTRY_CODE, handle_set_country_code_command },
+	{ LUNA_METHOD_GET_COUNTRY_CODE, handle_get_country_code_command },
 	{ },
 };
 
diff --git a/src/wifi_service.h b/src/wifi_service.h
index b51d7db..899f723 100644
--- a/src/wifi_service.h
+++ b/src/wifi_service.h
@@ -48,6 +48,8 @@
 #define LUNA_METHOD_STARTWPS                "startwps"
 #define LUNA_METHOD_CANCELWPS               "cancelwps"
 
+#define LUNA_METHOD_SET_COUNTRY_CODE        "setCountryCode"
+#define LUNA_METHOD_GET_COUNTRY_CODE        "getCountryCode"
 
 #define WIFI_ENTERPRISE_SECURITY_TYPE       "ieee8021x"
 

commit 4e636274696392f9776b7c91fdd2a8cdf0ae6827
Author: Sungho shin <sungho1.shin@lge.com>
Date:   Sun Jun 23 14:41:12 2019 +0900

    Add support for WiFi tethering IP address
    
    :Release Notes:
    Add support for WiFi tethering IP address
    
    :Detailed Notes:
    This commit adds 'ipAddress' property to get/set WiFi tethering
    IP address in setState and getState methods of com.webos.service.
    wifi/tethering.
    
    :Testing Performed:
    - Build tested.
    - Tested /tethering/setState works as expected.
    - Tested /tethering/getState works as expected.
    - See PLAT-79665 for luna methods used in testing.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-79665] Impelment LS2 API for softap ip setting
    
    Change-Id: I3ab42288493610c7682a453186258c9b74cb9d1e

diff --git a/src/connman_technology.c b/src/connman_technology.c
index d2dfbbf..3181e49 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -197,6 +197,38 @@ gboolean connman_technology_set_tethering_channel(connman_technology_t
 	return TRUE;
 }
 
+/**
+ * Set the ipaddress of ssid used in tethering (see header for API details)
+ */
+
+extern gboolean connman_technology_set_tethering_ipaddress(
+    connman_technology_t *technology, const gchar *tethering_ipaddress)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "TetheringIPAddress",
+	        g_variant_new_variant(g_variant_new_string(tethering_ipaddress)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_TETHERING_IPADDRESS_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	g_free(technology->tethering_ipaddress);
+	technology->tethering_ipaddress = g_strdup(tethering_ipaddress);
+	return TRUE;
+}
+
 /**
  * Cancel any active P2P connection (see header for API details)
  */
@@ -675,6 +707,11 @@ static void set_property_value(connman_technology_t *technology,
 	{
 		technology->tethering_channel = g_variant_get_uint32(val);
 	}
+	else if (!g_strcmp0(key, "TetheringIPAddress"))
+	{
+		g_free(technology->tethering_ipaddress);
+		technology->tethering_ipaddress = g_variant_dup_string(val, NULL);
+	}
 	else if (!g_strcmp0(key, "CountryCode"))
 	{
 		g_free(technology->country_code);
diff --git a/src/connman_technology.h b/src/connman_technology.h
index 1aea8f5..2be5a00 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -47,6 +47,7 @@ typedef struct connman_technology
 	gchar *country_code;
 	gchar *tethering_identifier;
 	gchar *tethering_passphrase;
+	gchar *tethering_ipaddress;
 	gboolean powered;
 	gboolean connected;
 	gboolean tethering;
@@ -146,6 +147,17 @@ extern gboolean connman_technology_set_tethering_passphrase(
 extern gboolean connman_technology_set_tethering_channel(
 	connman_technology_t*technology, const guint32 channel);
 
+/**
+ * Set ip address used in tethering
+ *
+ * @param[IN]  technology A technology instance
+ * @param[IN]  tethering ip address
+ *
+ * @return FALSE for any error, TRUE otherwise
+ */
+extern gboolean connman_technology_set_tethering_ipaddress(
+    connman_technology_t *technology, const gchar *tethering_ipaddress);
+
 /**
  * Enable/disable wifi-direct technology
  *
diff --git a/src/errors.h b/src/errors.h
index 07fb07f..555d7e7 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -110,5 +110,6 @@
 #define WCA_API_ERROR_TETHERING_CHANNEL_FAILED   207
 #define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_CHANNEL 208
 #define WCA_API_ERROR_WIFI_SET_COUNTRY_CODE_FAILED 209
+#define WCA_API_ERROR_TETHERING_IP_ADDRESS_FAILED         148
 
 #endif /* ERRORS_H_ */
diff --git a/src/logging.h b/src/logging.h
index fcce5fb..5fea943 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -134,6 +134,7 @@ extern PmLogContext gLogContext;
 #define MSGID_TECHNOLOGY_SET_TETHERING_IDENTIFIER_ERROR "TECH_SET_TETHERING_IDENTI_ERR"
 #define MSGID_TECHNOLOGY_SET_TETHERING_PASSPHRASE_ERROR "TECH_SET_TETHERING_PASSPH_ERR"
 #define MSGID_TECHNOLOGY_SET_TETHERING_CHANNEL_ERROR    "TECH_SET_TETHERING_CHANNEL_ERR"
+#define MSGID_TECHNOLOGY_SET_TETHERING_IPADDRESS_ERROR  "TECH_SET_TETHERING_IP_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_P2P_ERROR               "TECH_CANCEL_P2P_ERR"
 #define MSGID_TECHNOLOGY_CANCEL_WPS_ERROR               "TECH_CANCEL_WPS_ERR"
 #define MSGID_TECHNOLOGY_START_WPS_ERROR                "TECH_START_WPS_ERR"
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 905f409..858c747 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -249,6 +249,12 @@ static void send_tethering_state(jvalue_ref *reply)
 		                           && (strlen(wifi_tech->tethering_passphrase) != 0) ? "psk" : "open"));
 	}
 
+	if (NULL != wifi_tech->tethering_ipaddress)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("ipAddress"),
+		            jstring_create(wifi_tech->tethering_ipaddress));
+	}
+
 	if (wifi_tech->tethering_channel == 0)
 	{
 		jobject_put(*reply, J_CSTR_TO_JVAL("channel"),
@@ -452,17 +458,17 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
 	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_6(PROP(enabled, boolean),
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_7(PROP(enabled, boolean),
 	                                     PROP(ssid, string), PROP(passPhrase, string), PROP(securityType, string),
-	                                     PROP(timeout, integer), PROP(channel, integer)))), &parsedObj))
+	                                     PROP(timeout, integer), PROP(channel, integer), PROP(ipAddress, string)))), &parsedObj))
 	{
 		return true;
 	}
 
 	jvalue_ref enabledObj = {0}, ssidObj = {0}, passPhraseObj = {0}, securityTypeObj
-	                                       = {0}, timeoutObj = {0}, channelObj = {0};
+	                                       = {0}, timeoutObj = {0}, channelObj = {0}, ipAddressObj = {0};
 	gboolean enable_tethering = FALSE, invalidArg = TRUE;
-	gchar *ssid = NULL, *passphrase = NULL;
+	gchar *ssid = NULL, *passphrase = NULL, *ipAddress = NULL;
 	int timeout = 0;
 	guint32 channel = 0;
 	gboolean is_open = FALSE;
@@ -650,6 +656,36 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 		invalidArg = FALSE;
 	}
 
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ipAddress"), &ipAddressObj))
+	{
+		if (is_wifi_tethering())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Not allowed to change IP Address while tethering is enabled",
+			                          WCA_API_ERROR_TETHERING_IP_ADDRESS_FAILED);
+			goto cleanup;
+		}
+
+		raw_buffer ipAddress_buf = jstring_get(ipAddressObj);
+		ipAddress = g_strdup(ipAddress_buf.m_str);
+		jstring_free_buffer(ipAddress_buf);
+
+		if (NULL == ipAddress)
+		{
+			goto invalid_params;
+		}
+
+		invalidArg = FALSE;
+
+		if (!connman_technology_set_tethering_ipaddress(
+		            connman_manager_find_wifi_technology(manager), ipAddress))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in setting tethering IP Address",
+					                                WCA_API_ERROR_TETHERING_IP_ADDRESS_FAILED);
+			goto cleanup;
+		}
+	}
+
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
 	{
 		jboolean_get(enabledObj, &enable_tethering);

commit 61c559cf6d8591deb20123773c8932eeba47196a
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed Aug 28 19:30:03 2019 +0900

    Support channel frequency of scanned AP
    
    :Release Notes:
    Support channel frequency of scanned AP
    
    :Detailed Notes:
    This commit modified webos-connman-adapter to provide BSS info
    of scanned AP around.
    
    :Testing Performed:
    Verified that channel frequency of scanned AP is retrieved.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-84457] Get the channel of connected AP
    
    Change-Id: I1827bc538729e57567a5bbe14f738aae0fdff1f2

diff --git a/src/connman_service.c b/src/connman_service.c
index 9026589..a855586 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1066,6 +1066,79 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 			                            CONNMAN_SERVICE_CHANGE_CATEGORY_FINDNETWORKS);
 		}
 	}
+	else if (!g_strcmp0(property, "BSS"))
+	{
+		if (service->bss != NULL)
+		{
+			g_array_free(service->bss ,TRUE);
+			service->bss = NULL;
+		}
+
+		gsize len = g_variant_n_children(va);
+		gsize j;
+		GArray* array = g_array_sized_new(FALSE, FALSE, sizeof(bssinfo_t), len);
+
+		for (j = 0; j < len; j++)
+		{
+			/* FIXME: Remove the extra struct from connman response? */
+			GVariant *temp = g_variant_get_child_value(va, j);
+			GVariant *bss_entry = g_variant_get_child_value(temp, 0);
+			g_variant_unref(temp);
+
+			bssinfo_t bss_info;
+
+			GVariant *bss_v = g_variant_lookup_value(bss_entry, "Id", G_VARIANT_TYPE_STRING);
+			GVariant *signal_v = g_variant_lookup_value(bss_entry, "Signal", G_VARIANT_TYPE_INT32);
+			GVariant *frequency_v = g_variant_lookup_value(bss_entry, "Frequency", G_VARIANT_TYPE_INT32);
+			if (!bss_v || !signal_v  || !frequency_v)
+			{
+				WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Missing some fields in BSS section");
+			}
+
+			if (bss_v)
+			{
+				gsize length;
+				const char* bss = g_variant_get_string(bss_v, &length);
+
+				if (length > 17)
+				{
+					WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %i, truncting", length);
+				}
+
+				g_strlcpy(bss_info.bssid, bss, 18);
+				g_variant_unref(bss_v);
+			}
+			else
+			{
+				bss_info.bssid[0] = 0;
+			}
+
+			if (signal_v)
+			{
+				bss_info.signal = g_variant_get_int32(signal_v);
+				g_variant_unref(signal_v);
+			}
+			else
+			{
+				bss_info.signal = 0;
+			}
+
+			if (frequency_v)
+			{
+				bss_info.frequency = g_variant_get_int32(frequency_v);
+				g_variant_unref(frequency_v);
+			}
+			else
+			{
+				bss_info.frequency = 0;
+			}
+
+			g_variant_unref(bss_entry);
+			array = g_array_append_val(array, bss_info);
+		}
+
+		service->bss = array;
+	}
 	else if (!g_strcmp0(property, "Online"))
 	{
 		connman_service_advance_online_state(service, va);

commit 7fa5f961cff66b811356f3f18e30e0a60e0ec5f0
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed Sep 4 14:08:13 2019 +0900

    Provide station information when AP mode
    
    :Release Notes:
    Provide station information when AP mode
    
    :Detailed Notes:
    This commit modifies webos-connman-adapter to
    provide connected station information via
    tethering/getStationCount.
    
    "StationMac" property comes from connman via dbus and
    webos-connman-adapter retrieves MAC of connected station
    and show this to subscribers or callers.
    
    :Testing Performed:
    Verified that MAC of connected station is subscribed using
    tethering/getStationCount
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-84454] Get the information of connected client on the server
    
    Change-Id: I9d73f538e81bea6a33d63196a642d36adc6ccd70

diff --git a/src/connman_technology.c b/src/connman_technology.c
index 3181e49..f145f7b 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -1071,5 +1071,7 @@ void connman_technology_free(connman_technology_t *technology)
 	g_object_unref(technology->remote);
 	technology->remote = NULL;
 
+	g_strfreev(technology->station_mac);
+
 	g_free(technology);
 }
diff --git a/src/connman_technology.h b/src/connman_technology.h
index 2be5a00..d6f9169 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -74,6 +74,7 @@ typedef struct connman_technology
 
 	gboolean removed; /* If true, the technology has been removed and should be deleted when callbacks complete*/
 	gint32 calls_pending; /* Number of connman DBUS calls pending. */
+	GStrv station_mac;
 } connman_technology_t;
 
 
diff --git a/src/wifi_service.c b/src/wifi_service.c
index c65388f..7d9502c 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1991,7 +1991,12 @@ static void technology_property_changed_callback(gpointer data,
 			wifi_send_status_to_subscribers();
 		}
 
-		if(g_strcmp0(property, "StaCount") == 0) {
+		if(g_strcmp0(property, "StationMac") == 0) {
+			GVariant *va = g_variant_get_child_value(value, 0);
+			g_strfreev(technology->station_mac);
+			technology->station_mac = g_variant_dup_strv(va, NULL);
+
+			g_variant_unref(va);
 			send_sta_count_to_subscribers();
 		}
 	}
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 858c747..d388f62 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -310,6 +310,17 @@ static void send_sta_count(jvalue_ref *reply)
 
 	unsigned int sta_count = connman_manager_get_sta_count(manager);
 	jobject_put(*reply, J_CSTR_TO_JVAL("stationCount"), jnumber_create_i32(sta_count));
+
+	jvalue_ref connected_stations_obj = jarray_create(NULL);
+
+	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+
+	for (int i = 0; i < g_strv_length(wifi_tech->station_mac); i++)
+	{
+		jarray_append(connected_stations_obj, jstring_create(wifi_tech->station_mac[i]));
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("connectedStations"), connected_stations_obj);
 }
 
 void send_sta_count_to_subscribers(void)

commit b23a839abc9836353a212013d420ab46480562f5
Merge: 8a9118f 7fa5f96
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Sep 24 11:03:46 2019 +0900

    Merge remote-tracking branch 'origin/develop'

commit 4050234a21307933d9a91dcabf7ebba9d0825e0f
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Fri Oct 4 21:34:57 2019 +0900

    Fix static analysis regarding SoftAP impl.
    
    :Release Notes:
    Fix static analysis regarding SoftAP impl.
    
    :Detailed Notes:
    This commit fixes static analysis reported regarding
    SoftAP implementation.
    
    - 260288 Unchecked return value from library
    - 260302 Resource leak
    - 260303 Resource leak
    - 260289 Resource leak
    - 260292 Resource leak
    
    :Testing Performed:
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-86705] 260303 Resource leak (webos-connman-adapter)
    [PLAT-86706] 260302 Resource leak (webos-connman-adapter)
    [PLAT-86707] 260292 Resource leak (webos-connman-adapter)
    [PLAT-86708] 260289 Resource leak (webos-connman-adapter)
    [PLAT-86709] 260288 Unchecked return value from library
                 (webos-connman-adapter)
    
    Change-Id: I7bed5d123851ed2c8f8e8513dc542a68ae1873d4

diff --git a/src/connman_service.c b/src/connman_service.c
index a855586..272ca5e 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1097,6 +1097,7 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 
 			if (bss_v)
 			{
+				gsize i;
 				gsize length;
 				const char* bss = g_variant_get_string(bss_v, &length);
 
@@ -1105,7 +1106,11 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 					WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %i, truncting", length);
 				}
 
-				g_strlcpy(bss_info.bssid, bss, 18);
+				i = g_strlcpy(bss_info.bssid, bss, 18);
+				if (i != strlen(bss))
+				{
+					WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Failed to copy bssid info.");
+				}
 				g_variant_unref(bss_v);
 			}
 			else
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 7d9502c..bbaefc9 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -3517,6 +3517,9 @@ static bool set_country_code(const char* countryCode)
 		return false;
 	}
 
+	g_free(command);
+	pclose(fp);
+
 	return true;
 }
 
@@ -3627,13 +3630,20 @@ static bool get_country_code()
 	connman_technology_t *technology = connman_manager_find_wifi_technology(manager);
 
 	if (NULL == technology)
+	{
+		pclose(fp);
+		g_free(command);
 		return false;
+	}
 
 	if (NULL != technology->country_code)
 		g_free(technology->country_code);
 
 	technology->country_code = g_strndup(countryCodeBuff, MAX_COUNTRY_CODE_LENGTH);
 
+	pclose(fp);
+	g_free(command);
+
 	return true;
 }
 

commit 1d08e53a2708b2e74e955b460a428027700e4d53
Merge: b23a839 4050234
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Oct 8 10:58:32 2019 +0900

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I5558d9e86abe5be26624d9f6c1db974f61bfebe1

commit e37b389cd0dad0ead2ad2d73767b1f9d437c016d
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Oct 10 19:01:54 2019 +0900

    Remove duplicated return from tethering/getState
    
    :Release Notes:
    Remove duplicated return from tethering/getState
    
    :Detailed Notes:
    This commit fixes the duplicated return issue from com.webos
    .service.wifi/tethering/getState when enabling tethering
    using changed argument. Root cause of this issue is because
    tethering related property of technology struct was modified
    immediately with the value that has been requested by user
    when setting the tethering property. Normally, modified
    tethering property should be retrieved from connman layer.
    
    :Testing Performed:
    Verified that QWA-1001 passes.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-86919] [webOS OSE2.0] : The return is displayed twice
    
    Change-Id: I2126c73261ce93cfd8c43b3267270836cc608cbb

diff --git a/src/connman_technology.c b/src/connman_technology.c
index f145f7b..695526f 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -98,7 +98,6 @@ extern gboolean connman_technology_set_tethering(connman_technology_t
 		return FALSE;
 	}
 
-	technology->tethering = state;
 	g_usleep(1000000);
 	return TRUE;
 }
@@ -130,8 +129,6 @@ extern gboolean connman_technology_set_tethering_identifier(
 		return FALSE;
 	}
 
-	g_free(technology->tethering_identifier);
-	technology->tethering_identifier = g_strdup(tethering_identifier);
 	return TRUE;
 }
 
@@ -162,8 +159,6 @@ extern gboolean connman_technology_set_tethering_passphrase(
 		return FALSE;
 	}
 
-	g_free(technology->tethering_passphrase);
-	technology->tethering_passphrase = g_strdup(tethering_passphrase);
 	return TRUE;
 }
 
@@ -193,7 +188,6 @@ gboolean connman_technology_set_tethering_channel(connman_technology_t
 		return FALSE;
 	}
 
-	technology->tethering_channel = channel;
 	return TRUE;
 }
 
@@ -224,8 +218,6 @@ extern gboolean connman_technology_set_tethering_ipaddress(
 		return FALSE;
 	}
 
-	g_free(technology->tethering_ipaddress);
-	technology->tethering_ipaddress = g_strdup(tethering_ipaddress);
 	return TRUE;
 }
 
diff --git a/src/wifi_service.c b/src/wifi_service.c
index bbaefc9..0f881b4 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1981,16 +1981,20 @@ static void technology_property_changed_callback(gpointer data,
 
 		}
 
-		if (g_strcmp0(property, "Tethering") == 0 ||
-		    g_strcmp0(property, "TetheringIdentifier") == 0 ||
-		    g_strcmp0(property, "TetheringPassphrase") == 0 ||
-		    g_strcmp0(property, "TetheringChannel") == 0)
+		if (g_strcmp0(property, "Tethering") == 0)
 		{
 			send_tethering_state_to_subscribers();
 			connectionmanager_send_status_to_subscribers();
 			wifi_send_status_to_subscribers();
 		}
 
+		if (g_strcmp0(property, "TetheringIPAddress") == 0 ||
+				g_strcmp0(property, "TetheringIdentifier") == 0 ||
+				g_strcmp0(property, "TetheringChannel") == 0)
+		{
+			send_tethering_state_to_subscribers();
+		}
+
 		if(g_strcmp0(property, "StationMac") == 0) {
 			GVariant *va = g_variant_get_child_value(value, 0);
 			g_strfreev(technology->station_mac);

commit cdfb68f1d85c47e9376dcf4ce669c2441bcd87c7
Merge: 1d08e53 e37b389
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Oct 10 19:25:11 2019 +0900

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I288c2d93426bde73f557ee9b6ec8f6a6dc0027e0

commit 35b973fd68a589bc4739f1519fc035ec2e9c1e7c
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Tue Nov 5 11:24:03 2019 +0530

    Fix coverity issues for webos-connman-adapter
    
    :Release Notes:
    Fix coverity issues
    
    :Detailed Notes:
    Removed unnecessary headers
    fixed debug log argument
    
    :Testing Performed:
    Build successfully.
    Ethernet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-93181] 283077 Unnecessary header file (webos-connman-adapter)
    [PLAT-93202] 282293 Unnecessary header file (webos-connman-adapter)
    [PLAT-93230] 281088 Unnecessary header file (webos-connman-adapter)
    [PLAT-93317] 277721 Unnecessary header file (webos-connman-adapter)
    [PLAT-93481] 272889 Unnecessary header file (webos-connman-adapter)
    [PLAT-93754] 260744 Extra argument to printf format specifier
                        (webos-connman-adapter)
    
    Change-Id: If7d48527223e71c60d39a46b65c5f7d59d0524a9

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 6581c65..5f07353 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -43,7 +43,6 @@ errorText | Yes | String | Error description
 #include <time.h>
 #include <string.h>
 #include <pbnjson.h>
-#include <errno.h>
 
 #include "common.h"
 #include "connman_manager.h"
diff --git a/src/connman_manager.c b/src/connman_manager.c
index a72aa01..06ec085 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -24,7 +24,6 @@
 #include "connman_manager.h"
 #include "logging.h"
 #include "connectionmanager_service.h"
-#include "utils.h"
 
 
 wca_support_connman_update_callbacks *connman_update_callbacks = { { NULL } };
diff --git a/src/connman_service_discovery.c b/src/connman_service_discovery.c
index b2cd184..9b83aa6 100644
--- a/src/connman_service_discovery.c
+++ b/src/connman_service_discovery.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2018 LG Electronics, Inc.
+// Copyright (c) 2013-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -23,7 +23,6 @@
 
 #include "connman_service_discovery.h"
 #include "connman_manager.h"
-#include "common.h"
 
 #include "logging.h"
 
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 0f881b4..5d7de9f 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -58,7 +58,6 @@ errorText | Yes | String | Error description
 #include "logging.h"
 #include "wifi_tethering_service.h"
 #include "errors.h"
-#include "nyx.h"
 
 /* Range for converting signal strength to signal bars */
 #define MID_SIGNAL_RANGE_LOW    55
@@ -640,7 +639,7 @@ static gboolean handle_failed_connection_request(gpointer user_data)
 		wifi_profile_t *profile = get_profile_by_ssid_security(service->name,
 		                          service->security[0]);
 		if (profile) {
-			WCALOG_DEBUG(MSGID_WIFI_CONNECT_SERVICE, "profile present for failed connection so delete it after 5sec");
+			WCALOG_DEBUG("profile present for failed connection so delete it after 5sec");
 			profile_info_t* failed_connection_profile_info = g_new0(profile_info_t, 1);
 			failed_connection_profile_info->service_path = g_strdup(service->path);
 			failed_connection_profile_info->profile_id = profile->profile_id;
diff --git a/tests/test-ssid-conversion.c b/tests/test-ssid-conversion.c
index ef9a8f4..8a98b9d 100644
--- a/tests/test-ssid-conversion.c
+++ b/tests/test-ssid-conversion.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2019 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
 // SPDX-License-Identifier: Apache-2.0
 
 #include <glib.h>
-#include <locale.h>
 #include <string.h>
 
 #include "utils.h"

commit e2eb43084f5067a3f754b4b9d12cfcb5ccd15d33
Merge: cdfb68f 35b973f
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Tue Nov 5 17:12:18 2019 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: Ia01d8ea19f929ce16a8cf3f82589214315203bc3

commit 57c10937c7ec696637c11b8a8d1ea38e9ad5b3e1
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Thu Dec 5 15:31:15 2019 +0530

    Fix coverity issues
    
    :Release Notes:
    Fix Resource leak coverity issues
    
    :Detailed Notes:
    Address Resource leak coverity issues, occurd due to not freeing
    allocation done by g_key_file_new().
    
    :Testing Performed:
    Build successful
    
    :Issues Addressed:
    [PLAT-97076] 133647 Resource leak (webos-connman-adapter)
    [PLAT-97077] 133245 Resource leak (webos-connman-adapter)
    [PLAT-97078] 132912 Resource leak (webos-connman-adapter)
    [PLAT-97079] 132892 Resource leak (webos-connman-adapter)
    [PLAT-97080] 131929 Resource leak (webos-connman-adapter)
    
    Change-Id: Ied945bba74b707f653cb03e825daffbb51d518bf

diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index cff6843..8896e74 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -770,6 +770,7 @@ gboolean change_network_passphrase(const char *ssid, const char *security,
 
 	g_free(pathname);
 	g_free(config_group);
+	g_key_file_free(keyfile);
 	return ret;
 }
 
@@ -810,6 +811,7 @@ gboolean change_network_ipv4(const char *ssid, const char *security,
 	g_free(ipv4str);
 	g_free(pathname);
 	g_free(config_group);
+	g_key_file_free(keyfile);
 	return ret;
 }
 
@@ -851,6 +853,7 @@ gboolean change_network_ipv6(const char *ssid, const char *security,
 	g_free(ipv6str);
 	g_free(pathname);
 	g_free(config_group);
+	g_key_file_free(keyfile);
 	return ret;
 }
 
@@ -902,6 +905,7 @@ gboolean change_network_dns(const char *ssid, const char *security,
 	g_free(dnsstr);
 	g_free(pathname);
 	g_free(config_group);
+	g_key_file_free(keyfile);
 	return ret;
 }
 
@@ -939,6 +943,7 @@ gboolean change_network_remove_entry(const char *ssid, const char *security,
 
 	g_free(pathname);
 	g_free(config_group);
+	g_key_file_free(keyfile);
 	return ret;
 
 }
@@ -1030,6 +1035,7 @@ gboolean check_profile_or_create(const char *file, gchar **pathname)
 	}
 
 	g_strfreev(groups);
+	g_key_file_free(keyfile);
 	return ret;
 }
 

commit 9faa30429792ced96d7cd43e7482ab66033f2b86
Merge: e2eb430 57c1093
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Thu Dec 5 16:37:37 2019 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: Ia0745fdbf43c2c151cb14b36b265e869e0646520

commit 798fc9da67287413438657c4ccb7d63456b877b1
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Oct 29 21:13:21 2019 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis reported.
    
    - 132924 Resource leak
    
    :Testing Performed:
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-88510] 132924 Resource leak (webos-connman-adapter)
    
    Change-Id: I74f3f0c0c3ac4d91c91af8ae4d46c0a7639526c9

diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 8896e74..4662222 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -1127,6 +1127,7 @@ void sync_network_configs_with_profiles(void)
 
 		if (config_pathname == NULL)
 		{
+			g_free(abs_filename);
 			break;
 		}
 

commit c991227354bc96c80d2e225b2c2452d686677d8e
Merge: 9faa304 798fc9d
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon Dec 9 16:21:29 2019 +0900

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I25987d93064bbf544e2d19138682fd5bfe0fa893

commit 4a013084ea058e46d66928e8e265e6ea03ce7768
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Fri Jan 3 13:30:00 2020 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis reported.
    
    - 77146 Branch past initialization
    - 77147 Branch past initialization
    - 77148 Branch past initialization
    - 77144 Branch past initialization
    - 77145 Branch past initialization
    - 161886 Branch past initialization
    - 39140 Branch past initialization
    - 122801 Unchecked return value
    - 122803 Unchecked return value
    - 238197 Unchecked return value from library
    - 239047 Unchecked return value from library
    - 39129 Branch past initialization
    - 39130 Branch past initialization
    - 39131 Branch past initialization
    - 39139 Branch past initialization
    - 39143 Branch past initialization
    - 122806 Unchecked return value
    - 232956 Invalid type in argument to printf
             format specifier
    - 238371 Unchecked return value from library
    - 260723 Printf arg type mismatch
    - 263824 Invalid type in argument to printf
             format specifier
    - 264190 Printf arg type mismatch
    - 265224 Invalid type in argument to printf
             format specifier
    - 267242 Invalid type in argument to printf
             format specifier
    - 305960 Printf arg type mismatch
    - 306107 Invalid type in argument to printf
             format specifier
    
    :Testing Performed:
    Verified that Wi-Fi / Ethernet connection works as expected
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-87526] 267242 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-87655] 265224 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-87739] 264190 Printf arg type mismatch (webos-connman-adapter)
    [PLAT-87765] 263824 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-88017] 260723 Printf arg type mismatch (webos-connman-adapter)
    [PLAT-88417] 122803 Unchecked return value (webos-connman-adapter)
    [PLAT-88441] 238371 Unchecked return value from library
                 (webos-connman-adapter)
    [PLAT-88443] 238197 Unchecked return value from library
                 (webos-connman-adapter)
    [PLAT-88474] 232956 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-88479] 161886 Branch past initialization (webos-connman-adapter)
    [PLAT-88535] 122806 Unchecked return value (webos-connman-adapter)
    [PLAT-88536] 122803 Unchecked return value (webos-connman-adapter)
    [PLAT-88537] 122801 Unchecked return value (webos-connman-adapter)
    [PLAT-88642] 77147 Branch past initialization (webos-connman-adapter)
    [PLAT-88643] 77146 Branch past initialization (webos-connman-adapter)
    [PLAT-88644] 77145 Branch past initialization (webos-connman-adapter)
    [PLAT-88645] 77144 Branch past initialization (webos-connman-adapter)
    [PLAT-88657] 39143 Branch past initialization (webos-connman-adapter)
    [PLAT-88658] 39140 Branch past initialization (webos-connman-adapter)
    [PLAT-88659] 39139 Branch past initialization (webos-connman-adapter)
    [PLAT-88660] 39131 Branch past initialization (webos-connman-adapter)
    [PLAT-88661] 39130 Branch past initialization (webos-connman-adapter)
    [PLAT-88662] 39129 Branch past initialization (webos-connman-adapter)
    [PLAT-88855] 267242 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-88917] 265224 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-88965] 264190 Printf arg type mismatch (webos-connman-adapter)
    [PLAT-88981] 263824 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-89119] 260723 Printf arg type mismatch (webos-connman-adapter)
    [PLAT-89402] 239047 Unchecked return value from library
                 (webos-connman-adapter)
    [PLAT-89403] 238371 Unchecked return value from library
                 (webos-connman-adapter)
    [PLAT-89404] 238197 Unchecked return value from library
                 (webos-connman-adapter)
    [PLAT-89408] 232956 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-89416] 161886 Branch past initialization (webos-connman-adapter)
    [PLAT-89464] 122806 Unchecked return value (webos-connman-adapter)
    [PLAT-89465] 122803 Unchecked return value (webos-connman-adapter)
    [PLAT-89466] 122801 Unchecked return value (webos-connman-adapter)
    [PLAT-89537] 77148 Branch past initialization (webos-connman-adapter)
    [PLAT-89538] 77147 Branch past initialization (webos-connman-adapter)
    [PLAT-89539] 77146 Branch past initialization (webos-connman-adapter)
    [PLAT-89540] 77145 Branch past initialization (webos-connman-adapter)
    [PLAT-89541] 77144 Branch past initialization (webos-connman-adapter)
    [PLAT-89554] 39143 Branch past initialization (webos-connman-adapter)
    [PLAT-89555] 39140 Branch past initialization (webos-connman-adapter)
    [PLAT-89556] 39139 Branch past initialization (webos-connman-adapter)
    [PLAT-89557] 39131 Branch past initialization (webos-connman-adapter)
    [PLAT-89558] 39130 Branch past initialization (webos-connman-adapter)
    [PLAT-89559] 39129 Branch past initialization (webos-connman-adapter)
    [PLAT-97729] 306107 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-97750] 77148 Branch past initialization (webos-connman-adapter)
    [PLAT-97753] 305960 Printf arg type mismatch (webos-connman-adapter)
    [PLAT-97979] 306107 Invalid type in argument to printf format specifier
                 (webos-connman-adapter)
    [PLAT-97988] 305960 Printf arg type mismatch (webos-connman-adapter)
    
    Change-Id: I84bc0cd18d04f3ed5e9b4b7e9adde2c0e0ac3bb2

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 5f07353..0c310fc 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -140,7 +140,7 @@ static void update_connection_status(connman_service_t *connected_service,
 
 		for (i = 0; i < g_strv_length(connected_service->ipinfo.dns); i++)
 		{
-			g_snprintf(dns_str, 16, "dns%d", i + 1);
+			g_snprintf(dns_str, 16, "dns%lu", i + 1);
 			jobject_put(*status, jstring_create(dns_str),
 			            jstring_create(connected_service->ipinfo.dns[i]));
 		}
@@ -1147,6 +1147,7 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 	           gatewayObj = {0};
 	ipv6info_t ipv6 = {0};
 	gchar *ssid = NULL;
+	connman_service_t *service = NULL;
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
 	{
@@ -1194,7 +1195,7 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 		jstring_free_buffer(ssid_buf);
 	}
 
-	connman_service_t *service = retrieve_service_by_ssid(ssid);
+	service = retrieve_service_by_ssid(ssid);
 
 	if (NULL != service)
 	{
@@ -1321,6 +1322,7 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 	jvalue_ref ssidObj = {0}, dnsObj = {0};
 	GStrv dns = NULL;
 	gchar *ssid = NULL;
+	connman_service_t *service = NULL;
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dns"), &dnsObj))
 	{
@@ -1349,7 +1351,7 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 		jstring_free_buffer(ssid_buf);
 	}
 
-	connman_service_t *service = retrieve_service_by_ssid(ssid);
+	service = retrieve_service_by_ssid(ssid);
 
 	if (NULL != service)
 	{
@@ -1642,12 +1644,17 @@ static void getinfo_update(void)
 
 	char wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
 	char wired_mac_address[MAC_ADDR_STRING_LEN]={0};
+	gsize i;
 
 	if (retrieve_wifi_mac_address(wifi_mac_address, MAC_ADDR_STRING_LEN))
 	{
 		if (g_strcmp0(getinfo_cur_wifi_mac_address, wifi_mac_address))
 		{
-			g_strlcpy(getinfo_cur_wifi_mac_address, wifi_mac_address, MAC_ADDR_STRING_LEN);
+			i = g_strlcpy(getinfo_cur_wifi_mac_address, wifi_mac_address, MAC_ADDR_STRING_LEN);
+			if (i != strlen(wifi_mac_address))
+			{
+				WCALOG_ERROR(MSGID_WIFI_MAC_ADDR_ERROR,0,"Failed to copy mac address for wifi interface");
+			}
 		}
 	}
 	else
@@ -1665,7 +1672,11 @@ static void getinfo_update(void)
 	{
 		if (g_strcmp0(getinfo_cur_wired_mac_address, wired_mac_address))
 		{
-			g_strlcpy(getinfo_cur_wired_mac_address, wired_mac_address, MAC_ADDR_STRING_LEN);
+			i = g_strlcpy(getinfo_cur_wired_mac_address, wired_mac_address, MAC_ADDR_STRING_LEN);
+			if (i != strlen(wired_mac_address))
+			{
+				WCALOG_ERROR(MSGID_WIRED_MAC_ADDR_ERROR,0,"Failed to copy mac address for wired interface");
+			}
 		}
 	}
 	else
@@ -1743,7 +1754,10 @@ static bool handle_get_info_command(LSHandle *sh, LSMessage *message,
 	}
 
 	getinfo_add_response(&reply, subscribed);
-	LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()), &lserror);
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()), &lserror))
+	{
+		goto cleanup;
+	}
 
 cleanup:
 
@@ -1806,6 +1820,9 @@ static bool handle_check_internet_status_command(LSHandle *sh,
 	LSErrorInit(&lserror);
 	gboolean wired_status = TRUE, wifi_status = TRUE;
 
+	connman_service_t *connected_wired_service = NULL;
+	connman_service_t *connected_wifi_service = NULL;
+
 	if (block_getstatus_response)
 	{
 		goto exit;
@@ -1814,8 +1831,8 @@ static bool handle_check_internet_status_command(LSHandle *sh,
 	if (!connman_status_check(manager, sh, message))
 		return true;
 
-	connman_service_t *connected_wired_service =
-	    connman_manager_get_connected_service(manager->wired_services);
+	connected_wired_service =
+		connman_manager_get_connected_service(manager->wired_services);
 
 	if (connected_wired_service)
 	{
@@ -1823,8 +1840,8 @@ static bool handle_check_internet_status_command(LSHandle *sh,
 		               TRUE);
 	}
 
-	connman_service_t *connected_wifi_service =
-	    connman_manager_get_connected_service(manager->wifi_services);
+	connected_wifi_service =
+		connman_manager_get_connected_service(manager->wifi_services);
 
 	if (connected_wifi_service)
 	{
diff --git a/src/connman_service.c b/src/connman_service.c
index 272ca5e..c9e2b26 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -1103,7 +1103,7 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 
 				if (length > 17)
 				{
-					WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %i, truncting", length);
+					WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %lu, truncting", length);
 				}
 
 				i = g_strlcpy(bss_info.bssid, bss, 18);
@@ -1501,14 +1501,19 @@ void connman_service_update_properties(connman_service_t *service,
 				if (bss_v)
 				{
 					gsize length;
+					gsize i;
 					const char* bss = g_variant_get_string(bss_v, &length);
 
 					if (length > 17)
 					{
-						WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %i, truncting", length);
+						WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Incorrect bssid length, %lu, truncting", length);
 					}
 
-					g_strlcpy(bss_info.bssid, bss, 18);
+					i = g_strlcpy(bss_info.bssid, bss, 18);
+					if (i != strlen(bss))
+					{
+						WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Failed to copy bssid information");
+					}
 					g_variant_unref(bss_v);
 				}
 				else
diff --git a/src/connman_technology.c b/src/connman_technology.c
index 695526f..fd6073f 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -952,6 +952,7 @@ connman_technology_t *connman_technology_new(const gchar* path)
 
 	connman_technology_t *technology = g_new0(connman_technology_t, 1);
 	GError *error = NULL;
+	GVariant* properties = NULL;
 
 	technology->path = g_strdup(path);
 
@@ -985,7 +986,7 @@ connman_technology_t *connman_technology_new(const gchar* path)
 	 * before we register the signals, we do not get the update.
 	 * So, we need to get all that information from connman again.
 	 */
-	GVariant* properties = connman_technology_get_properties(technology);
+	properties = connman_technology_get_properties(technology);
 
 	if (NULL == properties)
 	{
diff --git a/src/nyx.c b/src/nyx.c
index 380e8c8..c91e3c5 100644
--- a/src/nyx.c
+++ b/src/nyx.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2016-2018 LG Electronics, Inc.
+// Copyright (c) 2016-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -62,6 +62,7 @@ static bool retrieve_nyx_data(nyx_device_info_type_t type, char* buffer, size_t
 {
 	nyx_error_t error;
 	const char* nyx_buffer = NULL;
+	gsize i;
 
 	error = nyx_device_info_query(device_main, type, &nyx_buffer);
 
@@ -70,7 +71,12 @@ static bool retrieve_nyx_data(nyx_device_info_type_t type, char* buffer, size_t
 		return false;
 	}
 
-	g_strlcpy(buffer, nyx_buffer, buffer_size);
+	i = g_strlcpy(buffer, nyx_buffer, buffer_size);
+	if (i != strlen(nyx_buffer))
+	{
+		WCALOG_ERROR(MSGID_NYX_INIT_ERROR, 0, "Error in nyx_init");
+		return false;
+	}
 	return true;
 }
 
@@ -82,4 +88,4 @@ bool retrieve_wired_mac_address(char* buffer, size_t buffer_size)
 bool retrieve_wifi_mac_address(char* buffer, size_t buffer_size)
 {
 	return retrieve_nyx_data(NYX_DEVICE_INFO_WIFI_ADDR, buffer, buffer_size);
-}
\ No newline at end of file
+}
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 5d7de9f..9b5f41a 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -321,7 +321,7 @@ static void add_connected_network_status(jvalue_ref *reply,
 
 			for (i = 0; i < g_strv_length(connected_service->ipinfo.dns); i++)
 			{
-				g_snprintf(dns_str, 16, "dns%d", i + 1);
+				g_snprintf(dns_str, 16, "dns%lu", i + 1);
 				jobject_put(ip_info, jstring_create(dns_str),
 				            jstring_create(connected_service->ipinfo.dns[i]));
 			}
@@ -471,6 +471,9 @@ static void wifi_send_status_to_subscribers(void)
 static gboolean delete_profile_if_not_connected(gpointer user_data)
 {
 	profile_info_t* failed_connection_profile_info = (profile_info_t*) user_data;
+	connman_service_t *connected_service = NULL;
+	connman_service_t *service = NULL;
+
 	if((!failed_connection_profile_info) || !(failed_connection_profile_info->service_path))
 	{
 		return FALSE;
@@ -481,7 +484,7 @@ static gboolean delete_profile_if_not_connected(gpointer user_data)
 		goto cleanup;
 	}
 
-	connman_service_t *service = connman_manager_find_service_by_path(
+	service = connman_manager_find_service_by_path(
 			manager->wifi_services,
 			failed_connection_profile_info->service_path);
 
@@ -492,7 +495,7 @@ static gboolean delete_profile_if_not_connected(gpointer user_data)
 		goto cleanup;
 	}
 
-	connman_service_t *connected_service = connman_manager_get_connected_service(
+	connected_service = connman_manager_get_connected_service(
 	        manager->wifi_services);
 
 	if (NULL != connected_service || (connected_service != service))
@@ -765,25 +768,24 @@ static void service_property_changed_callback(gpointer data,
 
 				/* When the service object the state has changed for is not the one we're
 				 * currently connecting to then we do nothing here. */
-				if (!current_connect_req)
+				if (current_connect_req)
 				{
-					return;
-				}
-
-				current_service_data_t *service_data = current_connect_req->user_data;
 
-				if (service_data)
-				{
-					connman_service_t *curr_service = service_data->service;
+					current_service_data_t *service_data = current_connect_req->user_data;
 
-					// In case of hidden networks the original service never matches with the new service added
-					if (service != curr_service)
+					if (service_data)
 					{
-						service_data->service = service;
+						connman_service_t *curr_service = service_data->service;
+
+						// In case of hidden networks the original service never matches with the new service added
+						if (service != curr_service)
+						{
+							service_data->service = service;
+						}
 					}
-				}
 
-				handle_failed_connection_request(NULL);
+					handle_failed_connection_request(NULL);
+				}
 				return;
 
 			default:
@@ -2466,6 +2468,7 @@ static bool handle_findnetworks_command(LSHandle *sh, LSMessage *message,
 	gboolean result;
 	LSError lserror;
 	LSErrorInit(&lserror);
+	connman_technology_t *wifi_tech = NULL;
 
 	if (LSMessageIsSubscription(message))
 	{
@@ -2510,7 +2513,7 @@ static bool handle_findnetworks_command(LSHandle *sh, LSMessage *message,
 		}
 	}
 
-	connman_technology_t *wifi_tech = connman_manager_find_wifi_technology(manager);
+	wifi_tech = connman_manager_find_wifi_technology(manager);
 
 	if (NULL == wifi_tech)
 	{
@@ -2541,7 +2544,10 @@ static bool handle_findnetworks_command(LSHandle *sh, LSMessage *message,
 
 	populate_wifi_networks(&reply, FALSE);
 
-	LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()), &lserror);
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()), &lserror))
+	{
+		goto cleanup;
+	}
 
 cleanup:
 
@@ -2594,6 +2600,7 @@ static bool handle_get_networks_command(LSHandle *sh, LSMessage *message,
 	bool subscribed = false;
 	LSError lserror;
 	LSErrorInit(&lserror);
+	jschema_ref response_schema  = NULL;
 
 	replyObj = jobject_create();
 
@@ -2629,7 +2636,7 @@ static bool handle_get_networks_command(LSHandle *sh, LSMessage *message,
 
 	populate_wifi_networks(&replyObj, TRUE);
 
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
 	                              DOMOPT_NOOPT, NULL);
 
 	if (!response_schema)
@@ -2866,8 +2873,11 @@ static bool handle_get_status_command(LSHandle *sh, LSMessage *message,
 
 	create_wifi_getstatus_response(&reply, subscribed);
 
-	LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()),
-	                    &lserror);
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, jschema_all()),
+	                    &lserror))
+	{
+		goto cleanup;
+	}
 
 cleanup:
 
@@ -3313,6 +3323,8 @@ static bool handle_create_wpspin_command(LSHandle *sh, LSMessage *message,
 	LSError lserror;
 	LSErrorInit(&lserror);
 
+	jschema_ref response_schema = NULL;
+
 	gint wpspin = generate_new_wpspin();
 
 	if (wpspin < 0)
@@ -3326,7 +3338,7 @@ static bool handle_create_wpspin_command(LSHandle *sh, LSMessage *message,
 	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
 	jobject_put(reply, J_CSTR_TO_JVAL("wpspin"), jstring_create(wpspin_str));
 
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
 	                              DOMOPT_NOOPT, NULL);
 
 	if (!response_schema)
diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 4662222..7bf7ef3 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -175,6 +175,11 @@ static gboolean populate_wifi_profile(jvalue_ref profileObj)
 		jstring_free_buffer(enc_profile_buf);
 		gchar *dec_profile = wifi_setting_decrypt(enc_profile, WIFI_LUNA_PREFS_ID);
 
+		gchar *ssid = NULL;
+		GStrv security = NULL;
+		bool hidden = false;
+		bool configured = false;
+		JSchemaInfo schemaInfo;
 		jvalue_ref parsedObj = {0};
 		jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT,
 		                           NULL);
@@ -184,7 +189,6 @@ static gboolean populate_wifi_profile(jvalue_ref profileObj)
 			goto Exit;
 		}
 
-		JSchemaInfo schemaInfo;
 		jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
 		parsedObj = jdom_parse(j_cstr_to_buffer(dec_profile), DOMOPT_NOOPT,
 		                       &schemaInfo);
@@ -195,9 +199,6 @@ static gboolean populate_wifi_profile(jvalue_ref profileObj)
 			goto Exit;
 		}
 
-		gchar *ssid = NULL;
-		GStrv security = NULL;
-
 		if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
 		{
 			raw_buffer ssid_buf = jstring_get(ssidObj);
@@ -210,9 +211,6 @@ static gboolean populate_wifi_profile(jvalue_ref profileObj)
 			WCALOG_DEBUG("ssid object not found");
 		}
 
-		bool hidden = false;
-		bool configured = false;
-
 		if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("security"), &securityListObj))
 		{
 			ssize_t i, num_elems = jarray_size(securityListObj);
@@ -647,6 +645,8 @@ gboolean store_network_config(connection_settings_t *settings,
 	gchar *pathname = NULL, *config_group = NULL;
 	GKeyFile *keyfile = g_key_file_new();
 	gboolean ret = FALSE;
+	GStrv security_type = NULL;
+	wifi_profile_t *profile = NULL;
 
 	if (NULL == settings->ssid || NULL == security)
 	{
@@ -690,11 +690,11 @@ gboolean store_network_config(connection_settings_t *settings,
 		}
 	}
 
-	GStrv security_type = (GStrv) g_new0(GStrv, 2);
+	security_type = (GStrv) g_new0(GStrv, 2);
 	security_type[0] = g_strdup(security);
 	security_type[1] = NULL;
 
-	wifi_profile_t *profile = get_profile_by_ssid_security(settings->ssid,
+	profile = get_profile_by_ssid_security(settings->ssid,
 	                          security);
 
 	if (NULL != profile)
@@ -1228,7 +1228,7 @@ static gboolean inotify_data(GIOChannel *channel, GIOCondition cond,
 		next_event += len;
 		bytes_read -= len;
 
-		WCALOG_DEBUG("New event found for file %s, event mask : %lx", file,
+		WCALOG_DEBUG("New event found for file %s, event mask : %u", file,
 		             event->mask);
 
 		if (event->mask & IN_CREATE || event->mask & IN_MOVED_TO ||
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index d388f62..46b0474 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2014-2019 LG Electronics, Inc.
+// Copyright (c) 2014-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -874,6 +874,7 @@ static bool handle_get_station_count_command(LSHandle *sh, LSMessage *message, v
 	LSError lserror;
 	LSErrorInit(&lserror);
 	bool subscribed = false;
+	jschema_ref response_schema = NULL;
 
 	jvalue_ref parsedObj = {0};
 	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
@@ -902,7 +903,7 @@ static bool handle_get_station_count_command(LSHandle *sh, LSMessage *message, v
 
 	send_sta_count(&reply);
 
-	jschema_ref response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+	response_schema = jschema_parse (j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
 	if(!response_schema)
 	{
 		LSMessageReplyErrorUnknown(sh,message);

commit 4eaf1714bafa1b69ae562e54d2c4f2c22007f734
Merge: c991227 4a01308
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon Jan 13 14:21:44 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit f715773028e9bd2c3c69d9504d3c76f2710ca4f8
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Jan 16 18:01:21 2020 +0900

    Retire nyx dependency
    
    :Release Notes:
    Retire nyx dependency
    
    :Detailed Notes:
    This commit modifies webos-connman-adapter not to depends on
    nyx library to retrieve ethernet/wlan MAC address to improve
    the porting efficiency and reduce the size of footprint of
    headless image.
    
    :Testing Performed:
    Verified that com.webos.service.connectionmanager/getinfo works
    as expected.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-99356] Remove nyx dependency of webos-connman-adapter
    
    Change-Id: I256ee02518c87b3d44df8eb3c2a772d33b9f97d7

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 90988f1..27c7baa 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2019 LG Electronics, Inc.
+# Copyright (c) 2012-2020 LG Electronics, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -74,10 +74,6 @@ pkg_check_modules(WCA_SUPPORT_API REQUIRED wca-support-api>=0.1.0)
 include_directories(${WCA_SUPPORT_API_INCLUDE_DIRS})
 webos_add_compiler_flags(ALL ${WCA_SUPPORT_API_CFLAGS_OTHER})
 
-pkg_check_modules(NYXLIB REQUIRED nyx)
-include_directories(${NYXLIB_INCLUDE_DIRS})
-webos_add_compiler_flags(ALL ${NYXLIB_CFLAGS_OTHER})
-
 webos_add_compiler_flags(ALL -Wall -g)
 
 webos_add_linker_options(ALL --no-undefined)
@@ -128,7 +124,6 @@ file(GLOB SOURCE_FILES
     src/json_utils.c
     src/lunaservice_utils.c
     src/main.c
-    src/nyx.c
     src/pacrunner_client.c
     src/utils.c
     src/wifi_tethering_service.c
@@ -150,7 +145,6 @@ target_link_libraries(webos-connman-adapter
                         ${LUNAPREFS_LDFLAGS}
                         ${PMLOG_LDFLAGS}
                         ${WCA_SUPPORT_LDFLAGS}
-                        ${NYXLIB_LDFLAGS}
                         rt
                         pthread)
 
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 0c310fc..5af9a89 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -42,6 +42,10 @@ errorText | Yes | String | Error description
 #include <stdbool.h>
 #include <time.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <linux/if.h>
+
 #include <pbnjson.h>
 
 #include "common.h"
@@ -54,7 +58,6 @@ errorText | Yes | String | Error description
 #include "errors.h"
 #include "wifi_profile.h"
 #include "utils.h"
-#include "nyx.h"
 #include "pacrunner_client.h"
 #include "wifi_setting.h"
 
@@ -62,6 +65,9 @@ errorText | Yes | String | Error description
 #define COUNTER_PERIOD      1
 #define GETINFO_UPDATE_INTERVAL_SECONDS 1
 
+#define MAC_ADDR_LEN    6
+#define MAC_ADDR_STRING_LEN 32
+
 static LSHandle *pLsHandle;
 
 connman_counter_t *counter = NULL;
@@ -1590,6 +1596,52 @@ cleanup:
 
 }
 
+/**
+ * @brief Determine the mac address of the supplied network interface. mac_address must
+ * point to a valid buffer of a length of at least 18 bytes (set real length with
+ * mac_address_len). The format of the mac address string is "HH:HH:HH:HH:HH::HH\0" where
+ * "H" represents a hex digit.
+ *
+ * @param interface Interface name (e.g. "eth0" or "wlan0") of which the mac address
+ * should be determined.
+ * @param mac_address Result buffer in which the mac address is written.
+ * @param mac_address_len Length of the supplied result buffer
+ * @result 0 when the operation was successfull. -1 otherwise.
+ */
+
+int retrieve_mac_address(const char *interface, char *mac_address,
+                         unsigned int mac_address_len)
+{
+	struct ifreq ifr;
+	int s;
+	int ret = -1;
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+
+	if (s == -1)
+	{
+		return ret;
+	}
+
+	g_strlcpy(ifr.ifr_name, interface, IFNAMSIZ);
+
+	if (ioctl(s, SIOCGIFHWADDR, &ifr) == 0)
+	{
+		int i;
+
+		for (i = 0; i < MAC_ADDR_LEN; i++)
+			g_snprintf(&mac_address[i * 3], mac_address_len, "%02X%s",
+							(unsigned char) ifr.ifr_hwaddr.sa_data[i],
+							(i < (MAC_ADDR_LEN - 1)) ? ":" : "");
+
+		ret = 0;
+	}
+
+	close(s);
+
+	return ret;
+}
+
 static void getinfo_add_response(jvalue_ref* reply, bool subscribed)
 {
 	jobject_put(*reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
@@ -1646,7 +1698,7 @@ static void getinfo_update(void)
 	char wired_mac_address[MAC_ADDR_STRING_LEN]={0};
 	gsize i;
 
-	if (retrieve_wifi_mac_address(wifi_mac_address, MAC_ADDR_STRING_LEN))
+	if (retrieve_mac_address(CONNMAN_WIFI_INTERFACE_NAME, wifi_mac_address, MAC_ADDR_STRING_LEN) == 0)
 	{
 		if (g_strcmp0(getinfo_cur_wifi_mac_address, wifi_mac_address))
 		{
@@ -1668,7 +1720,7 @@ static void getinfo_update(void)
 		WCALOG_ERROR(MSGID_WIFI_MAC_ADDR_ERROR,0,"Error in fetching mac address for wifi interface");
 	}
 
-	if (retrieve_wired_mac_address(wired_mac_address, MAC_ADDR_STRING_LEN))
+	if (retrieve_mac_address(CONNMAN_WIRED_INTERFACE_NAME, wired_mac_address, MAC_ADDR_STRING_LEN) == 0)
 	{
 		if (g_strcmp0(getinfo_cur_wired_mac_address, wired_mac_address))
 		{
diff --git a/src/logging.h b/src/logging.h
index 5fea943..d089faa 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -219,12 +219,6 @@ extern PmLogContext gLogContext;
 #define MSGID_COUNTRY_CODE_INFO                         "COUNTRY_CODE_INFO"
 #define MSGID_COUNTRY_CODE_FAILED                       "COUNTRY_CODE_FAILED"
 
-/** nyx.c */
-#define MSGID_NYX_INIT_ERROR                            "NYX_INIT_ERROR"
-#define MSGID_NYX_DEVICE_OPEN_ERROR                     "NYX_DEVICE_OPEN_ERROR"
-#define MSGID_NYX_DEVICE_CLOSE_ERROR                    "NYX_DEVICE_CLOSE_ERROR"
-#define MSGID_NYX_DEINIT_ERROR                          "NYX_DEINIT_ERROR"
-
 /** json_utils.c **/
 #define MSGID_JSON_KEY_NULL                             "JSON_KEY_NULL"
 #define MSGID_JSON_DEST_NULL                            "JSON_DEST_NULL"
diff --git a/src/main.c b/src/main.c
index 71c9687..f0f872d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -30,14 +30,12 @@
 #include <stdlib.h>
 #include <luna-service2/lunaservice.h>
 #include <wca-support.h>
-#include <nyx/common/nyx_core.h>
 
 #include "connman_manager.h"
 #include "logging.h"
 #include "wifi_service.h"
 #include "wifi_setting.h"
 #include "connectionmanager_service.h"
-#include "nyx.h"
 
 static GMainLoop *mainloop = NULL;
 
@@ -69,13 +67,6 @@ main(int argc, char **argv)
 
 	WCALOG_DEBUG("Starting webos-connman-adapter");
 
-	if (!init_nyx())
-	{
-		WCALOG_ERROR(MSGID_WIFI_SRVC_REGISTER_FAIL, 0,
-		             "Error in initializing nyx");
-		return -1;
-	}
-
 	if (initialize_wifi_ls2_calls(mainloop, &wifi_handle) < 0)
 	{
 		WCALOG_ERROR(MSGID_WIFI_SRVC_REGISTER_FAIL, 0,
@@ -110,7 +101,5 @@ main(int argc, char **argv)
 
 	g_main_loop_unref(mainloop);
 
-	release_nyx();
-
 	return 0;
 }
diff --git a/src/nyx.c b/src/nyx.c
deleted file mode 100644
index c91e3c5..0000000
--- a/src/nyx.c
+++ /dev/null
@@ -1,91 +0,0 @@
-// Copyright (c) 2016-2020 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-#include <glib.h>
-#include <string.h>
-#include <nyx/nyx_module.h>
-#include <nyx/client/nyx_device_info.h>
-
-#include "nyx.h"
-#include "logging.h"
-
-static nyx_device_handle_t device_main = NULL;
-
-bool init_nyx()
-{
-	if (nyx_init() != NYX_ERROR_NONE)
-	{
-		WCALOG_ERROR(MSGID_NYX_INIT_ERROR, 0, "Error in nyx_init");
-		return false;
-	}
-
-	if (nyx_device_open(NYX_DEVICE_DEVICE_INFO, "Main", &device_main) != NYX_ERROR_NONE)
-	{
-		WCALOG_ERROR(MSGID_NYX_DEVICE_OPEN_ERROR, 0, "Error in nyx_device_open");
-		return false;
-	}
-
-	return true;
-}
-
-void release_nyx()
-{
-	if (device_main)
-	{
-		if (nyx_device_close(device_main) != NYX_ERROR_NONE)
-		{
-			WCALOG_ERROR(MSGID_NYX_DEVICE_CLOSE_ERROR, 0, "Error while closing nyx device");
-		}
-		device_main = 0;
-	}
-
-	if (nyx_deinit() != NYX_ERROR_NONE)
-	{
-		WCALOG_ERROR(MSGID_NYX_DEINIT_ERROR, 0, "Error in nyx_deinit");
-	}
-}
-
-static bool retrieve_nyx_data(nyx_device_info_type_t type, char* buffer, size_t buffer_size)
-{
-	nyx_error_t error;
-	const char* nyx_buffer = NULL;
-	gsize i;
-
-	error = nyx_device_info_query(device_main, type, &nyx_buffer);
-
-	if (error != NYX_ERROR_NONE)
-	{
-		return false;
-	}
-
-	i = g_strlcpy(buffer, nyx_buffer, buffer_size);
-	if (i != strlen(nyx_buffer))
-	{
-		WCALOG_ERROR(MSGID_NYX_INIT_ERROR, 0, "Error in nyx_init");
-		return false;
-	}
-	return true;
-}
-
-bool retrieve_wired_mac_address(char* buffer, size_t buffer_size)
-{
-	return retrieve_nyx_data(NYX_DEVICE_INFO_WIRED_ADDR, buffer, buffer_size);
-}
-
-bool retrieve_wifi_mac_address(char* buffer, size_t buffer_size)
-{
-	return retrieve_nyx_data(NYX_DEVICE_INFO_WIFI_ADDR, buffer, buffer_size);
-}
diff --git a/src/nyx.h b/src/nyx.h
deleted file mode 100644
index 8269cd1..0000000
--- a/src/nyx.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright (c) 2016-2018 LG Electronics, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// SPDX-License-Identifier: Apache-2.0
-
-#ifndef _NYX_H_
-#define _NYX_H_
-
-#include <stdbool.h>
-
-#define UNUSED(x) (void)(x)
-
-#define MAC_ADDR_STRING_LEN 32
-
-extern bool init_nyx();
-
-extern void release_nyx();
-
-extern bool retrieve_wired_mac_address(char* buffer, size_t buffer_size);
-
-extern bool retrieve_wifi_mac_address(char* buffer, size_t buffer_size);
-
-#endif /* _NYX_H_ */

commit a569e59ed7107c3254bc816cd858621b1456e7fa
Merge: 4eaf171 f715773
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Feb 13 09:05:16 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit d120941bd197888fbf71c35c6a24fdf8304b8aab
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Mar 5 16:08:34 2020 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis issues detected by coverity
    regarding "Calling Risky function".
    
    - CID-80565
    
    :Testing Performed:
    Only build is tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-101936] Fix "Calling Risky function" of webos-connman-adapter
    
    Change-Id: Ia89e918c8549c46abb4bb40b452f7a553ae738e6

diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 7bf7ef3..a12b607 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -890,11 +890,11 @@ gboolean change_network_dns(const char *ssid, const char *security,
 
 	for (i = 0; i < num_elems; i++)
 	{
-		dnsstr = strcat(dnsstr, dns[i]);
+		dnsstr = strncat(dnsstr, dns[i], strlen(dns[i]));
 
 		if (i < (num_elems - 1))
 		{
-			dnsstr = strcat(dnsstr, ",");
+			dnsstr = strncat(dnsstr, ",", strlen(","));
 		}
 	}
 

commit 8566c9bf097b7b40bb252f5d55ce338b645c726c
Merge: a569e59 d120941
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Sun Mar 8 14:36:52 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 7232cec85ed44213f2d4c0bee8b98be3f0177b23
Author: Sungho Shin <sungho1.shin@lge.com>
Date:   Thu Mar 5 13:05:07 2020 +0900

    Add support for Wi-Fi scan in Wi-Fi tethering status
    
    :Release Notes:
    Add support for Wi-Fi scan in Wi-Fi tethering status
    
    :Detailed Notes:
    This commit adds support for Wi-Fi scan in Wi-Fi tethering
    status
    
    :Testing Performed:
    - Build tested.
    - Tested /findnetworks works as expected.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-101600] Implement scan function in tethering status
    
    Change-Id: I55d3407f23dec8209da45cedb7e1247c3508c01c

diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index 3d1bb5c..30e98f3 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -156,6 +156,15 @@ gboolean wifi_scan_now(void)
 		regular_scan_pending = true;
 		result = true;
 	}
+	else if (is_wifi_tethering())
+	{
+		WCALOG_DEBUG("wifi_scan: Scanning wifi in tethering status");
+		system("iw dev wlan0 scan");
+		scan_running = false;
+		regular_scan_pending = false;
+		scan_time = g_get_monotonic_time() / 1000;
+		result = true;
+	}
 	else if (!wifi_tech)
 	{
 		return false;

commit 3d173fd55beec4306b546452e7e579f3fd28ef96
Author: Sungho Shin <sungho1.shin@lge.com>
Date:   Thu Mar 5 16:04:02 2020 +0900

    Add support for tethering/getMaxStationCount API
    
    :Release Notes:
    Add support for tethering/getMaxStationCount API
    
    :Detailed Notes:
    This commit adds com.webos.service.wifi/tethering/getMaxStationCount
    API which gets the maximum number of stations allowed to connect
    to the AP.
    
    :Testing Performed:
    - Build tested.
    - Tested /tethering/getMaxStationCount works as expected.
    - See PLAT-101919 for luna methods used in testing
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-101919] Implement com.webos.service.wifi/tethering/
                  getMaxStationCount
    
    Change-Id: I298bc19f3cea11f635317b96d25ab370296e9d44

diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index 9ff2c2b..e3a99e2 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -27,8 +27,9 @@
         "com.webos.service.wifi/scan",
         "com.webos.service.wifi/setstate",
         "com.webos.service.wifi/startwps",
-        "com.webos.service.wifi/tethering/setState",
+        "com.webos.service.wifi/tethering/getMaxStationCount",
         "com.webos.service.wifi/tethering/getState",
+        "com.webos.service.wifi/tethering/setState",
         "com.webos.service.wifi/tethering/getStationCount"
     ],
     "networking": [
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 46b0474..9e5b546 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -52,6 +52,37 @@ static guint wifi_tethering_client_count = 0;
 
 void start_tethering_timeout(void);
 
+static int get_max_station_count(void)
+{
+	int ret = -1;
+	FILE *fp = NULL;
+	char buff[1024];
+	size_t readSize = 0;
+	char *max_num_sta = NULL;
+
+	fp = popen("wpa_cli -i wlan0 get max_num_sta", "r");
+	if (NULL == fp)
+	{
+	   return ret;
+	}
+
+	readSize = fread((void*)buff, sizeof(char), 1024 - 1, fp);
+	if (0 == readSize)
+	{
+	   return ret;
+	}
+	buff[readSize]='0';
+
+	max_num_sta = g_strndup(buff, readSize);
+	ret = atoi(max_num_sta);
+
+	pclose(fp);
+	g_free(max_num_sta);
+
+	return ret;
+}
+
+
 static void support_tethering_disabled_cb(bool success, void *user_data)
 {
 	LSMessage *message = user_data;
@@ -929,6 +960,97 @@ cleanup:
 	return true;
 }
 
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_wifi com.webos.wifi/tethering/getMaxStationCount
+@{
+@page com_webos_service_wifi com.webos.service.wifi/tethering/getMaxStationCount
+@{
+@section com_webos_service_wifi_tethering_getMaxStationCount getMaxStationCount
+
+Get the maximum number of stations allowed to connect to the AP.
+
+@par Parameters
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+maxStationCount | Yes | Number | Number of stations allowed to connect to the AP.
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_get_max_station_count_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	int max_sta_count = get_max_station_count();
+	if (max_sta_count < 0)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("getMaxStationCount"), jnumber_create_i32(max_sta_count));
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
 /**
  * com.webos.service.wifi/tethering service Luna Method Table
  */
@@ -938,6 +1060,7 @@ static LSMethod wifi_tethering_methods[] =
 	{ LUNA_METHOD_TETHERING_SETSTATE,              handle_set_state_command },
 	{ LUNA_METHOD_TETHERING_GETSTATE,              handle_get_state_command },
 	{ LUNA_METHOD_TETHERING_GETSTACOUNT,           handle_get_station_count_command },
+	{ LUNA_METHOD_TETHERING_GETMAXSTACOUNT,        handle_get_max_station_count_command },
 	{},
 };
 
diff --git a/src/wifi_tethering_service.h b/src/wifi_tethering_service.h
index dd46347..e53eb3e 100644
--- a/src/wifi_tethering_service.h
+++ b/src/wifi_tethering_service.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2014-2019 LG Electronics, Inc.
+// Copyright (c) 2014-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -31,9 +31,10 @@
  * @{
  */
 
-#define LUNA_METHOD_TETHERING_SETSTATE       "setState"
-#define LUNA_METHOD_TETHERING_GETSTATE       "getState"
-#define LUNA_METHOD_TETHERING_GETSTACOUNT    "getStationCount"
+#define LUNA_METHOD_TETHERING_SETSTATE          "setState"
+#define LUNA_METHOD_TETHERING_GETSTATE          "getState"
+#define LUNA_METHOD_TETHERING_GETSTACOUNT       "getStationCount"
+#define LUNA_METHOD_TETHERING_GETMAXSTACOUNT    "getMaxStationCount"
 
 extern void send_tethering_state_to_subscribers(void);
 extern void send_sta_count_to_subscribers(void);

commit 8c4bb9631f007c37c39951eb6263b6410df486f1
Author: Sungho Shin <sungho1.shin@lge.com>
Date:   Fri Mar 6 11:25:38 2020 +0900

    Add support for tethering/setMaxStationCount API
    
    :Release Notes:
    Add support for tethering/getMaxStationCount API
    
    :Detailed Notes:
    This commit adds com.webos.service.wifi/tethering/setMaxStationCount
    API which sets the maximum number of stations allowed to connect
    to the AP.
    
    :Testing Performed:
    - Build tested.
    - Tested /tethering/getMaxStationCount works as expected.
    - See PLAT-101919 for luna methods used in testing
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-101920] Implement com.webos.service.wifi/tethering/
                  setMaxStationCount
    
    Change-Id: Ibf82f8752fda537c70775b69d3e4507bee17b31b

diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index e3a99e2..21c994a 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -29,8 +29,9 @@
         "com.webos.service.wifi/startwps",
         "com.webos.service.wifi/tethering/getMaxStationCount",
         "com.webos.service.wifi/tethering/getState",
-        "com.webos.service.wifi/tethering/setState",
-        "com.webos.service.wifi/tethering/getStationCount"
+        "com.webos.service.wifi/tethering/getStationCount",
+        "com.webos.service.wifi/tethering/setMaxStationCount",
+        "com.webos.service.wifi/tethering/setState"
     ],
     "networking": [
         "com.webos.service.connectionmanager/checkinternetstatus",
diff --git a/src/errors.h b/src/errors.h
index 555d7e7..b382b52 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -111,5 +111,8 @@
 #define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_CHANNEL 208
 #define WCA_API_ERROR_WIFI_SET_COUNTRY_CODE_FAILED 209
 #define WCA_API_ERROR_TETHERING_IP_ADDRESS_FAILED         148
+#define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_MAX_STATION_COUNT 210
+#define WCA_API_ERROR_TETHERING_SET_MAX_STATION_COUNT_FAILED 211
+
 
 #endif /* ERRORS_H_ */
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 9e5b546..e4add7b 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -82,6 +82,19 @@ static int get_max_station_count(void)
 	return ret;
 }
 
+static bool set_max_station_count(gint count)
+{
+	char *command = NULL;
+
+	if (count <= 0 || count > 254)
+		return false;
+
+	command	= g_strdup_printf("%s %d","wpa_cli -i wlan0 set max_num_sta" , count);
+	(void)system(command);
+	(void)system("wpa_cli -i wlan0 save_config");
+
+	return true;
+}
 
 static void support_tethering_disabled_cb(bool success, void *user_data)
 {
@@ -1051,6 +1064,100 @@ cleanup:
 	return true;
 }
 
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            Start of API documentation comment block         //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+/**
+@page com_webos_service_wifi com.webos.service.wifi/tethering/setMaxStationCount
+@{
+@section com_webos_service_wifi_tethering_setMaxStationCount setMaxStationCount
+
+Set the maximum number of stations allowed to connect to the AP.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+maxStationCount | Yes | Number | Number of stations allowed to connect to the AP.
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True, if call was successful. False otherwise.
+errorText | No | String | Error text when call was not successful.
+errorCode | No | Integer | Error code when call was not successful.
+
+@par Returns(Subscription)
+Not applicable.
+
+@}
+*/
+/////////////////////////////////////////////////////////////////
+//                                                             //
+//            End of API documentation comment block           //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+
+static bool handle_set_max_station_count_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref parsedObj = {0};
+	jvalue_ref maxStationCountObj = NULL;
+	gint maxStationCount = 0;
+
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(maxStationCount, number)) REQUIRED_1(maxStationCount))),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	if (is_wifi_tethering())
+	{
+		LSMessageReplyCustomError(sh, message,
+		                          "Not allowed to change the maximum number of stations allowed to connect to the AP while tethering is enabled",
+								  WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_MAX_STATION_COUNT);
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("maxStationCount"), &maxStationCountObj))
+	{
+		jnumber_get_i32(maxStationCountObj, &maxStationCount);
+
+		if (maxStationCount <= 0 || maxStationCount > 254)
+		{
+			LSMessageReplyErrorInvalidParams(sh, message);
+			goto cleanup;
+		}
+	}
+
+	if (!set_max_station_count(maxStationCount))
+	{
+		LSMessageReplyCustomError(sh, message,
+		                          "Error in setting Max Station Count",
+								  WCA_API_ERROR_TETHERING_SET_MAX_STATION_COUNT_FAILED);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
 /**
  * com.webos.service.wifi/tethering service Luna Method Table
  */
@@ -1061,6 +1168,7 @@ static LSMethod wifi_tethering_methods[] =
 	{ LUNA_METHOD_TETHERING_GETSTATE,              handle_get_state_command },
 	{ LUNA_METHOD_TETHERING_GETSTACOUNT,           handle_get_station_count_command },
 	{ LUNA_METHOD_TETHERING_GETMAXSTACOUNT,        handle_get_max_station_count_command },
+	{ LUNA_METHOD_TETHERING_SETMAXSTACOUNT,        handle_set_max_station_count_command },
 	{},
 };
 
diff --git a/src/wifi_tethering_service.h b/src/wifi_tethering_service.h
index e53eb3e..ee0fe16 100644
--- a/src/wifi_tethering_service.h
+++ b/src/wifi_tethering_service.h
@@ -35,6 +35,7 @@
 #define LUNA_METHOD_TETHERING_GETSTATE          "getState"
 #define LUNA_METHOD_TETHERING_GETSTACOUNT       "getStationCount"
 #define LUNA_METHOD_TETHERING_GETMAXSTACOUNT    "getMaxStationCount"
+#define LUNA_METHOD_TETHERING_SETMAXSTACOUNT    "setMaxStationCount"
 
 extern void send_tethering_state_to_subscribers(void);
 extern void send_sta_count_to_subscribers(void);

commit ddf1ecc31a792cd1f2c0d98ca89b8461138bfeff
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed Mar 11 13:32:37 2020 +0900

    Add missing API in permission group
    
    :Release Notes:
    Add missing API in permission group
    
    :Detailed Notes:
    Below API is missed in the permission group.
    
    - com.webos.service.wifi/getCountryCode
    - com.webos.service.wifi/setCountryCode
    
    Also, copyright of wifi_scan.c is updated.
    
    :Testing Performed:
    - Build tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102284] Add missing API in the permission group of
                  webos-connman-adapter
    
    Change-Id: I18eb890b82f3f8e446bc25aabb8e550ba68de7e8

diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index 21c994a..ce801ed 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -20,11 +20,13 @@
         "com.webos.service.wifi/createwpspin",
         "com.webos.service.wifi/deleteprofile",
         "com.webos.service.wifi/findnetworks",
+        "com.webos.service.wifi/getCountryCode",
         "com.webos.service.wifi/getNetworks",
         "com.webos.service.wifi/getprofile",
         "com.webos.service.wifi/getprofilelist",
         "com.webos.service.wifi/getstatus",
         "com.webos.service.wifi/scan",
+        "com.webos.service.wifi/setCountryCode",
         "com.webos.service.wifi/setstate",
         "com.webos.service.wifi/startwps",
         "com.webos.service.wifi/tethering/getMaxStationCount",
diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index 30e98f3..bebaf3f 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2015-2018 LG Electronics, Inc.
+// Copyright (c) 2015-2020 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.

commit 3a867838824666e5fe98fa60f797985e438827de
Merge: 8566c9b ddf1ecc
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed Mar 11 13:45:15 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit c17230419c4d5584e2f18b9461a77b90bf6f4f67
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Fri Mar 13 09:30:49 2020 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis issues detected by coverity
    regarding below defects.
    
    - CID-238371 Unchecked return value
    - CID-6433302 Unchecked return value
    - CID-77148 Branch past initialization
    - CID-39129 Branch past initialization
    - CID-39139 Branch past initialization
    
    :Testing Performed:
    Only build is tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102533] Fix static analysis (Branch past initialization
                  & Unchecked return value)
    
    Change-Id: Ie8d8ea1763482b51fc1323c2982d5a568766380d

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 5af9a89..edb4528 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1615,6 +1615,7 @@ int retrieve_mac_address(const char *interface, char *mac_address,
 	struct ifreq ifr;
 	int s;
 	int ret = -1;
+	gsize = i;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 
@@ -1623,7 +1624,11 @@ int retrieve_mac_address(const char *interface, char *mac_address,
 		return ret;
 	}
 
-	g_strlcpy(ifr.ifr_name, interface, IFNAMSIZ);
+	i = g_strlcpy(ifr.ifr_name, interface, IFNAMSIZ);
+	if (i != strlen(interface))
+	{
+		WCALOG_ERROR(MSGID_WIRED_MAC_ADDR_ERROR,0,"Failed to copy interface name for wired interface");
+	}
 
 	if (ioctl(s, SIOCGIFHWADDR, &ifr) == 0)
 	{
@@ -2402,6 +2407,8 @@ cleanup:
 static bool handle_set_proxy_command(LSHandle *sh,
         LSMessage *message, void *context)
 {
+	connman_service_t *service = NULL;
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;
@@ -2477,7 +2484,7 @@ static bool handle_set_proxy_command(LSHandle *sh,
 			goto invalid_params;
 	}
 
-	connman_service_t *service = retrieve_service_by_ssid(ssid);
+	service = retrieve_service_by_ssid(ssid);
 
 	if (NULL != service)
 	{
diff --git a/src/connman_service.c b/src/connman_service.c
index c9e2b26..7bbd00c 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1394,7 +1394,11 @@ void connman_service_update_properties(connman_service_t *service,
 			service->ssid_len = g_variant_get_size(val);
 			g_free(service->ssid);
 			service->ssid = g_new(gchar, service->ssid_len + 1);
-			g_strlcpy(service->ssid, data, service->ssid_len + 1);
+			i = g_strlcpy(service->ssid, data, service->ssid_len + 1);
+			if (i != strlen(data))
+			{
+				WCALOG_ERROR(MSGID_MANAGER_FIELDS_ERROR, 0, "Failed to copy ssid info.");
+			}
 
 			connman_service_update_display_name(service);
 		}
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 9b5f41a..3454d96 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -3189,6 +3189,8 @@ Not applicable.
 static bool handle_delete_profile_command(LSHandle *sh, LSMessage *message,
         void *context)
 {
+	wifi_profile_t *profile = NULL;
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;
@@ -3219,12 +3221,11 @@ static bool handle_delete_profile_command(LSHandle *sh, LSMessage *message,
 	}
 	else
 	{
-
 		LSMessageReplyErrorInvalidParams(sh, message);
 		goto cleanup;
 	}
 
-	wifi_profile_t *profile = get_profile_by_id(profile_id);
+	profile = get_profile_by_id(profile_id);
 
 	if (NULL == profile)
 	{
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index e4add7b..aa250f6 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -856,6 +856,7 @@ static bool handle_get_state_command(LSHandle *sh, LSMessage *message,
 	LSError lserror;
 	LSErrorInit(&lserror);
 	bool subscribed = false;
+	jschema_ref response_schema  = NULL;
 
 	if (LSMessageIsSubscription(message))
 	{
@@ -881,7 +882,7 @@ static bool handle_get_state_command(LSHandle *sh, LSMessage *message,
 
 	send_tethering_state(&reply);
 
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
 	                              DOMOPT_NOOPT, NULL);
 
 	if (!response_schema)

commit ed010974572533d1ccc94f69293b5be6b5dd68fb
Merge: 3a86783 c172304
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Fri Mar 13 11:21:34 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 3b249c6fd250388619ee48a79ee65627a9688d7c
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Fri Mar 13 12:50:36 2020 +0900

    Fix compile error during fixing static analysis
    
    :Release Notes:
    Fix compile error during fixing static analysis
    
    :Detailed Notes:
    This commit fixes compile error during fixing static analysis.
    
    :Testing Performed:
    Only build is tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102533] Fix static analysis (Branch past initialization
                  & Unchecked return value)
    
    Change-Id: I19032b31d0096b40d55054e0d434aed7692f7282

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index edb4528..224c8d8 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1615,7 +1615,7 @@ int retrieve_mac_address(const char *interface, char *mac_address,
 	struct ifreq ifr;
 	int s;
 	int ret = -1;
-	gsize = i;
+	gsize i;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 

commit 8d9615fe1493dcfa0b26b66466f9aea0922bb942
Merge: ed01097 3b249c6
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Fri Mar 13 12:53:43 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 6327cc246e7b90d2b2de8b6237a8079672430fdd
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Mar 17 00:37:20 2020 +0900

    Fix second Wi-Fi connection failure
    
    :Release Notes:
    Fix second Wi-Fi connection failure
    
    :Detailed Notes:
    This commit fixes Wi-Fi connection failure when Wi-Fi connection
    is already established. Further investigation is needed why
    agent operation fails when Wi-Fi connection already exits.
    
    :Testing Performed:
    QWA-1682 is passed.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102750] [Auto]: Second time wifi is not connecting.
    
    Change-Id: I40cffcb0761bdc611e94bdf1dde4cd26071b0901

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 3454d96..2515dfc 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -849,7 +849,8 @@ static void service_property_changed_callback(gpointer data,
 
 #endif
 		/* Unset agent callback as we no longer have any valid input for connman available */
-		connman_agent_set_request_input_callback(agent, NULL, NULL);
+		// PLAT-102750 [Auto]: Second time wifi is not connecting.
+		//connman_agent_set_request_input_callback(agent, NULL, NULL);
 	}
 	else if (!g_strcmp0(property, "Online"))
 	{

commit ea89ef10308960eb3e506e823f87fcf0dd73653e
Merge: 8d9615f 6327cc2
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Mar 17 00:47:20 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 7fbb68f200edd0d5647e09a5391f9392f00fb735
Author: Sungho Shin <sungho1.shin@lge.com>
Date:   Wed Mar 18 14:11:55 2020 +0900

    Remove connected Wi-Fi service before Wi-Fi connection
    
    :Release Notes:
    Remove connected Wi-Fi service before Wi-Fi connection
    
    :Detailed Notes:
    This commit added to remove connected Wi-Fi service before
    Wi-Fi connection.
    
    :Testing Performed:
    QWA-1682 is passed.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102987] Remove connected Wi-Fi service before new Wi-Fi
                  connection
    
    Change-Id: I3f3f70b922b1b1ca9d7cee4eca1ca0064926d836

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 2515dfc..f56c02f 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -96,6 +96,26 @@ typedef struct profile_info
 } profile_info_t;
 
 static gboolean check_wifi_services_for_updates(void);
+static void remove_service_or_all_other(const gchar *ssid, gboolean others);
+
+static void remove_connected_service()
+{
+	WCALOG_DEBUG("Remove connected_service");
+
+	wifi_profile_t *current_connected_profile = NULL;
+	connman_service_t *connected_service = NULL;
+	connected_service = connman_manager_get_connected_service(manager->wifi_services);
+
+	if (!connected_service)
+		return;
+
+	current_connected_profile = get_profile_by_ssid_security(connected_service->name, connected_service->security[0]);
+
+	if (!current_connected_profile)
+		return;
+
+	connman_service_disconnect(connected_service);
+}
 
 connection_settings_t *connection_settings_new(void)
 {
@@ -2334,6 +2354,8 @@ static bool handle_connect_command(LSHandle *sh, LSMessage *message,
 
 	service_req = luna_service_request_new(sh, message);
 
+	remove_connected_service();
+
 	connect_wifi_with_ssid(ssid, profile, parsedObj, service_req);
 
 	g_free(ssid);

commit daf00470162b726e1744e69e1392fa53499f124a
Merge: ea89ef1 7fbb68f
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed Mar 18 16:04:02 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 9b2b5e9b11168296516d8b13b428e59e3a9d06d9
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon Mar 23 09:51:23 2020 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis issues detected by coverity
    regarding below defects.
    
    - CID-8479535 Resource leak
    - CID-77148 Branch past initialization
    - CID-39129 Branch past initialization
    - CID-39139 Branch past initialization
    
    :Testing Performed:
    Only build is tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102533] Fix static analysis (Branch past initialization
                  & Unchecked return value & Resource leak)
    
    Change-Id: I36400b1e3669d1f2c1a6721017967ae1a36c9c75

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 224c8d8..458fc71 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -989,6 +989,8 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
+	connman_service_t *service = NULL;
+
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
 	if (!LSMessageValidateSchema(sh, message,
@@ -1055,7 +1057,7 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 		jstring_free_buffer(ssid_buf);
 	}
 
-	connman_service_t *service = retrieve_service_by_ssid(ssid);
+	service = retrieve_service_by_ssid(ssid);
 
 	if (NULL != service)
 	{
diff --git a/src/wifi_service.c b/src/wifi_service.c
index f56c02f..2170c56 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -557,6 +557,7 @@ static gboolean handle_failed_connection_request(gpointer user_data)
 {
 	const char *error_message = "Unknown error";
 	unsigned int error_code = WCA_API_ERROR_UNKNOWN;
+	GVariant *properties = NULL;
 
 	if (NULL == manager)
 	{
@@ -604,7 +605,7 @@ static gboolean handle_failed_connection_request(gpointer user_data)
 		goto cleanup;
 	}
 
-	GVariant *properties = connman_service_fetch_properties(service);
+	properties = connman_service_fetch_properties(service);
 
 	if (NULL == properties)
 	{
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index aa250f6..5f1006a 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -69,7 +69,8 @@ static int get_max_station_count(void)
 	readSize = fread((void*)buff, sizeof(char), 1024 - 1, fp);
 	if (0 == readSize)
 	{
-	   return ret;
+		pclose(fp);
+		return ret;
 	}
 	buff[readSize]='0';
 
@@ -1024,6 +1025,7 @@ static bool handle_get_max_station_count_command(LSHandle *sh, LSMessage *messag
 	}
 
 	jvalue_ref reply = jobject_create();
+	jschema_ref response_schema = NULL;
 	LSError lserror;
 	LSErrorInit(&lserror);
 
@@ -1036,7 +1038,7 @@ static bool handle_get_max_station_count_command(LSHandle *sh, LSMessage *messag
 
 	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
 	jobject_put(reply, J_CSTR_TO_JVAL("getMaxStationCount"), jnumber_create_i32(max_sta_count));
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
 
 	if (!response_schema)
 	{

commit 6102df8f7f9c75f04f5f30d3dda00ebe1ffe5a40
Merge: daf0047 9b2b5e9
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon Mar 23 11:05:21 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 8978b93d7788781de10b6c8b2ecafdf5e014aeed
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Mar 24 12:01:06 2020 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis issues detected by coverity
    regarding below defects.
    
    - CID-39139 Branch past initialization
    
    :Testing Performed:
    Only build is tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-103424] Fix static analysis (Branch past initialization)
    
    Change-Id: Iad29a1c7849b3b30218d17a0d7d4d48045b55bc3

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 2170c56..639bff5 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -558,6 +558,8 @@ static gboolean handle_failed_connection_request(gpointer user_data)
 	const char *error_message = "Unknown error";
 	unsigned int error_code = WCA_API_ERROR_UNKNOWN;
 	GVariant *properties = NULL;
+	connman_service_t *service = NULL;
+	connection_settings_t *settings = NULL;
 
 	if (NULL == manager)
 	{
@@ -576,8 +578,8 @@ static gboolean handle_failed_connection_request(gpointer user_data)
 		goto cleanup;
 	}
 
-	connman_service_t *service = service_data->service;
-	connection_settings_t *settings = service_data->settings;
+	service = service_data->service;
+	settings = service_data->settings;
 
 	if (NULL == service || NULL == g_slist_find(manager->wifi_services, service))
 	{
@@ -751,6 +753,7 @@ static void service_property_changed_callback(gpointer data,
 	if (!g_strcmp0(property, "State"))
 	{
 		connman_service_t *service = (connman_service_t *)data;
+		wifi_profile_t *profile = NULL;
 
 		if (NULL == service)
 		{
@@ -819,8 +822,6 @@ static void service_property_changed_callback(gpointer data,
 			return;
 		}
 
-		wifi_profile_t *profile = NULL;
-
 		if (service->security != NULL)
 		{
 			profile = get_profile_by_ssid_security(service->name, service->security[0]);

commit 6519d59f4a432c257ab645316ca1caee535bf37d
Merge: 6102df8 8978b93
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Mar 24 12:08:54 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 7d14251fdedd47d960706ef7538be255bee827ee
Author: jonghen.han <jonghen.han@lge.com>
Date:   Mon Mar 23 15:17:44 2020 +0900

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis issues detected by coverity
    CID-7126748 Function declared implicity
    CID-7126299 Persistent side effect
    CID-7124114 Function declared implicity
    CID-7126285 Standard Libraries
    CID-7123837 Persistent side effect
    CID-7050357 Using uninitialized value
    
    :Testing Performed:
    Only build is tested.
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-103500] Fix static analysis (Function declared implicity &
                  Persistent side effect & Standard Libraries
                  & Using uninitialized value)
    
    Change-Id: Icfb7dbb891021606b12037a5d1fff5d88fe8eedc

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 458fc71..bea4222 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -60,6 +60,7 @@ errorText | Yes | String | Error description
 #include "utils.h"
 #include "pacrunner_client.h"
 #include "wifi_setting.h"
+#include "wifi_tethering_service.h"
 
 #define COUNTER_ACCURACY    10
 #define COUNTER_PERIOD      1
@@ -81,7 +82,7 @@ gboolean wired_connected = FALSE;
 gboolean wifi_connected = FALSE;
 gboolean p2p_connected = FALSE;
 guint block_getstatus_response = 0;
-gboolean old_wifi_tethering = FALSE;
+gboolean wifi_tethering = FALSE;
 gboolean wired_plugged = FALSE;
 
 char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
@@ -560,9 +561,11 @@ static gboolean check_update_is_needed(void)
 		return FALSE;
 	}
 
-	if (old_wifi_tethering != is_wifi_tethering())
+	gboolean old_wifi_tethering = wifi_tethering;
+
+	wifi_tethering = is_wifi_tethering();
+	if (old_wifi_tethering != wifi_tethering)
 	{
-		old_wifi_tethering = is_wifi_tethering();
 		needed = TRUE;
 	}
 
@@ -638,7 +641,7 @@ void connectionmanager_send_status_to_subscribers(void)
 	if (manager == NULL)
 		return;
 
-	if (block_getstatus_response || !check_update_is_needed())
+	if (block_getstatus_response > 0 || !check_update_is_needed())
 	{
 		// Retrieve the connected service for wired to check the online checking status
 		connman_service_t *connected_wired_service =
@@ -1075,7 +1078,6 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 		if (ssid)
 		{
 			wifi_profile_t *profile = get_profile_by_ssid(ssid);
-
 			if (profile && profile->configured)
 			{
 				if (!g_strcmp0(ipv4.method, "manual"))
@@ -1377,7 +1379,6 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 		if (ssid)
 		{
 			wifi_profile_t *profile = get_profile_by_ssid(ssid);
-
 			if (profile && profile->configured)
 			{
 				if (change_network_dns(profile->ssid, profile->security[0], dns))
@@ -1508,7 +1509,7 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 		{
 			if (enable_offline && is_wifi_tethering())
 			{
-				set_wifi_tethering(!enable_offline);
+				set_wifi_tethering(!enable_offline, 0);
 			}
 
 			connman_manager_set_offlinemode(manager, enable_offline);
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 639bff5..70918cf 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1202,32 +1202,36 @@ GVariant *agent_request_input_callback(GVariant *fields, gpointer data)
 
 	while (g_variant_iter_next(&iter, "{sv}", &key, &value))
 	{
-		if (!strncmp(key, "Name", 10))
+		size_t len = strlen(key) - 1;
+		if (len > 0)
 		{
-			if (NULL != settings->ssid)
+			if (strncmp(key, "Name", len) == 0)
 			{
-				g_variant_builder_add(vabuilder, "{sv}", "Name",
-				                      g_variant_new("s", settings->ssid));
+				if (NULL != settings->ssid)
+				{
+					g_variant_builder_add(vabuilder, "{sv}", "Name",
+				                          g_variant_new("s", settings->ssid));
+				}
 			}
-		}
-		else if (!strncmp(key, "Passphrase", 10))
-		{
-			/* FIXME we're ignoring the other fields here as we're only connecting to
-			 * psk secured networks at the moment */
-			if (NULL != settings->passkey)
+			else if (strncmp(key, "Passphrase", len) == 0)
 			{
-				g_variant_builder_add(vabuilder, "{sv}", "Passphrase",
-				                      g_variant_new("s", settings->passkey));
+				/* FIXME we're ignoring the other fields here as we're only connecting to
+				* psk secured networks at the moment */
+				if (NULL != settings->passkey)
+				{
+					g_variant_builder_add(vabuilder, "{sv}", "Passphrase",
+				                          g_variant_new("s", settings->passkey));
+				}
 			}
-		}
-		else if (!strncmp(key, "WPS", 10))
-		{
-			if (settings->wpsmode)
+			else if (strncmp(key, "WPS", len) == 0)
 			{
-				if (settings->wpspin != NULL)
+				if (settings->wpsmode)
 				{
-					g_variant_builder_add(vabuilder, "{sv}", "WPS",
-					                      g_variant_new("s", settings->wpspin));
+					if (settings->wpspin != NULL)
+					{
+						g_variant_builder_add(vabuilder, "{sv}", "WPS",
+				                              g_variant_new("s", settings->wpspin));
+					}
 				}
 			}
 		}
diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index a12b607..84371c5 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -1174,7 +1174,7 @@ static gboolean inotify_data(GIOChannel *channel, GIOCondition cond,
 {
 	char buffer[256];
 	char *next_event;
-	gsize bytes_read;
+	gsize bytes_read = 0;
 	GIOStatus status;
 
 	if (cond & (G_IO_NVAL | G_IO_ERR | G_IO_HUP))
diff --git a/src/wifi_setting.h b/src/wifi_setting.h
index 4823f83..020b2ad 100644
--- a/src/wifi_setting.h
+++ b/src/wifi_setting.h
@@ -47,6 +47,7 @@ extern gboolean change_network_ipv4(const char *ssid, const char *security,
                                     const char *address, const char *netmask, const char *gateway);
 extern gboolean change_network_ipv6(const char *ssid, const char *security,
                                     const char *address, const char *prefixLen, const char *gateway);
+extern gboolean change_network_dns(const char *ssid, const char *security, const GStrv *dns);
 extern gboolean change_network_remove_entry(const char *ssid, const char *security, const char *key);
 extern void remove_config_inotify_watch(void);
 
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 5f1006a..799c859 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -235,7 +235,7 @@ gboolean set_wifi_tethering(bool state, LSMessage *message)
 
 	if (!is_wifi_powered() && state)
 	{
-		previous_wifi_legacy_powered = FALSE;
+		previous_wifi_legacy_powered = is_wifi_powered();
 
 		// we need to have WiFI powered otherwise we can't start tethering
 		connman_technology_set_powered(wifi_tech, TRUE, NULL);
@@ -246,7 +246,7 @@ gboolean set_wifi_tethering(bool state, LSMessage *message)
 	}
 	else if (is_wifi_powered() && state)
 	{
-		previous_wifi_legacy_powered = TRUE;
+		previous_wifi_legacy_powered = is_wifi_powered();
 	}
 
 	if (state)
diff --git a/src/wifi_tethering_service.h b/src/wifi_tethering_service.h
index ee0fe16..d96d98f 100644
--- a/src/wifi_tethering_service.h
+++ b/src/wifi_tethering_service.h
@@ -37,6 +37,7 @@
 #define LUNA_METHOD_TETHERING_GETMAXSTACOUNT    "getMaxStationCount"
 #define LUNA_METHOD_TETHERING_SETMAXSTACOUNT    "setMaxStationCount"
 
+extern gboolean set_wifi_tethering(bool state, LSMessage *message);
 extern void send_tethering_state_to_subscribers(void);
 extern void send_sta_count_to_subscribers(void);
 extern int initialize_wifi_tethering_ls2_calls(GMainLoop *mainloop,

commit f794de97f595c13bc9729ee1114a03f1b984f7d4
Merge: 6519d59 7d14251
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed Mar 25 15:54:52 2020 +0900

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I8f7dc0d75a4de1b9858e58662cb7e1aa7733f597

commit 7227431076f02c00dd716226052e9233dafb1ceb
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Mar 26 11:56:42 2020 +0900

    Fix static analysis (cont)
    
    :Release Notes:
    Fix static analysis (cont)
    
    :Detailed Notes:
    This commit fixes static analysis issues detected by coverity
    regarding below defects.
    
    - CID-39139 Branch past initialization
    
    :Testing Performed:
    Only build is tested
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-103424] Fix static analysis (Branch past initialization)
    
    Change-Id: Id2a5237478c5ab661c9ba43d13bdbb10488b6a21

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 70918cf..b82b830 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -3030,6 +3030,7 @@ static bool handle_get_profilelist_command(LSHandle *sh, LSMessage *message,
 	jvalue_ref reply = jobject_create();
 	LSError lserror;
 	LSErrorInit(&lserror);
+	jschema_ref response_schema  = NULL;
 
 	if (profile_list_is_empty())
 	{
@@ -3041,8 +3042,8 @@ static bool handle_get_profilelist_command(LSHandle *sh, LSMessage *message,
 	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
 	add_wifi_profile_list(&reply);
 
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
-	                              DOMOPT_NOOPT, NULL);
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                                  DOMOPT_NOOPT, NULL);
 
 	if (!response_schema)
 	{
@@ -3107,6 +3108,9 @@ Not applicable.
 static bool handle_get_profile_command(LSHandle *sh, LSMessage *message,
                                        void *context)
 {
+	jschema_ref response_schema  = NULL;
+	wifi_profile_t *profile = NULL;
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;
@@ -3142,7 +3146,7 @@ static bool handle_get_profile_command(LSHandle *sh, LSMessage *message,
 		goto cleanup;
 	}
 
-	wifi_profile_t *profile = get_profile_by_id(profile_id);
+	profile = get_profile_by_id(profile_id);
 
 	if (NULL == profile)
 	{
@@ -3156,7 +3160,7 @@ static bool handle_get_profile_command(LSHandle *sh, LSMessage *message,
 		add_wifi_profile(&reply, profile);
 	}
 
-	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
 	                              DOMOPT_NOOPT, NULL);
 
 	if (!response_schema)

commit 1516e3c994bce1c28e2faf1cb02466d2a6045e12
Merge: f794de9 7227431
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Thu Mar 26 13:56:39 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 20c03f57d99d40306477fb1af90b91bf68cc35b9
Author: Sungho Shin <sungho1.shin@lge.com>
Date:   Fri Mar 20 08:13:30 2020 +0900

    Add support for Wi-Fi scan options
    
    :Release Notes:
    Add support for Wi-Fi scan options
    
    :Detailed Notes:
    This commit added support for Wi-Fi scan options which are ssid and
    frequency that need to be scanned.
    
    :Testing Performed:
    - Build tested.
    - See PLAT-102941 for luna methods used in testing
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-102941] Implement Wi-Fi scan options
    
    Change-Id: I17793af9bf81d7a5ee978c1d9dbf922ef662a3bc

diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index bebaf3f..332441e 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -420,3 +420,64 @@ void wifi_scan_start(connman_technology_t* _wifi_tech)
 		scan_timeout_cb(NULL);
 	}
 }
+
+gboolean wifi_scan_now_with_option(const GStrv *ssid, const GStrv *freq)
+{
+	if (!wifi_tech)
+	{
+		return false;
+	}
+
+	gsize i;
+	gsize ssid_num = g_strv_length(ssid);
+	gsize freq_num = g_strv_length(freq);
+
+	gchar *ssidstr = g_strnfill(32 * (ssid_num + 1), 0);
+	gchar *freqstr = g_strnfill(5 * (ssid_num + 1), 0);
+
+	gchar *basestr = "iw dev wlan0 scan";
+	gchar *command = NULL;
+
+	for (i = 0; i < ssid_num; i++)
+	{
+		ssidstr = strncat(ssidstr, ssid[i], strlen(ssid[i]));
+
+		if (i < (ssid_num - 1))
+		{
+			ssidstr = strncat(ssidstr, " ", strlen(" "));
+		}
+	}
+
+	for (i = 0; i < freq_num; i++)
+	{
+		char *frequency = NULL;
+		frequency = g_strdup_printf("%d", freq[i]);
+
+		freqstr = strncat(freqstr, frequency, strlen(frequency));
+
+		if (i < (freq_num - 1))
+		{
+			freqstr = strncat(freqstr, " ", strlen(" "));
+		}
+
+		g_free(frequency);
+	}
+
+	if (ssid_num > 0 && freq_num > 0)
+	{
+		command = g_strdup_printf("%s -u ssid %s freq %s", basestr, ssidstr, freqstr);
+	}
+	else if (ssid_num > 0 && freq_num <= 0)
+	{
+		command = g_strdup_printf("%s ssid %s", basestr, ssidstr);
+	}
+	else if (ssid_num <= 0 && freq_num > 0)
+	{
+		command = g_strdup_printf("%s freq %s", basestr, freqstr);
+	}
+
+	WCALOG_DEBUG("wifi_scan: Scanning wifi with %s", command);
+	(void)system(command);
+
+	return true;
+}
diff --git a/src/wifi_scan.h b/src/wifi_scan.h
index 28927a3..d553b8a 100644
--- a/src/wifi_scan.h
+++ b/src/wifi_scan.h
@@ -78,3 +78,9 @@ void wifi_scan_start(connman_technology_t* _wifi_tech);
  */
 extern void wifi_scan_stop(void);
 
+/**
+ * Starts a fresh scan with options, or does nothing if scan already running.
+ * Returns success/error.
+ */
+extern gboolean wifi_scan_now_with_option(const GStrv *ssid, const GStrv *freq);
+
diff --git a/src/wifi_service.c b/src/wifi_service.c
index b82b830..e81c565 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2594,6 +2594,51 @@ cleanup:
 static bool handle_scan_command(LSHandle *sh, LSMessage *message,
                                 void *user_data)
 {
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(ARRAY(ssid, string),
+									ARRAY(frequency, number)))), &parsedObj))
+	{
+		return true;
+	}
+
+	GStrv ssid = NULL;
+	GStrv frequency = NULL;
+	jvalue_ref ssidObj = {0};
+	jvalue_ref frequencyObj = {0};
+	bool is_scan_option = false;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		int i, ssid_arrsize = jarray_size(ssidObj);
+		ssid = (GStrv) g_new0(GStrv, ssid_arrsize + 1);
+
+		for (i = 0; i < ssid_arrsize; i++)
+		{
+			raw_buffer ssid_buf = jstring_get(jarray_get(ssidObj, i));
+			ssid[i] = g_strdup(ssid_buf.m_str);
+			jstring_free_buffer(ssid_buf);
+		}
+
+		ssid[ssid_arrsize] = NULL;
+		is_scan_option = true;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("frequency"), &frequencyObj))
+	{
+		int i, frequency_arrsize = jarray_size(frequencyObj);
+		frequency = (GStrv) g_new0(GStrv, frequency_arrsize + 1);
+
+		for (i = 0; i < frequency_arrsize; i++)
+		{
+			int freq = 0;
+			jnumber_get_i32(jarray_get(frequencyObj, i), &freq);
+			frequency[i] = freq;
+		}
+
+		frequency[frequency_arrsize] = NULL;
+		is_scan_option = true;
+	}
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;
@@ -2611,14 +2656,29 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
-	if (!wifi_scan_now())
+	if (is_scan_option)
 	{
-		LSMessageReplyCustomError(sh, message, "Error in scanning network",
-		                          WCA_API_ERROR_SCANNING);
-		return true;
+		if (!wifi_scan_now_with_option(ssid, frequency))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in scanning network",
+												  WCA_API_ERROR_SCANNING);
+			return true;
+		}
+	}
+	else
+	{
+		if (!wifi_scan_now())
+		{
+			LSMessageReplyCustomError(sh, message, "Error in scanning network",
+									  WCA_API_ERROR_SCANNING);
+			return true;
+		}
 	}
 
 	LSMessageReplySuccess(sh, message);
+
+	j_release(&parsedObj);
+	g_strfreev(ssid);
 	return true;
 }
 

commit 5dc303bf33a6810d8b1a0dca935bee4af9d78d69
Merge: 1516e3c 20c03f5
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon May 18 23:26:49 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 9a715f1a688ec43069049ac27c47021a76084d54
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed May 27 21:01:54 2020 +0900

    Support selective compile for scan on softAP
    
    :Release Notes:
    Support selective compile for scan on softAP
    
    :Detailed Notes:
    This commit adds define statement to support selective
    compile for scan on softAP.
    
    :Testing Performed:
    Only build is tested
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-108955] Support selective compile for scan on softAP
    
    Change-Id: Iba7678ab2687573e59eb0b180e4f1cdcd13f9f8b

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 27c7baa..540b131 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -108,6 +108,10 @@ if (ENABLE_QUICK_WOL)
 webos_add_compiler_flags(ALL -DENABLE_QUICK_WOL)
 endif()
 
+if (ENABLE_SCAN_ON_SOFTAP)
+webos_add_compiler_flags(ALL -DENABLE_SCAN_ON_SOFTAP)
+endif()
+
 include_directories(src ${GDBUS_IF_DIR})
 webos_configure_header_files(src)
 
diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index 332441e..f22972c 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -156,6 +156,7 @@ gboolean wifi_scan_now(void)
 		regular_scan_pending = true;
 		result = true;
 	}
+#ifdef ENABLE_SCAN_ON_SOFTAP
 	else if (is_wifi_tethering())
 	{
 		WCALOG_DEBUG("wifi_scan: Scanning wifi in tethering status");
@@ -165,6 +166,7 @@ gboolean wifi_scan_now(void)
 		scan_time = g_get_monotonic_time() / 1000;
 		result = true;
 	}
+#endif
 	else if (!wifi_tech)
 	{
 		return false;

commit 0401c478de5002e1e18c1df9d4d979caa997cba8
Merge: 5dc303b 9a715f1
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Wed May 27 21:17:38 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit 28523309259a6c2e1e6ff11476a95c51e27fc1e8
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Fri May 29 11:47:01 2020 +0530

    Add OSS package information file
    
    :Release Notes:
    Add OSS package information file oss-pkg-info.yaml
    
    :Detailed Notes:
    Add OSS package information file
    
    :Testing Performed:
    Build successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-108954] [Connectivity] Create OSS package information files
                  for connection manager components in OSE
    
    Change-Id: I0320d87e6f62150f994d7b356f5e9aee8a96a8b9

diff --git a/oss-pkg-info.yaml b/oss-pkg-info.yaml
new file mode 100644
index 0000000..7bc9505
--- /dev/null
+++ b/oss-pkg-info.yaml
@@ -0,0 +1,4 @@
+Open Source Software Package:
+- name: webOSOSE-webos-connman-adapter
+  source: git://github.com/webosose/webos-connman-adapter
+  license: Apache-2.0

commit 1205a76a3ae19fdf93e854b86d6c78d0e666bbbc
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Fri May 29 11:47:01 2020 +0530

    Add OSS package information file
    
    :Release Notes:
    Add OSS package information file oss-pkg-info.yaml
    
    :Detailed Notes:
    Add OSS package information file
    
    :Testing Performed:
    Build successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-108954] [Connectivity] Create OSS package information files
                  for connection manager components in OSE
    
    Change-Id: I0320d87e6f62150f994d7b356f5e9aee8a96a8b9
    (cherry picked from commit 28523309259a6c2e1e6ff11476a95c51e27fc1e8)

diff --git a/oss-pkg-info.yaml b/oss-pkg-info.yaml
new file mode 100644
index 0000000..7bc9505
--- /dev/null
+++ b/oss-pkg-info.yaml
@@ -0,0 +1,4 @@
+Open Source Software Package:
+- name: webOSOSE-webos-connman-adapter
+  source: git://github.com/webosose/webos-connman-adapter
+  license: Apache-2.0

commit af6646b26092ddd96b3549c06ba2eae3f13aab29
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Mon Aug 10 23:45:07 2020 +0900

    Do not handle wifiDirect object
    
    :Release Notes:
    Do not handle wifiDirect object
    
    :Detailed Notes:
    Since Wi-Fi direct is not supported in webOS OSE, let us remove
    the wifiDirect object from the return of com.webos.service.
    connectionmanager/getStatus.
    
    :Testing Performed:
    Verified that wifiDirect object does not exist from the return
    of com.webos.service.connectionmanager/getStatus
    
    :QA Notes:
    
    :Issues Addressed:
    [PLAT-116017] [Auto] When method getStatus's returnValue
                  is true, name doesn't exist Return is displayed.
    
    Change-Id: Iddde073e0e6c9163cea4e29b4a5ae6c95ad407c7

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index bea4222..20d3b43 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -486,18 +486,6 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 		connected_p2p_service = connman_manager_get_connected_service(
 		                            manager->p2p_services);
 	}
-
-	if (NULL != connected_p2p_service)
-	{
-		append_p2p_connection_status(&connected_p2p_status, connected_p2p_service);
-		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), connected_p2p_status);
-		j_release(&disconnected_p2p_status);
-	}
-	else
-	{
-		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), disconnected_p2p_status);
-		j_release(&connected_p2p_status);
-	}
 }
 
 /**

commit e0f76ffdf714efaa703bbb0429bd9d21dcd199c3
Merge: 1205a76 af6646b
Author: sungmok.shin <sungmok.shin@lge.com>
Date:   Tue Aug 11 15:34:15 2020 +0900

    Merge remote-tracking branch 'origin/develop'

commit c4748e13e24ab742426cc09a32f202b3a2710732
Author: Vasu Kantubukta <vasu.kantubukta@lge.com>
Date:   Wed Oct 9 21:06:07 2019 +0530

    Modify API groups as per ACG guidelines
    
    :Release Notes:
    Modify API groups as per ACG guidelines based on functionality
    
    :Detailed Notes:
    Luna apis are modified according to different functionality
    such as query, management, devutility for each service by
    following three principles below.
    
    1) To maintain only 2 groups oem / dev for RP.
    2) To use nouns that represent functions.
    3) To integrate and simplify groups too finely divided.
    
    :Testing Performed:
    Build Successful, verified all luna apis
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-83664] webos-connman-adapter - revisit API groups as per
                 revised ACG guidelines
    [PLAT-96062] ACG Review for webos-connman-adapter
    
    Change-Id: I3a68ae63a0cb07730f435aef108a42af6cfd1294

diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index ce801ed..24cd7df 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -1,78 +1,42 @@
 {
-    "networking.internal": [
-        "com.webos.service.connectionmanager/checkinternetstatus",
+    "networkconnection.query": [
         "com.webos.service.connectionmanager/findProxyForURL",
         "com.webos.service.connectionmanager/getinfo",
         "com.webos.service.connectionmanager/getStatus",
-        "com.webos.service.connectionmanager/getstatus",
-        "com.webos.service.connectionmanager/getUserStatus",
-        "com.webos.service.connectionmanager/monitorActivity",
+        "com.webos.service.connectionmanager/getstatus"
+    ],
+    "networkconnection.management": [
         "com.webos.service.connectionmanager/setdns",
         "com.webos.service.connectionmanager/setipv4",
         "com.webos.service.connectionmanager/setipv6",
         "com.webos.service.connectionmanager/setProxy",
         "com.webos.service.connectionmanager/setstate",
         "com.webos.service.connectionmanager/setTechnologyState",
-        "com.webos.service.wifi/cancel",
-        "com.webos.service.wifi/cancelwps",
-        "com.webos.service.wifi/changeNetwork",
-        "com.webos.service.wifi/connect",
-        "com.webos.service.wifi/createwpspin",
-        "com.webos.service.wifi/deleteprofile",
+        "com.webos.service.connectionmanager/monitorActivity"
+    ],
+    "wifi.query": [
         "com.webos.service.wifi/findnetworks",
         "com.webos.service.wifi/getCountryCode",
         "com.webos.service.wifi/getNetworks",
         "com.webos.service.wifi/getprofile",
         "com.webos.service.wifi/getprofilelist",
         "com.webos.service.wifi/getstatus",
-        "com.webos.service.wifi/scan",
-        "com.webos.service.wifi/setCountryCode",
-        "com.webos.service.wifi/setstate",
-        "com.webos.service.wifi/startwps",
         "com.webos.service.wifi/tethering/getMaxStationCount",
         "com.webos.service.wifi/tethering/getState",
-        "com.webos.service.wifi/tethering/getStationCount",
-        "com.webos.service.wifi/tethering/setMaxStationCount",
-        "com.webos.service.wifi/tethering/setState"
+        "com.webos.service.wifi/tethering/getStationCount"
     ],
-    "networking": [
-        "com.webos.service.connectionmanager/checkinternetstatus",
-        "com.webos.service.connectionmanager/findProxyForURL",
-        "com.webos.service.connectionmanager/getinfo",
-        "com.webos.service.connectionmanager/getStatus",
-        "com.webos.service.connectionmanager/getstatus",
-        "com.webos.service.connectionmanager/getUserStatus",
-        "com.webos.service.connectionmanager/monitorActivity",
-        "com.webos.service.connectionmanager/setdns",
-        "com.webos.service.connectionmanager/setipv4",
-        "com.webos.service.connectionmanager/setipv6",
-        "com.webos.service.connectionmanager/setProxy",
-        "com.webos.service.connectionmanager/setstate",
-        "com.webos.service.connectionmanager/setTechnologyState",
+    "wifi.management": [
+        "com.webos.service.wifi/scan",
         "com.webos.service.wifi/cancel",
         "com.webos.service.wifi/cancelwps",
         "com.webos.service.wifi/changeNetwork",
         "com.webos.service.wifi/connect",
         "com.webos.service.wifi/createwpspin",
         "com.webos.service.wifi/deleteprofile",
-        "com.webos.service.wifi/findnetworks",
-        "com.webos.service.wifi/getNetworks",
-        "com.webos.service.wifi/getprofile",
-        "com.webos.service.wifi/getprofilelist",
-        "com.webos.service.wifi/getstatus",
-        "com.webos.service.wifi/scan",
         "com.webos.service.wifi/setstate",
-        "com.webos.service.wifi/startwps"
-    ],
-    "networking.query": [
-        "com.webos.service.connectionmanager/checkinternetstatus",
-        "com.webos.service.connectionmanager/findProxyForURL",
-        "com.webos.service.connectionmanager/getinfo",
-        "com.webos.service.connectionmanager/getStatus",
-        "com.webos.service.connectionmanager/getstatus",
-        "com.webos.service.connectionmanager/getUserStatus",
-        "com.webos.service.connectionmanager/getwolwowlstatus",
-        "com.webos.service.connectionmanager/monitorActivity",
-        "com.webos.service.wifi/getstatus"
+        "com.webos.service.wifi/startwps",
+        "com.webos.service.wifi/setCountryCode",
+        "com.webos.service.wifi/tethering/setState",
+        "com.webos.service.wifi/tethering/setMaxStationCount"
     ]
 }
diff --git a/files/sysbus/webos-connman-adapter.groups.json b/files/sysbus/webos-connman-adapter.groups.json
new file mode 100644
index 0000000..3b3c226
--- /dev/null
+++ b/files/sysbus/webos-connman-adapter.groups.json
@@ -0,0 +1,8 @@
+{
+    "allowedNames": ["com.webos.service.wifi", "com.webos.service.connectionmanager"],
+          "networkconnection.query": ["dev"],
+          "networkconnection.management": ["oem"],
+          "wifi.query": ["dev"],
+          "wifi.management": ["oem"]
+}
+
diff --git a/files/sysbus/webos-connman-adapter.perm.json b/files/sysbus/webos-connman-adapter.perm.json
index 19ee494..4d441b3 100644
--- a/files/sysbus/webos-connman-adapter.perm.json
+++ b/files/sysbus/webos-connman-adapter.perm.json
@@ -1,11 +1,11 @@
 {
     "com.webos.service.wifi": [
-        "settings",
+        "settings.read",
         "devices",
         "networking.internal"
     ],
     "com.webos.service.connectionmanager": [
-        "settings",
+        "settings.read",
         "devices",
         "networking.internal"
     ]
diff --git a/files/sysbus/webos-connman-adapter.role.json.in b/files/sysbus/webos-connman-adapter.role.json.in
index 6613e56..4d1cf9b 100644
--- a/files/sysbus/webos-connman-adapter.role.json.in
+++ b/files/sysbus/webos-connman-adapter.role.json.in
@@ -1,6 +1,7 @@
 {
     "exeName":"@WEBOS_INSTALL_SBINDIR@/webos-connman-adapter",
     "type":"regular",
+    "trustLevel": "oem",
     "allowedNames":["com.webos.service.wifi", "com.webos.service.connectionmanager"],
     "permissions": [
         {

commit 4790e42604286409253358ab45152226ee40dea7
Merge: e0f76ff c4748e1
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Tue Dec 15 10:33:27 2020 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I7489e0d20f79bc56a822e5e4c946fb24012f007e

commit c7f03e798a9b6bf69d4555783d3287a559bbac19
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Thu Dec 3 18:15:38 2020 +0530

    Modifying getinfo to support multiple wired interface
    
    :Release Notes:
    Modifying getinfo to support multiple wired interface
    
    :Detailed Notes:
    getinfo response will contain multiple available interfaces
    
    :Testing Performed:
    Built and Tested
    luna-send -i -f luna://com.webos.service.connectionmanager/getinfo
    '{"subscribe" : true}'
    {
        "subscribed": true,
        "returnValue": true,
        "wifiInfo": {
            "macAddress": "DC:A6:32:AF:7C:55"
        },
        "wiredInfo": {
            "macAddress": "DC:A6:32:AF:7C:53",
            "interface": [
                {
                    "name": "eth1",
                    "macAddress": "D0:37:45:1E:87:CB"
                },
                {
                    "name": "eth0",
                    "macAddress": "DC:A6:32:AF:7C:53"
                }
            ]
        }
    }
    {
        "subscribed": true,
        "returnValue": true,
        "wifiInfo": {
            "macAddress": "DC:A6:32:AF:7C:55"
        },
        "wiredInfo": {
            "macAddress": "DC:A6:32:AF:7C:53",
            "interface": [
                {
                    "name": "eth0",
                    "macAddress": "DC:A6:32:AF:7C:53"
                }
            ]
        }
    }
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [PLAT-123914] Implementation for handling multiple Wired interfaces
                  for getinfo API in webos-connman-adapter
    [PLAT-123912] Implement getStatus and getInfo API's as per approved
                  API changes and create test cases
    
    Change-Id: I3d141ee2ea61b39b222905c9ee59e1e792c35772

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 20d3b43..8923edb 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1654,12 +1654,35 @@ static void getinfo_add_response(jvalue_ref* reply, bool subscribed)
 
 	if (getinfo_cur_wired_mac_address[0])
 	{
+		GSList *iter;
+		connman_technology_t *technology = NULL;
+		jvalue_ref interface_obj = jarray_create(NULL);
+		for (iter = manager->technologies ; NULL != iter; iter = iter->next)
+		{
+			technology = (struct connman_technology *)(iter->data);
+			if (!g_strcmp0(technology->type, "ethernet"))
+			{
+				int n = 0;
+				for (n = 0; n < g_strv_length(technology->interfaces); n++)
+				{
+					char wired_mac_address[MAC_ADDR_STRING_LEN]={0};
+					if (retrieve_mac_address(technology->interfaces[n], wired_mac_address, MAC_ADDR_STRING_LEN) == 0)
+					{
+						jvalue_ref wired_info = jobject_create();
+						jobject_put(wired_info, J_CSTR_TO_JVAL("name"), jstring_create(technology->interfaces[n]));
+						jobject_put(wired_info, J_CSTR_TO_JVAL("macAddress"), jstring_create(wired_mac_address));
+						jarray_append(interface_obj, wired_info);
+					}
+				}
+				break;
+			}
+		}
 		jvalue_ref wired_info = jobject_create();
-		jobject_put(wired_info,
-		            J_CSTR_TO_JVAL("macAddress"),
-		            jstring_create(getinfo_cur_wired_mac_address));
+		jobject_put(wired_info, J_CSTR_TO_JVAL("macAddress"), jstring_create(getinfo_cur_wired_mac_address));
+		jobject_put(wired_info, J_CSTR_TO_JVAL("interface"), interface_obj);
 		jobject_put(*reply, J_CSTR_TO_JVAL("wiredInfo"), wired_info);
 	}
+
 }
 
 void send_getinfo_to_subscribers(void)
@@ -1967,6 +1990,10 @@ static void technology_property_changed_callback(gpointer data,
 		}
 		connectionmanager_send_status_to_subscribers();
 	}
+	else if (!g_strcmp0(property, "Interfaces"))
+	{
+		send_getinfo_to_subscribers();
+	}
 }
 
 static void increment_counter_statistics(connman_service_t *service,
diff --git a/src/connman_manager.c b/src/connman_manager.c
index 06ec085..6a2c448 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -200,7 +200,7 @@ static gboolean service_on_configured_iface(GVariant *service_v)
 					g_variant_unref(ifaceva);
 
 					if (!g_strcmp0(iface, CONNMAN_WIFI_INTERFACE_NAME) ||
-					        !g_strcmp0(iface, CONNMAN_WIRED_INTERFACE_NAME))
+					        g_str_has_prefix (iface, "eth"))
 					{
 						return TRUE;
 					}
diff --git a/src/connman_service.c b/src/connman_service.c
index 7bbd00c..143b8cf 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1373,7 +1373,6 @@ void connman_service_update_properties(connman_service_t *service,
 		GVariant *val_v = g_variant_get_child_value(property, 1);
 		GVariant *val = g_variant_get_variant(val_v);
 		const gchar *key = g_variant_get_string(key_v, NULL);
-
 		if (!g_strcmp0(key, "Name"))
 		{
 			char *name =  g_variant_dup_string(val, NULL);
@@ -1473,6 +1472,44 @@ void connman_service_update_properties(connman_service_t *service,
 			g_free(service->address);
 			service->address = g_variant_dup_string(val, NULL);
 		}
+		else if (!g_strcmp0(key, "Ethernet"))
+		{
+			GVariant *v = g_variant_get_child_value(property, 1);
+			GVariant *va = g_variant_get_child_value(v, 0);
+			gsize j;
+
+			for (j = 0; j < g_variant_n_children(va); j++)
+			{
+				GVariant *ethernet = g_variant_get_child_value(va, j);
+				GVariant *ekey_v = g_variant_get_child_value(ethernet, 0);
+				const gchar *ekey = g_variant_get_string(ekey_v, NULL);
+
+				if (!g_strcmp0(ekey, "Interface"))
+				{
+					GVariant *ifacev = g_variant_get_child_value(ethernet, 1);
+					GVariant *ifaceva = g_variant_get_variant(ifacev);
+					g_free(service->interface_name);
+					service->interface_name = g_variant_dup_string(ifaceva, NULL);
+					g_variant_unref(ifacev);
+					g_variant_unref(ifaceva);
+					WCALOG_DEBUG("Interface Name %s", service->interface_name);
+				}
+				else if (!g_strcmp0(ekey, "Address"))
+				{
+					GVariant *macv = g_variant_get_child_value(ethernet, 1);
+					GVariant *macva = g_variant_get_variant(macv);
+					g_free(service->macaddress);
+					service->macaddress = g_variant_dup_string(macva, NULL);
+					g_variant_unref(macv);
+					g_variant_unref(macva);
+					WCALOG_DEBUG("Interface Mac %s", service->macaddress);
+				}
+				g_variant_unref(ethernet);
+				g_variant_unref(ekey_v);
+			}
+			g_variant_unref(v);
+			g_variant_unref(va);
+		}
 		else if (!g_strcmp0(key, "BSS"))
 		{
 			if (service->bss != NULL)
@@ -1662,6 +1699,9 @@ void connman_service_free(gpointer data, gpointer user_data)
 	g_free(service->name);
 	service->name = NULL;
 
+	g_free(service->interface_name);
+	service->interface_name = NULL;
+
 	g_free(service->display_name);
 	service->display_name = NULL;
 
@@ -1674,6 +1714,9 @@ void connman_service_free(gpointer data, gpointer user_data)
 	g_free(service->address);
 	service->address = NULL;
 
+	g_free(service->macaddress);
+	service->macaddress = NULL;
+
 	g_strfreev(service->security);
 	service->security = NULL;
 
diff --git a/src/connman_service.h b/src/connman_service.h
index a72f992..19037db 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -122,10 +122,12 @@ typedef struct connman_service
 	gchar *path;
 	gchar *identifier;
 	gchar *name; /* Service name, can be null for hidden wifi networks */
+	gchar *interface_name; /* Interface name */
 	gchar *display_name; /* Service display name, can be null for hidden wifi networks */
 	gchar *state;
 	gchar *error;
 	gchar *address;
+	gchar *macaddress;
 
 	guchar strength;
 	GStrv security;
diff --git a/src/connman_technology.c b/src/connman_technology.c
index fd6073f..9b66898 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -632,6 +632,11 @@ static void set_property_value(connman_technology_t *technology,
 		g_free(technology->name);
 		technology->name = g_variant_dup_string(val, NULL);
 	}
+	else if (!g_strcmp0(key, "Interfaces"))
+	{
+		g_strfreev(technology->interfaces);
+		technology->interfaces = g_variant_dup_strv(val, NULL);
+	}
 	else if (!g_strcmp0(key, "Powered"))
 	{
 		technology->powered = g_variant_get_boolean(val);
@@ -1066,5 +1071,8 @@ void connman_technology_free(connman_technology_t *technology)
 
 	g_strfreev(technology->station_mac);
 
+	g_strfreev(technology->interfaces);
+	technology->interfaces = NULL;
+
 	g_free(technology);
 }
diff --git a/src/connman_technology.h b/src/connman_technology.h
index d6f9169..0f44037 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -48,6 +48,7 @@ typedef struct connman_technology
 	gchar *tethering_identifier;
 	gchar *tethering_passphrase;
 	gchar *tethering_ipaddress;
+	GStrv interfaces;
 	gboolean powered;
 	gboolean connected;
 	gboolean tethering;
diff --git a/src/wifi_service.c b/src/wifi_service.c
index e81c565..3ef1169 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2038,6 +2038,10 @@ static void technology_property_changed_callback(gpointer data,
 		{
 			connectionmanager_send_status_to_subscribers();
 		}
+		else if (!g_strcmp0(property, "Interfaces"))
+		{
+			send_getinfo_to_subscribers();
+		}
 	}
 }
 

commit 5a0dcf8b8b26e728b41539feebeaa8cb636a451e
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Mon Jan 4 19:10:58 2021 +0530

    Add ACG new group names in perm.json file
    
    :Release Notes:
    Add ACG new group names
    
    :Detailed Notes:
    Add ACG outbound new group in perm.json file
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-123921] Integration of ACG Changes for connectivity components
    
    Change-Id: I7d076df3d0fa18c7202fc6dbdf485138be875c2c

diff --git a/files/sysbus/webos-connman-adapter.perm.json b/files/sysbus/webos-connman-adapter.perm.json
index 4d441b3..370c7f1 100644
--- a/files/sysbus/webos-connman-adapter.perm.json
+++ b/files/sysbus/webos-connman-adapter.perm.json
@@ -1,12 +1,22 @@
 {
     "com.webos.service.wifi": [
-        "settings.read",
-        "devices",
-        "networking.internal"
+        "settings.query",
+        "networkconnection.query",
+        "networkconnection.management",
+        "wifi.query",
+        "wifi.management",
+        "configd.query",
+        "settings",
+        "devices"
     ],
     "com.webos.service.connectionmanager": [
-        "settings.read",
-        "devices",
-        "networking.internal"
+        "settings.query",
+        "networkconnection.query",
+        "networkconnection.management",
+        "wifi.query",
+        "wifi.management",
+        "configd.query",
+        "settings",
+        "devices"
     ]
 }

commit 86aea8fee149cb61baf9bbec9c3a361f359e2bf6
Merge: 4790e42 5a0dcf8
Author: Sameer Mulla <sameer.mulla@lge.com>
Date:   Wed Jan 13 11:57:26 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: Id20403f21b25a893ed9331e9b0503fdedd326cb1

commit a8e1954757e2a020ca22cd9433f584da08ba5124
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Tue Jan 19 12:32:44 2021 +0530

    Remove old ACG group names in perm.json file
    
    :Release Notes:
    Remove old ACG group names
    
    :Detailed Notes:
    Remove old ACG group names in perm.json file
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-132734] webos-connman-adapter.perm.json file not migrated
                  to enhanced ACG groups
    
    Change-Id: Ia46e13b511d647868e7c76a01a27b7c87b46098e

diff --git a/files/sysbus/webos-connman-adapter.perm.json b/files/sysbus/webos-connman-adapter.perm.json
index 370c7f1..2621a73 100644
--- a/files/sysbus/webos-connman-adapter.perm.json
+++ b/files/sysbus/webos-connman-adapter.perm.json
@@ -5,9 +5,7 @@
         "networkconnection.management",
         "wifi.query",
         "wifi.management",
-        "configd.query",
-        "settings",
-        "devices"
+        "systemconfig.query"
     ],
     "com.webos.service.connectionmanager": [
         "settings.query",
@@ -15,8 +13,6 @@
         "networkconnection.management",
         "wifi.query",
         "wifi.management",
-        "configd.query",
-        "settings",
-        "devices"
+        "systemconfig.query"
     ]
 }

commit 841edd41fcb8262cf69fe09af5ad56083e0e50c8
Merge: 86aea8f a8e1954
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Tue Jan 19 15:25:04 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I936594298d112bc2a7e947473a0e30611b4ba4cd

commit 195230e7033d951dc216cedf0e820eeaeac6f5f2
Merge: a8e1954 c7f03e7
Author: Rajesh Kanna <rajesh.kanna@lge.com>
Date:   Thu Jan 28 14:45:09 2021 +0900

    Merge "Modifying getinfo to support multiple wired interface" into develop

commit 95514c2542e02f7c2abc1a46a9248ce1034d0243
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Wed Dec 9 10:59:09 2020 +0530

    Modifying getStatus to support multiple wired interface
    
    :Release Notes:
    Modifying getStatus to support multiple wired interface
    
    :Detailed Notes:
    getStatus response will contain status of multiple available
    interfaces
    
    :Testing Performed:
    Built and Tested
    luna-send -i -f luna://com.webos.service.connectionmanager/getStatus
    '{"subscribe":true}'
    {
        "subscribed": true,
        "returnValue": true,
        "offlineMode": "disabled",
        "isInternetConnectionAvailable": true,
        "wired": {
            "method": "dhcp",
            "proxyinfo": {
                "url": "http://wpad.domain.name/wpad.dat",
                "method": "auto"
            },
            "interfaceName": "eth0",
            "plugged": true,
            "state": "connected",
            "netmask": "255.255.255.0",
            "dns2": "192.168.1.1",
            "ipAddress": "192.168.1.7",
            "dns1": "fe80::fac4:f3ff:fe0d:1a0",
            "ipv6": {
                "ipAddress": "2401:4900:1f24:5256:dea6:32ff:feaf:7c53",
                "method": "auto",
                "prefixLength": 64
            },
            "interface": [
                {
                    {
                        "interfaceName": "eth1",
                        "plugged": false,
                        "state": "disconnected"
                    }
                },
                {
                    {
                        "method": "dhcp",
                        "onInternet": "no",
                        "interfaceName": "eth0",
                        "proxyinfo": {
                            "url": "http://wpad.domain.name/wpad.dat",
                            "method": "auto"
                        },
                        "state": "connected",
                        "netmask": "255.255.255.0",
                        "dns2": "192.168.1.1",
                        "ipAddress": "192.168.1.7",
                        "dns1": "fe80::fac4:f3ff:fe0d:1a0",
                        "ipv6": {
                    "ipAddress": "2401:4900:1f24:5256:dea6:32ff:feaf:7c53",
                    "method": "auto",
                    "prefixLength": 64
                        },
                        "default": true,
                        "checkingInternet": false,
                        "plugged": true
                    }
                }
            ],
            "onInternet": "no",
            "checkingInternet": false
        },
        "wifi": {
            "proxyinfo": {
                "url": "http://wpad.domain.name/wpad.dat",
                "method": "auto"
            },
            "method": "dhcp",
            "onInternet": "yes",
            "interfaceName": "wlan0",
            "state": "connected",
            "gateway": "192.168.1.1",
            "netmask": "255.255.255.0",
            "dns2": "fe80::fac4:f3ff:fe0d:1a0",
            "ipAddress": "192.168.1.6",
            "dns1": "192.168.1.1",
            "ipv6": {
                "ipAddress": "2401:4900:1f24:5256:dea6:32ff:feaf:7c55",
                "method": "auto",
                "prefixLength": 64
            },
            "ssid": "CXXX",
            "isWakeOnWifiEnabled": false,
            "checkingInternet": false
        }
    }
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [PLAT-123913] Implementation for handling multiple Wired interfaces
                  for getStatus API in webos-connman-adapter
    [PLAT-123912] Implement getStatus and getInfo API's as per approved
                  API changes and create test cases
    
    Change-Id: I8846eccc37bc8a7baaa8d1fd83d0224d535cd3af

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 8923edb..cee4282 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -84,6 +84,8 @@ gboolean p2p_connected = FALSE;
 guint block_getstatus_response = 0;
 gboolean wifi_tethering = FALSE;
 gboolean wired_plugged = FALSE;
+guint available_lan_interface = 0;
+
 
 char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
 char getinfo_cur_wired_mac_address[MAC_ADDR_STRING_LEN]={0};
@@ -418,15 +420,12 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	jobject_put(*reply, J_CSTR_TO_JVAL("offlineMode"),
 	            jstring_create(offlineMode ? "enabled" : "disabled"));
 
-	jvalue_ref connected_wired_status = jobject_create();
-	jvalue_ref disconnected_wired_status = jobject_create();
+	jvalue_ref wired_interfaces = jobject_create();
 	jvalue_ref connected_wifi_status = jobject_create();
 	jvalue_ref disconnected_wifi_status = jobject_create();
 	jvalue_ref connected_p2p_status = jobject_create();
 	jvalue_ref disconnected_p2p_status = jobject_create();
 
-	jobject_put(disconnected_wired_status, J_CSTR_TO_JVAL("state"),
-	            jstring_create("disconnected"));
 	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("state"),
 	            jstring_create("disconnected"));
 	jobject_put(disconnected_wifi_status, J_CSTR_TO_JVAL("tetheringEnabled"),
@@ -435,25 +434,63 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	            jstring_create("disconnected"));
 
 	/* get the service which is currently connecting or already in connected */
+	GSList *iter;
+	connman_technology_t *technology = NULL;
+	for (iter = manager->technologies ; NULL != iter; iter = iter->next)
+	{
+		technology = (struct connman_technology *)(iter->data);
+		if (!g_strcmp0(technology->type, "ethernet"))
+		{
+			int n = 0;
+			jvalue_ref interface_obj = jarray_create(NULL);
+			for (n = 0; n < g_strv_length(technology->interfaces); n++)
+			{
+				gboolean isPlugged = false;
+				connman_service_t *connected_wired_service =
+					connman_manager_get_connected_service_by_interfaceName(manager->wired_services,technology->interfaces[n],&isPlugged);
+				jvalue_ref wired_info = jobject_create();
+				if (NULL != connected_wired_service)
+				{
+					update_connection_status(connected_wired_service, &wired_info);
+					int connman_state = 0;
+					connman_state = connman_service_get_state(connected_wired_service->state);
+					if(connman_state == CONNMAN_SERVICE_STATE_ONLINE)
+					{
+						jobject_put(wired_info, J_CSTR_TO_JVAL("default"), jboolean_create(true));
+					}
+					jobject_put(wired_info, J_CSTR_TO_JVAL("plugged"),jboolean_create(true));
+				}
+				else
+				{
+					jobject_put(wired_info, J_CSTR_TO_JVAL("interfaceName"),jstring_create(technology->interfaces[n]));
+					jobject_put(wired_info, J_CSTR_TO_JVAL("plugged"),jboolean_create(isPlugged));
+					jobject_put(wired_info, J_CSTR_TO_JVAL("state"), jstring_create("disconnected"));
+				}
+				jarray_append(interface_obj, wired_info);
+			}
+			jobject_put(wired_interfaces, J_CSTR_TO_JVAL("interface"), interface_obj);
+			break;
+		}
+	}
+
 	connman_service_t *connected_wired_service =
 	    connman_manager_get_connected_service(manager->wired_services);
 
 	if (NULL != connected_wired_service)
 	{
-		update_connection_status(connected_wired_service, &connected_wired_status);
-		jobject_put(connected_wired_status, J_CSTR_TO_JVAL("plugged"),
+		update_connection_status(connected_wired_service, &wired_interfaces);
+		jobject_put(wired_interfaces, J_CSTR_TO_JVAL("plugged"),
 		            jboolean_create(true));
-		jobject_put(*reply, J_CSTR_TO_JVAL("wired"), connected_wired_status);
-		j_release(&disconnected_wired_status);
 	}
 	else
 	{
-		jobject_put(disconnected_wired_status, J_CSTR_TO_JVAL("plugged"),
+		jobject_put(wired_interfaces, J_CSTR_TO_JVAL("plugged"),
 		            jboolean_create(wired_plugged ? true : false));
-		jobject_put(*reply, J_CSTR_TO_JVAL("wired"), disconnected_wired_status);
-		j_release(&connected_wired_status);
+		jobject_put(wired_interfaces, J_CSTR_TO_JVAL("state"), jstring_create("disconnected"));
 	}
 
+	jobject_put(*reply, J_CSTR_TO_JVAL("wired"), wired_interfaces);
+
 	connman_service_t *connected_wifi_service = NULL;
 
 	if (is_wifi_powered())
@@ -625,6 +662,7 @@ static gboolean check_update_is_needed(void)
 void connectionmanager_send_status_to_subscribers(void)
 {
 	bool wired_skip, wifi_skip = false;
+	guint connected_ethernet_interfaces = 0;
 
 	if (manager == NULL)
 		return;
@@ -667,8 +705,24 @@ void connectionmanager_send_status_to_subscribers(void)
 			}
 		}
 
+		GSList *iter;
+		connman_technology_t *technology = NULL;
+		for (iter = manager->technologies ; NULL != iter; iter = iter->next)
+		{
+			technology = (struct connman_technology *)(iter->data);
+			if (!g_strcmp0(technology->type, "ethernet"))
+			{
+				connected_ethernet_interfaces =  g_strv_length(technology->interfaces);
+				break;
+			}
+		}
+
+		if(available_lan_interface != connected_ethernet_interfaces)
+		{
+			available_lan_interface = connected_ethernet_interfaces;
+		}
 		// This routine affects when connected service for both wired and wifi exists.
-		if (connected_wired_service && connected_wifi_service)
+		else if (connected_wired_service && connected_wifi_service)
 		{
 			/* If there is no change of online_checking status for both wired and wifi,
 			 * getstatus will not be emitted. If there is a change of online_checking status
@@ -698,7 +752,6 @@ void connectionmanager_send_status_to_subscribers(void)
 
 	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
 	                              DOMOPT_NOOPT, NULL);
-
 	if (response_schema)
 	{
 		const char *payload = jvalue_tostring(reply, response_schema);
@@ -1972,7 +2025,6 @@ static void technology_property_changed_callback(gpointer data,
         const gchar *property, GVariant *value)
 {
 	connman_technology_t *technology = (connman_technology_t *)data;
-
 	if (NULL == technology)
 	{
 		return;
@@ -1980,7 +2032,6 @@ static void technology_property_changed_callback(gpointer data,
 
 	/* Need to send getstatus method to all com.webos.service.connectionmanager subscribers whenever the
 	   "powered" or "connected" state of the technology changes */
-
 	if (!g_strcmp0(property, "Powered") || !g_strcmp0(property, "Connected"))
 	{
 		if (manager) {
@@ -1992,6 +2043,7 @@ static void technology_property_changed_callback(gpointer data,
 	}
 	else if (!g_strcmp0(property, "Interfaces"))
 	{
+		connectionmanager_send_status_to_subscribers();
 		send_getinfo_to_subscribers();
 	}
 }
diff --git a/src/connman_manager.c b/src/connman_manager.c
index 6a2c448..05a85a2 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -1306,6 +1306,57 @@ connman_service_t *connman_manager_get_connected_service(GSList *service_list)
 	return NULL;
 }
 
+
+/**
+ * Go through the manager's given services list and get the one by interface name which is in
+ * "ready" or "online" state (see header for API details) and updates plugged state of the
+ * ethernet cable
+ */
+
+connman_service_t *connman_manager_get_connected_service_by_interfaceName(GSList *service_list, const char *interface , gboolean* plugged)
+{
+	if (NULL == service_list)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+	connman_service_t *service = NULL, *connected_service = NULL;
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		service = (struct connman_service *)(iter->data);
+		if(!g_strcmp0(interface, service->interface_name))
+		{
+			plugged = true;
+			int service_state = connman_service_get_state(service->state);
+
+			if(service_state == CONNMAN_SERVICE_STATE_ONLINE
+				|| service_state == CONNMAN_SERVICE_STATE_READY
+				|| service_state == CONNMAN_SERVICE_STATE_CONFIGURATION)
+			{
+				connected_service = service;
+				break;
+			}
+		}
+	}
+
+	if (connected_service != NULL)
+	{
+		GVariant *properties = connman_service_fetch_properties(connected_service);
+
+		if (NULL != properties)
+		{
+			connman_service_update_properties(connected_service, properties);
+			g_variant_unref(properties);
+			return connected_service;
+		}
+	}
+
+	return NULL;
+}
+
+
 /**
  * Go through the manager's given service list and find the currently connecting service
  * and return it.
diff --git a/src/connman_manager.h b/src/connman_manager.h
index fbf8507..a21dc1e 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -174,6 +174,19 @@ extern connman_service_t *connman_manager_get_connected_service(
 extern connman_service_t *connman_manager_get_connecting_service(
     GSList *service_list);
 
+/**
+ * Go through the manager's given services list and get the one by interface name which is in
+ * "ready" or "online" state (see header for API details) and updates plugged state of the
+ * ethernet cable
+ *
+ * @param[IN] service_list Manager's service list (wired of wifi)
+ * @param[IN] interface name of the interface which needs to be searched in the list
+ * @param[OUT] plugged status to be updated for ethernet cable
+ */
+
+extern connman_service_t *connman_manager_get_connected_service_by_interfaceName(
+    GSList *service_list, const char *interface, gboolean* plugged);
+
 /**
  * Register for manager's "properties_changed" signal, calling the provided function whenever the callback function
  * for the signal is called
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 3ef1169..1149a77 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2040,6 +2040,7 @@ static void technology_property_changed_callback(gpointer data,
 		}
 		else if (!g_strcmp0(property, "Interfaces"))
 		{
+			connectionmanager_send_status_to_subscribers();
 			send_getinfo_to_subscribers();
 		}
 	}

commit 78254f9560099352593e98d63b21aaa2bd05187f
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Tue Jan 5 17:53:44 2021 +0530

    Implemented setDefaultInterface
    
    :Release Notes:
    Implemented setDefaultInterface which can be used to change
    default interface
    
    :Detailed Notes:
    Implemented setDefaultInterface which can be used to change
    default interface
    
    :Testing Performed:
    Build and tested
    luna-send -n -1 luna://com.webos.service.connectionmanager/
    setDefaultInterface '{"ifName":"eth1"}'
    {"returnValue":true}
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-123930] Implement setDefaultInterface API as per approved design
                  in webos-connman-adapter
    
    Change-Id: I8133febb5a5107d746b3db956bcbacb038f79228

diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index 24cd7df..a15565e 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -12,7 +12,8 @@
         "com.webos.service.connectionmanager/setProxy",
         "com.webos.service.connectionmanager/setstate",
         "com.webos.service.connectionmanager/setTechnologyState",
-        "com.webos.service.connectionmanager/monitorActivity"
+        "com.webos.service.connectionmanager/monitorActivity",
+        "com.webos.service.connectionmanager/setDefaultInterface"
     ],
     "wifi.query": [
         "com.webos.service.wifi/findnetworks",
diff --git a/files/xml/connman.xml b/files/xml/connman.xml
index 54d2e1d..7c38dbf 100644
--- a/files/xml/connman.xml
+++ b/files/xml/connman.xml
@@ -149,6 +149,8 @@ limitations under the License.
 		</method>
 		<method name="RejectPeer">
 		</method>
+		<method name="SetDefault">
+		</method>
 		<signal name="PropertyChanged">
 			<arg type="s"/>
 			<arg type="v"/>
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index cee4282..ed32ede 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -2666,6 +2666,74 @@ cleanup:
 	return true;
 }
 
+static bool handle_set_default_interface(LSHandle *sh, LSMessage *message,
+                                    void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	connman_service_t *service = NULL;
+	gchar *interfaceName = NULL;
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(ifName, string)) REQUIRED_1(ifName))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref interfaceObj = {0};
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ifName"), &interfaceObj))
+	{
+		raw_buffer interface_buf = jstring_get(interfaceObj);
+		interfaceName = g_strdup(interface_buf.m_str);
+		jstring_free_buffer(interface_buf);
+	}
+
+	service = connman_manager_retreive_service_by_interfaceName(manager->wired_services ,interfaceName);
+
+	if (NULL != service)
+	{
+		int service_state = connman_service_get_state(service->state);
+
+		if(service_state == CONNMAN_SERVICE_STATE_ONLINE)
+		{
+			LSMessageReplyCustomError(sh, message, "Already default",
+									WCA_API_ERROR_INTERFACE_ALREADY_DEFAULT);
+		}
+		else if(service_state == CONNMAN_SERVICE_STATE_READY
+			|| service_state == CONNMAN_SERVICE_STATE_CONFIGURATION)
+		{
+			if (connman_service_set_default(service))
+			{
+				LSMessageReplySuccess(sh, message);
+			}
+			else
+			{
+				LSMessageReplyErrorUnknown(sh, message);
+			}
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message, "Invalid Interface",
+										WCA_API_ERROR_INTERFACE_NOT_CONNECTED);
+		}
+	}
+	else
+	{
+		LSMessageReplyCustomError(sh, message, "Invalid Interface",
+									WCA_API_ERROR_INTERFACE_NOT_CONNECTED);
+	}
+
+	g_free(interfaceName);
+	j_release(&parsedObj);
+	return true;
+}
+
 /**
  * @brief com.webos.service.connectionmanager service method table
  */
@@ -2683,6 +2751,7 @@ static LSMethod connectionmanager_methods[] =
 	{ LUNA_METHOD_SETTECHNOLOGYSTATE,   handle_set_technology_state_command },
 	{ LUNA_METHOD_SETPROXY,             handle_set_proxy_command },
 	{ LUNA_METHOD_FINDPROXYFORURL,      handle_find_proxy_for_url_command },
+	{ LUNA_METHOD_SETDEFAULT,           handle_set_default_interface },
 	{ },
 };
 
diff --git a/src/connectionmanager_service.h b/src/connectionmanager_service.h
index 8a78fb8..85f206c 100644
--- a/src/connectionmanager_service.h
+++ b/src/connectionmanager_service.h
@@ -45,6 +45,8 @@
 #define LUNA_METHOD_SETTECHNOLOGYSTATE    "setTechnologyState"
 #define LUNA_METHOD_SETPROXY              "setProxy"
 #define LUNA_METHOD_FINDPROXYFORURL       "findProxyForURL"
+#define LUNA_METHOD_SETDEFAULT            "setDefaultInterface"
+
 
 enum ipadress_type
 {
diff --git a/src/connman_manager.c b/src/connman_manager.c
index 05a85a2..dbec8e1 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -1357,6 +1357,33 @@ connman_service_t *connman_manager_get_connected_service_by_interfaceName(GSList
 }
 
 
+/**
+ * Go through the manager's given services list and get the one by interface name
+ */
+
+connman_service_t *connman_manager_retreive_service_by_interfaceName(GSList *service_list, const char *interface)
+{
+	if (NULL == service_list)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+	connman_service_t *service = NULL, *connected_service = NULL;
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		service = (struct connman_service *)(iter->data);
+		if(!g_strcmp0(interface, service->interface_name))
+		{
+			connected_service = service;
+			return connected_service;
+		}
+	}
+
+	return NULL;
+}
+
 /**
  * Go through the manager's given service list and find the currently connecting service
  * and return it.
diff --git a/src/connman_manager.h b/src/connman_manager.h
index a21dc1e..5ff87e5 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -187,6 +187,16 @@ extern connman_service_t *connman_manager_get_connecting_service(
 extern connman_service_t *connman_manager_get_connected_service_by_interfaceName(
     GSList *service_list, const char *interface, gboolean* plugged);
 
+/**
+ * Go through the manager's given services list and get the one by interface name
+ *
+ * @param[IN] service_list Manager's service list (wired of wifi)
+ * @param[IN] interface name of the interface which needs to be searched in the list
+ */
+
+extern connman_service_t *connman_manager_retreive_service_by_interfaceName(
+   GSList *service_list, const char *interface);
+
 /**
  * Register for manager's "properties_changed" signal, calling the provided function whenever the callback function
  * for the signal is called
diff --git a/src/connman_service.c b/src/connman_service.c
index 143b8cf..943073c 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1279,6 +1279,31 @@ gboolean connman_service_reject_peer(connman_service_t *service)
 	return TRUE;
 }
 
+/**
+ * Set the given service as default interface(see header for API details)
+ */
+
+gboolean connman_service_set_default(connman_service_t *service)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_service_call_set_default_sync(service->remote, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_SET_DEFAULT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
 /**
  * Register for incoming P2P requests  (see header for API details)
  */
@@ -1492,17 +1517,15 @@ void connman_service_update_properties(connman_service_t *service,
 					service->interface_name = g_variant_dup_string(ifaceva, NULL);
 					g_variant_unref(ifacev);
 					g_variant_unref(ifaceva);
-					WCALOG_DEBUG("Interface Name %s", service->interface_name);
 				}
 				else if (!g_strcmp0(ekey, "Address"))
 				{
 					GVariant *macv = g_variant_get_child_value(ethernet, 1);
 					GVariant *macva = g_variant_get_variant(macv);
-					g_free(service->macaddress);
-					service->macaddress = g_variant_dup_string(macva, NULL);
+					g_free(service->mac_address);
+					service->mac_address = g_variant_dup_string(macva, NULL);
 					g_variant_unref(macv);
 					g_variant_unref(macva);
-					WCALOG_DEBUG("Interface Mac %s", service->macaddress);
 				}
 				g_variant_unref(ethernet);
 				g_variant_unref(ekey_v);
@@ -1714,8 +1737,8 @@ void connman_service_free(gpointer data, gpointer user_data)
 	g_free(service->address);
 	service->address = NULL;
 
-	g_free(service->macaddress);
-	service->macaddress = NULL;
+	g_free(service->mac_address);
+	service->mac_address = NULL;
 
 	g_strfreev(service->security);
 	service->security = NULL;
diff --git a/src/connman_service.h b/src/connman_service.h
index 19037db..9156484 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -127,7 +127,7 @@ typedef struct connman_service
 	gchar *state;
 	gchar *error;
 	gchar *address;
-	gchar *macaddress;
+	gchar *mac_address;
 
 	guchar strength;
 	GStrv security;
@@ -282,6 +282,15 @@ extern gboolean connman_service_disconnect(connman_service_t *service);
  */
 extern gboolean connman_service_reject_peer(connman_service_t *service);
 
+/**
+ * Set this service as default , this will make this service state online
+ *
+ * @param[IN]  service A service instance
+ *
+ * @return FALSE if the call failed, TRUE otherwise
+ */
+extern gboolean connman_service_set_default(connman_service_t *service);
+
 /**
  * remove a remote connman service
  *
diff --git a/src/errors.h b/src/errors.h
index b382b52..e4a2e16 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -114,5 +114,10 @@
 #define WCA_API_ERROR_TETHERING_NOT_ALLOWED_TO_CHANGE_MAX_STATION_COUNT 210
 #define WCA_API_ERROR_TETHERING_SET_MAX_STATION_COUNT_FAILED 211
 
+#define WCA_API_ERROR_INTERFACE_NOT_CONNECTED    301
+#define WCA_API_ERROR_INTERFACE_ALREADY_DEFAULT  302
+
+
+
 
 #endif /* ERRORS_H_ */
diff --git a/src/logging.h b/src/logging.h
index d089faa..724ff2a 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -110,6 +110,7 @@ extern PmLogContext gLogContext;
 /** connman_service.c */
 #define MSGID_SERVICE_CONNECT_ERROR                     "SRVC_CONNECT_ERR"
 #define MSGID_SERVICE_DISCONNECT_ERROR                  "SRVC_DISCONNECT_ERR"
+#define MSGID_SERVICE_SET_DEFAULT_ERROR                 "SRVC_SET_DEFAULT_ERR"
 #define MSGID_SERVICE_REMOVE_ERROR                      "SRVC_REMOVE_ERR"
 #define MSGID_SERVICE_SET_IPV4_ERROR                    "SRVC_SET_IPV4_ERR"
 #define MSGID_SERVICE_SET_IPV6_ERROR                    "SRVC_SET_IPV6_ERR"

commit 5483fbc6e333e304a97c2e1db81523e8e7671ee8
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Sun Jan 17 14:25:36 2021 +0530

    Add IP table for each interface if state is in ready state
    
    :Release Notes:
    Add IP table for each interface if state is in ready state
    
    :Detailed Notes:
    Add IP table for each interface if state is in ready state
    
    :Testing Performed:
    Built and Tested
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [PLAT-123900] Implementation for addition of ip rules to
    maintain multiple Wired interfaces list in webos-connman-adpter
    
    Change-Id: I047ef2eb86d635a5834d96c817cae03fe5a71cf0

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 540b131..b520fea 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2020 LG Electronics, Inc.
+# Copyright (c) 2012-2021 LG Electronics, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -112,6 +112,10 @@ if (ENABLE_SCAN_ON_SOFTAP)
 webos_add_compiler_flags(ALL -DENABLE_SCAN_ON_SOFTAP)
 endif()
 
+if (MULTIPLE_ROUTING_TABLE)
+webos_add_compiler_flags(ALL -DMULTIPLE_ROUTING_TABLE)
+endif()
+
 include_directories(src ${GDBUS_IF_DIR})
 webos_configure_header_files(src)
 
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index ed32ede..f415547 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -474,7 +474,7 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 	}
 
 	connman_service_t *connected_wired_service =
-	    connman_manager_get_connected_service(manager->wired_services);
+	    connman_manager_get_default_service(manager->wired_services);
 
 	if (NULL != connected_wired_service)
 	{
@@ -661,7 +661,7 @@ static gboolean check_update_is_needed(void)
 
 void connectionmanager_send_status_to_subscribers(void)
 {
-	bool wired_skip, wifi_skip = false;
+	bool wired_skip, wifi_skip ,update_required = false;
 	guint connected_ethernet_interfaces = 0;
 
 	if (manager == NULL)
@@ -712,12 +712,22 @@ void connectionmanager_send_status_to_subscribers(void)
 			technology = (struct connman_technology *)(iter->data);
 			if (!g_strcmp0(technology->type, "ethernet"))
 			{
+				for (int n = 0; n < g_strv_length(technology->interfaces); n++)
+				{
+					connman_service_t *service = connman_manager_retreive_service_by_interfaceName(manager->wired_services,technology->interfaces[n]);
+					if ((NULL != service) && (connman_service_is_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS)))
+					{
+						connman_service_unset_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+						update_required = true;
+					}
+				}
 				connected_ethernet_interfaces =  g_strv_length(technology->interfaces);
 				break;
 			}
 		}
 
-		if(available_lan_interface != connected_ethernet_interfaces)
+
+		if((available_lan_interface != connected_ethernet_interfaces)|| (update_required))
 		{
 			available_lan_interface = connected_ethernet_interfaces;
 		}
diff --git a/src/connman_manager.c b/src/connman_manager.c
index dbec8e1..a708df0 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -1306,6 +1306,52 @@ connman_service_t *connman_manager_get_connected_service(GSList *service_list)
 	return NULL;
 }
 
+/**
+ * Go through the manager's given services list and get the one which is in
+ * "online" state , if none of the service is in online state then it returns 
+ * first available service which is in "ready" state
+ */
+connman_service_t *connman_manager_get_default_service(GSList *service_list)
+{
+	if (NULL == service_list)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+	connman_service_t *service = NULL, *connected_service = NULL;
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		service = (struct connman_service *)(iter->data);
+		int service_state = connman_service_get_state(service->state);
+
+		if(service_state == CONNMAN_SERVICE_STATE_ONLINE)
+		{
+			connected_service = service;
+			break;
+		}
+		else if((connected_service == NULL) && ( service_state == CONNMAN_SERVICE_STATE_READY || 
+			service_state == CONNMAN_SERVICE_STATE_CONFIGURATION))
+		{
+			connected_service = service;
+		}
+	}
+
+	if (connected_service != NULL)
+	{
+		GVariant *properties = connman_service_fetch_properties(connected_service);
+
+		if (NULL != properties)
+		{
+			connman_service_update_properties(connected_service, properties);
+			g_variant_unref(properties);
+			return connected_service;
+		}
+	}
+
+	return NULL;
+}
 
 /**
  * Go through the manager's given services list and get the one by interface name which is in
diff --git a/src/connman_manager.h b/src/connman_manager.h
index 5ff87e5..1c036cf 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -163,6 +163,14 @@ extern connman_technology_t *connman_manager_find_ethernet_technology(
 extern connman_service_t *connman_manager_get_connected_service(
     GSList *service_list);
 
+/**
+* Go through the manager's given services list and get the one which is in 
+* "online" state , if none of the service is in online state then it returns
+* first available service which is in "ready" state 
+*/
+extern connman_service_t *connman_manager_get_default_service(
+    GSList *service_list);
+
 /**
  * Go through the manager's given service list and find the currently connecting service
  * and return it.
diff --git a/src/connman_service.c b/src/connman_service.c
index 943073c..2724c91 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -786,6 +786,17 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 					g_variant_unref(methodva);
 				}
 
+				if (!g_strcmp0(ikey, "PrefixLength"))
+				{
+					GVariant *prefix_lengthv = g_variant_get_child_value(ipv4, 1);
+					GVariant *prefix_lengthva = g_variant_get_variant(prefix_lengthv);
+					const char *prefix_length = g_variant_get_data(prefix_lengthva);
+					service->ipinfo.ipv4.prefix_len = *prefix_length;
+
+					g_variant_unref(prefix_lengthv);
+					g_variant_unref(prefix_lengthva);
+				}
+
 				if (!g_strcmp0(ikey, "Netmask"))
 				{
 					GVariant *netmaskv = g_variant_get_child_value(ipv4, 1);
@@ -961,6 +972,53 @@ gboolean connman_service_get_proxyinfo(connman_service_t *service)
 	return TRUE;
 }
 
+static void connman_service_set_ip_rule(connman_service_t *service , bool status)
+{
+	WCALOG_DEBUG("connman_service_set_ip_rule");
+	if ((NULL != service->ipinfo.ipv4.address)&&
+		(NULL != service->ipinfo.ipv4.netmask)&&
+		(NULL != service->ipinfo.ipv4.gateway)&&
+		(NULL != service->interface_name) &&
+		(!is_vlan(service->interface_name)))
+	{
+		char addtable[80] = {0,};
+		WCALOG_DEBUG("connman_service_set_ip_rule %s", service->interface_name);
+		char* find_Id = service->interface_name;
+		find_Id +=3;
+		int table_Id = 0;
+		int assigned = sscanf(find_Id, "%d", &table_Id);
+		if(assigned > 0)
+		{
+			table_Id = table_Id+10;
+			WCALOG_DEBUG("connman_service_set_ip_rule Ready state address available %s ID %d", service->interface_name , table_Id);
+			sprintf(addtable,"ip route %s table %d default via %s", (status) ? "add" : "delete", table_Id , service->ipinfo.ipv4.gateway);
+			system(addtable);
+			char addDestrule[80] = {0,};
+			sprintf(addDestrule,"ip rule %s from  %s/%d table %d", (status) ? "add" : "delete", service->ipinfo.ipv4.address, service->ipinfo.ipv4.prefix_len, table_Id );
+			system(addDestrule);
+			char addSrcrule[80] = {0,};
+			sprintf(addSrcrule,"ip rule %s to %s/%d table %d", (status) ? "add" : "delete", service->ipinfo.ipv4.address, service->ipinfo.ipv4.prefix_len, table_Id );
+			system(addSrcrule);
+			service->iprule_added = status;
+		}
+	}
+}
+
+static void connman_service_create_ip_rule(connman_service_t *service)
+{
+	WCALOG_DEBUG("connman_service_create_ip_rule ");
+	if (!service->iprule_added &&
+		(!g_strcmp0(service->state, "ready")))
+		connman_service_set_ip_rule(service,true);
+}
+
+static void connman_service_delete_ip_rule(connman_service_t *service)
+{
+	WCALOG_DEBUG("connman_service_delete_ip_rule ");
+	if ( service->iprule_added)
+		connman_service_set_ip_rule(service,false);
+}
+
 /**
  * @brief Check service->state is changed
  */
@@ -1000,10 +1058,22 @@ static void connman_service_advance_state(connman_service_t *service,
 		{
 			(service->handle_property_change_fn)((gpointer) service, "State", v);
 		}
+
+#ifdef MULTIPLE_ROUTING_TABLE
+		if((!g_strcmp0(new_state, "ready")) && (service->type == CONNMAN_SERVICE_TYPE_ETHERNET))
+		{
+			WCALOG_DEBUG("connman_service_advance_state  Ready state");
+			connman_service_get_ipinfo(service);
+			connman_service_create_ip_rule(service);
+		}
+		else if((!g_strcmp0(new_state, "online")) && (service->type == CONNMAN_SERVICE_TYPE_ETHERNET))
+		{
+			connman_service_delete_ip_rule(service);
+		}
+#endif
 	}
+	WCALOG_DEBUG("connman_service_advance_state exit");
 }
-
-
 /**
  * @brief Check service->online is changed
  */
@@ -1515,6 +1585,9 @@ void connman_service_update_properties(connman_service_t *service,
 					GVariant *ifaceva = g_variant_get_variant(ifacev);
 					g_free(service->interface_name);
 					service->interface_name = g_variant_dup_string(ifaceva, NULL);
+#ifdef MULTIPLE_ROUTING_TABLE
+					connman_service_create_ip_rule(service);
+#endif
 					g_variant_unref(ifacev);
 					g_variant_unref(ifaceva);
 				}
@@ -1678,7 +1751,7 @@ connman_service_t *connman_service_new(GVariant *variant)
 	}
 
 	g_dbus_proxy_set_default_timeout(service->remote, DBUS_CALL_TIMEOUT);
-
+	service->iprule_added = false;
 	service->sighandler_id = g_signal_connect_data(G_OBJECT(service->remote),
 	                         "property-changed",
 	                         G_CALLBACK(property_changed_cb), service, NULL, 0);
@@ -1713,6 +1786,10 @@ void connman_service_free(gpointer data, gpointer user_data)
 
 	WCALOG_DEBUG("Service free name %s, path %s", service->name, service->path);
 
+#ifdef MULTIPLE_ROUTING_TABLE
+	connman_service_delete_ip_rule(service);
+#endif
+
 	g_free(service->path);
 	service->path = NULL;
 
diff --git a/src/connman_service.h b/src/connman_service.h
index 9156484..ce2954d 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -40,6 +40,7 @@ typedef struct ipv4info
 	gchar *address;
 	gchar *netmask;
 	gchar *gateway;
+	gint prefix_len;
 } ipv4info_t;
 
 /**
@@ -166,6 +167,7 @@ typedef struct connman_service
 	gchar *ssid; /* Wifi service ssid, can be null for hidden networks */
 	gsize ssid_len;
 	GCancellable *cancellable;
+	gboolean iprule_added;
 } connman_service_t;
 
 /**
diff --git a/src/utils.c b/src/utils.c
index b26b778..7df86db 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -188,3 +188,24 @@ bool is_valid_wifi_passphrase(const char* passphrase, const char* security)
 		return true;
 	}
 }
+
+bool is_vlan(const char* string)
+{
+	if (!string)
+	{
+		return false;
+	}
+
+	size_t len = strlen(string);
+	size_t i;
+
+	for (i = 0; i < len; i++)
+	{
+		if (string[i] == '.')
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
diff --git a/src/utils.h b/src/utils.h
index 51b26b8..7a0a993 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -47,4 +47,6 @@ char *strip_prefix(const char *str, const char *prefix);
 
 bool is_valid_wifi_passphrase(const char* passphrase, const char* security);
 
+bool is_vlan(const char* string);
+
 #endif

commit cf931c93f3bf938d02fa0e539fd390b54dc6d317
Merge: 841edd4 5483fbc
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Thu Jan 28 11:38:40 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I8e4ac9242e542ec55a89fcdd123a756a70e1e781

commit 31812efdf67a5e40f7827c23c5937731bcf7f110
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Fri Jan 29 10:45:42 2021 +0530

    Fixed Coverity Issue
    
    :Release Notes:
    Fixed Coverity Issue in webos-connman-adapter
    
    :Detailed Notes:
    Resource leak
    
    :Testing Performed:
    Build successfully
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [CID-8978881] Resource leak
    [CID-8978880] Resource leak
    [CID-8978879] Resource leak
    [CID-8978878] Resource leak
    [CID-8978876] Resource leak
    [CID-8978877] Resource leak
    [CID-8978875] Resource leak
    [CID-8978874] Resource leak
    [CID-260292] Resource leak
    [CID-260303] Resource leak
    
    Change-Id: Ibed787ca0bbdd5d1e69e35a68a96988939ae5246

diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index f22972c..df2ea5a 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -479,7 +479,11 @@ gboolean wifi_scan_now_with_option(const GStrv *ssid, const GStrv *freq)
 	}
 
 	WCALOG_DEBUG("wifi_scan: Scanning wifi with %s", command);
-	(void)system(command);
+	if(command != NULL)
+	{
+		(void)system(command);
+		g_free(command);
+	}
 
 	return true;
 }
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 1149a77..6b24637 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2645,20 +2645,16 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 	}
 
 	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
+		goto Exit;
 
 	if (!wifi_technology_status_check(sh, message))
-	{
-		return true;
-	}
+		goto Exit;
 
 	if (!is_wifi_powered())
 	{
 		LSMessageReplyCustomError(sh, message, "WiFi switched off",
 		                          WCA_API_ERROR_WIFI_SWITCHED_OFF);
-		return true;
+		goto Exit;
 	}
 
 	if (is_scan_option)
@@ -2667,7 +2663,7 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 		{
 			LSMessageReplyCustomError(sh, message, "Error in scanning network",
 												  WCA_API_ERROR_SCANNING);
-			return true;
+			goto Exit;
 		}
 	}
 	else
@@ -2676,14 +2672,16 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 		{
 			LSMessageReplyCustomError(sh, message, "Error in scanning network",
 									  WCA_API_ERROR_SCANNING);
-			return true;
+			goto Exit;
 		}
 	}
 
 	LSMessageReplySuccess(sh, message);
 
+Exit:
 	j_release(&parsedObj);
 	g_strfreev(ssid);
+	g_strfreev(frequency);
 	return true;
 }
 
@@ -3628,6 +3626,7 @@ static bool set_country_code(const char* countryCode)
 	fp = popen(command, "r");
 	if (NULL == fp)
 	{
+		g_free(command);
 		return false;
 	}
 
@@ -3730,6 +3729,7 @@ static bool get_country_code()
 	fp = popen(command, "r");
 	if (NULL == fp)
 	{
+		g_free(command);
 		return false;
 	}
 
diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 84371c5..9dd9d0a 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -759,6 +759,7 @@ gboolean change_network_passphrase(const char *ssid, const char *security,
 
 	if (keyfile == NULL)
 	{
+		g_free(pathname);
 		return FALSE;
 	}
 
@@ -798,6 +799,7 @@ gboolean change_network_ipv4(const char *ssid, const char *security,
 
 	if (keyfile == NULL)
 	{
+		g_free(pathname);
 		return FALSE;
 	}
 
@@ -840,6 +842,7 @@ gboolean change_network_ipv6(const char *ssid, const char *security,
 
 	if (keyfile == NULL)
 	{
+		g_free(pathname);
 		return FALSE;
 	}
 
@@ -880,6 +883,7 @@ gboolean change_network_dns(const char *ssid, const char *security,
 
 	if (keyfile == NULL)
 	{
+		g_free(pathname);
 		return FALSE;
 	}
 
@@ -932,6 +936,7 @@ gboolean change_network_remove_entry(const char *ssid, const char *security,
 
 	if (keyfile == NULL)
 	{
+		g_free(pathname);
 		return FALSE;
 	}
 
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 799c859..f14a616 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -90,9 +90,14 @@ static bool set_max_station_count(gint count)
 	if (count <= 0 || count > 254)
 		return false;
 
-	command	= g_strdup_printf("%s %d","wpa_cli -i wlan0 set max_num_sta" , count);
-	(void)system(command);
-	(void)system("wpa_cli -i wlan0 save_config");
+	command = g_strdup_printf("%s %d","wpa_cli -i wlan0 set max_num_sta" , count);
+
+	if(command != NULL)
+	{
+		(void)system(command);
+		(void)system("wpa_cli -i wlan0 save_config");
+		g_free(command);
+	}
 
 	return true;
 }

commit 83a1089660793df7182cd0fde3763c0e20c55e29
Merge: cf931c9 31812ef
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Fri Jan 29 12:09:02 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I8eb9610dc0df5ccd343921591e1b1f8526755aba

commit 02b2c6d5d70223aba4620a6c3d80dc0bb880b23f
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Wed Jan 27 14:37:02 2021 +0530

    Add p2p support
    
    :Release Notes:
    Add p2p luna api's
    
    :Detailed Notes:
    Added p2p luna api's for supporting wifi direct.
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-131728] Integrating and verification p2p/getstate, p2p/setstate
                  and p2p/setgointent Luna API
    [PLAT-131739] Integrating and verification p2p/connect, p2p/disconnect
                  and p2p/cancel Luna API
    
    Change-Id: If9fcfbe2a5fc48448f0329aeb325b1bebff20173

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b520fea..2fa2af5 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -119,6 +119,7 @@ endif()
 include_directories(src ${GDBUS_IF_DIR})
 webos_configure_header_files(src)
 
+add_subdirectory(src/wfdsie)
 file(GLOB SOURCE_FILES
     src/common.c
     src/connectionmanager_service.c
@@ -134,6 +135,7 @@ file(GLOB SOURCE_FILES
     src/main.c
     src/pacrunner_client.c
     src/utils.c
+    src/wifi_p2p_service.c
     src/wifi_tethering_service.c
     src/wifi_profile.c
     src/wifi_service.c
@@ -154,7 +156,8 @@ target_link_libraries(webos-connman-adapter
                         ${PMLOG_LDFLAGS}
                         ${WCA_SUPPORT_LDFLAGS}
                         rt
-                        pthread)
+                        pthread
+                        wfdsie)
 
 webos_build_daemon()
 webos_build_system_bus_files()
diff --git a/files/sysbus/webos-connman-adapter.api.json b/files/sysbus/webos-connman-adapter.api.json
index a15565e..c238f03 100644
--- a/files/sysbus/webos-connman-adapter.api.json
+++ b/files/sysbus/webos-connman-adapter.api.json
@@ -24,7 +24,14 @@
         "com.webos.service.wifi/getstatus",
         "com.webos.service.wifi/tethering/getMaxStationCount",
         "com.webos.service.wifi/tethering/getState",
-        "com.webos.service.wifi/tethering/getStationCount"
+        "com.webos.service.wifi/tethering/getStationCount",
+        "com.webos.service.wifi/p2p/getdevicename",
+        "com.webos.service.wifi/p2p/getstate",
+        "com.webos.service.wifi/p2p/getgrouppeers",
+        "com.webos.service.wifi/p2p/getgroups",
+        "com.webos.service.wifi/p2p/getp2prequests",
+        "com.webos.service.wifi/p2p/getpeers",
+        "com.webos.service.wifi/p2p/getwifidisplayinfo"
     ],
     "wifi.management": [
         "com.webos.service.wifi/scan",
@@ -38,6 +45,25 @@
         "com.webos.service.wifi/startwps",
         "com.webos.service.wifi/setCountryCode",
         "com.webos.service.wifi/tethering/setState",
-        "com.webos.service.wifi/tethering/setMaxStationCount"
+        "com.webos.service.wifi/tethering/setMaxStationCount",
+        "com.webos.service.wifi/p2p/addservice",
+        "com.webos.service.wifi/p2p/cancel",
+        "com.webos.service.wifi/p2p/connect",
+        "com.webos.service.wifi/p2p/creategroup",
+        "com.webos.service.wifi/p2p/deleteprofile",
+        "com.webos.service.wifi/p2p/deleteservice",
+        "com.webos.service.wifi/p2p/disconnect",
+        "com.webos.service.wifi/p2p/disconnectgroup",
+        "com.webos.service.wifi/p2p/findservice",
+        "com.webos.service.wifi/p2p/invite",
+        "com.webos.service.wifi/p2p/rejectpeer",
+        "com.webos.service.wifi/p2p/setdevicename",
+        "com.webos.service.wifi/p2p/setgointent",
+        "com.webos.service.wifi/p2p/setlistenchannel",
+        "com.webos.service.wifi/p2p/setlistenparams",
+        "com.webos.service.wifi/p2p/setstate",
+        "com.webos.service.wifi/p2p/settethering",
+        "com.webos.service.wifi/p2p/setwifidisplayinfo"
+
     ]
 }
diff --git a/files/xml/connman.xml b/files/xml/connman.xml
index 7c38dbf..392e73a 100644
--- a/files/xml/connman.xml
+++ b/files/xml/connman.xml
@@ -1,6 +1,6 @@
 <!-- LICENSE@@@
 
-Copyright (c) 2013 LG Electronics, Inc.
+Copyright (c) 2013-2021 LG Electronics, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -74,6 +74,13 @@ limitations under the License.
 		<method name="GetStaCount">
 			<arg type="i" direction="out"/>
 		</method>
+		<method name="RegisterPeerService">
+			<arg name="specification" type="a{sv}" direction="in"/>
+			<arg name="master" type="b" direction="in"/>
+		</method>
+		<method name="UnregisterPeerService">
+			<arg name="specification" type="a{sv}" direction="in"/>
+		</method>
 		<signal name="PropertyChanged">
 			<arg type="s"/>
 			<arg type="v"/>
@@ -89,6 +96,10 @@ limitations under the License.
 			<arg type="a(oa{sv})"/>
 			<arg type="ao"/>
 		</signal>
+		<signal name="PeersChanged">
+			<arg type="a(oa{sv})"/>
+			<arg type="ao"/>
+		</signal>
 		<signal name="SavedServicesChanged">
 			<arg type="a(oa{sv})"/>
 			<arg type="ao"/>
@@ -147,8 +158,6 @@ limitations under the License.
 		</method>
 		<method name="Remove">
 		</method>
-		<method name="RejectPeer">
-		</method>
 		<method name="SetDefault">
 		</method>
 		<signal name="PropertyChanged">
@@ -156,6 +165,21 @@ limitations under the License.
 			<arg type="v"/>
 		</signal>
 	</interface>
+	<interface name="net.connman.Peer">
+		<method name="GetProperties">
+			<arg type="a{sv}" direction="out"/>
+		</method>
+		<method name="Connect">
+		</method>
+		<method name="Disconnect">
+		</method>
+		<method name="RejectPeer">
+		</method>
+		<signal name="PropertyChanged">
+			<arg type="s"/>
+			<arg type="v"/>
+		</signal>
+	</interface>
 	<interface name="net.connman.Agent">
 		<method name="Release">
 		</method>
@@ -163,6 +187,10 @@ limitations under the License.
 			<arg type="o" direction="in"/>
 			<arg type="s" direction="in"/>
 		</method>
+		<method name="ReportPeerError">
+			<arg type="o" direction="in"/>
+			<arg type="s" direction="in"/>
+		</method>
 		<method name="RequestBrowser">
 			<arg type="o" direction="in"/>
 			<arg type="s" direction="in"/>
@@ -172,6 +200,11 @@ limitations under the License.
 			<arg type="a{sv}" direction="in"/>
 			<arg type="a{sv}" direction="out"/>
 		</method>
+		<method name="RequestPeerAuthorization">
+			<arg type="o" direction="in"/>
+			<arg type="a{sv}" direction="in"/>
+			<arg type="a{sv}" direction="out"/>
+		</method>
 	</interface>
 	<interface name="net.connman.Counter">
 		<method name="Release">
diff --git a/src/common.c b/src/common.c
index cd48350..c7c7d42 100644
--- a/src/common.c
+++ b/src/common.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -118,6 +118,18 @@ gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message)
 	return TRUE;
 }
 
+gboolean p2p_technology_status_check(LSHandle *sh, LSMessage *message)
+{
+	if (NULL == connman_manager_find_p2p_technology(manager))
+	{
+		LSMessageReplyCustomError(sh, message, "WiFi technology unavailable",
+					WCA_API_ERROR_P2P_TECH_UNAVAILABLE);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
 gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
         LSMessage *message, bool subscribed)
 {
@@ -131,6 +143,21 @@ gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
 
 	return TRUE;
 }
+
+gboolean p2p_technology_status_check_with_subscription(LSHandle *sh,
+	LSMessage *message, bool subscribed)
+{
+	if (NULL == connman_manager_find_p2p_technology(manager))
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message,
+			"WiFi technology unavailable",
+			WCA_API_ERROR_P2P_TECH_UNAVAILABLE, subscribed);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
 /**
  * @brief Set the wifi power status according to wether network access is allowed or not
  */
diff --git a/src/common.h b/src/common.h
index cf90e86..f58dae2 100644
--- a/src/common.h
+++ b/src/common.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -30,8 +30,11 @@ extern gboolean connman_status_check(connman_manager_t *manager, LSHandle *sh,
 extern gboolean is_wifi_powered(void);
 extern gboolean is_wifi_tethering(void);
 extern gboolean wifi_technology_status_check(LSHandle *sh, LSMessage *message);
+extern gboolean p2p_technology_status_check(LSHandle *sh, LSMessage *message);
 extern gboolean wifi_technology_status_check_with_subscription(LSHandle *sh,
                                                         LSMessage *message, bool subscribed);
+extern gboolean p2p_technology_status_check_with_subscription(LSHandle *sh,
+                                                        LSMessage *message, bool subscribed);
 extern gboolean connman_status_check_with_subscription(connman_manager_t *manager,
                                                 LSHandle *sh, LSMessage *message, bool subscribed);
 extern gboolean set_wifi_powered_status(gboolean state);
diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index f415547..8816369 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -86,9 +86,11 @@ gboolean wifi_tethering = FALSE;
 gboolean wired_plugged = FALSE;
 guint available_lan_interface = 0;
 
+guint p2p_connected_count;
 
 char getinfo_cur_wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
 char getinfo_cur_wired_mac_address[MAC_ADDR_STRING_LEN]={0};
+char getinfo_cur_p2p_mac_address[MAC_ADDR_STRING_LEN]={0};
 
 static void getinfo_update(void);
 
@@ -272,7 +274,7 @@ static void update_connection_status(connman_service_t *connected_service,
 static void group_property_changed_callback(gpointer data,
         const gchar *property, GVariant *value)
 {
-	if (!g_strcmp0(property, "LocalAddress"))
+	if (!g_strcmp0(property, "LocalAddress") || !g_strcmp0(property, "DHCPAddress"))
 	{
 		connman_service_t *connected_p2p_service =
 		    connman_manager_get_connected_service(manager->p2p_services);
@@ -282,6 +284,7 @@ static void group_property_changed_callback(gpointer data,
 			connman_service_set_changed(connected_p2p_service,
 			                            CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
 			connectionmanager_send_status_to_subscribers();
+			send_peer_information_to_subscribers();
 		}
 	}
 }
@@ -383,6 +386,12 @@ static void append_p2p_connection_status(jvalue_ref *status,
 					            jstring_create(service->ipinfo.ipv4.address));
 				}
 
+				if (service->peer.wfd_enabled)
+				{
+					jobject_put(peer_info, J_CSTR_TO_JVAL("wfdEnabled"),
+					            jboolean_create(service->peer.wfd_enabled));
+				}
+
 				jvalue_ref peer_list_j = jobject_create();
 				jobject_put(peer_list_j, J_CSTR_TO_JVAL("peerInfo"), peer_info);
 				jarray_append(peer_list, peer_list_j);
@@ -520,9 +529,21 @@ static void append_connection_status(jvalue_ref *reply, bool subscribed)
 
 	if (is_wifi_powered())
 	{
-		connected_p2p_service = connman_manager_get_connected_service(
+		connected_p2p_service = connman_manager_get_p2p_connected_service(
 		                            manager->p2p_services);
 	}
+
+	if (NULL != connected_p2p_service)
+	{
+		append_p2p_connection_status(&connected_p2p_status, connected_p2p_service);
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), connected_p2p_status);
+		j_release(&disconnected_p2p_status);
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("wifiDirect"), disconnected_p2p_status);
+		j_release(&connected_p2p_status);
+	}
 }
 
 /**
@@ -639,7 +660,7 @@ static gboolean check_update_is_needed(void)
 
 	if (is_wifi_powered())
 	{
-		connected_p2p_service = connman_manager_get_connected_service(
+		connected_p2p_service = connman_manager_get_p2p_connected_service(
 		                            manager->p2p_services);
 	}
 
@@ -648,6 +669,14 @@ static gboolean check_update_is_needed(void)
 		needed = TRUE;
 	}
 
+	guint p2p_connected_count_now = connman_manager_get_p2p_connected_service_count(manager->p2p_services);
+	if(p2p_connected_count != p2p_connected_count_now)
+	{
+		needed = TRUE;
+	}
+
+	p2p_connected_count = p2p_connected_count_now;
+
 	p2p_connected = (connected_p2p_service != NULL && manager->groups != NULL);
 
 	WCALOG_INFO(MSGID_CONNECTION_INFO, 0, "needed: %d",needed);
@@ -1746,6 +1775,14 @@ static void getinfo_add_response(jvalue_ref* reply, bool subscribed)
 		jobject_put(*reply, J_CSTR_TO_JVAL("wiredInfo"), wired_info);
 	}
 
+	if (getinfo_cur_p2p_mac_address[0])
+	{
+		jvalue_ref p2p_info = jobject_create();
+		jobject_put(p2p_info,
+		            J_CSTR_TO_JVAL("macAddress"),
+		            jstring_create(getinfo_cur_p2p_mac_address));
+		jobject_put(*reply, J_CSTR_TO_JVAL("p2pInfo"), p2p_info);
+	}
 }
 
 void send_getinfo_to_subscribers(void)
@@ -1778,6 +1815,7 @@ static void getinfo_update(void)
 
 	char wifi_mac_address[MAC_ADDR_STRING_LEN]={0};
 	char wired_mac_address[MAC_ADDR_STRING_LEN]={0};
+	char p2p_mac_address[MAC_ADDR_STRING_LEN]={0};
 	gsize i;
 
 	if (retrieve_mac_address(CONNMAN_WIFI_INTERFACE_NAME, wifi_mac_address, MAC_ADDR_STRING_LEN) == 0)
@@ -1823,6 +1861,28 @@ static void getinfo_update(void)
 
 		WCALOG_ERROR(MSGID_WIRED_MAC_ADDR_ERROR,0,"Error in fetching mac address for wired interface");
 	}
+
+	if (retrieve_mac_address(CONNMAN_P2P_INTERFACE_NAME, p2p_mac_address, MAC_ADDR_STRING_LEN) == 0)
+	{
+		if (g_strcmp0(getinfo_cur_p2p_mac_address, p2p_mac_address))
+		{
+			i = g_strlcpy(getinfo_cur_p2p_mac_address, p2p_mac_address, MAC_ADDR_STRING_LEN);
+			if (i != strlen(p2p_mac_address))
+			{
+				WCALOG_ERROR(MSGID_WIFI_MAC_ADDR_ERROR,0,"Failed to copy mac address for p2p interface");
+			}
+		}
+	}
+	else
+	{
+		/** Mark as invalid */
+		if (getinfo_cur_p2p_mac_address[0])
+		{
+			getinfo_cur_p2p_mac_address[0] = 0;
+		}
+
+		WCALOG_ERROR(MSGID_WIFI_MAC_ADDR_ERROR,0,"Error in fetching mac address for p2p interface");
+	}
 }
 
 //->Start of API documentation comment block
diff --git a/src/connman_agent.c b/src/connman_agent.c
index 240f295..faf709e 100644
--- a/src/connman_agent.c
+++ b/src/connman_agent.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -88,6 +88,31 @@ static gboolean report_error_cb(ConnmanInterfaceAgent *interface,
 	return TRUE;
 }
 
+static gboolean request_peer_authorization_cb(
+                                 ConnmanInterfaceAgent *interface,
+                                 GDBusMethodInvocation *invocation,
+                                 const gchar *path,
+                                 GVariant *fields,
+                                 gpointer user_data)
+{
+	connman_agent_t *agent = user_data;
+	GVariant *response = NULL;
+
+	if (agent->request_input_cb == NULL)
+	{
+		g_dbus_method_invocation_return_dbus_error(invocation, AGENT_ERROR_CANCELED,
+		        "No handler available");
+	}
+	else
+	{
+		response = agent->request_input_cb(fields, agent->request_input_data);
+		connman_interface_agent_complete_request_peer_authorization(agent->interface,
+								invocation, response);
+	}
+
+	return TRUE;
+}
+
 static void bus_acquired_cb(GDBusConnection *connection, const gchar *name,
                             gpointer user_data)
 {
@@ -101,6 +126,10 @@ static void bus_acquired_cb(GDBusConnection *connection, const gchar *name,
 	                 G_CALLBACK(request_input_cb), agent);
 	g_signal_connect(agent->interface, "handle-report-error",
 	                 G_CALLBACK(report_error_cb), agent);
+	g_signal_connect(agent->interface, "handle-request-peer-authorization",
+	                 G_CALLBACK(request_peer_authorization_cb), agent);
+	g_signal_connect(agent->interface, "handle-report-peer-error",
+	                 G_CALLBACK(report_error_cb), agent);
 
 	error = NULL;
 
diff --git a/src/connman_common.h.in b/src/connman_common.h.in
index 42ac7c8..622aecb 100644
--- a/src/connman_common.h.in
+++ b/src/connman_common.h.in
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@
 
 #define CONNMAN_WIFI_INTERFACE_NAME     "@WIFI_IFACE_NAME@"
 #define CONNMAN_WIRED_INTERFACE_NAME    "@WIRED_IFACE_NAME@"
+#define CONNMAN_P2P_INTERFACE_NAME	"@P2P_IFACE_NAME@"
 
 #define CONNMAN_SAVED_PROFILE_CONFIG_DIR	"@CONNMAN_CONFIG_DIR@"
 
diff --git a/src/connman_manager.c b/src/connman_manager.c
index a708df0..b76a53c 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -24,10 +24,16 @@
 #include "connman_manager.h"
 #include "logging.h"
 #include "connectionmanager_service.h"
+#include "utils.h"
+#include "wfdsie/wfdinfoelemwrapper.h"
 
 
 wca_support_connman_update_callbacks *connman_update_callbacks = { { NULL } };
 
+/*Default UPnP service version is maintained as 10
+as no input is available via luna command*/
+#define DEFAULT_UPNP_VERSION 10
+
 /**
  * Retrieve all the properties of the given manager instance
  *
@@ -60,6 +66,216 @@ GVariant *connman_manager_get_properties(connman_manager_t *manager)
 	return ret;
 }
 
+/**
+ * Function to add wifi direct service type
+ *
+ * @param[IN]  manager A connman manager instance
+ * @param[IN]  type A P2P service type
+ * @param[IN]  description A string UPnP service type
+ * @param[IN]  query A string containing BonjourQuery
+ * @param[IN]  response A string containing BonjourResponse
+ *
+ * @return A Boolean stating service register is successful or not
+  */
+
+gboolean connman_manager_p2p_service_register (connman_manager_t *manager,
+                        const connman_p2p_service_type type,
+                        const gchar *description,
+                        const gchar *query, const gchar *response, const void* infoelemarray, bool is_master)
+{
+
+	if (!manager)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	gboolean master = FALSE;
+	GVariantBuilder *builder = NULL;
+	GVariant *arguments = NULL;
+
+	switch (type)
+	{
+		case CONNMAN_SERVICE_TYPE_P2P_UPNP:
+		{
+			if (NULL == description)
+			{
+				return FALSE;
+			}
+			WCALOG_DEBUG("connman_manager_service_register = %s", description);
+			builder = g_variant_builder_new (G_VARIANT_TYPE ("a{sv}"));
+			g_variant_builder_add(builder, "{sv}", "UpnpService",
+	                      g_variant_new_string(description));
+			g_variant_builder_add(builder, "{sv}", "UpnpVersion",
+	                      g_variant_new_int32(DEFAULT_UPNP_VERSION));
+			arguments = g_variant_builder_end (builder);
+			g_variant_builder_unref(builder);
+			connman_interface_manager_call_register_peer_service_sync(manager->remote,
+			        arguments, master, NULL, &error);
+			break;
+		}
+
+		case CONNMAN_SERVICE_TYPE_P2P_BONJOUR:
+		{
+			if (NULL == query)
+			{
+				return FALSE;
+			}
+			WCALOG_DEBUG("BonjourQuery = %s BonjourResponse = %s", query, response);
+			builder = g_variant_builder_new (G_VARIANT_TYPE ("a{sv}"));
+			g_variant_builder_add(builder, "{sv}", "BonjourQuery",
+	                      g_variant_new_string(query));
+			g_variant_builder_add(builder, "{sv}", "BonjourResponse",
+	                      g_variant_new_string(response));
+			arguments = g_variant_builder_end (builder);
+			g_variant_builder_unref(builder);
+			connman_interface_manager_call_register_peer_service_sync(manager->remote,
+			        arguments, master, NULL, &error);
+			break;
+		}
+
+                case CONNMAN_SERVICE_TYPE_P2P_WiFiDisplayIEs:
+                {
+                        if (NULL == infoelemarray)
+                        {
+                                return FALSE;
+                        }
+                        InformationElementArray* array = (InformationElementArray*) infoelemarray;
+                        WCALOG_DEBUG("WiFiDisplayIEs array length %d", array->length);
+
+                        for (size_t i = 0; i < array->length; i++) {
+                                WCALOG_DEBUG("WiFiDisplayIEs array bytes %02X", array->bytes[i]);
+                        }
+
+                        builder = g_variant_builder_new (G_VARIANT_TYPE ("a{sv}"));
+                        g_variant_builder_add (builder, "{sv}", "WiFiDisplayIEs",
+                                g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
+                                                      array->bytes,
+                                                      array->length,
+                                                      1));
+                        arguments = g_variant_builder_end (builder);
+                        g_variant_builder_unref(builder);
+                        connman_interface_manager_call_register_peer_service_sync(manager->remote,
+                                arguments, is_master, NULL, &error);
+                        break;
+                }
+
+		default:
+			return FALSE;
+	}
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_P2P_SRV_REGISTER_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Function to remove wifi direct service type
+ *
+ * @param[IN]  manager A connman manager instance
+ * @param[IN]  type A P2P service type
+ * @param[IN]  description A string UPnP service type
+ * @param[IN]  query A string containing BonjourQuery
+ * @param[IN]  response A string containing BonjourResponse
+ *
+ * @return A Boolean stating service register is successful or not
+  */
+
+gboolean connman_manager_p2p_service_unregister(connman_manager_t *manager,
+                         const connman_p2p_service_type type,
+                         const gchar *description, const gchar *query, const void* infoelemarray)
+{
+
+	if (!manager)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+	GVariantBuilder *builder = NULL;
+	GVariant *arguments = NULL;
+
+	switch (type)
+	{
+		case CONNMAN_SERVICE_TYPE_P2P_UPNP:
+		{
+			if (NULL == description)
+			{
+				return FALSE;
+			}
+			WCALOG_DEBUG("connman_manager_service_unregister = %s", description);
+			builder = g_variant_builder_new (G_VARIANT_TYPE ("a{sv}"));
+			g_variant_builder_add(builder, "{sv}", "UpnpService",
+	                      g_variant_new_string(description));
+			g_variant_builder_add(builder, "{sv}", "UpnpVersion",
+	                      g_variant_new_int32(DEFAULT_UPNP_VERSION));
+			arguments = g_variant_builder_end (builder);
+			g_variant_builder_unref(builder);
+			connman_interface_manager_call_unregister_peer_service_sync(manager->remote,
+			        arguments, NULL, &error);
+			break;
+		}
+
+		case CONNMAN_SERVICE_TYPE_P2P_BONJOUR:
+		{
+			if (NULL == query)
+			{
+				return FALSE;
+			}
+			WCALOG_DEBUG("BonjourQuery = %s", query);
+			builder = g_variant_builder_new (G_VARIANT_TYPE ("a{sv}"));
+			g_variant_builder_add(builder, "{sv}", "BonjourQuery",
+	                      g_variant_new_string(query));
+			arguments = g_variant_builder_end (builder);
+			g_variant_builder_unref(builder);
+			connman_interface_manager_call_unregister_peer_service_sync(manager->remote,
+			        arguments,NULL, &error);
+			break;
+		}
+                case CONNMAN_SERVICE_TYPE_P2P_WiFiDisplayIEs:
+                {
+                        if (NULL == infoelemarray)
+                        {
+                                return FALSE;
+                        }
+                        InformationElementArray* array = (InformationElementArray*) infoelemarray;
+                        WCALOG_DEBUG("WiFiDisplayIEs array length %d", array->length);
+
+                        for (size_t i = 0; i < array->length; i++) {
+                                WCALOG_DEBUG("WiFiDisplayIEs array bytes %02X", array->bytes[i]);
+                        }
+
+                        builder = g_variant_builder_new (G_VARIANT_TYPE ("a{sv}"));
+                        g_variant_builder_add (builder, "{sv}", "WiFiDisplayIEs",
+                             g_variant_new_fixed_array (G_VARIANT_TYPE_BYTE,
+                                                      array->bytes,
+                                                      array->length,
+                                                      1));
+                        arguments = g_variant_builder_end (builder);
+                        g_variant_builder_unref(builder);
+                        connman_interface_manager_call_unregister_peer_service_sync(manager->remote,
+                             arguments,NULL, &error);
+                        break;
+               }
+               default:
+			return FALSE;
+	}
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_MANAGER_P2P_SRV_UNREGISTER_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
 /**
  * Get the service in the manager's list matching the path.
  *
@@ -155,7 +371,8 @@ static connman_technology_t *find_technology_by_path(connman_manager_t *manager,
  * @return TRUE if the service is either on wifi/wired interface, FALSE otherwise
  */
 
-static gboolean service_on_configured_iface(GVariant *service_v)
+static gboolean service_on_configured_iface(GVariant *service_v,
+		gboolean *peer_service)
 {
 	if (NULL == service_v)
 	{
@@ -227,8 +444,9 @@ static gboolean service_on_configured_iface(GVariant *service_v)
 			g_variant_unref(v);
 			g_variant_unref(va);
 
-			if (!g_strcmp0(type, "Peer"))
+			if (!g_strcmp0(type, "peer"))
 			{
+				*peer_service = TRUE;
 				g_variant_unref(properties);
 				g_variant_unref(property);
 				g_variant_unref(key_v);
@@ -310,10 +528,14 @@ static connman_service_t* update_or_add_service(connman_manager_t *manager,
 	{
 		/* Only in case that the service was added as new one it contains all
 		 * properties and we can check wether it's on one of the supported
-		 * network interfaces. */
-		if (saved || service_on_configured_iface(service_v) == TRUE)
+		 * network interfaces. If the service is a cellular one we ignore the
+		 * interface check as the interface is just way to route data and not
+		 * the primary control point. */
+
+		gboolean peer_service = FALSE;
+		if (saved || service_on_configured_iface(service_v, &peer_service) == TRUE)
 		{
-			service = connman_service_new(service_v);
+			service = connman_service_new(service_v, peer_service);
 			add_service_to_list(manager, service, saved);
 		}
 	}
@@ -1262,6 +1484,40 @@ connman_technology_t *connman_manager_find_ethernet_technology(
 	return NULL;
 }
 
+/**
+ * Go through the manager's technologies list and get the p2p one
+ * (see header for API details)
+ */
+
+connman_technology_t *connman_manager_find_p2p_technology(
+    connman_manager_t *manager)
+{
+	if (NULL == manager)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+
+	for (iter = manager->technologies; NULL != iter; iter = iter->next)
+	{
+		connman_technology_t *tech = (struct connman_technology *)(iter->data);
+
+		if (!tech)
+		{
+			continue;
+		}
+
+		if (g_strcmp0("p2p", tech->type) == 0)
+		{
+			return tech;
+		}
+	}
+
+	return NULL;
+}
+
+
 /**
  * Go through the manager's given services list and get the one which is in
  * "ready" or "online" state (see header for API details)
@@ -1306,6 +1562,70 @@ connman_service_t *connman_manager_get_connected_service(GSList *service_list)
 	return NULL;
 }
 
+connman_service_t *connman_manager_get_p2p_connected_service(GSList *service_list)
+{
+	if (NULL == service_list)
+	{
+		return NULL;
+	}
+
+	GSList *iter;
+	connman_service_t *service = NULL, *connected_service = NULL;
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		service = (struct connman_service *)(iter->data);
+		int service_state = connman_service_get_state(service->state);
+		if(service_state == CONNMAN_SERVICE_STATE_ONLINE
+			|| service_state == CONNMAN_SERVICE_STATE_READY)
+		{
+			connected_service = service;
+			break;
+		}
+	}
+
+
+	if (connected_service != NULL)
+	{
+		GVariant *properties = connman_service_fetch_properties(connected_service);
+
+		if (NULL != properties)
+		{
+			connman_service_update_properties(connected_service, properties);
+			g_variant_unref(properties);
+			return connected_service;
+		}
+	}
+
+	return NULL;
+}
+
+guint connman_manager_get_p2p_connected_service_count(GSList *service_list)
+{
+	if (NULL == service_list)
+	{
+		return 0;
+	}
+
+	GSList *iter;
+	int count = 0;
+	connman_service_t *service = NULL;
+
+	for (iter = service_list; NULL != iter; iter = iter->next)
+	{
+		service = (struct connman_service *)(iter->data);
+		int service_state = connman_service_get_state(service->state);
+
+		if(service_state == CONNMAN_SERVICE_STATE_ONLINE
+			|| service_state == CONNMAN_SERVICE_STATE_READY)
+		{
+			count++;
+		}
+	}
+
+	return count;
+}
+
 /**
  * Go through the manager's given services list and get the one which is in
  * "online" state , if none of the service is in online state then it returns 
@@ -1897,6 +2217,9 @@ connman_manager_t *connman_manager_new(void)
 	g_signal_connect(G_OBJECT(manager->remote), "services-changed",
 	                 G_CALLBACK(services_changed_cb), manager);
 
+	g_signal_connect(G_OBJECT(manager->remote), "peers-changed",
+			 G_CALLBACK(services_changed_cb), manager);
+
 	g_signal_connect(G_OBJECT(manager->remote), "saved-services-changed",
 	                 G_CALLBACK(saved_services_changed_cb), manager);
 
diff --git a/src/connman_manager.h b/src/connman_manager.h
index 1c036cf..e418f4c 100644
--- a/src/connman_manager.h
+++ b/src/connman_manager.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2019 LG Electronics, Inc.
+// Copyright (c) 2013-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -35,6 +35,13 @@
 #define WIFI_SERVICES_CHANGED       2
 #define P2P_SERVICES_CHANGED        4
 
+typedef enum
+{
+	CONNMAN_SERVICE_TYPE_P2P_UPNP = 0,
+	CONNMAN_SERVICE_TYPE_P2P_BONJOUR,
+	CONNMAN_SERVICE_TYPE_P2P_WiFiDisplayIEs
+} connman_p2p_service_type;
+
 /**
  * Callback function for handling any changes in connman services
  *
@@ -152,6 +159,15 @@ extern connman_technology_t *connman_manager_find_wifi_technology(
 extern connman_technology_t *connman_manager_find_ethernet_technology(
     connman_manager_t *manager);
 
+/**
+ * Go through the manager's technologies list and get the technology with type "p2p"
+ *
+ * @param[IN]  manager A manager instance
+ *
+ * @return Technology with type "p2p"
+ */
+extern connman_technology_t *connman_manager_find_p2p_technology(
+    connman_manager_t *manager);
 /**
  * Go through the manager's given services list and get the one which is in "ready" or
  * "online" state , i.e  one of the connected states.
@@ -162,6 +178,8 @@ extern connman_technology_t *connman_manager_find_ethernet_technology(
  */
 extern connman_service_t *connman_manager_get_connected_service(
     GSList *service_list);
+extern connman_service_t *connman_manager_get_p2p_connected_service(
+    GSList *service_list);
 
 /**
 * Go through the manager's given services list and get the one which is in 
@@ -308,6 +326,15 @@ extern gboolean connman_manager_populate_group_peers(connman_manager_t *manager,
 extern void connman_manager_register_groups_changed_cb(connman_manager_t
         *manager, connman_groups_changed_cb func);
 
+extern gboolean connman_manager_p2p_service_register(connman_manager_t
+        *manager, const connman_p2p_service_type type,
+        const gchar *description, const gchar *query,
+        const gchar *response, const void* infoelemarray, bool is_master);
+
+extern gboolean connman_manager_p2p_service_unregister(connman_manager_t
+        *manager, const connman_p2p_service_type type,
+        const gchar *description, const gchar *query, const void* infoelemarray);
+
 /**
  * Register for manager's "TechnologyAdded" and "TechnologyRemoved" siganls, calling the provided function whenever the callback function
  * for any of those signals is called
@@ -356,5 +383,6 @@ extern void connman_manager_free(connman_manager_t *manager);
 extern void set_wca_support_connman_update_callbacks(
     wca_support_connman_update_callbacks *callbacks);
 
+extern guint connman_manager_get_p2p_connected_service_count(GSList *service_list);
 #endif /* CONNMAN_MANAGER_H_ */
 
diff --git a/src/connman_service.c b/src/connman_service.c
index 2724c91..8d398e6 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -27,10 +27,17 @@
 #include "logging.h"
 #include "common.h"
 #include "connectionmanager_service.h"
+#include "wfdsie/wfdinfoelemwrapper.h"
+#include "wifi_p2p_service.h"
 
 /* gdbus default timeout is 25 seconds */
 #define DBUS_CALL_TIMEOUT   (120 * 1000)
 
+static bool subscibed_for_diagnostiecs = false;
+
+#define Bit1		0x02
+#define Bit0		0x01
+
 /**
  * Check if the type of the service is wifi (see header for API details)
  */
@@ -259,6 +266,88 @@ gboolean connman_service_connect(connman_service_t *service,
 	return TRUE;
 }
 
+/**
+ * Asynchronous connect callback for a remote "connect" call for peer
+ */
+
+static void peer_connect_callback(GDBusConnection *connection, GAsyncResult *res,
+                             gpointer user_data)
+{
+	GError *error = NULL;
+	struct cb_data *cbd = user_data;
+	connman_service_t *service = cbd->user;
+	connman_service_connect_cb cb = cbd->cb;
+	gboolean ret = FALSE;
+
+	if (NULL == service->cancellable ||
+	        g_cancellable_is_cancelled(service->cancellable))
+	{
+		if (service->cancellable != NULL)
+		{
+			g_object_unref(service->cancellable);
+			service->cancellable = NULL;
+		}
+
+		if (cb != NULL)
+		{
+			cb(ret, cbd->data);
+		}
+
+		g_free(cbd);
+		return;
+	}
+
+	ret = connman_interface_peer_call_connect_finish((ConnmanInterfacePeer *)service->remote, res,
+	        &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_P2P_SERVICE_CONNECT_ERROR, error->message);
+
+		/* If the error is "AlreadyConnected" its not an error */
+		if (NULL != g_strrstr(error->message, "AlreadyConnected") ||
+			NULL != g_strrstr(error->message, "Operation aborted"))
+		{
+			ret = TRUE;
+		}
+
+		g_error_free(error);
+	}
+
+	if (cb != NULL)
+	{
+		cb(ret, cbd->data);
+	}
+
+	g_free(cbd);
+
+	g_object_unref(service->cancellable);
+	service->cancellable = NULL;
+}
+
+/**
+ * Connect to a remote connman peer (see header for API details)
+ */
+
+gboolean connman_peer_connect(connman_service_t *service,
+                                 connman_service_connect_cb cb, gpointer user_data)
+{
+	struct cb_data *cbd;
+
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	service->disconnecting = FALSE;
+	cbd = cb_data_new(cb, user_data);
+	cbd->user = service;
+	service->cancellable = g_cancellable_new();
+
+	connman_interface_peer_call_connect((ConnmanInterfacePeer *)service->remote, service->cancellable,
+	                                    (GAsyncReadyCallback) peer_connect_callback, cbd);
+	return TRUE;
+}
 
 /**
  * Disconnect from a remote connman service (see header for API details)
@@ -286,6 +375,32 @@ gboolean connman_service_disconnect(connman_service_t *service)
 	return TRUE;
 }
 
+/**
+ * Disconnect from a remote connman peer (see header for API details)
+ */
+
+gboolean connman_peer_disconnect(connman_service_t *service)
+{
+	if (NULL == service)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	service->disconnecting = TRUE;
+	connman_interface_peer_call_disconnect_sync((ConnmanInterfacePeer *)service->remote, NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_P2P_SERVICE_DISCONNECT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
 /**
  * Remove a remote connman service (see header for API details)
  */
@@ -1072,6 +1187,22 @@ static void connman_service_advance_state(connman_service_t *service,
 		}
 #endif
 	}
+
+	if (!subscibed_for_diagnostiecs && service->type == CONNMAN_SERVICE_TYPE_P2P
+				&& !g_strcmp0(service->state, "ready") && is_connected_peer())
+	{
+		connman_technology_t *technology = connman_manager_find_wifi_technology(manager);
+		connman_technology_update_properties(technology);
+		subscibed_for_diagnostiecs = true;
+	}
+	else if (subscibed_for_diagnostiecs && service->type == CONNMAN_SERVICE_TYPE_P2P
+				&& !g_strcmp0(service->state, "disconnect") && !is_connected_peer())
+	{
+		connman_technology_t *technology = connman_manager_find_wifi_technology(manager);
+		connman_technology_update_properties(technology);
+		subscibed_for_diagnostiecs = false;
+	}
+
 	WCALOG_DEBUG("connman_service_advance_state exit");
 }
 /**
@@ -1296,6 +1427,19 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 			                               "P2PPersistentReceived");
 		}
 	}
+	else if (!g_strcmp0(property, "PeerAdded"))
+	{
+		connman_service_t *connected_p2p_service = NULL;
+
+		if(manager)
+			connected_p2p_service = connman_manager_get_connected_service(manager->p2p_services);
+
+		if (NULL != service->handle_p2p_request_fn && connected_p2p_service)
+		{
+			service->handle_p2p_request_fn((gpointer)service, 0, NULL, NULL,
+			                               "PeerAdded");
+		}
+	}
 	else if (!g_strcmp0(property, "IPv6"))
 	{
 		connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
@@ -1307,6 +1451,16 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 		connectionmanager_send_status_to_subscribers();
 	}
 
+	else if (!g_strcmp0(property, "IPv4"))
+	{
+		if (service->type == CONNMAN_SERVICE_TYPE_P2P && service->peer.group_owner) {
+			if (NULL != service->handle_property_change_fn)
+			{
+				(service->handle_property_change_fn)((gpointer) service, "IPv4", va);
+			}
+		}
+	}
+
 	g_variant_unref(va);
 }
 
@@ -1337,7 +1491,7 @@ gboolean connman_service_reject_peer(connman_service_t *service)
 
 	GError *error = NULL;
 
-	connman_interface_service_call_reject_peer_sync(service->remote, NULL, &error);
+	connman_interface_peer_call_reject_peer_sync((ConnmanInterfacePeer *)service->remote, NULL, &error);
 
 	if (error)
 	{
@@ -1445,6 +1599,29 @@ void connman_service_update_display_name(connman_service_t *service)
 	WCALOG_INFO("SSID_CONVERSION", 0, "Convert result: service->ssid: %s --> service->display_name: %s", service->ssid, service->display_name);
 }
 
+static void p2p_parse_wfd_dev_info(unsigned char *wfd_subelems, int len,
+					struct peer* peer)
+{
+	if(len < 9)
+		return;
+
+	//Subelement ID is 0 for WFD Device Infomation
+	if(wfd_subelems[0] != 0x00)
+		return;
+
+	//Length field is 6 for WFD Device Information
+	if(wfd_subelems[1] != 0x00 && wfd_subelems[2] != 0x06)
+		return;
+
+	peer->wfd_enabled = TRUE;
+	peer->wfd_devtype = wfd_subelems[4] & (Bit0|Bit1);
+	peer->wfd_sessionavail = (wfd_subelems[4] >> 4) & (Bit0|Bit1);
+	peer->wfd_cpsupport = wfd_subelems[3] & Bit0;
+	peer->wfd_rtspport = (wfd_subelems[5] << 8) + wfd_subelems[6];
+
+	return;
+}
+
 /**
  * Update service properties from the supplied variant  (see header for API details)
  */
@@ -1508,7 +1685,7 @@ void connman_service_update_properties(connman_service_t *service,
 			{
 				service->type = CONNMAN_SERVICE_TYPE_ETHERNET;
 			}
-			else if (!g_strcmp0(v, "Peer"))
+			else if (!g_strcmp0(v, "Peer") || (!g_strcmp0(v, "peer")))
 			{
 				service->type = CONNMAN_SERVICE_TYPE_P2P;
 			}
@@ -1562,6 +1739,106 @@ void connman_service_update_properties(connman_service_t *service,
 		{
 			service->online_checking = g_variant_get_boolean(val);
 		}
+		else if (!g_strcmp0(key, "P2P"))
+		{
+			gsize j;
+			service->peer.wfd_enabled = FALSE;
+
+			for (j = 0; j < g_variant_n_children(val); j++)
+			{
+				GVariant *p2p_property = g_variant_get_child_value(val, j);
+				GVariant *p2p_key_v = g_variant_get_child_value(p2p_property, 0);
+				GVariant *p2p_val_v = g_variant_get_child_value(p2p_property, 1);
+				GVariant *p2p_val = g_variant_get_variant(p2p_val_v);
+				const gchar *p2p_key = g_variant_get_string(p2p_key_v, NULL);
+
+				if (!g_strcmp0(p2p_key, "DeviceAddress"))
+				{
+					g_free(service->peer.address);
+					service->peer.address = g_variant_dup_string(p2p_val, NULL);
+				}
+				else if(!g_strcmp0(p2p_key, "DeviceType"))
+				{
+					g_free(service->peer.pri_dev_type);
+					service->peer.pri_dev_type = g_variant_dup_string(p2p_val, NULL);
+				}
+				else if (!g_strcmp0(p2p_key, "GroupOwner"))
+				{
+					service->peer.group_owner = g_variant_get_boolean(p2p_val);
+				}
+				else if (!g_strcmp0(p2p_key, "ConfigMethod"))
+				{
+					service->peer.config_method = g_variant_get_uint16(p2p_val);
+				}
+				else if (!g_strcmp0(p2p_key, "WFDDevType"))
+				{
+					service->peer.wfd_devtype = (connman_wfd_dev_type) g_variant_get_uint16(p2p_val);
+					service->peer.wfd_enabled = TRUE;
+				}
+				else if (!g_strcmp0(p2p_key, "WFDSessionAvail"))
+				{
+					service->peer.wfd_sessionavail = g_variant_get_boolean(p2p_val);
+				}
+				else if (!g_strcmp0(p2p_key, "WFDCPSupport"))
+				{
+					service->peer.wfd_cpsupport = g_variant_get_boolean(p2p_val);
+				}
+				else if (!g_strcmp0(p2p_key, "WFDRtspPort"))
+				{
+					service->peer.wfd_rtspport = g_variant_get_uint32(p2p_val);
+				}
+
+				g_variant_unref(p2p_property);
+				g_variant_unref(p2p_key_v);
+				g_variant_unref(p2p_val_v);
+				g_variant_unref(p2p_val);
+			}
+		}
+		else if (!g_strcmp0(key, "Services"))
+		{
+			WCALOG_DEBUG("in p2p service ");
+			GVariant *service_struct = g_variant_get_child_value(val, 0);
+			GVariant *service_array = g_variant_get_child_value(service_struct, 0);
+
+			gsize j;
+			for (j = 0; j < g_variant_n_children(service_array); j++) {
+				GVariant *service_property = g_variant_get_child_value(service_array, j);
+				GVariant *p2p_service_key_v = g_variant_get_child_value(service_property, 0);
+				GVariant *p2p_service_val_v = g_variant_get_child_value(service_property, 1);
+
+				const gchar *p2p_service_key = g_variant_get_string(p2p_service_key_v, NULL);
+				if (!g_strcmp0(p2p_service_key, "WiFiDisplayIEs")) {
+
+					GVariant *p2p_service_val = g_variant_get_variant(p2p_service_val_v);
+					unsigned long len = g_variant_get_size(p2p_service_val);
+
+					gchar *p2p_service_val_string = g_variant_print (p2p_service_val, TRUE);
+					WCALOG_DEBUG("P2p wifi display service %s size: %lu", p2p_service_val_string, len);
+					g_free(p2p_service_val_string);
+
+					WCALOG_DEBUG("P2p wifi display service %s size: %ld",
+							g_variant_print (p2p_service_val, TRUE), len);
+					InformationElementArray* widiInfoElemArray =
+							(InformationElementArray*) malloc(sizeof(InformationElementArray));
+					widiInfoElemArray->bytes = (uint8_t*) malloc(sizeof(uint8_t)*len);
+					widiInfoElemArray->length = len;
+					memcpy (widiInfoElemArray->bytes, g_variant_get_data(p2p_service_val), len);
+
+					p2p_parse_wfd_dev_info(widiInfoElemArray->bytes,
+							widiInfoElemArray->length, &service->peer);
+
+					free (widiInfoElemArray->bytes);
+					free (widiInfoElemArray);
+					g_variant_unref(p2p_service_val);
+				}
+
+				g_variant_unref(p2p_service_val_v);
+				g_variant_unref(p2p_service_key_v);
+				g_variant_unref(service_property);
+			}
+			g_variant_unref(service_array);
+			g_variant_unref(service_struct);
+		}
 		else if (!g_strcmp0(key, "Address"))
 		{
 			g_free(service->address);
@@ -1711,7 +1988,7 @@ gboolean connman_service_is_online(connman_service_t *service)
  * Create a new connman service instance and set its properties  (see header for API details)
  */
 
-connman_service_t *connman_service_new(GVariant *variant)
+connman_service_t *connman_service_new(GVariant *variant, gboolean p2p)
 {
 	if (NULL == variant)
 	{
@@ -1725,19 +2002,33 @@ connman_service_t *connman_service_new(GVariant *variant)
 		return NULL;
 	}
 
+	GError *error = NULL;
 	GVariant *service_v = g_variant_get_child_value(variant, 0);
 	service->path = g_variant_dup_string(service_v, NULL);
-	service->identifier = strip_prefix(service->path, "/net/connman/service/");
 
-	GError *error = NULL;
+	if(p2p)
+	{
+		service->identifier = strip_prefix(service->path, "/net/connman/peer/");
+		service->remote = (ConnmanInterfaceService *)connman_interface_peer_proxy_new_for_bus_sync(
+                                      G_BUS_TYPE_SYSTEM,
+                                      G_DBUS_PROXY_FLAGS_NONE,
+                                      "net.connman",
+                                      service->path,
+                                      NULL,
+                                      &error);
 
-	service->remote = connman_interface_service_proxy_new_for_bus_sync(
-	                      G_BUS_TYPE_SYSTEM,
-	                      G_DBUS_PROXY_FLAGS_NONE,
-	                      "net.connman",
-	                      service->path,
-	                      NULL,
-	                      &error);
+	}
+	else
+	{
+		service->identifier = strip_prefix(service->path, "/net/connman/service/");
+		service->remote = connman_interface_service_proxy_new_for_bus_sync(
+	                              G_BUS_TYPE_SYSTEM,
+	                              G_DBUS_PROXY_FLAGS_NONE,
+	                              "net.connman",
+	                              service->path,
+	                              NULL,
+	                              &error);
+	}
 
 	g_variant_unref(service_v);
 
@@ -1751,7 +2042,9 @@ connman_service_t *connman_service_new(GVariant *variant)
 	}
 
 	g_dbus_proxy_set_default_timeout(service->remote, DBUS_CALL_TIMEOUT);
+	g_dbus_proxy_set_default_timeout((GDBusProxy *)service->remote, DBUS_CALL_TIMEOUT);
 	service->iprule_added = false;
+
 	service->sighandler_id = g_signal_connect_data(G_OBJECT(service->remote),
 	                         "property-changed",
 	                         G_CALLBACK(property_changed_cb), service, NULL, 0);
@@ -1766,7 +2059,6 @@ connman_service_t *connman_service_new(GVariant *variant)
 	return service;
 }
 
-
 /**
  * Free the connman service instance  (see header for API details)
  */
@@ -1838,6 +2130,7 @@ void connman_service_free(gpointer data, gpointer user_data)
 
 	g_free(service->peer.address);
 	g_free(service->peer.service_discovery_response);
+	service->peer.service_discovery_response = NULL;
 
 	if (service->bss)
 	{
@@ -1862,5 +2155,6 @@ void connman_service_free(gpointer data, gpointer user_data)
 	service->remote = NULL;
 
 	g_free(service);
+	service=NULL;
 }
 
diff --git a/src/connman_service.h b/src/connman_service.h
index ce2954d..c76ff33 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -95,6 +95,7 @@ typedef struct bssinfo
 typedef struct peer
 {
 	gchar *address;
+	gchar *pri_dev_type;
 	gboolean group_owner;
 	gboolean wfd_enabled;
 	gboolean wfd_sessionavail;
@@ -422,7 +423,7 @@ extern void connman_service_register_p2p_requests_cb(connman_service_t *service,
  *
  * @param[IN] variant List of properties for a new service
  */
-extern connman_service_t *connman_service_new(GVariant *variant);
+extern connman_service_t *connman_service_new(GVariant *variant, gboolean p2p);
 
 /**
  * Free the connman service instance
@@ -448,6 +449,10 @@ extern gboolean connman_service_set_passphrase(connman_service_t *service,
 
 extern gboolean connman_service_is_connected(connman_service_t *service);
 extern gboolean connman_service_is_online(connman_service_t *service);
+extern gboolean connman_peer_connect(connman_service_t *service,
+                                 connman_service_connect_cb cb, gpointer user_data);
+extern gboolean connman_peer_disconnect(connman_service_t *service);
+
 
 #endif /* CONNMAN_SERVICE_H_ */
 
diff --git a/src/connman_service_discovery.c b/src/connman_service_discovery.c
index 9b83aa6..201be71 100644
--- a/src/connman_service_discovery.c
+++ b/src/connman_service_discovery.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2019 LG Electronics, Inc.
+// Copyright (c) 2013-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -23,8 +23,10 @@
 
 #include "connman_service_discovery.h"
 #include "connman_manager.h"
+#include "common.h"
 
 #include "logging.h"
+#include "wifi_p2p_service.h"
 
 static ConnmanInterfaceServiceDiscovery *sd = NULL;
 
@@ -59,8 +61,8 @@ discovery_response_cb(ConnmanInterfaceManager *proxy, const gchar *address,
 
 	GVariantIter *iter;
 	guchar byte;
-	g_variant_get(tlv, "ay", &iter);
-	gsize tlvstr_len = g_variant_n_children(tlv) * 3;
+	g_variant_get((GVariant *)tlv, "ay", &iter);
+	gsize tlvstr_len = g_variant_n_children((GVariant *)tlv) * 3;
 	tlvstr = g_new0(gchar, tlvstr_len);
 
 	while (g_variant_iter_loop(iter, "y", &byte))
@@ -78,6 +80,20 @@ discovery_response_cb(ConnmanInterfaceManager *proxy, const gchar *address,
 	}
 
 	g_variant_iter_free(iter);
+
+	for (listnode = manager->p2p_services; NULL != listnode ;
+	        listnode = listnode->next)
+	{
+		service = (connman_service_t *)(listnode->data);
+
+		if (!g_strcmp0(service->peer.address, address))
+		{
+			g_free(service->peer.service_discovery_response);
+			service->peer.service_discovery_response = g_strdup(tlvstr);
+			send_peer_information_to_subscribers();
+		}
+	}
+
 	g_free(tlvstr);
 }
 
diff --git a/src/connman_service_discovery.h b/src/connman_service_discovery.h
index 45ed321..9c2367e 100644
--- a/src/connman_service_discovery.h
+++ b/src/connman_service_discovery.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2013-2018 LG Electronics, Inc.
+// Copyright (c) 2013-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -32,7 +32,8 @@
 typedef enum
 {
 	CONNMAN_SERVICE_TYPE_UPNP = 0,
-	CONNMAN_SERVICE_TYPE_BONJOUR
+	CONNMAN_SERVICE_TYPE_BONJOUR,
+	CONNMAN_SERVICE_TYPE_WiFiDisplayIEs
 } connman_service_type;
 
 extern gboolean connman_service_discovery_request(const connman_service_type
diff --git a/src/connman_technology.c b/src/connman_technology.c
index 9b66898..ac98fb4 100644
--- a/src/connman_technology.c
+++ b/src/connman_technology.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
  *
  */
 
+#include "common.h"
 #include "connman_technology.h"
 #include "connman_manager.h"
 #include "logging.h"
@@ -403,6 +404,7 @@ gboolean connman_technology_set_wfd(connman_technology_t *technology,
 		return FALSE;
 	}
 
+#ifdef CONNMAN_VER_1_1
 	GError *error = NULL;
 
 	connman_interface_technology_call_set_property_sync(technology->remote,
@@ -416,6 +418,7 @@ gboolean connman_technology_set_wfd(connman_technology_t *technology,
 		g_error_free(error);
 		return FALSE;
 	}
+#endif
 
 	technology->wfd = state;
 	return TRUE;
@@ -432,7 +435,7 @@ gboolean connman_technology_set_wfd_devtype(connman_technology_t *technology,
 	{
 		return FALSE;
 	}
-
+#ifdef CONNMAN_VER_1_1
 	GError *error = NULL;
 
 	connman_interface_technology_call_set_property_sync(technology->remote,
@@ -446,11 +449,163 @@ gboolean connman_technology_set_wfd_devtype(connman_technology_t *technology,
 		g_error_free(error);
 		return FALSE;
 	}
-
+#endif
 	technology->wfd_devtype = devtype;
 	return TRUE;
 }
 
+/**
+ * Set WFDSessionAvail (see header for API details)
+ */
+
+gboolean connman_technology_set_wfd_sessionavail(connman_technology_t
+        *technology, const gboolean sessionavail)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+#ifdef CONNMAN_VER_1_1
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "WFDSessionAvail",
+	        g_variant_new_variant(g_variant_new_boolean(sessionavail)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_WFD_SESSION_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+#endif
+	technology->wfd_sessionavail = sessionavail;
+	return TRUE;
+}
+
+/**
+ * Set WFDCPSupport (see header for API details)
+ */
+
+gboolean connman_technology_set_wfd_cpsupport(connman_technology_t *technology,
+        const gboolean cpsupport)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+#ifdef CONNMAN_VER_1_1
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "WFDCPSupport",
+	        g_variant_new_variant(g_variant_new_boolean(cpsupport)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_WFD_CPSUPPORT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+#endif
+	technology->wfd_cpsupport = cpsupport;
+	return TRUE;
+}
+
+/**
+ * Set WFDRtspPort (see header for API details)
+ */
+
+gboolean connman_technology_set_wfd_rtspport(connman_technology_t *technology,
+        const guint32 rtspport)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+#ifdef CONNMAN_VER_1_1
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "WFDRtspPort",
+	        g_variant_new_variant(g_variant_new_uint32(rtspport)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_WFD_RTSPPORT_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+#endif
+	technology->wfd_rtspport = rtspport;
+	return TRUE;
+}
+
+/**
+ * Set P2P listen state (see header for API details)
+ */
+
+gboolean connman_technology_set_p2p_listen_state(connman_technology_t
+        *technology, gboolean state)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "P2PListen",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_P2P_LISTEN_ERROR, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->p2p_listen = state;
+	return TRUE;
+}
+
+/**
+ * Set P2P persistent mode (see header for API details)
+ */
+
+gboolean connman_technology_set_p2p_persistent_mode(connman_technology_t
+        *technology, gboolean state)
+{
+	if (NULL == technology)
+	{
+		return FALSE;
+	}
+
+	GError *error = NULL;
+
+	connman_interface_technology_call_set_property_sync(technology->remote,
+	        "P2PPersistent",
+	        g_variant_new_variant(g_variant_new_boolean(state)),
+	        NULL, &error);
+
+	if (error)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_TECHNOLOGY_SET_P2P_PERSISTENT_ERROR,
+		                      error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	technology->persistent_mode = state;
+	return TRUE;
+}
+
 /**
  * Callback for the technology scan call after it finishes
  */
@@ -503,9 +658,24 @@ gboolean connman_technology_scan_network(connman_technology_t *technology,
 	}
 
 	technology->calls_pending += 1;
-	connman_interface_technology_call_scan(technology->remote,
-	                                       NULL, connman_technology_scan_callback,
-	                                       (gpointer)technology);
+	if (p2p)
+	{
+		connman_technology_t *p2p_tech = connman_manager_find_p2p_technology(manager);
+
+		if (!p2p_tech)
+		{
+			return FALSE;
+		}
+		connman_interface_technology_call_scan(p2p_tech->remote,
+					NULL, connman_technology_scan_callback,
+					(gpointer)technology);
+	}
+	else
+	{
+		connman_interface_technology_call_scan(technology->remote,
+					NULL, connman_technology_scan_callback,
+					(gpointer)technology);
+	}
 
 	return TRUE;
 }
@@ -662,6 +832,10 @@ static void set_property_value(connman_technology_t *technology,
 	{
 		technology->p2p_listen = g_variant_get_boolean(val);
 	}
+	else if (!g_strcmp0(key, "P2PListenChannel"))
+	{
+		technology->p2p_listen_channel= g_variant_get_uint32(val);
+	}
 	else if (!g_strcmp0(key, "P2PPersistent"))
 	{
 		technology->persistent_mode = g_variant_get_boolean(val);
diff --git a/src/connman_technology.h b/src/connman_technology.h
index 0f44037..04be7c4 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -56,6 +56,7 @@ typedef struct connman_technology
 	gboolean wfd;
 	gboolean p2p_listen;
 	gboolean persistent_mode;
+	guint32 p2p_listen_channel;
 	gboolean wfd_sessionavail;
 	gboolean wfd_cpsupport;
 	gboolean legacy_scan;
diff --git a/src/errors.h b/src/errors.h
index e4a2e16..724946c 100644
--- a/src/errors.h
+++ b/src/errors.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -34,6 +34,7 @@
 #define WCA_API_ERROR_PIN_MISSING       15
 #define WCA_API_ERROR_OUT_OF_RANGE      16
 
+#define WCA_API_ERROR_P2P_TECH_UNAVAILABLE 17
 
 #define WCA_API_ERROR_INTERNAL          100
 #define WCA_API_ERROR_ALREADY_CONNECTING    101
diff --git a/src/logging.h b/src/logging.h
index 724ff2a..7260c44 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -106,6 +106,8 @@ extern PmLogContext gLogContext;
 #define MSGID_MANAGER_CHANGE_SAVED_SERVICE_ERROR        "MGR_CHANGE_SAVED_SERVICE_ERROR"
 #define MSGID_MANAGER_FIELDS_ERROR                      "MGR_FIELDS_ERROR"
 #define MSGID_MANAGER_SET_WOL_WOWL_ERROR                "MGR_SET_WOL_WOWL_ERR"
+#define MSGID_MANAGER_P2P_SRV_REGISTER_ERROR            "MGR_P2P_SRV_REG_ERR"
+#define MSGID_MANAGER_P2P_SRV_UNREGISTER_ERROR          "MGR_P2P_SRV_UNREG_ERR"
 
 /** connman_service.c */
 #define MSGID_SERVICE_CONNECT_ERROR                     "SRVC_CONNECT_ERR"
@@ -202,6 +204,8 @@ extern PmLogContext gLogContext;
 #define MSGID_P2P_DELETE_PROFILE                        "P2P_DELETE_PROFILE"
 #define MSGID_P2P_METHODS_LUNA_ERROR                    "P2P_METHODS_LUNA_ERR"
 #define MSGID_SETTINGS_SERVICE_REG_ERROR                "SETTINGS_SRVC_REG_ERR"
+#define MSGID_P2P_SERVICE_CONNECT_ERROR                 "P2P_SRVC_CONNECT_ERR"
+#define MSGID_P2P_SERVICE_DISCONNECT_ERROR              "P2P_SRVC_DISCONNECT_ERR"
 
 /* lunaservice_utils.c */
 #define MSGID_LUNA_CREATE_JSON_FAILED                   "LUNA_CREATE_JSON_FAILED"
diff --git a/src/wfdsie/CMakeLists.txt b/src/wfdsie/CMakeLists.txt
new file mode 100644
index 0000000..eff8ef2
--- /dev/null
+++ b/src/wfdsie/CMakeLists.txt
@@ -0,0 +1,38 @@
+# @@@LICENSE
+#
+# Copyright (c) 2021 LG Electronics, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# LICENSE@@@
+
+#
+# webos-connman-adapter/src/wfdsie/CMakeLists.txt
+
+project(libwfdsie CXX)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -g")
+
+include_directories(${CMAKE_SOURCE_DIR}/src/wfdsie)
+
+set(WFDSIE_LIB wfdsie)
+
+set(SRC_LIB
+        ${CMAKE_SOURCE_DIR}/src/wfdsie/information-element.cpp ${CMAKE_SOURCE_DIR}/src/wfdsie/wfdinfoelemwrapper.cpp
+    )
+
+add_library(${WFDSIE_LIB} SHARED ${SRC_LIB})
+
+webos_build_library(NAME ${WFDSIE_LIB} NOHEADERS)
+
+install(TARGETS ${WFDSIE_LIB} DESTINATION ${WEBOS_INSTALL_LIBDIR})
diff --git a/src/wfdsie/common.h b/src/wfdsie/common.h
new file mode 100644
index 0000000..899fc06
--- /dev/null
+++ b/src/wfdsie/common.h
@@ -0,0 +1,115 @@
+/* @@@LICENSE
+*
+*      Copyright (c) 2021 LG Electronics, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* LICENSE@@@ */
+
+#ifndef _INFORMATION_ELEMENT_COMMON_H_
+#define _INFORMATION_ELEMENT_COMMON_H_
+
+#include <stdint.h>
+
+typedef enum DeviceType {
+    SOURCE,
+    PRIMARY_SINK,
+    SECONDARY_SINK,
+    DUAL_ROLE
+}DeviceType;
+
+typedef enum SubelementId {
+    DEVICE_INFORMATION,
+    ASSOCIATED_BSSID,
+    AUDIO_FORMATS,
+    VIDEO_FORMATS,
+    FORMATS_3D,
+    CONTENT_PROTECTION,
+    COUPLED_SINK_INFORMATION,
+    EXTENDED_CAPABILITY,
+    LOCAL_IP_ADDRESS,
+    SESSION_INFORMATION,
+    ALTERNATIVE_MAC,
+} SubelementId;
+
+typedef struct InformationElementArray {
+    uint8_t *bytes;
+    uint length;
+}InformationElementArray;
+
+typedef struct __attribute__ ((packed)) Subelement {
+    uint8_t id;
+    uint16_t length;
+}Subelement;
+
+typedef struct __attribute__ ((packed)) DeviceinformationBits1 {
+    unsigned device_type : 2; // DeviceType
+    unsigned coupled_sink_support_at_source : 1;
+    unsigned coupled_sink_support_at_sink : 1;
+    unsigned session_availability : 1;
+    unsigned reserved : 1;
+    unsigned service_discovery_support : 1;
+    unsigned preferred_connectivity : 1;
+}DeviceinformationBits1;
+
+typedef struct __attribute__ ((packed)) DeviceinformationBits2 {
+    unsigned hdcp_support : 1;
+    unsigned time_synchronization_support : 1;
+    unsigned audio_unsupport_at_primary_sink : 1;
+    unsigned audio_only_support_at_source : 1;
+    unsigned tdls_persistent_group : 1;
+    unsigned tdls_persistent_group_reinvoke : 1;
+    unsigned reserved2 : 2;
+}DeviceinformationBits2;
+
+typedef struct __attribute__ ((packed)) DeviceInformationSubelement {
+    uint8_t id;
+    uint16_t length;
+    DeviceinformationBits2 field2;
+    DeviceinformationBits1 field1;
+    uint16_t session_management_control_port;
+    uint16_t maximum_throughput;
+}DeviceInformationSubelement;
+
+typedef struct __attribute__ ((packed)) AssociatedBSSIDSubelement {
+    uint8_t id;
+    uint16_t length;
+    uint8_t bssid[6];
+}AssociatedBSSIDSubelement;
+
+typedef struct __attribute__ ((packed)) CoupledSinkStatus {
+    unsigned status : 2;
+    unsigned reserved : 6;
+}CoupledSinkStatus;
+
+typedef struct __attribute__ ((packed)) CoupledSinkInformationSubelement {
+    uint8_t id;
+    uint16_t length;
+    CoupledSinkStatus status;
+    uint8_t mac_address[6];
+}CoupledSinkInformationSubelement;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+Subelement* new_subelement (SubelementId id);
+void delete_subelement(Subelement* subelement);
+#ifdef __cplusplus
+}
+#endif
+
+void InitializeArray(InformationElementArray *infoelementarray, uint len);
+void InitializeArrayinBytes(InformationElementArray *infoelementarray, uint len, uint8_t* in_bytes);
+void DeleteArray(InformationElementArray *infoelementarray);
+
+#endif // _INFORMATION_ELEMENT_COMMON_H_
diff --git a/src/wfdsie/information-element.cpp b/src/wfdsie/information-element.cpp
new file mode 100644
index 0000000..ef7c1f4
--- /dev/null
+++ b/src/wfdsie/information-element.cpp
@@ -0,0 +1,228 @@
+/*
+ * This file is part of Wireless Display Software for Linux OS
+ *
+ * Copyright (C) 2021 Intel Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <assert.h>
+#include <iostream>
+#include <string.h>
+#include <netinet/in.h> // htons()
+
+#include "information-element.h"
+
+const uint16_t SubelementSizearray[] = {
+    9,
+    9,
+    18,
+    24,
+    20,
+    4,
+    10,
+    5,
+    11,
+    3, // variable: 3 + N*24, where N is number of devices connected to GO
+    9,
+};
+
+Subelement* new_subelement (SubelementId id)
+{
+    Subelement* element;
+    switch (id) {
+        case DEVICE_INFORMATION:
+            element = (Subelement*)new DeviceInformationSubelement;
+            break;
+        case ASSOCIATED_BSSID:
+            element = (Subelement*)new AssociatedBSSIDSubelement;
+            break;
+        case COUPLED_SINK_INFORMATION:
+            element = (Subelement*)new CoupledSinkInformationSubelement;
+            break;
+        default:
+            element = NULL;
+            break;
+    }
+
+    if (element) {
+        /* Fill in the common values */
+        memset(element, 0, SubelementSizearray[id]);
+        element->id = id;
+        element->length = htons(SubelementSizearray[id] - 3);
+    }
+
+    return element;
+}
+
+void delete_subelement (Subelement *element)
+{
+    switch (element->id) {
+        case DEVICE_INFORMATION:
+            delete ((DeviceInformationSubelement*)element);
+            break;
+        case ASSOCIATED_BSSID:
+            delete ((AssociatedBSSIDSubelement*)element);
+            break;
+        case COUPLED_SINK_INFORMATION:
+            delete ((CoupledSinkInformationSubelement*)element);
+            break;
+        default:
+            assert(false);
+    }
+}
+
+void InitializeArray(InformationElementArray *infoelementarray, uint len)
+{
+     infoelementarray->bytes = new uint8_t[len];
+     infoelementarray->length = len;
+}
+
+void InitializeArrayinBytes(InformationElementArray *infoelementarray, uint len, uint8_t* in_bytes)
+{
+     infoelementarray->bytes = new uint8_t[len];
+     infoelementarray->length = len;
+     memcpy (infoelementarray->bytes, in_bytes, len);
+}
+
+void DeleteArray(InformationElementArray *infoelementarray)
+{
+        delete[] infoelementarray->bytes;
+}
+
+InformationElement::InformationElement(): length_(0) {}
+
+InformationElement::InformationElement(InformationElementArray* array)
+{
+    uint pos = 0;
+    length_ = array->length;
+
+    while (length_ >= pos + 2) {
+        SubelementId id = (SubelementId)array->bytes[pos];
+        size_t subelement_size = SubelementSizearray[id];
+
+        Subelement *element = new_subelement(id);
+        if (element) {
+            memcpy (element, array->bytes + pos, subelement_size);
+            subelements_[id] = element;
+        }
+        pos += subelement_size;
+    }
+}
+
+InformationElement::~InformationElement()
+{
+    for (auto it = subelements_.begin(); it != subelements_.end(); it++){
+        delete_subelement ((*it).second);
+    }
+    subelements_.clear();
+}
+
+void InformationElement::add_subelement(Subelement* subelement)
+{
+    SubelementId id = (SubelementId)subelement->id;
+    Subelement* old = subelements_[id];
+    if (old){
+        delete_subelement (old);
+    } else {
+        length_ += SubelementSizearray[id];
+    }
+    subelements_[id] = subelement;
+}
+
+DeviceType InformationElement::get_device_type() const
+{
+    auto it = subelements_.find (DEVICE_INFORMATION);
+    if (it == subelements_.end()) {
+        /* FIXME : exception ? */
+        return DUAL_ROLE;
+    }
+
+    auto dev_info = (DeviceInformationSubelement*)(*it).second;
+    return (DeviceType)dev_info->field1.device_type;
+}
+
+int InformationElement::get_rtsp_port() const
+{
+    auto it = subelements_.find (DEVICE_INFORMATION);
+    if (it == subelements_.end()) {
+       /* FIXME : exception ? */
+       return -1;
+    }
+
+    auto dev_info = (DeviceInformationSubelement*)(*it).second;
+    return dev_info->session_management_control_port;
+}
+
+bool InformationElement::is_session_available() const
+{
+	bool ret = false;
+    auto it = subelements_.find (DEVICE_INFORMATION);
+    if (it == subelements_.end()) {
+       /* FIXME : exception ? */
+       return ret;
+    }
+
+    auto dev_info = (DeviceInformationSubelement*)(*it).second;
+    ret = dev_info->field1.session_availability ? true : false;
+	return ret;
+}
+
+bool InformationElement::is_cp_supported() const
+{
+	bool ret = false;
+    auto it = subelements_.find (DEVICE_INFORMATION);
+    if (it == subelements_.end()) {
+       /* FIXME : exception ? */
+       return ret;
+    }
+
+    auto dev_info = (DeviceInformationSubelement*)(*it).second;
+    ret = dev_info->field2.hdcp_support ? true : false;
+	return ret;
+}
+
+InformationElementArray* InformationElement::serialize () const
+{
+    uint8_t pos = 0;
+    InformationElementArray* array = new InformationElementArray();
+    InitializeArray(array, length_);
+    for (auto it = subelements_.begin(); it != subelements_.end(); it++) {
+        Subelement* element = (*it).second;
+        memcpy (array->bytes + pos, element, SubelementSizearray[element->id]);
+        pos += SubelementSizearray[element->id];
+    }
+
+    return array;
+}
+
+std::string InformationElement::to_string() const
+{
+    std::string ret;
+
+    InformationElementArray* array = serialize ();
+
+    for (size_t i = 0; i < array->length; i++) {
+        char hex[3];
+        sprintf(hex,"%02X", array->bytes[i]);
+        ret += hex;
+    }
+
+	DeleteArray(array);
+	delete array;
+
+    return ret;
+}
diff --git a/src/wfdsie/information-element.h b/src/wfdsie/information-element.h
new file mode 100644
index 0000000..f5be0f0
--- /dev/null
+++ b/src/wfdsie/information-element.h
@@ -0,0 +1,53 @@
+/*
+ * This file is part of Wireless Display Software for Linux OS
+ *
+ * Copyright (C) 2021 Intel Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef INFORMATION_ELEMENT_H_
+#define INFORMATION_ELEMENT_H_
+
+#include <cstring>
+#include <map>
+#include <memory>
+#include <string>
+#include <stdint.h>
+#include "common.h"
+
+class InformationElement {
+public:
+	InformationElement();
+	InformationElement(InformationElementArray *array);
+	virtual ~InformationElement();
+
+	void add_subelement(Subelement* subelement);
+	DeviceType get_device_type() const;
+	int get_rtsp_port() const;
+	bool is_session_available() const;
+	bool is_cp_supported() const;
+
+	InformationElementArray* serialize () const;
+	std::string to_string() const;
+
+private:
+
+	uint length_;
+	std::map<SubelementId, Subelement*> subelements_;
+};
+
+#endif // INFORMATION_ELEMENT_H_
diff --git a/src/wfdsie/wfdinfoelemwrapper.cpp b/src/wfdsie/wfdinfoelemwrapper.cpp
new file mode 100644
index 0000000..330e88c
--- /dev/null
+++ b/src/wfdsie/wfdinfoelemwrapper.cpp
@@ -0,0 +1,63 @@
+/* @@@LICENSE
+*
+*      Copyright (c) 2021 LG Electronics, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* LICENSE@@@ */
+
+#include "information-element.h"
+#include "wfdinfoelemwrapper.h"
+
+extern "C" {
+        InformationElement* newInformationElement() {
+            return new InformationElement();
+        }
+
+        InformationElement* newInformationElementArray(InformationElementArray* array) {
+            return new InformationElement(array);
+        }
+
+        void wfdinfoelem_add_subelement(InformationElement* wfdinfoelem, Subelement* subelement) {
+            wfdinfoelem->add_subelement(subelement);
+        }
+
+        DeviceType wfdinfoelem_get_device_type(InformationElement* wfdinfoelem) {
+            return wfdinfoelem->get_device_type();
+        }
+
+        int wfdinfoelem_get_rtsp_port(InformationElement* wfdinfoelem) {
+            return wfdinfoelem->get_rtsp_port();
+        }
+
+        bool wfdinfoelem_is_session_available(InformationElement* wfdinfoelem) {
+            return wfdinfoelem->is_session_available();
+        }
+
+        bool wfdinfoelem_is_cp_supported(InformationElement* wfdinfoelem) {
+            return wfdinfoelem->is_cp_supported();
+        }
+
+        InformationElementArray* wfdinfoelem_serialize (InformationElement* wfdinfoelem) {
+            return wfdinfoelem->serialize();
+        }
+
+        void deleteInformationElement(InformationElement* v) {
+            delete v;
+        }
+
+        void deleteInformationElementArray(InformationElementArray* v) {
+            DeleteArray(v);
+            delete v;
+        }
+}
diff --git a/src/wfdsie/wfdinfoelemwrapper.h b/src/wfdsie/wfdinfoelemwrapper.h
new file mode 100644
index 0000000..0806553
--- /dev/null
+++ b/src/wfdsie/wfdinfoelemwrapper.h
@@ -0,0 +1,47 @@
+/* @@@LICENSE
+*
+*      Copyright (c) 2021 LG Electronics, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* LICENSE@@@ */
+
+#ifndef __WFDINFOELEMWRAPPER_H
+#define __WFDINFOELEMWRAPPER_H
+#include "common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct InformationElement InformationElement;
+
+InformationElement* newInformationElement();
+InformationElement* newInformationElementArray(InformationElementArray* array);
+
+void wfdinfoelem_add_subelement(InformationElement* wfdinfoelem, Subelement* subelement);
+DeviceType wfdinfoelem_get_device_type(InformationElement* wfdinfoelem);
+int wfdinfoelem_get_rtsp_port(InformationElement* wfdinfoelem);
+bool wfdinfoelem_is_session_available(InformationElement* wfdinfoelem);
+bool wfdinfoelem_is_cp_supported(InformationElement* wfdinfoelem);
+InformationElementArray* wfdinfoelem_serialize (InformationElement* wfdinfoelem);
+void deleteInformationElement(InformationElement* v);
+void deleteInformationElementArray(InformationElementArray* v);
+
+InformationElementArray* serialize (InformationElement* wfdinfoelem);
+InformationElementArray* wfdinfoelem_serialize (InformationElement* wfdinfoelem);
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __WFDINFOELEMWRAPPER_H
diff --git a/src/wifi_p2p_service.c b/src/wifi_p2p_service.c
new file mode 100644
index 0000000..a2a04ac
--- /dev/null
+++ b/src/wifi_p2p_service.c
@@ -0,0 +1,4247 @@
+/* @@@LICENSE
+*
+* Copyright (c) 2021 LG Electronics, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* LICENSE@@@ */
+
+/**
+ * @file  wifi_p2p_service.c
+ *
+ * @brief Implements the com.webos.service.wifi/p2p service API with using connman in the backend.
+ */
+
+#include <glib.h>
+#include <stdbool.h>
+#include <time.h>
+#include <string.h>
+#include <pbnjson.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <linux/if.h>
+
+#include "wifi_service.h"
+#include "wifi_profile.h"
+#include "wifi_setting.h"
+#include "wifi_p2p_service.h"
+#include "wifi_scan.h"
+#include "connman_manager.h"
+#include "connman_service.h"
+#include "connman_agent.h"
+#include "connman_service_discovery.h"
+#include "lunaservice_utils.h"
+#include "common.h"
+#include "connectionmanager_service.h"
+#include "logging.h"
+#include "errors.h"
+#include "wfdsie/wfdinfoelemwrapper.h"
+
+LSHandle *localpLSHandle = NULL;
+bool subscribed_for_device_name = false;
+static pthread_mutex_t callback_sequence_lock = PTHREAD_MUTEX_INITIALIZER;
+static gboolean group_added_by_p2p_request = FALSE;
+static gboolean group_added_pending = FALSE;
+
+static char* p2p_get_state_prev_response = NULL;
+
+void manager_groups_changed_callback(gpointer data, gboolean group_added);
+void setPropertyUpdateCallback(connman_service_t *service);
+
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+
+@brief Manages connections to WiFi Direct (P2P) networks.
+
+Each call has a standard return in the case of a failure, as follows:
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | False to inidicate an error
+errorCode | Yes | Integer | Error code
+errorText | Yes | String | Error description
+
+@{
+@}
+*/
+
+
+/**
+ *  @brief Check whether p2p is enabled or not.
+ *
+ *  @return TRUE if P2P is enabled. FALSE otherwise.
+ */
+
+gboolean is_p2p_enabled(void)
+{
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+	return (NULL != technology) && technology->powered;
+}
+
+/**
+ * @brief Enable or disable P2P functionality by setting it's power state. This will not
+ * turn of WiFi functionality but just P2P.
+ *
+ * @param state TRUE if P2P should be powered off. FALSE otherwise.
+ * @return TRUE if the operation was successfull. FALSE otherwise.
+ */
+
+static gboolean set_p2p_power_state(gboolean state)
+{
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (technology)
+	{
+		return connman_technology_set_powered(technology, state, NULL);
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+
+/**
+ *  @brief Check if the P2P listen state is enabled or not.
+ *
+ *  @return TRUE if P2P listen state is enabled. FALSE otherwise.
+ */
+
+gboolean is_p2p_listen_state_enabled(void)
+{
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+	return (NULL != technology) && technology->p2p_listen;
+}
+
+/**
+ *  @brief Enable or disable the P2P listen state.
+ *
+ *  @param state TRUE if P2P listen state should be enabled. FALSE otherwise.
+ *  @return TRUE if the operation was successfull. FALSE otherwise.
+ */
+
+static gboolean set_p2p_listen_state(gboolean state)
+{
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (technology)
+	{
+		return connman_technology_set_p2p_listen_state(technology, state);
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+
+/**
+ *  @brief Check if the P2P persistent mode is anbled or not.
+ *
+ *  @return TRUE if the P2P persistent mode is enabled. FALSE otherwise
+ */
+
+gboolean is_p2p_persistent_mode_enabled(void)
+{
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+	return (NULL != technology) && technology->persistent_mode;
+}
+
+/**
+ *  @brief Enable or disable the P2P persistent mode.
+ *
+ *  @param state TRUE to enable the P2P persistent mode. FALSE otherwise.
+ *  @return TRUE if the operation was successfull. FALSE otherwise.
+ */
+
+static gboolean set_p2p_persistent_mode(gboolean state)
+{
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (technology)
+	{
+		return connman_technology_set_p2p_persistent_mode(technology, state);
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+
+/**
+ * @brief Find a specific peer by it's address for the list of internally stored peer
+ * objects.
+ *
+ * @param address The address of the peer to find. It's simply it's MAC address in the
+ * format HH:HH:HH:HH:HH:HH (where H is one hex digit).
+ * @return If a peer with the supplied address is found the object representation of the
+ * peer. NULL otherwise.
+ */
+
+static connman_service_t *find_peer_by_address(const gchar *address)
+{
+	connman_service_t *service = NULL;
+	GSList *listnode = NULL;
+
+	for (listnode = manager->p2p_services; NULL != listnode ;
+	        listnode = listnode->next)
+	{
+		service = (connman_service_t *)(listnode->data);
+
+		if (!g_strcmp0(service->peer.address, address))
+		{
+			return service;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * @brief Find a group by it's name (SSID) from the internal stored list of group objects.
+ *
+ * @param ssid SSID of the group to search for.
+ * @return If a group for the supplied SSID is found the object representation of the
+ * group. NULL otherwise.
+ */
+
+static connman_group_t *find_group_by_name(const char *ssid)
+{
+	connman_group_t *group = NULL;
+	GSList *listnode = NULL;
+
+	for (listnode = manager->groups; NULL != listnode ; listnode = listnode->next)
+	{
+		group = (connman_group_t *)(listnode->data);
+
+		if (!g_strcmp0(group->name, ssid))
+		{
+			return group;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * @brief Append the requested peer to the JSON object.
+ *
+ * @param reply JSON object to which the requested peeer should be appended,
+ * if the device address is matched.
+ */
+
+static void append_requested_peer(jvalue_ref *reply,
+                                  const gchar *device_address)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	GSList *listnode;
+	jvalue_ref wfd_info = jobject_create();
+
+	for (listnode = manager->p2p_services; listnode ; listnode = listnode->next)
+	{
+		connman_service_t *service = (connman_service_t *)(listnode->data);
+
+		if (!g_strcmp0(device_address, service->peer.address) &&
+		        service->peer.wfd_enabled)
+		{
+			jobject_put(*reply, J_CSTR_TO_JVAL("deviceName"),
+			            jstring_create(service->name));
+
+			switch (service->peer.wfd_devtype)
+			{
+				case CONNMAN_WFD_DEV_TYPE_SOURCE:
+					jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+					            jstring_create("source"));
+					break;
+
+				case CONNMAN_WFD_DEV_TYPE_PRIMARY_SINK:
+					jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+					            jstring_create("primary-sink"));
+					break;
+
+				case CONNMAN_WFD_DEV_TYPE_SECONDARY_SINK:
+					jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+					            jstring_create("secondary-sink"));
+					break;
+
+				case CONNMAN_WFD_DEV_TYPE_DUAL:
+					jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+					            jstring_create("dual-role"));
+					break;
+
+				default:
+					break;
+			}
+
+			jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdSessionAvail"),
+			            jboolean_create(service->peer.wfd_sessionavail));
+			jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdCpSupport"),
+			            jboolean_create(service->peer.wfd_cpsupport));
+			jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdRtspPort"),
+			            jnumber_create_i32(service->peer.wfd_rtspport));
+		}
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("wfdInfo"), wfd_info);
+}
+
+
+static void append_device_type(jvalue_ref *reply, const gchar *pri_dev_type)
+{
+	if (!g_strcmp0(pri_dev_type, "000a0050f2040005"))
+			jobject_put(*reply, J_CSTR_TO_JVAL("deviceType"), jstring_create("phone"));
+	/* 00010050f2000000 is win8.1 or win10, 00010050f2040000 is win8, 00010050f2040001 is win7 */
+	else if (!g_strcmp0(pri_dev_type, "00010050f2000000") ||
+			!g_strcmp0(pri_dev_type, "00010050f2040000") ||
+			!g_strcmp0(pri_dev_type, "00010050f2040001"))
+			jobject_put(*reply, J_CSTR_TO_JVAL("deviceType"), jstring_create("pc"));
+	else
+			jobject_put(*reply, J_CSTR_TO_JVAL("deviceType"),
+					jstring_create(pri_dev_type));
+}
+
+/**
+ * @brief Notify possible subscribers of the com.webos.service.wifi/p2p/getp2prequests method about
+ * a new P2P connection request.
+ *
+ * @param data User context data.
+ * @param wpstype The WPS type the other peers requests to use for the connection
+ * establishment.
+ * @param wpspin The WPS pin (if wpstype is WPS_DISPLAY) to use
+ * @param goaddr The address of the group owner.
+ */
+static void notify_new_p2p_request(gpointer data, const int wpstype,
+                                   const gchar *wpspin, const gchar *goaddr,
+                                   const char *signal_name)
+{
+	connman_service_t *service = (connman_service_t *) data;
+
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("deviceName"), jstring_create(service->name));
+	jobject_put(reply, J_CSTR_TO_JVAL("deviceAddress"),
+	            jstring_create(service->peer.address));
+	jobject_put(reply, J_CSTR_TO_JVAL("signalName"), jstring_create(signal_name));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+
+	switch (wpstype)
+	{
+		case WPS_PBC:
+			jobject_put(reply, J_CSTR_TO_JVAL("wpsType"), jstring_create("pbc"));
+			break;
+
+		case WPS_KEYPAD:
+			jobject_put(reply, J_CSTR_TO_JVAL("wpsType"), jstring_create("keypad"));
+			break;
+
+		case WPS_DISPLAY:
+			jobject_put(reply, J_CSTR_TO_JVAL("wpsType"), jstring_create("display"));
+
+			if (wpspin)
+			{
+				jobject_put(reply, J_CSTR_TO_JVAL("wpsPin"), jstring_create(wpspin));
+			}
+
+			break;
+
+		default:
+			if (goaddr)
+			{
+				jobject_put(reply, J_CSTR_TO_JVAL("groupOwner"), jstring_create(goaddr));
+			}
+
+			break;
+	}
+
+	if (service->peer.pri_dev_type)
+		append_device_type(&reply, service->peer.pri_dev_type);
+	append_requested_peer(&reply, service->peer.address);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+
+		WCALOG_INFO(MSGID_P2P_CONNECT_PEER, 0, "Incoming P2P request : %s", payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(localpLSHandle, "/p2p/getp2prequests",
+		                        payload,
+		                        &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+
+	if (wpspin == NULL)
+		manager_groups_changed_callback(NULL, TRUE);
+}
+
+/**
+ * @brief Append peer specific information to a existing JSON object
+ *
+ * @param peer_info JSON object the peer information should be appended to
+ * @param service The service object which represents the peer itself.
+ */
+
+static void append_peer_information(jvalue_ref *peer_info,
+                                    connman_service_t *service)
+{
+	jobject_put(*peer_info, J_CSTR_TO_JVAL("deviceName"),
+	            jstring_create(service->name));
+
+	if (service->peer.address)
+	{
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("deviceAddress"),
+		            jstring_create(service->peer.address));
+	}
+
+	jobject_put(*peer_info, J_CSTR_TO_JVAL("groupOwner"),
+	            jboolean_create(service->peer.group_owner));
+
+	if (service->peer.config_method)
+	{
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("configMethod"),
+		            jnumber_create_i32(service->peer.config_method));
+	}
+
+	if (service->peer.pri_dev_type)
+		append_device_type(peer_info, service->peer.pri_dev_type);
+
+	jobject_put(*peer_info, J_CSTR_TO_JVAL("signalLevel"),
+	            jnumber_create_i32(service->strength));
+
+	if (service->peer.wfd_enabled)
+	{
+		jvalue_ref wfd_info = jobject_create();
+
+		switch (service->peer.wfd_devtype)
+		{
+			case CONNMAN_WFD_DEV_TYPE_SOURCE:
+				jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("source"));
+				break;
+
+			case CONNMAN_WFD_DEV_TYPE_PRIMARY_SINK:
+				jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("primary-sink"));
+				break;
+
+			case CONNMAN_WFD_DEV_TYPE_SECONDARY_SINK:
+				jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("secondary-sink"));
+				break;
+
+			case CONNMAN_WFD_DEV_TYPE_DUAL:
+				jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("dual-role"));
+				break;
+
+			default:
+				break;
+		}
+
+		jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdSessionAvail"),
+		            jboolean_create(service->peer.wfd_sessionavail));
+		jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdCpSupport"),
+		            jboolean_create(service->peer.wfd_cpsupport));
+		jobject_put(wfd_info, J_CSTR_TO_JVAL("wfdRtspPort"),
+		            jnumber_create_i32(service->peer.wfd_rtspport));
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("wfdInfo"), wfd_info);
+	}
+
+	bool connection_state = ((connman_service_get_state(service->state) ==
+	                          CONNMAN_SERVICE_STATE_READY) ||
+	                         (connman_service_get_state(service->state) == CONNMAN_SERVICE_STATE_ONLINE));
+	jobject_put(*peer_info, J_CSTR_TO_JVAL("connected"),
+	            jboolean_create(connection_state));
+
+	if (NULL != service->ipinfo.ipv4.address)
+	{
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("peerIp"),
+		            jstring_create(service->ipinfo.ipv4.address));
+	}
+
+	if (connman_service_get_state(service->state) ==
+	        CONNMAN_SERVICE_STATE_ASSOCIATION)
+	{
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("invited"), jboolean_create(true));
+	}
+
+	if (connman_service_get_state(service->state) == CONNMAN_SERVICE_STATE_FAILURE)
+	{
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("invited"), jboolean_create(false));
+	}
+
+	if (service->peer.service_discovery_response)
+	{
+		/* Send service discovery response only once, and then free the field so that its not sent again */
+		jobject_put(*peer_info, J_CSTR_TO_JVAL("serviceDiscoveryResponse"),
+		            jstring_create(service->peer.service_discovery_response));
+		g_free(service->peer.service_discovery_response);
+		service->peer.service_discovery_response = NULL;
+	}
+}
+
+static gboolean is_connected_state(connman_service_t *service)
+{
+	return ((connman_service_get_state(service->state) == CONNMAN_SERVICE_STATE_READY) ||
+			(connman_service_get_state(service->state) == CONNMAN_SERVICE_STATE_ONLINE));
+}
+
+static void updatepeers_propertychanged_callback()
+{
+	GSList *listnode;
+
+	if(manager)
+	{
+		for (listnode = manager->p2p_services; listnode ; listnode = listnode->next)
+		{
+			connman_service_t *service = (connman_service_t *)(listnode->data);
+			setPropertyUpdateCallback(service);
+		}
+	}
+}
+
+/**
+ * @brief Append all available peers to the JSON object with their specific information.
+ *
+ * @param reply JSON object to which the peers should be appended.
+ */
+
+static gboolean append_peers(jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return FALSE;
+	}
+
+	GSList *listnode;
+	gboolean peer_found = FALSE;
+	gboolean connected_peer_found = FALSE;
+
+	jvalue_ref peer_list = jarray_create(NULL);
+	jvalue_ref connected_peer = jarray_create(NULL);
+
+	for (listnode = manager->p2p_services; listnode ; listnode = listnode->next)
+	{
+		connman_service_t *service = (connman_service_t *)(listnode->data);
+
+		jvalue_ref peer_info = jobject_create();
+
+		append_peer_information(&peer_info, service);
+
+		jvalue_ref peer_list_j = jobject_create();
+		jobject_put(peer_list_j, J_CSTR_TO_JVAL("peerInfo"), peer_info);
+
+		/* FIXME we're doing things which are unrelated to populating the peer
+		 * information as part of the JSON object. This needs to be moved
+		 * somewhere else */
+		connman_service_register_p2p_requests_cb(service, notify_new_p2p_request);
+
+		peer_found = TRUE;
+		if (is_connected_state(service))
+		{
+			jarray_append(connected_peer, peer_list_j);
+			connected_peer_found = TRUE;
+			continue;
+		}
+		else
+			jarray_append(peer_list, peer_list_j);
+	}
+
+	if (connected_peer_found)
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("peers"), connected_peer);
+		j_release(&peer_list);
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("peers"), peer_list);
+		j_release(&connected_peer);
+	}
+
+	return peer_found;
+}
+
+gboolean is_connected_peer(void)
+{
+	GSList *listnode;
+
+	for (listnode = manager->p2p_services; listnode ; listnode = listnode->next)
+	{
+		connman_service_t *service = (connman_service_t *)(listnode->data);
+
+		if (is_connected_state(service))
+		{
+			WCALOG_DEBUG("Connected peer is found. p2p scan will be blocked.");
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+/**
+ * @brief Send an update to subscribers for com.webos.service.wifi/p2p/getpeers about changes to
+ * the list of available peers.
+ */
+
+void send_peer_information_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	append_peers(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+
+		WCALOG_DEBUG("Sending payload %s", payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(localpLSHandle, "/p2p/getpeers",
+		                        payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+/**
+ * @brief Callback function registered with the connman service object which
+ * represents the peer and is called whenever the any service property
+ * changes.
+ *
+ * @param data User context data
+ * @param new_state Name of the new state the peer switched to
+ */
+
+static void peer_service_property_changed_callback(gpointer data,
+        const gchar *property, GVariant *value)
+{
+	connman_service_t *service = (connman_service_t *) data;
+
+	if (NULL == service)
+	{
+		return;
+	}
+
+	if (!g_strcmp0(property, "State"))
+	{
+		WCALOG_DEBUG("Service %s state changed to %s", service->name, service->state);
+
+		int service_state = connman_service_get_state(service->state);
+
+		switch (service_state)
+		{
+			case CONNMAN_SERVICE_STATE_IDLE:
+				connectionmanager_send_status_to_subscribers();
+				send_peer_information_to_subscribers();
+				break;
+
+			case CONNMAN_SERVICE_STATE_ASSOCIATION:
+				send_peer_information_to_subscribers();
+				break;
+
+			case CONNMAN_SERVICE_STATE_READY:
+			case CONNMAN_SERVICE_STATE_ONLINE:
+				connectionmanager_send_status_to_subscribers();
+				send_peer_information_to_subscribers();
+				/* Unset agent callback as we no longer have any valid input for connman available */
+				connman_agent_set_request_input_callback(agent, NULL, NULL);
+				break;
+		}
+	}
+
+	if (!g_strcmp0(property, "IPv4"))
+	{
+		gsize j;
+		for (j = 0; j < g_variant_n_children(value); j++)
+		{
+			GVariant *ipv4 = g_variant_get_child_value(value, j);
+			GVariant *ikey_v = g_variant_get_child_value(ipv4, 0);
+			const gchar *ikey = g_variant_get_string(ikey_v, NULL);
+
+			if (!g_strcmp0(ikey, "Remote"))
+			{
+				GVariant *addressv = g_variant_get_child_value(ipv4, 1);
+				GVariant *addressva = g_variant_get_variant(addressv);
+				const gchar *new_addressva = g_variant_get_string(addressva, NULL);
+
+				if (g_strcmp0(new_addressva, service->ipinfo.ipv4.address)){
+					g_free(service->ipinfo.ipv4.address);
+					service->ipinfo.ipv4.address = g_variant_dup_string(addressva, NULL);
+					send_peer_information_to_subscribers();
+				}
+
+				g_variant_unref(addressv);
+				g_variant_unref(addressva);
+			}
+
+			g_variant_unref(ipv4);
+			g_variant_unref(ikey_v);
+		}
+	}
+}
+
+/**
+ * @brief Append information about the available P2P groups to a existing JSON object.
+ *
+ * @param reply The JSON object the group information should be appended to.
+ */
+
+static gboolean append_groups(jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return FALSE;
+	}
+
+	GSList *listnode;
+	gboolean group_found = FALSE;
+	jvalue_ref group_list = jarray_create(NULL);
+
+	for (listnode = manager->groups; listnode ; listnode = listnode->next)
+	{
+		connman_group_t *group = (connman_group_t *)(listnode->data);
+		jvalue_ref group_info = jobject_create();
+
+		jobject_put(group_info, J_CSTR_TO_JVAL("ssid"), jstring_create(group->name));
+		jobject_put(group_info, J_CSTR_TO_JVAL("owner"),
+		            jboolean_create(group->is_group_owner));
+		jobject_put(group_info, J_CSTR_TO_JVAL("persistent"),
+		            jboolean_create(group->is_persistent));
+		jobject_put(group_info, J_CSTR_TO_JVAL("tethering"),
+		            jboolean_create(group->tethering));
+		jobject_put(group_info, J_CSTR_TO_JVAL("frequency"),
+		            jnumber_create_i32(group->freq));
+
+		jvalue_ref group_list_j = jobject_create();
+		jobject_put(group_list_j, J_CSTR_TO_JVAL("groupInfo"), group_info);
+		jarray_append(group_list, group_list_j);
+
+		group_found = TRUE;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("groups"), group_list);
+
+	return group_found;
+}
+
+/**
+ * @brief Callback called from connman when any of the available group objects changes. As
+ * consequence this will send an update to all subscribers of the
+ * com.webos.service.wifi/p2p/getgroups method.
+ *
+ * @param data User context data
+ */
+
+void manager_groups_changed_callback(gpointer data, gboolean group_added)
+{
+	if (group_added)
+	{
+		pthread_mutex_lock(&callback_sequence_lock);
+
+		if (!group_added_by_p2p_request && !group_added_pending)
+		{
+			if (data)
+				group_added_pending = TRUE;
+
+			group_added_by_p2p_request = TRUE;
+			pthread_mutex_unlock(&callback_sequence_lock);
+			return;
+		}
+
+		if (!group_added_pending && !data) {
+			pthread_mutex_unlock(&callback_sequence_lock);
+			return;
+		}
+
+		group_added_by_p2p_request = FALSE;
+		group_added_pending = FALSE;
+		pthread_mutex_unlock(&callback_sequence_lock);
+	}
+
+	jvalue_ref reply = jobject_create();
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	append_groups(&reply);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+
+		WCALOG_DEBUG("Sending payload %s", payload);
+
+		LSError lserror;
+		LSErrorInit(&lserror);
+
+		if (!LSSubscriptionReply(localpLSHandle, "/p2p/getgroups", payload, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+static gboolean set_p2p_persistent_callback(gpointer user_data)
+{
+	gboolean enable_persistent_mode = user_data;
+
+	set_p2p_persistent_mode(enable_persistent_mode);
+
+	return FALSE;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_setstate setstate
+
+Enables/disables Wi-Fi Direct technology
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+P2P | No | String | "enabled" or "disabled" to control P2P state accordingly
+listenState | No | String | "enabled" or "disabled" to control P2P listen state accordingly
+persistentMode | No | String | "enabled" or "disabled" to control P2P persistent mode accordingly
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_3(PROP(P2P, string),
+	                                     PROP(listenState, string), PROP(persistentMode, string)))), &parsedObj))
+	{
+		return true;
+	}
+
+	gboolean enable_p2p = TRUE, enable_p2p_listen = FALSE,
+	         enable_persistent_mode = FALSE, error = FALSE;
+
+	pthread_mutex_lock(&callback_sequence_lock);
+	group_added_by_p2p_request = FALSE;
+	group_added_pending = FALSE;
+	pthread_mutex_unlock(&callback_sequence_lock);
+
+	jvalue_ref stateObj = {0};
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("P2P"), &stateObj))
+	{
+		if (jstring_equal2(stateObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_p2p = TRUE;
+			if (!(enable_p2p == is_p2p_enabled()) && !set_p2p_power_state(enable_p2p))
+			{
+				LSMessageReplyCustomError(sh, message, "Error in changing P2P state",
+				                          WCA_API_ERROR_P2P_STATE_CHANGE);
+				error = TRUE;
+				goto cleanup;
+			}
+		}
+		else if (jstring_equal2(stateObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_p2p = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("listenState"), &stateObj))
+	{
+		if (jstring_equal2(stateObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_p2p_listen = TRUE;
+		}
+		else if (jstring_equal2(stateObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_p2p_listen = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		if (!is_p2p_enabled())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "P2P disabled, so cannot changing listen state",
+			                          WCA_API_ERROR_P2P_DISABLED);
+			goto cleanup;
+		}
+		else if (!set_p2p_listen_state(enable_p2p_listen))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in changing listen state",
+			                          WCA_API_ERROR_LISTEN_STATE);
+			goto cleanup;
+		}
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("persistentMode"), &stateObj))
+	{
+		if (jstring_equal2(stateObj, J_CSTR_TO_BUF("enabled")))
+		{
+			enable_persistent_mode = TRUE;
+		}
+		else if (jstring_equal2(stateObj, J_CSTR_TO_BUF("disabled")))
+		{
+			enable_persistent_mode = FALSE;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+
+		if (!is_p2p_enabled())
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "P2P disabled, so cannot changing persistent mode",
+			                          WCA_API_ERROR_P2P_DISABLED);
+			goto cleanup;
+		}
+
+		if (!enable_p2p)
+		{
+				if (!set_p2p_persistent_mode(enable_persistent_mode))
+				{
+					LSMessageReplyCustomError(sh, message, "Error in changing persistent mode",
+							WCA_API_ERROR_PERSISTENT_STATE);
+					goto cleanup;
+				}
+		}
+		else
+			g_timeout_add(500, set_p2p_persistent_callback, enable_persistent_mode);
+	}
+
+	if (!enable_p2p && !(enable_p2p == is_p2p_enabled()) && !set_p2p_power_state(enable_p2p))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in changing P2P state",
+								  WCA_API_ERROR_P2P_STATE_CHANGE);
+		error = TRUE;
+	}
+
+	if (!error)
+	{
+		LSMessageReplySuccess(sh, message);
+	}
+
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+/**
+ * @brief Fill in all status information to be sent with '/p2p/getstate' method
+ */
+
+static void create_wifi_p2p_get_state_response(jvalue_ref *reply, bool subscribed)
+{
+	if (NULL == reply)
+	{
+		return;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(*reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	if (is_p2p_enabled())
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("P2P"), jstring_create("enabled"));
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("P2P"), jstring_create("disabled"));
+	}
+
+	if (is_p2p_listen_state_enabled())
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("listenState"), jstring_create("enabled"));
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("listenState"), jstring_create("disabled"));
+	}
+
+	if (is_p2p_persistent_mode_enabled())
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("persistentMode"),
+		            jstring_create("enabled"));
+	}
+	else
+	{
+		jobject_put(*reply, J_CSTR_TO_JVAL("persistentMode"),
+		            jstring_create("disabled"));
+	}
+}
+
+void send_p2p_get_state_to_subscribers(void)
+{
+	jvalue_ref reply = jobject_create();
+
+	create_wifi_p2p_get_state_response(&reply, true);
+
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+
+	if (response_schema)
+	{
+		const char *payload = jvalue_tostring(reply, response_schema);
+
+		/*
+		 * Do not send identical responses back.
+		 * Check if the payload is different from previous payload.
+		 * Note this is executed also when there are no subscribers, keeping
+		 * prev_response always up to date with current situation.
+		 **/
+		 if (g_strcmp0(payload, p2p_get_state_prev_response) != 0)
+		 {
+			g_free(p2p_get_state_prev_response);
+			p2p_get_state_prev_response = g_strdup(payload);
+
+			WCALOG_DEBUG("Sending payload : %s", payload);
+
+			LSError lserror;
+			LSErrorInit(&lserror);
+
+			if (!LSSubscriptionReply(localpLSHandle, "/p2p/getstate", payload, &lserror))
+			{
+				LSErrorPrint(&lserror, stderr);
+				LSErrorFree(&lserror);
+			}
+		}
+			jschema_release(&response_schema);
+	}
+
+	j_release(&reply);
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_getstate getstate
+
+Gets the state for Wi-Fi Direct technology
+
+@par Parameters
+
+None required
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+P2P | Yes | String | "enabled" or "disabled"
+listenState | Yes | String | "enabled" or "disabled"
+persistentMode | Yes | String | "enabled" or "disabled"
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_state_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialize
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+								j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+	jschema_ref response_schema = NULL;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!p2p_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	create_wifi_p2p_get_state_response(&reply, subscribed);
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_getpeers getpeers
+
+Gets the information about the Wi-Fi Direct peers
+
+Callers can subscribe to this method to be notified of any changes
+in the list of neighbouring peers.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subscribe to this method
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+peers | No | Array of Objects | List of p2p peers (see "peerInfo" Object)
+
+@par "peerInfo" Object
+
+Each entry in the "peers" array is of the form "peerInfo":{...}
+
+Name | Required | Type | Description
+-----|--------|------|----------
+deviceName | Yes | String | Name of the peer
+deviceAddress | Yes | String | Hardware (MAC) address of the peer
+groupOwner | Yes | Boolean | True if this peer is owner of a group
+configMethod | Yes | Integer | Authentication method that peer supports "PIN" or "PBC"
+signalLevel | Yes | Integer | Signal strength of the peer
+
+@par Returns(Subscription)
+
+As for a successful call
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_peers_command(LSHandle *sh, LSMessage *message,
+                                     void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(subscribe, boolean),
+		PROP(scan, boolean)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+	jschema_ref response_schema = NULL;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	jvalue_ref scanObj = NULL;
+	gboolean scan = TRUE;
+
+	if(jobject_get_exists(parsedObj, J_CSTR_TO_BUF("scan"), &scanObj))
+	{
+		bool value;
+		jboolean_get(scanObj, &value);
+		scan = value? TRUE : FALSE;
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!p2p_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message, "P2P is not enabled",
+		        WCA_API_ERROR_P2P_DISABLED, subscribed);
+		return true;
+	}
+
+	if (subscribed && scan)
+	{
+		if (!wifi_scan_now_p2p())
+		{
+			LSMessageReplyCustomErrorWithSubscription(sh, message,
+			        "Error in scanning network", WCA_API_ERROR_SCANNING, subscribed);
+			return true;
+		}
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	append_peers(&reply);
+	updatepeers_propertychanged_callback();
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+static void service_connect_callback(gboolean success, gpointer user_data)
+{
+	luna_service_request_t *service_req = user_data;
+
+	if (success)
+	{
+		LSMessageReplySuccess(service_req->handle, service_req->message);
+	}
+	else
+	{
+		LSMessageReplyCustomError(service_req->handle, service_req->message,
+		                          "Failed to connect",
+		                          WCA_API_ERROR_FAILED_TO_CONNECT);
+	}
+
+	luna_service_request_free(service_req);
+}
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_connect connect
+
+Connect to a given p2p peer
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+peerAddress | Yes | String | Device address of the peer that we want to connect to
+wpsInfo | Yes | Object | WPS information to connect to the peer
+
+@par "wpsInfo" Object
+
+Name | Required | Type | Description
+-----|--------|------|----------
+wps | Yes | Boolean | true to enable wps mode
+wpspin | No | String | WPS PIN if using WPS-PIN mode
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_connect_command(LSHandle *sh, LSMessage *message,
+                                   void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(peerAddress, string),
+	                                     OBJECT(wpsInfo, OBJSCHEMA_2(PROP(wps, boolean), PROP(wpsPin,
+	                                             string)))) REQUIRED_2(peerAddress, wpsInfo))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref peerAddressObj = {0};
+	char *peerAddress = NULL;
+	jvalue_ref wpsinfo_obj = NULL;
+	jvalue_ref wps_obj = NULL;
+	jvalue_ref wpspin_obj = NULL;
+	raw_buffer wpspin_buf;
+	connman_service_t *service = NULL;
+
+	connection_settings_t *settings = NULL;
+	luna_service_request_t *service_req = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("peerAddress"),
+	                       &peerAddressObj))
+	{
+		raw_buffer address_buf = jstring_get(peerAddressObj);
+		peerAddress = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the service with the given peer address */
+	service = find_peer_by_address(peerAddress);
+
+	if (service == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Peer not found",
+		                          WCA_API_ERROR_PEER_NOT_FOUND);
+		goto cleanup;
+	}
+
+	WCALOG_ADDR_INFOMSG(MSGID_P2P_CONNECT_PEER, "Peer", service);
+
+	/* Register for 'state changed' signal for this service to update its connection status */
+	connman_service_register_property_changed_cb(service,
+	        peer_service_property_changed_callback);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wpsInfo"), &wpsinfo_obj))
+	{
+		settings = connection_settings_new();
+		settings->ssid = strdup(service->name);
+
+		if (jobject_get_exists(wpsinfo_obj, J_CSTR_TO_BUF("wps"), &wps_obj))
+		{
+			jboolean_get(wps_obj, &settings->wpsmode);
+
+			if (jobject_get_exists(wpsinfo_obj, J_CSTR_TO_BUF("wpsPin"), &wpspin_obj))
+			{
+				wpspin_buf = jstring_get(wpspin_obj);
+				settings->wpspin = strdup(wpspin_buf.m_str);
+				jstring_free_buffer(wpspin_buf);
+			}
+			else
+			{
+				settings->wpspin = strdup("");
+			}
+		}
+		pthread_mutex_lock(&callback_sequence_lock);
+		group_added_by_p2p_request = TRUE;
+		pthread_mutex_unlock(&callback_sequence_lock);
+		WCALOG_DEBUG("Setup for connecting with secured network");
+		connman_agent_set_request_input_callback(agent, agent_request_input_callback,
+		        settings);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (connman_service_get_state(service->state) ==
+	        CONNMAN_SERVICE_STATE_ASSOCIATION)
+	{
+		LSMessageReplyCustomError(sh, message, "Peer still in association state",
+		                          WCA_API_ERROR_PEER_IN_ASSOC);
+		goto cleanup;
+	}
+
+	service_req = luna_service_request_new(sh, message);
+
+	if (!connman_peer_connect(service, service_connect_callback, service_req))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+cleanup:
+	g_free(peerAddress);
+	j_release(&parsedObj);
+	return true;
+}
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_disconnect disconnect
+
+Disconnect the given p2p peer
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+peerAddress | Yes | String | Device address of the peer that we want to connect to
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_disconnect_command(LSHandle *sh, LSMessage *message,
+                                      void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(peerAddress,
+	                                     string)) REQUIRED_1(peerAddress))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref peerAddressObj = {0};
+	char *peerAddress = NULL;
+	int service_state;
+	connman_service_t *service = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("peerAddress"),
+	                       &peerAddressObj))
+	{
+		raw_buffer address_buf = jstring_get(peerAddressObj);
+		peerAddress = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the service with the given peer address */
+	service = find_peer_by_address(peerAddress);
+	if (service == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Peer not found",
+		                          WCA_API_ERROR_PEER_NOT_FOUND);
+		goto cleanup;
+	}
+
+	WCALOG_ADDR_INFOMSG(MSGID_P2P_DISCONNECT_PEER, "Peer", service);
+
+	service_state = connman_service_get_state(service->state);
+
+	if (service_state != CONNMAN_SERVICE_STATE_READY)
+	{
+		LSMessageReplyCustomError(sh, message, "Not connected",
+		                          WCA_API_ERROR_NOT_CONNECTED);
+		goto cleanup;
+	}
+
+	if (!connman_peer_disconnect(service))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in disconnecting peer",
+			                          WCA_API_ERROR_DISCONNECT_FAILED);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(peerAddress);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_invite invite
+
+Invite a p2p peer to the group that this device belongs to
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+peerAddress | Yes | String | Device address of the peer that we want to invite
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_invite_command(LSHandle *sh, LSMessage *message,
+                                  void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(peerAddress,
+	                                     string)) REQUIRED_1(peerAddress))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref peerAddressObj = {0};
+	char *peerAddress = NULL;
+	connman_service_t *service = NULL;
+	connman_group_t *group = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("peerAddress"),
+	                       &peerAddressObj))
+	{
+		raw_buffer address_buf = jstring_get(peerAddressObj);
+		peerAddress = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the service with the given peer address */
+	service = find_peer_by_address(peerAddress);
+
+	if (service == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Peer not found",
+		                          WCA_API_ERROR_PEER_NOT_FOUND);
+		goto cleanup;
+	}
+
+	WCALOG_ADDR_INFOMSG(MSGID_P2P_INVITE_PEER, "Peer", service);
+
+	// As of now connman supports just one group on the dbus, so use that group
+	if (manager->groups == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "No active group found",
+		                          WCA_API_ERROR_NO_ACTIVE_GRP);
+		goto cleanup;
+	}
+
+	group = (connman_group_t *)(manager->groups->data);
+
+	if (!connman_group_invite_peer(group, service))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(peerAddress);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_creategroup creategroup
+
+Create an autonomous group
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | Name of the new group we want to create
+passPhrase | Yes | String | Passphrase for connecting to this group
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_create_group_command(LSHandle *sh, LSMessage *message,
+                                        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(ssid, string),
+	                                     PROP(passPhrase, string)) REQUIRED_2(ssid, passPhrase))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0}, passPhraseObj = {0};
+	char *ssid = NULL, *passphrase = NULL;
+	int passphrase_length;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer address_buf = jstring_get(ssidObj);
+		ssid = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("passPhrase"), &passPhraseObj))
+	{
+		raw_buffer address_buf = jstring_get(passPhraseObj);
+		passphrase = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	passphrase_length = strlen(passphrase);
+
+	if (passphrase_length < 8 || passphrase_length > 63)
+	{
+		LSMessageReplyCustomError(sh,
+		                          message,
+		                          "Passphrase doesn't match the requirements",
+		                          WCA_API_ERROR_P2P_PASSPHRASE_INVALID);
+		goto cleanup;
+	}
+
+	if (manager->groups)
+	{
+		LSMessageReplyCustomError(sh,
+		                          message,
+		                          "Only one group can be created at a time",
+		                          WCA_API_ERROR_P2P_MULTIPLE_GROUPS_NOT_ALLOWED);
+		goto cleanup;
+	}
+
+	if (!connman_manager_create_group(manager, ssid, passphrase))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(ssid);
+	g_free(passphrase);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_disconnectgroup disconnectgroup
+
+Disconnect a group.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | Name of the group we want to disconnect
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_disconnect_group_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(ssid, string)) REQUIRED_1(ssid))),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0};
+	char *ssid = NULL;
+	connman_group_t *group = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer address_buf = jstring_get(ssidObj);
+		ssid = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the group with the given ssid */
+	group = find_group_by_name(ssid);
+
+	if (group == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Group not found",
+		                          WCA_API_ERROR_GRP_NOT_FOUND);
+		goto cleanup;
+	}
+
+	WCALOG_INFO(MSGID_P2P_DISCONNECT_GROUP, 1, PMLOGKS("Group", group->name), "");
+
+	if (!connman_group_disconnect(group))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(ssid);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_getgroups getgroups
+
+Gets the information about all the Wi-Fi Direct groups
+
+Callers can subscribe to this method to be notified of any changes
+in the list of groups.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subscribe to this method
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+groups | Yes | Array of Objects | List of groups.
+
+@par "groupInfo" Object
+
+Each entry in the "groups" array is of the form "groupInfo":{...}
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | Name of the group
+owner | Yes | Boolean | True if this group is an owner
+persistent | Yes | Boolean | True if this group is a persistent group
+tethering | Yes | Boolean | True if this group allows tethering
+
+@par Returns(Subscription)
+
+As for a successful call
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_groups_command(LSHandle *sh, LSMessage *message,
+                                      void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+	jschema_ref response_schema = NULL;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+	}
+
+	if (!connman_status_check_with_subscription(manager, sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!p2p_technology_status_check_with_subscription(sh, message, subscribed))
+	{
+		goto cleanup;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomErrorWithSubscription(sh, message, "P2P is not enabled",
+		        WCA_API_ERROR_P2P_DISABLED, subscribed);
+		return true;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+
+	append_groups(&reply);
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_settethering settethering
+
+Enable/disable a group's tethering property
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | Name of the group
+tethering | Yes | Boolean | "true" to enable, "false" to disable
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_tethering_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(ssid, string),
+	                                     PROP(tethering, boolean)) REQUIRED_2(ssid, tethering))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = NULL, tetheringObj = NULL;
+	char *ssid = NULL;
+	gboolean tethering = FALSE;
+	connman_group_t *group = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer address_buf = jstring_get(ssidObj);
+		ssid = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("tethering"), &tetheringObj))
+	{
+		bool value;
+		jboolean_get(tetheringObj, &value);
+		tethering = value ? TRUE : FALSE;
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the group with the given ssid */
+	group = find_group_by_name(ssid);
+
+	if (group == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Group not found",
+		                          WCA_API_ERROR_GRP_NOT_FOUND);
+		goto cleanup;
+	}
+
+	WCALOG_INFO(MSGID_P2P_SET_TETHERING, 2, PMLOGKS("Group", group->name),
+	            PMLOGKS("Tethering", tethering ? "true" : "false"), "");
+
+	if (group->tethering == tethering)
+	{
+		if (tethering == TRUE)
+		{
+			LSMessageReplyCustomError(sh, message, "Already enabled",
+			                          WCA_API_ERROR_ALREADY_ENABLED);
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message, "Already disabled",
+			                          WCA_API_ERROR_ALREADY_DISABLED);
+		}
+
+		goto cleanup;
+	}
+	else if (!connman_group_set_tethering(group, tethering))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(ssid);
+	j_release(&parsedObj);
+	return true;
+}
+
+static gboolean send_group_peers_information(connman_group_t *group,
+        jvalue_ref *reply)
+{
+	if (NULL == reply)
+	{
+		return FALSE;
+	}
+
+	GSList *listnode;
+	gboolean peer_found = FALSE;
+
+	jvalue_ref peer_list = jarray_create(NULL);
+
+	for (listnode = group->peer_list; listnode ; listnode = listnode->next)
+	{
+		connman_service_t *service = (connman_service_t *)(listnode->data);
+
+		jvalue_ref peer_info = jobject_create();
+
+		append_peer_information(&peer_info, service);
+
+		jvalue_ref peer_list_j = jobject_create();
+		jobject_put(peer_list_j, J_CSTR_TO_JVAL("peerInfo"), peer_info);
+		jarray_append(peer_list, peer_list_j);
+
+		peer_found = TRUE;
+	}
+
+	jobject_put(*reply, J_CSTR_TO_JVAL("peers"), peer_list);
+
+	return peer_found;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_getgrouppeers getgrouppeers
+
+Gets the list of peers for a group.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+ssid | Yes | String | Name of the group
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+peers | Yes | Array | List of peers in the group (see "peerInfo" Object)
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@par "peerInfo" Object
+
+Each entry in the "peers" array is of the form "peerInfo":{...}
+
+Name | Required | Type | Description
+-----|--------|------|----------
+deviceName | Yes | String | Name of the peer
+deviceAddress | Yes | String | Hardware (MAC) address of the peer
+groupOwner | Yes | Boolean | True if this peer is owner of a group
+configMethod | Yes | Integer | Authentication method that peer supports "PIN" or "PBC"
+signalLevel | Yes | Integer | Signal strength of the peer
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_group_peers_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(ssid, string)) REQUIRED_1(ssid))),
+	                             &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref ssidObj = {0};
+	char *ssid = NULL;
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	connman_group_t *group = NULL;
+	jschema_ref response_schema = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	{
+		raw_buffer address_buf = jstring_get(ssidObj);
+		ssid = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the group with the given ssid */
+	group = find_group_by_name(ssid);
+
+	if (group == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Group not found",
+		                          WCA_API_ERROR_GRP_NOT_FOUND);
+		goto cleanup;
+	}
+
+	WCALOG_DEBUG("Listing peers for group %s", group->name);
+
+	if (!connman_manager_populate_group_peers(manager, group))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	send_group_peers_information(group, &reply);
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	g_free(ssid);
+	j_release(&reply);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_setdevicename setdevicename
+
+Set the device name for p2p communication
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+deviceName | Yes | String | Device name to be used
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_device_name_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(deviceName,
+	                                     string)) REQUIRED_1(deviceName))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref nameObj = NULL;
+	char *name = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("deviceName"), &nameObj))
+	{
+		raw_buffer address_buf = jstring_get(nameObj);
+		name = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	WCALOG_DEBUG("Setting new P2P identifier : %s", name);
+
+	if (!connman_technology_set_p2p_identifier(connman_manager_find_p2p_technology(
+	            manager), name))
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(name);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_getdevicename getdevicename
+
+Gets the device name used for P2P communication
+
+@par Parameters
+
+None required
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+deviceName | Yes | String | P2P device name
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_device_name_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	jschema_ref response_schema = NULL;
+
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (technology->p2p_identifier)
+	{
+		jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+		jobject_put(reply, J_CSTR_TO_JVAL("deviceName"),
+		            jstring_create(technology->p2p_identifier));
+	}
+	else
+	{
+		LSMessageReplyCustomError(sh, message, "Device name not set",
+		                          WCA_API_ERROR_DEVICE_NAME_UNSET);
+		goto cleanup;
+	}
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_setwifidisplayinfo setwifidisplayinfo
+
+Set the wifi display parameters.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+enabled | No | Boolean | Enable/disable WiFi Display feature
+deviceType | No | String | Set the device type : Should be one of source/primary-sink/secondary-sink/dual-role
+sessionAvailable | No | Boolean | WFD Session Available
+rtspPort | No | Integer | Session management control port
+cpSupport | No | Boolean | Content Protection using HDCP System 2.0/2.1
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_wifidisplay_info_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(enabled, boolean),
+	                                     PROP(deviceType, string), PROP(sessionAvailable, boolean), PROP(rtspPort,
+	                                             integer), PROP(cpSupport, boolean)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref deviceTypeObj = NULL, enabledObj = NULL, sessionAvailableObj = NULL,
+	           cpSupportObj = NULL, rtspPortObj = NULL;
+	gchar *deviceType = NULL;
+	gboolean sessionAvailable = FALSE, cpSupport = FALSE, enabled = FALSE;
+	bool value = false;
+	int rtspPort = 0;
+	bool is_master = FALSE;
+	guint16 devtype = SOURCE;
+	InformationElementArray* array = NULL;
+
+	struct InformationElement* infoelem = newInformationElement();
+	Subelement *newsubElement = new_subelement(DEVICE_INFORMATION);
+	DeviceInformationSubelement* newDeviceInfo = (DeviceInformationSubelement *) newsubElement;
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
+	{
+		jboolean_get(enabledObj, &value);
+		enabled = value ? TRUE : FALSE;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("deviceType"), &deviceTypeObj))
+	{
+		raw_buffer address_buf = jstring_get(deviceTypeObj);
+		deviceType = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!g_strcmp0(deviceType, "source"))
+		{
+			devtype = SOURCE;
+			is_master = TRUE;
+		}
+		else if (!g_strcmp0(deviceType, "primary-sink"))
+		{
+			devtype = PRIMARY_SINK;
+		}
+		else if (!g_strcmp0(deviceType, "secondary-sink"))
+		{
+			devtype = SECONDARY_SINK;
+		}
+		else if (!g_strcmp0(deviceType, "dual-role"))
+		{
+			devtype = DUAL_ROLE;
+		}
+		else
+		{
+			LSMessageReplyCustomError(sh, message,
+			                          "Invalid value for deviceType (should be one of source/primary-sink/secondary-sink/dual-role",
+			                          WCA_API_ERROR_DEVICETYPE_INVALID);
+			goto cleanup;
+		}
+
+		newDeviceInfo->field1.device_type = devtype;
+
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("sessionAvailable"),
+	                       &sessionAvailableObj))
+	{
+		jboolean_get(sessionAvailableObj, &value);
+		sessionAvailable = value ? TRUE : FALSE;
+
+		newDeviceInfo->field1.session_availability = sessionAvailable;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("cpSupport"), &cpSupportObj))
+	{
+		jboolean_get(cpSupportObj, &value);
+		cpSupport = value ? TRUE : FALSE;
+
+		newDeviceInfo->field2.hdcp_support = cpSupport;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("rtspPort"), &rtspPortObj))
+	{
+		jnumber_get_i32(rtspPortObj, &rtspPort);
+
+		newDeviceInfo->session_management_control_port =  htons(rtspPort);
+		newDeviceInfo->maximum_throughput = htons(50);
+
+	}
+
+	wfdinfoelem_add_subelement(infoelem, newsubElement);
+	array = wfdinfoelem_serialize(infoelem);
+
+	if(technology->wfd & enabled)
+	{
+
+		if(technology->wfd == enabled && technology->wfd_sessionavail == sessionAvailable
+			&& technology->wfd_cpsupport == cpSupport &&
+			technology->wfd_rtspport == rtspPort && technology->wfd_devtype == devtype)
+		{
+			WCALOG_DEBUG("Activate Request is same as old one, so Return Just True");
+			LSMessageReplySuccess(sh, message);
+			goto cleanup;
+		}
+
+		struct InformationElement* tempinfoelem = newInformationElement();
+		Subelement *tempnewsubElement = new_subelement(DEVICE_INFORMATION);
+		DeviceInformationSubelement* tempnewDeviceInfo = (DeviceInformationSubelement *) tempnewsubElement;
+
+		tempnewDeviceInfo->field1.device_type = technology->wfd_devtype;
+		tempnewDeviceInfo->field1.session_availability = technology->wfd_sessionavail;
+		tempnewDeviceInfo->field2.hdcp_support = technology->wfd_cpsupport;
+		tempnewDeviceInfo->session_management_control_port =  htons(technology->wfd_rtspport);
+		tempnewDeviceInfo->maximum_throughput = htons(50);
+
+		wfdinfoelem_add_subelement(tempinfoelem, tempnewsubElement);
+		InformationElementArray* temparray = wfdinfoelem_serialize(tempinfoelem);
+
+		if (!connman_manager_p2p_service_unregister(manager, CONNMAN_SERVICE_TYPE_WiFiDisplayIEs, NULL, NULL, temparray))
+		{
+				LSMessageReplyCustomError(sh, message, "Internal Error", WCA_API_ERROR_INTERNAL);
+				deleteInformationElement(tempinfoelem);
+				deleteInformationElementArray(temparray);
+				goto cleanup;
+		}
+
+		deleteInformationElement(tempinfoelem);
+		deleteInformationElementArray(temparray);
+	}
+
+	if (enabled)
+	{
+		if (!connman_manager_p2p_service_register(manager, CONNMAN_SERVICE_TYPE_WiFiDisplayIEs, NULL, NULL, NULL, array, is_master))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in register servie", WCA_API_ERROR_ADDSERVICE);
+			goto cleanup;
+		}
+	}
+	else
+	{
+		if (!connman_manager_p2p_service_unregister(manager, CONNMAN_SERVICE_TYPE_WiFiDisplayIEs, NULL, NULL, array))
+		{
+			LSMessageReplyCustomError(sh, message, "Error in unregister service", WCA_API_ERROR_ADDSERVICE);
+			goto cleanup;
+		}
+	}
+
+	if (enabled != technology->wfd &&
+		        !connman_technology_set_wfd(technology, enabled))
+	{
+			LSMessageReplyCustomError(sh, message, "Error in changing WFD state",
+			                          WCA_API_ERROR_WFD_STATE);
+			goto cleanup;
+	}
+
+
+	if (devtype != technology->wfd_devtype &&
+		        !connman_technology_set_wfd_devtype(technology, (connman_wfd_dev_type) devtype))
+	{
+			LSMessageReplyCustomError(sh, message, "Error in changing WFD device type",
+			                          WCA_API_ERROR_DEVICETYPE);
+			goto cleanup;
+	}
+
+	if (sessionAvailable != technology->wfd_sessionavail &&
+		        !connman_technology_set_wfd_sessionavail(technology, sessionAvailable))
+	{
+			LSMessageReplyCustomError(sh, message,
+			                          "Error in changing WFD session available bit", WCA_API_ERROR_SESSION_AVAIL_BIT);
+			goto cleanup;
+	}
+
+	if (cpSupport != technology->wfd_cpsupport &&
+		        !connman_technology_set_wfd_cpsupport(technology, cpSupport))
+	{
+			LSMessageReplyCustomError(sh, message, "Error in changing WFD cp support bit",
+			                          WCA_API_ERROR_CP_SUPPORT_BIT);
+			goto cleanup;
+	}
+
+	if (rtspPort != technology->wfd_rtspport &&
+		        !connman_technology_set_wfd_rtspport(technology, rtspPort))
+	{
+			LSMessageReplyCustomError(sh, message, "Error in changing WFD rtsp port",
+			                          WCA_API_ERROR_RTSP_PORT);
+			goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(deviceType);
+	deleteInformationElement(infoelem);
+	if (array)
+		deleteInformationElementArray(array);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_getwifidisplayinfo getwifidisplayinfo
+
+Gets the wifi display parameters
+
+@par Parameters
+
+None required
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+enabled | Yes | Boolean | WiFi Display feature status
+deviceType | Yes | String | WFD Device type : source/primary-sink/secondary-sink/dual-role
+sessionAvailable | Yes | Boolean | WFD Session Available
+rtspPort | Yes | Integer | Session management control port
+cpSupport | Yes | Boolean | Content Protection using HDCP System 2.0/2.1
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_wifidisplay_info_command(LSHandle *sh,
+        LSMessage *message, void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	connman_technology_t *technology = connman_manager_find_wifi_technology(
+	                                       manager);
+	jobject_put(reply, J_CSTR_TO_JVAL("enabled"), jboolean_create(technology->wfd));
+
+	if (technology->wfd)
+	{
+		switch (technology->wfd_devtype)
+		{
+			case CONNMAN_WFD_DEV_TYPE_SOURCE:
+				jobject_put(reply, J_CSTR_TO_JVAL("wfdDeviceType"), jstring_create("source"));
+				break;
+
+			case CONNMAN_WFD_DEV_TYPE_PRIMARY_SINK:
+				jobject_put(reply, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("primary-sink"));
+				break;
+
+			case CONNMAN_WFD_DEV_TYPE_SECONDARY_SINK:
+				jobject_put(reply, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("secondary-sink"));
+				break;
+
+			case CONNMAN_WFD_DEV_TYPE_DUAL:
+				jobject_put(reply, J_CSTR_TO_JVAL("wfdDeviceType"),
+				            jstring_create("dual-role"));
+				break;
+
+		}
+
+		jobject_put(reply, J_CSTR_TO_JVAL("wfdSessionAvail"),
+		            jboolean_create(technology->wfd_sessionavail));
+		jobject_put(reply, J_CSTR_TO_JVAL("wfdCpSupport"),
+		            jboolean_create(technology->wfd_cpsupport));
+		jobject_put(reply, J_CSTR_TO_JVAL("wfdRtspPort"),
+		            jnumber_create_i32(technology->wfd_rtspport));
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+	jschema_ref response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_getp2prequests getp2prequests
+
+Subscribes the caller for incoming p2p request notification
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+subscribe | No | Boolean | true to subscribe to this method
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_get_p2p_requests_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(SCHEMA_1(PROP(subscribe, boolean))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	LSError lserror;
+	LSErrorInit(&lserror);
+	bool subscribed = false;
+	jschema_ref response_schema = NULL;
+
+	if (LSMessageIsSubscription(message))
+	{
+		if (!LSSubscriptionProcess(sh, message, &subscribed, &lserror))
+		{
+			LSErrorPrint(&lserror, stderr);
+			LSErrorFree(&lserror);
+		}
+
+		jobject_put(reply, J_CSTR_TO_JVAL("subscribed"), jboolean_create(subscribed));
+	}
+	else
+	{
+		LSMessageReplyCustomError(sh, message, "Subscription is mandatory for this API",
+		                          WCA_API_ERROR_SUBSCRIPTION_REQD);
+		goto cleanup;
+	}
+
+	jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
+
+	response_schema = jschema_parse(j_cstr_to_buffer("{}"),
+	                              DOMOPT_NOOPT, NULL);
+
+	if (!response_schema)
+	{
+		LSMessageReplyErrorUnknown(sh, message);
+		goto cleanup;
+	}
+
+	if (!LSMessageReply(sh, message, jvalue_tostring(reply, response_schema),
+	                    &lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	jschema_release(&response_schema);
+cleanup:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	j_release(&parsedObj);
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_findservice findservice
+
+Finds all Wi-Fi Direct services or a specific service based on
+service type. Once this API is triggered, the response will be
+received to the subscriber of the getpeers API.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+type | yes | String | Should be one of "upnp" or "bonjour"
+address | no | String | If not set will look for all peers
+version | no | Integer | Version number for "upnp"
+description | no | String | Description for "upnp"
+query | no | String | Query for "bonjour"
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_find_service_command(LSHandle *sh, LSMessage *message,
+                                        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(type, string),
+	                                     PROP(address, string), PROP(version, integer), PROP(description, string),
+	                                     PROP(query, string)) REQUIRED_1(type))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	jvalue_ref typeObj = NULL, addressObj = NULL, versionObj = NULL,
+	           descriptionObj = NULL, queryObj = NULL;
+	gchar *type = NULL, *address = NULL, *description = NULL, *query = NULL;
+	gint version = 0;
+	connman_service_type service_type;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("type"), &typeObj))
+	{
+		raw_buffer address_buf = jstring_get(typeObj);
+		type = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!g_strcmp0(type, "upnp"))
+		{
+			service_type = CONNMAN_SERVICE_TYPE_UPNP;
+		}
+		else if (!g_strcmp0(type, "bonjour"))
+		{
+			service_type = CONNMAN_SERVICE_TYPE_BONJOUR;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+	}
+	else
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		address = g_strdup("00:00:00:00:00:00");
+	}
+
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("version"), &versionObj))
+	{
+		jnumber_get_i32(versionObj, &version);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_UPNP)
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("description"),
+	                       &descriptionObj))
+	{
+		raw_buffer address_buf = jstring_get(descriptionObj);
+		description = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_UPNP)
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("query"), &queryObj))
+	{
+		raw_buffer address_buf = jstring_get(queryObj);
+		query = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_BONJOUR)
+	{
+		goto invalid_params;
+	}
+
+	if (!connman_service_discovery_request(service_type, address, version,
+	                                       description, query))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in findservice",
+		                          WCA_API_ERROR_FINDSERVICE);
+		goto cleanup;
+	}
+
+
+	LSMessageReplySuccess(sh, message);
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+cleanup:
+	g_free(type);
+	g_free(address);
+	g_free(description);
+	g_free(query);
+	j_release(&reply);
+
+	if (!jis_null(parsedObj))
+	{
+		j_release(&parsedObj);
+	}
+	return true;
+}
+
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_addservice addservice
+
+Adds a Wi-Fi Direct service.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+type | yes | String | Should be one of "upnp" or "bonjour"
+description | no | String | Description for "upnp"
+query | no | String | Query for "bonjour"
+response | no | String | Response for "bonjour"
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_add_service_command(LSHandle *sh, LSMessage *message,
+                                       void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_4(PROP(type, string),
+	                                     PROP(description, string), PROP(query, string), PROP(response,
+	                                             string)) REQUIRED_1(type))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	jvalue_ref typeObj = NULL, descriptionObj = NULL, queryObj = NULL,
+	           *responseObj = NULL;
+	gchar *type = NULL, *description = NULL, *query = NULL, *response = NULL;
+	connman_service_type service_type;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("type"), &typeObj))
+	{
+		raw_buffer address_buf = jstring_get(typeObj);
+		type = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!g_strcmp0(type, "upnp"))
+		{
+			service_type = CONNMAN_SERVICE_TYPE_UPNP;
+		}
+		else if (!g_strcmp0(type, "bonjour"))
+		{
+			service_type = CONNMAN_SERVICE_TYPE_BONJOUR;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+	}
+	else
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("description"),
+	                       &descriptionObj))
+	{
+		raw_buffer address_buf = jstring_get(descriptionObj);
+		description = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_UPNP)
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("query"), &queryObj))
+	{
+		raw_buffer address_buf = jstring_get(queryObj);
+		query = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_BONJOUR)
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("response"), &responseObj))
+	{
+		raw_buffer address_buf = jstring_get(responseObj);
+		response = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_BONJOUR)
+	{
+		goto invalid_params;
+	}
+
+	if (!connman_manager_p2p_service_register(manager, service_type, description, query,
+	                                        response, NULL, FALSE))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in addservice",
+		                          WCA_API_ERROR_ADDSERVICE);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+cleanup:
+	g_free(type);
+	g_free(description);
+	g_free(query);
+	g_free(response);
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_deleteservice deleteservice
+
+Deletes a Wi-Fi Direct service.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+serviceType | yes | String | Should be one of "upnp" or "bonjour"
+description | no | String | Description for "upnp"
+query | no | String | Query for "bonjour"
+
+@par Returns(Call)
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par
+As for a successful call
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_delete_service_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!wifi_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_3(PROP(type, string),
+	                                     PROP(description, string), PROP(query, string)) REQUIRED_1(type))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref reply = jobject_create();
+	jvalue_ref typeObj = NULL, descriptionObj = NULL, queryObj = NULL;
+	gchar *type = NULL, *description = NULL, *query = NULL;
+	connman_service_type service_type;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("type"), &typeObj))
+	{
+		raw_buffer address_buf = jstring_get(typeObj);
+		type = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!g_strcmp0(type, "upnp"))
+		{
+			service_type = CONNMAN_SERVICE_TYPE_UPNP;
+		}
+		else if (!g_strcmp0(type, "bonjour"))
+		{
+			service_type = CONNMAN_SERVICE_TYPE_BONJOUR;
+		}
+		else
+		{
+			goto invalid_params;
+		}
+	}
+	else
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("description"),
+	                       &descriptionObj))
+	{
+		raw_buffer address_buf = jstring_get(descriptionObj);
+		description = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_UPNP)
+	{
+		goto invalid_params;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("query"), &queryObj))
+	{
+		raw_buffer address_buf = jstring_get(queryObj);
+		query = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else if (service_type == CONNMAN_SERVICE_TYPE_BONJOUR)
+	{
+		goto invalid_params;
+	}
+
+	if (!connman_manager_p2p_service_unregister(manager, service_type, description, query, NULL))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in deleteservice",
+		                          WCA_API_ERROR_DELETESERVICE);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+	goto cleanup;
+
+invalid_params:
+	LSMessageReplyErrorInvalidParams(sh, message);
+cleanup:
+	g_free(type);
+	g_free(description);
+	g_free(query);
+	j_release(&reply);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_cancel cancel
+
+Cancel any ongoing P2P connection.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+None
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_cancel_command(LSHandle *sh, LSMessage *message,
+                                  void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	pthread_mutex_lock(&callback_sequence_lock);
+	group_added_by_p2p_request = FALSE;
+	group_added_pending = FALSE;
+	pthread_mutex_unlock(&callback_sequence_lock);
+
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (!connman_technology_cancel_p2p(technology))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in cancelling P2P connection",
+		                          WCA_API_ERROR_CANCEL_P2P_CONN);
+		return true;
+	}
+
+	LSMessageReplySuccess(sh, message);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_rejectPeer rejectPeer
+
+Reject any incoming P2P connection.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+peerAddress | Yes | String | Device address of the peer that we want to reject
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_reject_peer_command(LSHandle *sh, LSMessage *message,
+                                       void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(peerAddress,
+	                                     string)) REQUIRED_1(peerAddress))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref peerAddressObj = {0};
+	char *peerAddress = NULL;
+	connman_service_t *service = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("peerAddress"),
+	                       &peerAddressObj))
+	{
+		raw_buffer address_buf = jstring_get(peerAddressObj);
+		peerAddress = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Look up for the service with the given peer address */
+	service = find_peer_by_address(peerAddress);
+
+	if (service == NULL)
+	{
+		LSMessageReplyCustomError(sh, message, "Peer not found",
+		                          WCA_API_ERROR_PEER_NOT_FOUND);
+		goto cleanup;
+	}
+
+	if (!connman_service_reject_peer(service))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in rejecting peer",
+		                          WCA_API_ERROR_REJECT_PEER);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(peerAddress);
+	j_release(&parsedObj);
+	return true;
+}
+
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_deleteprofile deleteprofile
+
+Delete persistent profile for a specific mac address or all
+profiles and also disconnect the peer(s) if connected.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+deviceAddress | Yes | String | Device address or "all"
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_delete_profile_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(deviceAddress,
+	                                     string)) REQUIRED_1(deviceAddress))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref addressObj = NULL;
+	char *address = NULL;
+	connman_service_t *service = NULL;
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("deviceAddress"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	/* Disconnect the peer(s) if they are already connected */
+
+	if (!g_strcmp0(address, "all"))
+	{
+		service = connman_manager_get_connected_service(manager->p2p_services);
+	}
+	else
+	{
+		service = find_peer_by_address(address);
+	}
+
+	if (service != NULL)
+	{
+		WCALOG_ADDR_INFOMSG(MSGID_P2P_DELETE_PROFILE, "Peer", service);
+
+		int service_state = connman_service_get_state(service->state);
+
+		if (service_state == CONNMAN_SERVICE_STATE_READY ||
+		        service_state == CONNMAN_SERVICE_STATE_ONLINE)
+		{
+			connman_group_t *group = NULL;
+			GSList *listnode = NULL;
+
+			// Since net.connman.Service.Disconnect API is not valid for a p2p service,
+			// we will just disconnect all the groups which will effectively disconnect
+			// the p2p connections associated with them (currently connman just
+			// supports one group)
+			for (listnode = manager->groups; NULL != listnode ; listnode = listnode->next)
+			{
+				group = (connman_group_t *)(listnode->data);
+
+				/* Disconnecting the group will disconnect all connected peers */
+				if (!connman_group_disconnect(group))
+				{
+					LSMessageReplyCustomError(sh, message, "Error in disconnecting group",
+					                          WCA_API_ERROR_DISC_GROUP);
+					goto cleanup;
+				}
+			}
+		}
+	}
+
+	if (!connman_technology_delete_profile(connman_manager_find_p2p_technology(
+	        manager), address))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in deleting profile",
+		                          WCA_API_ERROR_DELETING_PROFILE);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	g_free(address);
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_setlistenparams setlistenparams
+
+Set the wifi display listen parameters.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+period | Yes | Integer | Set listen state period
+interval | Yes | Integer | Set listen state interval
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+static bool handle_set_listen_params_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(PROP(period, integer),
+	                                     PROP(interval, integer)) REQUIRED_2(period, interval))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref periodObj = NULL, intervalObj = NULL;
+	int period = 0, interval = 0;
+
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("period"), &periodObj))
+	{
+		jnumber_get_i32(periodObj, &period);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interval"), &intervalObj))
+	{
+		jnumber_get_i32(intervalObj, &interval);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (period <= 0 || interval <= 0)
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (period > interval)
+	{
+		LSMessageReplyCustomError(sh, message, "Period cannot be larger than interval",
+		                          WCA_API_ERROR_LISTEN_PARAMS_INVALID_VALUES);
+		goto cleanup;
+	}
+
+	if (!connman_technology_set_listen_params(technology, period, interval))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in setting listen parameters",
+		                          WCA_API_ERROR_LISTEN_PARAMS);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_setlistenchannel setlistenchannel
+
+Set the wifi display listen channel.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+listenChannel | Yes | Integer | Set listen channel
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+static bool handle_set_listen_channel_command(LSHandle *sh, LSMessage *message,
+        void *context)
+{
+	if (!connman_status_check(manager, sh, message))
+	{
+		return true;
+	}
+
+	if (!p2p_technology_status_check(sh, message))
+	{
+		return true;
+	}
+
+	if (!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh, message, "P2P is not enabled",
+		                          WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(listenChannel,
+	                                     integer)) REQUIRED_1(listenChannel))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref channelObj = NULL;
+	int listen_channel = 0;
+
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("listenChannel"), &channelObj))
+	{
+		jnumber_get_i32(channelObj, &listen_channel);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (listen_channel <= 0)
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if (!connman_technology_set_listen_channel(technology, listen_channel))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in changing listen channel",
+		                          WCA_API_ERROR_FAILED_TO_SET_LISTEN_CHANNEL);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh, message);
+
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+//->Start of API documentation comment block
+/**
+@page com_webos_wifi_p2p com.webos.wifi/p2p
+@{
+@section com_webos_wifi_p2p_setgointent setgointent
+
+Set the group owner intent value.
+
+@par Parameters
+
+Name | Required | Type | Description
+-----|--------|------|----------
+GoIntent | Yes | Integer | Set GO intent value
+
+@par Returns(Call) for all forms
+
+Name | Required | Type | Description
+-----|--------|------|----------
+returnValue | Yes | Boolean | True
+
+@par Returns(Subscription)
+
+Not applicable.
+
+@}
+*/
+//->End of API documentation comment block
+
+static bool handle_set_go_intent_command(LSHandle *sh, LSMessage *message, void* context)
+{
+	if(!connman_status_check(manager, sh, message))
+		return true;
+
+	if(!p2p_technology_status_check(sh, message))
+		return true;
+
+	if(!is_p2p_enabled())
+	{
+		LSMessageReplyCustomError(sh,message,"P2P is not enabled", WCA_API_ERROR_P2P_DISABLED);
+		return true;
+	}
+
+	jvalue_ref parsedObj = {0};
+	if(!LSMessageValidateSchema(sh, message, j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(GOIntent, integer)) REQUIRED_1(GOIntent))), &parsedObj))
+		return true;
+
+	jvalue_ref channelObj = NULL;
+	int go_intent = 0;
+
+	connman_technology_t *technology = connman_manager_find_p2p_technology(manager);
+	if(jobject_get_exists(parsedObj, J_CSTR_TO_BUF("GOIntent"), &channelObj))
+	{
+		jnumber_get_i32(channelObj, &go_intent);
+	}
+	else
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
+	if(!connman_technology_set_go_intent(technology, go_intent))
+	{
+		LSMessageReplyCustomError(sh, message, "Error in changing go intent value", WCA_API_ERROR_FAILED_TO_SET_GO_INTENT);
+		goto cleanup;
+	}
+
+	LSMessageReplySuccess(sh,message);
+
+cleanup:
+	j_release(&parsedObj);
+	return true;
+}
+
+static bool new_device_name_cb(LSHandle *sh, LSMessage *message, void *ctx)
+{
+	connman_technology_t *p2p_tech = connman_manager_find_p2p_technology(manager);
+
+	if (!connman_manager_is_manager_available(manager) && !p2p_tech)
+	{
+		return true;
+	}
+
+	jvalue_ref parsedObj = {0};
+	jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT,
+	                           NULL);
+
+	if (!input_schema)
+	{
+		return false;
+	}
+
+	JSchemaInfo schemaInfo;
+	jschema_info_init(&schemaInfo, input_schema, NULL,
+	                  NULL); // no external refs & no error handlers
+	parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)),
+	                       DOMOPT_NOOPT, &schemaInfo);
+	jschema_release(&input_schema);
+
+	if (jis_null(parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref settingsObj = {0}, deviceNameObj = {0}, subscribedObj = {0},
+	           returnValueObj = {0};
+	gchar *device_name = NULL;
+	bool returnValue = false;
+	raw_buffer address_buf = {0};
+
+	if (!jobject_get_exists(parsedObj, J_CSTR_TO_BUF("returnValue"),
+	                        &returnValueObj))
+	{
+		goto cleanup;
+	}
+
+	jboolean_get(returnValueObj, &returnValue);
+
+	if (!returnValue)
+	{
+		goto cleanup;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("subscribed"), &subscribedObj))
+	{
+		jboolean_get(subscribedObj, &subscribed_for_device_name);
+	}
+
+	if (!jobject_get_exists(parsedObj, J_CSTR_TO_BUF("settings"), &settingsObj))
+	{
+		goto cleanup;
+	}
+
+	if (!jobject_get_exists(settingsObj, J_CSTR_TO_BUF("deviceName"),
+	                        &deviceNameObj))
+	{
+		goto cleanup;
+	}
+
+	address_buf = jstring_get(deviceNameObj);
+	device_name = g_strdup(address_buf.m_str);
+	jstring_free_buffer(address_buf);
+
+	connman_technology_set_p2p_identifier(p2p_tech, device_name);
+
+cleanup:
+	g_free(device_name);
+	j_release(&parsedObj);
+
+	return true;
+}
+
+
+/**
+ * com.webos.service.wifi/p2p service Luna Method Table
+ */
+
+static LSMethod wifi_p2p_methods[] =
+{
+	{ LUNA_METHOD_P2P_SETSTATE,              handle_set_state_command },
+	{ LUNA_METHOD_P2P_GETSTATE,              handle_get_state_command },
+	{ LUNA_METHOD_P2P_GETPEERS,              handle_get_peers_command },
+	{ LUNA_METHOD_P2P_CONNECT,               handle_connect_command },
+	{ LUNA_METHOD_P2P_DISCONNECT,            handle_disconnect_command },
+	{ LUNA_METHOD_P2P_INVITE,                handle_invite_command },
+	{ LUNA_METHOD_P2P_CREATEGROUP,           handle_create_group_command },
+	{ LUNA_METHOD_P2P_DISCONNECTGROUP,       handle_disconnect_group_command },
+	{ LUNA_METHOD_P2P_GETGROUPS,             handle_get_groups_command },
+	{ LUNA_METHOD_P2P_SETTETHERING,          handle_set_tethering_command },
+	{ LUNA_METHOD_P2P_GETGROUPPEERS,         handle_get_group_peers_command },
+	{ LUNA_METHOD_P2P_SETDEVICENAME,         handle_set_device_name_command },
+	{ LUNA_METHOD_P2P_GETDEVICENAME,         handle_get_device_name_command },
+	{ LUNA_METHOD_P2P_SETWIFIDISPLAYINFO,    handle_set_wifidisplay_info_command },
+	{ LUNA_METHOD_P2P_GETWIFIDISPLAYINFO,    handle_get_wifidisplay_info_command },
+	{ LUNA_METHOD_P2P_GETP2PREQUESTS,        handle_get_p2p_requests_command },
+	{ LUNA_METHOD_P2P_FINDSERVICE,           handle_find_service_command },
+	{ LUNA_METHOD_P2P_ADDSERVICE,            handle_add_service_command },
+	{ LUNA_METHOD_P2P_DELETESERVICE,         handle_delete_service_command },
+	{ LUNA_METHOD_P2P_CANCEL,                handle_cancel_command },
+	{ LUNA_METHOD_P2P_REJECTPEER,                handle_reject_peer_command },
+	{ LUNA_METHOD_P2P_DELETE_PROFILE,        handle_delete_profile_command },
+	{ LUNA_METHOD_P2P_SETLISTENPARAMS,     handle_set_listen_params_command },
+	{ LUNA_METHOD_P2P_SETLISTENCHANNEL,     handle_set_listen_channel_command },
+	{ LUNA_METHOD_P2P_SETGOINTENT,          handle_set_go_intent_command },
+	{ },
+};
+
+gboolean settingsservice_started = FALSE;
+
+void update_p2p_device_name(void)
+{
+	if (settingsservice_started && connman_manager_find_wifi_technology(manager))
+	{
+		if (!subscribed_for_device_name)
+		{
+			if (!LSCall(localpLSHandle, "palm://com.webos.settingsservice/getSystemSettings",
+			       "{\"keys\":[\"deviceName\"],"
+			       "\"category\":\"network\",\"subscribe\":true}", new_device_name_cb, NULL, NULL,
+			       NULL))
+				WCALOG_DEBUG("Failed to get system device name from com.webos.settigsservice");
+		}
+		else
+		{
+			LSCallOneReply(localpLSHandle,
+			               "palm://com.webos.settingsservice/getSystemSettings",
+			               "{\"keys\":[\"deviceName\"],"
+			               "\"category\":\"network\"}", new_device_name_cb, NULL, NULL, NULL);
+		}
+	}
+}
+
+
+static gboolean register_settingsservice_status_cb(LSHandle *sh,
+        const char *service, gboolean connected, void *ctx)
+{
+	if (connected)
+	{
+		settingsservice_started = TRUE;
+		retrieve_system_locale_info(sh);
+		update_p2p_device_name();
+	}
+
+	return TRUE;
+}
+
+void setPropertyUpdateCallback(connman_service_t *service)
+{
+	if(service==NULL)
+		return;
+	connman_service_register_property_changed_cb(service, peer_service_property_changed_callback);
+}
+
+/**
+ *  @brief Initialize com.webos.service.wifi/p2p service and all of its methods
+ */
+
+int initialize_wifi_p2p_ls2_calls(GMainLoop *mainloop, LSHandle *pLsHandle)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	if (NULL == mainloop)
+	{
+		goto Exit;
+	}
+
+	localpLSHandle = pLsHandle;
+
+	if (LSRegisterCategory(pLsHandle, LUNA_CATEGORY_P2P, wifi_p2p_methods, NULL,
+	                       NULL,
+	                       &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_P2P_METHODS_LUNA_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	if (LSRegisterServerStatusEx(pLsHandle, "com.webos.settingsservice",
+	                             (LSServerStatusFunc)register_settingsservice_status_cb, NULL, NULL,
+	                             &lserror) == false)
+	{
+		WCALOG_ESCAPED_ERRMSG(MSGID_SETTINGS_SERVICE_REG_ERROR, lserror.message);
+		goto Exit;
+	}
+
+	return 0;
+Exit:
+
+	if (LSErrorIsSet(&lserror))
+	{
+		LSErrorPrint(&lserror, stderr);
+		LSErrorFree(&lserror);
+	}
+
+	return -1;
+}
diff --git a/src/wifi_p2p_service.h b/src/wifi_p2p_service.h
new file mode 100644
index 0000000..27d3c4f
--- /dev/null
+++ b/src/wifi_p2p_service.h
@@ -0,0 +1,69 @@
+/* @@@LICENSE
+*
+* Copyright (c) 2021 LG Electronics, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* LICENSE@@@ */
+
+/**
+ * @file  wifi_p2p_service.h
+ *
+ */
+
+
+#ifndef _WIFI_P2P_SERVICE_H_
+#define _WIFI_P2P_SERVICE_H_
+
+#include <luna-service2/lunaservice.h>
+
+#define LUNA_CATEGORY_P2P                 "/p2p"
+
+/**
+ * @name Luna WiFi P2P Method Names
+ * @{
+ */
+#define LUNA_METHOD_P2P_SETSTATE         "setstate"
+#define LUNA_METHOD_P2P_GETSTATE         "getstate"
+#define LUNA_METHOD_P2P_GETPEERS         "getpeers"
+#define LUNA_METHOD_P2P_CONNECT          "connect"
+#define LUNA_METHOD_P2P_DISCONNECT       "disconnect"
+#define LUNA_METHOD_P2P_INVITE               "invite"
+#define LUNA_METHOD_P2P_CREATEGROUP          "creategroup"
+#define LUNA_METHOD_P2P_DISCONNECTGROUP      "disconnectgroup"
+#define LUNA_METHOD_P2P_GETGROUPS            "getgroups"
+#define LUNA_METHOD_P2P_SETTETHERING         "settethering"
+#define LUNA_METHOD_P2P_GETGROUPPEERS        "getgrouppeers"
+#define LUNA_METHOD_P2P_SETDEVICENAME        "setdevicename"
+#define LUNA_METHOD_P2P_GETDEVICENAME        "getdevicename"
+#define LUNA_METHOD_P2P_SETWIFIDISPLAYINFO   "setwifidisplayinfo"
+#define LUNA_METHOD_P2P_GETWIFIDISPLAYINFO   "getwifidisplayinfo"
+#define LUNA_METHOD_P2P_GETP2PREQUESTS       "getp2prequests"
+#define LUNA_METHOD_P2P_FINDSERVICE          "findservice"
+#define LUNA_METHOD_P2P_ADDSERVICE           "addservice"
+#define LUNA_METHOD_P2P_DELETESERVICE        "deleteservice"
+#define LUNA_METHOD_P2P_CANCEL               "cancel"
+#define LUNA_METHOD_P2P_REJECTPEER           "rejectpeer"
+#define LUNA_METHOD_P2P_DELETE_PROFILE       "deleteprofile"
+#define LUNA_METHOD_P2P_SETLISTENPARAMS       "setlistenparams"
+#define LUNA_METHOD_P2P_SETLISTENCHANNEL       "setlistenchannel"
+#define LUNA_METHOD_P2P_SETGOINTENT           "setgointent"
+
+extern int initialize_wifi_p2p_ls2_calls(GMainLoop *mainloop,
+        LSHandle *pLsHandle);
+extern void send_peer_information_to_subscribers(void);
+extern void send_p2p_get_state_to_subscribers(void);
+extern void update_p2p_device_name(void);
+extern gboolean is_connected_peer(void);
+
+#endif /* _WIFI_P2P_SERVICE_H_ */
diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index df2ea5a..4f682ca 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2015-2020 LG Electronics, Inc.
+// Copyright (c) 2015-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -110,7 +110,7 @@ gboolean wifi_scan_now_p2p(void)
 {
 	gboolean result;
 
-	if (scan_running && scan_is_p2p)
+	if (scan_running && scan_is_p2p || is_connected_peer())
 	{
 		result = true;
 	}
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 6b24637..ee7ab2b 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2021 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -56,6 +56,7 @@ errorText | Yes | String | Error description
 #include "common.h"
 #include "connectionmanager_service.h"
 #include "logging.h"
+#include "wifi_p2p_service.h"
 #include "wifi_tethering_service.h"
 #include "errors.h"
 
@@ -1827,6 +1828,21 @@ static void manager_services_changed_callback(gpointer data,
 		mark_all_wifi_services_as_unchanged();
 	}
 
+	if (service_type & P2P_SERVICES_CHANGED)
+	{
+		GSList *listnode;
+                if(manager)
+                {
+			for (listnode = manager->p2p_services; listnode ; listnode = listnode->next)
+			{
+				connman_service_t *service = (connman_service_t *)(listnode->data);
+				setPropertyUpdateCallback(service);
+			}
+                }
+		connectionmanager_send_status_to_subscribers();
+		send_peer_information_to_subscribers();
+	}
+
 	if (service_type & ETHERNET_SERVICES_CHANGED)
 	{
 		connectionmanager_send_status_to_subscribers();
@@ -2071,6 +2087,28 @@ static void check_and_initialize_ethernet_technology(void)
 	}
 }
 
+static void check_and_initialize_p2p_technology(void)
+{
+
+	connman_technology_t *technology = connman_manager_find_p2p_technology(
+	                                       manager);
+
+	if (technology)
+	{
+		connman_technology_register_property_changed_cb(technology,
+		        technology_property_changed_callback);
+
+		if (technology->powered)
+		{
+			//send_p2p_get_state_to_subscribers();
+			//initialize_wfds();
+		}
+
+	}
+
+}
+
+
 static void check_and_initialize_wifi_technology(void)
 {
 	connman_technology_t *technology = connman_manager_find_wifi_technology(
@@ -2084,6 +2122,8 @@ static void check_and_initialize_wifi_technology(void)
 		connman_technology_register_property_changed_cb(technology,
 		        technology_property_changed_callback);
 
+		update_p2p_device_name();
+
 		if (technology->powered)
 		{
 			wifi_scan_start(technology);
@@ -2106,6 +2146,7 @@ static void check_and_initialize_wifi_technology(void)
 static void manager_technologies_changed_callback(gpointer data)
 {
 	check_and_initialize_wifi_technology();
+	check_and_initialize_p2p_technology();
 	check_and_initialize_ethernet_technology();
 }
 
@@ -3889,6 +3930,9 @@ static void connman_service_stopped(GDBusConnection *conn, const gchar *name,
 	}
 }
 
+extern void manager_groups_changed_callback(gpointer data,
+        gboolean group_added);
+
 static void connman_service_started(GDBusConnection *conn, const gchar *name,
                                     const gchar *name_owner, gpointer user_data)
 {
@@ -3934,8 +3978,11 @@ static void connman_service_started(GDBusConnection *conn, const gchar *name,
 	        manager_services_changed_callback);
 	connman_manager_register_technologies_changed_cb(manager,
 	        manager_technologies_changed_callback);
+	connman_manager_register_groups_changed_cb(manager,
+	                                           manager_groups_changed_callback);
 
 	check_and_initialize_wifi_technology();
+	check_and_initialize_p2p_technology();
 	check_and_initialize_ethernet_technology();
 
 	connectionmanager_send_status_to_subscribers();
@@ -4038,6 +4085,7 @@ int initialize_wifi_ls2_calls(GMainLoop *mainloop , LSHandle **wifi_handle)
 
 	init_wifi_profile_list();
 
+	initialize_wifi_p2p_ls2_calls(mainloop, pLsHandle);
 	initialize_wifi_tethering_ls2_calls(mainloop, pLsHandle);
 
 	*wifi_handle = pLsHandle;

commit 68ef60bf359877dbf8fd829908416c895f8fa006
Merge: 83a1089 02b2c6d
Author: rajesh.kanna <rajesh.kanna@lge.com>
Date:   Mon Feb 1 16:51:01 2021 +0530

    Merge remote-tracking branch 'remotes/origin/develop'
    
    Change-Id: I141f00744d9b9b18f468fa1ce81970f0c77277d6

commit b879efa0dbf6ef65d3c14519c0c1adbc24870d3d
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Tue Feb 2 09:48:45 2021 +0530

    Check P2P technology available for p2p/getdevicename
    
    :Release Notes:
    P2P technology available need to be checked
    
    :Detailed Notes:
    Observed a crash for p2p/getdevicename when WiFi tech is disabled.
    luna-send -n 1 -f luna://com.webos.service.wifi/p2p/getdevicename '{}'
    Address correct P2P tech check to fix it.
    
    :Testing Performed:
    Build successfully
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-131752] Integrating and verification p2p/getdevicename,
                  p2p/getgrouppeers, p2p/getgroups Luna API
    
    Change-Id: I185dcd0bee31124e931ee250fb2dd08e26862fc1

diff --git a/src/wifi_p2p_service.c b/src/wifi_p2p_service.c
index a2a04ac..2697734 100644
--- a/src/wifi_p2p_service.c
+++ b/src/wifi_p2p_service.c
@@ -2509,7 +2509,7 @@ static bool handle_get_device_name_command(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
-	if (!wifi_technology_status_check(sh, message))
+	if (!p2p_technology_status_check(sh, message))
 	{
 		return true;
 	}

commit 8a3213a63e0e47b965e22683d69c16692fc8345d
Merge: 68ef60b b879efa
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Tue Feb 2 13:13:18 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I167e44b0dd984178317dde1911ca4944fa43e22b

commit e3c9defbde70e9119fff806a4743a0bcd1e391d2
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Tue Feb 2 14:35:47 2021 +0530

    Modifying setIpv4 setIpv6 setdns to support multiple wired interface
    
    :Release Notes:
    Update setIpv4 setIpv6 setdns for multiple wired interface and
    
    :Detailed Notes:
    Modifying setIpv4 setIpv6 setdns to support multiple wired interface
    
    :Testing Performed:
    Built and Tested
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [PLAT-123940] Integration of setipv4/setipv6/setDNS in OSE & auto
    
    Change-Id: I2ce351fc7177aeb4224f39d2929080a9e78cb007

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 8816369..ea7a686 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -998,7 +998,7 @@ cleanup:
  * @return Connman service object or NULL in case of a failure.
  */
 
-static connman_service_t *retrieve_service_by_ssid(gchar *ssid)
+static connman_service_t *retrieve_service_by_ssid(gchar *ssid, gchar *interface_name)
 {
 	if (NULL != ssid)
 	{
@@ -1020,6 +1020,28 @@ static connman_service_t *retrieve_service_by_ssid(gchar *ssid)
 		/* Return the first wired service (there will be just one on most systems) */
 		GSList *ap = manager->wired_services;
 
+		if (interface_name)
+		{
+			/* Look up for the Wired service with the given interface_name */
+			for (; ap; ap = ap->next)
+			{
+				connman_service_t *service = (connman_service_t *)(ap->data);
+				if (!g_strcmp0(service->interface_name, interface_name))
+				{
+					return service;
+				}
+			}
+			return NULL;
+		}
+		else
+		{
+			connman_service_t *service = connman_manager_get_default_service(manager->wired_services);
+			if(service != NULL)
+			{
+				return service;
+			}
+		}
+
 		if (ap != NULL)
 		{
 			return (connman_service_t *) ap->data;
@@ -1077,18 +1099,19 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
 	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(method, string), PROP(address,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_6(PROP(method, string), PROP(address,
 	                                     string),
 	                                     PROP(netmask, string), PROP(gateway, string), PROP(ssid,
-	                                             string)) REQUIRED_1(method))), &parsedObj))
+	                                             string),PROP(interfaceName, string)) REQUIRED_1(method))), &parsedObj))
 	{
 		return true;
 	}
 
 	jvalue_ref ssidObj = {0}, methodObj = {0}, addressObj = {0}, netmaskObj = {0},
-	           gatewayObj = {0};
+	           gatewayObj = {0}, interfaceNameObj = {0};
 	ipv4info_t ipv4 = {0};
 	gchar *ssid = NULL;
+	gchar *interface_name = NULL;
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
 	{
@@ -1140,7 +1163,15 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 		jstring_free_buffer(ssid_buf);
 	}
 
-	service = retrieve_service_by_ssid(ssid);
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interfaceName"), &interfaceNameObj))
+	{
+		raw_buffer interfaceName_buf = jstring_get(interfaceNameObj);
+		interface_name = g_strdup(interfaceName_buf.m_str);
+		jstring_free_buffer(interfaceName_buf);
+	}
+
+	service = retrieve_service_by_ssid(ssid, interface_name);
+
 
 	if (NULL != service)
 	{
@@ -1195,6 +1226,12 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 				goto exit;
 			}
 		}
+		else if(interface_name)
+		{
+			LSMessageReplyCustomError(sh, message, "Invalid Interface",
+		                          WCA_API_ERROR_INTERFACE_NOT_CONNECTED);
+			goto exit;
+		}
 
 		LSMessageReplyCustomError(sh, message, "Network not found",
 		                          WCA_API_ERROR_NETWORK_NOT_FOUND);
@@ -1210,6 +1247,7 @@ exit:
 	g_free(ipv4.netmask);
 	g_free(ipv4.gateway);
 	g_free(ssid);
+	g_free(interface_name);
 	j_release(&parsedObj);
 	return true;
 }
@@ -1225,19 +1263,20 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
 	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_5(PROP(method, string), PROP(address,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_6(PROP(method, string), PROP(address,
 	                                     string),
 	                                     PROP(prefixLength, integer), PROP(gateway, string), PROP(ssid,
-	                                             string)) REQUIRED_1(method))), &parsedObj))
+	                                             string), PROP(interfaceName, string)) REQUIRED_1(method))), &parsedObj))
 	{
 		return true;
 	}
 
 	jvalue_ref ssidObj = {0}, methodObj = {0}, addressObj = {0}, prefixLengthObj = {0},
-	           gatewayObj = {0};
+	           gatewayObj = {0}, interfaceNameObj = {0};
 	ipv6info_t ipv6 = {0};
 	gchar *ssid = NULL;
 	connman_service_t *service = NULL;
+	gchar *interface_name = NULL;
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
 	{
@@ -1285,7 +1324,15 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 		jstring_free_buffer(ssid_buf);
 	}
 
-	service = retrieve_service_by_ssid(ssid);
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interfaceName"), &interfaceNameObj))
+	{
+		raw_buffer interfaceName_buf = jstring_get(interfaceNameObj);
+		interface_name = g_strdup(interfaceName_buf.m_str);
+		jstring_free_buffer(interfaceName_buf);
+	}
+
+	service = retrieve_service_by_ssid(ssid, interface_name);
+
 
 	if (NULL != service)
 	{
@@ -1341,6 +1388,12 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 				goto exit;
 			}
 		}
+		else if(interface_name)
+		{
+			LSMessageReplyCustomError(sh, message, "Invalid Interface",
+		                          WCA_API_ERROR_INTERFACE_NOT_CONNECTED);
+			goto exit;
+		}
 
 		LSMessageReplyCustomError(sh, message, "Network not found",
 		                          WCA_API_ERROR_NETWORK_NOT_FOUND);
@@ -1356,6 +1409,7 @@ exit:
 	g_free(ipv6.address);
 	g_free(ipv6.gateway);
 	g_free(ssid);
+	g_free(interface_name);
 	j_release(&parsedObj);
 	return true;
 }
@@ -1403,16 +1457,17 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
 	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_2(ARRAY(dns, string), PROP(ssid,
-	                                     string)) REQUIRED_1(dns))), &parsedObj))
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_3(ARRAY(dns, string), PROP(ssid,
+	                                     string), PROP(interfaceName, string)) REQUIRED_1(dns))), &parsedObj))
 	{
 		return true;
 	}
 
-	jvalue_ref ssidObj = {0}, dnsObj = {0};
+	jvalue_ref ssidObj = {0}, dnsObj = {0}, interfaceNameObj = {0};
 	GStrv dns = NULL;
 	gchar *ssid = NULL;
 	connman_service_t *service = NULL;
+	gchar *interface_name = NULL;
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dns"), &dnsObj))
 	{
@@ -1441,7 +1496,15 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 		jstring_free_buffer(ssid_buf);
 	}
 
-	service = retrieve_service_by_ssid(ssid);
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interfaceName"), &interfaceNameObj))
+	{
+		raw_buffer interfaceName_buf = jstring_get(interfaceNameObj);
+		interface_name = g_strdup(interfaceName_buf.m_str);
+		jstring_free_buffer(interfaceName_buf);
+	}
+
+	service = retrieve_service_by_ssid(ssid, interface_name);
+
 
 	if (NULL != service)
 	{
@@ -1473,6 +1536,12 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 				goto exit;
 			}
 		}
+		else if(interface_name)
+		{
+			LSMessageReplyCustomError(sh, message, "Invalid Interface",
+		                          WCA_API_ERROR_INTERFACE_NOT_CONNECTED);
+			goto exit;
+		}
 
 		LSMessageReplyCustomError(sh, message, "No connected network",
 		                          WCA_API_ERROR_NO_CONNECTED_NW);
@@ -1485,6 +1554,7 @@ invalid_params:
 exit:
 	g_strfreev(dns);
 	g_free(ssid);
+	g_free(interface_name);
 	j_release(&parsedObj);
 	return true;
 }
@@ -2624,7 +2694,7 @@ static bool handle_set_proxy_command(LSHandle *sh,
 			goto invalid_params;
 	}
 
-	service = retrieve_service_by_ssid(ssid);
+	service = retrieve_service_by_ssid(ssid,NULL);
 
 	if (NULL != service)
 	{
diff --git a/src/connman_service.c b/src/connman_service.c
index 8d398e6..2f77df2 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1181,7 +1181,7 @@ static void connman_service_advance_state(connman_service_t *service,
 			connman_service_get_ipinfo(service);
 			connman_service_create_ip_rule(service);
 		}
-		else if((!g_strcmp0(new_state, "online")) && (service->type == CONNMAN_SERVICE_TYPE_ETHERNET))
+		else if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
 		{
 			connman_service_delete_ip_rule(service);
 		}

commit 62a6b9fd1fcd68b21afd7fb28efb2bf215e30e7e
Merge: 8a3213a e3c9def
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Wed Feb 3 21:32:31 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I1c7a5d5620c689cba1df8c034c47518be71e119a

commit e344290ebdcb2b0c485ce8f2d2b8b35ccdb9db79
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Wed Feb 10 17:19:44 2021 +0530

    Fixed swmd issues in webos-connman-adapter
    
    :Release Notes:
    Fixed swmd issues in webos-connman-adapter
    
    :Detailed Notes:
    Reduced cyclomatic complexity in webos-connman-adapter
    
    :Testing Performed:
    Built and Tested
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [PLAT-123933] Analyze and fix swmd issues in webos-connman-adapter
    
    Change-Id: Id4dc146185256ef38e1f38730c9b2a2c03888110

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index ea7a686..1183b49 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -96,6 +96,35 @@ static void getinfo_update(void);
 
 #define IS_WIRED_PLUGGED() g_slist_length(manager->wired_services)
 
+static void update_string_value(jvalue_ref *status, jvalue_ref key, gchar *inVal)
+{
+	if (NULL != inVal)
+		jobject_put(*status,key, jstring_create(inVal));
+}
+
+static void update_ipv6(jvalue_ref *status, connman_service_t *service)
+{
+	if (NULL != service->ipinfo.ipv6.address)
+	{
+		jvalue_ref connected_ipv6_status = jobject_create();
+
+		jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("ipAddress"),
+					jstring_create(service->ipinfo.ipv6.address));
+
+		if (service->ipinfo.ipv6.prefix_length >= 0 &&
+				service->ipinfo.ipv6.prefix_length <= 128)
+		{
+			jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("prefixLength"),
+						jnumber_create_i32(service->ipinfo.ipv6.prefix_length));
+		}
+
+		update_string_value(&connected_ipv6_status, J_CSTR_TO_JVAL("gateway"),service->ipinfo.ipv6.gateway);
+		update_string_value(&connected_ipv6_status, J_CSTR_TO_JVAL("method"),service->ipinfo.ipv6.method);
+
+		jobject_put(*status, J_CSTR_TO_JVAL("ipv6"), connected_ipv6_status);
+	}
+
+}
 /**
  * @brief Fill in information about the system's connection status
  *
@@ -122,29 +151,10 @@ static void update_connection_status(connman_service_t *connected_service,
 		connman_service_get_ipinfo(connected_service);
 		jobject_put(*status, J_CSTR_TO_JVAL("state"), jstring_create("connected"));
 
-		if (NULL != connected_service->ipinfo.iface)
-		{
-			jobject_put(*status, J_CSTR_TO_JVAL("interfaceName"),
-			            jstring_create(connected_service->ipinfo.iface));
-		}
-
-		if (NULL != connected_service->ipinfo.ipv4.address)
-		{
-			jobject_put(*status, J_CSTR_TO_JVAL("ipAddress"),
-			            jstring_create(connected_service->ipinfo.ipv4.address));
-		}
-
-		if (NULL != connected_service->ipinfo.ipv4.netmask)
-		{
-			jobject_put(*status, J_CSTR_TO_JVAL("netmask"),
-			            jstring_create(connected_service->ipinfo.ipv4.netmask));
-		}
-
-		if (NULL != connected_service->ipinfo.ipv4.gateway)
-		{
-			jobject_put(*status, J_CSTR_TO_JVAL("gateway"),
-			            jstring_create(connected_service->ipinfo.ipv4.gateway));
-		}
+		update_string_value(status, J_CSTR_TO_JVAL("interfaceName"),connected_service->ipinfo.iface);
+		update_string_value(status, J_CSTR_TO_JVAL("ipAddress"),connected_service->ipinfo.ipv4.address);
+		update_string_value(status, J_CSTR_TO_JVAL("netmask"),connected_service->ipinfo.ipv4.netmask);
+		update_string_value(status, J_CSTR_TO_JVAL("gateway"),connected_service->ipinfo.ipv4.gateway);
 
 		gsize i;
 		char dns_str[16];
@@ -156,20 +166,11 @@ static void update_connection_status(connman_service_t *connected_service,
 			            jstring_create(connected_service->ipinfo.dns[i]));
 		}
 
-		if (NULL != connected_service->ipinfo.ipv4.method)
-		{
-			jobject_put(*status, J_CSTR_TO_JVAL("method"),
-			            jstring_create(connected_service->ipinfo.ipv4.method));
-		}
+		update_string_value(status, J_CSTR_TO_JVAL("method"),connected_service->ipinfo.ipv4.method);
 
 		if (connman_service_type_wifi(connected_service))
 		{
-			if (NULL != connected_service->name)
-			{
-				jobject_put(*status, J_CSTR_TO_JVAL("ssid"),
-				            jstring_create(connected_service->name));
-			}
-
+			update_string_value(status, J_CSTR_TO_JVAL("ssid"),connected_service->name);
 			jobject_put(*status, J_CSTR_TO_JVAL("isWakeOnWifiEnabled"),
 			            jboolean_create(false));
 		}
@@ -178,34 +179,7 @@ static void update_connection_status(connman_service_t *connected_service,
 		jobject_put(*status, J_CSTR_TO_JVAL("onInternet"), jstring_create(s));
 		jobject_put(*status, J_CSTR_TO_JVAL("checkingInternet"), jboolean_create(connected_service->online_checking));
 
-		if (NULL != connected_service->ipinfo.ipv6.address)
-		{
-			jvalue_ref connected_ipv6_status = jobject_create();
-
-			jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("ipAddress"),
-			            jstring_create(connected_service->ipinfo.ipv6.address));
-
-			if (connected_service->ipinfo.ipv6.prefix_length >= 0 &&
-			        connected_service->ipinfo.ipv6.prefix_length <= 128)
-			{
-				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("prefixLength"),
-				            jnumber_create_i32(connected_service->ipinfo.ipv6.prefix_length));
-			}
-
-			if (NULL != connected_service->ipinfo.ipv6.gateway)
-			{
-				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("gateway"),
-				            jstring_create(connected_service->ipinfo.ipv6.gateway));
-			}
-
-			if (NULL != connected_service->ipinfo.ipv6.method)
-			{
-				jobject_put(connected_ipv6_status, J_CSTR_TO_JVAL("method"),
-				            jstring_create(connected_service->ipinfo.ipv6.method));
-			}
-
-			jobject_put(*status, J_CSTR_TO_JVAL("ipv6"), connected_ipv6_status);
-		}
+		update_ipv6(status,connected_service);
 
 		connman_service_get_proxyinfo(connected_service);
 
@@ -218,11 +192,7 @@ static void update_connection_status(connman_service_t *connected_service,
 
 			if (!g_strcmp0(connected_service->proxyinfo.method, "auto"))
 			{
-				if (NULL != connected_service->proxyinfo.url)
-				{
-					jobject_put(connected_proxy_status, J_CSTR_TO_JVAL("url"),
-								jstring_create(connected_service->proxyinfo.url));
-				}
+				update_string_value(&connected_proxy_status, J_CSTR_TO_JVAL("url"),connected_service->proxyinfo.url);
 			}
 			else if(!g_strcmp0(connected_service->proxyinfo.method, "manual"))
 			{
@@ -1051,6 +1021,57 @@ static connman_service_t *retrieve_service_by_ssid(gchar *ssid, gchar *interface
 	return NULL;
 }
 
+static void get_string_value(jvalue_ref parsedObj,raw_buffer key, gchar **outVal)
+{
+	jvalue_ref Obj = {0};
+	if (jobject_get_exists(parsedObj, key, &Obj))
+	{
+		raw_buffer obj_buf = jstring_get(Obj);
+		*outVal = g_strdup(obj_buf.m_str);
+		jstring_free_buffer(obj_buf);
+	}
+}
+
+static bool get_ipv4_value(jvalue_ref parsedObj, ipv4info_t* ipv4info)
+{
+	jvalue_ref addressObj = {0}, netmaskObj = {0}, gatewayObj = {0};
+
+	get_string_value(parsedObj,J_CSTR_TO_BUF("method"),&(ipv4info->method));
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
+	{
+		raw_buffer address_buf = jstring_get(addressObj);
+		ipv4info->address = g_strdup(address_buf.m_str);
+		jstring_free_buffer(address_buf);
+
+		if (!is_valid_ipaddress(ipv4info->address))
+			return false;
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("netmask"), &netmaskObj))
+	{
+		raw_buffer netmask_buf = jstring_get(netmaskObj);
+		ipv4info->netmask = g_strdup(netmask_buf.m_str);
+		jstring_free_buffer(netmask_buf);
+
+		if (!is_valid_ipaddress(ipv4info->netmask))
+			return false;
+
+	}
+
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("gateway"), &gatewayObj))
+	{
+		raw_buffer gateway_buf = jstring_get(gatewayObj);
+		ipv4info->gateway = g_strdup(gateway_buf.m_str);
+		jstring_free_buffer(gateway_buf);
+
+		if (!is_valid_ipaddress(ipv4info->gateway))
+			return false;
+	}
+
+	return true;
+}
+
 //->Start of API documentation comment block
 /**
 @page com_webos_connectionmanager com.webos.connectionmanager
@@ -1107,68 +1128,16 @@ static bool handle_set_ipv4_command(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
-	jvalue_ref ssidObj = {0}, methodObj = {0}, addressObj = {0}, netmaskObj = {0},
-	           gatewayObj = {0}, interfaceNameObj = {0};
 	ipv4info_t ipv4 = {0};
 	gchar *ssid = NULL;
 	gchar *interface_name = NULL;
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
-	{
-		raw_buffer method_buf = jstring_get(methodObj);
-		ipv4.method = g_strdup(method_buf.m_str);
-		jstring_free_buffer(method_buf);
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
-	{
-		raw_buffer address_buf = jstring_get(addressObj);
-		ipv4.address = g_strdup(address_buf.m_str);
-		jstring_free_buffer(address_buf);
-
-		if (!is_valid_ipaddress(ipv4.address))
-		{
-			goto invalid_params;
-		}
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("netmask"), &netmaskObj))
-	{
-		raw_buffer netmask_buf = jstring_get(netmaskObj);
-		ipv4.netmask = g_strdup(netmask_buf.m_str);
-		jstring_free_buffer(netmask_buf);
 
-		if (!is_valid_ipaddress(ipv4.netmask))
-		{
-			goto invalid_params;
-		}
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("gateway"), &gatewayObj))
-	{
-		raw_buffer gateway_buf = jstring_get(gatewayObj);
-		ipv4.gateway = g_strdup(gateway_buf.m_str);
-		jstring_free_buffer(gateway_buf);
-
-		if (!is_valid_ipaddress(ipv4.gateway))
-		{
-			goto invalid_params;
-		}
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
-	{
-		raw_buffer ssid_buf = jstring_get(ssidObj);
-		ssid = g_strdup(ssid_buf.m_str);
-		jstring_free_buffer(ssid_buf);
-	}
+	if(!get_ipv4_value(parsedObj,&ipv4))
+		goto invalid_params;
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interfaceName"), &interfaceNameObj))
-	{
-		raw_buffer interfaceName_buf = jstring_get(interfaceNameObj);
-		interface_name = g_strdup(interfaceName_buf.m_str);
-		jstring_free_buffer(interfaceName_buf);
-	}
+	get_string_value(parsedObj,J_CSTR_TO_BUF("ssid"),&ssid);
+	get_string_value(parsedObj,J_CSTR_TO_BUF("interfaceName"),&interface_name);
 
 	service = retrieve_service_by_ssid(ssid, interface_name);
 
@@ -1252,49 +1221,21 @@ exit:
 	return true;
 }
 
-static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
-                                    void *context)
-{
-	if (!connman_status_check(manager, sh, message))
-	{
-		return true;
-	}
-
-	// To prevent memory leaks, schema should be checked before the variables will be initialized.
-	jvalue_ref parsedObj = {0};
-	if (!LSMessageValidateSchema(sh, message,
-	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_6(PROP(method, string), PROP(address,
-	                                     string),
-	                                     PROP(prefixLength, integer), PROP(gateway, string), PROP(ssid,
-	                                             string), PROP(interfaceName, string)) REQUIRED_1(method))), &parsedObj))
-	{
-		return true;
-	}
 
-	jvalue_ref ssidObj = {0}, methodObj = {0}, addressObj = {0}, prefixLengthObj = {0},
-	           gatewayObj = {0}, interfaceNameObj = {0};
-	ipv6info_t ipv6 = {0};
-	gchar *ssid = NULL;
-	connman_service_t *service = NULL;
-	gchar *interface_name = NULL;
+static bool get_ipv6_value(jvalue_ref parsedObj, ipv6info_t* ipv6info)
+{
+	jvalue_ref addressObj = {0}, prefixLengthObj = {0}, gatewayObj = {0};
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("method"), &methodObj))
-	{
-		raw_buffer method_buf = jstring_get(methodObj);
-		ipv6.method = g_strdup(method_buf.m_str);
-		jstring_free_buffer(method_buf);
-	}
+	get_string_value(parsedObj,J_CSTR_TO_BUF("method"),&(ipv6info->method));
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("address"), &addressObj))
 	{
 		raw_buffer address_buf = jstring_get(addressObj);
-		ipv6.address = g_strdup(address_buf.m_str);
+		ipv6info->address = g_strdup(address_buf.m_str);
 		jstring_free_buffer(address_buf);
 
-		if (!is_valid_ipv6address(ipv6.address))
-		{
-			goto invalid_params;
-		}
+		if (!is_valid_ipv6address(ipv6info->address))
+			return false;
 	}
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("prefixLength"),
@@ -1302,35 +1243,52 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 	{
 		int prefixLength_val = 0;
 		jnumber_get_i32(prefixLengthObj, &prefixLength_val);
-		ipv6.prefix_length = prefixLength_val;
+		ipv6info->prefix_length = prefixLength_val;
 	}
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("gateway"), &gatewayObj))
 	{
 		raw_buffer gateway_buf = jstring_get(gatewayObj);
-		ipv6.gateway = g_strdup(gateway_buf.m_str);
+		ipv6info->gateway = g_strdup(gateway_buf.m_str);
 		jstring_free_buffer(gateway_buf);
 
-		if (!is_valid_ipv6address(ipv6.gateway))
-		{
-			goto invalid_params;
-		}
+		if (!is_valid_ipv6address(ipv6info->gateway))
+			return false;
 	}
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
+	return true;
+}
+
+static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
+                                    void *context)
+{
+	if (!connman_status_check(manager, sh, message))
 	{
-		raw_buffer ssid_buf = jstring_get(ssidObj);
-		ssid = g_strdup(ssid_buf.m_str);
-		jstring_free_buffer(ssid_buf);
+		return true;
 	}
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interfaceName"), &interfaceNameObj))
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_6(PROP(method, string), PROP(address,
+	                                     string),
+	                                     PROP(prefixLength, integer), PROP(gateway, string), PROP(ssid,
+	                                             string), PROP(interfaceName, string)) REQUIRED_1(method))), &parsedObj))
 	{
-		raw_buffer interfaceName_buf = jstring_get(interfaceNameObj);
-		interface_name = g_strdup(interfaceName_buf.m_str);
-		jstring_free_buffer(interfaceName_buf);
+		return true;
 	}
 
+	ipv6info_t ipv6 = {0};
+	gchar *ssid = NULL;
+	connman_service_t *service = NULL;
+	gchar *interface_name = NULL;
+
+	if(!get_ipv6_value(parsedObj,&ipv6))
+		goto invalid_params;
+
+	get_string_value(parsedObj,J_CSTR_TO_BUF("ssid"),&ssid);
+	get_string_value(parsedObj,J_CSTR_TO_BUF("interfaceName"),&interface_name);
+
 	service = retrieve_service_by_ssid(ssid, interface_name);
 
 
@@ -1463,7 +1421,7 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
-	jvalue_ref ssidObj = {0}, dnsObj = {0}, interfaceNameObj = {0};
+	jvalue_ref dnsObj = {0};
 	GStrv dns = NULL;
 	gchar *ssid = NULL;
 	connman_service_t *service = NULL;
@@ -1489,19 +1447,8 @@ static bool handle_set_dns_command(LSHandle *sh, LSMessage *message,
 		dns[dns_arrsize] = NULL;
 	}
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
-	{
-		raw_buffer ssid_buf = jstring_get(ssidObj);
-		ssid = g_strdup(ssid_buf.m_str);
-		jstring_free_buffer(ssid_buf);
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("interfaceName"), &interfaceNameObj))
-	{
-		raw_buffer interfaceName_buf = jstring_get(interfaceNameObj);
-		interface_name = g_strdup(interfaceName_buf.m_str);
-		jstring_free_buffer(interfaceName_buf);
-	}
+	get_string_value(parsedObj,J_CSTR_TO_BUF("ssid"),&ssid);
+	get_string_value(parsedObj,J_CSTR_TO_BUF("interfaceName"),&interface_name);
 
 	service = retrieve_service_by_ssid(ssid, interface_name);
 
@@ -2633,7 +2580,7 @@ static bool handle_set_proxy_command(LSHandle *sh,
 		return true;
 	}
 
-	jvalue_ref ssidObj = {0}, methodObj = {0}, urlObj = {0}, serversObj = {0}, excludesObj = {0};
+	jvalue_ref methodObj = {0}, urlObj = {0}, serversObj = {0}, excludesObj = {0};
 	proxyinfo_t proxyinfo = {0};
 	gchar *ssid = NULL;
 
@@ -2681,12 +2628,7 @@ static bool handle_set_proxy_command(LSHandle *sh,
 		proxyinfo.excludes[excludes_arrsize] = NULL;
 	}
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
-	{
-		raw_buffer ssid_buf = jstring_get(ssidObj);
-		ssid = g_strdup(ssid_buf.m_str);
-		jstring_free_buffer(ssid_buf);
-	}
+	get_string_value(parsedObj,J_CSTR_TO_BUF("ssid"),&ssid);
 
 	if (!g_strcmp0(proxyinfo.method, "manual"))
 	{
@@ -2742,22 +2684,10 @@ static bool handle_find_proxy_for_url_command(LSHandle *sh,
 	jvalue_ref reply = jobject_create();
 	LSError lserror;
 	LSErrorInit(&lserror);
-	jvalue_ref urlObj = {0}, hostObj = {0};
 	gchar *url = NULL, *host = NULL, *proxy = NULL;
 
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("url"), &urlObj))
-	{
-		raw_buffer url_buf = jstring_get(urlObj);
-		url = g_strdup(url_buf.m_str);
-		jstring_free_buffer(url_buf);
-	}
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("host"), &hostObj))
-	{
-		raw_buffer host_buf = jstring_get(hostObj);
-		host = g_strdup(host_buf.m_str);
-		jstring_free_buffer(host_buf);
-	}
+	get_string_value(parsedObj,J_CSTR_TO_BUF("url"),&url);
+	get_string_value(parsedObj,J_CSTR_TO_BUF("host"),&host);
 
 	pacrunner_client_t *client = pacrunner_client_new();
 
@@ -2815,7 +2745,7 @@ static bool handle_set_default_interface(LSHandle *sh, LSMessage *message,
 	}
 
 	connman_service_t *service = NULL;
-	gchar *interfaceName = NULL;
+	gchar *interface_name = NULL;
 
 	// To prevent memory leaks, schema should be checked before the variables will be initialized.
 	jvalue_ref parsedObj = {0};
@@ -2825,16 +2755,8 @@ static bool handle_set_default_interface(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
-	jvalue_ref interfaceObj = {0};
-
-	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ifName"), &interfaceObj))
-	{
-		raw_buffer interface_buf = jstring_get(interfaceObj);
-		interfaceName = g_strdup(interface_buf.m_str);
-		jstring_free_buffer(interface_buf);
-	}
-
-	service = connman_manager_retreive_service_by_interfaceName(manager->wired_services ,interfaceName);
+	get_string_value(parsedObj,J_CSTR_TO_BUF("ifName"),&interface_name);
+	service = connman_manager_retreive_service_by_interfaceName(manager->wired_services ,interface_name);
 
 	if (NULL != service)
 	{
@@ -2869,7 +2791,7 @@ static bool handle_set_default_interface(LSHandle *sh, LSMessage *message,
 									WCA_API_ERROR_INTERFACE_NOT_CONNECTED);
 	}
 
-	g_free(interfaceName);
+	g_free(interface_name);
 	j_release(&parsedObj);
 	return true;
 }
diff --git a/src/connman_service.c b/src/connman_service.c
index 2f77df2..2cd2017 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -743,6 +743,30 @@ gboolean compare_strv(gchar **first, gchar **second)
 	return TRUE;
 }
 
+static void update_string_val_from_first_element(GVariant *inVal, gchar **outVal)
+{
+	GVariant *inValv = g_variant_get_child_value(inVal, 1);
+	GVariant *inValva = g_variant_get_variant(inValv);
+
+	g_free(*outVal);
+	*outVal = g_variant_dup_string(inValva, NULL);
+
+	g_variant_unref(inValv);
+	g_variant_unref(inValva);
+}
+
+static gint get_int_val_from_first_element(GVariant *inVal)
+{
+	GVariant *inValv = g_variant_get_child_value(inVal, 1);
+	GVariant *inValva = g_variant_get_variant(inValv);
+	const char *prefix_length = g_variant_get_data(inValva);
+	gint retval = *prefix_length;
+
+	g_variant_unref(inValv);
+	g_variant_unref(inValva);
+	return retval;
+}
+
 /**
  * Get all the network related information for a connected service (in online state)
  * (see header for API details)
@@ -757,7 +781,6 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 
 	GError *error = NULL;
 	GVariant *properties;
-	gsize i;
 
 	connman_interface_service_call_get_properties_sync(service->remote, &properties,
 	        NULL, &error);
@@ -769,7 +792,7 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 		return FALSE;
 	}
 
-	for (i = 0; i < g_variant_n_children(properties); i++)
+	for (gsize i = 0; i < g_variant_n_children(properties); i++)
 	{
 		GVariant *property = g_variant_get_child_value(properties, i);
 		GVariant *key_v = g_variant_get_child_value(property, 0);
@@ -779,25 +802,15 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 		{
 			GVariant *v = g_variant_get_child_value(property, 1);
 			GVariant *va = g_variant_get_child_value(v, 0);
-			gsize j;
 
-			for (j = 0; j < g_variant_n_children(va); j++)
+			for (gsize j = 0; j < g_variant_n_children(va); j++)
 			{
 				GVariant *ethernet = g_variant_get_child_value(va, j);
 				GVariant *ekey_v = g_variant_get_child_value(ethernet, 0);
 				const gchar *ekey = g_variant_get_string(ekey_v, NULL);
 
 				if (!g_strcmp0(ekey, "Interface"))
-				{
-					GVariant *ifacev = g_variant_get_child_value(ethernet, 1);
-					GVariant *ifaceva = g_variant_get_variant(ifacev);
-
-					g_free(service->ipinfo.iface);
-					service->ipinfo.iface = g_variant_dup_string(ifaceva, NULL);
-
-					g_variant_unref(ifacev);
-					g_variant_unref(ifaceva);
-				}
+					update_string_val_from_first_element(ethernet,&(service->ipinfo.iface));
 
 				g_variant_unref(ethernet);
 				g_variant_unref(ekey_v);
@@ -812,61 +825,24 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 
 			GVariant *v = g_variant_get_child_value(property, 1);
 			GVariant *va = g_variant_get_child_value(v, 0);
-			gsize j;
 
-			for (j = 0; j < g_variant_n_children(va); j++)
+			for (gsize j = 0; j < g_variant_n_children(va); j++)
 			{
 				GVariant *ipv6 = g_variant_get_child_value(va, j);
 				GVariant *ikey_v = g_variant_get_child_value(ipv6, 0);
 				const gchar *ikey = g_variant_get_string(ikey_v, NULL);
 
 				if (!g_strcmp0(ikey, "Method"))
-				{
-					GVariant *methodv = g_variant_get_child_value(ipv6, 1);
-					GVariant *methodva = g_variant_get_variant(methodv);
-
-					g_free(service->ipinfo.ipv6.method);
-					service->ipinfo.ipv6.method = g_variant_dup_string(methodva, NULL);
-
-					g_variant_unref(methodv);
-					g_variant_unref(methodva);
-				}
+					update_string_val_from_first_element(ipv6,&(service->ipinfo.ipv6.method));
 
 				if (!g_strcmp0(ikey, "PrefixLength"))
-				{
-					GVariant *prefix_lengthv = g_variant_get_child_value(ipv6, 1);
-					GVariant *prefix_lengthva = g_variant_get_variant(prefix_lengthv);
-					const char *prefix_length = g_variant_get_data(prefix_lengthva);
-
-					service->ipinfo.ipv6.prefix_length = *prefix_length;
-
-					g_variant_unref(prefix_lengthv);
-					g_variant_unref(prefix_lengthva);
-				}
+					service->ipinfo.ipv6.prefix_length = get_int_val_from_first_element(ipv6);
 
 				if (!g_strcmp0(ikey, "Address"))
-				{
-					GVariant *addressv = g_variant_get_child_value(ipv6, 1);
-					GVariant *addressva = g_variant_get_variant(addressv);
-
-					g_free(service->ipinfo.ipv6.address);
-					service->ipinfo.ipv6.address = g_variant_dup_string(addressva, NULL);
-
-					g_variant_unref(addressv);
-					g_variant_unref(addressva);
-				}
+					update_string_val_from_first_element(ipv6,&(service->ipinfo.ipv6.address));
 
 				if (!g_strcmp0(ikey, "Gateway"))
-				{
-					GVariant *gatewayv = g_variant_get_child_value(ipv6, 1);
-					GVariant *gatewayva = g_variant_get_variant(gatewayv);
-
-					g_free(service->ipinfo.ipv6.gateway);
-					service->ipinfo.ipv6.gateway = g_variant_dup_string(gatewayva, NULL);
-
-					g_variant_unref(gatewayv);
-					g_variant_unref(gatewayva);
-				}
+					update_string_val_from_first_element(ipv6,&(service->ipinfo.ipv6.gateway));
 
 				g_variant_unref(ipv6);
 				g_variant_unref(ikey_v);
@@ -881,72 +857,27 @@ gboolean connman_service_get_ipinfo(connman_service_t *service)
 		{
 			GVariant *v = g_variant_get_child_value(property, 1);
 			GVariant *va = g_variant_get_child_value(v, 0);
-			gsize j;
 
-			for (j = 0; j < g_variant_n_children(va); j++)
+			for (gsize j = 0; j < g_variant_n_children(va); j++)
 			{
 				GVariant *ipv4 = g_variant_get_child_value(va, j);
 				GVariant *ikey_v = g_variant_get_child_value(ipv4, 0);
 				const gchar *ikey = g_variant_get_string(ikey_v, NULL);
 
 				if (!g_strcmp0(ikey, "Method"))
-				{
-					GVariant *methodv = g_variant_get_child_value(ipv4, 1);
-					GVariant *methodva = g_variant_get_variant(methodv);
-
-					g_free(service->ipinfo.ipv4.method);
-					service->ipinfo.ipv4.method = g_variant_dup_string(methodva, NULL);
-
-					g_variant_unref(methodv);
-					g_variant_unref(methodva);
-				}
+					update_string_val_from_first_element(ipv4,&(service->ipinfo.ipv4.method));
 
 				if (!g_strcmp0(ikey, "PrefixLength"))
-				{
-					GVariant *prefix_lengthv = g_variant_get_child_value(ipv4, 1);
-					GVariant *prefix_lengthva = g_variant_get_variant(prefix_lengthv);
-					const char *prefix_length = g_variant_get_data(prefix_lengthva);
-					service->ipinfo.ipv4.prefix_len = *prefix_length;
-
-					g_variant_unref(prefix_lengthv);
-					g_variant_unref(prefix_lengthva);
-				}
+					service->ipinfo.ipv4.prefix_len = get_int_val_from_first_element(ipv4);
 
 				if (!g_strcmp0(ikey, "Netmask"))
-				{
-					GVariant *netmaskv = g_variant_get_child_value(ipv4, 1);
-					GVariant *netmaskva = g_variant_get_variant(netmaskv);
-
-					g_free(service->ipinfo.ipv4.netmask);
-					service->ipinfo.ipv4.netmask = g_variant_dup_string(netmaskva, NULL);
-
-					g_variant_unref(netmaskv);
-					g_variant_unref(netmaskva);
-				}
+					update_string_val_from_first_element(ipv4,&(service->ipinfo.ipv4.netmask));
 
 				if (!g_strcmp0(ikey, "Address"))
-				{
-					GVariant *addressv = g_variant_get_child_value(ipv4, 1);
-					GVariant *addressva = g_variant_get_variant(addressv);
-
-					g_free(service->ipinfo.ipv4.address);
-					service->ipinfo.ipv4.address = g_variant_dup_string(addressva, NULL);
-
-					g_variant_unref(addressv);
-					g_variant_unref(addressva);
-				}
+					update_string_val_from_first_element(ipv4,&(service->ipinfo.ipv4.address));
 
 				if (!g_strcmp0(ikey, "Gateway"))
-				{
-					GVariant *gatewayv = g_variant_get_child_value(ipv4, 1);
-					GVariant *gatewayva = g_variant_get_variant(gatewayv);
-
-					g_free(service->ipinfo.ipv4.gateway);
-					service->ipinfo.ipv4.gateway = g_variant_dup_string(gatewayva, NULL);
-
-					g_variant_unref(gatewayv);
-					g_variant_unref(gatewayva);
-				}
+					update_string_val_from_first_element(ipv4,&(service->ipinfo.ipv4.gateway));
 
 				g_variant_unref(ipv4);
 				g_variant_unref(ikey_v);
@@ -1023,28 +954,10 @@ gboolean connman_service_get_proxyinfo(connman_service_t *service)
 				const gchar *pkey = g_variant_get_string(pkey_v, NULL);
 
 				if (!g_strcmp0(pkey, "Method"))
-				{
-					GVariant *methodv = g_variant_get_child_value(proxy, 1);
-					GVariant *methodva = g_variant_get_variant(methodv);
-
-					g_free(service->proxyinfo.method);
-					service->proxyinfo.method = g_variant_dup_string(methodva, NULL);
-
-					g_variant_unref(methodv);
-					g_variant_unref(methodva);
-				}
+					update_string_val_from_first_element(proxy,&(service->proxyinfo.method));
 
 				if (!g_strcmp0(pkey, "URL"))
-				{
-					GVariant *urlv = g_variant_get_child_value(proxy, 1);
-					GVariant *urlva = g_variant_get_variant(urlv);
-
-					g_free(service->proxyinfo.url);
-					service->proxyinfo.url = g_variant_dup_string(urlva, NULL);
-
-					g_variant_unref(urlv);
-					g_variant_unref(urlva);
-				}
+					update_string_val_from_first_element(proxy,&(service->proxyinfo.url));
 
 				if (!g_strcmp0(pkey, "Servers"))
 				{
@@ -1089,7 +1002,6 @@ gboolean connman_service_get_proxyinfo(connman_service_t *service)
 
 static void connman_service_set_ip_rule(connman_service_t *service , bool status)
 {
-	WCALOG_DEBUG("connman_service_set_ip_rule");
 	if ((NULL != service->ipinfo.ipv4.address)&&
 		(NULL != service->ipinfo.ipv4.netmask)&&
 		(NULL != service->ipinfo.ipv4.gateway)&&
@@ -1105,7 +1017,6 @@ static void connman_service_set_ip_rule(connman_service_t *service , bool status
 		if(assigned > 0)
 		{
 			table_Id = table_Id+10;
-			WCALOG_DEBUG("connman_service_set_ip_rule Ready state address available %s ID %d", service->interface_name , table_Id);
 			sprintf(addtable,"ip route %s table %d default via %s", (status) ? "add" : "delete", table_Id , service->ipinfo.ipv4.gateway);
 			system(addtable);
 			char addDestrule[80] = {0,};
@@ -1121,7 +1032,6 @@ static void connman_service_set_ip_rule(connman_service_t *service , bool status
 
 static void connman_service_create_ip_rule(connman_service_t *service)
 {
-	WCALOG_DEBUG("connman_service_create_ip_rule ");
 	if (!service->iprule_added &&
 		(!g_strcmp0(service->state, "ready")))
 		connman_service_set_ip_rule(service,true);
@@ -1129,7 +1039,6 @@ static void connman_service_create_ip_rule(connman_service_t *service)
 
 static void connman_service_delete_ip_rule(connman_service_t *service)
 {
-	WCALOG_DEBUG("connman_service_delete_ip_rule ");
 	if ( service->iprule_added)
 		connman_service_set_ip_rule(service,false);
 }
@@ -1599,6 +1508,22 @@ void connman_service_update_display_name(connman_service_t *service)
 	WCALOG_INFO("SSID_CONVERSION", 0, "Convert result: service->ssid: %s --> service->display_name: %s", service->ssid, service->display_name);
 }
 
+void connman_service_update_type(connman_service_t *service, const gchar *v)
+{
+	if (!g_strcmp0(v, "wifi"))
+	{
+		service->type = CONNMAN_SERVICE_TYPE_WIFI;
+	}
+	else if (!g_strcmp0(v, "ethernet"))
+	{
+		service->type = CONNMAN_SERVICE_TYPE_ETHERNET;
+	}
+	else if (!g_strcmp0(v, "Peer") || (!g_strcmp0(v, "peer")))
+	{
+		service->type = CONNMAN_SERVICE_TYPE_P2P;
+	}
+}
+
 static void p2p_parse_wfd_dev_info(unsigned char *wfd_subelems, int len,
 					struct peer* peer)
 {
@@ -1676,19 +1601,7 @@ void connman_service_update_properties(connman_service_t *service,
 		else if (!g_strcmp0(key, "Type"))
 		{
 			const gchar *v = g_variant_get_string(val, NULL);
-
-			if (!g_strcmp0(v, "wifi"))
-			{
-				service->type = CONNMAN_SERVICE_TYPE_WIFI;
-			}
-			else if (!g_strcmp0(v, "ethernet"))
-			{
-				service->type = CONNMAN_SERVICE_TYPE_ETHERNET;
-			}
-			else if (!g_strcmp0(v, "Peer") || (!g_strcmp0(v, "peer")))
-			{
-				service->type = CONNMAN_SERVICE_TYPE_P2P;
-			}
+			connman_service_update_type(service,v);
 		}
 		else if (!g_strcmp0(key, "State"))
 		{
@@ -1858,24 +1771,14 @@ void connman_service_update_properties(connman_service_t *service,
 
 				if (!g_strcmp0(ekey, "Interface"))
 				{
-					GVariant *ifacev = g_variant_get_child_value(ethernet, 1);
-					GVariant *ifaceva = g_variant_get_variant(ifacev);
-					g_free(service->interface_name);
-					service->interface_name = g_variant_dup_string(ifaceva, NULL);
+					update_string_val_from_first_element(ethernet,&(service->interface_name));
 #ifdef MULTIPLE_ROUTING_TABLE
 					connman_service_create_ip_rule(service);
 #endif
-					g_variant_unref(ifacev);
-					g_variant_unref(ifaceva);
 				}
 				else if (!g_strcmp0(ekey, "Address"))
 				{
-					GVariant *macv = g_variant_get_child_value(ethernet, 1);
-					GVariant *macva = g_variant_get_variant(macv);
-					g_free(service->mac_address);
-					service->mac_address = g_variant_dup_string(macva, NULL);
-					g_variant_unref(macv);
-					g_variant_unref(macva);
+					update_string_val_from_first_element(ethernet,&(service->mac_address));
 				}
 				g_variant_unref(ethernet);
 				g_variant_unref(ekey_v);
diff --git a/src/connman_service.h b/src/connman_service.h
index c76ff33..35c62b8 100644
--- a/src/connman_service.h
+++ b/src/connman_service.h
@@ -440,7 +440,7 @@ extern void connman_service_set_changed(connman_service_t *service,
 extern gboolean connman_service_is_changed(connman_service_t *service,
         unsigned int category);
 extern void connman_service_update_display_name(connman_service_t *service);
-
+extern void connman_service_update_type(connman_service_t *service, const gchar *v);
 
 extern gboolean connman_service_set_run_online_check(connman_service_t *service,
         gboolean value);
diff --git a/src/wifi_service.c b/src/wifi_service.c
index ee7ab2b..b03eded 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1952,9 +1952,6 @@ static gboolean signal_polling_cb(gpointer user_data)
 
 static void start_signal_polling()
 {
-	connman_technology_t *wifi_technology = connman_manager_find_wifi_technology(
-	        manager);
-
 	if (0 == signal_polling_timeout_source)
 	{
 		signal_polling_timeout_source = g_timeout_add_seconds(3, signal_polling_cb,
@@ -3730,9 +3727,6 @@ static bool handle_set_country_code_command(LSHandle *sh,
 	jvalue_ref countryCodeObj = NULL;
 	char *countryCode = NULL;
 
-	connman_technology_t *technology = connman_manager_find_wifi_technology(
-	                                       manager);
-
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("countryCode"), &countryCodeObj))
 	{
 		raw_buffer countryCode_buf = jstring_get(countryCodeObj);

commit ee14455ba52d65aaa85e32234d92201c896c2de8
Merge: 62a6b9f e344290
Author: Rakes Pani <rakes.pani@lge.com>
Date:   Fri Feb 12 18:02:34 2021 +0530

    Merge branch 'develop'
    
    Change-Id: If9ca18a628152ce461d1a1566bde7242c51ffbfc

commit 694189ee9bcafb4cf549a380d3616e0e520525fe
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Fri Feb 12 20:13:32 2021 +0530

    Fixing crash when calling scan with frequency
    
    :Release Notes:
    Fixing crash issue when calling scan with frequency
    
    :Detailed Notes:
    When calling scan API with frequency its getting crash.
    g_strfreev(frequency); will free array of string but frequency
    stored with integer type. because of this crash is happned.
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-135488] [webOS OSE]: "Message status unknown." errorText is
                  displayed.
    
    Change-Id: I55316148752c6dc136cd63667e86dcf72d1e556b

diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index 4f682ca..f0436c8 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -423,7 +423,7 @@ void wifi_scan_start(connman_technology_t* _wifi_tech)
 	}
 }
 
-gboolean wifi_scan_now_with_option(const GStrv *ssid, const GStrv *freq)
+gboolean wifi_scan_now_with_option(const GStrv *ssid, const int *freq, const int freq_num)
 {
 	if (!wifi_tech)
 	{
@@ -432,7 +432,6 @@ gboolean wifi_scan_now_with_option(const GStrv *ssid, const GStrv *freq)
 
 	gsize i;
 	gsize ssid_num = g_strv_length(ssid);
-	gsize freq_num = g_strv_length(freq);
 
 	gchar *ssidstr = g_strnfill(32 * (ssid_num + 1), 0);
 	gchar *freqstr = g_strnfill(5 * (ssid_num + 1), 0);
diff --git a/src/wifi_scan.h b/src/wifi_scan.h
index d553b8a..c0f7781 100644
--- a/src/wifi_scan.h
+++ b/src/wifi_scan.h
@@ -82,5 +82,5 @@ extern void wifi_scan_stop(void);
  * Starts a fresh scan with options, or does nothing if scan already running.
  * Returns success/error.
  */
-extern gboolean wifi_scan_now_with_option(const GStrv *ssid, const GStrv *freq);
+extern gboolean wifi_scan_now_with_option(const GStrv *ssid, const int *freq, const int freq_num);
 
diff --git a/src/wifi_service.c b/src/wifi_service.c
index b03eded..031106d 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -70,6 +70,7 @@ errorText | Yes | String | Error description
 #define MAX_PREFIX_LENGTH   128
 
 #define MAX_COUNTRY_CODE_LENGTH 2
+#define MAX_FREQUENCY_CHANNELS 10
 
 static LSHandle *pLsHandle;
 
@@ -2645,7 +2646,8 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 	}
 
 	GStrv ssid = NULL;
-	GStrv frequency = NULL;
+	int frequency[MAX_FREQUENCY_CHANNELS] = {0};
+	int freq_cnt = 0;
 	jvalue_ref ssidObj = {0};
 	jvalue_ref frequencyObj = {0};
 	bool is_scan_option = false;
@@ -2669,16 +2671,15 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("frequency"), &frequencyObj))
 	{
 		int i, frequency_arrsize = jarray_size(frequencyObj);
-		frequency = (GStrv) g_new0(GStrv, frequency_arrsize + 1);
 
-		for (i = 0; i < frequency_arrsize; i++)
+		for (i = 0; i < frequency_arrsize && i < MAX_FREQUENCY_CHANNELS; i++)
 		{
 			int freq = 0;
 			jnumber_get_i32(jarray_get(frequencyObj, i), &freq);
 			frequency[i] = freq;
+			freq_cnt++;
 		}
 
-		frequency[frequency_arrsize] = NULL;
 		is_scan_option = true;
 	}
 
@@ -2697,7 +2698,7 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 
 	if (is_scan_option)
 	{
-		if (!wifi_scan_now_with_option(ssid, frequency))
+		if (!wifi_scan_now_with_option(ssid, &frequency, freq_cnt))
 		{
 			LSMessageReplyCustomError(sh, message, "Error in scanning network",
 												  WCA_API_ERROR_SCANNING);
@@ -2719,7 +2720,6 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 Exit:
 	j_release(&parsedObj);
 	g_strfreev(ssid);
-	g_strfreev(frequency);
 	return true;
 }
 

commit 9654fcbd9d138a5530926dbd96b3d105ab1e9a66
Merge: ee14455 694189e
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Fri Feb 12 20:49:37 2021 +0530

    Merge remote-tracking branch 'remotes/origin/develop'
    
    Change-Id: I181e16cf25c6002bed4da8f59381d09bda12bf93

commit c76226035898258d39631aed09f38cae4e34b54a
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Mon Feb 22 17:58:18 2021 +0530

    Fix coverity issues
    
    :Release Notes:
    Fix coverity issues for webos-connman-adapter
    
    :Detailed Notes:
    Fixing Logically dead code.
    Fixing Unchecked return value from library.
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-136186] Fix coverity issues of webos-connman-adapter in OSE
    [CID-14932] Logically dead code
    [CID-12264] Unchecked return value from library
    [CID-12791] Unchecked return value from library
    
    Change-Id: Icfa6e9f020959c59271ce4b7034430fff3845bc7

diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 9dd9d0a..7eae04a 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -1159,7 +1159,7 @@ void sync_network_configs_with_profiles(void)
 	while (iter != NULL)
 	{
 		rename_files_t *fileptrs = (rename_files_t *)(iter->data);
-		g_rename(fileptrs->oldpath, fileptrs->newpath);
+		(void)g_rename(fileptrs->oldpath, fileptrs->newpath);
 		g_free(fileptrs->oldpath);
 		g_free(fileptrs->newpath);
 		iter = iter->next;
@@ -1251,7 +1251,7 @@ static gboolean inotify_data(GIOChannel *channel, GIOCondition cond,
 			{
 				if (g_strcmp0(abs_filename, config_pathname) != 0)
 				{
-					g_rename(abs_filename, config_pathname);
+					(void)g_rename(abs_filename, config_pathname);
 				}
 				g_free(config_pathname);
 			}
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index f14a616..19345ed 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -648,7 +648,7 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 			                          WCA_API_ERROR_TETHERING_PASSPHRASE_INVALID);
 			goto cleanup;
 		}
-
+/*
 		if (is_open && passphrase != NULL && strlen(passphrase) > 0)
 		{
 			LSMessageReplyCustomError(sh, message,
@@ -656,7 +656,7 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 			                          WCA_API_ERROR_TETHERING_PASSPHRASE_WITH_OPEN_FAILED);
 			goto cleanup;
 		}
-
+*/
 		invalidArg = FALSE;
 
 		if (!is_open &&

commit 65796c91e6cf649b0bf796d82b5069bd2b8e3353
Merge: 9654fcb c762260
Author: Sameer Mulla <sameer.mulla@lge.com>
Date:   Tue Mar 9 16:19:34 2021 +0530

    Merge remote-tracking branch 'origin/develop'
    
    Change-Id: I1288691923229b8e1b43482a24e1404ec8d86323

commit fd80870b142f19b0813bcdde91f70204bec30b90
Author: Vibhanshu Dhote <vibhanshu.dhote@lge.com>
Date:   Wed May 12 14:17:58 2021 +0530

    Add schema validation for getprofilelist
    
    :Release Notes:
    Add schema realted to wfi service api's
    
    :Detailed Notes:
    Add schama validation for getprofilelist API
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-140311] Add schema validations for wifi service api's
    
    Change-Id: I12eaada98b2a9e338d80985e93fef0d0273c07ee

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 031106d..9cdfdac 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -3118,6 +3118,21 @@ Not applicable.
 static bool handle_get_profilelist_command(LSHandle *sh, LSMessage *message,
         void *context)
 {
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(dummy,
+	                                     integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dummy"), &profileIdObj))
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		goto cleanup;
+	}
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;

commit 8a1d7f1fb9e4da4dfd4826fcf1da7e86f676e7c4
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Thu May 20 18:44:03 2021 +0530

    Add schema validation for wifi service api's
    
    :Release Notes:
    Add schema realted to wfi service api's
    
    :Detailed Notes:
    Add schama validation for below wifi service API's
    cancel
    cancelwps
    createwpspin
    getCountryCode
    
    :Testing Performed:
    Build successfully.
    Ethrenet/wifi connection successfully.
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [PLAT-140311] Add schema validations for wifi service api's
    
    Change-Id: Idaebf6bd7fa2bde3b7affbdc98eb3590eb9f1633

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 9cdfdac..3c3a8a2 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2439,6 +2439,23 @@ returnValue | yes | Boolean | True
 static bool handle_cancel_command(LSHandle *handle, LSMessage *message,
                                   void *user_data)
 {
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(handle, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(dummy,
+	                                     integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dummy"), &profileIdObj))
+	{
+		LSMessageReplyErrorInvalidParams(handle, message);
+		return true;
+	}
+
 	connman_service_t *connecting_service;
 
 	if (!connman_status_check(manager, handle, message))
@@ -3469,6 +3486,22 @@ Not applicable.
 static bool handle_create_wpspin_command(LSHandle *sh, LSMessage *message,
         void *context)
 {
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(dummy,
+	                                     integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dummy"), &profileIdObj))
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		return true;
+	}
+
 	jvalue_ref reply = jobject_create();
 	LSError lserror;
 	LSErrorInit(&lserror);
@@ -3633,6 +3666,23 @@ Not applicable.
 static bool handle_cancel_wps_command(LSHandle *sh, LSMessage *message,
                                       void *context)
 {
+
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(dummy,
+	                                     integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dummy"), &profileIdObj))
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		return true;
+	}
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;
@@ -3843,6 +3893,22 @@ Not applicable.
 static bool handle_get_country_code_command(LSHandle *sh,
         LSMessage *message, void *context)
 {
+	// To prevent memory leaks, schema should be checked before the variables will be initialized.
+	jvalue_ref parsedObj = {0};
+	if (!LSMessageValidateSchema(sh, message,
+	                             j_cstr_to_buffer(STRICT_SCHEMA(PROPS_1(PROP(dummy,
+	                                     integer)))), &parsedObj))
+	{
+		return true;
+	}
+
+	jvalue_ref profileIdObj = {0};
+	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dummy"), &profileIdObj))
+	{
+		LSMessageReplyErrorInvalidParams(sh, message);
+		return true;
+	}
+
 	if (!connman_status_check(manager, sh, message))
 	{
 		return true;

commit 674ae13bf8c127aa09768acdbeb509121b8b1f92
Merge: 65796c9 8a1d7f1
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Fri May 21 17:50:48 2021 +0530

    Merge remote-tracking branch 'remotes/origin/develop'
    
    Change-Id: I96081aeaa70b96ed05ed106a5483585889fbfda9

commit d586bafddbaa9324269086c88be97a01f056c0e7
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Thu May 27 10:57:57 2021 +0530

    Address Coverity static analysis issues
    
    :Release Notes:
    Fix Coverity static analysis issues
    
    :Detailed Notes:
    Address 'Branch past initialization' issues
    
    :Testing Performed:
    Build is successfully done.
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [PLAT-140312] Address Coverity issues for OSE webos-connman-adapter
    [CID-39139] Branch past initialization
    
    Change-Id: Iedb1d5479d6d2c32fb5c1d845401f41528820bc5

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 3c3a8a2..dbbb36a 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -3147,7 +3147,7 @@ static bool handle_get_profilelist_command(LSHandle *sh, LSMessage *message,
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("dummy"), &profileIdObj))
 	{
 		LSMessageReplyErrorInvalidParams(sh, message);
-		goto cleanup;
+		return true;
 	}
 
 	if (!connman_status_check(manager, sh, message))

commit 420b208f1cababfea4e7a00aebb479f8177be003
Merge: 674ae13 d586baf
Author: penikelapati.kumar <penikelapati.kumar@lge.com>
Date:   Thu May 27 11:29:58 2021 +0530

    Merge remote-tracking branch 'remotes/origin/develop'
    
    Change-Id: Ifc13f9088e36b313d7a9ba892c7b1091f0954d08

commit 48a355be374649b8f45fdb1361ca9dcc1f4eb404
Author: paramesh.kuberappa <paramesh.kuberappa@lge.com>
Date:   Tue Jul 27 14:48:48 2021 +0530

    Add LICENSE file
    
    :Release Notes:
    Add LICENSE with the same content of Apache-2.0 license.
    
    :Detailed Notes:
    Added the LICENSE file
    
    :Testing Performed:
    Build and tested
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [WRN-3751] Fix License and update md5sum for all connectivity
               components
    
    Change-Id: I881562e580883198c9900b345c98731be3173691

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..e0529f4
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks of the Licensor, except as required
+      for reasonable and customary use in describing the origin of the Work
+      and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.

commit ab6d330eb041b121595278d6c5b923ab24b2cd49
Merge: 420b208 48a355b
Author: paramesh.kuberappa <paramesh.kuberappa@lge.com>
Date:   Tue Jul 27 18:27:06 2021 +0530

    Merge remote-tracking branch 'origin/develop'lready up to date.
    
    Change-Id: I8240fec5e222b0be182b3543e7856233f790a9dc

commit 41dbf5471741078dca516de15b19675ab6890da0
Author: avanti.kumbhar <avanti.kumbhar@lge.com>
Date:   Tue Dec 6 14:21:19 2022 +0530

    Fix static analysis
    
    :Release Notes:
    Fix static analysis
    
    :Detailed Notes:
    This commit fixes static analysis detected by coverity.
    
    Detected types are as follows:
    - Dereference null return value
    
    :Testing Performed:
    Build is successfully done.
    
    :QA Notes:
    
    :Issues Addressed:
    [WRP-4095] 9015219 Dereference null return value (webos-connman-adapter)
    [wrp-4094] 9166170 Dereference null return value (webos-connman-adapter)
    
    Change-Id: Iedf6ae61f0dad44db8d360f5d675e3df93a4efac

diff --git a/src/connman_manager.c b/src/connman_manager.c
index b76a53c..83c214b 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -535,8 +535,11 @@ static connman_service_t* update_or_add_service(connman_manager_t *manager,
 		gboolean peer_service = FALSE;
 		if (saved || service_on_configured_iface(service_v, &peer_service) == TRUE)
 		{
-			service = connman_service_new(service_v, peer_service);
-			add_service_to_list(manager, service, saved);
+			if(service_v != NULL)
+			{
+				service = connman_service_new(service_v, peer_service);
+				add_service_to_list(manager, service, saved);
+			}
 		}
 	}
 

commit 97b60bd5624ea9f671040009bafbe9e2b7785698
Author: piyush10.asalmol <piyush10.asalmol@lge.com>
Date:   Tue Jan 17 11:10:23 2023 +0530

    Fix for DNS Server value disappeared
    
    :Release Notes:
    Fix for DNS Server value is disappeared when
    clicked on Connect Button
    
    :Detailed Notes:
    DNS address was missing even though connman has
    the address internally.Nameservers property
    changed call back is added so that the address is
    changed when connman gets it.
    
    :Testing Performed:
    Tested Locally.
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [WRP-5183] [OSE -RPI4]: Newly entered DNS Server
    value is disappeared when clicked on Connect
    button
    
    Change-Id: Ifea1b48e32704ef69b4bf876083268edc67cd4bb

diff --git a/src/connman_service.c b/src/connman_service.c
index 2cd2017..febcc3a 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1370,6 +1370,12 @@ property_changed_cb(ConnmanInterfaceService *proxy, gchar *property,
 		}
 	}
 
+	else if (!g_strcmp0(property, "Nameservers"))
+        {
+                connman_service_set_changed(service, CONNMAN_SERVICE_CHANGE_CATEGORY_GETSTATUS);
+                connectionmanager_send_status_to_subscribers();
+        }
+
 	g_variant_unref(va);
 }
 

commit 861b0ac71c69e3dc717bad5c9bfda4620ab852ce
Author: avanti.kumbhar <avanti.kumbhar@lge.com>
Date:   Tue Mar 7 20:44:16 2023 +0530

    Fix for [OSE-RPi4] : 'Wi-Fi Network is disconnected'
    popup is displayed when connecting to a WiFi Network
    
    :Release Notes:
    Fix for [OSE-RPi4] : 'Wi-Fi Network is disconnected'
    popup is displayed when connecting to a WiFi Network
    
    :Detailed Notes:
    When connect command is executed to connect to a
    wifi network that is already connected, the
    WiFi is disconnected and disconect pop getting on the
    UI So that we removed remove_connected_service method
    so it will not disconnect from network.
    
    :Testing Performed:
    Tested Locally.
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [WRP-9151] [OSE-RPi4] : 'Wi-Fi Network is disconnected'
    popup is displayed when connecting to a WiFi Network
    
    Change-Id: Ic6c955825164175ef3db692bfa976046a9a471a2

diff --git a/src/wifi_service.c b/src/wifi_service.c
index dbbb36a..9287c97 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2403,9 +2403,6 @@ static bool handle_connect_command(LSHandle *sh, LSMessage *message,
 	}
 
 	service_req = luna_service_request_new(sh, message);
-
-	remove_connected_service();
-
 	connect_wifi_with_ssid(ssid, profile, parsedObj, service_req);
 
 	g_free(ssid);

commit a469601664bde63d49910cf721388990bc6e42d7
Author: piyush10.asalmol <piyush10.asalmol@lge.com>
Date:   Wed Nov 9 19:47:16 2022 +0530

    Workaround to prevent luna call pending
    
    :Release Notes:
    
    :Detailed Notes:
    
    :Testing Performed:
    Only build tested.
    
    :QA Notes:
    No change to image.
    
    :Issues Addressed:
    [WRP-310] Apply .patch files for hot-fix to corresponding repositories
    [WRP-11630] Add Upstream-Status to existing .patch files in meta-lg-webos
    [WRP-11864] CCC: Various build fixes and .patch files cleanup
    
    Change-Id: I3e32d725d8cd3c6e559d895399a537aeb621f346

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 9287c97..93521af 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1932,7 +1932,7 @@ static gboolean signal_polling_cb(gpointer user_data)
 	        manager);
 	connman_technology_interface_t interface_properties;
 
-	if (connman_technology_get_interface_properties(wifi_technology,
+	/*if (connman_technology_get_interface_properties(wifi_technology,
 	        CONNMAN_WIFI_INTERFACE_NAME, &interface_properties) == TRUE)
 	{
 
@@ -1946,7 +1946,7 @@ static gboolean signal_polling_cb(gpointer user_data)
 			send_findnetworks_status_to_subscribers();
 			send_getnetworks_status_to_subscribers();
 		}
-	}
+	}*/
 
 	return TRUE;
 }

commit d67ee85900b82800825ccbd0f403e701e66d006e
Author: puneeth.krishna <puneeth.krishna@lge.com>
Date:   Thu Aug 8 10:18:47 2024 +0000

    Fix Coverity Issue in webos-connman-adapter
    
    :Release Notes:
    Fix Coverity Issue in webos-connman-adapter
    
    :Detailed Notes:
    Fix the Coverity issue for webos-connman-adapter
    to handle the error check  pthread_mutex_lock()
    If pthread_mutex_lock() fails to lock the mutex
    for some reason(e.g., if the mutex is already
    locked by another thread or if there's an invalid
    mutex handle), it returns an error code.
    
    :Testing Performed:
    Build Successful
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [WRQ-7897] Fix Coverity Issue in webos-connman-adapter
    [CID-9015187]  CERT-C POSIX (CERT POS54-C)
    [CID-9015108]  CERT-C POSIX (CERT POS54-C)
    [CID-9015076]  CERT-C POSIX (CERT POS54-C)
    [CID-9015170]  CERT-C POSIX (CERT POS54-C)
    [CID-9015218]  CERT-C POSIX (CERT POS54-C)
    [CID-9014895]  CERT-C Error Handling (CERT ERR33-C)
    [CID-9014898]  CERT-C Error Handling (CERT ERR33-C)
    [CID-9015211]  CERT-C Error Handling (CERT ERR33-C)
    [CID-9015211]  CERT-C Error Handling (CERT ERR33-C)
    [CID-9014899]  CERT-C Error Handling (CERT ERR33-C)
    [CID-9015112]  CERT-C Error Handling (CERT ERR33-C)
    
    Change-Id: Ic81782709e8ed595bce5402b1c74ddeff54390b0

diff --git a/src/wifi_p2p_service.c b/src/wifi_p2p_service.c
index 2697734..0738b4f 100644
--- a/src/wifi_p2p_service.c
+++ b/src/wifi_p2p_service.c
@@ -1,6 +1,6 @@
 /* @@@LICENSE
 *
-* Copyright (c) 2021 LG Electronics, Inc.
+* Copyright (c) 2024 LG Electronics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -782,7 +782,10 @@ void manager_groups_changed_callback(gpointer data, gboolean group_added)
 {
 	if (group_added)
 	{
-		pthread_mutex_lock(&callback_sequence_lock);
+                if (pthread_mutex_lock(&callback_sequence_lock)!=0)
+                {
+                        return;
+                }
 
 		if (!group_added_by_p2p_request && !group_added_pending)
 		{
@@ -898,7 +901,11 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 	gboolean enable_p2p = TRUE, enable_p2p_listen = FALSE,
 	         enable_persistent_mode = FALSE, error = FALSE;
 
-	pthread_mutex_lock(&callback_sequence_lock);
+        int lock_result = pthread_mutex_lock(&callback_sequence_lock);
+        if (lock_result != 0)
+        {
+           goto cleanup;
+        }
 	group_added_by_p2p_request = FALSE;
 	group_added_pending = FALSE;
 	pthread_mutex_unlock(&callback_sequence_lock);
@@ -1495,7 +1502,12 @@ static bool handle_connect_command(LSHandle *sh, LSMessage *message,
 				settings->wpspin = strdup("");
 			}
 		}
-		pthread_mutex_lock(&callback_sequence_lock);
+                int lock_result = pthread_mutex_lock(&callback_sequence_lock);
+                if(lock_result!=0)
+                {
+                    goto cleanup;
+                }
+
 		group_added_by_p2p_request = TRUE;
 		pthread_mutex_unlock(&callback_sequence_lock);
 		WCALOG_DEBUG("Setup for connecting with secured network");
@@ -2522,7 +2534,7 @@ static bool handle_get_device_name_command(LSHandle *sh, LSMessage *message,
 	connman_technology_t *technology = connman_manager_find_p2p_technology(
 	                                       manager);
 
-	if (technology->p2p_identifier)
+        if ((NULL != technology) && (technology->p2p_identifier))
 	{
 		jobject_put(reply, J_CSTR_TO_JVAL("returnValue"), jboolean_create(true));
 		jobject_put(reply, J_CSTR_TO_JVAL("deviceName"),
@@ -3521,7 +3533,7 @@ static bool handle_cancel_command(LSHandle *sh, LSMessage *message,
 		return true;
 	}
 
-	pthread_mutex_lock(&callback_sequence_lock);
+        (void)pthread_mutex_lock(&callback_sequence_lock);
 	group_added_by_p2p_request = FALSE;
 	group_added_pending = FALSE;
 	pthread_mutex_unlock(&callback_sequence_lock);
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 93521af..7951d3f 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2021 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -3431,7 +3431,10 @@ gint generate_new_wpspin(void)
 	pin %= 10000000;
 	pin *= 10;
 
-	fclose(f);
+        if(fclose(f)!=0)
+        {
+          WCALOG_DEBUG("Failed_fileClose");
+        }
 
 	// Append checksum digit in the end
 
diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 7eae04a..9fbe51f 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2020 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -515,9 +515,15 @@ static gboolean store_config(GKeyFile *keyfile, char *pathname)
 			return FALSE;
 		}
 
-		fprintf(fp, "%s", data);
-		fclose(fp);
-	}
+                if(fprintf(fp, "%s", data)<0)
+                {
+                        WCALOG_DEBUG("Failed_fprintf");
+                }
+                if(fclose(fp)!=0)
+                {
+                        WCALOG_DEBUG("Failed_fileClose");
+                }
+        }
 
 	g_free(data);
 

commit ee2304d0ab170593ce8ea6387a8031ac95bdc89b
Author: sharad12.kumar <sharad12.kumar@lge.com>
Date:   Mon Sep 23 18:17:14 2024 +0900

    Fix high static issue for webos-connman-adapter
    
    :Release Notes:
    Fix high static issue for webos-connman-adapter
    
    :Detailed Notes:
    Fix high static issue for webos-connman-adapter
    
    :Testing Performed:
    Build successfully
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [WRR-4268] - Fix High OSE static issue
    
    Change-Id: I41f23578cd6f32d51724c23ce5652209af944a52

diff --git a/src/connman_service.c b/src/connman_service.c
index febcc3a..986418e 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2021 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -1945,6 +1945,7 @@ connman_service_t *connman_service_new(GVariant *variant, gboolean p2p)
 	{
 		WCALOG_ESCAPED_ERRMSG(MSGID_SERVICE_INIT_ERROR, error->message);
 		g_error_free(error);
+		g_free(service->identifier);
 		g_free(service->path);
 		g_free(service);
 		return NULL;

commit 806ef5f01452b5f42a38ae420eea5c7cbd27fc19
Author: dileep.ragipindi <dileep.ragipindi@lge.com>
Date:   Mon Sep 30 08:45:59 2024 +0000

    Fix static issues for webos-connman-adapter
    
    :Release Notes:
    Fix static issues for webos-connman-adapter
    
    :Detailed Notes:
    Fix static issues for webos-connman-adapter
    
    :Testing Performed:
    Build successfully
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [WRR-5299]- To fix static issues
    
    Change-Id: Iaf805994db3a0542b6b4d34cb66a10feed3160c8

diff --git a/src/wifi_service.c b/src/wifi_service.c
index 7951d3f..55d6b23 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2668,7 +2668,7 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("ssid"), &ssidObj))
 	{
-		int i, ssid_arrsize = jarray_size(ssidObj);
+		long int i, ssid_arrsize = jarray_size(ssidObj);
 		ssid = (GStrv) g_new0(GStrv, ssid_arrsize + 1);
 
 		for (i = 0; i < ssid_arrsize; i++)
@@ -2684,7 +2684,7 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("frequency"), &frequencyObj))
 	{
-		int i, frequency_arrsize = jarray_size(frequencyObj);
+		long int i, frequency_arrsize = jarray_size(frequencyObj);
 
 		for (i = 0; i < frequency_arrsize && i < MAX_FREQUENCY_CHANNELS; i++)
 		{

commit dc12bfaad23266b63f1b844b2045fda30377c23d
Author: sanjay.b <sanjay.b@lge.com>
Date:   Wed Oct 23 12:02:48 2024 +0000

    Fix CFLAGS for webos-connman-adapter
    
    :Release Notes:
    Fix CFLAGS for webos-connman-adapter
    
    :Detailed Notes:
    Addressed CFLAGS += "-Wno-error=incompatible-pointer-types
    -Wno-error=int-conversion
    -Wno-error=implicit-function-declaration"
    
    :Testing Performed:
    Build successful
    
    :QA Notes:
    NA
    
    :Issues Addressed:
    [WRR-7998] To resolve webos CFlags for webos-connman -adapter
    
    Change-Id: I38da5cb6ea15503e60258a6b77587619dfe8c04a

diff --git a/src/connectionmanager_service.c b/src/connectionmanager_service.c
index 1183b49..c4c522b 100644
--- a/src/connectionmanager_service.c
+++ b/src/connectionmanager_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2021 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -1318,7 +1318,7 @@ static bool handle_set_ipv6_command(LSHandle *sh, LSMessage *message,
 						                          "Address, prefix length as well as gateway should be specified for out of range networks",
 						                          WCA_API_ERROR_INVALID_PARAMETERS);
 					else if (change_network_ipv6(profile->ssid, profile->security[0], ipv6.address,
-					                             ipv6.prefix_length, ipv6.gateway))
+					                             (const char *)&ipv6.prefix_length, ipv6.gateway))
 					{
 						LSMessageReplySuccess(sh, message);
 					}
@@ -2368,7 +2368,7 @@ static bool handle_monitor_activity_command(LSHandle *sh, LSMessage *message,
 
 	if (NULL == counter)
 	{
-		counter = connman_counter_new(notify_counter_statistics);
+		counter = connman_counter_new((GSourceFunc)notify_counter_statistics);
 
 		if (NULL == counter)
 		{
diff --git a/src/connectionmanager_service.h b/src/connectionmanager_service.h
index 85f206c..b906455 100644
--- a/src/connectionmanager_service.h
+++ b/src/connectionmanager_service.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2019 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -59,5 +59,6 @@ extern void connectionmanager_send_status_to_subscribers(void);
 extern int initialize_connectionmanager_ls2_calls(GMainLoop *mainloop,
         LSHandle **cm_handle);
 extern void send_getinfo_to_subscribers(void);
+extern void send_peer_information_to_subscribers(void);
 
 #endif /* _CONNECTIONMANAGER_SERVICE_H_ */
diff --git a/src/connman_manager.c b/src/connman_manager.c
index 83c214b..bc8c99e 100644
--- a/src/connman_manager.c
+++ b/src/connman_manager.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2021 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -1697,7 +1697,7 @@ connman_service_t *connman_manager_get_connected_service_by_interfaceName(GSList
 		service = (struct connman_service *)(iter->data);
 		if(!g_strcmp0(interface, service->interface_name))
 		{
-			plugged = true;
+			*plugged = true;
 			int service_state = connman_service_get_state(service->state);
 
 			if(service_state == CONNMAN_SERVICE_STATE_ONLINE
@@ -1959,7 +1959,7 @@ services_changed_cb(ConnmanInterfaceManager *proxy, GVariant *services_added,
 
 	if (connman_update_callbacks->services_changed)
 	{
-		connman_update_callbacks->services_changed(services_added, services_removed);
+		connman_update_callbacks->services_changed(services_added, (const gchar **)services_removed);
 	}
 
 	unsigned char service_type = 0;
@@ -1991,7 +1991,7 @@ saved_services_changed_cb(ConnmanInterfaceManager *proxy,
 	if (connman_update_callbacks->saved_services_changed)
 	{
 		connman_update_callbacks->saved_services_changed(saved_services_added,
-		        saved_services_removed);
+		        (const gchar **)saved_services_removed);
 	}
 
 	connman_manager_update_services(manager, saved_services_added, NULL, TRUE);
diff --git a/src/connman_service.c b/src/connman_service.c
index 986418e..fa2965e 100644
--- a/src/connman_service.c
+++ b/src/connman_service.c
@@ -1951,7 +1951,7 @@ connman_service_t *connman_service_new(GVariant *variant, gboolean p2p)
 		return NULL;
 	}
 
-	g_dbus_proxy_set_default_timeout(service->remote, DBUS_CALL_TIMEOUT);
+	g_dbus_proxy_set_default_timeout((GDBusProxy *)service->remote, DBUS_CALL_TIMEOUT);
 	g_dbus_proxy_set_default_timeout((GDBusProxy *)service->remote, DBUS_CALL_TIMEOUT);
 	service->iprule_added = false;
 
diff --git a/src/connman_technology.h b/src/connman_technology.h
index 04be7c4..f16d367 100644
--- a/src/connman_technology.h
+++ b/src/connman_technology.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2021 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -414,5 +414,7 @@ extern connman_technology_t *connman_technology_new(const gchar* path);
 
 extern void connman_technology_free(connman_technology_t *technology);
 
+extern gboolean connman_technology_set_go_intent(connman_technology_t *technology, const guint32 go_intent);
+
 #endif /* CONNMAN_TECHNOLOGY_H_ */
 
diff --git a/src/wifi_p2p_service.c b/src/wifi_p2p_service.c
index 0738b4f..019cc2f 100644
--- a/src/wifi_p2p_service.c
+++ b/src/wifi_p2p_service.c
@@ -48,6 +48,7 @@
 #include "logging.h"
 #include "errors.h"
 #include "wfdsie/wfdinfoelemwrapper.h"
+#include "connman_technology.h"
 
 LSHandle *localpLSHandle = NULL;
 bool subscribed_for_device_name = false;
@@ -839,7 +840,7 @@ void manager_groups_changed_callback(gpointer data, gboolean group_added)
 
 static gboolean set_p2p_persistent_callback(gpointer user_data)
 {
-	gboolean enable_persistent_mode = user_data;
+	gboolean enable_persistent_mode = *(gboolean *)user_data;
 
 	set_p2p_persistent_mode(enable_persistent_mode);
 
@@ -998,7 +999,7 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 				}
 		}
 		else
-			g_timeout_add(500, set_p2p_persistent_callback, enable_persistent_mode);
+			g_timeout_add(500, set_p2p_persistent_callback, &enable_persistent_mode);
 	}
 
 	if (!enable_p2p && !(enable_p2p == is_p2p_enabled()) && !set_p2p_power_state(enable_p2p))
@@ -3271,7 +3272,7 @@ static bool handle_add_service_command(LSHandle *sh, LSMessage *message,
 
 	jvalue_ref reply = jobject_create();
 	jvalue_ref typeObj = NULL, descriptionObj = NULL, queryObj = NULL,
-	           *responseObj = NULL;
+	           responseObj = NULL;
 	gchar *type = NULL, *description = NULL, *query = NULL, *response = NULL;
 	connman_service_type service_type;
 
diff --git a/src/wifi_p2p_service.h b/src/wifi_p2p_service.h
index 27d3c4f..146a889 100644
--- a/src/wifi_p2p_service.h
+++ b/src/wifi_p2p_service.h
@@ -1,6 +1,6 @@
 /* @@@LICENSE
 *
-* Copyright (c) 2021 LG Electronics, Inc.
+* Copyright (c) 2024 LG Electronics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -26,6 +26,7 @@
 #define _WIFI_P2P_SERVICE_H_
 
 #include <luna-service2/lunaservice.h>
+#include "connman_service.h"
 
 #define LUNA_CATEGORY_P2P                 "/p2p"
 
@@ -65,5 +66,6 @@ extern void send_peer_information_to_subscribers(void);
 extern void send_p2p_get_state_to_subscribers(void);
 extern void update_p2p_device_name(void);
 extern gboolean is_connected_peer(void);
+extern void setPropertyUpdateCallback(connman_service_t *service);
 
 #endif /* _WIFI_P2P_SERVICE_H_ */
diff --git a/src/wifi_scan.c b/src/wifi_scan.c
index f0436c8..d924753 100644
--- a/src/wifi_scan.c
+++ b/src/wifi_scan.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2015-2021 LG Electronics, Inc.
+// Copyright (c) 2015-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -24,6 +24,8 @@
 #include "wifi_scan.h"
 #include "logging.h"
 #include "utils.h"
+#include "wifi_p2p_service.h"
+#include "common.h"
 
 #define MIN_SCAN_INTERVAL 1000
 
@@ -423,7 +425,7 @@ void wifi_scan_start(connman_technology_t* _wifi_tech)
 	}
 }
 
-gboolean wifi_scan_now_with_option(const GStrv *ssid, const int *freq, const int freq_num)
+gboolean wifi_scan_now_with_option(const GStrv ssid, const int *freq, const int freq_num)
 {
 	if (!wifi_tech)
 	{
diff --git a/src/wifi_scan.h b/src/wifi_scan.h
index c0f7781..bf52307 100644
--- a/src/wifi_scan.h
+++ b/src/wifi_scan.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2015-2018 LG Electronics, Inc.
+// Copyright (c) 2015-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@
 #include "lunaservice_utils.h"
 #include "connman_manager.h"
 
+
 typedef void (*wifi_scan_callback_t)(gpointer user_data);
 
 /**
@@ -82,5 +83,5 @@ extern void wifi_scan_stop(void);
  * Starts a fresh scan with options, or does nothing if scan already running.
  * Returns success/error.
  */
-extern gboolean wifi_scan_now_with_option(const GStrv *ssid, const int *freq, const int freq_num);
-
+extern gboolean wifi_scan_now_with_option(const GStrv ssid, const int *freq, const int freq_num);
+gboolean wifi_scan_now_p2p(void);
diff --git a/src/wifi_service.c b/src/wifi_service.c
index 55d6b23..0d6172c 100644
--- a/src/wifi_service.c
+++ b/src/wifi_service.c
@@ -2712,7 +2712,7 @@ static bool handle_scan_command(LSHandle *sh, LSMessage *message,
 
 	if (is_scan_option)
 	{
-		if (!wifi_scan_now_with_option(ssid, &frequency, freq_cnt))
+		if (!wifi_scan_now_with_option(ssid, frequency, freq_cnt))
 		{
 			LSMessageReplyCustomError(sh, message, "Error in scanning network",
 												  WCA_API_ERROR_SCANNING);
@@ -2885,7 +2885,7 @@ static bool handle_change_network_command(LSHandle *sh, LSMessage *message,
 			connman_service_t *service = (connman_service_t *)(ap->data);
 
 			if (g_strcmp0(service->name, profile->ssid) ||
-			        check_service_security(service, profile->security))
+			        check_service_security(service, profile->security[0]))
 			{
 				continue;
 			}
@@ -4144,7 +4144,7 @@ int initialize_wifi_ls2_calls(GMainLoop *mainloop , LSHandle **wifi_handle)
 		goto Exit;
 	}
 
-	if (LSSubscriptionSetCancelFunction(pLsHandle, handle_luna_subscription_cancel, NULL, &lserror) == false)
+	if (LSSubscriptionSetCancelFunction(pLsHandle, (LSFilterFunc) handle_luna_subscription_cancel, NULL, &lserror) == false)
 	{
 		WCALOG_ESCAPED_ERRMSG(MSGID_WIFI_SUBSCRIPTIONCANCEL_LUNA_ERROR, lserror.message);
 		goto Exit;
@@ -4153,7 +4153,7 @@ int initialize_wifi_ls2_calls(GMainLoop *mainloop , LSHandle **wifi_handle)
 	g_type_init();
 
 	g_bus_watch_name(G_BUS_TYPE_SYSTEM, "net.connman",
-	                 G_BUS_NAME_WATCHER_FLAGS_NONE, connman_service_started, connman_service_stopped,
+	                 G_BUS_NAME_WATCHER_FLAGS_NONE, connman_service_started, (GBusNameVanishedCallback) connman_service_stopped,
 	                 NULL, NULL);
 
 	retrieve_system_locale_info(pLsHandle);
diff --git a/src/wifi_setting.c b/src/wifi_setting.c
index 9fbe51f..f8f1263 100644
--- a/src/wifi_setting.c
+++ b/src/wifi_setting.c
@@ -867,7 +867,7 @@ gboolean change_network_ipv6(const char *ssid, const char *security,
 }
 
 gboolean change_network_dns(const char *ssid, const char *security,
-                            const GStrv *dns)
+                            const GStrv dns)
 {
 	gchar *pathname = NULL, *config_group = NULL;
 	GKeyFile *keyfile = NULL;
diff --git a/src/wifi_setting.h b/src/wifi_setting.h
index 020b2ad..df5bd7f 100644
--- a/src/wifi_setting.h
+++ b/src/wifi_setting.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -47,7 +47,7 @@ extern gboolean change_network_ipv4(const char *ssid, const char *security,
                                     const char *address, const char *netmask, const char *gateway);
 extern gboolean change_network_ipv6(const char *ssid, const char *security,
                                     const char *address, const char *prefixLen, const char *gateway);
-extern gboolean change_network_dns(const char *ssid, const char *security, const GStrv *dns);
+extern gboolean change_network_dns(const char *ssid, const char *security, const GStrv dns);
 extern gboolean change_network_remove_entry(const char *ssid, const char *security, const char *key);
 extern void remove_config_inotify_watch(void);
 
diff --git a/src/wifi_tethering_service.c b/src/wifi_tethering_service.c
index 19345ed..51810d4 100644
--- a/src/wifi_tethering_service.c
+++ b/src/wifi_tethering_service.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2014-2020 LG Electronics, Inc.
+// Copyright (c) 2014-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -749,7 +749,7 @@ static bool handle_set_state_command(LSHandle *sh, LSMessage *message,
 
 	if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("enabled"), &enabledObj))
 	{
-		jboolean_get(enabledObj, &enable_tethering);
+		jboolean_get(enabledObj, (bool *) &enable_tethering);
 
 		if (enable_tethering && is_wifi_tethering())
 		{

commit 88571f68624384d9cf6713760a57df2574c20f6c
Author: dhanush.rajn <dhanush.rajn@lge.com>
Date:   Sat Nov 23 16:15:19 2024 +0000

    Resolve c-flags issue for webos-qemux
    
    :Release Notes:
    Resolve c-flags issue for webos-qemux
    
    :Detailed Notes:
    Resolved c-flags issue by typecasting to
    va_list*
    
    :Testing Performed:
    Tested locally
    
    :QA Notes:
    N/A
    
    :Issues Addressed:
    [WRR-9888] To resolve cflags for connectivity components
    
    Change-Id: I7425eca9ef0de55eb40f3fa76de61a8aecae4258

diff --git a/src/lunaservice_utils.c b/src/lunaservice_utils.c
index eb44cd5..af11088 100644
--- a/src/lunaservice_utils.c
+++ b/src/lunaservice_utils.c
@@ -1,4 +1,4 @@
-// Copyright (c) 2012-2018 LG Electronics, Inc.
+// Copyright (c) 2012-2024 LG Electronics, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -241,7 +241,7 @@ static bool LSMessageParseToNative_valist(LSMessage *message, jvalue_ref *parsed
 		return false;
 	}
 
-	error = json_convert_to_native_valist(*parsedObj, &args);
+	error = json_convert_to_native_valist(*parsedObj, (va_list *)&args);
 
 	if (error)
 	{
