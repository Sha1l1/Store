commit ba189b000c4c5ab4d15c6b155a7dbf8bd46c42d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 20:47:27 2007 +0100

    Initial revision

diff --git a/AUTHORS b/AUTHORS
new file mode 100644
index 00000000..48482e80
--- /dev/null
+++ b/AUTHORS
@@ -0,0 +1 @@
+Marcel Holtmann <marcel@holtmann.org>
diff --git a/COPYING b/COPYING
new file mode 100644
index 00000000..3912109b
--- /dev/null
+++ b/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/ChangeLog b/ChangeLog
new file mode 100644
index 00000000..e69de29b
diff --git a/INSTALL b/INSTALL
new file mode 100644
index 00000000..56b077d6
--- /dev/null
+++ b/INSTALL
@@ -0,0 +1,236 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005 Free
+Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' will install the package's files in
+`/usr/local/bin', `/usr/local/man', etc.  You can specify an
+installation prefix other than `/usr/local' by giving `configure' the
+option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+give `configure' the option `--exec-prefix=PREFIX', the package will
+use PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files will still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the `--target=TYPE' option to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).  Here is a another example:
+
+     /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+Here the `CONFIG_SHELL=/bin/bash' operand causes subsequent
+configuration-related scripts to be executed by `/bin/bash'.
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+
diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 00000000..4a0cec8e
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,4 @@
+
+MAINTAINERCLEANFILES = Makefile.in \
+	aclocal.m4 configure config.h.in config.sub config.guess \
+	ltmain.sh depcomp missing install-sh mkinstalldirs
diff --git a/NEWS b/NEWS
new file mode 100644
index 00000000..e69de29b
diff --git a/README b/README
new file mode 100644
index 00000000..e69de29b
diff --git a/acinclude.m4 b/acinclude.m4
new file mode 100644
index 00000000..95486c3d
--- /dev/null
+++ b/acinclude.m4
@@ -0,0 +1,11 @@
+AC_DEFUN([AC_PROG_CC_PIE], [
+	AC_CACHE_CHECK([whether ${CC-cc} accepts -fPIE], ac_cv_prog_cc_pie, [
+		echo 'void f(){}' > conftest.c
+		if test -z "`${CC-cc} -fPIE -pie -c conftest.c 2>&1`"; then
+			ac_cv_prog_cc_pie=yes
+		else
+			ac_cv_prog_cc_pie=no
+		fi
+		rm -rf conftest*
+	])
+])
diff --git a/bootstrap b/bootstrap
new file mode 100755
index 00000000..053f5c8f
--- /dev/null
+++ b/bootstrap
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+aclocal && \
+    autoheader && \
+        libtoolize --automake --copy --force &&
+	    automake --add-missing --copy && \
+		autoconf
diff --git a/bootstrap-configure b/bootstrap-configure
new file mode 100755
index 00000000..2d56ff31
--- /dev/null
+++ b/bootstrap-configure
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+if [ -f config.status ]; then
+	make maintainer-clean
+fi
+
+./bootstrap && \
+    ./configure --enable-maintainer-mode \
+		--prefix=/usr \
+		--mandir=/usr/share/man \
+		--sysconfdir=/etc
diff --git a/configure.in b/configure.in
new file mode 100644
index 00000000..645032c2
--- /dev/null
+++ b/configure.in
@@ -0,0 +1,21 @@
+AC_PREREQ(2.50)
+AC_INIT()
+
+AM_INIT_AUTOMAKE(connman-core, 0.0)
+AM_CONFIG_HEADER(config.h)
+
+AM_MAINTAINER_MODE
+
+AC_PREFIX_DEFAULT(/usr/local)
+
+if (test "${CFLAGS}" = ""); then
+	CFLAGS="-Wall -O2"
+fi
+
+AC_LANG_C
+
+AC_PROG_CC
+AC_PROG_CC_PIE
+AC_PROG_INSTALL
+
+AC_OUTPUT(Makefile)

commit e8f7754e312aeac4aaca74d304ed6e36ed2f6a0d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 20:49:15 2007 +0100

    Add skeleton for daemon and D-Bus registration

diff --git a/Makefile.am b/Makefile.am
index 4a0cec8e..baa76129 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,6 @@
 
+SUBDIRS = src
+
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
 	ltmain.sh depcomp missing install-sh mkinstalldirs
diff --git a/configure.in b/configure.in
index 645032c2..7cddb933 100644
--- a/configure.in
+++ b/configure.in
@@ -18,4 +18,9 @@ AC_PROG_CC
 AC_PROG_CC_PIE
 AC_PROG_INSTALL
 
-AC_OUTPUT(Makefile)
+PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
+				AC_MSG_ERROR(libgdbus is required))
+AC_SUBST(GDBUS_CFLAGS)
+AC_SUBST(GDBUS_LIBS)
+
+AC_OUTPUT(Makefile src/Makefile)
diff --git a/src/Makefile.am b/src/Makefile.am
new file mode 100644
index 00000000..87a6e78a
--- /dev/null
+++ b/src/Makefile.am
@@ -0,0 +1,16 @@
+
+dbusdir = $(sysconfdir)/dbus-1/system.d
+
+dbus_DATA = connman.conf
+
+sbin_PROGRAMS = connmand
+
+connmand_SOURCES = main.c connman.h
+
+connmand_LDADD = @GDBUS_LIBS@
+
+AM_CFLAGS = @GDBUS_CFLAGS@
+
+EXTRA_DIST = $(dbus_DATA)
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/src/connman.conf b/src/connman.conf
new file mode 100644
index 00000000..4e83980e
--- /dev/null
+++ b/src/connman.conf
@@ -0,0 +1,11 @@
+<!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+    <policy user="root">
+        <allow own="org.freedesktop.connman"/>
+    </policy>
+    <policy at_console="true">
+        <allow send_interface="org.freedesktop.connman"/>
+        <allow send_destination="org.freedesktop.connman"/>
+    </policy>
+</busconfig>
diff --git a/src/connman.h b/src/connman.h
new file mode 100644
index 00000000..5282d144
--- /dev/null
+++ b/src/connman.h
@@ -0,0 +1,25 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#define CONNMAN_SERVICE  "org.freedesktop.connman"
+
+#define CONNMAN_MANAGER_PATH "/"
+#define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 00000000..76af50a6
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,71 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+
+#include <gdbus.h>
+
+#include "connman.h"
+
+static GMainLoop *main_loop = NULL;
+
+static void sig_term(int sig)
+{
+	g_main_loop_quit(main_loop);
+}
+
+int main(int argc, char *argv[])
+{
+	DBusConnection *conn;
+	struct sigaction sa;
+
+	main_loop = g_main_loop_new(NULL, FALSE);
+
+	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
+	if (conn == NULL) {
+		fprintf(stderr, "Can't register with system bus\n");
+		exit(1);
+	}
+
+	g_dbus_register_object(conn, CONNMAN_MANAGER_PATH, NULL, NULL);
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_handler = sig_term;
+	sigaction(SIGINT, &sa, NULL);
+	sigaction(SIGTERM, &sa, NULL);
+
+	g_main_loop_run(main_loop);
+
+	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);
+
+	g_dbus_cleanup_connection(conn);
+
+	g_main_loop_unref(main_loop);
+
+	return 0;
+}

commit c33b387b3ed16bce4058b9088260c4ece1ff6342
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 20:51:05 2007 +0100

    Add plugin infrastructure

diff --git a/Makefile.am b/Makefile.am
index baa76129..0a0969fa 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = src
+SUBDIRS = include src plugins
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index 7cddb933..ecf67c43 100644
--- a/configure.in
+++ b/configure.in
@@ -18,9 +18,20 @@ AC_PROG_CC
 AC_PROG_CC_PIE
 AC_PROG_INSTALL
 
+m4_define([_LT_AC_TAGCONFIG], [])
+m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
+
+AC_DISABLE_STATIC
+AC_PROG_LIBTOOL
+
+PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
+				AC_MSG_ERROR(gmodule is required))
+AC_SUBST(GMODULE_CFLAGS)
+AC_SUBST(GMODULE_LIBS)
+
 PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
 				AC_MSG_ERROR(libgdbus is required))
 AC_SUBST(GDBUS_CFLAGS)
 AC_SUBST(GDBUS_LIBS)
 
-AC_OUTPUT(Makefile src/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile plugins/Makefile)
diff --git a/include/Makefile.am b/include/Makefile.am
new file mode 100644
index 00000000..55bf6b5a
--- /dev/null
+++ b/include/Makefile.am
@@ -0,0 +1,12 @@
+
+includedir = @includedir@/connman
+
+noinst_HEADERS = plugin.h
+
+MAINTAINERCLEANFILES = Makefile.in
+
+all-local:
+	@if [ ! -e connman ] ; then $(LN_S) $(top_srcdir)/include connman ; fi
+
+clean-local:
+	@rm -f connman
diff --git a/include/plugin.h b/include/plugin.h
new file mode 100644
index 00000000..b7f1eb3a
--- /dev/null
+++ b/include/plugin.h
@@ -0,0 +1,46 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_PLUGIN_H
+#define __CONNMAN_PLUGIN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct connman_plugin_desc {
+	const char *name;
+	const char *description;
+	const char *version;
+	int (*init) (void);
+	void (*exit) (void);
+};
+
+#define CONNMAN_PLUGIN_DEFINE(name,description,version,init,exit) \
+		struct connman_plugin_desc connman_plugin_desc = { \
+			name, description, version, init, exit \
+		};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_PLUGIN_H */
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/plugins/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/src/Makefile.am b/src/Makefile.am
index 87a6e78a..9f15cf37 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,11 +5,20 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h
+connmand_SOURCES = main.c connman.h plugin.c
 
-connmand_LDADD = @GDBUS_LIBS@
+connmand_LDADD = @GDBUS_LIBS@ @GMODULE_LIBS@
+ 
+if MAINTAINER_MODE
+plugindir = $(abs_top_srcdir)/plugins
+else
+plugindir = $(libdir)/connman
+endif
 
-AM_CFLAGS = @GDBUS_CFLAGS@
+AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ \
+			-DPLUGINDIR=\""$(plugindir)"\"
+
+INCLUDES = -I$(top_builddir)/include
 
 EXTRA_DIST = $(dbus_DATA)
 
diff --git a/src/connman.h b/src/connman.h
index 5282d144..f81ecd08 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -19,7 +19,17 @@
  *
  */
 
+#include <stdio.h>
+
+#define DBG(fmt, arg...)  printf("%s: " fmt "\n" , __FUNCTION__ , ## arg)
+//#define DBG(fmt, arg...)
+
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
 #define CONNMAN_MANAGER_PATH "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
+
+#include <connman/plugin.h>
+
+int __connman_plugin_init(void);
+void __connman_plugin_cleanup(void);
diff --git a/src/main.c b/src/main.c
index 76af50a6..74378029 100644
--- a/src/main.c
+++ b/src/main.c
@@ -54,6 +54,8 @@ int main(int argc, char *argv[])
 
 	g_dbus_register_object(conn, CONNMAN_MANAGER_PATH, NULL, NULL);
 
+	__connman_plugin_init();
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -61,6 +63,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_plugin_cleanup();
+
 	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);
 
 	g_dbus_cleanup_connection(conn);
diff --git a/src/plugin.c b/src/plugin.c
new file mode 100644
index 00000000..8e164e1e
--- /dev/null
+++ b/src/plugin.c
@@ -0,0 +1,141 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <dbus/dbus.h>
+
+#include <glib.h>
+#include <gmodule.h>
+
+#include <connman/plugin.h>
+
+#include "connman.h"
+
+static GSList *plugins = NULL;
+
+struct connman_plugin {
+	GModule *module;
+	struct connman_plugin_desc *desc;
+};
+
+static gboolean add_plugin(GModule *module, struct connman_plugin_desc *desc)
+{
+	struct connman_plugin *plugin;
+
+	plugin = g_try_new0(struct connman_plugin, 1);
+	if (plugin == NULL)
+		return FALSE;
+
+	plugin->module = module;
+	plugin->desc = desc;
+
+	plugins = g_slist_append(plugins, plugin);
+
+	desc->init();
+
+	return TRUE;
+}
+
+static void load_plugins(const gchar *path)
+{
+	GDir *dir;
+	const gchar *file;
+	gchar *filename;
+
+	dir = g_dir_open(path, 0, NULL);
+	if (dir != NULL) {
+		while ((file = g_dir_read_name(dir)) != NULL) {
+			GModule *module;
+			struct connman_plugin_desc *desc;
+
+			if (g_str_has_prefix(file, "libconnman") == FALSE)
+				continue;
+
+			filename = g_build_filename(path, file, NULL);
+
+			module = g_module_open(filename, 0);
+			if (module == NULL) {
+				g_warning("Can't load %s", filename);
+				continue;
+			}
+
+			g_free(filename);
+
+			DBG("%s", g_module_name(module));
+
+			if (g_module_symbol(module, "connman_plugin_desc",
+						(gpointer) &desc) == FALSE) {
+				g_warning("Can't load symbol");
+				g_module_close(module);
+				continue;
+			}
+
+			if (desc == NULL || desc->init == NULL) {
+				g_module_close(module);
+				continue;
+			}
+
+			if (add_plugin(module, desc) == FALSE)
+				g_module_close(module);
+		}
+
+		g_dir_close(dir);
+	}
+}
+
+int __connman_plugin_init(void)
+{
+	DBG("");
+
+	if (g_module_supported() == FALSE) {
+		g_warning("Modules not supported: %s", g_module_error());
+		return FALSE;
+	}
+
+	load_plugins(PLUGINDIR);
+
+	return 0;
+}
+
+void __connman_plugin_cleanup(void)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = plugins; list; list = list->next) {
+		struct connman_plugin *plugin = list->data;
+
+		DBG("%s", g_module_name(plugin->module));
+
+		if (plugin->desc->exit)
+			plugin->desc->exit();
+
+		g_module_close(plugin->module);
+
+		g_free(plugin);
+	}
+
+	g_slist_free(plugins);
+}

commit 56cf3e5a8c9403db1f1dd5c86367aba995d5fe7d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 22:10:15 2007 +0100

    Add interface infrastructure

diff --git a/configure.in b/configure.in
index ecf67c43..930691af 100644
--- a/configure.in
+++ b/configure.in
@@ -34,4 +34,9 @@ PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
 AC_SUBST(GDBUS_CFLAGS)
 AC_SUBST(GDBUS_LIBS)
 
+PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
+				AC_MSG_ERROR(libhal is required))
+AC_SUBST(HAL_CFLAGS)
+AC_SUBST(HAL_LIBS)
+
 AC_OUTPUT(Makefile include/Makefile src/Makefile plugins/Makefile)
diff --git a/include/Makefile.am b/include/Makefile.am
index 55bf6b5a..ece5af1b 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h
+noinst_HEADERS = plugin.h iface.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/iface.h b/include/iface.h
new file mode 100644
index 00000000..cc3ab0ce
--- /dev/null
+++ b/include/iface.h
@@ -0,0 +1,66 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_IFACE_H
+#define __CONNMAN_IFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum connman_iface_type {
+	CONNMAN_IFACE_TYPE_UNKNOWN   = 0,
+	CONNMAN_IFACE_TYPE_80203     = 1,
+	CONNMAN_IFACE_TYPE_80211     = 2,
+	CONNMAN_IFACE_TYPE_WIMAX     = 3,
+	CONNMAN_IFACE_TYPE_BLUETOOTH = 4,
+};
+
+enum connman_iface_flags {
+	CONNMAN_IFACE_FLAGS_CARRIER_DETECT	= (1 << 0),
+	CONNMAN_IFACE_FLAGS_IPV4		= (1 << 1),
+	CONNMAN_IFACE_FLAGS_IPV6		= (1 << 2),
+};
+
+struct connman_iface {
+	struct connman_iface_driver *driver;
+	char *path;
+	char *udi;
+	char *sysfs;
+	enum connman_iface_type type;
+	enum connman_iface_flags flags;
+};
+
+struct connman_iface_driver {
+	const char *name;
+	const char *capability;
+	int (*probe) (struct connman_iface *iface);
+	void (*remove) (struct connman_iface *iface);
+};
+
+extern int connman_iface_register(struct connman_iface_driver *driver);
+extern void connman_iface_unregister(struct connman_iface_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_IFACE_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 9f15cf37..5233c0b4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,17 +5,17 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c
+connmand_SOURCES = main.c connman.h plugin.c iface.c
 
-connmand_LDADD = @GDBUS_LIBS@ @GMODULE_LIBS@
+connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
 if MAINTAINER_MODE
 plugindir = $(abs_top_srcdir)/plugins
 else
-plugindir = $(libdir)/connman
+plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ \
+AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
 			-DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
diff --git a/src/connman.h b/src/connman.h
index f81ecd08..641b0a26 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -29,7 +29,15 @@
 #define CONNMAN_MANAGER_PATH "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 
+#define CONNMAN_IFACE_BASEPATH  "/interface"
+#define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
 void __connman_plugin_cleanup(void);
+
+#include <connman/iface.h>
+
+int __connman_iface_init(DBusConnection *conn);
+void __connman_iface_cleanup(void);
diff --git a/src/iface.c b/src/iface.c
new file mode 100644
index 00000000..ce6ab380
--- /dev/null
+++ b/src/iface.c
@@ -0,0 +1,293 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+
+#include <glib.h>
+#include <gdbus.h>
+
+#include <hal/libhal.h>
+
+#include "connman.h"
+
+static GSList *drivers = NULL;
+
+int connman_iface_register(struct connman_iface_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_append(drivers, driver);
+
+	return 0;
+}
+
+void connman_iface_unregister(struct connman_iface_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_remove(drivers, driver);
+}
+
+static GSList *interfaces = NULL;
+
+static void device_free(void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->driver && iface->driver->remove)
+		iface->driver->remove(iface);
+
+	g_free(iface->path);
+	g_free(iface->udi);
+	g_free(iface->sysfs);
+	g_free(iface);
+}
+
+static int probe_device(LibHalContext *ctx,
+			struct connman_iface_driver *driver, const char *udi)
+{
+	DBusConnection *conn;
+	struct connman_iface *iface;
+	char *temp, *sysfs;
+	int err;
+
+	DBG("ctx %p driver %p udi %s", ctx, driver, udi);
+
+	if (!driver->probe)
+		return -1;
+
+	iface = g_try_new0(struct connman_iface, 1);
+	if (iface == NULL)
+		return -1;
+
+	temp = g_path_get_basename(udi);
+	iface->path = g_strdup_printf("%s/%s", CONNMAN_IFACE_BASEPATH, temp);
+	g_free(temp);
+
+	iface->udi = g_strdup(udi);
+
+	DBG("path %s", iface->path);
+
+	sysfs = libhal_device_get_property_string(ctx, udi,
+						"linux.sysfs_path", NULL);
+	if (sysfs != NULL)
+		iface->sysfs = g_strdup(sysfs);
+
+	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
+	iface->flags = 0;
+
+	DBG("iface %p", iface);
+
+	err = driver->probe(iface);
+	if (err < 0) {
+		device_free(iface);
+		return -1;
+	}
+
+	iface->driver = driver;
+
+	conn = libhal_ctx_get_dbus_connection(ctx);
+
+	g_dbus_register_object(conn, iface->path, iface, device_free);
+
+	interfaces = g_slist_append(interfaces, iface);
+
+	return 0;
+}
+
+static void device_added(LibHalContext *ctx, const char *udi)
+{
+	GSList *list;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	for (list = drivers; list; list = list->next) {
+		struct connman_iface_driver *driver = list->data;
+
+		if (driver->capability == NULL)
+			continue;
+
+		if (libhal_device_query_capability(ctx, udi,
+					driver->capability, NULL) == TRUE) {
+			if (probe_device(ctx, driver, udi) == 0)
+				break;
+		}
+	}
+}
+
+static void device_removed(LibHalContext *ctx, const char *udi)
+{
+	DBusConnection *conn;
+	GSList *list;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	conn = libhal_ctx_get_dbus_connection(ctx);
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		if (strcmp(udi, iface->udi) == 0) {
+			interfaces = g_slist_remove(interfaces, iface);
+			g_dbus_unregister_object(conn, iface->path);
+			break;
+		}
+	}
+}
+
+static void probe_driver(LibHalContext *ctx,
+				struct connman_iface_driver *driver)
+{
+	char **list;
+	int num;
+
+	DBG("ctx %p driver %p", ctx, driver);
+
+	list = libhal_find_device_by_capability(ctx,
+					driver->capability, &num, NULL);
+	if (list) {
+		char **tmp = list;
+
+		while (*tmp) {
+			probe_device(ctx, driver, *tmp);
+			tmp++;
+		}
+
+		libhal_free_string_array(list);
+	}
+}
+
+static void find_devices(LibHalContext *ctx)
+{
+	GSList *list;
+
+	DBG("ctx %p", ctx);
+
+	for (list = drivers; list; list = list->next) {
+		struct connman_iface_driver *driver = list->data;
+
+		DBG("driver %p", driver);
+
+		if (driver->capability == NULL)
+			continue;
+
+		probe_driver(ctx, driver);
+	}
+}
+
+static LibHalContext *hal_ctx = NULL;
+
+static void hal_init(void *data)
+{
+	DBusConnection *conn = data;
+
+	DBG("conn %p", conn);
+
+	if (hal_ctx != NULL)
+		return;
+
+	hal_ctx = libhal_ctx_new();
+	if (hal_ctx == NULL)
+		return;
+
+	if (libhal_ctx_set_dbus_connection(hal_ctx, conn) == FALSE) {
+		libhal_ctx_free(hal_ctx);
+		return;
+	}
+
+	if (libhal_ctx_init(hal_ctx, NULL) == FALSE) {
+		libhal_ctx_free(hal_ctx);
+		return ;
+	}
+
+	libhal_ctx_set_device_added(hal_ctx, device_added);
+	libhal_ctx_set_device_removed(hal_ctx, device_removed);
+
+	//libhal_ctx_set_device_new_capability(hal_ctx, new_capability);
+	//libhal_ctx_set_device_lost_capability(hal_ctx, lost_capability);
+
+	find_devices(hal_ctx);
+}
+
+static void hal_cleanup(void *data)
+{
+	DBusConnection *conn = data;
+	GSList *list;
+
+	DBG("conn %p", conn);
+
+	if (hal_ctx == NULL)
+		return;
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		DBG("path %s", iface->path);
+
+		g_dbus_unregister_object(conn, iface->path);
+	}
+
+	g_slist_free(interfaces);
+
+	interfaces = NULL;
+
+	libhal_ctx_shutdown(hal_ctx, NULL);
+
+	libhal_ctx_free(hal_ctx);
+
+	hal_ctx = NULL;
+}
+
+static DBusConnection *connection = NULL;
+static guint hal_watch = 0;
+
+int __connman_iface_init(DBusConnection *conn)
+{
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
+
+	hal_init(connection);
+
+	hal_watch = g_dbus_add_watch(connection, "org.freedesktop.Hal",
+				hal_init, hal_cleanup, connection, NULL);
+
+	return 0;
+}
+
+void __connman_iface_cleanup(void)
+{
+	DBG("conn %p", connection);
+
+	g_dbus_remove_watch(connection, hal_watch);
+
+	hal_cleanup(connection);
+
+	dbus_connection_unref(connection);
+}
diff --git a/src/main.c b/src/main.c
index 74378029..89c49fdb 100644
--- a/src/main.c
+++ b/src/main.c
@@ -56,6 +56,8 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
+	__connman_iface_init(conn);
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -63,6 +65,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_iface_cleanup();
+
 	__connman_plugin_cleanup();
 
 	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);

commit 369edde7e8054b798f9a70d20f98864a1f324e05
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 22:10:30 2007 +0100

    Add skeletons for 802.03 and 802.11 interface plugins

diff --git a/plugins/80203.c b/plugins/80203.c
new file mode 100644
index 00000000..7921d9c2
--- /dev/null
+++ b/plugins/80203.c
@@ -0,0 +1,68 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <connman/plugin.h>
+#include <connman/iface.h>
+
+static int iface_probe(struct connman_iface *iface)
+{
+	printf("[802.03] probe interface %s\n", iface->udi);
+
+	iface->type = CONNMAN_IFACE_TYPE_80203;
+
+	iface->flags = CONNMAN_IFACE_FLAGS_CARRIER_DETECT |
+						CONNMAN_IFACE_FLAGS_IPV4;
+
+	return 0;
+}
+
+static void iface_remove(struct connman_iface *iface)
+{
+	printf("[802.03] remove interface %s\n", iface->udi);
+}
+
+static struct connman_iface_driver iface_driver = {
+	.name		= "80203",
+	.capability	= "net.80203",
+	.probe		= iface_probe,
+	.remove		= iface_remove,
+};
+
+static int plugin_init(void)
+{
+	connman_iface_register(&iface_driver);
+
+	return 0;
+}
+
+static void plugin_exit(void)
+{
+	connman_iface_unregister(&iface_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("80203", "IEEE 802.03 interface plugin", VERSION,
+						plugin_init, plugin_exit)
diff --git a/plugins/80211.c b/plugins/80211.c
new file mode 100644
index 00000000..eea416ba
--- /dev/null
+++ b/plugins/80211.c
@@ -0,0 +1,67 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <connman/plugin.h>
+#include <connman/iface.h>
+
+static int iface_probe(struct connman_iface *iface)
+{
+	printf("[802.11] probe interface %s\n", iface->udi);
+
+	iface->type = CONNMAN_IFACE_TYPE_80211;
+
+	iface->flags = CONNMAN_IFACE_FLAGS_IPV4;
+
+	return 0;
+}
+
+static void iface_remove(struct connman_iface *iface)
+{
+	printf("[802.11] remove interface %s\n", iface->udi);
+}
+
+static struct connman_iface_driver iface_driver = {
+	.name		= "80211",
+	.capability	= "net.80211",
+	.probe		= iface_probe,
+	.remove		= iface_remove,
+};
+
+static int plugin_init(void)
+{
+	connman_iface_register(&iface_driver);
+
+	return 0;
+}
+
+static void plugin_exit(void)
+{
+	connman_iface_unregister(&iface_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("80211", "IEEE 802.11 interface plugin", VERSION,
+						plugin_init, plugin_exit)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 02742923..aa9ed779 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,2 +1,14 @@
 
+plugindir = $(libdir)/connman/plugins
+
+plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la
+
+libconnman_80203_la_SOURCES = 80203.c
+
+libconnman_80211_la_SOURCES = 80211.c
+
+AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
+
+INCLUDES = -I$(top_builddir)/include
+
 MAINTAINERCLEANFILES = Makefile.in

commit 0446b9206238e24a5019483a2e2aea27d41f75dc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 22:36:10 2007 +0100

    Add basic DHCP infrastructure

diff --git a/include/Makefile.am b/include/Makefile.am
index ece5af1b..627ab0a0 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h iface.h
+noinst_HEADERS = plugin.h iface.h dhcp.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/dhcp.h b/include/dhcp.h
new file mode 100644
index 00000000..337746b3
--- /dev/null
+++ b/include/dhcp.h
@@ -0,0 +1,44 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_DHCP_H
+#define __CONNMAN_DHCP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/iface.h>
+
+struct connman_dhcp_driver {
+	const char *name;
+	int (*request) (struct connman_iface *iface);
+	int (*release) (struct connman_iface *iface);
+};
+
+extern int connman_dhcp_register(struct connman_dhcp_driver *driver);
+extern void connman_dhcp_unregister(struct connman_dhcp_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_DHCP_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 5233c0b4..05f342b9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c iface.c
+connmand_SOURCES = main.c connman.h plugin.c iface.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 641b0a26..1cd6c163 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -24,6 +24,8 @@
 #define DBG(fmt, arg...)  printf("%s: " fmt "\n" , __FUNCTION__ , ## arg)
 //#define DBG(fmt, arg...)
 
+#include <dbus/dbus.h>
+
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
 #define CONNMAN_MANAGER_PATH "/"
@@ -41,3 +43,8 @@ void __connman_plugin_cleanup(void);
 
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
+
+#include <connman/dhcp.h>
+
+int __connman_dhcp_request(struct connman_iface *iface);
+int __connman_dhcp_release(struct connman_iface *iface);
diff --git a/src/dhcp.c b/src/dhcp.c
new file mode 100644
index 00000000..5a6e5c9b
--- /dev/null
+++ b/src/dhcp.c
@@ -0,0 +1,66 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+
+#include "connman.h"
+
+static GSList *drivers = NULL;
+
+int connman_dhcp_register(struct connman_dhcp_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_append(drivers, driver);
+
+	return 0;
+}
+
+void connman_dhcp_unregister(struct connman_dhcp_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_remove(drivers, driver);
+}
+
+int __connman_dhcp_request(struct connman_iface *iface)
+{
+	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->request)
+		return driver->request(iface);
+
+	return -1;
+}
+
+int __connman_dhcp_release(struct connman_iface *iface)
+{
+	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->release)
+		return driver->release(iface);
+
+	return -1;
+}

commit e6adbd6658b15bb8dd9504fec86424382b443ab4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 23 00:07:39 2007 +0100

    Add network interface helper functions

diff --git a/plugins/80203.c b/plugins/80203.c
index 7921d9c2..6c9f9507 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -28,21 +28,39 @@
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
+#include "net.h"
+
 static int iface_probe(struct connman_iface *iface)
 {
-	printf("[802.03] probe interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	printf("[802.03] probe interface %s\n", ifname);
 
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
 	iface->flags = CONNMAN_IFACE_FLAGS_CARRIER_DETECT |
 						CONNMAN_IFACE_FLAGS_IPV4;
 
+	__net_free(ifname);
+
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.03] remove interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return;
+
+	printf("[802.03] remove interface %s\n", ifname);
+
+	__net_free(ifname);
 }
 
 static struct connman_iface_driver iface_driver = {
diff --git a/plugins/80211.c b/plugins/80211.c
index eea416ba..74438db4 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -28,20 +28,38 @@
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
+#include "net.h"
+
 static int iface_probe(struct connman_iface *iface)
 {
-	printf("[802.11] probe interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	printf("[802.11] probe interface %s\n", ifname);
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAGS_IPV4;
 
+	__net_free(ifname);
+
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.11] remove interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return;
+
+	printf("[802.11] remove interface %s\n", ifname);
+
+	__net_free(ifname);
 }
 
 static struct connman_iface_driver iface_driver = {
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index aa9ed779..2d7d5df0 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -3,9 +3,9 @@ plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la
 
-libconnman_80203_la_SOURCES = 80203.c
+libconnman_80203_la_SOURCES = 80203.c net.h net.c
 
-libconnman_80211_la_SOURCES = 80211.c
+libconnman_80211_la_SOURCES = 80211.c net.h net.c
 
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
diff --git a/plugins/net.c b/plugins/net.c
new file mode 100644
index 00000000..627b4c56
--- /dev/null
+++ b/plugins/net.c
@@ -0,0 +1,107 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "net.h"
+
+static int __net_ifindex(const char *sysfs)
+{
+	char *pathname;
+	char buf[8];
+	size_t size;
+	ssize_t len;
+	int fd, val = -EIO;
+
+	if (sysfs == NULL)
+		return -1;
+
+	size = strlen(sysfs) + 9;
+
+	pathname = malloc(size);
+
+	sprintf(pathname, "%s/ifindex", sysfs);
+
+	fd = open(pathname, O_RDONLY);
+
+	free(pathname);
+
+	if (fd < 0)
+		return -errno;
+
+	memset(buf, 0, sizeof(buf));
+
+	len = read(fd, buf, sizeof(buf) - 1);
+	if (len < 0) {
+		val = -errno;
+		goto done;
+	}
+
+	val = atoi(buf);
+
+done:
+	close(fd);
+
+	return val;
+}
+
+char *__net_ifname(const char *sysfs)
+{
+	struct ifreq ifr;
+	int sk, err, ifindex;
+
+	ifindex = __net_ifindex(sysfs);
+	if (ifindex < 0)
+		return NULL;
+
+	sk = socket (PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = ifindex;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	return strdup(ifr.ifr_name);
+}
+
+void __net_free(void *ptr)
+{
+	if (ptr)
+		free(ptr);
+}
diff --git a/plugins/net.h b/plugins/net.h
new file mode 100644
index 00000000..10f46fff
--- /dev/null
+++ b/plugins/net.h
@@ -0,0 +1,23 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+char *__net_ifname(const char *sysfs);
+void __net_free(void *ptr);

commit b93a99e200eaec8c8b0943531e11bffe86d3122d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:22:43 2007 +0100

    Add experimental IPv4 support

diff --git a/include/iface.h b/include/iface.h
index cc3ab0ce..daeaf172 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -26,6 +26,8 @@
 extern "C" {
 #endif
 
+#include <netinet/in.h>
+
 enum connman_iface_type {
 	CONNMAN_IFACE_TYPE_UNKNOWN   = 0,
 	CONNMAN_IFACE_TYPE_80203     = 1,
@@ -40,6 +42,15 @@ enum connman_iface_flags {
 	CONNMAN_IFACE_FLAGS_IPV6		= (1 << 2),
 };
 
+struct connman_ipv4 {
+	struct in_addr address;
+	struct in_addr netmask;
+	struct in_addr gateway;
+	struct in_addr network;
+	struct in_addr broadcast;
+	struct in_addr nameserver;
+};
+
 struct connman_iface {
 	struct connman_iface_driver *driver;
 	char *path;
@@ -47,6 +58,7 @@ struct connman_iface {
 	char *sysfs;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
+	struct connman_ipv4 ipv4;
 };
 
 struct connman_iface_driver {
@@ -54,6 +66,10 @@ struct connman_iface_driver {
 	const char *capability;
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
+	int (*get_ipv4) (struct connman_iface *iface,
+					struct connman_ipv4 *ipv4);
+	int (*set_ipv4) (struct connman_iface *iface,
+					struct connman_ipv4 *ipv4);
 };
 
 extern int connman_iface_register(struct connman_iface_driver *driver);
diff --git a/plugins/80203.c b/plugins/80203.c
index 6c9f9507..e39fcdc4 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <stdio.h>
+#include <arpa/inet.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
@@ -52,15 +53,34 @@ static int iface_probe(struct connman_iface *iface)
 
 static void iface_remove(struct connman_iface *iface)
 {
-	char *ifname;
+	printf("[802.03] remove interface\n");
 
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return;
+	__net_clear(iface->sysfs);
+}
 
-	printf("[802.03] remove interface %s\n", ifname);
+static int iface_get_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+		return -1;
 
-	__net_free(ifname);
+	printf("[802.03] get address %s\n", inet_ntoa(ipv4->address));
+
+	return 0;
+}
+
+static int iface_set_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	printf("[802.03] set address %s\n", inet_ntoa(ipv4->address));
+	printf("[802.03] set netmask %s\n", inet_ntoa(ipv4->netmask));
+	printf("[802.03] set gateway %s\n", inet_ntoa(ipv4->gateway));
+
+	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+				&ipv4->gateway, &ipv4->broadcast,
+						&ipv4->nameserver);
+
+	return 0;
 }
 
 static struct connman_iface_driver iface_driver = {
@@ -68,6 +88,8 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80203",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
+	.get_ipv4	= iface_get_ipv4,
+	.set_ipv4	= iface_set_ipv4,
 };
 
 static int plugin_init(void)
diff --git a/plugins/80211.c b/plugins/80211.c
index 74438db4..1fd5aaf5 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <stdio.h>
+#include <arpa/inet.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
@@ -51,15 +52,34 @@ static int iface_probe(struct connman_iface *iface)
 
 static void iface_remove(struct connman_iface *iface)
 {
-	char *ifname;
+	printf("[802.11] remove interface\n");
 
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return;
+	__net_clear(iface->sysfs);
+}
 
-	printf("[802.11] remove interface %s\n", ifname);
+static int iface_get_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+		return -1;
 
-	__net_free(ifname);
+	printf("[802.11] get address %s\n", inet_ntoa(ipv4->address));
+
+	return 0;
+}
+
+static int iface_set_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	printf("[802.11] set address %s\n", inet_ntoa(ipv4->address));
+	printf("[802.11] set netmask %s\n", inet_ntoa(ipv4->netmask));
+	printf("[802.11] set gateway %s\n", inet_ntoa(ipv4->gateway));
+
+	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+				&ipv4->gateway, &ipv4->broadcast,
+						&ipv4->nameserver);
+
+	return 0;
 }
 
 static struct connman_iface_driver iface_driver = {
@@ -67,6 +87,8 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
+	.get_ipv4	= iface_get_ipv4,
+	.set_ipv4	= iface_set_ipv4,
 };
 
 static int plugin_init(void)
diff --git a/plugins/net.c b/plugins/net.c
index 627b4c56..e0aa5a4e 100644
--- a/plugins/net.c
+++ b/plugins/net.c
@@ -30,6 +30,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
 #include <net/if.h>
 
 #include "net.h"
@@ -74,6 +76,39 @@ done:
 	return val;
 }
 
+int __net_ifaddr(const char *sysfs, struct in_addr *addr)
+{
+	struct ifreq ifr;
+	int sk, ifindex;
+
+	ifindex = __net_ifindex(sysfs);
+	if (ifindex < 0)
+		return ifindex;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = ifindex;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -errno;
+	}
+
+	if (ioctl(sk, SIOCGIFADDR, &ifr) < 0) {
+		close(sk);
+		return -errno;
+	}
+
+	close(sk);
+
+	*addr = ((struct sockaddr_in *) (&ifr.ifr_addr))->sin_addr;
+
+	return 0;
+}
+
 char *__net_ifname(const char *sysfs)
 {
 	struct ifreq ifr;
@@ -83,7 +118,7 @@ char *__net_ifname(const char *sysfs)
 	if (ifindex < 0)
 		return NULL;
 
-	sk = socket (PF_INET, SOCK_DGRAM, 0);
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return NULL;
 
@@ -105,3 +140,58 @@ void __net_free(void *ptr)
 	if (ptr)
 		free(ptr);
 }
+
+int __net_clear(const char *sysfs)
+{
+	char *ifname, cmd[128];
+
+	ifname = __net_ifname(sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	sprintf(cmd, "resolvconf -d %s", ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	sprintf(cmd, "ip addr flush dev %s", ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	__net_free(ifname);
+
+	return 0;
+}
+
+int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+				struct in_addr *route, struct in_addr *bcast,
+						struct in_addr *namesrv)
+{
+	char *ifname, cmd[128], msk[32], brd[32];
+
+	ifname = __net_ifname(sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	__net_clear(sysfs);
+
+	sprintf(msk, "%s", "24");
+	sprintf(brd, "%s", inet_ntoa(*bcast));
+	sprintf(cmd, "ip addr add %s/%s brd %s dev %s",
+				inet_ntoa(*addr), msk, brd, ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	sprintf(cmd, "ip route add default via %s dev %s",
+					inet_ntoa(*route), ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
+					inet_ntoa(*namesrv), ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	__net_free(ifname);
+
+	return 0;
+}
diff --git a/plugins/net.h b/plugins/net.h
index 10f46fff..b30ae7c0 100644
--- a/plugins/net.h
+++ b/plugins/net.h
@@ -19,5 +19,11 @@
  *
  */
 
+int __net_ifaddr(const char *sysfs, struct in_addr *addr);
 char *__net_ifname(const char *sysfs);
 void __net_free(void *ptr);
+
+int __net_clear(const char *sysfs);
+int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+				struct in_addr *route, struct in_addr *bcast,
+						struct in_addr *namesrv);

commit fb83ef710615f3239e1a9ce48363bf215359eb78
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:25:21 2007 +0100

    Add support for state directory

diff --git a/bootstrap-configure b/bootstrap-configure
index 2d56ff31..1da77dae 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -8,4 +8,5 @@ fi
     ./configure --enable-maintainer-mode \
 		--prefix=/usr \
 		--mandir=/usr/share/man \
+		--localstatedir=/var \
 		--sysconfdir=/etc
diff --git a/src/Makefile.am b/src/Makefile.am
index 05f342b9..d693035f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -9,6 +9,8 @@ connmand_SOURCES = main.c connman.h plugin.c iface.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
+statedir = $(localstatedir)/run/connman
+
 if MAINTAINER_MODE
 plugindir = $(abs_top_srcdir)/plugins
 else
@@ -16,7 +18,7 @@ plugindir = $(libdir)/connman/plugins
 endif
 
 AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
-			-DPLUGINDIR=\""$(plugindir)"\"
+		-DSTATEDIR=\""$(statedir)"\" -DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/src/main.c b/src/main.c
index 89c49fdb..245dece0 100644
--- a/src/main.c
+++ b/src/main.c
@@ -25,8 +25,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <string.h>
 #include <signal.h>
+#include <sys/stat.h>
 
 #include <gdbus.h>
 
@@ -44,6 +46,9 @@ int main(int argc, char *argv[])
 	DBusConnection *conn;
 	struct sigaction sa;
 
+	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
+			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+
 	main_loop = g_main_loop_new(NULL, FALSE);
 
 	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
@@ -75,5 +80,7 @@ int main(int argc, char *argv[])
 
 	g_main_loop_unref(main_loop);
 
+	rmdir(STATEDIR);
+
 	return 0;
 }

commit afd6d12088afd2ddcfcc23ec6060bc3216ac6977
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:29:59 2007 +0100

    Add support for initial IPv4 address retrieval

diff --git a/src/iface.c b/src/iface.c
index ce6ab380..39de81dc 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <string.h>
+#include <arpa/inet.h>
 
 #include <glib.h>
 #include <gdbus.h>
@@ -116,6 +117,13 @@ static int probe_device(LibHalContext *ctx,
 
 	interfaces = g_slist_append(interfaces, iface);
 
+	if ((iface->flags & CONNMAN_IFACE_FLAGS_IPV4) &&
+						driver->get_ipv4) {
+		driver->get_ipv4(iface, &iface->ipv4);
+
+		DBG("address %s", inet_ntoa(iface->ipv4.address));
+	}
+
 	return 0;
 }
 

commit 743f1f56acd3622f93d339370ea923c18814d241
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:43:47 2007 +0100

    Fix naming of interface flags

diff --git a/include/iface.h b/include/iface.h
index daeaf172..db0dec50 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -37,9 +37,9 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAGS_CARRIER_DETECT	= (1 << 0),
-	CONNMAN_IFACE_FLAGS_IPV4		= (1 << 1),
-	CONNMAN_IFACE_FLAGS_IPV6		= (1 << 2),
+	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 0),
+	CONNMAN_IFACE_FLAG_IPV4           = (1 << 1),
+	CONNMAN_IFACE_FLAG_IPV6           = (1 << 2),
 };
 
 struct connman_ipv4 {
diff --git a/plugins/80203.c b/plugins/80203.c
index e39fcdc4..826dd818 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -43,8 +43,8 @@ static int iface_probe(struct connman_iface *iface)
 
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
-	iface->flags = CONNMAN_IFACE_FLAGS_CARRIER_DETECT |
-						CONNMAN_IFACE_FLAGS_IPV4;
+	iface->flags = CONNMAN_IFACE_FLAG_CARRIER_DETECT |
+					CONNMAN_IFACE_FLAG_IPV4;
 
 	__net_free(ifname);
 
diff --git a/plugins/80211.c b/plugins/80211.c
index 1fd5aaf5..091a3a06 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -43,7 +43,7 @@ static int iface_probe(struct connman_iface *iface)
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
-	iface->flags = CONNMAN_IFACE_FLAGS_IPV4;
+	iface->flags = CONNMAN_IFACE_FLAG_IPV4;
 
 	__net_free(ifname);
 
diff --git a/src/iface.c b/src/iface.c
index 39de81dc..69da8fe0 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -117,7 +117,7 @@ static int probe_device(LibHalContext *ctx,
 
 	interfaces = g_slist_append(interfaces, iface);
 
-	if ((iface->flags & CONNMAN_IFACE_FLAGS_IPV4) &&
+	if ((iface->flags & CONNMAN_IFACE_FLAG_IPV4) &&
 						driver->get_ipv4) {
 		driver->get_ipv4(iface, &iface->ipv4);
 

commit 5bc520d3b5025d29a1782fc093d2f8532580e767
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 03:00:36 2007 +0100

    Add helper script and configuration file for DHCP support

diff --git a/Makefile.am b/Makefile.am
index 0a0969fa..52247b98 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src plugins
+SUBDIRS = include src plugins scripts
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index 930691af..8f13afcd 100644
--- a/configure.in
+++ b/configure.in
@@ -34,9 +34,15 @@ PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
 AC_SUBST(GDBUS_CFLAGS)
 AC_SUBST(GDBUS_LIBS)
 
+PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
+				AC_MSG_ERROR(libdbus is required))
+AC_SUBST(DBUS_CFLAGS)
+AC_SUBST(DBUS_LIBS)
+
 PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 				AC_MSG_ERROR(libhal is required))
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile plugins/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile
+			plugins/Makefile scripts/Makefile)
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
new file mode 100644
index 00000000..bb79358e
--- /dev/null
+++ b/scripts/Makefile.am
@@ -0,0 +1,14 @@
+
+scriptdir = $(libdir)/connman/scripts
+
+script_DATA = dhclient.conf
+
+script_PROGRAMS = dhclient-script
+
+dhclient_script_LDADD = @DBUS_LIBS@
+
+AM_CFLAGS = @DBUS_CFLAGS@
+
+EXTRA_DIST = $(script_DATA)
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
new file mode 100644
index 00000000..39b235c7
--- /dev/null
+++ b/scripts/dhclient-script.c
@@ -0,0 +1,110 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dbus/dbus.h>
+
+extern char **environ;
+
+static void append(DBusMessageIter *dict, const char *pattern)
+{
+	DBusMessageIter entry;
+	const char *key, *value;
+	char *delim;
+
+	delim = strchr(pattern, '=');
+	*delim = '\0';
+
+	key = pattern;
+	value = delim + 1;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+							NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+int main(int argc, char *argv[])
+{
+	DBusConnection *conn;
+	DBusMessage *msg;
+	DBusMessageIter iter, dict;
+	dbus_uint32_t pid;
+	char **envp, *busname, *reason, *interface;
+
+	busname = getenv("BUSNAME");
+
+	pid = atoi(getenv("pid"));
+	reason = getenv("reason");
+	interface = getenv("interface");
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (conn == NULL)
+		exit(1);
+
+	msg = dbus_message_new_method_call(busname, "/org/isc/dhclient",
+						"org.isc.dhclient", "notify");
+	if (msg == NULL) {
+		dbus_connection_unref(conn);
+		exit(1);
+	}
+
+	dbus_message_append_args(msg, DBUS_TYPE_UINT32, &pid,
+				DBUS_TYPE_STRING, &reason, DBUS_TYPE_INVALID);
+
+	dbus_message_iter_init_append(msg, &iter);
+
+	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_STRING_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	for (envp = environ; envp && *envp; envp++) {
+		if (strlen(*envp) < 5)
+			continue;
+
+		if (strncmp(*envp, "new_", 4) == 0 ||
+				strncmp(*envp, "old_", 4) == 0 ||
+					strncmp(*envp, "alia", 4) == 0)
+			append(&dict, *envp);
+	}
+
+	dbus_message_iter_close_container(&iter, &dict);
+
+	dbus_connection_send(conn, msg, NULL);
+
+	dbus_message_unref(msg);
+
+	dbus_connection_unref(conn);
+
+	return 0;
+}
diff --git a/scripts/dhclient.conf b/scripts/dhclient.conf
new file mode 100644
index 00000000..4b206a3b
--- /dev/null
+++ b/scripts/dhclient.conf
@@ -0,0 +1,3 @@
+send host-name "<hostname>";
+request subnet-mask, broadcast-address, time-offset, routers,
+	domain-name, domain-name-servers, host-name;

commit e1ec0cf683d35746dd4e94abfab6ad5aa2de10fe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 03:04:10 2007 +0100

    Add experimental DHCP plugin

diff --git a/include/dhcp.h b/include/dhcp.h
index 337746b3..f817e0a1 100644
--- a/include/dhcp.h
+++ b/include/dhcp.h
@@ -28,6 +28,14 @@ extern "C" {
 
 #include <connman/iface.h>
 
+enum connman_dhcp_state {
+	CONNMAN_DHCP_STATE_UNKNOWN = 0,
+	CONNMAN_DHCP_STATE_INIT    = 1,
+	CONNMAN_DHCP_STATE_BOUND   = 2,
+	CONNMAN_DHCP_STATE_RENEW   = 3,
+	CONNMAN_DHCP_STATE_FAILED  = 4,
+};
+
 struct connman_dhcp_driver {
 	const char *name;
 	int (*request) (struct connman_iface *iface);
@@ -37,6 +45,10 @@ struct connman_dhcp_driver {
 extern int connman_dhcp_register(struct connman_dhcp_driver *driver);
 extern void connman_dhcp_unregister(struct connman_dhcp_driver *driver);
 
+extern int connman_dhcp_update(struct connman_iface *iface,
+				enum connman_dhcp_state state,
+					struct connman_ipv4 *ipv4);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2d7d5df0..a0a387de 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,14 +1,29 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la
+plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
+			libconnman-dhclient.la
 
 libconnman_80203_la_SOURCES = 80203.c net.h net.c
 
 libconnman_80211_la_SOURCES = 80211.c net.h net.c
 
+libconnman_dhclient_la_SOURCES = dhclient.c net.h net.c
+libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
+
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
+statedir = $(localstatedir)/run/connman
+
+if MAINTAINER_MODE
+scriptdir = $(abs_top_srcdir)/scripts
+else
+scriptdir = $(libdir)/connman/scripts
+endif
+
+AM_CFLAGS = @GDBUS_CFLAGS@ \
+		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
+
 INCLUDES = -I$(top_builddir)/include
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
new file mode 100644
index 00000000..dbf6e6d9
--- /dev/null
+++ b/plugins/dhclient.c
@@ -0,0 +1,273 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#include <arpa/inet.h>
+
+#include <glib.h>
+#include <gdbus.h>
+
+#include <connman/plugin.h>
+#include <connman/dhcp.h>
+
+#include "net.h"
+
+static const char *busname;
+
+struct dhclient_task {
+	GPid pid;
+	char *ifname;
+	struct connman_iface *iface;
+};
+
+static GSList *tasks = NULL;
+
+static struct dhclient_task *find_task(GPid pid)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct dhclient_task *task = list->data;
+
+		if (task->pid == pid)
+			return task;
+	}
+
+	return NULL;
+}
+
+static int dhclient_request(struct connman_iface *iface)
+{
+	struct dhclient_task *task;
+	char *ifname, *argv[16], address[128], pidfile[PATH_MAX];
+	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	task = g_try_new0(struct dhclient_task, 1);
+	if (task == NULL)
+		return -1;
+
+	task->ifname = ifname;
+	task->iface = iface;
+
+	printf("[DHCP] request for %s\n", ifname);
+
+	snprintf(address, sizeof(address) - 1, "BUSNAME=%s", busname);
+	snprintf(pidfile, sizeof(pidfile) - 1,
+				"%s/dhclient.%s.pid", STATEDIR, ifname);
+	snprintf(leases, sizeof(leases) - 1,
+				"%s/dhclient.%s.leases", STATEDIR, ifname);
+	snprintf(config, sizeof(config) - 1, "%s/dhclient.conf", SCRIPTDIR);
+	snprintf(script, sizeof(script) - 1, "%s/dhclient-script", SCRIPTDIR);
+
+	argv[0] = "/sbin/dhclient";
+	argv[1] = "-d";
+	argv[2] = "-q";
+	argv[3] = "-n";
+	argv[4] = "-e";
+	argv[5] = address;
+	argv[6] = "-pf";
+	argv[7] = pidfile;
+	argv[8] = "-lf";
+	argv[9] = leases;
+	argv[10] = "-cf";
+	argv[11] = config;
+	argv[12] = "-sf";
+	argv[13] = script;
+	argv[14] = ifname;
+	argv[15] = NULL;
+
+	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+				NULL, NULL, &task->pid, NULL) == FALSE) {
+		printf("Failed to spawn dhclient\n");
+		return -1;
+	}
+
+	tasks = g_slist_append(tasks, task);
+
+	printf("[DHCP] executed with pid %d\n", task->pid);
+
+	return 0;
+}
+
+static int dhclient_release(struct connman_iface *iface)
+{
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	printf("[DHCP] release for %s\n", ifname);
+
+	__net_free(ifname);
+
+	return 0;
+}
+
+static struct connman_dhcp_driver dhclient_driver = {
+	.name		= "dhclient",
+	.request	= dhclient_request,
+	.release	= dhclient_release,
+};
+
+static DBusMessage *notify_method(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessageIter iter, dict;
+	dbus_uint32_t pid;
+	struct dhclient_task *task;
+	struct connman_ipv4 ipv4;
+	const char *text, *key, *value;
+
+	memset(&ipv4, 0, sizeof(ipv4));
+
+	dbus_message_iter_init(msg, &iter);
+
+	dbus_message_iter_get_basic(&iter, &pid);
+	dbus_message_iter_next(&iter);
+
+	dbus_message_iter_get_basic(&iter, &text);
+	dbus_message_iter_next(&iter);
+
+	printf("[DHCP] change %d to %s\n", pid, text);
+
+	task = find_task(pid);
+	if (task == NULL)
+		return NULL;
+
+	dbus_message_iter_recurse(&iter, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+		dbus_message_iter_next(&entry);
+		dbus_message_iter_get_basic(&entry, &value);
+
+		printf("[DHCP] %s = %s\n", key, value);
+
+		if (strcmp(key, "new_ip_address") == 0)
+			inet_aton(value, &ipv4.address);
+
+		if (strcmp(key, "new_subnet_mask") == 0)
+			inet_aton(value, &ipv4.netmask);
+
+		if (strcmp(key, "new_routers") == 0)
+			inet_aton(value, &ipv4.gateway);
+
+		if (strcmp(key, "new_network_number") == 0)
+			inet_aton(value, &ipv4.network);
+
+		if (strcmp(key, "new_broadcast_address") == 0)
+			inet_aton(value, &ipv4.broadcast);
+
+		if (strcmp(key, "new_domain_name_servers") == 0)
+			inet_aton(value, &ipv4.nameserver);
+
+		dbus_message_iter_next(&dict);
+	}
+
+	if (strcmp(text, "PREINIT") == 0)
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_INIT, &ipv4);
+	else if (strcmp(text, "BOUND") == 0 || strcmp(text, "REBOOT") == 0)
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_BOUND, &ipv4);
+	else if (strcmp(text, "RENEW") == 0 || strcmp(text, "REBIND") == 0)
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_RENEW, &ipv4);
+	else
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_FAILED, NULL);
+
+	return NULL;
+}
+
+static GDBusMethodTable dhclient_methods[] = {
+	{ "notify", "usa{ss}", "", notify_method, G_DBUS_METHOD_FLAG_NOREPLY },
+	{ },
+};
+
+static DBusConnection *connection;
+
+static int plugin_init(void)
+{
+	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL);
+
+	busname = dbus_bus_get_unique_name(connection);
+
+	g_dbus_register_object(connection, "/org/isc/dhclient", NULL, NULL);
+
+	g_dbus_register_interface(connection, "/org/isc/dhclient",
+					"org.isc.dhclient",
+					dhclient_methods, NULL, NULL);
+
+	connman_dhcp_register(&dhclient_driver);
+
+	return 0;
+}
+
+static void plugin_exit(void)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct dhclient_task *task = list->data;
+		char pathname[PATH_MAX];
+
+		printf("[DHCP] killing process %d\n", task->pid);
+
+		kill(task->pid, SIGTERM);
+
+		snprintf(pathname, sizeof(pathname) - 1,
+				"%s/dhclient.%s.pid", STATEDIR, task->ifname);
+		unlink(pathname);
+
+		snprintf(pathname, sizeof(pathname) - 1,
+				"%s/dhclient.%s.leases", STATEDIR, task->ifname);
+		unlink(pathname);
+
+		__net_free(task->ifname);
+
+		g_free(task);
+	}
+
+	g_slist_free(tasks);
+
+	connman_dhcp_unregister(&dhclient_driver);
+
+	g_dbus_cleanup_connection(connection);
+}
+
+CONNMAN_PLUGIN_DEFINE("dhclient", "ISC DHCP client plugin", VERSION,
+						plugin_init, plugin_exit)
diff --git a/src/dhcp.c b/src/dhcp.c
index 5a6e5c9b..8af6dab3 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <arpa/inet.h>
+
 #include <glib.h>
 
 #include "connman.h"
@@ -45,6 +47,29 @@ void connman_dhcp_unregister(struct connman_dhcp_driver *driver)
 	drivers = g_slist_remove(drivers, driver);
 }
 
+int connman_dhcp_update(struct connman_iface *iface,
+				enum connman_dhcp_state state,
+					struct connman_ipv4 *ipv4)
+{
+	DBG("iface %p state %d", iface, state);
+
+	if (state == CONNMAN_DHCP_STATE_BOUND) {
+		DBG("address %s", inet_ntoa(ipv4->address));
+		DBG("netmask %s", inet_ntoa(ipv4->netmask));
+		DBG("gateway %s", inet_ntoa(ipv4->gateway));
+		DBG("network %s", inet_ntoa(ipv4->network));
+		DBG("broadcast %s", inet_ntoa(ipv4->broadcast));
+		DBG("nameserver %s", inet_ntoa(ipv4->nameserver));
+
+		if (iface->driver->set_ipv4) {
+			iface->driver->set_ipv4(iface, ipv4);
+			iface->ipv4 = *ipv4;
+		}
+	}
+
+	return 0;
+}
+
 int __connman_dhcp_request(struct connman_iface *iface)
 {
 	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);

commit 1f883743506f40054c29b33021948cdb4e765ba6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 09:27:23 2007 +0100

    Add interface index and state variables

diff --git a/include/iface.h b/include/iface.h
index db0dec50..9f3e5e06 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -37,9 +37,17 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 0),
+	CONNMAN_IFACE_FLAG_RTNL           = (1 << 0),
 	CONNMAN_IFACE_FLAG_IPV4           = (1 << 1),
 	CONNMAN_IFACE_FLAG_IPV6           = (1 << 2),
+	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 3),
+};
+
+enum connman_iface_state {
+	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
+	CONNMAN_IFACE_STATE_ACTIVE    = 1,
+	CONNMAN_IFACE_STATE_CONNECTED = 2,
+	CONNMAN_IFACE_STATE_READY     = 3,
 };
 
 struct connman_ipv4 {
@@ -51,13 +59,18 @@ struct connman_ipv4 {
 	struct in_addr nameserver;
 };
 
+struct connman_network {
+};
+
 struct connman_iface {
 	struct connman_iface_driver *driver;
 	char *path;
 	char *udi;
 	char *sysfs;
+	int index;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
+	enum connman_iface_state state;
 	struct connman_ipv4 ipv4;
 };
 
@@ -66,15 +79,23 @@ struct connman_iface_driver {
 	const char *capability;
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
+	int (*activate) (struct connman_iface *iface);
+	int (*shutdown) (struct connman_iface *iface);
 	int (*get_ipv4) (struct connman_iface *iface,
 					struct connman_ipv4 *ipv4);
 	int (*set_ipv4) (struct connman_iface *iface,
 					struct connman_ipv4 *ipv4);
+	int (*scan) (struct connman_iface *iface);
+	int (*connect) (struct connman_iface *iface,
+					struct connman_network *network);
 };
 
 extern int connman_iface_register(struct connman_iface_driver *driver);
 extern void connman_iface_unregister(struct connman_iface_driver *driver);
 
+extern int connman_iface_update(struct connman_iface *iface,
+					enum connman_iface_state state);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/plugins/80203.c b/plugins/80203.c
index 826dd818..785c441e 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -33,35 +33,28 @@
 
 static int iface_probe(struct connman_iface *iface)
 {
-	char *ifname;
-
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return -1;
-
-	printf("[802.03] probe interface %s\n", ifname);
+	printf("[802.03] probe interface index %d\n", iface->index);
 
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
-	iface->flags = CONNMAN_IFACE_FLAG_CARRIER_DETECT |
-					CONNMAN_IFACE_FLAG_IPV4;
-
-	__net_free(ifname);
+	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
+				CONNMAN_IFACE_FLAG_IPV4 |
+				CONNMAN_IFACE_FLAG_CARRIER_DETECT;
 
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.03] remove interface\n");
+	printf("[802.03] remove interface index %d\n", iface->index);
 
-	__net_clear(iface->sysfs);
+	__net_clear(iface->index);
 }
 
 static int iface_get_ipv4(struct connman_iface *iface,
 					struct connman_ipv4 *ipv4)
 {
-	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
 		return -1;
 
 	printf("[802.03] get address %s\n", inet_ntoa(ipv4->address));
@@ -76,7 +69,7 @@ static int iface_set_ipv4(struct connman_iface *iface,
 	printf("[802.03] set netmask %s\n", inet_ntoa(ipv4->netmask));
 	printf("[802.03] set gateway %s\n", inet_ntoa(ipv4->gateway));
 
-	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
 				&ipv4->gateway, &ipv4->broadcast,
 						&ipv4->nameserver);
 
diff --git a/plugins/80211.c b/plugins/80211.c
index 091a3a06..56306860 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -33,34 +33,36 @@
 
 static int iface_probe(struct connman_iface *iface)
 {
-	char *ifname;
-
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return -1;
-
-	printf("[802.11] probe interface %s\n", ifname);
+	printf("[802.11] probe interface index %d\n", iface->index);
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
-	iface->flags = CONNMAN_IFACE_FLAG_IPV4;
-
-	__net_free(ifname);
+	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
+				CONNMAN_IFACE_FLAG_IPV4;
 
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.11] remove interface\n");
+	printf("[802.11] remove interface index %d\n", iface->index);
+
+	__net_clear(iface->index);
+}
+
+static int iface_activate(struct connman_iface *iface)
+{
+	printf("[802.11] activate interface index %d\n", iface->index);
 
-	__net_clear(iface->sysfs);
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
+
+	return 0;
 }
 
 static int iface_get_ipv4(struct connman_iface *iface,
 					struct connman_ipv4 *ipv4)
 {
-	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
 		return -1;
 
 	printf("[802.11] get address %s\n", inet_ntoa(ipv4->address));
@@ -75,20 +77,38 @@ static int iface_set_ipv4(struct connman_iface *iface,
 	printf("[802.11] set netmask %s\n", inet_ntoa(ipv4->netmask));
 	printf("[802.11] set gateway %s\n", inet_ntoa(ipv4->gateway));
 
-	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
 				&ipv4->gateway, &ipv4->broadcast,
 						&ipv4->nameserver);
 
 	return 0;
 }
 
+static int iface_scan(struct connman_iface *iface)
+{
+	printf("[802.11] scanning interface index %d\n", iface->index);
+
+	return 0;
+}
+
+static int iface_connect(struct connman_iface *iface,
+					struct connman_network *network)
+{
+	printf("[802.11] connect interface index %d\n", iface->index);
+
+	return 0;
+}
+
 static struct connman_iface_driver iface_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
+	.activate	= iface_activate,
 	.get_ipv4	= iface_get_ipv4,
 	.set_ipv4	= iface_set_ipv4,
+	.scan		= iface_scan,
+	.connect	= iface_connect,
 };
 
 static int plugin_init(void)
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index dbf6e6d9..d32f68a7 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -67,7 +67,7 @@ static int dhclient_request(struct connman_iface *iface)
 	char *ifname, *argv[16], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
 
-	ifname = __net_ifname(iface->sysfs);
+	ifname = __net_ifname(iface->index);
 	if (ifname == NULL)
 		return -1;
 
@@ -122,7 +122,7 @@ static int dhclient_release(struct connman_iface *iface)
 {
 	char *ifname;
 
-	ifname = __net_ifname(iface->sysfs);
+	ifname = __net_ifname(iface->index);
 	if (ifname == NULL)
 		return -1;
 
diff --git a/plugins/net.c b/plugins/net.c
index e0aa5a4e..18927eed 100644
--- a/plugins/net.c
+++ b/plugins/net.c
@@ -36,54 +36,10 @@
 
 #include "net.h"
 
-static int __net_ifindex(const char *sysfs)
-{
-	char *pathname;
-	char buf[8];
-	size_t size;
-	ssize_t len;
-	int fd, val = -EIO;
-
-	if (sysfs == NULL)
-		return -1;
-
-	size = strlen(sysfs) + 9;
-
-	pathname = malloc(size);
-
-	sprintf(pathname, "%s/ifindex", sysfs);
-
-	fd = open(pathname, O_RDONLY);
-
-	free(pathname);
-
-	if (fd < 0)
-		return -errno;
-
-	memset(buf, 0, sizeof(buf));
-
-	len = read(fd, buf, sizeof(buf) - 1);
-	if (len < 0) {
-		val = -errno;
-		goto done;
-	}
-
-	val = atoi(buf);
-
-done:
-	close(fd);
-
-	return val;
-}
-
-int __net_ifaddr(const char *sysfs, struct in_addr *addr)
+int __net_ifaddr(int ifindex, struct in_addr *addr)
 {
 	struct ifreq ifr;
-	int sk, ifindex;
-
-	ifindex = __net_ifindex(sysfs);
-	if (ifindex < 0)
-		return ifindex;
+	int sk;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
@@ -109,14 +65,10 @@ int __net_ifaddr(const char *sysfs, struct in_addr *addr)
 	return 0;
 }
 
-char *__net_ifname(const char *sysfs)
+char *__net_ifname(int ifindex)
 {
 	struct ifreq ifr;
-	int sk, err, ifindex;
-
-	ifindex = __net_ifindex(sysfs);
-	if (ifindex < 0)
-		return NULL;
+	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
@@ -141,11 +93,11 @@ void __net_free(void *ptr)
 		free(ptr);
 }
 
-int __net_clear(const char *sysfs)
+int __net_clear(int ifindex)
 {
 	char *ifname, cmd[128];
 
-	ifname = __net_ifname(sysfs);
+	ifname = __net_ifname(ifindex);
 	if (ifname == NULL)
 		return -1;
 
@@ -162,17 +114,17 @@ int __net_clear(const char *sysfs)
 	return 0;
 }
 
-int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
 				struct in_addr *route, struct in_addr *bcast,
 						struct in_addr *namesrv)
 {
 	char *ifname, cmd[128], msk[32], brd[32];
 
-	ifname = __net_ifname(sysfs);
+	ifname = __net_ifname(ifindex);
 	if (ifname == NULL)
 		return -1;
 
-	__net_clear(sysfs);
+	__net_clear(ifindex);
 
 	sprintf(msk, "%s", "24");
 	sprintf(brd, "%s", inet_ntoa(*bcast));
diff --git a/plugins/net.h b/plugins/net.h
index b30ae7c0..83de416e 100644
--- a/plugins/net.h
+++ b/plugins/net.h
@@ -19,11 +19,13 @@
  *
  */
 
-int __net_ifaddr(const char *sysfs, struct in_addr *addr);
-char *__net_ifname(const char *sysfs);
+#include <arpa/inet.h>
+
+int __net_ifaddr(int ifindex, struct in_addr *addr);
+char *__net_ifname(int ifindex);
 void __net_free(void *ptr);
 
-int __net_clear(const char *sysfs);
-int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+int __net_clear(int ifindex);
+int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
 				struct in_addr *route, struct in_addr *bcast,
 						struct in_addr *namesrv);
diff --git a/src/dhcp.c b/src/dhcp.c
index 8af6dab3..b4e921e3 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -65,6 +65,8 @@ int connman_dhcp_update(struct connman_iface *iface,
 			iface->driver->set_ipv4(iface, ipv4);
 			iface->ipv4 = *ipv4;
 		}
+
+		connman_iface_update(iface, CONNMAN_IFACE_STATE_READY);
 	}
 
 	return 0;
diff --git a/src/iface.c b/src/iface.c
index 69da8fe0..9dc0c801 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -53,6 +53,33 @@ void connman_iface_unregister(struct connman_iface_driver *driver)
 
 static GSList *interfaces = NULL;
 
+int connman_iface_update(struct connman_iface *iface,
+                                        enum connman_iface_state state)
+{
+	switch (state) {
+	case CONNMAN_IFACE_STATE_ACTIVE:
+		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
+			if (iface->driver->scan)
+				iface->driver->scan(iface);
+
+			if (iface->driver->connect)
+				iface->driver->connect(iface, NULL);
+		}
+		break;
+
+	case CONNMAN_IFACE_STATE_CONNECTED:
+		__connman_dhcp_request(iface);
+		break;
+
+	default:
+		break;
+        }
+
+	iface->state = state;
+
+	return 0;
+}
+
 static void device_free(void *data)
 {
 	struct connman_iface *iface = data;
@@ -98,8 +125,15 @@ static int probe_device(LibHalContext *ctx,
 	if (sysfs != NULL)
 		iface->sysfs = g_strdup(sysfs);
 
+	iface->index = -1;
+
+	if (g_str_has_prefix(driver->capability, "net") == TRUE)
+		iface->index = libhal_device_get_property_int(ctx, udi,
+						"net.linux.ifindex", NULL);
+
 	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
 	iface->flags = 0;
+	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
 
 	DBG("iface %p", iface);
 
@@ -124,6 +158,9 @@ static int probe_device(LibHalContext *ctx,
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
 
+	if (driver->activate)
+		driver->activate(iface);
+
 	return 0;
 }
 

commit cd577016d4d7730bb612c6a5771122b68a2e1664
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 09:45:07 2007 +0100

    Add experimental netlink support

diff --git a/include/Makefile.am b/include/Makefile.am
index 627ab0a0..2d28a822 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h iface.h dhcp.h
+noinst_HEADERS = plugin.h iface.h rtnl.h dhcp.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/rtnl.h b/include/rtnl.h
new file mode 100644
index 00000000..4b3e6925
--- /dev/null
+++ b/include/rtnl.h
@@ -0,0 +1,33 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_RTNL_H
+#define __CONNMAN_RTNL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_RTNL_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index d693035f..65636af4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c iface.c dhcp.c
+connmand_SOURCES = main.c connman.h plugin.c iface.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 1cd6c163..b1b6cbea 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -44,6 +44,11 @@ void __connman_plugin_cleanup(void);
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
 
+#include <connman/rtnl.h>
+
+int __connman_rtnl_init(void);
+void __connman_rtnl_cleanup(void);
+
 #include <connman/dhcp.h>
 
 int __connman_dhcp_request(struct connman_iface *iface);
diff --git a/src/main.c b/src/main.c
index 245dece0..40d6e072 100644
--- a/src/main.c
+++ b/src/main.c
@@ -63,6 +63,8 @@ int main(int argc, char *argv[])
 
 	__connman_iface_init(conn);
 
+	__connman_rtnl_init();
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -70,6 +72,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_rtnl_cleanup();
+
 	__connman_iface_cleanup();
 
 	__connman_plugin_cleanup();
diff --git a/src/rtnl.c b/src/rtnl.c
new file mode 100644
index 00000000..c88aad10
--- /dev/null
+++ b/src/rtnl.c
@@ -0,0 +1,336 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include <glib.h>
+
+#include "connman.h"
+
+static void parse_link(struct nlmsghdr *hdr)
+{
+	struct ifinfomsg *msg;
+	struct rtattr *attr;
+	int bytes;
+
+	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
+	bytes = IFLA_PAYLOAD(hdr);
+
+	DBG("ifi_index %d ifi_flags %d", msg->ifi_index, msg->ifi_flags);
+
+	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		int len = RTA_PAYLOAD(attr);
+
+		switch (attr->rta_type) {
+		case IFLA_ADDRESS:
+			DBG("  rta_type address len %d", len);
+			break;
+		case IFLA_BROADCAST:
+			DBG("  rta_type broadcast len %d", len);
+			break;
+		case IFLA_IFNAME:
+			DBG("  rta_type ifname %s", (char *) RTA_DATA(attr));
+			break;
+		case IFLA_MTU:
+			DBG("  rta_type mtu len %d", len);
+			break;
+		case IFLA_LINK:
+			DBG("  rta_type link len %d", len);
+			break;
+		case IFLA_QDISC:
+			DBG("  rta_type qdisc len %d", len);
+			break;
+		case IFLA_STATS:
+			DBG("  rta_type stats len %d", len);
+			break;
+		case IFLA_COST:
+			DBG("  rta_type cost len %d", len);
+			break;
+		case IFLA_PRIORITY:
+			DBG("  rta_type priority len %d", len);
+			break;
+		case IFLA_MASTER:
+			DBG("  rta_type master len %d", len);
+			break;
+		case IFLA_WIRELESS:
+			DBG("  rta_type wireless len %d", len);
+			{
+				unsigned char *data = RTA_DATA(attr);
+				int i;
+				for (i = 0; i < len; i++)
+					printf(" %02x", data[i]);
+				printf("\n");
+			}
+			break;
+		case IFLA_PROTINFO:
+			DBG("  rta_type protinfo len %d", len);
+			break;
+		case IFLA_TXQLEN:
+			DBG("  rta_type txqlen len %d", len);
+			break;
+		case IFLA_MAP:
+			DBG("  rta_type map len %d", len);
+			break;
+		case IFLA_WEIGHT:
+			DBG("  rta_type widght len %d", len);
+			break;
+		case IFLA_OPERSTATE:
+			DBG("  rta_type operstate len %d", len);
+			break;
+		case IFLA_LINKMODE:
+			DBG("  rta_type linkmode len %d", len);
+			break;
+		default:
+			DBG("  rta_type %d len %d", attr->rta_type, len);
+			break;
+		}
+	}
+}
+
+static void parse_addr(struct nlmsghdr *hdr)
+{
+	struct ifaddrmsg *msg;
+	struct rtattr *attr;
+	int bytes;
+
+	msg = (struct ifaddrmsg *) NLMSG_DATA(hdr);
+	bytes = IFA_PAYLOAD(hdr);
+
+	DBG("ifa_family %d ifa_index %d", msg->ifa_family, msg->ifa_index);
+
+	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		int len = RTA_PAYLOAD(attr);
+
+		switch (attr->rta_type) {
+		case IFA_ADDRESS:
+			DBG("  rta_type address len %d", len);
+			if (msg->ifa_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case IFA_LOCAL:
+			DBG("  rta_type local len %d", len);
+			if (msg->ifa_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case IFA_LABEL:
+			DBG("  rta_type label %s", (char *) RTA_DATA(attr));
+			break;
+		case IFA_BROADCAST:
+			DBG("  rta_type broadcast len %d", len);
+			if (msg->ifa_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case IFA_ANYCAST:
+			DBG("  rta_type anycast len %d", len);
+			break;
+		case IFA_CACHEINFO:
+			DBG("  rta_type cacheinfo len %d", len);
+			break;
+		case IFA_MULTICAST:
+			DBG("  rta_type multicast len %d", len);
+			break;
+		default:
+			DBG("  rta_type %d len %d", attr->rta_type, len);
+			break;
+		}
+	}
+}
+
+static void parse_route(struct nlmsghdr *hdr)
+{
+	struct rtmsg *msg;
+	struct rtattr *attr;
+	int bytes;
+
+	msg = (struct rtmsg *) NLMSG_DATA(hdr);
+	bytes = IFA_PAYLOAD(hdr);
+
+	DBG("rtm_family %d rtm_flags %d", msg->rtm_family, msg->rtm_flags);
+
+	for (attr = RTA_DATA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		int len = RTA_PAYLOAD(attr);
+
+		switch (attr->rta_type) {
+		case RTA_DST:
+			DBG("  rta_type dst len %d", len);
+			break;
+		case RTA_SRC:
+			DBG("  rta_type src len %d", len);
+			break;
+		case RTA_IIF:
+			DBG("  rta_type iff len %d", len);
+			break;
+		case RTA_OIF:
+			DBG("  rta_type oif len %d", len);
+			break;
+		case RTA_GATEWAY:
+			DBG("  rta_type gateway len %d", len);
+			break;
+		default:
+			DBG("  rta_type %d len %d", attr->rta_type, len);
+			break;
+		}
+	}
+}
+
+static void parse_message(unsigned char *buf, size_t size)
+{
+	struct nlmsghdr *hdr = (void *) buf;
+
+	if (!NLMSG_OK(hdr, size))
+		return;
+
+	switch (hdr->nlmsg_type) {
+	case NLMSG_DONE:
+		DBG("nlmsg_type done");
+		return;
+	case NLMSG_NOOP:
+		DBG("nlmsg_type noop");
+		return;
+	case NLMSG_OVERRUN:
+		DBG("nlmsg_type overrun");
+		return;
+	case NLMSG_ERROR:
+		DBG("nlmsg_type error");
+		return;
+	case RTM_NEWLINK:
+		DBG("nlmsg_type RTM_NEWLINK");
+		parse_link(hdr);
+		break;
+	case RTM_DELLINK:
+		DBG("nlmsg_type RTM_DELLINK");
+		parse_link(hdr);
+		break;
+	case RTM_NEWADDR:
+		DBG("nlmsg_type RTM_NEWADDR");
+		parse_addr(hdr);
+		break;
+	case RTM_DELADDR:
+		DBG("nlmsg_type RTM_DELADDR");
+		parse_addr(hdr);
+		break;
+	case RTM_NEWROUTE:
+		DBG("nlmsg_type RTM_NEWROUTE");
+		parse_route(hdr);
+		break;
+	case RTM_DELROUTE:
+		DBG("nlmsg_type RTM_DELROUTE");
+		parse_route(hdr);
+		break;
+	default:
+		DBG("nlmsg_type %d", hdr->nlmsg_type);
+		break;
+	}
+}
+
+static gboolean netlink_event(GIOChannel *chan,
+				GIOCondition cond, gpointer data)
+{
+	unsigned char buf[256];
+	gsize len;
+	GIOError err;
+
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	memset(buf, 0, sizeof(buf));
+
+	err = g_io_channel_read(chan, (gchar *) buf, sizeof(buf), &len);
+	if (err) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	parse_message(buf, len);
+
+	return TRUE;
+}
+
+static GIOChannel *channel = NULL;
+
+int __connman_rtnl_init(void)
+{
+	struct sockaddr_nl addr;
+	int sk;
+
+	DBG("");
+
+	sk = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);
+	if (sk < 0)
+		return -1;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
+	addr.nl_pid = getpid();
+
+	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	channel = g_io_channel_unix_new(sk);
+	g_io_channel_set_close_on_unref(channel, TRUE);
+
+	g_io_add_watch(channel,
+			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+						netlink_event, NULL);
+
+	g_io_channel_unref(channel);
+
+	return 0;
+}
+
+void __connman_rtnl_cleanup(void)
+{
+	DBG("");
+
+	g_io_channel_unref(channel);
+
+	channel = NULL;
+}

commit e61188bfd0bf715afd472ab04867ae53cf38c647
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 09:50:33 2007 +0100

    Add skeleton for supplicant infrastructure

diff --git a/plugins/80211.c b/plugins/80211.c
index 56306860..5d52ed9b 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -30,6 +30,7 @@
 #include <connman/iface.h>
 
 #include "net.h"
+#include "supplicant.h"
 
 static int iface_probe(struct connman_iface *iface)
 {
@@ -48,12 +49,16 @@ static void iface_remove(struct connman_iface *iface)
 	printf("[802.11] remove interface index %d\n", iface->index);
 
 	__net_clear(iface->index);
+
+	__supplicant_stop(iface);
 }
 
 static int iface_activate(struct connman_iface *iface)
 {
 	printf("[802.11] activate interface index %d\n", iface->index);
 
+	__supplicant_start(iface);
+
 	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
 
 	return 0;
@@ -96,6 +101,8 @@ static int iface_connect(struct connman_iface *iface,
 {
 	printf("[802.11] connect interface index %d\n", iface->index);
 
+	__supplicant_connect(iface);
+
 	return 0;
 }
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index a0a387de..24e4433f 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -6,7 +6,8 @@ plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
 
 libconnman_80203_la_SOURCES = 80203.c net.h net.c
 
-libconnman_80211_la_SOURCES = 80211.c net.h net.c
+libconnman_80211_la_SOURCES = 80211.c net.h net.c \
+				supplicant.h supplicant.c
 
 libconnman_dhclient_la_SOURCES = dhclient.c net.h net.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
new file mode 100644
index 00000000..b83f290a
--- /dev/null
+++ b/plugins/supplicant.c
@@ -0,0 +1,49 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include "supplicant.h"
+
+int __supplicant_start(struct connman_iface *iface)
+{
+	printf("[SUPPLICANT] start for index %d\n", iface->index);
+
+	return 0;
+}
+
+int __supplicant_stop(struct connman_iface *iface)
+{
+	printf("[SUPPLICANT] stop for index %d\n", iface->index);
+
+	return 0;
+}
+
+int __supplicant_connect(struct connman_iface *iface)
+{
+	printf("[SUPPLICANT] connect for index %d\n", iface->index);
+
+	return 0;
+}
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
new file mode 100644
index 00000000..ed753a88
--- /dev/null
+++ b/plugins/supplicant.h
@@ -0,0 +1,27 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <connman/iface.h>
+
+int __supplicant_start(struct connman_iface *iface);
+int __supplicant_stop(struct connman_iface *iface);
+
+int __supplicant_connect(struct connman_iface *iface);

commit 20f5610e7d3214bd96ba976d0cafcd0a20743dde
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 10:06:17 2007 +0100

    Fix parsing of netlink messages for routing

diff --git a/src/rtnl.c b/src/rtnl.c
index c88aad10..1657c9ae 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -183,20 +183,30 @@ static void parse_route(struct nlmsghdr *hdr)
 	int bytes;
 
 	msg = (struct rtmsg *) NLMSG_DATA(hdr);
-	bytes = IFA_PAYLOAD(hdr);
+	bytes = RTM_PAYLOAD(hdr);
 
 	DBG("rtm_family %d rtm_flags %d", msg->rtm_family, msg->rtm_flags);
 
-	for (attr = RTA_DATA(msg); RTA_OK(attr, bytes);
+	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		int len = RTA_PAYLOAD(attr);
 
 		switch (attr->rta_type) {
 		case RTA_DST:
 			DBG("  rta_type dst len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
 			break;
 		case RTA_SRC:
 			DBG("  rta_type src len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
 			break;
 		case RTA_IIF:
 			DBG("  rta_type iff len %d", len);
@@ -206,6 +216,28 @@ static void parse_route(struct nlmsghdr *hdr)
 			break;
 		case RTA_GATEWAY:
 			DBG("  rta_type gateway len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case RTA_PRIORITY:
+			DBG("  rta_type priority len %d", len);
+			break;
+		case RTA_PREFSRC:
+			DBG("  rta_type prefsrc len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case RTA_METRICS:
+			DBG("  rta_type metrics len %d", len);
+			break;
+		case RTA_TABLE:
+			DBG("  rta_type table len %d", len);
 			break;
 		default:
 			DBG("  rta_type %d len %d", attr->rta_type, len);

commit c00282b78a8c8eee17f65fb75f7f9eaa89c1925a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 26 09:47:00 2007 +0100

    Add skeleton for manager interface

diff --git a/src/Makefile.am b/src/Makefile.am
index 65636af4..b78d4b38 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c iface.c rtnl.c dhcp.c
+connmand_SOURCES = main.c connman.h manager.c plugin.c iface.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index b1b6cbea..cff8f8f6 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -34,6 +34,9 @@
 #define CONNMAN_IFACE_BASEPATH  "/interface"
 #define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
 
+int __connman_manager_init(DBusConnection *conn);
+void __connman_manager_cleanup(void);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/main.c b/src/main.c
index 40d6e072..21a0513f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -57,7 +57,7 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 
-	g_dbus_register_object(conn, CONNMAN_MANAGER_PATH, NULL, NULL);
+	__connman_manager_init(conn);
 
 	__connman_plugin_init();
 
@@ -78,7 +78,7 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_cleanup();
 
-	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);
+	__connman_manager_cleanup();
 
 	g_dbus_cleanup_connection(conn);
 
diff --git a/src/manager.c b/src/manager.c
new file mode 100644
index 00000000..5fa60cc2
--- /dev/null
+++ b/src/manager.c
@@ -0,0 +1,52 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gdbus.h>
+
+#include "connman.h"
+
+static DBusConnection *connection = NULL;
+
+int __connman_manager_init(DBusConnection *conn)
+{
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
+
+	g_dbus_register_object(connection, CONNMAN_MANAGER_PATH, NULL, NULL);
+
+	return 0;
+}
+
+void __connman_manager_cleanup(void)
+{
+	DBG("conn %p", connection);
+
+	g_dbus_unregister_object(connection, CONNMAN_MANAGER_PATH);
+
+	dbus_connection_unref(connection);
+}

commit e5ea9b79443b759f6d3086d40b57a94213604352
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 26 10:13:30 2007 +0100

    Add basic methods and signals for manager interface

diff --git a/src/connman.h b/src/connman.h
index cff8f8f6..b5f0e48f 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -47,6 +47,8 @@ void __connman_plugin_cleanup(void);
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
 
+void __connman_iface_list(DBusMessageIter *iter);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/iface.c b/src/iface.c
index 9dc0c801..6825c51d 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -53,8 +53,22 @@ void connman_iface_unregister(struct connman_iface_driver *driver)
 
 static GSList *interfaces = NULL;
 
+void __connman_iface_list(DBusMessageIter *iter)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		dbus_message_iter_append_basic(iter,
+				DBUS_TYPE_OBJECT_PATH, &iface->path);
+	}
+}
+
 int connman_iface_update(struct connman_iface *iface,
-                                        enum connman_iface_state state)
+					enum connman_iface_state state)
 {
 	switch (state) {
 	case CONNMAN_IFACE_STATE_ACTIVE:
@@ -158,6 +172,12 @@ static int probe_device(LibHalContext *ctx,
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
 
+	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
+					CONNMAN_MANAGER_INTERFACE,
+					"InterfaceAdded",
+					DBUS_TYPE_OBJECT_PATH, &iface->path,
+					DBUS_TYPE_INVALID);
+
 	if (driver->activate)
 		driver->activate(iface);
 
@@ -197,6 +217,11 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 		struct connman_iface *iface = list->data;
 
 		if (strcmp(udi, iface->udi) == 0) {
+			g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
+					CONNMAN_MANAGER_INTERFACE,
+					"InterfaceRemoved",
+					DBUS_TYPE_OBJECT_PATH, &iface->path,
+					DBUS_TYPE_INVALID);
 			interfaces = g_slist_remove(interfaces, iface);
 			g_dbus_unregister_object(conn, iface->path);
 			break;
@@ -293,6 +318,12 @@ static void hal_cleanup(void *data)
 
 		DBG("path %s", iface->path);
 
+		g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
+					CONNMAN_MANAGER_INTERFACE,
+					"InterfaceRemoved",
+					DBUS_TYPE_OBJECT_PATH, &iface->path,
+					DBUS_TYPE_INVALID);
+
 		g_dbus_unregister_object(conn, iface->path);
 	}
 
diff --git a/src/manager.c b/src/manager.c
index 5fa60cc2..1afecc88 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,6 +27,41 @@
 
 #include "connman.h"
 
+static DBusMessage *list_interfaces(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, iter;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_iface_list(&iter);
+
+	dbus_message_iter_close_container(&array, &iter);
+
+	return reply;
+}
+
+static GDBusMethodTable manager_methods[] = {
+	{ "ListInterfaces", "", "ao", list_interfaces },
+	{ },
+};
+
+static GDBusSignalTable manager_signals[] = {
+	{ "InterfaceAdded",   "o" },
+	{ "InterfaceRemoved", "o" },
+	{ },
+};
+
 static DBusConnection *connection = NULL;
 
 int __connman_manager_init(DBusConnection *conn)
@@ -39,6 +74,11 @@ int __connman_manager_init(DBusConnection *conn)
 
 	g_dbus_register_object(connection, CONNMAN_MANAGER_PATH, NULL, NULL);
 
+	g_dbus_register_interface(connection, CONNMAN_MANAGER_PATH,
+						CONNMAN_MANAGER_INTERFACE,
+						manager_methods,
+						manager_signals, NULL);
+
 	return 0;
 }
 
@@ -46,6 +86,9 @@ void __connman_manager_cleanup(void)
 {
 	DBG("conn %p", connection);
 
+	g_dbus_unregister_interface(connection, CONNMAN_MANAGER_PATH,
+						CONNMAN_MANAGER_INTERFACE);
+
 	g_dbus_unregister_object(connection, CONNMAN_MANAGER_PATH);
 
 	dbus_connection_unref(connection);

commit 08647078e04d94f58155e4735fe0585fead881e3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 26 10:29:31 2007 +0100

    Add basic methods and signals for interfaces

diff --git a/src/iface.c b/src/iface.c
index 6825c51d..31763b74 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -94,6 +94,68 @@ int connman_iface_update(struct connman_iface *iface,
 	return 0;
 }
 
+static DBusMessage *enable_iface(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->activate)
+		driver->activate(iface);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static GDBusMethodTable iface_methods[] = {
+	{ "Enable", "", "", enable_iface },
+	{ },
+};
+
+static dbus_bool_t get_type(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+	const char *type;
+
+	DBG("iface %p", iface);
+
+	switch (iface->type) {
+	case CONNMAN_IFACE_TYPE_80203:
+		type = "80203";
+		break;
+	case CONNMAN_IFACE_TYPE_80211:
+		type = "80211";
+		break;
+	case CONNMAN_IFACE_TYPE_WIMAX:
+		type = "wimax";
+		break;
+	case CONNMAN_IFACE_TYPE_BLUETOOTH:
+		type = "bluetooth";
+		break;
+	default:
+		type = "unknown";
+		break;
+	}
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &type);
+
+	return TRUE;
+}
+
+static GDBusPropertyTable iface_properties[] = {
+	{ "Type", "s", get_type },
+	{ },
+};
+
 static void device_free(void *data)
 {
 	struct connman_iface *iface = data;
@@ -172,15 +234,16 @@ static int probe_device(LibHalContext *ctx,
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
 
+	g_dbus_register_interface(conn, iface->path,
+					CONNMAN_IFACE_INTERFACE,
+					iface_methods, NULL, iface_properties);
+
 	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
 					CONNMAN_MANAGER_INTERFACE,
 					"InterfaceAdded",
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
-	if (driver->activate)
-		driver->activate(iface);
-
 	return 0;
 }
 
@@ -223,6 +286,8 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 			interfaces = g_slist_remove(interfaces, iface);
+			g_dbus_unregister_interface(conn, iface->path,
+						CONNMAN_IFACE_INTERFACE);
 			g_dbus_unregister_object(conn, iface->path);
 			break;
 		}
@@ -324,6 +389,9 @@ static void hal_cleanup(void *data)
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
+		g_dbus_unregister_interface(conn, iface->path,
+						CONNMAN_IFACE_INTERFACE);
+
 		g_dbus_unregister_object(conn, iface->path);
 	}
 

commit c3a32686d0a50746e152967fd6f4912aec336f66
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 29 07:28:59 2007 +0100

    Add callback for wireless netlink events

diff --git a/include/iface.h b/include/iface.h
index 9f3e5e06..4fc51879 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -88,6 +88,9 @@ struct connman_iface_driver {
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
+
+	void (*rtnl_wireless) (struct connman_iface *iface,
+					void *data, unsigned short len);
 };
 
 extern int connman_iface_register(struct connman_iface_driver *driver);
diff --git a/src/connman.h b/src/connman.h
index b5f0e48f..6f361c86 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -47,6 +47,7 @@ void __connman_plugin_cleanup(void);
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
 
+struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
 
 #include <connman/rtnl.h>
diff --git a/src/iface.c b/src/iface.c
index 31763b74..72bc142c 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -53,6 +53,20 @@ void connman_iface_unregister(struct connman_iface_driver *driver)
 
 static GSList *interfaces = NULL;
 
+struct connman_iface *__connman_iface_find(int index)
+{
+	GSList *list;
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		if (iface->index == index)
+			return iface;
+	}
+
+	return NULL;
+}
+
 void __connman_iface_list(DBusMessageIter *iter)
 {
 	GSList *list;
diff --git a/src/rtnl.c b/src/rtnl.c
index 1657c9ae..5b245497 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -36,8 +36,23 @@
 
 #include "connman.h"
 
-static void parse_link(struct nlmsghdr *hdr)
+static inline void print_char(struct rtattr *attr, const char *name)
 {
+	printf("  attr %s (len %d) %s", name, RTA_PAYLOAD(attr),
+						(char *) RTA_DATA(attr));
+}
+
+static inline void print_attr(struct rtattr *attr, const char *name)
+{
+	if (name)
+		printf("  attr %s (len %d)", name, RTA_PAYLOAD(attr));
+	else
+		printf("  attr %d (len %d)", attr->rta_type, RTA_PAYLOAD(attr));
+}
+
+static void rtnl_link(struct nlmsghdr *hdr)
+{
+	struct connman_iface *iface;
 	struct ifinfomsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -47,78 +62,79 @@ static void parse_link(struct nlmsghdr *hdr)
 
 	DBG("ifi_index %d ifi_flags %d", msg->ifi_index, msg->ifi_flags);
 
+	iface = __connman_iface_find(msg->ifi_index);
+	if (iface == NULL)
+		return;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return;
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
-		int len = RTA_PAYLOAD(attr);
-
 		switch (attr->rta_type) {
 		case IFLA_ADDRESS:
-			DBG("  rta_type address len %d", len);
+			print_attr(attr, "address");
 			break;
 		case IFLA_BROADCAST:
-			DBG("  rta_type broadcast len %d", len);
+			print_attr(attr, "broadcast");
 			break;
 		case IFLA_IFNAME:
-			DBG("  rta_type ifname %s", (char *) RTA_DATA(attr));
+			print_char(attr, "ifname");
 			break;
 		case IFLA_MTU:
-			DBG("  rta_type mtu len %d", len);
+			print_attr(attr, "mtu");
 			break;
 		case IFLA_LINK:
-			DBG("  rta_type link len %d", len);
+			print_attr(attr, "link");
 			break;
 		case IFLA_QDISC:
-			DBG("  rta_type qdisc len %d", len);
+			print_attr(attr, "qdisc");
 			break;
 		case IFLA_STATS:
-			DBG("  rta_type stats len %d", len);
+			print_attr(attr, "stats");
 			break;
 		case IFLA_COST:
-			DBG("  rta_type cost len %d", len);
+			print_attr(attr, "cost");
 			break;
 		case IFLA_PRIORITY:
-			DBG("  rta_type priority len %d", len);
+			print_attr(attr, "priority");
 			break;
 		case IFLA_MASTER:
-			DBG("  rta_type master len %d", len);
+			print_attr(attr, "master");
 			break;
 		case IFLA_WIRELESS:
-			DBG("  rta_type wireless len %d", len);
-			{
-				unsigned char *data = RTA_DATA(attr);
-				int i;
-				for (i = 0; i < len; i++)
-					printf(" %02x", data[i]);
-				printf("\n");
-			}
+			if (iface->driver->rtnl_wireless)
+				iface->driver->rtnl_wireless(iface,
+					RTA_DATA(attr), RTA_PAYLOAD(attr));
 			break;
 		case IFLA_PROTINFO:
-			DBG("  rta_type protinfo len %d", len);
+			print_attr(attr, "protinfo");
 			break;
 		case IFLA_TXQLEN:
-			DBG("  rta_type txqlen len %d", len);
+			print_attr(attr, "txqlen");
 			break;
 		case IFLA_MAP:
-			DBG("  rta_type map len %d", len);
+			print_attr(attr, "map");
 			break;
 		case IFLA_WEIGHT:
-			DBG("  rta_type widght len %d", len);
+			print_attr(attr, "weight");
 			break;
 		case IFLA_OPERSTATE:
-			DBG("  rta_type operstate len %d", len);
+			print_attr(attr, "operstate");
 			break;
 		case IFLA_LINKMODE:
-			DBG("  rta_type linkmode len %d", len);
+			print_attr(attr, "linkmode");
 			break;
 		default:
-			DBG("  rta_type %d len %d", attr->rta_type, len);
+			print_attr(attr, NULL);
 			break;
 		}
 	}
 }
 
-static void parse_addr(struct nlmsghdr *hdr)
+static void rtnl_addr(struct nlmsghdr *hdr)
 {
+	struct connman_iface *iface;
 	struct ifaddrmsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -128,13 +144,18 @@ static void parse_addr(struct nlmsghdr *hdr)
 
 	DBG("ifa_family %d ifa_index %d", msg->ifa_family, msg->ifa_index);
 
+	iface = __connman_iface_find(msg->ifa_index);
+	if (iface == NULL)
+		return;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return;
+
 	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
-		int len = RTA_PAYLOAD(attr);
-
 		switch (attr->rta_type) {
 		case IFA_ADDRESS:
-			DBG("  rta_type address len %d", len);
+			print_attr(attr, "address");
 			if (msg->ifa_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -142,7 +163,7 @@ static void parse_addr(struct nlmsghdr *hdr)
 			}
 			break;
 		case IFA_LOCAL:
-			DBG("  rta_type local len %d", len);
+			print_attr(attr, "local");
 			if (msg->ifa_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -150,10 +171,10 @@ static void parse_addr(struct nlmsghdr *hdr)
 			}
 			break;
 		case IFA_LABEL:
-			DBG("  rta_type label %s", (char *) RTA_DATA(attr));
+			print_char(attr, "label");
 			break;
 		case IFA_BROADCAST:
-			DBG("  rta_type broadcast len %d", len);
+			print_attr(attr, "broadcast");
 			if (msg->ifa_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -161,22 +182,22 @@ static void parse_addr(struct nlmsghdr *hdr)
 			}
 			break;
 		case IFA_ANYCAST:
-			DBG("  rta_type anycast len %d", len);
+			print_attr(attr, "anycast");
 			break;
 		case IFA_CACHEINFO:
-			DBG("  rta_type cacheinfo len %d", len);
+			print_attr(attr, "cacheinfo");
 			break;
 		case IFA_MULTICAST:
-			DBG("  rta_type multicast len %d", len);
+			print_attr(attr, "multicast");
 			break;
 		default:
-			DBG("  rta_type %d len %d", attr->rta_type, len);
+			print_attr(attr, NULL);
 			break;
 		}
 	}
 }
 
-static void parse_route(struct nlmsghdr *hdr)
+static void rtnl_route(struct nlmsghdr *hdr)
 {
 	struct rtmsg *msg;
 	struct rtattr *attr;
@@ -189,11 +210,9 @@ static void parse_route(struct nlmsghdr *hdr)
 
 	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
-		int len = RTA_PAYLOAD(attr);
-
 		switch (attr->rta_type) {
 		case RTA_DST:
-			DBG("  rta_type dst len %d", len);
+			print_attr(attr, "dst");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -201,7 +220,7 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_SRC:
-			DBG("  rta_type src len %d", len);
+			print_attr(attr, "src");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -209,13 +228,13 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_IIF:
-			DBG("  rta_type iff len %d", len);
+			print_char(attr, "iif");
 			break;
 		case RTA_OIF:
-			DBG("  rta_type oif len %d", len);
+			print_attr(attr, "oif");
 			break;
 		case RTA_GATEWAY:
-			DBG("  rta_type gateway len %d", len);
+			print_attr(attr, "gateway");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -223,10 +242,10 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_PRIORITY:
-			DBG("  rta_type priority len %d", len);
+			print_attr(attr, "priority");
 			break;
 		case RTA_PREFSRC:
-			DBG("  rta_type prefsrc len %d", len);
+			print_attr(attr, "prefsrc");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -234,19 +253,19 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_METRICS:
-			DBG("  rta_type metrics len %d", len);
+			print_attr(attr, "metrics");
 			break;
 		case RTA_TABLE:
-			DBG("  rta_type table len %d", len);
+			print_attr(attr, "table");
 			break;
 		default:
-			DBG("  rta_type %d len %d", attr->rta_type, len);
+			print_attr(attr, NULL);
 			break;
 		}
 	}
 }
 
-static void parse_message(unsigned char *buf, size_t size)
+static void rtnl_message(unsigned char *buf, size_t size)
 {
 	struct nlmsghdr *hdr = (void *) buf;
 
@@ -255,43 +274,37 @@ static void parse_message(unsigned char *buf, size_t size)
 
 	switch (hdr->nlmsg_type) {
 	case NLMSG_DONE:
-		DBG("nlmsg_type done");
+		DBG("done");
 		return;
 	case NLMSG_NOOP:
-		DBG("nlmsg_type noop");
+		DBG("noop");
 		return;
 	case NLMSG_OVERRUN:
-		DBG("nlmsg_type overrun");
+		DBG("overrun");
 		return;
 	case NLMSG_ERROR:
-		DBG("nlmsg_type error");
+		DBG("error");
 		return;
 	case RTM_NEWLINK:
-		DBG("nlmsg_type RTM_NEWLINK");
-		parse_link(hdr);
+		rtnl_link(hdr);
 		break;
 	case RTM_DELLINK:
-		DBG("nlmsg_type RTM_DELLINK");
-		parse_link(hdr);
+		rtnl_link(hdr);
 		break;
 	case RTM_NEWADDR:
-		DBG("nlmsg_type RTM_NEWADDR");
-		parse_addr(hdr);
+		rtnl_addr(hdr);
 		break;
 	case RTM_DELADDR:
-		DBG("nlmsg_type RTM_DELADDR");
-		parse_addr(hdr);
+		rtnl_addr(hdr);
 		break;
 	case RTM_NEWROUTE:
-		DBG("nlmsg_type RTM_NEWROUTE");
-		parse_route(hdr);
+		rtnl_route(hdr);
 		break;
 	case RTM_DELROUTE:
-		DBG("nlmsg_type RTM_DELROUTE");
-		parse_route(hdr);
+		rtnl_route(hdr);
 		break;
 	default:
-		DBG("nlmsg_type %d", hdr->nlmsg_type);
+		DBG("type %d", hdr->nlmsg_type);
 		break;
 	}
 }
@@ -318,7 +331,7 @@ static gboolean netlink_event(GIOChannel *chan,
 		return FALSE;
 	}
 
-	parse_message(buf, len);
+	rtnl_message(buf, len);
 
 	return TRUE;
 }
@@ -338,7 +351,8 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
+	addr.nl_groups = RTMGRP_LINK;
+	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 	addr.nl_pid = getpid();
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {

commit 0c2d46245dd190dc80872bd1627bfd908dfa8c14
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 29 08:02:19 2007 +0100

    Add basic carrier detection

diff --git a/include/iface.h b/include/iface.h
index 4fc51879..930abe79 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -68,6 +68,7 @@ struct connman_iface {
 	char *udi;
 	char *sysfs;
 	int index;
+	int carrier;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
diff --git a/src/rtnl.c b/src/rtnl.c
index 5b245497..726d4917 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -29,6 +29,7 @@
 #include <sys/socket.h>
 #include <arpa/inet.h>
 
+#include <linux/if.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 
@@ -38,16 +39,17 @@
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %d) %s", name, RTA_PAYLOAD(attr),
+	printf("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		printf("  attr %s (len %d)", name, RTA_PAYLOAD(attr));
+		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
 	else
-		printf("  attr %d (len %d)", attr->rta_type, RTA_PAYLOAD(attr));
+		printf("  attr %d (len %d)\n",
+					attr->rta_type, RTA_PAYLOAD(attr));
 }
 
 static void rtnl_link(struct nlmsghdr *hdr)
@@ -60,7 +62,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
 	bytes = IFLA_PAYLOAD(hdr);
 
-	DBG("ifi_index %d ifi_flags %d", msg->ifi_index, msg->ifi_flags);
+	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
 
 	iface = __connman_iface_find(msg->ifi_index);
 	if (iface == NULL)
@@ -69,6 +71,11 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
 		return;
 
+	if (iface->carrier != (msg->ifi_flags & IFF_RUNNING)) {
+		iface->carrier = (msg->ifi_flags & IFF_RUNNING);
+		DBG("carrier %s", iface->carrier ? "on" : "off");
+	}
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
@@ -206,7 +213,7 @@ static void rtnl_route(struct nlmsghdr *hdr)
 	msg = (struct rtmsg *) NLMSG_DATA(hdr);
 	bytes = RTM_PAYLOAD(hdr);
 
-	DBG("rtm_family %d rtm_flags %d", msg->rtm_family, msg->rtm_flags);
+	DBG("rtm_family %d rtm_flags 0x%04x", msg->rtm_family, msg->rtm_flags);
 
 	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {

commit aa844c538bf698eba5799526ca1d246fec9503eb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 30 04:12:04 2007 +0100

    Add carrier detection callbacks and driver data functions

diff --git a/include/iface.h b/include/iface.h
index 930abe79..d4eb2134 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -63,7 +63,6 @@ struct connman_network {
 };
 
 struct connman_iface {
-	struct connman_iface_driver *driver;
 	char *path;
 	char *udi;
 	char *sysfs;
@@ -73,6 +72,9 @@ struct connman_iface {
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
 	struct connman_ipv4 ipv4;
+
+	struct connman_iface_driver *driver;
+	void *driver_data;
 };
 
 struct connman_iface_driver {
@@ -90,6 +92,7 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
+	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
 	void (*rtnl_wireless) (struct connman_iface *iface,
 					void *data, unsigned short len);
 };
@@ -97,9 +100,23 @@ struct connman_iface_driver {
 extern int connman_iface_register(struct connman_iface_driver *driver);
 extern void connman_iface_unregister(struct connman_iface_driver *driver);
 
+static inline void *connman_iface_get_data(struct connman_iface *iface)
+{
+	return iface->driver_data;
+}
+
+static inline void connman_iface_set_data(struct connman_iface *iface,
+								void *data)
+{
+	iface->driver_data = data;
+}
+
 extern int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state);
 
+extern void connman_iface_indicate_carrier(struct connman_iface *iface,
+							int carrier);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/iface.c b/src/iface.c
index 72bc142c..a641bf33 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -108,6 +108,11 @@ int connman_iface_update(struct connman_iface *iface,
 	return 0;
 }
 
+void connman_iface_indicate_carrier(struct connman_iface *iface, int carrier)
+{
+	DBG("iface %p carrier %d", iface, carrier);
+}
+
 static DBusMessage *enable_iface(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
diff --git a/src/rtnl.c b/src/rtnl.c
index 726d4917..33031ffc 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -43,6 +43,12 @@ static inline void print_char(struct rtattr *attr, const char *name)
 						(char *) RTA_DATA(attr));
 }
 
+static inline void print_byte(struct rtattr *attr, const char *name)
+{
+	printf("  attr %s (len %d) 0x%02x\n", name, RTA_PAYLOAD(attr),
+					*((unsigned char *) RTA_DATA(attr)));
+}
+
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
@@ -71,9 +77,12 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
 		return;
 
-	if (iface->carrier != (msg->ifi_flags & IFF_RUNNING)) {
-		iface->carrier = (msg->ifi_flags & IFF_RUNNING);
-		DBG("carrier %s", iface->carrier ? "on" : "off");
+	if (iface->carrier != ((msg->ifi_flags & IFF_RUNNING) != 0)) {
+		iface->carrier = ((msg->ifi_flags & IFF_RUNNING) != 0);
+		if (iface->driver->rtnl_carrier)
+			iface->driver->rtnl_carrier(iface, iface->carrier);
+		else
+			connman_iface_indicate_carrier(iface, iface->carrier);
 	}
 
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
@@ -127,10 +136,10 @@ static void rtnl_link(struct nlmsghdr *hdr)
 			print_attr(attr, "weight");
 			break;
 		case IFLA_OPERSTATE:
-			print_attr(attr, "operstate");
+			print_byte(attr, "operstate");
 			break;
 		case IFLA_LINKMODE:
-			print_attr(attr, "linkmode");
+			print_byte(attr, "linkmode");
 			break;
 		default:
 			print_attr(attr, NULL);

commit cdaa2829f53e2476bab667fd2330cde19bdfb7b4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 05:22:46 2008 +0100

    Add experimental supplicant support

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b83f290a..ec0b7e73 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -24,26 +24,253 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <net/if.h>
+
+#include <glib.h>
 
 #include "supplicant.h"
 
+struct supplicant_task {
+	GPid pid;
+	int ifindex;
+	char *ifname;
+	struct connman_iface *iface;
+	int socket;
+	GIOChannel *channel;
+};
+
+static GSList *tasks = NULL;
+
+static struct supplicant_task *find_task(int ifindex)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct supplicant_task *task = list->data;
+
+		if (task->ifindex == ifindex) 
+			return task;
+	}
+
+	return NULL;
+}
+
+static int exec_cmd(struct supplicant_task *task, char *cmd)
+{
+	write(task->socket, cmd, strlen(cmd));
+
+	return 0;
+}
+
+static gboolean control_event(GIOChannel *chan,
+				GIOCondition cond, gpointer data)
+{
+	struct supplicant_task *task = data;
+	char buf[256];
+	gsize len;
+	GIOError err;
+
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	memset(buf, 0, sizeof(buf));
+
+	err = g_io_channel_read(chan, buf, sizeof(buf), &len);
+	if (err) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	if (buf[0] != '<')
+		return TRUE;
+
+	printf("[SUPPLICANT] %s\n", buf + 3);
+
+	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
+		printf("[SUPPLICANT] connected\n");
+		connman_iface_update(task->iface,
+					CONNMAN_IFACE_STATE_CONNECTED);
+	}
+
+	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
+		printf("[SUPPLICANT] disconnected\n");
+	}
+
+	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-TERMINATING") == TRUE) {
+		printf("[SUPPLICANT] terminating\n");
+	}
+
+	return TRUE;
+}
+
+static int open_control(struct supplicant_task *task)
+{
+	struct sockaddr_un addr;
+	int sk;
+
+	printf("[SUPPLICANT] open control for %s\n", task->ifname);
+
+	sk = socket(PF_UNIX, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_UNIX;
+	snprintf(addr.sun_path, sizeof(addr.sun_path),
+					"%s/%s.cli", STATEDIR, task->ifname);
+	//unlink(addr.sun_path);
+
+	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_UNIX;
+	snprintf(addr.sun_path, sizeof(addr.sun_path),
+					"%s/%s", STATEDIR, task->ifname);
+
+	if (connect(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	task->socket = sk;
+
+	task->channel = g_io_channel_unix_new(sk);
+	g_io_channel_set_close_on_unref(task->channel, TRUE);
+
+	g_io_add_watch(task->channel,
+			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+						control_event, task);
+
+	exec_cmd(task, "ATTACH");
+	exec_cmd(task, "ADD_NETWORK");
+
+	g_io_channel_unref(task->channel);
+
+	return 0;
+}
+
 int __supplicant_start(struct connman_iface *iface)
 {
-	printf("[SUPPLICANT] start for index %d\n", iface->index);
+	struct ifreq ifr;
+	struct supplicant_task *task;
+	char *argv[9];
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	printf("[SUPPLICANT] start %s\n", ifr.ifr_name);
+
+	task = g_try_new0(struct supplicant_task, 1);
+	if (task == NULL)
+		return -ENOMEM;
+
+	task->ifindex = iface->index;
+	task->ifname = strdup(ifr.ifr_name);
+	task->iface = iface;
+
+	if (task->ifname == NULL) {
+		g_free(task);
+		return -ENOMEM;
+	}
+
+	argv[0] = "/sbin/wpa_supplicant";
+	argv[1] = "-qq";
+	argv[2] = "-C";
+	argv[3] = STATEDIR;
+	argv[4] = "-D";
+	argv[5] = "wext";
+	argv[6] = "-i";
+	argv[7] = task->ifname;
+	argv[8] = NULL;
+
+	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+				NULL, NULL, &task->pid, NULL) == FALSE) {
+		printf("Failed to spawn wpa_supplicant\n");
+		return -1;
+	}
+
+	tasks = g_slist_append(tasks, task);
+
+	printf("[SUPPLICANT] executed with pid %d\n", task->pid);
+
+	sleep(1);
+
+	task->socket = -1;
+
+	if (open_control(task) < 0)
+		printf("[SUPPLICANT] control failed\n");
 
 	return 0;
 }
 
 int __supplicant_stop(struct connman_iface *iface)
 {
-	printf("[SUPPLICANT] stop for index %d\n", iface->index);
+	struct supplicant_task *task;
+	char pathname[PATH_MAX];
+
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
+
+	printf("[SUPPLICANT] stop %s\n", task->ifname);
+
+	tasks = g_slist_remove(tasks, task);
+
+	exec_cmd(task, "DETACH");
+
+	//close(task->socket);
+	g_io_channel_unref(task->channel);
+
+	snprintf(pathname, sizeof(pathname),
+					"%s/%s.cli", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	kill(task->pid, SIGTERM);
+
+	free(task->ifname);
+
+	g_free(task);
 
 	return 0;
 }
 
 int __supplicant_connect(struct connman_iface *iface)
 {
-	printf("[SUPPLICANT] connect for index %d\n", iface->index);
+	struct supplicant_task *task;
+
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
+
+	printf("[SUPPLICANT] connect %s\n", task->ifname);
+
+	exec_cmd(task, "DISABLE_NETWORK 0");
 
 	return 0;
 }

commit 921f79feea506fd3e44ea980c6aad04c9aac7955
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 05:34:18 2008 +0100

    Add independent interface name retrieval

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index d32f68a7..8506c633 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -24,10 +24,15 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <signal.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
 #include <arpa/inet.h>
+#include <net/if.h>
 
 #include <glib.h>
 #include <gdbus.h>
@@ -35,12 +40,11 @@
 #include <connman/plugin.h>
 #include <connman/dhcp.h>
 
-#include "net.h"
-
 static const char *busname;
 
 struct dhclient_task {
 	GPid pid;
+	int ifindex;
 	char *ifname;
 	struct connman_iface *iface;
 };
@@ -63,28 +67,46 @@ static struct dhclient_task *find_task(GPid pid)
 
 static int dhclient_request(struct connman_iface *iface)
 {
+	struct ifreq ifr;
 	struct dhclient_task *task;
-	char *ifname, *argv[16], address[128], pidfile[PATH_MAX];
+	char *argv[16], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
+	int sk, err;
 
-	ifname = __net_ifname(iface->index);
-	if (ifname == NULL)
-		return -1;
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
 
 	task = g_try_new0(struct dhclient_task, 1);
 	if (task == NULL)
-		return -1;
+		return -ENOMEM;
 
-	task->ifname = ifname;
+	task->ifindex = iface->index;
+	task->ifname = strdup(ifr.ifr_name);
 	task->iface = iface;
 
-	printf("[DHCP] request for %s\n", ifname);
+	if (task->ifname == NULL) {
+		g_free(task);
+		return -ENOMEM;
+	}
+
+	printf("[DHCP] request %s\n", task->ifname);
 
 	snprintf(address, sizeof(address) - 1, "BUSNAME=%s", busname);
 	snprintf(pidfile, sizeof(pidfile) - 1,
-				"%s/dhclient.%s.pid", STATEDIR, ifname);
+			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
 	snprintf(leases, sizeof(leases) - 1,
-				"%s/dhclient.%s.leases", STATEDIR, ifname);
+			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
 	snprintf(config, sizeof(config) - 1, "%s/dhclient.conf", SCRIPTDIR);
 	snprintf(script, sizeof(script) - 1, "%s/dhclient-script", SCRIPTDIR);
 
@@ -102,7 +124,7 @@ static int dhclient_request(struct connman_iface *iface)
 	argv[11] = config;
 	argv[12] = "-sf";
 	argv[13] = script;
-	argv[14] = ifname;
+	argv[14] = task->ifname;
 	argv[15] = NULL;
 
 	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
@@ -120,15 +142,7 @@ static int dhclient_request(struct connman_iface *iface)
 
 static int dhclient_release(struct connman_iface *iface)
 {
-	char *ifname;
-
-	ifname = __net_ifname(iface->index);
-	if (ifname == NULL)
-		return -1;
-
-	printf("[DHCP] release for %s\n", ifname);
-
-	__net_free(ifname);
+	printf("[DHCP] release\n");
 
 	return 0;
 }
@@ -257,7 +271,7 @@ static void plugin_exit(void)
 				"%s/dhclient.%s.leases", STATEDIR, task->ifname);
 		unlink(pathname);
 
-		__net_free(task->ifname);
+		free(task->ifname);
 
 		g_free(task);
 	}

commit 95dcef8b866aa9effbbde4c1103d960420cf5fff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 07:20:26 2008 +0100

    Add handling of scanning and stations

diff --git a/plugins/80211.c b/plugins/80211.c
index 5d52ed9b..d4c63dcc 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -24,76 +24,236 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
 #include <arpa/inet.h>
+#include <net/if.h>
+#include <net/ethernet.h>
+#include <linux/wireless.h>
+
+#include <glib.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
-#include "net.h"
 #include "supplicant.h"
 
+struct station_data {
+	char *address;
+	char *name;
+	int mode;
+	int qual;
+	int noise;
+	int level;
+
+	unsigned char wpa_ie[40];
+	int wpa_ie_len;
+	unsigned char rsn_ie[40];
+	int rsn_ie_len;
+};
+
+struct iface_data {
+	char ifname[IFNAMSIZ];
+	GSList *stations;
+};
+
+static struct station_data *create_station(struct iface_data *iface,
+							const char *address)
+{
+	struct station_data *station;
+	GSList *list;
+
+	for (list = iface->stations; list; list = list->next) {
+		station = list->data;
+
+		if (g_ascii_strcasecmp(station->address, address) == 0)
+			return station;
+	}
+
+	station = g_try_new0(struct station_data, 1);
+	if (station == NULL)
+		return NULL;
+
+	station->address = g_strdup(address);
+	if (station->address == NULL) {
+		g_free(station);
+		return NULL;
+	}
+
+	iface->stations = g_slist_append(iface->stations, station);
+
+	return station;
+}
+
+static void load_stations(struct iface_data *iface)
+{
+	GKeyFile *keyfile;
+	gchar **groups, **group;
+	gsize length;
+
+	keyfile = g_key_file_new();
+
+	if (g_key_file_load_from_file(keyfile, "/tmp/stations.list",
+				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+		goto done;
+
+	groups = g_key_file_get_groups(keyfile, &length);
+
+	for (group = groups; *group; group++) {
+		struct station_data *station;
+
+		station = create_station(iface, *group);
+		if (station == NULL)
+			continue;
+
+		station->name = g_key_file_get_string(keyfile,
+						*group, "Name", NULL);
+	
+		station->mode = g_key_file_get_integer(keyfile,
+						*group, "Mode", NULL);
+	}
+
+	g_strfreev(groups);
+
+done:
+	g_key_file_free(keyfile);
+
+	printf("[802.11] loaded %d stations\n",
+				g_slist_length(iface->stations));
+}
+
+static void print_stations(struct iface_data *iface)
+{
+	GKeyFile *keyfile;
+	gchar *data;
+	gsize length;
+	GSList *list;
+
+	keyfile = g_key_file_new();
+
+	for (list = iface->stations; list; list = list->next) {
+		struct station_data *station = list->data;
+
+		//printf("Address:%s Mode:%d ESSID:\"%s\" Quality:%d/100\n",
+		//			station->address, station->mode,
+		//				station->name, station->qual);
+
+		g_key_file_set_string(keyfile, station->address,
+						"Name", station->name);
+
+		g_key_file_set_integer(keyfile, station->address,
+						"Mode", station->mode);
+	}
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents("/tmp/stations.list", data, length, NULL);
+
+	g_key_file_free(keyfile);
+}
+
 static int iface_probe(struct connman_iface *iface)
 {
-	printf("[802.11] probe interface index %d\n", iface->index);
+	struct iface_data *data;
+	struct ifreq ifr;
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	printf("[802.11] probe %s\n", ifr.ifr_name);
+
+	data = malloc(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	memset(data, 0, sizeof(*data));
+
+	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
 				CONNMAN_IFACE_FLAG_IPV4;
 
+	connman_iface_set_data(iface, data);
+
+	load_stations(data);
+
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.11] remove interface index %d\n", iface->index);
+	struct iface_data *data = connman_iface_get_data(iface);
 
-	__net_clear(iface->index);
+	printf("[802.11] remove %s\n", data->ifname);
 
 	__supplicant_stop(iface);
+
+	connman_iface_set_data(iface, NULL);
+
+	free(data);
 }
 
 static int iface_activate(struct connman_iface *iface)
 {
-	printf("[802.11] activate interface index %d\n", iface->index);
+	struct iface_data *data = connman_iface_get_data(iface);
 
-	__supplicant_start(iface);
+	printf("[802.11] activate %s\n", data->ifname);
 
 	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
 
 	return 0;
 }
 
-static int iface_get_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
+static int iface_scan(struct connman_iface *iface)
 {
-	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
-		return -1;
+	struct iface_data *data = connman_iface_get_data(iface);
+	struct iwreq iwr;
+	struct iw_scan_req iws;
+	int sk, err;
 
-	printf("[802.11] get address %s\n", inet_ntoa(ipv4->address));
+	printf("[802.11] scanning %s\n", data->ifname);
 
-	return 0;
-}
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
 
-static int iface_set_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
-{
-	printf("[802.11] set address %s\n", inet_ntoa(ipv4->address));
-	printf("[802.11] set netmask %s\n", inet_ntoa(ipv4->netmask));
-	printf("[802.11] set gateway %s\n", inet_ntoa(ipv4->gateway));
+	memset(&iws, 0, sizeof(iws));
+	iws.scan_type = IW_SCAN_TYPE_PASSIVE;
+	//iws.scan_type = IW_SCAN_TYPE_ACTIVE;
 
-	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
-				&ipv4->gateway, &ipv4->broadcast,
-						&ipv4->nameserver);
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
 
-	return 0;
-}
+	iwr.u.data.pointer = (caddr_t ) &iws;
+	iwr.u.data.length = sizeof(iws);
+	iwr.u.data.flags = IW_SCAN_DEFAULT;
 
-static int iface_scan(struct connman_iface *iface)
-{
-	printf("[802.11] scanning interface index %d\n", iface->index);
+	err = ioctl(sk, SIOCSIWSCAN, &iwr);
 
-	return 0;
+	close(sk);
+
+	if (err < 0)
+		printf("[802.11] scan initiate error %d\n", errno);
+
+	return err;
 }
 
 static int iface_connect(struct connman_iface *iface,
@@ -101,21 +261,227 @@ static int iface_connect(struct connman_iface *iface,
 {
 	printf("[802.11] connect interface index %d\n", iface->index);
 
+	__supplicant_start(iface);
+
 	__supplicant_connect(iface);
 
 	return 0;
 }
 
+static void iface_carrier(struct connman_iface *iface, int carrier)
+{
+	printf("[802.11] carrier %s\n", carrier ? "on" : "off");
+
+	connman_iface_indicate_carrier(iface, carrier);
+}
+
+static void parse_genie(struct station_data *station,
+					unsigned char *data, int len)
+{
+	int offset = 0;
+
+	while (offset <= len - 2) {
+		//int i;
+
+		switch (data[offset]) {
+		case 0xdd:	/* WPA1 (and other) */
+			break;
+		case 0x30:	/* WPA2 (RSN) */
+			break;
+		default:
+			break;
+		}
+
+		//for (i = 0; i < len; i++)
+		//	printf(" %02x", data[i]);
+		//printf("\n");
+
+		offset += data[offset + 1] + 2;
+	}
+}
+
+static void parse_scan_results(struct connman_iface *iface,
+					unsigned char *data, int len)
+{
+	unsigned char *ptr = data;
+	struct station_data *station = NULL;
+	struct ether_addr *eth;
+	char addr[18];
+	int num = 0;
+
+	while (len > IW_EV_LCP_PK_LEN) {
+		struct iw_event *event = (void *) ptr;
+
+		switch (event->cmd) {
+		case SIOCGIWAP:
+			eth = (void *) &event->u.ap_addr.sa_data;
+			sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+			station = create_station(connman_iface_get_data(iface),
+									addr);
+			num++;
+			break;
+		case SIOCGIWESSID:
+			if (station != NULL) {
+				station->name = malloc(event->len - 7);
+				if (station->name != NULL) {
+					memset(station->name, 0, event->len - 7);
+					memcpy(station->name, ptr + 8,
+								event->len - 8);
+				}
+			}
+			break;
+		case SIOCGIWNAME:
+			break;
+		case SIOCGIWMODE:
+			if (station != NULL)
+				station->mode = event->u.mode;
+			break;
+		case SIOCGIWFREQ:
+			break;
+		case SIOCGIWENCODE:
+			if (station != NULL) {
+				if (!(event->u.data.flags & IW_ENCODE_DISABLED)) {
+					/* privacy */
+				}
+			}
+			break;
+		case SIOCGIWRATE:
+			break;
+		case IWEVQUAL:
+			if (station != NULL) {
+				station->qual = event->u.qual.qual;
+				station->noise = event->u.qual.noise;
+				station->level = event->u.qual.level;
+			}
+			break;
+		case IWEVGENIE:
+			if (station != NULL)
+				parse_genie(station, ptr + 8, event->len - 8);
+			break;
+		case IWEVCUSTOM:
+			break;
+		default:
+			printf("[802.11] scan element 0x%04x (len %d)\n",
+						event->cmd, event->len);
+			break;
+		}
+
+		ptr += event->len;
+		len -= event->len;
+	}
+
+	printf("[802.11] found %d networks\n", num);
+}
+
+static void iface_scan_results(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+	struct iwreq iwr;
+	unsigned char *buf;
+	int sk, err, size = 1024;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return;
+
+retrieve:
+	buf = malloc(size);
+	if (buf == NULL) {
+		close(sk);
+		return;
+	}
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = buf;
+	iwr.u.data.length = size;
+	iwr.u.data.flags = 0;
+
+	err = ioctl(sk, SIOCGIWSCAN, &iwr);
+	if (err < 0) {
+		if (errno == E2BIG) {
+			free(buf);
+			size *= 2;
+			goto retrieve;
+		}
+	} else
+		parse_scan_results(iface, iwr.u.data.pointer,
+						iwr.u.data.length);
+
+	close(sk);
+
+	free(buf);
+
+	print_stations(data);
+}
+
+static void iface_wireless(struct connman_iface *iface,
+					void *data, unsigned short len)
+{
+	struct iw_event *event = data;
+	struct iw_point point;
+	struct ether_addr *eth;
+	char addr[18];
+
+	switch (event->cmd) {
+	case SIOCSIWFREQ:
+		printf("[802.11] Set Frequency (flags %d)\n",
+							event->u.freq.flags);
+		break;
+	case SIOCSIWMODE:
+		printf("[802.11] Set Mode (mode %d)\n", event->u.mode);
+		break;
+	case SIOCSIWESSID:
+		memcpy(&point, data + IW_EV_LCP_LEN -
+					IW_EV_POINT_OFF, sizeof(point));
+		point.pointer = data + IW_EV_LCP_LEN +
+					sizeof(point) - IW_EV_POINT_OFF;
+		printf("[802.11] Set ESSID (length %d flags %d) \"%s\"\n",
+					point.length, point.flags,
+						(char *) point.pointer);
+		break;
+	case SIOCSIWENCODE:
+		printf("[802.11] Set Encryption key (flags %d)\n",
+							event->u.data.flags);
+		break;
+
+	case SIOCGIWAP:
+		eth = (void *) &event->u.ap_addr.sa_data;
+		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+		printf("[802.11] New Access Point %s\n", addr);
+		break;
+	case SIOCGIWSCAN:
+		iface_scan_results(iface);
+		break;
+	default:
+		printf("[802.11] Wireless event (cmd 0x%04x len %d)\n",
+						event->cmd, event->len);
+		break;
+	}
+}
+
 static struct connman_iface_driver iface_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
 	.activate	= iface_activate,
-	.get_ipv4	= iface_get_ipv4,
-	.set_ipv4	= iface_set_ipv4,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.rtnl_carrier	= iface_carrier,
+	.rtnl_wireless	= iface_wireless,
 };
 
 static int plugin_init(void)

commit 352f418dd03cd3ac1aac6dc52d9f69209ba98744
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 20:43:34 2008 +0100

    Add experimental IPv4 address retrieval over netlink

diff --git a/include/iface.h b/include/iface.h
index d4eb2134..a128e062 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -117,6 +117,11 @@ extern int connman_iface_update(struct connman_iface *iface,
 extern void connman_iface_indicate_carrier(struct connman_iface *iface,
 							int carrier);
 
+extern int connman_iface_get_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4);
+extern int connman_iface_set_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/connman.h b/src/connman.h
index 6f361c86..fdb9fa83 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -55,6 +55,8 @@ void __connman_iface_list(DBusMessageIter *iter);
 int __connman_rtnl_init(void);
 void __connman_rtnl_cleanup(void);
 
+int __connman_rtnl_send(const void *buf, size_t len);
+
 #include <connman/dhcp.h>
 
 int __connman_dhcp_request(struct connman_iface *iface);
diff --git a/src/dhcp.c b/src/dhcp.c
index b4e921e3..2fa3f1fe 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -64,6 +64,9 @@ int connman_dhcp_update(struct connman_iface *iface,
 		if (iface->driver->set_ipv4) {
 			iface->driver->set_ipv4(iface, ipv4);
 			iface->ipv4 = *ipv4;
+		} else {
+			connman_iface_set_ipv4(iface, ipv4);
+			iface->ipv4 = *ipv4;
 		}
 
 		connman_iface_update(iface, CONNMAN_IFACE_STATE_READY);
diff --git a/src/iface.c b/src/iface.c
index a641bf33..be7f261e 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -26,6 +26,9 @@
 #include <string.h>
 #include <arpa/inet.h>
 
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
 #include <glib.h>
 #include <gdbus.h>
 
@@ -101,7 +104,7 @@ int connman_iface_update(struct connman_iface *iface,
 
 	default:
 		break;
-        }
+	}
 
 	iface->state = state;
 
@@ -113,6 +116,43 @@ void connman_iface_indicate_carrier(struct connman_iface *iface, int carrier)
 	DBG("iface %p carrier %d", iface, carrier);
 }
 
+int connman_iface_get_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4)
+{
+	struct {
+		struct nlmsghdr hdr;
+		struct rtgenmsg msg;
+	} req;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return -1;
+
+	DBG("iface %p ipv4 %p", iface, ipv4);
+
+	memset(&req, 0, sizeof(req));
+	req.hdr.nlmsg_len = sizeof(req);
+	req.hdr.nlmsg_type = RTM_GETADDR;
+	req.hdr.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.hdr.nlmsg_pid = 0;
+	req.hdr.nlmsg_seq = 4711;
+	req.msg.rtgen_family = AF_INET;
+
+	__connman_rtnl_send(&req, sizeof(req));
+
+	return 0;
+}
+
+int connman_iface_set_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4)
+{
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return -1;
+
+	DBG("iface %p ipv4 %p", iface, ipv4);
+
+	return 0;
+}
+
 static DBusMessage *enable_iface(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -246,9 +286,11 @@ static int probe_device(LibHalContext *ctx,
 
 	interfaces = g_slist_append(interfaces, iface);
 
-	if ((iface->flags & CONNMAN_IFACE_FLAG_IPV4) &&
-						driver->get_ipv4) {
-		driver->get_ipv4(iface, &iface->ipv4);
+	if (iface->flags & CONNMAN_IFACE_FLAG_IPV4) {
+		if (driver->get_ipv4)
+			driver->get_ipv4(iface, &iface->ipv4);
+		else
+			connman_iface_get_ipv4(iface, &iface->ipv4);
 
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
diff --git a/src/main.c b/src/main.c
index 21a0513f..14198cd4 100644
--- a/src/main.c
+++ b/src/main.c
@@ -61,10 +61,10 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
-	__connman_iface_init(conn);
-
 	__connman_rtnl_init();
 
+	__connman_iface_init(conn);
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -72,10 +72,10 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
-	__connman_rtnl_cleanup();
-
 	__connman_iface_cleanup();
 
+	__connman_rtnl_cleanup();
+
 	__connman_plugin_cleanup();
 
 	__connman_manager_cleanup();
diff --git a/src/rtnl.c b/src/rtnl.c
index 33031ffc..d678aa70 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -37,6 +37,17 @@
 
 #include "connman.h"
 
+static inline void print_inet(struct rtattr *attr, const char *name, int family)
+{
+	if (family == AF_INET) {
+		struct in_addr addr;
+		addr = *((struct in_addr *) RTA_DATA(attr));
+		printf("  attr %s (len %d) %s\n",
+				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
+	} else
+		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
+}
+
 static inline void print_char(struct rtattr *attr, const char *name)
 {
 	printf("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
@@ -171,31 +182,16 @@ static void rtnl_addr(struct nlmsghdr *hdr)
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
 		case IFA_ADDRESS:
-			print_attr(attr, "address");
-			if (msg->ifa_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "address", msg->ifa_family);
 			break;
 		case IFA_LOCAL:
-			print_attr(attr, "local");
-			if (msg->ifa_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "local", msg->ifa_family);
 			break;
 		case IFA_LABEL:
 			print_char(attr, "label");
 			break;
 		case IFA_BROADCAST:
-			print_attr(attr, "broadcast");
-			if (msg->ifa_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "broadcast", msg->ifa_family);
 			break;
 		case IFA_ANYCAST:
 			print_attr(attr, "anycast");
@@ -228,20 +224,10 @@ static void rtnl_route(struct nlmsghdr *hdr)
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
 		case RTA_DST:
-			print_attr(attr, "dst");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "dst", msg->rtm_family);
 			break;
 		case RTA_SRC:
-			print_attr(attr, "src");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "src", msg->rtm_family);
 			break;
 		case RTA_IIF:
 			print_char(attr, "iif");
@@ -250,23 +236,13 @@ static void rtnl_route(struct nlmsghdr *hdr)
 			print_attr(attr, "oif");
 			break;
 		case RTA_GATEWAY:
-			print_attr(attr, "gateway");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "gateway", msg->rtm_family);
 			break;
 		case RTA_PRIORITY:
 			print_attr(attr, "priority");
 			break;
 		case RTA_PREFSRC:
-			print_attr(attr, "prefsrc");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "prefsrc", msg->rtm_family);
 			break;
 		case RTA_METRICS:
 			print_attr(attr, "metrics");
@@ -281,47 +257,57 @@ static void rtnl_route(struct nlmsghdr *hdr)
 	}
 }
 
-static void rtnl_message(unsigned char *buf, size_t size)
+static void rtnl_message(void *buf, size_t len)
 {
-	struct nlmsghdr *hdr = (void *) buf;
+	DBG("buf %p len %d", buf, len);
 
-	if (!NLMSG_OK(hdr, size))
-		return;
+	while (len > 0) {
+		struct nlmsghdr *hdr = buf;
 
-	switch (hdr->nlmsg_type) {
-	case NLMSG_DONE:
-		DBG("done");
-		return;
-	case NLMSG_NOOP:
-		DBG("noop");
-		return;
-	case NLMSG_OVERRUN:
-		DBG("overrun");
-		return;
-	case NLMSG_ERROR:
-		DBG("error");
-		return;
-	case RTM_NEWLINK:
-		rtnl_link(hdr);
-		break;
-	case RTM_DELLINK:
-		rtnl_link(hdr);
-		break;
-	case RTM_NEWADDR:
-		rtnl_addr(hdr);
-		break;
-	case RTM_DELADDR:
-		rtnl_addr(hdr);
-		break;
-	case RTM_NEWROUTE:
-		rtnl_route(hdr);
-		break;
-	case RTM_DELROUTE:
-		rtnl_route(hdr);
-		break;
-	default:
-		DBG("type %d", hdr->nlmsg_type);
-		break;
+		if (!NLMSG_OK(hdr, len))
+			break;
+
+		DBG("len %d type %d flags 0x%04x",
+			hdr->nlmsg_len, hdr->nlmsg_type, hdr->nlmsg_flags);
+
+		switch (hdr->nlmsg_type) {
+		case NLMSG_DONE:
+			DBG("done");
+			return;
+		case NLMSG_NOOP:
+			DBG("noop");
+			return;
+		case NLMSG_OVERRUN:
+			DBG("overrun");
+			return;
+		case NLMSG_ERROR:
+			DBG("error");
+			return;
+		case RTM_NEWLINK:
+			rtnl_link(hdr);
+			break;
+		case RTM_DELLINK:
+			rtnl_link(hdr);
+			break;
+		case RTM_NEWADDR:
+			rtnl_addr(hdr);
+			break;
+		case RTM_DELADDR:
+			rtnl_addr(hdr);
+			break;
+		case RTM_NEWROUTE:
+			rtnl_route(hdr);
+			break;
+		case RTM_DELROUTE:
+			rtnl_route(hdr);
+			break;
+		default:
+			DBG("type %d", hdr->nlmsg_type);
+			break;
+		}
+
+		len -= hdr->nlmsg_len;
+		buf += hdr->nlmsg_len;
 	}
 }
 
@@ -354,6 +340,22 @@ static gboolean netlink_event(GIOChannel *chan,
 
 static GIOChannel *channel = NULL;
 
+int __connman_rtnl_send(const void *buf, size_t len)
+{
+	struct sockaddr_nl addr;
+	int sk;
+
+	DBG("buf %p len %d", buf, len);
+
+	sk = g_io_channel_unix_get_fd(channel);
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+
+	return sendto(sk, buf, len, 0,
+			(struct sockaddr *) &addr, sizeof(addr));
+}
+
 int __connman_rtnl_init(void)
 {
 	struct sockaddr_nl addr;

commit f24401eee00df645f2f676381c947487b4ddf6ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 2 18:30:19 2008 +0100

    Add more netlink debugging

diff --git a/src/rtnl.c b/src/rtnl.c
index d678aa70..a8131d08 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -263,12 +263,14 @@ static void rtnl_message(void *buf, size_t len)
 
 	while (len > 0) {
 		struct nlmsghdr *hdr = buf;
+		struct nlmsgerr *err;
 
 		if (!NLMSG_OK(hdr, len))
 			break;
 
-		DBG("len %d type %d flags 0x%04x",
-			hdr->nlmsg_len, hdr->nlmsg_type, hdr->nlmsg_flags);
+		DBG("len %d type %d flags 0x%04x seq %d",
+					hdr->nlmsg_len, hdr->nlmsg_type,
+					hdr->nlmsg_flags, hdr->nlmsg_seq);
 
 		switch (hdr->nlmsg_type) {
 		case NLMSG_DONE:
@@ -281,7 +283,9 @@ static void rtnl_message(void *buf, size_t len)
 			DBG("overrun");
 			return;
 		case NLMSG_ERROR:
-			DBG("error");
+			err = NLMSG_DATA(hdr);
+			DBG("error %d (%s)", -err->error,
+						strerror(-err->error));
 			return;
 		case RTM_NEWLINK:
 			rtnl_link(hdr);
@@ -371,7 +375,6 @@ int __connman_rtnl_init(void)
 	addr.nl_family = AF_NETLINK;
 	addr.nl_groups = RTMGRP_LINK;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
-	addr.nl_pid = getpid();
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 		close(sk);

commit 5057d6849ddaead7b1f5f614d58670122f2fde6f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:32:12 2008 +0100

    Fix netlink debugging and enable IPv4 address notifications

diff --git a/src/rtnl.c b/src/rtnl.c
index a8131d08..fd61d0dc 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -273,36 +273,42 @@ static void rtnl_message(void *buf, size_t len)
 					hdr->nlmsg_flags, hdr->nlmsg_seq);
 
 		switch (hdr->nlmsg_type) {
-		case NLMSG_DONE:
-			DBG("done");
-			return;
 		case NLMSG_NOOP:
-			DBG("noop");
-			return;
-		case NLMSG_OVERRUN:
-			DBG("overrun");
+			DBG("NOOP");
 			return;
 		case NLMSG_ERROR:
 			err = NLMSG_DATA(hdr);
-			DBG("error %d (%s)", -err->error,
+			DBG("ERROR %d (%s)", -err->error,
 						strerror(-err->error));
 			return;
+		case NLMSG_DONE:
+			DBG("DONE");
+			return;
+		case NLMSG_OVERRUN:
+			DBG("OVERRUN");
+			return;
 		case RTM_NEWLINK:
+			DBG("NEWLINK");
 			rtnl_link(hdr);
 			break;
 		case RTM_DELLINK:
+			DBG("DELLINK");
 			rtnl_link(hdr);
 			break;
 		case RTM_NEWADDR:
+			DBG("NEWADDR");
 			rtnl_addr(hdr);
 			break;
 		case RTM_DELADDR:
+			DBG("DELADDR");
 			rtnl_addr(hdr);
 			break;
 		case RTM_NEWROUTE:
+			DBG("NEWROUTE");
 			rtnl_route(hdr);
 			break;
 		case RTM_DELROUTE:
+			DBG("DELROUTE");
 			rtnl_route(hdr);
 			break;
 		default:
@@ -373,7 +379,7 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK;
+	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {

commit 3b0fee6fcf0de532b1b115341e53ac3ec5c5768a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:35:18 2008 +0100

    Add generic setting of IPv4 addresses and the default route

diff --git a/include/iface.h b/include/iface.h
index a128e062..d6b67932 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -121,6 +121,7 @@ extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
 extern int connman_iface_set_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
+extern int connman_iface_clear_ipv4(struct connman_iface *iface);
 
 #ifdef __cplusplus
 }
diff --git a/src/iface.c b/src/iface.c
index be7f261e..2446d125 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -23,8 +23,16 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
 #include <arpa/inet.h>
+#include <net/if.h>
+#include <net/route.h>
 
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
@@ -130,9 +138,9 @@ int connman_iface_get_ipv4(struct connman_iface *iface,
 	DBG("iface %p ipv4 %p", iface, ipv4);
 
 	memset(&req, 0, sizeof(req));
-	req.hdr.nlmsg_len = sizeof(req);
+	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
 	req.hdr.nlmsg_type = RTM_GETADDR;
-	req.hdr.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
 	req.hdr.nlmsg_pid = 0;
 	req.hdr.nlmsg_seq = 4711;
 	req.msg.rtgen_family = AF_INET;
@@ -145,11 +153,123 @@ int connman_iface_get_ipv4(struct connman_iface *iface,
 int connman_iface_set_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4)
 {
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
 		return -1;
 
 	DBG("iface %p ipv4 %p", iface, ipv4);
 
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->address;
+
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+
+	if (err < 0)
+		DBG("address setting failed (%s)", strerror(errno));
+
+	addr = (struct sockaddr_in *) &ifr.ifr_netmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->netmask;
+
+	err = ioctl(sk, SIOCSIFNETMASK, &ifr);
+
+	if (err < 0)
+		DBG("netmask setting failed (%s)", strerror(errno));
+
+	addr = (struct sockaddr_in *) &ifr.ifr_broadaddr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->broadcast;
+
+	err = ioctl(sk, SIOCSIFBRDADDR, &ifr);
+
+	if (err < 0)
+		DBG("broadcast setting failed (%s)", strerror(errno));
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->gateway;
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCADDRT, &rt);
+
+	close(sk);
+
+	if (err < 0) {
+		DBG("default route failed (%s)", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+int connman_iface_clear_ipv4(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return -1;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	//err = ioctl(sk, SIOCDIFADDR, &ifr);
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0 && errno != EADDRNOTAVAIL) {
+		DBG("address removal failed (%s)", strerror(errno));
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -221,6 +341,8 @@ static void device_free(void *data)
 
 	DBG("iface %p", iface);
 
+	connman_iface_clear_ipv4(iface);
+
 	if (iface->driver && iface->driver->remove)
 		iface->driver->remove(iface);
 

commit 0e3c123c9fc860de733b4df6647efe70c4780add
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:37:29 2008 +0100

    Add experimental method for scanning activation

diff --git a/src/iface.c b/src/iface.c
index 2446d125..5fc4eaf5 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -98,9 +98,6 @@ int connman_iface_update(struct connman_iface *iface,
 	switch (state) {
 	case CONNMAN_IFACE_STATE_ACTIVE:
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
-			if (iface->driver->scan)
-				iface->driver->scan(iface);
-
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
 		}
@@ -294,8 +291,30 @@ static DBusMessage *enable_iface(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *scan_iface(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->scan)
+		driver->scan(iface);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static GDBusMethodTable iface_methods[] = {
 	{ "Enable", "", "", enable_iface },
+	{ "Scan",   "", "", scan_iface   },
 	{ },
 };
 

commit 7a580c5a50681601db10786f327899b309879009
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:48:25 2008 +0100

    Add support for setting the nameserver using resolvconf

diff --git a/src/iface.c b/src/iface.c
index 5fc4eaf5..53031f62 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -26,6 +26,7 @@
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
@@ -153,6 +154,7 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 	struct ifreq ifr;
 	struct rtentry rt;
 	struct sockaddr_in *addr;
+	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -225,6 +227,13 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 		return -1;
 	}
 
+	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
+				inet_ntoa(ipv4->nameserver), ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	system(cmd);
+
 	return 0;
 }
 
@@ -232,6 +241,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct sockaddr_in *addr;
+	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -267,6 +277,12 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 		return -1;
 	}
 
+	sprintf(cmd, "resolvconf -d %s", ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	system(cmd);
+
 	return 0;
 }
 

commit 047005ba15de74a21a39240d85ba37927db9cdb0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:51:19 2008 +0100

    Remove network interface helpers

diff --git a/plugins/80203.c b/plugins/80203.c
index 785c441e..65a22aa1 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -29,8 +29,6 @@
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
-#include "net.h"
-
 static int iface_probe(struct connman_iface *iface)
 {
 	printf("[802.03] probe interface index %d\n", iface->index);
@@ -47,33 +45,6 @@ static int iface_probe(struct connman_iface *iface)
 static void iface_remove(struct connman_iface *iface)
 {
 	printf("[802.03] remove interface index %d\n", iface->index);
-
-	__net_clear(iface->index);
-}
-
-static int iface_get_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
-{
-	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
-		return -1;
-
-	printf("[802.03] get address %s\n", inet_ntoa(ipv4->address));
-
-	return 0;
-}
-
-static int iface_set_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
-{
-	printf("[802.03] set address %s\n", inet_ntoa(ipv4->address));
-	printf("[802.03] set netmask %s\n", inet_ntoa(ipv4->netmask));
-	printf("[802.03] set gateway %s\n", inet_ntoa(ipv4->gateway));
-
-	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
-				&ipv4->gateway, &ipv4->broadcast,
-						&ipv4->nameserver);
-
-	return 0;
 }
 
 static struct connman_iface_driver iface_driver = {
@@ -81,8 +52,6 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80203",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
-	.get_ipv4	= iface_get_ipv4,
-	.set_ipv4	= iface_set_ipv4,
 };
 
 static int plugin_init(void)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 24e4433f..2f789ec3 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -4,12 +4,11 @@ plugindir = $(libdir)/connman/plugins
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
 			libconnman-dhclient.la
 
-libconnman_80203_la_SOURCES = 80203.c net.h net.c
+libconnman_80203_la_SOURCES = 80203.c
 
-libconnman_80211_la_SOURCES = 80211.c net.h net.c \
-				supplicant.h supplicant.c
+libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
-libconnman_dhclient_la_SOURCES = dhclient.c net.h net.c
+libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
 
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
diff --git a/plugins/net.c b/plugins/net.c
deleted file mode 100644
index 18927eed..00000000
--- a/plugins/net.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <net/if.h>
-
-#include "net.h"
-
-int __net_ifaddr(int ifindex, struct in_addr *addr)
-{
-	struct ifreq ifr;
-	int sk;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -errno;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = ifindex;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		close(sk);
-		return -errno;
-	}
-
-	if (ioctl(sk, SIOCGIFADDR, &ifr) < 0) {
-		close(sk);
-		return -errno;
-	}
-
-	close(sk);
-
-	*addr = ((struct sockaddr_in *) (&ifr.ifr_addr))->sin_addr;
-
-	return 0;
-}
-
-char *__net_ifname(int ifindex)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return NULL;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = ifindex;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return NULL;
-
-	return strdup(ifr.ifr_name);
-}
-
-void __net_free(void *ptr)
-{
-	if (ptr)
-		free(ptr);
-}
-
-int __net_clear(int ifindex)
-{
-	char *ifname, cmd[128];
-
-	ifname = __net_ifname(ifindex);
-	if (ifname == NULL)
-		return -1;
-
-	sprintf(cmd, "resolvconf -d %s", ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	sprintf(cmd, "ip addr flush dev %s", ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	__net_free(ifname);
-
-	return 0;
-}
-
-int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
-				struct in_addr *route, struct in_addr *bcast,
-						struct in_addr *namesrv)
-{
-	char *ifname, cmd[128], msk[32], brd[32];
-
-	ifname = __net_ifname(ifindex);
-	if (ifname == NULL)
-		return -1;
-
-	__net_clear(ifindex);
-
-	sprintf(msk, "%s", "24");
-	sprintf(brd, "%s", inet_ntoa(*bcast));
-	sprintf(cmd, "ip addr add %s/%s brd %s dev %s",
-				inet_ntoa(*addr), msk, brd, ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	sprintf(cmd, "ip route add default via %s dev %s",
-					inet_ntoa(*route), ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
-					inet_ntoa(*namesrv), ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	__net_free(ifname);
-
-	return 0;
-}
diff --git a/plugins/net.h b/plugins/net.h
deleted file mode 100644
index 83de416e..00000000
--- a/plugins/net.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#include <arpa/inet.h>
-
-int __net_ifaddr(int ifindex, struct in_addr *addr);
-char *__net_ifname(int ifindex);
-void __net_free(void *ptr);
-
-int __net_clear(int ifindex);
-int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
-				struct in_addr *route, struct in_addr *bcast,
-						struct in_addr *namesrv);

commit 8af2802c979ac2d63df1885c247a1cb387cab3bd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 09:11:41 2008 +0100

    Add callbacks for setting network name and passphrase

diff --git a/include/iface.h b/include/iface.h
index d6b67932..cc79a4d5 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -92,6 +92,11 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
+	void (*set_network) (struct connman_iface *iface,
+						const char *network);
+	void (*set_passphrase) (struct connman_iface *iface,
+						const char *passphrase);
+
 	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
 	void (*rtnl_wireless) (struct connman_iface *iface,
 					void *data, unsigned short len);
diff --git a/src/iface.c b/src/iface.c
index 53031f62..82fbdda9 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -328,9 +328,61 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *set_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+	const char *network;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->set_network)
+		driver->set_network(iface, network);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_passphrase(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+	const char *passphrase;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &passphrase,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->set_passphrase)
+		driver->set_passphrase(iface, passphrase);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static GDBusMethodTable iface_methods[] = {
-	{ "Enable", "", "", enable_iface },
-	{ "Scan",   "", "", scan_iface   },
+	{ "Enable",        "",  "", enable_iface   },
+	{ "Scan",          "",  "", scan_iface     },
+	{ "SetNetwork",    "s", "", set_network    },
+	{ "SetPassphrase", "s", "", set_passphrase },
 	{ },
 };
 

commit a53b633f9df38ad25b06b79e94e8fe21d1543c1b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 09:28:21 2008 +0100

    Add methods for setting 802.11 network name and passphrase

diff --git a/plugins/80211.c b/plugins/80211.c
index d4c63dcc..5a74de5a 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -59,6 +59,9 @@ struct station_data {
 struct iface_data {
 	char ifname[IFNAMSIZ];
 	GSList *stations;
+
+	gchar *network;
+	gchar *passphrase;
 };
 
 static struct station_data *create_station(struct iface_data *iface,
@@ -208,6 +211,9 @@ static void iface_remove(struct connman_iface *iface)
 
 	connman_iface_set_data(iface, NULL);
 
+	g_free(data->network);
+	g_free(data->passphrase);
+
 	free(data);
 }
 
@@ -259,15 +265,41 @@ static int iface_scan(struct connman_iface *iface)
 static int iface_connect(struct connman_iface *iface,
 					struct connman_network *network)
 {
-	printf("[802.11] connect interface index %d\n", iface->index);
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] connect %s\n", data->ifname);
 
 	__supplicant_start(iface);
 
-	__supplicant_connect(iface);
+	__supplicant_connect(iface, data->network, data->passphrase);
 
 	return 0;
 }
 
+static void iface_set_network(struct connman_iface *iface,
+						const char *network)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] set network %s\n", data->ifname);
+
+	g_free(data->network);
+
+	data->network = g_strdup(network);
+}
+
+static void iface_set_passphrase(struct connman_iface *iface,
+						const char *passphrase)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] set passphrase %s\n", data->ifname);
+
+	g_free(data->passphrase);
+
+	data->passphrase = g_strdup(passphrase);
+}
+
 static void iface_carrier(struct connman_iface *iface, int carrier)
 {
 	printf("[802.11] carrier %s\n", carrier ? "on" : "off");
@@ -480,6 +512,8 @@ static struct connman_iface_driver iface_driver = {
 	.activate	= iface_activate,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.set_network	= iface_set_network,
+	.set_passphrase	= iface_set_passphrase,
 	.rtnl_carrier	= iface_carrier,
 	.rtnl_wireless	= iface_wireless,
 };
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index ec0b7e73..1eb729bc 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -260,9 +260,11 @@ int __supplicant_stop(struct connman_iface *iface)
 	return 0;
 }
 
-int __supplicant_connect(struct connman_iface *iface)
+int __supplicant_connect(struct connman_iface *iface,
+				const char *network, const char *passphrase)
 {
 	struct supplicant_task *task;
+	char cmd[128];
 
 	task = find_task(iface->index);
 	if (task == NULL)
@@ -272,5 +274,21 @@ int __supplicant_connect(struct connman_iface *iface)
 
 	exec_cmd(task, "DISABLE_NETWORK 0");
 
+	sprintf(cmd, "SET_NETWORK 0 ssid \"%s\"", network);
+	exec_cmd(task, cmd);
+
+	if (passphrase && strlen(passphrase) > 0) {
+		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
+
+		sprintf(cmd, "SET_NETWORK 0 psk \"%s\"", passphrase);
+		exec_cmd(task, cmd);
+	} else {
+		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
+	}
+
+	exec_cmd(task, "ENABLE_NETWORK 0");
+
 	return 0;
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index ed753a88..9e5ebc67 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -24,4 +24,5 @@
 int __supplicant_start(struct connman_iface *iface);
 int __supplicant_stop(struct connman_iface *iface);
 
-int __supplicant_connect(struct connman_iface *iface);
+int __supplicant_connect(struct connman_iface *iface,
+				const char *network, const char *passphrase);

commit 986cc2bccd53c801a9c15a0e1367dd1d63f2ca30
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 22:56:58 2008 +0100

    Add preparation for Network Manager compatibility

diff --git a/src/connman.h b/src/connman.h
index fdb9fa83..ec7a1f3e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -28,13 +28,18 @@
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
-#define CONNMAN_MANAGER_PATH "/"
+#define CONNMAN_MANAGER_PATH       "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 
 #define CONNMAN_IFACE_BASEPATH  "/interface"
 #define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
 
-int __connman_manager_init(DBusConnection *conn);
+#define NM_SERVICE    "org.freedesktop.NetworkManager"
+#define NM_PATH       "/org/freedesktop/NetworkManager"
+#define NM_INTERFACE  NM_SERVICE
+#define NM_DEVICE     NM_SERVICE ".Devices"
+
+int __connman_manager_init(DBusConnection *conn, int compat);
 void __connman_manager_cleanup(void);
 
 #include <connman/plugin.h>
diff --git a/src/main.c b/src/main.c
index 14198cd4..1f30cb48 100644
--- a/src/main.c
+++ b/src/main.c
@@ -27,7 +27,9 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
+#include <syslog.h>
 #include <signal.h>
+#include <getopt.h>
 #include <sys/stat.h>
 
 #include <gdbus.h>
@@ -41,10 +43,63 @@ static void sig_term(int sig)
 	g_main_loop_quit(main_loop);
 }
 
+static void usage(void)
+{
+	printf("Connection Manager version %s\n\n", VERSION);
+
+	printf("Usage:\n"
+		"\tconnmand [options]\n"
+		"\n");
+
+	printf("Options:\n"
+		"\t-c, --compat         Enable Network Manager compatibility\n"
+		"\t-n, --nodaemon       Don't fork daemon to background\n"
+		"\t-h, --help           Display help\n"
+		"\n");
+}
+
+static struct option options[] = {
+	{ "nodaemon", 0, 0, 'n' },
+	{ "compat",   0, 0, 'c' },
+	{ "help",     0, 0, 'h' },
+	{ }
+};
+
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
 	struct sigaction sa;
+	int log_option = LOG_NDELAY | LOG_PID;
+	int opt, detach = 1, compat = 0;
+
+	while ((opt = getopt_long(argc, argv, "+nch", options, NULL)) != EOF) {
+		switch(opt) {
+		case 'n':
+			detach = 0;
+			break;
+		case 'c':
+			compat = 1;
+			break;
+		case 'h':
+		default:
+			usage();
+			exit(0);
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+	optind = 0;
+
+	if (detach) {
+		if (daemon(0, 0)) {
+			perror("Can't start daemon");
+			exit(1);
+		}
+	} else
+		log_option |= LOG_PERROR;
+
+	openlog("connmand", log_option, LOG_DAEMON);
 
 	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
@@ -57,7 +112,12 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 
-	__connman_manager_init(conn);
+	if (compat) {
+		if (g_dbus_request_name(conn, NM_SERVICE) == FALSE)
+			compat = 0;
+	}
+
+	__connman_manager_init(conn, compat);
 
 	__connman_plugin_init();
 
@@ -86,5 +146,7 @@ int main(int argc, char *argv[])
 
 	rmdir(STATEDIR);
 
+	closelog();
+
 	return 0;
 }
diff --git a/src/manager.c b/src/manager.c
index 1afecc88..d8c6a5a7 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -62,9 +62,139 @@ static GDBusSignalTable manager_signals[] = {
 	{ },
 };
 
+static DBusMessage *activate_device(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	DBG("device %s", path);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_wireless(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	dbus_bool_t enabled;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_BOOLEAN, &enabled,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *get_wireless(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	dbus_bool_t enabled = TRUE;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &enabled,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *do_sleep(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *do_wake(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+enum {
+	NM_STATE_UNKNOWN = 0,
+	NM_STATE_ASLEEP,
+	NM_STATE_CONNECTING,
+	NM_STATE_CONNECTED,
+	NM_STATE_DISCONNECTED
+};
+
+static DBusMessage *get_state(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	dbus_uint32_t state = NM_STATE_DISCONNECTED;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_UINT32, &state,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static GDBusMethodTable nm_methods[] = {
+	{ "getDevices",            "",  "ao", list_interfaces },
+	{ "setActiveDevice",       "o", "",   activate_device },
+	{ "setWirelessEnabled",    "b", "",   set_wireless    },
+	{ "getWirelessEnabled",    "",  "b",  get_wireless    },
+	{ "sleep",                 "",  "",   do_sleep        },
+	{ "wake",                  "",  "",   do_wake         },
+	{ "state",                 "",  "u",  get_state       },
+	{ },
+};
+
 static DBusConnection *connection = NULL;
+static int nm_compat = 0;
 
-int __connman_manager_init(DBusConnection *conn)
+int __connman_manager_init(DBusConnection *conn, int compat)
 {
 	DBG("conn %p", conn);
 
@@ -79,6 +209,15 @@ int __connman_manager_init(DBusConnection *conn)
 						manager_methods,
 						manager_signals, NULL);
 
+	if (compat) {
+		g_dbus_register_object(connection, NM_PATH, NULL, NULL);
+
+		g_dbus_register_interface(connection, NM_PATH, NM_INTERFACE,
+						nm_methods, NULL, NULL);
+
+		nm_compat = 1;
+	}
+
 	return 0;
 }
 
@@ -86,6 +225,12 @@ void __connman_manager_cleanup(void)
 {
 	DBG("conn %p", connection);
 
+	if (nm_compat) {
+		g_dbus_unregister_interface(connection, NM_PATH, NM_INTERFACE);
+
+		g_dbus_unregister_object(connection, NM_PATH);
+	}
+
 	g_dbus_unregister_interface(connection, CONNMAN_MANAGER_PATH,
 						CONNMAN_MANAGER_INTERFACE);
 

commit e0979df838ec942c23d8a5bad23a1e7f87d666ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 4 02:37:34 2008 +0100

    Add interface properties for device details

diff --git a/include/iface.h b/include/iface.h
index cc79a4d5..a916cd16 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -75,6 +75,12 @@ struct connman_iface {
 
 	struct connman_iface_driver *driver;
 	void *driver_data;
+
+	struct {
+		char *driver;
+		char *vendor;
+		char *product;
+	} device;
 };
 
 struct connman_iface_driver {
@@ -92,6 +98,8 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
+	const char * (*get_address) (struct connman_iface *iface);
+
 	void (*set_network) (struct connman_iface *iface,
 						const char *network);
 	void (*set_passphrase) (struct connman_iface *iface,
diff --git a/plugins/80211.c b/plugins/80211.c
index 5a74de5a..5aebe964 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -58,6 +58,7 @@ struct station_data {
 
 struct iface_data {
 	char ifname[IFNAMSIZ];
+	char ifaddr[18];
 	GSList *stations;
 
 	gchar *network;
@@ -163,6 +164,7 @@ static int iface_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
 	struct ifreq ifr;
+	struct ether_addr *eth;
 	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
@@ -174,6 +176,9 @@ static int iface_probe(struct connman_iface *iface)
 
 	err = ioctl(sk, SIOCGIFNAME, &ifr);
 
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
 	close(sk);
 
 	if (err < 0)
@@ -189,6 +194,15 @@ static int iface_probe(struct connman_iface *iface)
 
 	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
 
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	sprintf(data->ifaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
@@ -276,6 +290,15 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
+static const char *iface_get_address(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] get address %s\n", data->ifname);
+
+	return data->ifaddr;
+}
+
 static void iface_set_network(struct connman_iface *iface,
 						const char *network)
 {
@@ -512,6 +535,7 @@ static struct connman_iface_driver iface_driver = {
 	.activate	= iface_activate,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.get_address	= iface_get_address,
 	.set_network	= iface_set_network,
 	.set_passphrase	= iface_set_passphrase,
 	.rtnl_carrier	= iface_carrier,
diff --git a/src/iface.c b/src/iface.c
index 82fbdda9..b08fdb8f 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -417,8 +417,80 @@ static dbus_bool_t get_type(DBusConnection *conn,
 	return TRUE;
 }
 
+static dbus_bool_t get_address(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+	const char *address;
+
+	DBG("iface %p", iface);
+
+	if (!iface->driver->get_address)
+		return FALSE;
+
+	address = iface->driver->get_address(iface);
+	if (address == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &address);
+
+	return TRUE;
+}
+
+static dbus_bool_t get_driver(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->device.driver == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+						&iface->device.driver);
+
+	return TRUE;
+}
+
+static dbus_bool_t get_vendor(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->device.vendor == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+						&iface->device.vendor);
+
+	return TRUE;
+}
+
+static dbus_bool_t get_product(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->device.product == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+						&iface->device.product);
+
+	return TRUE;
+}
+
 static GDBusPropertyTable iface_properties[] = {
-	{ "Type", "s", get_type },
+	{ "Type",    "s", get_type    },
+	{ "Address", "s", get_address },
+	{ "Driver",  "s", get_driver  },
+	{ "Vendor",  "s", get_vendor  },
+	{ "Product", "s", get_product },
 	{ },
 };
 
@@ -436,9 +508,44 @@ static void device_free(void *data)
 	g_free(iface->path);
 	g_free(iface->udi);
 	g_free(iface->sysfs);
+	g_free(iface->device.driver);
+	g_free(iface->device.vendor);
+	g_free(iface->device.product);
 	g_free(iface);
 }
 
+static void detect_device_info(LibHalContext *ctx, struct connman_iface *iface)
+{
+	char *parent, *subsys, *value;
+
+	parent = libhal_device_get_property_string(ctx, iface->udi,
+						"info.parent", NULL);
+
+	subsys = libhal_device_get_property_string(ctx, iface->udi,
+						"linux.subsystem", NULL);
+
+	value = libhal_device_get_property_string(ctx, iface->udi,
+						"info.linux.driver", NULL);
+	if (value == NULL) {
+		value = libhal_device_get_property_string(ctx, parent,
+						"info.linux.driver", NULL);
+		if (value != NULL)
+			iface->device.driver = g_strdup(value);
+	}
+
+	if (strcmp(subsys, "net") == 0) {
+		value = libhal_device_get_property_string(ctx, parent,
+							"info.vendor", NULL);
+		if (value != NULL)
+			iface->device.vendor = g_strdup(value);
+
+		value = libhal_device_get_property_string(ctx, parent,
+							"info.product", NULL);
+		if (value != NULL)
+			iface->device.product = g_strdup(value);
+	}
+}
+
 static int probe_device(LibHalContext *ctx,
 			struct connman_iface_driver *driver, const char *udi)
 {
@@ -469,6 +576,8 @@ static int probe_device(LibHalContext *ctx,
 	if (sysfs != NULL)
 		iface->sysfs = g_strdup(sysfs);
 
+	detect_device_info(ctx, iface);
+
 	iface->index = -1;
 
 	if (g_str_has_prefix(driver->capability, "net") == TRUE)

commit 77b9f324261f3482b3c0bc89c1d5c734a624a590
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:30:16 2008 +0100

    Add method and signal for master state

diff --git a/src/manager.c b/src/manager.c
index d8c6a5a7..b11d805e 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,6 +27,8 @@
 
 #include "connman.h"
 
+static const char *master_state = "unknown";
+
 static DBusMessage *list_interfaces(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -51,14 +53,33 @@ static DBusMessage *list_interfaces(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *get_state(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &master_state,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static GDBusMethodTable manager_methods[] = {
 	{ "ListInterfaces", "", "ao", list_interfaces },
+	{ "GetState",       "", "s",  get_state       },
 	{ },
 };
 
 static GDBusSignalTable manager_signals[] = {
 	{ "InterfaceAdded",   "o" },
 	{ "InterfaceRemoved", "o" },
+	{ "StateChanged",     "s" },
 	{ },
 };
 
@@ -162,7 +183,7 @@ enum {
 	NM_STATE_DISCONNECTED
 };
 
-static DBusMessage *get_state(DBusConnection *conn,
+static DBusMessage *do_state(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
@@ -187,7 +208,7 @@ static GDBusMethodTable nm_methods[] = {
 	{ "getWirelessEnabled",    "",  "b",  get_wireless    },
 	{ "sleep",                 "",  "",   do_sleep        },
 	{ "wake",                  "",  "",   do_wake         },
-	{ "state",                 "",  "u",  get_state       },
+	{ "state",                 "",  "u",  do_state        },
 	{ },
 };
 

commit 82907b261ddc17ea7c4b838d927a6c9c9b00e6a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:34:25 2008 +0100

    Add creation of the storage directory

diff --git a/src/Makefile.am b/src/Makefile.am
index b78d4b38..66d2f1c8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,6 +11,8 @@ connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
 statedir = $(localstatedir)/run/connman
 
+storagedir = $(localstatedir)/lib/connman
+
 if MAINTAINER_MODE
 plugindir = $(abs_top_srcdir)/plugins
 else
@@ -18,7 +20,9 @@ plugindir = $(libdir)/connman/plugins
 endif
 
 AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
-		-DSTATEDIR=\""$(statedir)"\" -DPLUGINDIR=\""$(plugindir)"\"
+			-DSTATEDIR=\""$(statedir)"\" \
+			-DSTORAGEDIR=\""$(storagedir)\"" \
+			-DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/src/main.c b/src/main.c
index 1f30cb48..8de7fbed 100644
--- a/src/main.c
+++ b/src/main.c
@@ -104,6 +104,9 @@ int main(int argc, char *argv[])
 	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
 
+	mkdir(STORAGEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
+			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+
 	main_loop = g_main_loop_new(NULL, FALSE);
 
 	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
@@ -144,6 +147,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_unref(main_loop);
 
+	rmdir(STORAGEDIR);
+
 	rmdir(STATEDIR);
 
 	closelog();

commit d66283df5765240c23665e9825539af88b7c8167
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:46:58 2008 +0100

    Remove interface property callbacks

diff --git a/src/iface.c b/src/iface.c
index b08fdb8f..9c9d7350 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -386,114 +386,6 @@ static GDBusMethodTable iface_methods[] = {
 	{ },
 };
 
-static dbus_bool_t get_type(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-	const char *type;
-
-	DBG("iface %p", iface);
-
-	switch (iface->type) {
-	case CONNMAN_IFACE_TYPE_80203:
-		type = "80203";
-		break;
-	case CONNMAN_IFACE_TYPE_80211:
-		type = "80211";
-		break;
-	case CONNMAN_IFACE_TYPE_WIMAX:
-		type = "wimax";
-		break;
-	case CONNMAN_IFACE_TYPE_BLUETOOTH:
-		type = "bluetooth";
-		break;
-	default:
-		type = "unknown";
-		break;
-	}
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &type);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_address(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-	const char *address;
-
-	DBG("iface %p", iface);
-
-	if (!iface->driver->get_address)
-		return FALSE;
-
-	address = iface->driver->get_address(iface);
-	if (address == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &address);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_driver(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	if (iface->device.driver == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-						&iface->device.driver);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_vendor(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	if (iface->device.vendor == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-						&iface->device.vendor);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_product(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	if (iface->device.product == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-						&iface->device.product);
-
-	return TRUE;
-}
-
-static GDBusPropertyTable iface_properties[] = {
-	{ "Type",    "s", get_type    },
-	{ "Address", "s", get_address },
-	{ "Driver",  "s", get_driver  },
-	{ "Vendor",  "s", get_vendor  },
-	{ "Product", "s", get_product },
-	{ },
-};
-
 static void device_free(void *data)
 {
 	struct connman_iface *iface = data;
@@ -615,7 +507,7 @@ static int probe_device(LibHalContext *ctx,
 
 	g_dbus_register_interface(conn, iface->path,
 					CONNMAN_IFACE_INTERFACE,
-					iface_methods, NULL, iface_properties);
+					iface_methods, NULL, NULL);
 
 	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
 					CONNMAN_MANAGER_INTERFACE,

commit ca2197bc2724ed4534fc052d99d8815845d9315e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:55:49 2008 +0100

    Remove callback for getting the hardware address

diff --git a/include/iface.h b/include/iface.h
index a916cd16..ed85984b 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -98,8 +98,6 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
-	const char * (*get_address) (struct connman_iface *iface);
-
 	void (*set_network) (struct connman_iface *iface,
 						const char *network);
 	void (*set_passphrase) (struct connman_iface *iface,
diff --git a/plugins/80211.c b/plugins/80211.c
index 5aebe964..5a74de5a 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -58,7 +58,6 @@ struct station_data {
 
 struct iface_data {
 	char ifname[IFNAMSIZ];
-	char ifaddr[18];
 	GSList *stations;
 
 	gchar *network;
@@ -164,7 +163,6 @@ static int iface_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
 	struct ifreq ifr;
-	struct ether_addr *eth;
 	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
@@ -176,9 +174,6 @@ static int iface_probe(struct connman_iface *iface)
 
 	err = ioctl(sk, SIOCGIFNAME, &ifr);
 
-	if (err == 0)
-		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
-
 	close(sk);
 
 	if (err < 0)
@@ -194,15 +189,6 @@ static int iface_probe(struct connman_iface *iface)
 
 	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
 
-	eth = (void *) &ifr.ifr_hwaddr.sa_data;
-	sprintf(data->ifaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
@@ -290,15 +276,6 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
-static const char *iface_get_address(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	printf("[802.11] get address %s\n", data->ifname);
-
-	return data->ifaddr;
-}
-
 static void iface_set_network(struct connman_iface *iface,
 						const char *network)
 {
@@ -535,7 +512,6 @@ static struct connman_iface_driver iface_driver = {
 	.activate	= iface_activate,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
-	.get_address	= iface_get_address,
 	.set_network	= iface_set_network,
 	.set_passphrase	= iface_set_passphrase,
 	.rtnl_carrier	= iface_carrier,

commit 3dce61ceefbe49774724917d1e61ad1d41640f52
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 11:08:07 2008 +0100

    Update interface constants and definitions

diff --git a/include/iface.h b/include/iface.h
index ed85984b..4e2a30c0 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -33,7 +33,8 @@ enum connman_iface_type {
 	CONNMAN_IFACE_TYPE_80203     = 1,
 	CONNMAN_IFACE_TYPE_80211     = 2,
 	CONNMAN_IFACE_TYPE_WIMAX     = 3,
-	CONNMAN_IFACE_TYPE_BLUETOOTH = 4,
+	CONNMAN_IFACE_TYPE_MODEM     = 4,
+	CONNMAN_IFACE_TYPE_BLUETOOTH = 5,
 };
 
 enum connman_iface_flags {
@@ -45,12 +46,31 @@ enum connman_iface_flags {
 
 enum connman_iface_state {
 	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
-	CONNMAN_IFACE_STATE_ACTIVE    = 1,
-	CONNMAN_IFACE_STATE_CONNECTED = 2,
-	CONNMAN_IFACE_STATE_READY     = 3,
+	CONNMAN_IFACE_STATE_OFF       = 1,
+	CONNMAN_IFACE_STATE_ENABLED   = 2,
+	CONNMAN_IFACE_STATE_CONNECT   = 3,
+	CONNMAN_IFACE_STATE_CONFIG    = 4,
+	CONNMAN_IFACE_STATE_CARRIER   = 5,
+	CONNMAN_IFACE_STATE_READY     = 6,
+	CONNMAN_IFACE_STATE_SHUTDOWN  = 7,
+};
+
+enum connman_iface_policy {
+	CONNMAN_IFACE_POLICY_UNKNOWN = 0,
+	CONNMAN_IFACE_POLICY_OFF     = 1,
+	CONNMAN_IFACE_POLICY_IGNORE  = 2,
+	CONNMAN_IFACE_POLICY_AUTO    = 3,
+};
+
+enum connman_ipv4_method {
+	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
+	CONNMAN_IPV4_METHOD_OFF     = 1,
+	CONNMAN_IPV4_METHOD_STATIC  = 2,
+	CONNMAN_IPV4_METHOD_DHCP    = 3,
 };
 
 struct connman_ipv4 {
+	enum connman_ipv4_method method;
 	struct in_addr address;
 	struct in_addr netmask;
 	struct in_addr gateway;
@@ -66,11 +86,13 @@ struct connman_iface {
 	char *path;
 	char *udi;
 	char *sysfs;
+	char *identifier;
 	int index;
 	int carrier;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
+	enum connman_iface_policy policy;
 	struct connman_ipv4 ipv4;
 
 	struct connman_iface_driver *driver;
diff --git a/plugins/80211.c b/plugins/80211.c
index 5a74de5a..558dd971 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -223,7 +223,18 @@ static int iface_activate(struct connman_iface *iface)
 
 	printf("[802.11] activate %s\n", data->ifname);
 
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_ENABLED);
+
+	return 0;
+}
+
+static int iface_shutdown(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] shutdown %s\n", data->ifname);
+
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_SHUTDOWN);
 
 	return 0;
 }
@@ -510,6 +521,7 @@ static struct connman_iface_driver iface_driver = {
 	.probe		= iface_probe,
 	.remove		= iface_remove,
 	.activate	= iface_activate,
+	.shutdown	= iface_shutdown,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
 	.set_network	= iface_set_network,
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 1eb729bc..4787f435 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -100,7 +100,7 @@ static gboolean control_event(GIOChannel *chan,
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
 		printf("[SUPPLICANT] connected\n");
 		connman_iface_update(task->iface,
-					CONNMAN_IFACE_STATE_CONNECTED);
+					CONNMAN_IFACE_STATE_CARRIER);
 	}
 
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
diff --git a/src/iface.c b/src/iface.c
index 9c9d7350..fce6dd0f 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -97,14 +97,14 @@ int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state)
 {
 	switch (state) {
-	case CONNMAN_IFACE_STATE_ACTIVE:
+	case CONNMAN_IFACE_STATE_ENABLED:
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
 		}
 		break;
 
-	case CONNMAN_IFACE_STATE_CONNECTED:
+	case CONNMAN_IFACE_STATE_CARRIER:
 		__connman_dhcp_request(iface);
 		break;
 

commit 5c1b3864d4c0be14a181594bba6d871ea84b8985
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 11:21:39 2008 +0100

    Add string conversion helper functions

diff --git a/src/Makefile.am b/src/Makefile.am
index 66d2f1c8..cd80c8d2 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,8 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h manager.c plugin.c iface.c rtnl.c dhcp.c
+connmand_SOURCES = main.c connman.h manager.c plugin.c \
+			iface.c iface-helper.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index ec7a1f3e..7f789fe8 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -55,6 +55,14 @@ void __connman_iface_cleanup(void);
 struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
 
+const char *__connman_iface_type2string(enum connman_iface_type type);
+const char *__connman_iface_state2string(enum connman_iface_state state);
+const char *__connman_iface_policy2string(enum connman_iface_policy policy);
+enum connman_iface_policy __connman_iface_string2policy(const char *policy);
+
+const char *__connman_ipv4_method2string(enum connman_ipv4_method method);
+enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/iface-helper.c b/src/iface-helper.c
new file mode 100644
index 00000000..4fe4b649
--- /dev/null
+++ b/src/iface-helper.c
@@ -0,0 +1,128 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+
+#include "connman.h"
+
+const char *__connman_iface_type2string(enum connman_iface_type type)
+{
+	switch (type) {
+	case CONNMAN_IFACE_TYPE_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IFACE_TYPE_80203:
+		return "80203";
+	case CONNMAN_IFACE_TYPE_80211:
+		return "80211";
+	case CONNMAN_IFACE_TYPE_WIMAX:
+		return "wimax";
+	case CONNMAN_IFACE_TYPE_MODEM:
+		return "modem";
+	case CONNMAN_IFACE_TYPE_BLUETOOTH:
+		return "bluetooth";
+	}
+
+	return "unknown";
+}
+
+const char *__connman_iface_state2string(enum connman_iface_state state)
+{
+	switch (state) {
+	case CONNMAN_IFACE_STATE_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IFACE_STATE_OFF:
+		return "off";
+	case CONNMAN_IFACE_STATE_ENABLED:
+		return "enabled";
+	case CONNMAN_IFACE_STATE_CONNECT:
+		return "connect";
+	case CONNMAN_IFACE_STATE_CONFIG:
+		return "config";
+	case CONNMAN_IFACE_STATE_CARRIER:
+		return "carrier";
+	case CONNMAN_IFACE_STATE_READY:
+		return "ready";
+	case CONNMAN_IFACE_STATE_SHUTDOWN:
+		return "shutdown";
+	}
+
+	return "unknown";
+}
+
+const char *__connman_iface_policy2string(enum connman_iface_policy policy)
+{
+	switch (policy) {
+	case CONNMAN_IFACE_POLICY_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IFACE_POLICY_OFF:
+		return "off";
+	case CONNMAN_IFACE_POLICY_IGNORE:
+		return "ignore";
+	case CONNMAN_IFACE_POLICY_AUTO:
+		return "auto";
+	}
+
+	return "unknown";
+}
+
+enum connman_iface_policy __connman_iface_string2policy(const char *policy)
+{
+	if (strcasecmp(policy, "off") == 0)
+		return CONNMAN_IFACE_POLICY_OFF;
+	else if (strcasecmp(policy, "ignore") == 0)
+		return CONNMAN_IFACE_POLICY_IGNORE;
+	else if (strcasecmp(policy, "auto") == 0)
+		return CONNMAN_IFACE_POLICY_AUTO;
+	else
+		return CONNMAN_IFACE_POLICY_UNKNOWN;
+}
+
+const char *__connman_ipv4_method2string(enum connman_ipv4_method method)
+{
+	switch (method) {
+	case CONNMAN_IPV4_METHOD_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IPV4_METHOD_OFF:
+		return "off";
+	case CONNMAN_IPV4_METHOD_STATIC:
+		return "static";
+	case CONNMAN_IPV4_METHOD_DHCP:
+		return "dhcp";
+	}
+
+	return "unknown";
+}
+
+enum connman_ipv4_method __connman_ipv4_string2method(const char *method)
+{
+	if (strcasecmp(method, "off") == 0)
+		return CONNMAN_IPV4_METHOD_OFF;
+	else if (strcasecmp(method, "static") == 0)
+		return CONNMAN_IPV4_METHOD_STATIC;
+	else if (strcasecmp(method, "dhcp") == 0)
+		return CONNMAN_IPV4_METHOD_DHCP;
+	else
+		return CONNMAN_IPV4_METHOD_UNKNOWN;
+}

commit f4292c41c31dc7d0bb9fb3ed6061b6e9ef6ac484
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 11:41:12 2008 +0100

    Add new method and signal implementation

diff --git a/src/iface.c b/src/iface.c
index fce6dd0f..1c0c8823 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -45,6 +45,8 @@
 
 #include "connman.h"
 
+static DBusConnection *connection = NULL;
+
 static GSList *drivers = NULL;
 
 int connman_iface_register(struct connman_iface_driver *driver)
@@ -96,8 +98,11 @@ void __connman_iface_list(DBusMessageIter *iter)
 int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state)
 {
+	const char *str = NULL;
+
 	switch (state) {
 	case CONNMAN_IFACE_STATE_ENABLED:
+		str = "enabled";
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
@@ -105,15 +110,29 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
+		str = "carrier";
 		__connman_dhcp_request(iface);
 		break;
 
+	case CONNMAN_IFACE_STATE_READY:
+		str = "ready";
+		break;
+
+	case CONNMAN_IFACE_STATE_SHUTDOWN:
+		break;
+
 	default:
 		break;
 	}
 
 	iface->state = state;
 
+	if (str != NULL) {
+		g_dbus_emit_signal(connection, iface->path,
+				CONNMAN_IFACE_INTERFACE, "StateChanged",
+				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
+	}
+
 	return 0;
 }
 
@@ -286,7 +305,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 	return 0;
 }
 
-static DBusMessage *enable_iface(DBusConnection *conn,
+static DBusMessage *scan_iface(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
@@ -299,20 +318,52 @@ static DBusMessage *enable_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->activate)
-		driver->activate(iface);
+	if (driver->scan)
+		driver->scan(iface);
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	return reply;
 }
 
-static DBusMessage *scan_iface(DBusConnection *conn,
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
 	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -320,58 +371,332 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->scan)
-		driver->scan(iface);
+	dbus_message_iter_init_append(reply, &array);
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	str = __connman_iface_type2string(iface->type);
+	append_entry(&dict, "Type", DBUS_TYPE_STRING, &str);
+
+	str = __connman_iface_state2string(iface->state);
+	append_entry(&dict, "State", DBUS_TYPE_STRING, &str);
+
+	if (iface->type == CONNMAN_IFACE_TYPE_80211) {
+		dbus_uint16_t signal = 75;
+		append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
+	}
+
+	str = __connman_iface_policy2string(iface->policy);
+	append_entry(&dict, "Policy", DBUS_TYPE_STRING, &str);
+
+	if (iface->device.driver != NULL)
+		append_entry(&dict, "Driver",
+				DBUS_TYPE_STRING, &iface->device.driver);
+
+	if (iface->device.vendor != NULL)
+		append_entry(&dict, "Vendor",
+				DBUS_TYPE_STRING, &iface->device.vendor);
+
+	if (iface->device.product != NULL)
+		append_entry(&dict, "Product",
+				DBUS_TYPE_STRING, &iface->device.product);
+
+	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
 }
 
-static DBusMessage *set_network(DBusConnection *conn,
+static DBusMessage *get_state(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
 	DBusMessage *reply;
-	const char *network;
+	const char *state;
 
 	DBG("conn %p", conn);
 
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	state = __connman_iface_state2string(iface->state);
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &state,
 							DBUS_TYPE_INVALID);
 
+	return reply;
+}
+
+static DBusMessage *get_signal(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	dbus_uint16_t signal;
+
+	DBG("conn %p", conn);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->set_network)
-		driver->set_network(iface, network);
+	if (iface->type == CONNMAN_IFACE_TYPE_80211)
+		signal = 75;
+	else
+		signal = 0;
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+	dbus_message_append_args(reply, DBUS_TYPE_UINT16, &signal,
+							DBUS_TYPE_INVALID);
 
 	return reply;
 }
 
-static DBusMessage *set_passphrase(DBusConnection *conn,
+static DBusMessage *get_policy(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	const char *policy;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	policy = __connman_iface_policy2string(iface->policy);
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &policy,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_policy(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
 	DBusMessage *reply;
-	const char *passphrase;
+	enum connman_iface_policy new_policy;
+	const char *path, *policy;
 
 	DBG("conn %p", conn);
 
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &passphrase,
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &policy,
 							DBUS_TYPE_INVALID);
 
+	new_policy = __connman_iface_string2policy(policy);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	if (iface->policy != new_policy) {
+		path = dbus_message_get_path(msg);
+
+		iface->policy = new_policy;
+
+		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
+			if (iface->driver->activate)
+				iface->driver->activate(iface);
+		} else {
+			if (iface->driver->shutdown)
+				iface->driver->shutdown(iface);
+		}
+
+		g_dbus_emit_signal(conn, path, CONNMAN_IFACE_INTERFACE,
+				"PolicyChanged", DBUS_TYPE_STRING, &policy,
+							DBUS_TYPE_INVALID);
+	}
+
+	return reply;
+}
+
+static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
+{
+	DBusMessageIter array, dict;
+	const char *str;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	str = __connman_ipv4_method2string(iface->ipv4.method);
+	append_entry(&dict, "Method", DBUS_TYPE_STRING, &str);
+
+	if (iface->ipv4.address.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.address);
+		append_entry(&dict, "Address", DBUS_TYPE_STRING, &str);
+	}
+
+	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.netmask);
+		append_entry(&dict, "Netmask", DBUS_TYPE_STRING, &str);
+	}
+
+	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.gateway);
+		append_entry(&dict, "Gateway", DBUS_TYPE_STRING, &str);
+	}
+
+	dbus_message_iter_close_container(&array, &dict);
+}
+
+static DBusMessage *get_ipv4(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->set_passphrase)
-		driver->set_passphrase(iface, passphrase);
+	append_ipv4(reply, iface);
+
+	return reply;
+}
+
+static DBusMessage *set_ipv4(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply, *signal;
+	DBusMessageIter array, dict;
+	const char *path;
+	gboolean changed = FALSE;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+		enum connman_ipv4_method method;
+		in_addr_t addr;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "Method") == 0) {
+			method = __connman_ipv4_string2method(val);
+			if (iface->ipv4.method != method) {
+				iface->ipv4.method = method;
+				changed = TRUE;
+			}
+		}
+
+		if (g_strcasecmp(key, "Address") == 0) {
+			addr = inet_addr(val);
+			if (iface->ipv4.address.s_addr != addr) {
+				iface->ipv4.address.s_addr = addr;
+				changed = TRUE;
+			}
+		}
+
+		if (g_strcasecmp(key, "Netmask") == 0) {
+			addr = inet_addr(val);
+			if (iface->ipv4.netmask.s_addr != addr) {
+				iface->ipv4.netmask.s_addr = addr;
+				changed = TRUE;
+			}
+		}
+
+		if (g_strcasecmp(key, "Gateway") == 0) {
+			addr = inet_addr(val);
+			if (iface->ipv4.gateway.s_addr != addr) {
+				iface->ipv4.gateway.s_addr = addr;
+				changed = TRUE;
+			}
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	path = dbus_message_get_path(msg);
+
+	if (changed == TRUE) {
+		signal = dbus_message_new_signal(path,
+				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
+		if (signal != NULL) {
+			append_ipv4(signal, iface);
+			dbus_connection_send(conn, signal, NULL);
+			dbus_message_unref(signal);
+		}
+	}
+
+	return reply;
+}
+
+static DBusMessage *set_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "ESSID") == 0) {
+			if (iface->driver->set_network)
+				iface->driver->set_network(iface, val);
+		}
+
+		if (g_strcasecmp(key, "PSK") == 0) {
+			if (iface->driver->set_network)
+				iface->driver->set_passphrase(iface, val);
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
@@ -379,10 +704,24 @@ static DBusMessage *set_passphrase(DBusConnection *conn,
 }
 
 static GDBusMethodTable iface_methods[] = {
-	{ "Enable",        "",  "", enable_iface   },
-	{ "Scan",          "",  "", scan_iface     },
-	{ "SetNetwork",    "s", "", set_network    },
-	{ "SetPassphrase", "s", "", set_passphrase },
+	{ "Scan",          "",      "",      scan_iface     },
+	{ "GetProperties", "",      "a{sv}", get_properties },
+	{ "GetState",      "",      "s",     get_state      },
+	{ "GetSignal",     "",      "q",     get_signal     },
+	{ "GetPolicy",     "",      "s",     get_policy     },
+	{ "SetPolicy",     "s",     "",      set_policy     },
+	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
+	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
+	{ "SetNetwork",    "a{sv}", "",      set_network    },
+	{ },
+};
+
+static GDBusSignalTable iface_signals[] = {
+	{ "StateChanged",   "s"     },
+	{ "SignalChanged",  "q"     },
+	{ "PolicyChanged",  "s"     },
+	{ "IPv4Changed",    "a{sv}" },
+	{ "NetworkChanged", "a{sv}" },
 	{ },
 };
 
@@ -400,6 +739,7 @@ static void device_free(void *data)
 	g_free(iface->path);
 	g_free(iface->udi);
 	g_free(iface->sysfs);
+	g_free(iface->identifier);
 	g_free(iface->device.driver);
 	g_free(iface->device.vendor);
 	g_free(iface->device.product);
@@ -461,7 +801,7 @@ static int probe_device(LibHalContext *ctx,
 
 	iface->udi = g_strdup(udi);
 
-	DBG("path %s", iface->path);
+	DBG("iface %p path %s", iface, iface->path);
 
 	sysfs = libhal_device_get_property_string(ctx, udi,
 						"linux.sysfs_path", NULL);
@@ -479,8 +819,7 @@ static int probe_device(LibHalContext *ctx,
 	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
 	iface->flags = 0;
 	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
-
-	DBG("iface %p", iface);
+	iface->policy = CONNMAN_IFACE_POLICY_UNKNOWN;
 
 	err = driver->probe(iface);
 	if (err < 0) {
@@ -507,7 +846,9 @@ static int probe_device(LibHalContext *ctx,
 
 	g_dbus_register_interface(conn, iface->path,
 					CONNMAN_IFACE_INTERFACE,
-					iface_methods, NULL, NULL);
+					iface_methods, iface_signals, NULL);
+
+	DBG("iface %p identifier %s", iface, iface->identifier);
 
 	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
 					CONNMAN_MANAGER_INTERFACE,
@@ -515,6 +856,11 @@ static int probe_device(LibHalContext *ctx,
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
+	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
+		if (driver->activate)
+			driver->activate(iface);
+	}
+
 	return 0;
 }
 
@@ -677,7 +1023,6 @@ static void hal_cleanup(void *data)
 	hal_ctx = NULL;
 }
 
-static DBusConnection *connection = NULL;
 static guint hal_watch = 0;
 
 int __connman_iface_init(DBusConnection *conn)

commit 588882dd73aa475dd262d117c71dcabcde5e6d9c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 12:08:23 2008 +0100

    Add generic handling for hardware addresses and setup

diff --git a/src/Makefile.am b/src/Makefile.am
index cd80c8d2..e207525b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -6,7 +6,7 @@ dbus_DATA = connman.conf
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h manager.c plugin.c \
-			iface.c iface-helper.c rtnl.c dhcp.c
+			iface.c iface-helper.c iface-inet.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 7f789fe8..98d8ea80 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -55,6 +55,9 @@ void __connman_iface_cleanup(void);
 struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
 
+int __connman_iface_create_identifier(struct connman_iface *iface);
+int __connman_iface_init_via_inet(struct connman_iface *iface);
+
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
 const char *__connman_iface_policy2string(enum connman_iface_policy policy);
diff --git a/src/iface-inet.c b/src/iface-inet.c
new file mode 100644
index 00000000..664d2980
--- /dev/null
+++ b/src/iface-inet.c
@@ -0,0 +1,110 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <net/ethernet.h>
+
+#include "connman.h"
+
+int __connman_iface_create_identifier(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	struct ether_addr *eth;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	iface->identifier = malloc(18);
+	if (iface->identifier == NULL)
+		return -ENOMEM;
+
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	sprintf(iface->identifier, "%02X-%02X-%02X-%02X-%02X-%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
+	return 0;
+}
+
+int __connman_iface_init_via_inet(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFFLAGS, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	if (ifr.ifr_flags & IFF_UP)
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+	else
+		iface->state = CONNMAN_IFACE_STATE_OFF;
+
+	if (ifr.ifr_flags & IFF_RUNNING)
+		iface->state = CONNMAN_IFACE_STATE_CARRIER;
+
+	return 0;
+}
diff --git a/src/iface.c b/src/iface.c
index 1c0c8823..c9d25951 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -827,6 +827,10 @@ static int probe_device(LibHalContext *ctx,
 		return -1;
 	}
 
+	__connman_iface_create_identifier(iface);
+
+	__connman_iface_init_via_inet(iface);
+
 	iface->driver = driver;
 
 	conn = libhal_ctx_get_dbus_connection(ctx);

commit 8efebe4ff9af283939fc4587cc3f36c4599c964a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 12:27:05 2008 +0100

    Add support for storing interface settings

diff --git a/src/Makefile.am b/src/Makefile.am
index e207525b..4da752e5 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -6,7 +6,8 @@ dbus_DATA = connman.conf
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h manager.c plugin.c \
-			iface.c iface-helper.c iface-inet.c rtnl.c dhcp.c
+			iface.c iface-storage.c iface-helper.c \
+					iface-inet.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 98d8ea80..26931ff5 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -58,6 +58,9 @@ void __connman_iface_list(DBusMessageIter *iter);
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
 
+int __connman_iface_load(struct connman_iface *iface);
+int __connman_iface_store(struct connman_iface *iface);
+
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
 const char *__connman_iface_policy2string(enum connman_iface_policy policy);
diff --git a/src/iface-storage.c b/src/iface-storage.c
new file mode 100644
index 00000000..b7c84c38
--- /dev/null
+++ b/src/iface-storage.c
@@ -0,0 +1,192 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <arpa/inet.h>
+
+#include <glib.h>
+
+#include "connman.h"
+
+int __connman_iface_load(struct connman_iface *iface)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *str;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return -EIO;
+
+	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
+		goto done;
+
+	if (g_key_file_has_group(keyfile, iface->identifier) == FALSE)
+		goto done;
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"Policy", NULL);
+	if (str != NULL) {
+		iface->policy = __connman_iface_string2policy(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Method", NULL);
+	if (str != NULL) {
+		iface->ipv4.method = __connman_ipv4_string2method(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Address", NULL);
+	if (str != NULL) {
+		iface->ipv4.address.s_addr = inet_addr(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Netmask", NULL);
+	if (str != NULL) {
+		iface->ipv4.netmask.s_addr = inet_addr(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Gateway", NULL);
+	if (str != NULL) {
+		iface->ipv4.gateway.s_addr = inet_addr(str);
+		g_free(str);
+	}
+
+done:
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return 0;
+}
+
+static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
+{
+	const char *str;
+	gchar *comment;
+
+	DBG("iface %p", iface);
+
+	comment = g_key_file_get_comment(keyfile,
+					iface->identifier, NULL, NULL);
+	if (comment == NULL || *comment == '\0') {
+		if (iface->device.product != NULL)
+			g_key_file_set_comment(keyfile, iface->identifier,
+					NULL, iface->device.product, NULL);
+	}
+	g_free(comment);
+
+	str = __connman_iface_policy2string(iface->policy);
+	g_key_file_set_string(keyfile, iface->identifier, "Policy", str);
+
+	if (iface->ipv4.method != CONNMAN_IPV4_METHOD_UNKNOWN) {
+		str = __connman_ipv4_method2string(iface->ipv4.method);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Method", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Method", NULL);
+
+	if (iface->ipv4.address.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.address);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Address", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Address", NULL);
+
+	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.netmask);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Netmask", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Netmask", NULL);
+
+	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.gateway);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Gateway", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Gateway", NULL);
+}
+
+int __connman_iface_store(struct connman_iface *iface)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return -EIO;
+
+	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
+		goto done;
+
+	if (length > 0) {
+		if (g_key_file_load_from_data(keyfile, data, length,
+				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+			goto done;
+	}
+
+	g_free(data);
+
+	do_update(keyfile, iface);
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents(pathname, data, length, NULL);
+
+done:
+	g_free(data);
+
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return 0;
+}
diff --git a/src/iface.c b/src/iface.c
index c9d25951..df020a3a 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -500,6 +500,7 @@ static DBusMessage *set_policy(DBusConnection *conn,
 		path = dbus_message_get_path(msg);
 
 		iface->policy = new_policy;
+		__connman_iface_store(iface);
 
 		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
 			if (iface->driver->activate)
@@ -642,6 +643,8 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	path = dbus_message_get_path(msg);
 
 	if (changed == TRUE) {
+		__connman_iface_store(iface);
+
 		signal = dbus_message_new_signal(path,
 				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
 		if (signal != NULL) {
@@ -831,6 +834,8 @@ static int probe_device(LibHalContext *ctx,
 
 	__connman_iface_init_via_inet(iface);
 
+	__connman_iface_load(iface);
+
 	iface->driver = driver;
 
 	conn = libhal_ctx_get_dbus_connection(ctx);

commit 0ebfa46648f633da5d933af0c67277ad49ae4376
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 12:48:05 2008 +0100

    Add support for storing the network identifier

diff --git a/include/iface.h b/include/iface.h
index 4e2a30c0..a7c9f094 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -80,6 +80,7 @@ struct connman_ipv4 {
 };
 
 struct connman_network {
+	char *essid;
 };
 
 struct connman_iface {
@@ -93,6 +94,7 @@ struct connman_iface {
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
 	enum connman_iface_policy policy;
+	struct connman_network network;
 	struct connman_ipv4 ipv4;
 
 	struct connman_iface_driver *driver;
diff --git a/src/iface-storage.c b/src/iface-storage.c
index b7c84c38..ad2cfc5a 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -59,6 +59,15 @@ int __connman_iface_load(struct connman_iface *iface)
 		g_free(str);
 	}
 
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"Network.ESSID", NULL);
+	if (str != NULL) {
+		g_free(iface->network.essid);
+		iface->network.essid = str;
+		if (iface->driver->set_network)
+			iface->driver->set_network(iface, str);
+	}
+
 	str = g_key_file_get_string(keyfile, iface->identifier,
 							"IPv4.Method", NULL);
 	if (str != NULL) {
@@ -114,6 +123,13 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	str = __connman_iface_policy2string(iface->policy);
 	g_key_file_set_string(keyfile, iface->identifier, "Policy", str);
 
+	if (iface->network.essid != NULL) {
+		g_key_file_set_string(keyfile, iface->identifier,
+					"Network.ESSID", iface->network.essid);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"Network.ESSID", NULL);
+
 	if (iface->ipv4.method != CONNMAN_IPV4_METHOD_UNKNOWN) {
 		str = __connman_ipv4_method2string(iface->ipv4.method);
 		g_key_file_set_string(keyfile, iface->identifier,
diff --git a/src/iface.c b/src/iface.c
index df020a3a..b440d528 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -663,6 +663,7 @@ static DBusMessage *set_network(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	gboolean changed = FALSE;
 
 	DBG("conn %p", conn);
 
@@ -685,8 +686,11 @@ static DBusMessage *set_network(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &val);
 
 		if (g_strcasecmp(key, "ESSID") == 0) {
+			g_free(iface->network.essid);
+			iface->network.essid = g_strdup(val);
 			if (iface->driver->set_network)
 				iface->driver->set_network(iface, val);
+			changed = TRUE;
 		}
 
 		if (g_strcasecmp(key, "PSK") == 0) {
@@ -703,6 +707,9 @@ static DBusMessage *set_network(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
+	if (changed == TRUE)
+		__connman_iface_store(iface);
+
 	return reply;
 }
 
@@ -743,6 +750,7 @@ static void device_free(void *data)
 	g_free(iface->udi);
 	g_free(iface->sysfs);
 	g_free(iface->identifier);
+	g_free(iface->network.essid);
 	g_free(iface->device.driver);
 	g_free(iface->device.vendor);
 	g_free(iface->device.product);
@@ -834,10 +842,10 @@ static int probe_device(LibHalContext *ctx,
 
 	__connman_iface_init_via_inet(iface);
 
-	__connman_iface_load(iface);
-
 	iface->driver = driver;
 
+	__connman_iface_load(iface);
+
 	conn = libhal_ctx_get_dbus_connection(ctx);
 
 	g_dbus_register_object(conn, iface->path, iface, device_free);

commit baf41b9cfdb124c9369c7da522ec024625f877b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:43:50 2008 +0100

    Add support for terminating dhclient

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 8506c633..139eb8ff 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -51,7 +51,7 @@ struct dhclient_task {
 
 static GSList *tasks = NULL;
 
-static struct dhclient_task *find_task(GPid pid)
+static struct dhclient_task *find_task_by_pid(GPid pid)
 {
 	GSList *list;
 
@@ -65,6 +65,39 @@ static struct dhclient_task *find_task(GPid pid)
 	return NULL;
 }
 
+static struct dhclient_task *find_task_by_index(int index)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct dhclient_task *task = list->data;
+
+		if (task->ifindex == index)
+			return task;
+	}
+
+	return NULL;
+}
+
+static void kill_task(struct dhclient_task *task)
+{
+	char pathname[PATH_MAX];
+
+	kill(task->pid, SIGTERM);
+
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	free(task->ifname);
+
+	g_free(task);
+}
+
 static int dhclient_request(struct connman_iface *iface)
 {
 	struct ifreq ifr;
@@ -142,7 +175,17 @@ static int dhclient_request(struct connman_iface *iface)
 
 static int dhclient_release(struct connman_iface *iface)
 {
-	printf("[DHCP] release\n");
+	struct dhclient_task *task;
+
+	task = find_task_by_index(iface->index);
+	if (task == NULL)
+		return NULL;
+
+	printf("[DHCP] release %s\n", task->ifname);
+
+	tasks = g_slist_remove(tasks, task);
+
+	kill_task(task);
 
 	return 0;
 }
@@ -174,7 +217,7 @@ static DBusMessage *notify_method(DBusConnection *conn,
 
 	printf("[DHCP] change %d to %s\n", pid, text);
 
-	task = find_task(pid);
+	task = find_task_by_pid(pid);
 	if (task == NULL)
 		return NULL;
 
@@ -257,23 +300,10 @@ static void plugin_exit(void)
 
 	for (list = tasks; list; list = list->next) {
 		struct dhclient_task *task = list->data;
-		char pathname[PATH_MAX];
 
 		printf("[DHCP] killing process %d\n", task->pid);
 
-		kill(task->pid, SIGTERM);
-
-		snprintf(pathname, sizeof(pathname) - 1,
-				"%s/dhclient.%s.pid", STATEDIR, task->ifname);
-		unlink(pathname);
-
-		snprintf(pathname, sizeof(pathname) - 1,
-				"%s/dhclient.%s.leases", STATEDIR, task->ifname);
-		unlink(pathname);
-
-		free(task->ifname);
-
-		g_free(task);
+		kill_task(task);
 	}
 
 	g_slist_free(tasks);

commit c9ca5f2f6d9b10adec431e01472afb4c197e9f2a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:47:18 2008 +0100

    Update handling of shutdown procedure

diff --git a/src/iface.c b/src/iface.c
index b440d528..a5327f51 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -101,6 +101,10 @@ int connman_iface_update(struct connman_iface *iface,
 	const char *str = NULL;
 
 	switch (state) {
+	case CONNMAN_IFACE_STATE_OFF:
+		str = "off";
+		break;
+
 	case CONNMAN_IFACE_STATE_ENABLED:
 		str = "enabled";
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
@@ -119,6 +123,10 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
+		str = "shutdown";
+		__connman_dhcp_release(iface);
+		if (iface->driver->shutdown)
+			iface->driver->shutdown(iface);
 		break;
 
 	default:
@@ -505,10 +513,9 @@ static DBusMessage *set_policy(DBusConnection *conn,
 		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
 			if (iface->driver->activate)
 				iface->driver->activate(iface);
-		} else {
-			if (iface->driver->shutdown)
-				iface->driver->shutdown(iface);
-		}
+		} else
+			connman_iface_update(iface,
+					CONNMAN_IFACE_STATE_SHUTDOWN);
 
 		g_dbus_emit_signal(conn, path, CONNMAN_IFACE_INTERFACE,
 				"PolicyChanged", DBUS_TYPE_STRING, &policy,

commit 83bd9d00ec580988e38178ea1526505241535fdd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:48:33 2008 +0100

    Add support for retrieving network settings

diff --git a/include/iface.h b/include/iface.h
index a7c9f094..601253d3 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -81,6 +81,7 @@ struct connman_ipv4 {
 
 struct connman_network {
 	char *essid;
+	char *psk;
 };
 
 struct connman_iface {
diff --git a/src/iface.c b/src/iface.c
index a5327f51..f3098932 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -525,6 +525,116 @@ static DBusMessage *set_policy(DBusConnection *conn,
 	return reply;
 }
 
+static void append_network(DBusMessage *reply,
+				struct connman_iface *iface, gboolean secrets)
+{
+	DBusMessageIter array, dict;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	if (iface->network.essid != NULL)
+		append_entry(&dict, "ESSID",
+				DBUS_TYPE_STRING, &iface->network.essid);
+
+	if (secrets == TRUE && iface->network.psk != NULL)
+		append_entry(&dict, "PSK",
+				DBUS_TYPE_STRING, &iface->network.psk);
+
+	dbus_message_iter_close_container(&array, &dict);
+}
+
+static DBusMessage *get_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	append_network(reply, iface, TRUE);
+
+	return reply;
+}
+
+static DBusMessage *set_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply, *signal;
+	DBusMessageIter array, dict;
+	gboolean changed = FALSE;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "ESSID") == 0) {
+			g_free(iface->network.essid);
+			iface->network.essid = g_strdup(val);
+			if (iface->driver->set_network)
+				iface->driver->set_network(iface, val);
+			changed = TRUE;
+		}
+
+		if (g_strcasecmp(key, "PSK") == 0) {
+			g_free(iface->network.psk);
+			iface->network.psk = g_strdup(val);
+			if (iface->driver->set_network)
+				iface->driver->set_passphrase(iface, val);
+			changed = TRUE;
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	if (changed == TRUE) {
+		const char *path = dbus_message_get_path(msg);
+
+		__connman_iface_store(iface);
+
+		signal = dbus_message_new_signal(path,
+				CONNMAN_IFACE_INTERFACE, "NetworkChanged");
+		if (signal != NULL) {
+			append_network(signal, iface, FALSE);
+			dbus_connection_send(conn, signal, NULL);
+			dbus_message_unref(signal);
+		}
+	}
+
+	return reply;
+}
+
 static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
 {
 	DBusMessageIter array, dict;
@@ -581,7 +691,6 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply, *signal;
 	DBusMessageIter array, dict;
-	const char *path;
 	gboolean changed = FALSE;
 
 	DBG("conn %p", conn);
@@ -647,9 +756,9 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	path = dbus_message_get_path(msg);
-
 	if (changed == TRUE) {
+		const char *path = dbus_message_get_path(msg);
+
 		__connman_iface_store(iface);
 
 		signal = dbus_message_new_signal(path,
@@ -664,62 +773,6 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *set_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	gboolean changed = FALSE;
-
-	DBG("conn %p", conn);
-
-	dbus_message_iter_init(msg, &array);
-
-	dbus_message_iter_recurse(&array, &dict);
-
-	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key, *val;
-
-		dbus_message_iter_recurse(&dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-
-		dbus_message_iter_recurse(&entry, &value);
-
-		//type = dbus_message_iter_get_arg_type(&value);
-		dbus_message_iter_get_basic(&value, &val);
-
-		if (g_strcasecmp(key, "ESSID") == 0) {
-			g_free(iface->network.essid);
-			iface->network.essid = g_strdup(val);
-			if (iface->driver->set_network)
-				iface->driver->set_network(iface, val);
-			changed = TRUE;
-		}
-
-		if (g_strcasecmp(key, "PSK") == 0) {
-			if (iface->driver->set_network)
-				iface->driver->set_passphrase(iface, val);
-		}
-
-		dbus_message_iter_next(&dict);
-	}
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	if (changed == TRUE)
-		__connman_iface_store(iface);
-
-	return reply;
-}
-
 static GDBusMethodTable iface_methods[] = {
 	{ "Scan",          "",      "",      scan_iface     },
 	{ "GetProperties", "",      "a{sv}", get_properties },
@@ -727,9 +780,10 @@ static GDBusMethodTable iface_methods[] = {
 	{ "GetSignal",     "",      "q",     get_signal     },
 	{ "GetPolicy",     "",      "s",     get_policy     },
 	{ "SetPolicy",     "s",     "",      set_policy     },
+	{ "GetNetwork",    "",      "a{sv}", get_network    },
+	{ "SetNetwork",    "a{sv}", "",      set_network    },
 	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
 	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
-	{ "SetNetwork",    "a{sv}", "",      set_network    },
 	{ },
 };
 
@@ -737,8 +791,8 @@ static GDBusSignalTable iface_signals[] = {
 	{ "StateChanged",   "s"     },
 	{ "SignalChanged",  "q"     },
 	{ "PolicyChanged",  "s"     },
-	{ "IPv4Changed",    "a{sv}" },
 	{ "NetworkChanged", "a{sv}" },
+	{ "IPv4Changed",    "a{sv}" },
 	{ },
 };
 

commit ab8a6e3f5c4c10bac6a09887603f5d8ccbd0530b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:50:44 2008 +0100

    Fix wrong return value

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 139eb8ff..cc5efd86 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -179,7 +179,7 @@ static int dhclient_release(struct connman_iface *iface)
 
 	task = find_task_by_index(iface->index);
 	if (task == NULL)
-		return NULL;
+		return -ENODEV;
 
 	printf("[DHCP] release %s\n", task->ifname);
 

commit 98844b88980e2001ae3d8cd10f99d8ae9ac32b75
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:01:48 2008 +0100

    Fix shutdown procedure

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 4787f435..583b1f78 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -244,6 +244,10 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	exec_cmd(task, "DETACH");
 
+	sleep(1);
+
+	kill(task->pid, SIGTERM);
+
 	//close(task->socket);
 	g_io_channel_unref(task->channel);
 
@@ -251,8 +255,6 @@ int __supplicant_stop(struct connman_iface *iface)
 					"%s/%s.cli", STATEDIR, task->ifname);
 	unlink(pathname);
 
-	kill(task->pid, SIGTERM);
-
 	free(task->ifname);
 
 	g_free(task);

commit 56cf1fc63cdc201587b0bf7e1e06902acb090d6c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:02:17 2008 +0100

    Set the IPv4 method to DHCP in case of DHCP udpates

diff --git a/src/dhcp.c b/src/dhcp.c
index 2fa3f1fe..36132244 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -61,6 +61,8 @@ int connman_dhcp_update(struct connman_iface *iface,
 		DBG("broadcast %s", inet_ntoa(ipv4->broadcast));
 		DBG("nameserver %s", inet_ntoa(ipv4->nameserver));
 
+		ipv4->method = CONNMAN_IPV4_METHOD_DHCP;
+
 		if (iface->driver->set_ipv4) {
 			iface->driver->set_ipv4(iface, ipv4);
 			iface->ipv4 = *ipv4;

commit d48fb5d6e8c22200de560c430180bdb06a6e254b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:07:50 2008 +0100

    Stop supplicant on shutdown

diff --git a/plugins/80211.c b/plugins/80211.c
index 558dd971..6915a78b 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -234,7 +234,9 @@ static int iface_shutdown(struct connman_iface *iface)
 
 	printf("[802.11] shutdown %s\n", data->ifname);
 
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_SHUTDOWN);
+	__supplicant_stop(iface);
+
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_OFF);
 
 	return 0;
 }

commit 359571dd492865b5a8eefdc4d4c44e34d92568f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:08:34 2008 +0100

    Update scan result handling routine

diff --git a/plugins/80211.c b/plugins/80211.c
index 6915a78b..d8decec1 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -428,40 +428,53 @@ static void iface_scan_results(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 	struct iwreq iwr;
-	unsigned char *buf;
-	int sk, err, size = 1024;
+	void *buf;
+	size_t size;
+	int sk, err, done = 0;
+
+	if (data == NULL)
+		return;
+
+	memset(&iwr, 0, sizeof(iwr));
+	memcpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return;
 
-retrieve:
-	buf = malloc(size);
-	if (buf == NULL) {
-		close(sk);
-		return;
-	}
+	buf = NULL;
+	size = 1024;
 
-	memset(&iwr, 0, sizeof(iwr));
-	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
-	iwr.u.data.pointer = buf;
-	iwr.u.data.length = size;
-	iwr.u.data.flags = 0;
-
-	err = ioctl(sk, SIOCGIWSCAN, &iwr);
-	if (err < 0) {
-		if (errno == E2BIG) {
-			free(buf);
-			size *= 2;
-			goto retrieve;
+	while (!done) {
+		void *newbuf;
+
+		newbuf = g_realloc(buf, size);
+		if (newbuf == NULL) {
+			close(sk);
+			return;
 		}
-	} else
-		parse_scan_results(iface, iwr.u.data.pointer,
+
+		buf = newbuf;
+		iwr.u.data.pointer = buf;
+		iwr.u.data.length = size;
+		iwr.u.data.flags = 0;
+
+		err = ioctl(sk, SIOCGIWSCAN, &iwr);
+		if (err < 0) {
+			if (errno == E2BIG)
+				size *= 2;
+			else
+				done = 1;
+		} else {
+			parse_scan_results(iface, iwr.u.data.pointer,
 						iwr.u.data.length);
+			done = 1;
+		}
+	}
 
-	close(sk);
+	g_free(buf);
 
-	free(buf);
+	close(sk);
 
 	print_stations(data);
 }

commit e66c4ceb3685bc93ca067994f083f18d39f42aa7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 11 19:54:40 2008 +0100

    Fix IO handling for the control channel

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 583b1f78..e58415c1 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -77,10 +77,8 @@ static gboolean control_event(GIOChannel *chan,
 	gsize len;
 	GIOError err;
 
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
-		g_io_channel_unref(chan);
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
 		return FALSE;
-	}
 
 	memset(buf, 0, sizeof(buf));
 
@@ -88,7 +86,6 @@ static gboolean control_event(GIOChannel *chan,
 	if (err) {
 		if (err == G_IO_ERROR_AGAIN)
 			return TRUE;
-		g_io_channel_unref(chan);
 		return FALSE;
 	}
 
@@ -158,8 +155,6 @@ static int open_control(struct supplicant_task *task)
 	exec_cmd(task, "ATTACH");
 	exec_cmd(task, "ADD_NETWORK");
 
-	g_io_channel_unref(task->channel);
-
 	return 0;
 }
 
@@ -242,13 +237,14 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	tasks = g_slist_remove(tasks, task);
 
+	exec_cmd(task, "DISABLE_NETWORK 0");
 	exec_cmd(task, "DETACH");
 
 	sleep(1);
 
 	kill(task->pid, SIGTERM);
 
-	//close(task->socket);
+	g_io_channel_shutdown(task->channel, TRUE, NULL);
 	g_io_channel_unref(task->channel);
 
 	snprintf(pathname, sizeof(pathname),

commit be3d7a2524a2526ed6a3a9064307ee1dd60dfa34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 11 19:55:33 2008 +0100

    Update state machine handling

diff --git a/src/iface.c b/src/iface.c
index f3098932..2c7fdfea 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -98,15 +98,22 @@ void __connman_iface_list(DBusMessageIter *iter)
 int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state)
 {
-	const char *str = NULL;
+	const char *str;
+
+	iface->state = state;
+
+	str = __connman_iface_state2string(iface->state);
+
+	g_dbus_emit_signal(connection, iface->path,
+				CONNMAN_IFACE_INTERFACE, "StateChanged",
+				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
 
 	switch (state) {
 	case CONNMAN_IFACE_STATE_OFF:
-		str = "off";
+		__connman_dhcp_release(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
-		str = "enabled";
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
@@ -114,16 +121,10 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
-		str = "carrier";
 		__connman_dhcp_request(iface);
 		break;
 
-	case CONNMAN_IFACE_STATE_READY:
-		str = "ready";
-		break;
-
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
-		str = "shutdown";
 		__connman_dhcp_release(iface);
 		if (iface->driver->shutdown)
 			iface->driver->shutdown(iface);
@@ -133,14 +134,6 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 	}
 
-	iface->state = state;
-
-	if (str != NULL) {
-		g_dbus_emit_signal(connection, iface->path,
-				CONNMAN_IFACE_INTERFACE, "StateChanged",
-				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
-	}
-
 	return 0;
 }
 
@@ -489,7 +482,7 @@ static DBusMessage *set_policy(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply;
 	enum connman_iface_policy new_policy;
-	const char *path, *policy;
+	const char *policy;
 
 	DBG("conn %p", conn);
 
@@ -505,8 +498,6 @@ static DBusMessage *set_policy(DBusConnection *conn,
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	if (iface->policy != new_policy) {
-		path = dbus_message_get_path(msg);
-
 		iface->policy = new_policy;
 		__connman_iface_store(iface);
 
@@ -517,7 +508,9 @@ static DBusMessage *set_policy(DBusConnection *conn,
 			connman_iface_update(iface,
 					CONNMAN_IFACE_STATE_SHUTDOWN);
 
-		g_dbus_emit_signal(conn, path, CONNMAN_IFACE_INTERFACE,
+		policy = __connman_iface_policy2string(new_policy);
+
+		g_dbus_emit_signal(conn, iface->path, CONNMAN_IFACE_INTERFACE,
 				"PolicyChanged", DBUS_TYPE_STRING, &policy,
 							DBUS_TYPE_INVALID);
 	}
@@ -537,13 +530,18 @@ static void append_network(DBusMessage *reply,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	if (iface->network.essid != NULL)
-		append_entry(&dict, "ESSID",
+	switch (iface->type) {
+	case CONNMAN_IFACE_TYPE_80211:
+		if (iface->network.essid != NULL)
+			append_entry(&dict, "ESSID",
 				DBUS_TYPE_STRING, &iface->network.essid);
-
-	if (secrets == TRUE && iface->network.psk != NULL)
-		append_entry(&dict, "PSK",
+		if (secrets == TRUE && iface->network.psk != NULL)
+			append_entry(&dict, "PSK",
 				DBUS_TYPE_STRING, &iface->network.psk);
+		break;
+	default:
+		break;
+	}
 
 	dbus_message_iter_close_container(&array, &dict);
 }
@@ -619,11 +617,9 @@ static DBusMessage *set_network(DBusConnection *conn,
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	if (changed == TRUE) {
-		const char *path = dbus_message_get_path(msg);
-
 		__connman_iface_store(iface);
 
-		signal = dbus_message_new_signal(path,
+		signal = dbus_message_new_signal(iface->path,
 				CONNMAN_IFACE_INTERFACE, "NetworkChanged");
 		if (signal != NULL) {
 			append_network(signal, iface, FALSE);
@@ -757,11 +753,9 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	if (changed == TRUE) {
-		const char *path = dbus_message_get_path(msg);
-
 		__connman_iface_store(iface);
 
-		signal = dbus_message_new_signal(path,
+		signal = dbus_message_new_signal(iface->path,
 				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
 		if (signal != NULL) {
 			append_ipv4(signal, iface);

commit 7677b1bdb5df04b2e780d1bacf76f9de3f64d478
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 13 23:32:43 2008 +0100

    Add options for debug and PIE support

diff --git a/bootstrap-configure b/bootstrap-configure
index 1da77dae..2b8dc78e 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -6,6 +6,7 @@ fi
 
 ./bootstrap && \
     ./configure --enable-maintainer-mode \
+		--enable-debug \
 		--prefix=/usr \
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
diff --git a/configure.in b/configure.in
index 8f13afcd..0cbb0ad9 100644
--- a/configure.in
+++ b/configure.in
@@ -9,7 +9,7 @@ AM_MAINTAINER_MODE
 AC_PREFIX_DEFAULT(/usr/local)
 
 if (test "${CFLAGS}" = ""); then
-	CFLAGS="-Wall -O2"
+	CFLAGS="-Wall -O2 -D_FORTIFY_SOURCE=2"
 fi
 
 AC_LANG_C
@@ -24,6 +24,23 @@ m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 
+AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
+			[enable compiling with debugging information]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_prog_cc_g}" = "yes"); then
+		CFLAGS="$CFLAGS -g"
+	fi
+])
+
+AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
+			[enable position independent executables flag]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_prog_cc_pie}" = "yes"); then
+		CFLAGS="$CFLAGS -fPIE"
+		LDFLAGS="$LDFLAGS -pie"
+	fi
+])
+
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
 				AC_MSG_ERROR(gmodule is required))
 AC_SUBST(GMODULE_CFLAGS)

commit 6c6a470f8d4b2c5ec4725b13e7bfcf4ca0c04f41
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:00:15 2008 +0100

    Add generic helpers for device start and shutdown

diff --git a/src/connman.h b/src/connman.h
index 26931ff5..8756034c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -57,6 +57,8 @@ void __connman_iface_list(DBusMessageIter *iter);
 
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
+int __connman_iface_up(struct connman_iface *iface);
+int __connman_iface_down(struct connman_iface *iface);
 
 int __connman_iface_load(struct connman_iface *iface);
 int __connman_iface_store(struct connman_iface *iface);
diff --git a/src/iface-inet.c b/src/iface-inet.c
index 664d2980..a09ba312 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -108,3 +108,87 @@ int __connman_iface_init_via_inet(struct connman_iface *iface)
 
 	return 0;
 }
+
+int __connman_iface_up(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ifr.ifr_flags & IFF_UP) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags |= IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+		err = -errno;
+	else
+		err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}
+
+int __connman_iface_down(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (!(ifr.ifr_flags & IFF_UP)) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags &= ~IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+		err = -errno;
+	else
+		err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}

commit 2f088e1e27e0905da6d9b527bfff2a569bdef458
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:06:50 2008 +0100

    Remove unneeded callbacks from 802.03 and 802.11 plugins

diff --git a/include/iface.h b/include/iface.h
index 601253d3..96e9c4f0 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -38,10 +38,10 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_RTNL           = (1 << 0),
-	CONNMAN_IFACE_FLAG_IPV4           = (1 << 1),
-	CONNMAN_IFACE_FLAG_IPV6           = (1 << 2),
-	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 3),
+	CONNMAN_IFACE_FLAG_RTNL     = (1 << 0),
+	CONNMAN_IFACE_FLAG_IPV4     = (1 << 1),
+	CONNMAN_IFACE_FLAG_IPV6     = (1 << 2),
+	CONNMAN_IFACE_FLAG_SCANNING = (1 << 3),
 };
 
 enum connman_iface_state {
@@ -122,6 +122,7 @@ struct connman_iface_driver {
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
+	int (*disconnect) (struct connman_iface *iface);
 
 	void (*set_network) (struct connman_iface *iface,
 						const char *network);
diff --git a/plugins/80203.c b/plugins/80203.c
index 65a22aa1..d916c970 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -24,7 +24,6 @@
 #endif
 
 #include <stdio.h>
-#include <arpa/inet.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
@@ -36,8 +35,7 @@ static int iface_probe(struct connman_iface *iface)
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4 |
-				CONNMAN_IFACE_FLAG_CARRIER_DETECT;
+				CONNMAN_IFACE_FLAG_IPV4;
 
 	return 0;
 }
diff --git a/plugins/80211.c b/plugins/80211.c
index d8decec1..3327d107 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -217,30 +217,6 @@ static void iface_remove(struct connman_iface *iface)
 	free(data);
 }
 
-static int iface_activate(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	printf("[802.11] activate %s\n", data->ifname);
-
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_ENABLED);
-
-	return 0;
-}
-
-static int iface_shutdown(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	printf("[802.11] shutdown %s\n", data->ifname);
-
-	__supplicant_stop(iface);
-
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_OFF);
-
-	return 0;
-}
-
 static int iface_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
@@ -289,6 +265,17 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
+static int iface_disconnect(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] disconnect %s\n", data->ifname);
+
+	__supplicant_stop(iface);
+
+	return 0;
+}
+
 static void iface_set_network(struct connman_iface *iface,
 						const char *network)
 {
@@ -313,13 +300,6 @@ static void iface_set_passphrase(struct connman_iface *iface,
 	data->passphrase = g_strdup(passphrase);
 }
 
-static void iface_carrier(struct connman_iface *iface, int carrier)
-{
-	printf("[802.11] carrier %s\n", carrier ? "on" : "off");
-
-	connman_iface_indicate_carrier(iface, carrier);
-}
-
 static void parse_genie(struct station_data *station,
 					unsigned char *data, int len)
 {
@@ -535,13 +515,11 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
-	.activate	= iface_activate,
-	.shutdown	= iface_shutdown,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.disconnect	= iface_disconnect,
 	.set_network	= iface_set_network,
 	.set_passphrase	= iface_set_passphrase,
-	.rtnl_carrier	= iface_carrier,
 	.rtnl_wireless	= iface_wireless,
 };
 

commit 88be168553c2345349c614fbf7a208a32d0ca970
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:11:57 2008 +0100

    Handle return values of system calls

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index e58415c1..de74ce56 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -64,9 +64,7 @@ static struct supplicant_task *find_task(int ifindex)
 
 static int exec_cmd(struct supplicant_task *task, char *cmd)
 {
-	write(task->socket, cmd, strlen(cmd));
-
-	return 0;
+	return write(task->socket, cmd, strlen(cmd));
 }
 
 static gboolean control_event(GIOChannel *chan,
diff --git a/src/iface.c b/src/iface.c
index 2c7fdfea..a6b0ba24 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -252,7 +252,7 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 
 	DBG("%s", cmd);
 
-	system(cmd);
+	err = system(cmd);
 
 	return 0;
 }
@@ -301,7 +301,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 
 	DBG("%s", cmd);
 
-	system(cmd);
+	err = system(cmd);
 
 	return 0;
 }

commit d3ad57f2adff903961edfdec45b60e5813107eff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:17:23 2008 +0100

    Add more detailed interface state machine

diff --git a/include/iface.h b/include/iface.h
index 96e9c4f0..57a4d72e 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -48,11 +48,13 @@ enum connman_iface_state {
 	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
 	CONNMAN_IFACE_STATE_OFF       = 1,
 	CONNMAN_IFACE_STATE_ENABLED   = 2,
-	CONNMAN_IFACE_STATE_CONNECT   = 3,
-	CONNMAN_IFACE_STATE_CONFIG    = 4,
-	CONNMAN_IFACE_STATE_CARRIER   = 5,
-	CONNMAN_IFACE_STATE_READY     = 6,
-	CONNMAN_IFACE_STATE_SHUTDOWN  = 7,
+	CONNMAN_IFACE_STATE_SCANNING  = 3,
+	CONNMAN_IFACE_STATE_CONNECT   = 4,
+	CONNMAN_IFACE_STATE_CONNECTED = 5,
+	CONNMAN_IFACE_STATE_CARRIER   = 6,
+	CONNMAN_IFACE_STATE_CONFIGURE = 7,
+	CONNMAN_IFACE_STATE_READY     = 8,
+	CONNMAN_IFACE_STATE_SHUTDOWN  = 9,
 };
 
 enum connman_iface_policy {
@@ -90,7 +92,6 @@ struct connman_iface {
 	char *sysfs;
 	char *identifier;
 	int index;
-	int carrier;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
@@ -101,6 +102,8 @@ struct connman_iface {
 	struct connman_iface_driver *driver;
 	void *driver_data;
 
+	void *rtnl_data;
+
 	struct {
 		char *driver;
 		char *vendor;
@@ -113,12 +116,7 @@ struct connman_iface_driver {
 	const char *capability;
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
-	int (*activate) (struct connman_iface *iface);
-	int (*shutdown) (struct connman_iface *iface);
-	int (*get_ipv4) (struct connman_iface *iface,
-					struct connman_ipv4 *ipv4);
-	int (*set_ipv4) (struct connman_iface *iface,
-					struct connman_ipv4 *ipv4);
+
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
@@ -148,11 +146,12 @@ static inline void connman_iface_set_data(struct connman_iface *iface,
 	iface->driver_data = data;
 }
 
-extern int connman_iface_update(struct connman_iface *iface,
-					enum connman_iface_state state);
-
-extern void connman_iface_indicate_carrier(struct connman_iface *iface,
-							int carrier);
+extern void connman_iface_indicate_enabled(struct connman_iface *iface);
+extern void connman_iface_indicate_disabled(struct connman_iface *iface);
+extern void connman_iface_indicate_connected(struct connman_iface *iface);
+extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
+extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
+extern void connman_iface_indicate_configured(struct connman_iface *iface);
 
 extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index de74ce56..3c02abd8 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -94,8 +94,7 @@ static gboolean control_event(GIOChannel *chan,
 
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
 		printf("[SUPPLICANT] connected\n");
-		connman_iface_update(task->iface,
-					CONNMAN_IFACE_STATE_CARRIER);
+		connman_iface_indicate_connected(task->iface);
 	}
 
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
diff --git a/src/dhcp.c b/src/dhcp.c
index 36132244..ecf61f2b 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -63,15 +63,10 @@ int connman_dhcp_update(struct connman_iface *iface,
 
 		ipv4->method = CONNMAN_IPV4_METHOD_DHCP;
 
-		if (iface->driver->set_ipv4) {
-			iface->driver->set_ipv4(iface, ipv4);
-			iface->ipv4 = *ipv4;
-		} else {
-			connman_iface_set_ipv4(iface, ipv4);
-			iface->ipv4 = *ipv4;
-		}
-
-		connman_iface_update(iface, CONNMAN_IFACE_STATE_READY);
+		connman_iface_set_ipv4(iface, ipv4);
+		iface->ipv4 = *ipv4;
+
+		connman_iface_indicate_configured(iface);
 	}
 
 	return 0;
diff --git a/src/iface-helper.c b/src/iface-helper.c
index 4fe4b649..06642fb5 100644
--- a/src/iface-helper.c
+++ b/src/iface-helper.c
@@ -56,12 +56,16 @@ const char *__connman_iface_state2string(enum connman_iface_state state)
 		return "off";
 	case CONNMAN_IFACE_STATE_ENABLED:
 		return "enabled";
+	case CONNMAN_IFACE_STATE_SCANNING:
+		return "scanning";
 	case CONNMAN_IFACE_STATE_CONNECT:
 		return "connect";
-	case CONNMAN_IFACE_STATE_CONFIG:
-		return "config";
+	case CONNMAN_IFACE_STATE_CONNECTED:
+		return "connected";
 	case CONNMAN_IFACE_STATE_CARRIER:
 		return "carrier";
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+		return "configure";
 	case CONNMAN_IFACE_STATE_READY:
 		return "ready";
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
diff --git a/src/iface.c b/src/iface.c
index a6b0ba24..2e638663 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -95,51 +95,161 @@ void __connman_iface_list(DBusMessageIter *iter)
 	}
 }
 
-int connman_iface_update(struct connman_iface *iface,
-					enum connman_iface_state state)
+static void state_changed(struct connman_iface *iface)
 {
-	const char *str;
-
-	iface->state = state;
+	const char *str = __connman_iface_state2string(iface->state);
+	enum connman_iface_state state = iface->state;
 
-	str = __connman_iface_state2string(iface->state);
+	DBG("%s", str);
 
 	g_dbus_emit_signal(connection, iface->path,
 				CONNMAN_IFACE_INTERFACE, "StateChanged",
 				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
 
-	switch (state) {
+	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
 		__connman_dhcp_release(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
-			if (iface->driver->connect)
+			state = CONNMAN_IFACE_STATE_SCANNING;
+			if (iface->driver->connect) {
 				iface->driver->connect(iface, NULL);
+				state = CONNMAN_IFACE_STATE_CONNECT;
+			}
 		}
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
+		if (iface->policy == CONNMAN_IFACE_POLICY_AUTO)
+			state = CONNMAN_IFACE_STATE_CONFIGURE;
+		break;
+
+	case CONNMAN_IFACE_STATE_CONFIGURE:
 		__connman_dhcp_request(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
 		__connman_dhcp_release(iface);
-		if (iface->driver->shutdown)
-			iface->driver->shutdown(iface);
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+		if (iface->policy != CONNMAN_IFACE_POLICY_AUTO)
+			state = CONNMAN_IFACE_STATE_OFF;
 		break;
 
 	default:
 		break;
 	}
 
-	return 0;
+	if (iface->state != state) {
+		iface->state = state;
+		state_changed(iface);
+	}
+}
+
+static void switch_policy(struct connman_iface *iface)
+{
+	DBG("iface %p", iface);
+
+	switch (iface->policy) {
+	case CONNMAN_IFACE_POLICY_OFF:
+		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+		state_changed(iface);
+		__connman_iface_down(iface);
+		break;
+
+	case CONNMAN_IFACE_POLICY_IGNORE:
+		break;
+
+	case CONNMAN_IFACE_POLICY_AUTO:
+		__connman_iface_up(iface);
+		break;
+
+	default:
+		break;
+	}
 }
 
-void connman_iface_indicate_carrier(struct connman_iface *iface, int carrier)
+void connman_iface_indicate_enabled(struct connman_iface *iface)
 {
-	DBG("iface %p carrier %d", iface, carrier);
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_OFF:
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_disabled(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+	state_changed(iface);
+}
+
+void connman_iface_indicate_connected(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONNECT:
+		iface->state = CONNMAN_IFACE_STATE_CONNECTED;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_carrier_on(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_ENABLED:
+	case CONNMAN_IFACE_STATE_CONNECT:
+	case CONNMAN_IFACE_STATE_CONNECTED:
+		iface->state = CONNMAN_IFACE_STATE_CARRIER;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_carrier_off(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+	case CONNMAN_IFACE_STATE_READY:
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_configured(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+		iface->state = CONNMAN_IFACE_STATE_READY;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
 }
 
 int connman_iface_get_ipv4(struct connman_iface *iface,
@@ -501,13 +611,7 @@ static DBusMessage *set_policy(DBusConnection *conn,
 		iface->policy = new_policy;
 		__connman_iface_store(iface);
 
-		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
-			if (iface->driver->activate)
-				iface->driver->activate(iface);
-		} else
-			connman_iface_update(iface,
-					CONNMAN_IFACE_STATE_SHUTDOWN);
-
+		switch_policy(iface);
 		policy = __connman_iface_policy2string(new_policy);
 
 		g_dbus_emit_signal(conn, iface->path, CONNMAN_IFACE_INTERFACE,
@@ -908,10 +1012,7 @@ static int probe_device(LibHalContext *ctx,
 	interfaces = g_slist_append(interfaces, iface);
 
 	if (iface->flags & CONNMAN_IFACE_FLAG_IPV4) {
-		if (driver->get_ipv4)
-			driver->get_ipv4(iface, &iface->ipv4);
-		else
-			connman_iface_get_ipv4(iface, &iface->ipv4);
+		connman_iface_get_ipv4(iface, &iface->ipv4);
 
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
@@ -928,10 +1029,7 @@ static int probe_device(LibHalContext *ctx,
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
-	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
-		if (driver->activate)
-			driver->activate(iface);
-	}
+	switch_policy(iface);
 
 	return 0;
 }
diff --git a/src/rtnl.c b/src/rtnl.c
index fd61d0dc..3e26dbff 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -37,6 +37,21 @@
 
 #include "connman.h"
 
+struct rtnl_data {
+	unsigned ifi_flags;
+};
+
+static struct rtnl_data *get_rtnl_data(struct connman_iface *iface)
+{
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return NULL;
+
+	if (iface->rtnl_data == NULL)
+		iface->rtnl_data = g_try_new0(struct rtnl_data, 1);
+
+	return iface->rtnl_data;
+}
+
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
 {
 	if (family == AF_INET) {
@@ -72,6 +87,7 @@ static inline void print_attr(struct rtattr *attr, const char *name)
 static void rtnl_link(struct nlmsghdr *hdr)
 {
 	struct connman_iface *iface;
+	struct rtnl_data *data;
 	struct ifinfomsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -85,17 +101,26 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	if (iface == NULL)
 		return;
 
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+	data = get_rtnl_data(iface);
+	if (data == NULL)
 		return;
 
-	if (iface->carrier != ((msg->ifi_flags & IFF_RUNNING) != 0)) {
-		iface->carrier = ((msg->ifi_flags & IFF_RUNNING) != 0);
-		if (iface->driver->rtnl_carrier)
-			iface->driver->rtnl_carrier(iface, iface->carrier);
+	if ((data->ifi_flags & IFF_RUNNING) != (msg->ifi_flags & IFF_RUNNING)) {
+		if (msg->ifi_flags & IFF_RUNNING)
+			connman_iface_indicate_carrier_on(iface);
 		else
-			connman_iface_indicate_carrier(iface, iface->carrier);
+			connman_iface_indicate_carrier_off(iface);
 	}
 
+	if ((data->ifi_flags & IFF_UP) != (msg->ifi_flags & IFF_UP)) {
+		if (msg->ifi_flags & IFF_UP)
+			connman_iface_indicate_enabled(iface);
+		else
+			connman_iface_indicate_disabled(iface);
+	}
+
+	data->ifi_flags = msg->ifi_flags;
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
@@ -162,6 +187,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 static void rtnl_addr(struct nlmsghdr *hdr)
 {
 	struct connman_iface *iface;
+	struct rtnl_data *data;
 	struct ifaddrmsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -175,7 +201,8 @@ static void rtnl_addr(struct nlmsghdr *hdr)
 	if (iface == NULL)
 		return;
 
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+	data = get_rtnl_data(iface);
+	if (data == NULL)
 		return;
 
 	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
@@ -328,10 +355,8 @@ static gboolean netlink_event(GIOChannel *chan,
 	gsize len;
 	GIOError err;
 
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
-		g_io_channel_unref(chan);
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
 		return FALSE;
-	}
 
 	memset(buf, 0, sizeof(buf));
 
@@ -339,7 +364,6 @@ static gboolean netlink_event(GIOChannel *chan,
 	if (err) {
 		if (err == G_IO_ERROR_AGAIN)
 			return TRUE;
-		g_io_channel_unref(chan);
 		return FALSE;
 	}
 
@@ -394,8 +418,6 @@ int __connman_rtnl_init(void)
 			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
 						netlink_event, NULL);
 
-	g_io_channel_unref(channel);
-
 	return 0;
 }
 
@@ -403,6 +425,7 @@ void __connman_rtnl_cleanup(void)
 {
 	DBG("");
 
+	g_io_channel_shutdown(channel, TRUE, NULL);
 	g_io_channel_unref(channel);
 
 	channel = NULL;

commit d9bc76c98cfd933d365bdfb7b5fcfc5061aa6fb8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:25:40 2008 +0100

    Release DHCP lease when carrier off

diff --git a/src/iface.c b/src/iface.c
index 2e638663..ec790ade 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -112,6 +112,7 @@ static void state_changed(struct connman_iface *iface)
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
+		__connman_dhcp_release(iface);
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			state = CONNMAN_IFACE_STATE_SCANNING;
 			if (iface->driver->connect) {

commit 5554ad583523b6bea46c104999e1b5b00102594a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 07:24:03 2008 +0100

    Remove IP addresses on shutdown and fix carrier detect

diff --git a/src/iface.c b/src/iface.c
index ec790ade..c3ca6e2b 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -100,7 +100,7 @@ static void state_changed(struct connman_iface *iface)
 	const char *str = __connman_iface_state2string(iface->state);
 	enum connman_iface_state state = iface->state;
 
-	DBG("%s", str);
+	DBG("iface %p state %s", iface, str);
 
 	g_dbus_emit_signal(connection, iface->path,
 				CONNMAN_IFACE_INTERFACE, "StateChanged",
@@ -113,6 +113,7 @@ static void state_changed(struct connman_iface *iface)
 
 	case CONNMAN_IFACE_STATE_ENABLED:
 		__connman_dhcp_release(iface);
+		connman_iface_clear_ipv4(iface);
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			state = CONNMAN_IFACE_STATE_SCANNING;
 			if (iface->driver->connect) {
@@ -157,6 +158,7 @@ static void switch_policy(struct connman_iface *iface)
 	case CONNMAN_IFACE_POLICY_OFF:
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 		state_changed(iface);
+		connman_iface_clear_ipv4(iface);
 		__connman_iface_down(iface);
 		break;
 
@@ -165,6 +167,7 @@ static void switch_policy(struct connman_iface *iface)
 
 	case CONNMAN_IFACE_POLICY_AUTO:
 		__connman_iface_up(iface);
+		state_changed(iface);
 		break;
 
 	default:
@@ -178,6 +181,7 @@ void connman_iface_indicate_enabled(struct connman_iface *iface)
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
+	case CONNMAN_IFACE_STATE_CARRIER:
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
@@ -229,6 +233,7 @@ void connman_iface_indicate_carrier_off(struct connman_iface *iface)
 	DBG("iface %p state %d", iface, iface->state);
 
 	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CARRIER:
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 	case CONNMAN_IFACE_STATE_READY:
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;

commit b6af353282ffb3a90f9cce4aa408ac2347117f11
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 16 03:33:04 2008 +0100

    Report found networks and send out updates

diff --git a/plugins/80211.c b/plugins/80211.c
index 3327d107..a94551dd 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -64,6 +64,16 @@ struct iface_data {
 	gchar *passphrase;
 };
 
+static void report_station(struct connman_iface *iface,
+						struct station_data *station)
+{
+	if (station == NULL)
+		return;
+
+	if (station->name)
+		connman_iface_indicate_station(iface, station->name);
+}
+
 static struct station_data *create_station(struct iface_data *iface,
 							const char *address)
 {
@@ -339,6 +349,7 @@ static void parse_scan_results(struct connman_iface *iface,
 
 		switch (event->cmd) {
 		case SIOCGIWAP:
+			report_station(iface, station);
 			eth = (void *) &event->u.ap_addr.sa_data;
 			sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
 						eth->ether_addr_octet[0],
@@ -401,6 +412,8 @@ static void parse_scan_results(struct connman_iface *iface,
 		len -= event->len;
 	}
 
+	report_station(iface, station);
+
 	printf("[802.11] found %d networks\n", num);
 }
 
diff --git a/src/iface.c b/src/iface.c
index c3ca6e2b..1662fb7a 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -95,6 +95,37 @@ void __connman_iface_list(DBusMessageIter *iter)
 	}
 }
 
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
 static void state_changed(struct connman_iface *iface)
 {
 	const char *str = __connman_iface_state2string(iface->state);
@@ -258,6 +289,40 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	}
 }
 
+static void append_station(DBusMessage *reply, const char *name)
+{
+	DBusMessageIter array, dict;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
+
+	dbus_message_iter_close_container(&array, &dict);
+}
+
+void connman_iface_indicate_station(struct connman_iface *iface,
+							const char *name)
+{
+	DBusMessage *signal;
+
+	DBG("iface %p name %s", iface, name);
+
+	signal = dbus_message_new_signal(iface->path,
+				CONNMAN_IFACE_INTERFACE, "NetworkFound");
+	if (signal == NULL)
+		return;
+
+	append_station(signal, name);
+
+	dbus_connection_send(connection, signal, NULL);
+	dbus_message_unref(signal);
+}
+
 int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4)
 {
@@ -443,37 +508,6 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	return reply;
 }
 
-static void append_entry(DBusMessageIter *dict,
-				const char *key, int type, void *val)
-{
-	DBusMessageIter entry, value;
-	const char *signature;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	switch (type) {
-	case DBUS_TYPE_STRING:
-		signature = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT16:
-		signature = DBUS_TYPE_UINT16_AS_STRING;
-		break;
-	default:
-		signature = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							signature, &value);
-	dbus_message_iter_append_basic(&value, type, val);
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -895,6 +929,7 @@ static GDBusSignalTable iface_signals[] = {
 	{ "StateChanged",   "s"     },
 	{ "SignalChanged",  "q"     },
 	{ "PolicyChanged",  "s"     },
+	{ "NetworkFound",   "a{sv}" },
 	{ "NetworkChanged", "a{sv}" },
 	{ "IPv4Changed",    "a{sv}" },
 	{ },

commit 199daf70bac7eb1d2d7fdafc66b2a1baba188bdc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 16 06:59:22 2008 +0100

    Include signal strength for reported networks

diff --git a/include/iface.h b/include/iface.h
index 57a4d72e..6a80178a 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -153,6 +153,9 @@ extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
 extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
 extern void connman_iface_indicate_configured(struct connman_iface *iface);
 
+extern void connman_iface_indicate_station(struct connman_iface *iface,
+						const char *name, int strength);
+
 extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
 extern int connman_iface_set_ipv4(struct connman_iface *iface,
diff --git a/plugins/80211.c b/plugins/80211.c
index a94551dd..53b36b60 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -70,8 +70,10 @@ static void report_station(struct connman_iface *iface,
 	if (station == NULL)
 		return;
 
-	if (station->name)
-		connman_iface_indicate_station(iface, station->name);
+	if (station->name == NULL)
+		return;
+
+	connman_iface_indicate_station(iface, station->name, station->qual);
 }
 
 static struct station_data *create_station(struct iface_data *iface,
diff --git a/src/iface.c b/src/iface.c
index 1662fb7a..a412dab4 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -289,7 +289,7 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	}
 }
 
-static void append_station(DBusMessage *reply, const char *name)
+static void append_station(DBusMessage *reply, const char *name, int signal)
 {
 	DBusMessageIter array, dict;
 
@@ -301,12 +301,13 @@ static void append_station(DBusMessage *reply, const char *name)
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
 	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
+	append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
 
 	dbus_message_iter_close_container(&array, &dict);
 }
 
 void connman_iface_indicate_station(struct connman_iface *iface,
-							const char *name)
+						const char *name, int strength)
 {
 	DBusMessage *signal;
 
@@ -317,7 +318,7 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	if (signal == NULL)
 		return;
 
-	append_station(signal, name);
+	append_station(signal, name, strength);
 
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);

commit 7aac03f81d1a9e3d0e5c476b22ca883f839e6d1c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 24 12:07:55 2008 +0100

    Add skeleton for agent infrastructure

diff --git a/src/Makefile.am b/src/Makefile.am
index 4da752e5..1a09a0f8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h manager.c plugin.c \
+connmand_SOURCES = main.c connman.h manager.c agent.c plugin.c \
 			iface.c iface-storage.c iface-helper.c \
 					iface-inet.c rtnl.c dhcp.c
 
diff --git a/src/agent.c b/src/agent.c
new file mode 100644
index 00000000..d3a27463
--- /dev/null
+++ b/src/agent.c
@@ -0,0 +1,52 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+int __connman_agent_init(void)
+{
+	DBG("");
+
+	return 0;
+}
+
+void __connman_agent_cleanup(void)
+{
+	DBG("");
+}
+
+int __connman_agent_register(const char *path)
+{
+	DBG("");
+
+	return 0;
+}
+
+int __connman_agent_unregister(const char *path)
+{
+	DBG("");
+
+	return 0;
+}
diff --git a/src/connman.h b/src/connman.h
index 8756034c..ff33489e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -42,6 +42,12 @@
 int __connman_manager_init(DBusConnection *conn, int compat);
 void __connman_manager_cleanup(void);
 
+int __connman_agent_init(void);
+void __connman_agent_cleanup(void);
+
+int __connman_agent_register(const char *path);
+int __connman_agent_unregister(const char *path);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/main.c b/src/main.c
index 8de7fbed..1b314db8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -120,6 +120,8 @@ int main(int argc, char *argv[])
 			compat = 0;
 	}
 
+	__connman_agent_init();
+
 	__connman_manager_init(conn, compat);
 
 	__connman_plugin_init();
@@ -143,6 +145,8 @@ int main(int argc, char *argv[])
 
 	__connman_manager_cleanup();
 
+	__connman_agent_cleanup();
+
 	g_dbus_cleanup_connection(conn);
 
 	g_main_loop_unref(main_loop);
diff --git a/src/manager.c b/src/manager.c
index b11d805e..2a1a738f 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -70,9 +70,55 @@ static DBusMessage *get_state(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *register_agent(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	__connman_agent_register(path);
+
+	return reply;
+}
+
+static DBusMessage *unregister_agent(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	__connman_agent_unregister(path);
+
+	return reply;
+}
+
 static GDBusMethodTable manager_methods[] = {
-	{ "ListInterfaces", "", "ao", list_interfaces },
-	{ "GetState",       "", "s",  get_state       },
+	{ "ListInterfaces",  "",  "ao", list_interfaces  },
+	{ "GetState",        "",  "s",  get_state        },
+	{ "RegisterAgent",   "o", "",   register_agent   },
+	{ "UnregisterAgent", "o", "",   unregister_agent },
 	{ },
 };
 

commit 6908741e0b2291a32ae9aafe556f2a021e23c5af
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 24 14:05:43 2008 +0100

    Add directory for example applications

diff --git a/Makefile.am b/Makefile.am
index 52247b98..de0e19be 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src plugins scripts
+SUBDIRS = include src test plugins scripts
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index 0cbb0ad9..a5991e4d 100644
--- a/configure.in
+++ b/configure.in
@@ -61,5 +61,5 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile
-			plugins/Makefile scripts/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile test/Makefile
+				plugins/Makefile scripts/Makefile)
diff --git a/test/Makefile.am b/test/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/test/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in

commit 99983be83b0f1c0ecbce00276fd21ba05b4d681f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 24 15:01:28 2008 +0100

    Add handling for agent registration and monitoring

diff --git a/src/agent.c b/src/agent.c
index d3a27463..4765868d 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -23,30 +23,100 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <gdbus.h>
+
 #include "connman.h"
 
-int __connman_agent_init(void)
+static DBusConnection *connection = NULL;
+static guint agent_watch = 0;
+static gchar *agent_path = NULL;
+static gchar *agent_sender = NULL;
+
+static void agent_free(void)
 {
-	DBG("");
+	agent_watch = 0;
 
-	return 0;
+	g_free(agent_sender);
+	agent_sender = NULL;
+
+	g_free(agent_path);
+	agent_path = NULL;
 }
 
-void __connman_agent_cleanup(void)
+static gboolean agent_disconnect(void *data)
+{
+	DBG("data %p", data);
+
+	agent_free();
+
+	return TRUE;
+}
+
+int __connman_agent_register(const char *sender, const char *path)
 {
-	DBG("");
+	DBG("sender %s path %s", sender, path);
+
+	if (agent_path != NULL)
+		return -EEXIST;
+
+	agent_sender = g_strdup(sender);
+	agent_path = g_strdup(path);
+
+	agent_watch = g_dbus_add_disconnect_watch(connection, sender,
+						agent_disconnect, NULL, NULL);
+
+	return 0;
 }
 
-int __connman_agent_register(const char *path)
+int __connman_agent_unregister(const char *sender, const char *path)
 {
-	DBG("");
+	DBG("sender %s path %s", sender, path);
+
+	if (agent_path == NULL)
+		return -ENOENT;
+
+	if (agent_watch > 0)
+		g_dbus_remove_watch(connection, agent_watch);
+
+	agent_free();
 
 	return 0;
 }
 
-int __connman_agent_unregister(const char *path)
+int __connman_agent_init(DBusConnection *conn)
 {
-	DBG("");
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
 
 	return 0;
 }
+
+void __connman_agent_cleanup(void)
+{
+	DBusMessage *msg;
+
+	DBG("conn %p", connection);
+
+	if (agent_watch > 0)
+		g_dbus_remove_watch(connection, agent_watch);
+
+	msg = dbus_message_new_method_call(agent_sender, agent_path,
+					CONNMAN_AGENT_INTERFACE, "Release");
+
+	dbus_message_set_no_reply(msg, TRUE);
+
+	dbus_connection_send(connection, msg, NULL);
+
+	dbus_message_unref(msg);
+
+	agent_free();
+
+	dbus_connection_unref(connection);
+}
diff --git a/src/connman.h b/src/connman.h
index ff33489e..703b8c9c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -28,6 +28,8 @@
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
+#define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
+
 #define CONNMAN_MANAGER_PATH       "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 
@@ -42,11 +44,11 @@
 int __connman_manager_init(DBusConnection *conn, int compat);
 void __connman_manager_cleanup(void);
 
-int __connman_agent_init(void);
+int __connman_agent_init(DBusConnection *conn);
 void __connman_agent_cleanup(void);
 
-int __connman_agent_register(const char *path);
-int __connman_agent_unregister(const char *path);
+int __connman_agent_register(const char *sender, const char *path);
+int __connman_agent_unregister(const char *sender, const char *path);
 
 #include <connman/plugin.h>
 
diff --git a/src/main.c b/src/main.c
index 1b314db8..a54eaf6b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -120,7 +120,7 @@ int main(int argc, char *argv[])
 			compat = 0;
 	}
 
-	__connman_agent_init();
+	__connman_agent_init(conn);
 
 	__connman_manager_init(conn, compat);
 
diff --git a/src/manager.c b/src/manager.c
index 2a1a738f..11c25572 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -74,10 +74,12 @@ static DBusMessage *register_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *path;
+	const char *sender, *path;
 
 	DBG("conn %p", conn);
 
+	sender = dbus_message_get_sender(msg);
+
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
 
@@ -87,7 +89,7 @@ static DBusMessage *register_agent(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	__connman_agent_register(path);
+	__connman_agent_register(sender, path);
 
 	return reply;
 }
@@ -96,10 +98,12 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *path;
+	const char *sender, *path;
 
 	DBG("conn %p", conn);
 
+	sender = dbus_message_get_sender(msg);
+
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
 
@@ -109,7 +113,7 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	__connman_agent_unregister(path);
+	__connman_agent_unregister(sender, path);
 
 	return reply;
 }

commit 97697ebc4f19a72938252ea856d9e13a043ce0d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 16:10:56 2008 +0100

    Add documentation directory

diff --git a/Makefile.am b/Makefile.am
index de0e19be..35d8c884 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src test plugins scripts
+SUBDIRS = include src doc test plugins scripts
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index a5991e4d..9ecec4d6 100644
--- a/configure.in
+++ b/configure.in
@@ -61,5 +61,5 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile test/Makefile
-				plugins/Makefile scripts/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
+					plugins/Makefile scripts/Makefile)
diff --git a/doc/Makefile.am b/doc/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/doc/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in

commit 439bdfd6882e3632a4fe67f0d19801524a1c7d8d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 16:34:54 2008 +0100

    Add manager documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 02742923..fadc659d 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,2 +1,4 @@
 
+EXTRA_DIST = manager-api.txt
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
new file mode 100644
index 00000000..0d5fbfb8
--- /dev/null
+++ b/doc/manager-api.txt
@@ -0,0 +1,47 @@
+Manager hierarchy
+*****************
+
+Service name	org.freedesktop.connman
+Interface name	org.freedesktop.connman.Manager
+Object path	/
+
+Methods		array{object} ListInterfaces()
+		void RegisterAgent(object path)
+		void UnregisterAgent(object path)
+
+Signals		InterfaceAdded(object)
+		InterfaceRemoved(object)
+
+
+Method: ListInferfaces
+======================
+This method lists all available interfaces. The return value is an array of
+object paths. Every attached network interface (eth0, wlan0 etc.) of the
+system is presented by an object path with additional interfaces on it. The
+main interface is org.freedesktop.connman.Interface.
+
+Method: RegisterAgent
+=====================
+This method allows the user interace to register an agent. There can be only
+one agent registered at a time. The parameter of the method is the object
+path the agent has been registered for the callback method. The agent has
+to implement org.freedesktop.connman.Agent interface on this object path.
+
+Method: UnregisterAgent
+=======================
+This method unregisters a previously registered agent. In case the agent
+application exits the core will automatically unregister the agent. However
+for a clean agent application it is important to call the unregister method.
+
+Signal: InterfaceAdded
+======================
+This signal is emitted every time a new interface has been found by the
+core and successfully activated. The signal is also emitted on startup
+or at anytime at runtime in case of hotplug devices.
+
+Signal: InterfaceRemoved
+========================
+This signal is emitted every time an interface has been removed. This can
+happen at any time in case of hotplug devices. When the system shuts down,
+this signal is also emitted.
+

commit 2eed628fda87ad562d765c87a2d8330ee707ca3a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 19:18:50 2008 +0100

    Add initial interface documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index fadc659d..33cc0bdd 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt
+EXTRA_DIST = manager-api.txt interface-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/interface-api.txt b/doc/interface-api.txt
new file mode 100644
index 00000000..1b0d468a
--- /dev/null
+++ b/doc/interface-api.txt
@@ -0,0 +1,24 @@
+Interface hierarchy
+*******************
+
+Service name	org.freedesktop.connman
+Interface name	org.freedesktop.connman.Interface
+Object path	[interface object]
+
+Methods		dict GetProperties()
+		string GetState()
+		uint16 GetSignal()
+		string GetPolicy()
+		void SetPolicy(string policy)
+		dict GetNetwork()
+		void SetNetwork(dict network)
+		dict GetIPv4()
+		void SetIPv4(dict ipv4)
+
+Signals		StateChanged(string state)
+		SignalChanged(uint16 signal)
+		PolicyChanged(string policy)
+		NetworkFound(dict network)
+		NetworkChanged(dict network)
+		IPv4Changed(dict ipv4)
+

commit b627f1b548160dd36aa2edcb98aae210f483babe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 19:26:48 2008 +0100

    Add agent documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 33cc0bdd..04bffe2b 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt interface-api.txt
+EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/agent-api.txt b/doc/agent-api.txt
new file mode 100644
index 00000000..6a805e8d
--- /dev/null
+++ b/doc/agent-api.txt
@@ -0,0 +1,18 @@
+Agent hierarchy
+***************
+
+Service name	[unique name]
+Interface name	org.freedesktop.connman.Agent
+Object path	[random object]
+
+Methods		void Release()
+
+
+Method: Release
+===============
+This method will be called when the core releases the agent. This normally
+happens when the core shuts down.
+
+To get notified when the core exits, an agent should also watch out for the
+NameOwnerChanged from org.freedesktop.connman service.
+

commit cce41dad8e37117fa45bbc8e40f7c866612c6500
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 19:27:54 2008 +0100

    Remove last empty lines

diff --git a/doc/agent-api.txt b/doc/agent-api.txt
index 6a805e8d..27bd3219 100644
--- a/doc/agent-api.txt
+++ b/doc/agent-api.txt
@@ -15,4 +15,3 @@ happens when the core shuts down.
 
 To get notified when the core exits, an agent should also watch out for the
 NameOwnerChanged from org.freedesktop.connman service.
-
diff --git a/doc/interface-api.txt b/doc/interface-api.txt
index 1b0d468a..faee2033 100644
--- a/doc/interface-api.txt
+++ b/doc/interface-api.txt
@@ -21,4 +21,3 @@ Signals		StateChanged(string state)
 		NetworkFound(dict network)
 		NetworkChanged(dict network)
 		IPv4Changed(dict ipv4)
-
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 0d5fbfb8..9de15c30 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -44,4 +44,3 @@ Signal: InterfaceRemoved
 This signal is emitted every time an interface has been removed. This can
 happen at any time in case of hotplug devices. When the system shuts down,
 this signal is also emitted.
-

commit d9e03f2642a100bad7aeb290f68293abba21be2a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 18 22:45:31 2008 +0100

    Update for libgdbus API change

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index cc5efd86..211b84ef 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -279,7 +279,7 @@ static DBusConnection *connection;
 
 static int plugin_init(void)
 {
-	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL);
+	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL, NULL);
 
 	busname = dbus_bus_get_unique_name(connection);
 
diff --git a/src/main.c b/src/main.c
index a54eaf6b..0fcf614d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -68,6 +68,7 @@ static struct option options[] = {
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
+	DBusError err;
 	struct sigaction sa;
 	int log_option = LOG_NDELAY | LOG_PID;
 	int opt, detach = 1, compat = 0;
@@ -109,14 +110,20 @@ int main(int argc, char *argv[])
 
 	main_loop = g_main_loop_new(NULL, FALSE);
 
-	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
+	dbus_error_init(&err);
+
+	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE, &err);
 	if (conn == NULL) {
-		fprintf(stderr, "Can't register with system bus\n");
+		if (dbus_error_is_set(&err) == TRUE) {
+			fprintf(stderr, "%s\n", err.message);
+			dbus_error_free(&err);
+		} else
+			fprintf(stderr, "Can't register with system bus\n");
 		exit(1);
 	}
 
 	if (compat) {
-		if (g_dbus_request_name(conn, NM_SERVICE) == FALSE)
+		if (g_dbus_request_name(conn, NM_SERVICE, NULL) == FALSE)
 			compat = 0;
 	}
 

commit 5892fc367065eb79210359008da69887322327fa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 18 22:48:34 2008 +0100

    Fix 32-bit/64-bit format string issues

diff --git a/src/rtnl.c b/src/rtnl.c
index 3e26dbff..952f09b3 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -57,30 +57,30 @@ static inline void print_inet(struct rtattr *attr, const char *name, int family)
 	if (family == AF_INET) {
 		struct in_addr addr;
 		addr = *((struct in_addr *) RTA_DATA(attr));
-		printf("  attr %s (len %d) %s\n",
+		printf("  attr %s (len %jd) %s\n",
 				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
 	} else
-		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
+		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 }
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
+	printf("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_byte(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %d) 0x%02x\n", name, RTA_PAYLOAD(attr),
+	printf("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
 					*((unsigned char *) RTA_DATA(attr)));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
+		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 	else
-		printf("  attr %d (len %d)\n",
+		printf("  attr %d (len %jd)\n",
 					attr->rta_type, RTA_PAYLOAD(attr));
 }
 
@@ -286,7 +286,7 @@ static void rtnl_route(struct nlmsghdr *hdr)
 
 static void rtnl_message(void *buf, size_t len)
 {
-	DBG("buf %p len %d", buf, len);
+	DBG("buf %p len %zd", buf, len);
 
 	while (len > 0) {
 		struct nlmsghdr *hdr = buf;
@@ -379,7 +379,7 @@ int __connman_rtnl_send(const void *buf, size_t len)
 	struct sockaddr_nl addr;
 	int sk;
 
-	DBG("buf %p len %d", buf, len);
+	DBG("buf %p len %zd", buf, len);
 
 	sk = g_io_channel_unix_get_fd(channel);
 

commit 828ad7d4f5f678c2c92b9400a58f62bfaa0cd64f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 20 03:08:15 2008 +0100

    Add .gitignore file

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..f29ae7f0
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,26 @@
+*.o
+*.lo
+*.la
+.deps
+.libs
+Makefile
+Makefile.in
+aclocal.m4
+config.guess
+config.h
+config.h.in
+config.log
+config.status
+config.sub
+configure
+depcomp
+install-sh
+libtool
+ltmain.sh
+missing
+stamp-h1
+autom4te.cache
+
+include/connman
+src/connmand
+scripts/dhclient-script

commit 84deb674a0c3511dd4eee17d47ca07a4f51ba396
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 22 05:36:19 2008 +0100

    Add basic init script

diff --git a/.gitignore b/.gitignore
index f29ae7f0..d2429679 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,4 +23,5 @@ autom4te.cache
 
 include/connman
 src/connmand
+scripts/connman
 scripts/dhclient-script
diff --git a/configure.in b/configure.in
index 9ecec4d6..0c61409f 100644
--- a/configure.in
+++ b/configure.in
@@ -62,4 +62,4 @@ AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
-					plugins/Makefile scripts/Makefile)
+			plugins/Makefile scripts/Makefile scripts/connman)
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index bb79358e..1247398f 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -1,4 +1,10 @@
 
+initdir = $(sysconfdir)/init.d
+
+init_SCRIPTS = connman
+
+DISTCLEANFILES = $(init_SCRIPTS)
+
 scriptdir = $(libdir)/connman/scripts
 
 script_DATA = dhclient.conf
diff --git a/scripts/connman.in b/scripts/connman.in
new file mode 100644
index 00000000..a67f6673
--- /dev/null
+++ b/scripts/connman.in
@@ -0,0 +1,49 @@
+#!/bin/sh
+
+DAEMON=@prefix@/sbin/connmand
+PIDFILE=@localstatedir@/run/connmand.pid
+DESC="Connection Manager"
+
+. /lib/lsb/init-functions
+
+if [ -f @sysconfdir@/default/connman ] ; then
+	. @sysconfdir@/default/connman
+fi
+
+set -e
+
+do_start() {
+	start-stop-daemon --start --oknodo \
+		--pidfile $PIDFILE --exec $DAEMON -- $DAEMON_OPTS
+}
+
+do_stop() {
+	start-stop-daemon --stop --oknodo --quiet \
+		--pidfile $PIDFILE --exec $DAEMON
+}
+
+case "$1" in
+  start)
+	log_daemon_msg "Starting $DESC"
+	do_start
+	log_end_msg $?
+	;;
+  stop)
+	log_daemon_msg "Stopping $DESC"
+	do_stop
+	log_end_msg $?
+	;;
+  restart|force-reload)
+	log_daemon_msg "Restarting $DESC"
+	do_stop
+	sleep 1
+	do_start
+	log_end_msg $?
+	;;
+  *)
+	log_success_msg "Usage: $0 {start|stop|restart|force-reload}" >&2
+	exit 1
+	;;
+esac
+
+exit 0

commit dafd72419a43e2b5a0243d4b61372ca83747883f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 22 08:42:19 2008 +0100

    Add logging infrastructure

diff --git a/include/Makefile.am b/include/Makefile.am
index 2d28a822..ecca9287 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h iface.h rtnl.h dhcp.h
+noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/log.h b/include/log.h
new file mode 100644
index 00000000..e87e38ad
--- /dev/null
+++ b/include/log.h
@@ -0,0 +1,39 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_LOG_H
+#define __CONNMAN_LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DBG(fmt, arg...) connman_debug(fmt, ## arg)
+
+extern void connman_info(const char *format, ...);
+extern void connman_error(const char *format, ...);
+extern void connman_debug(const char *format, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_LOG_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 1a09a0f8..516c1b8b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,9 +5,9 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h manager.c agent.c plugin.c \
-			iface.c iface-storage.c iface-helper.c \
-					iface-inet.c rtnl.c dhcp.c
+connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
+				iface.c iface-storage.c iface-helper.c \
+						iface-inet.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 703b8c9c..da1693b1 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -21,9 +21,6 @@
 
 #include <stdio.h>
 
-#define DBG(fmt, arg...)  printf("%s: " fmt "\n" , __FUNCTION__ , ## arg)
-//#define DBG(fmt, arg...)
-
 #include <dbus/dbus.h>
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
@@ -50,6 +47,11 @@ void __connman_agent_cleanup(void);
 int __connman_agent_register(const char *sender, const char *path);
 int __connman_agent_unregister(const char *sender, const char *path);
 
+#include <connman/log.h>
+
+int __connman_log_init(int syslog, int debug);
+void __connman_log_cleanup(void);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/log.c b/src/log.c
new file mode 100644
index 00000000..867928ce
--- /dev/null
+++ b/src/log.c
@@ -0,0 +1,90 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdarg.h>
+#include <syslog.h>
+
+#include "connman.h"
+
+static volatile int debug_enabled = 0;
+
+void connman_info(const char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+
+	vsyslog(LOG_INFO, format, ap);
+
+	va_end(ap);
+}
+
+void connman_error(const char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+
+	vsyslog(LOG_ERR, format, ap);
+
+	va_end(ap);
+}
+
+void connman_debug(const char *format, ...)
+{
+	va_list ap;
+
+	if (!debug_enabled)
+		return;
+
+	va_start(ap, format);
+
+	vsyslog(LOG_DEBUG, format, ap);
+
+	va_end(ap);
+}
+
+int __connman_log_init(int syslog, int debug)
+{
+	int option = LOG_NDELAY | LOG_PID;
+
+	if (!syslog)
+		option |= LOG_PERROR;
+
+	openlog("connmand", option, LOG_DAEMON);
+
+	syslog(LOG_INFO, "Connection Manager version %s", VERSION);
+
+	debug_enabled = debug;
+
+	return 0;
+}
+
+void __connman_log_cleanup(void)
+{
+	syslog(LOG_INFO, "Exit");
+
+	closelog();
+}
diff --git a/src/main.c b/src/main.c
index 0fcf614d..a4962b2a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -27,7 +27,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
-#include <syslog.h>
 #include <signal.h>
 #include <getopt.h>
 #include <sys/stat.h>
@@ -61,6 +60,7 @@ static void usage(void)
 static struct option options[] = {
 	{ "nodaemon", 0, 0, 'n' },
 	{ "compat",   0, 0, 'c' },
+	{ "debug",    0, 0, 'd' },
 	{ "help",     0, 0, 'h' },
 	{ }
 };
@@ -70,17 +70,19 @@ int main(int argc, char *argv[])
 	DBusConnection *conn;
 	DBusError err;
 	struct sigaction sa;
-	int log_option = LOG_NDELAY | LOG_PID;
-	int opt, detach = 1, compat = 0;
+	int opt, detach = 1, compat = 0, debug = 0;
 
-	while ((opt = getopt_long(argc, argv, "+nch", options, NULL)) != EOF) {
-		switch(opt) {
+	while ((opt = getopt_long(argc, argv, "+ncdh", options, NULL)) != EOF) {
+		switch (opt) {
 		case 'n':
 			detach = 0;
 			break;
 		case 'c':
 			compat = 1;
 			break;
+		case 'd':
+			debug = 1;
+			break;
 		case 'h':
 		default:
 			usage();
@@ -97,10 +99,7 @@ int main(int argc, char *argv[])
 			perror("Can't start daemon");
 			exit(1);
 		}
-	} else
-		log_option |= LOG_PERROR;
-
-	openlog("connmand", log_option, LOG_DAEMON);
+	}
 
 	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
@@ -127,6 +126,8 @@ int main(int argc, char *argv[])
 			compat = 0;
 	}
 
+	__connman_log_init(detach, debug);
+
 	__connman_agent_init(conn);
 
 	__connman_manager_init(conn, compat);
@@ -154,6 +155,8 @@ int main(int argc, char *argv[])
 
 	__connman_agent_cleanup();
 
+	__connman_log_cleanup();
+
 	g_dbus_cleanup_connection(conn);
 
 	g_main_loop_unref(main_loop);
@@ -162,7 +165,5 @@ int main(int argc, char *argv[])
 
 	rmdir(STATEDIR);
 
-	closelog();
-
 	return 0;
 }

commit 46a64b472133cce416bd49e00a2cd3c7a2bd7c53
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 05:26:36 2008 +0100

    Include function name in debug message

diff --git a/include/log.h b/include/log.h
index e87e38ad..bf0dab50 100644
--- a/include/log.h
+++ b/include/log.h
@@ -26,7 +26,7 @@
 extern "C" {
 #endif
 
-#define DBG(fmt, arg...) connman_debug(fmt, ## arg)
+#define DBG(fmt, arg...) connman_debug("%s: " fmt, __FUNCTION__ , ## arg)
 
 extern void connman_info(const char *format, ...);
 extern void connman_error(const char *format, ...);

commit aa987a9aea8a69d172bee003261abe7859a5ad7d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 05:29:33 2008 +0100

    Detect bridge interfaces and ignore them

diff --git a/plugins/80203.c b/plugins/80203.c
index d916c970..b4d67457 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -24,14 +24,24 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
+#include <sys/stat.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
 static int iface_probe(struct connman_iface *iface)
 {
+	char sysfs_path[PATH_MAX];
+	struct stat st;
+
 	printf("[802.03] probe interface index %d\n", iface->index);
 
+	snprintf(sysfs_path, PATH_MAX, "%s/bridge", iface->sysfs);
+
+	if (stat(sysfs_path, &st) == 0 && (st.st_mode & S_IFDIR))
+		return -ENODEV;
+
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |

commit ba0da2f37c8a562684c58595e9a21c1cf96a3765
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 06:00:50 2008 +0100

    Use separate storage files for each interface

diff --git a/src/iface-storage.c b/src/iface-storage.c
index ad2cfc5a..0f14ebd0 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -30,6 +30,8 @@
 
 #include "connman.h"
 
+#define GROUP_CONFIG  "Config"
+
 int __connman_iface_load(struct connman_iface *iface)
 {
 	GKeyFile *keyfile;
@@ -40,7 +42,8 @@ int __connman_iface_load(struct connman_iface *iface)
 	if (iface->identifier == NULL)
 		return -EIO;
 
-	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
 	if (pathname == NULL)
 		return -ENOMEM;
 
@@ -49,16 +52,16 @@ int __connman_iface_load(struct connman_iface *iface)
 	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
 		goto done;
 
-	if (g_key_file_has_group(keyfile, iface->identifier) == FALSE)
+	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
 		goto done;
 
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"Policy", NULL);
+	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Policy", NULL);
 	if (str != NULL) {
 		iface->policy = __connman_iface_string2policy(str);
 		g_free(str);
 	}
 
+#if 0
 	str = g_key_file_get_string(keyfile, iface->identifier,
 							"Network.ESSID", NULL);
 	if (str != NULL) {
@@ -95,6 +98,7 @@ int __connman_iface_load(struct connman_iface *iface)
 		iface->ipv4.gateway.s_addr = inet_addr(str);
 		g_free(str);
 	}
+#endif
 
 done:
 	g_key_file_free(keyfile);
@@ -107,22 +111,13 @@ done:
 static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 {
 	const char *str;
-	gchar *comment;
 
 	DBG("iface %p", iface);
 
-	comment = g_key_file_get_comment(keyfile,
-					iface->identifier, NULL, NULL);
-	if (comment == NULL || *comment == '\0') {
-		if (iface->device.product != NULL)
-			g_key_file_set_comment(keyfile, iface->identifier,
-					NULL, iface->device.product, NULL);
-	}
-	g_free(comment);
-
 	str = __connman_iface_policy2string(iface->policy);
-	g_key_file_set_string(keyfile, iface->identifier, "Policy", str);
+	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
 
+#if 0
 	if (iface->network.essid != NULL) {
 		g_key_file_set_string(keyfile, iface->identifier,
 					"Network.ESSID", iface->network.essid);
@@ -161,6 +156,7 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	} else
 		g_key_file_remove_key(keyfile, iface->identifier,
 							"IPv4.Gateway", NULL);
+#endif
 }
 
 int __connman_iface_store(struct connman_iface *iface)
@@ -174,14 +170,15 @@ int __connman_iface_store(struct connman_iface *iface)
 	if (iface->identifier == NULL)
 		return -EIO;
 
-	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
 	if (pathname == NULL)
 		return -ENOMEM;
 
 	keyfile = g_key_file_new();
 
 	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
-		goto done;
+		goto update;
 
 	if (length > 0) {
 		if (g_key_file_load_from_data(keyfile, data, length,
@@ -191,6 +188,7 @@ int __connman_iface_store(struct connman_iface *iface)
 
 	g_free(data);
 
+update:
 	do_update(keyfile, iface);
 
 	data = g_key_file_to_data(keyfile, &length, NULL);

commit 09f4164cb5a096a6200736247c9ba4493d50e270
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 06:42:59 2008 +0100

    Fix agent cleanup function

diff --git a/src/agent.c b/src/agent.c
index 4765868d..b7db03c6 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -107,8 +107,13 @@ void __connman_agent_cleanup(void)
 	if (agent_watch > 0)
 		g_dbus_remove_watch(connection, agent_watch);
 
+	if (agent_path == NULL)
+		return;
+
 	msg = dbus_message_new_method_call(agent_sender, agent_path,
 					CONNMAN_AGENT_INTERFACE, "Release");
+	if (msg == NULL)
+		return;
 
 	dbus_message_set_no_reply(msg, TRUE);
 

commit 9d5d36d8f73dcf43fa562c327b33653ef7f7cdf9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:15:00 2008 +0100

    Add example for showing interfaces

diff --git a/test/Makefile.am b/test/Makefile.am
index 02742923..0649dab2 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,2 +1,4 @@
 
+EXTRA_DIST = list-interfaces
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/list-interfaces b/test/list-interfaces
new file mode 100755
index 00000000..2cd0424d
--- /dev/null
+++ b/test/list-interfaces
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	print "[ %s ]" % (path)
+
+	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.connman.Interface')
+
+	properties = interface.GetProperties()
+	for key in properties.keys():
+		print "    %s = %s" % (key, properties[key])
+
+	ipv4 = interface.GetIPv4()
+	for key in ipv4.keys():
+		print "    IPv4.%s = %s" % (key, ipv4[key])
+
+	print

commit b530bfa969ba35511a206dd2aca3e6bd0d4d0aea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:17:53 2008 +0100

    Add example for starting scanning

diff --git a/test/Makefile.am b/test/Makefile.am
index 0649dab2..ca88b98b 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = list-interfaces
+EXTRA_DIST = list-interfaces start-scanning
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/start-scanning b/test/start-scanning
new file mode 100755
index 00000000..712b3e93
--- /dev/null
+++ b/test/start-scanning
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	print "[ %s ]" % (path)
+
+	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.connman.Interface')
+
+	properties = interface.GetProperties()
+
+	if (properties["Type"] == "80211"):
+		print "   Started scanning"
+		interface.Scan()
+	else:
+		print "   No scanning"
+
+	print

commit 99cf3b6bbc863da93dc5af464e0211217d280ccb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:21:55 2008 +0100

    Add example for a simple agent

diff --git a/test/Makefile.am b/test/Makefile.am
index ca88b98b..8f8214f4 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = list-interfaces start-scanning
+EXTRA_DIST = list-interfaces start-scanning simple-agent
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/simple-agent b/test/simple-agent
new file mode 100755
index 00000000..47a61f62
--- /dev/null
+++ b/test/simple-agent
@@ -0,0 +1,31 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+
+class Agent(dbus.service.Object):
+	@dbus.service.method("org.freedesktop.connman.Agent",
+					in_signature='', out_signature='')
+	def Release(self):
+		print("Release")
+		mainloop.quit()
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+	manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+	path = "/test/agent"
+	object = Agent(bus, path)
+
+	manager.RegisterAgent(path)
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()
+
+	#manager.UnregisterAgent(path)

commit 2363421b798c295d226037defb96583ecf153b34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:26:42 2008 +0100

    Add constant for user confirmation policy

diff --git a/include/iface.h b/include/iface.h
index 6a80178a..5d0a7e7a 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -62,6 +62,7 @@ enum connman_iface_policy {
 	CONNMAN_IFACE_POLICY_OFF     = 1,
 	CONNMAN_IFACE_POLICY_IGNORE  = 2,
 	CONNMAN_IFACE_POLICY_AUTO    = 3,
+	CONNMAN_IFACE_POLICY_ASK     = 4,
 };
 
 enum connman_ipv4_method {
diff --git a/src/iface-helper.c b/src/iface-helper.c
index 06642fb5..7e177198 100644
--- a/src/iface-helper.c
+++ b/src/iface-helper.c
@@ -86,6 +86,8 @@ const char *__connman_iface_policy2string(enum connman_iface_policy policy)
 		return "ignore";
 	case CONNMAN_IFACE_POLICY_AUTO:
 		return "auto";
+	case CONNMAN_IFACE_POLICY_ASK:
+		return "ask";
 	}
 
 	return "unknown";
@@ -99,6 +101,8 @@ enum connman_iface_policy __connman_iface_string2policy(const char *policy)
 		return CONNMAN_IFACE_POLICY_IGNORE;
 	else if (strcasecmp(policy, "auto") == 0)
 		return CONNMAN_IFACE_POLICY_AUTO;
+	else if (strcasecmp(policy, "ask") == 0)
+		return CONNMAN_IFACE_POLICY_ASK;
 	else
 		return CONNMAN_IFACE_POLICY_UNKNOWN;
 }

commit 01dbb962cbb1ea6871ad1ee0c73461cd68511745
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:41:16 2008 +0100

    Rename syslog parameter

diff --git a/src/connman.h b/src/connman.h
index da1693b1..76bffe55 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -49,7 +49,7 @@ int __connman_agent_unregister(const char *sender, const char *path);
 
 #include <connman/log.h>
 
-int __connman_log_init(int syslog, int debug);
+int __connman_log_init(int detach, int debug);
 void __connman_log_cleanup(void);
 
 #include <connman/plugin.h>
diff --git a/src/log.c b/src/log.c
index 867928ce..83466d22 100644
--- a/src/log.c
+++ b/src/log.c
@@ -66,11 +66,11 @@ void connman_debug(const char *format, ...)
 	va_end(ap);
 }
 
-int __connman_log_init(int syslog, int debug)
+int __connman_log_init(int detach, int debug)
 {
 	int option = LOG_NDELAY | LOG_PID;
 
-	if (!syslog)
+	if (!detach)
 		option |= LOG_PERROR;
 
 	openlog("connmand", option, LOG_DAEMON);

commit 49b002eae97659e1ffc06fd7d49a1413b6a8296c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:22:00 2008 +0100

    Fix ESSID parsing on 64-bit architectures

diff --git a/plugins/80211.c b/plugins/80211.c
index 53b36b60..0434b8c1 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -366,11 +366,12 @@ static void parse_scan_results(struct connman_iface *iface,
 			break;
 		case SIOCGIWESSID:
 			if (station != NULL) {
-				station->name = malloc(event->len - 7);
+				station->name = malloc(event->len - IW_EV_POINT_LEN + 1);
 				if (station->name != NULL) {
-					memset(station->name, 0, event->len - 7);
-					memcpy(station->name, ptr + 8,
-								event->len - 8);
+					memset(station->name, 0,
+						event->len - IW_EV_POINT_LEN + 1);
+					memcpy(station->name, ptr + IW_EV_POINT_LEN,
+						event->len - IW_EV_POINT_LEN);
 				}
 			}
 			break;
@@ -462,7 +463,7 @@ static void iface_scan_results(struct connman_iface *iface)
 				done = 1;
 		} else {
 			parse_scan_results(iface, iwr.u.data.pointer,
-						iwr.u.data.length);
+							iwr.u.data.length);
 			done = 1;
 		}
 	}

commit 0b7a3348208dfc4981a48bc22bf783c5d55e5b96
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:33:18 2008 +0100

    Add support for storing last network and passphrases

diff --git a/src/iface-storage.c b/src/iface-storage.c
index 0f14ebd0..750aa43e 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -61,44 +61,22 @@ int __connman_iface_load(struct connman_iface *iface)
 		g_free(str);
 	}
 
-#if 0
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"Network.ESSID", NULL);
+	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Network", NULL);
 	if (str != NULL) {
 		g_free(iface->network.essid);
 		iface->network.essid = str;
 		if (iface->driver->set_network)
 			iface->driver->set_network(iface, str);
-	}
-
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Method", NULL);
-	if (str != NULL) {
-		iface->ipv4.method = __connman_ipv4_string2method(str);
-		g_free(str);
-	}
-
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Address", NULL);
-	if (str != NULL) {
-		iface->ipv4.address.s_addr = inet_addr(str);
-		g_free(str);
-	}
-
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Netmask", NULL);
-	if (str != NULL) {
-		iface->ipv4.netmask.s_addr = inet_addr(str);
-		g_free(str);
-	}
 
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Gateway", NULL);
-	if (str != NULL) {
-		iface->ipv4.gateway.s_addr = inet_addr(str);
-		g_free(str);
+		str = g_key_file_get_string(keyfile, iface->network.essid,
+								"PSK", NULL);
+		if (str != NULL) {
+			g_free(iface->network.psk);
+			iface->network.psk = str;
+			if (iface->driver->set_passphrase)
+				iface->driver->set_passphrase(iface, str);
+		}
 	}
-#endif
 
 done:
 	g_key_file_free(keyfile);
@@ -117,46 +95,15 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	str = __connman_iface_policy2string(iface->policy);
 	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
 
-#if 0
 	if (iface->network.essid != NULL) {
-		g_key_file_set_string(keyfile, iface->identifier,
-					"Network.ESSID", iface->network.essid);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"Network.ESSID", NULL);
-
-	if (iface->ipv4.method != CONNMAN_IPV4_METHOD_UNKNOWN) {
-		str = __connman_ipv4_method2string(iface->ipv4.method);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Method", str);
+		g_key_file_set_string(keyfile, GROUP_CONFIG,
+					"Network", iface->network.essid);
 	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Method", NULL);
+		g_key_file_remove_key(keyfile, GROUP_CONFIG, "Network", NULL);
 
-	if (iface->ipv4.address.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.address);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Address", str);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Address", NULL);
-
-	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.netmask);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Netmask", str);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Netmask", NULL);
-
-	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.gateway);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Gateway", str);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Gateway", NULL);
-#endif
+	if (iface->network.essid != NULL)
+		g_key_file_set_string(keyfile, iface->network.essid,
+						"PSK", iface->network.psk);
 }
 
 int __connman_iface_store(struct connman_iface *iface)

commit a88c950e23edd63ba4b3e8db414633f2a9449de4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:39:36 2008 +0100

    Add supplicant disconnect function

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 3c02abd8..b30b16cb 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -269,6 +269,9 @@ int __supplicant_connect(struct connman_iface *iface,
 
 	exec_cmd(task, "DISABLE_NETWORK 0");
 
+	if (network == NULL)
+		return 0;
+
 	sprintf(cmd, "SET_NETWORK 0 ssid \"%s\"", network);
 	exec_cmd(task, cmd);
 
@@ -287,3 +290,18 @@ int __supplicant_connect(struct connman_iface *iface,
 
 	return 0;
 }
+
+int __supplicant_disconnect(struct connman_iface *iface)
+{
+	struct supplicant_task *task;
+
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
+
+	printf("[SUPPLICANT] disconnect %s\n", task->ifname);
+
+	exec_cmd(task, "DISABLE_NETWORK 0");
+
+	return 0;
+}
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 9e5ebc67..dc015ed7 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -26,3 +26,4 @@ int __supplicant_stop(struct connman_iface *iface);
 
 int __supplicant_connect(struct connman_iface *iface,
 				const char *network, const char *passphrase);
+int __supplicant_disconnect(struct connman_iface *iface);

commit b9ff5385d914dbfde5543675569ee8b32c5d5a85
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:48:13 2008 +0100

    Fix reconnect case when ESSID or PSK changes

diff --git a/plugins/80211.c b/plugins/80211.c
index 0434b8c1..a3d5111a 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -272,7 +272,8 @@ static int iface_connect(struct connman_iface *iface,
 
 	__supplicant_start(iface);
 
-	__supplicant_connect(iface, data->network, data->passphrase);
+	if (data->network != NULL)
+		__supplicant_connect(iface, data->network, data->passphrase);
 
 	return 0;
 }
@@ -283,6 +284,9 @@ static int iface_disconnect(struct connman_iface *iface)
 
 	printf("[802.11] disconnect %s\n", data->ifname);
 
+	if (data->network != NULL)
+		__supplicant_disconnect(iface);
+
 	__supplicant_stop(iface);
 
 	return 0;
@@ -295,9 +299,15 @@ static void iface_set_network(struct connman_iface *iface,
 
 	printf("[802.11] set network %s\n", data->ifname);
 
+	if (data->network != NULL)
+		__supplicant_disconnect(iface);
+
 	g_free(data->network);
 
 	data->network = g_strdup(network);
+
+	if (data->network != NULL)
+		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void iface_set_passphrase(struct connman_iface *iface,
@@ -307,9 +317,15 @@ static void iface_set_passphrase(struct connman_iface *iface,
 
 	printf("[802.11] set passphrase %s\n", data->ifname);
 
+	if (data->network != NULL)
+		__supplicant_disconnect(iface);
+
 	g_free(data->passphrase);
 
 	data->passphrase = g_strdup(passphrase);
+
+	if (data->network != NULL)
+		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void parse_genie(struct station_data *station,

commit 225ed69e17d41b06aa293b05387cd82924f30705
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 09:35:34 2008 +0100

    Add support for indicating security methods

diff --git a/include/iface.h b/include/iface.h
index 5d0a7e7a..e5fb05d4 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -155,7 +155,7 @@ extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
 extern void connman_iface_indicate_configured(struct connman_iface *iface);
 
 extern void connman_iface_indicate_station(struct connman_iface *iface,
-						const char *name, int strength);
+				const char *name, int strength, int security);
 
 extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
diff --git a/plugins/80211.c b/plugins/80211.c
index a3d5111a..eaec342d 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -54,6 +54,10 @@ struct station_data {
 	int wpa_ie_len;
 	unsigned char rsn_ie[40];
 	int rsn_ie_len;
+
+	int has_wep;
+	int has_wpa;
+	int has_rsn;
 };
 
 struct iface_data {
@@ -67,13 +71,23 @@ struct iface_data {
 static void report_station(struct connman_iface *iface,
 						struct station_data *station)
 {
+	int security = 0;
+
 	if (station == NULL)
 		return;
 
 	if (station->name == NULL)
 		return;
 
-	connman_iface_indicate_station(iface, station->name, station->qual);
+	if (station->has_wep)
+		security |= 0x01;
+	if (station->has_wpa)
+		security |= 0x02;
+	if (station->has_rsn)
+		security |= 0x04;
+
+	connman_iface_indicate_station(iface, station->name,
+						station->qual, security);
 }
 
 static struct station_data *create_station(struct iface_data *iface,
@@ -157,6 +171,9 @@ static void print_stations(struct iface_data *iface)
 		//			station->address, station->mode,
 		//				station->name, station->qual);
 
+		if (station->name == NULL)
+			continue;
+
 		g_key_file_set_string(keyfile, station->address,
 						"Name", station->name);
 
@@ -338,8 +355,10 @@ static void parse_genie(struct station_data *station,
 
 		switch (data[offset]) {
 		case 0xdd:	/* WPA1 (and other) */
+			station->has_wpa = 1;
 			break;
 		case 0x30:	/* WPA2 (RSN) */
+			station->has_rsn = 1;
 			break;
 		default:
 			break;
@@ -401,9 +420,8 @@ static void parse_scan_results(struct connman_iface *iface,
 			break;
 		case SIOCGIWENCODE:
 			if (station != NULL) {
-				if (!(event->u.data.flags & IW_ENCODE_DISABLED)) {
-					/* privacy */
-				}
+				if (!(event->u.data.flags & IW_ENCODE_DISABLED))
+					station->has_wep = 1;
 			}
 			break;
 		case SIOCGIWRATE:
diff --git a/src/iface.c b/src/iface.c
index a412dab4..2d45a223 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -289,9 +289,11 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	}
 }
 
-static void append_station(DBusMessage *reply, const char *name, int signal)
+static void append_station(DBusMessage *reply, const char *name,
+						int signal, int security)
 {
 	DBusMessageIter array, dict;
+	const char *wpa = "WPA";
 
 	dbus_message_iter_init_append(reply, &array);
 
@@ -303,22 +305,28 @@ static void append_station(DBusMessage *reply, const char *name, int signal)
 	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
 	append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
 
+	if (security > 0)
+		append_entry(&dict, "Security", DBUS_TYPE_STRING, &wpa);
+
 	dbus_message_iter_close_container(&array, &dict);
 }
 
 void connman_iface_indicate_station(struct connman_iface *iface,
-						const char *name, int strength)
+				const char *name, int strength, int security)
 {
 	DBusMessage *signal;
 
-	DBG("iface %p name %s", iface, name);
+	DBG("iface %p security %d name %s", iface, security, name);
+
+	if (name == NULL || strlen(name) == 0)
+		return;
 
 	signal = dbus_message_new_signal(iface->path,
 				CONNMAN_IFACE_INTERFACE, "NetworkFound");
 	if (signal == NULL)
 		return;
 
-	append_station(signal, name, strength);
+	append_station(signal, name, strength, security);
 
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);

commit 4bfbc81069e03dd3533ddae2e435cbf5d4eada65
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 10:36:58 2008 +0100

    Add example for showing the full introspection data

diff --git a/test/Makefile.am b/test/Makefile.am
index 8f8214f4..f3ae1831 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = list-interfaces start-scanning simple-agent
+EXTRA_DIST = list-interfaces start-scanning simple-agent show-introspection
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/show-introspection b/test/show-introspection
new file mode 100755
index 00000000..9acdd112
--- /dev/null
+++ b/test/show-introspection
@@ -0,0 +1,21 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+object = dbus.Interface(bus.get_object('org.freedesktop.connman', '/'),
+				'org.freedesktop.DBus.Introspectable')
+
+print object.Introspect()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	object = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.DBus.Introspectable')
+
+	print object.Introspect()

commit 2cb57fdad6fa5716d8cd89d691857484a615ce37
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 27 03:17:54 2008 +0100

    Enable scanning flag and fix connect/disconnect handling

diff --git a/plugins/80211.c b/plugins/80211.c
index eaec342d..2e8968e8 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -221,7 +221,8 @@ static int iface_probe(struct connman_iface *iface)
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4;
+				CONNMAN_IFACE_FLAG_IPV4 |
+				CONNMAN_IFACE_FLAG_SCANNING;
 
 	connman_iface_set_data(iface, data);
 
@@ -316,15 +317,9 @@ static void iface_set_network(struct connman_iface *iface,
 
 	printf("[802.11] set network %s\n", data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_disconnect(iface);
-
 	g_free(data->network);
 
 	data->network = g_strdup(network);
-
-	if (data->network != NULL)
-		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void iface_set_passphrase(struct connman_iface *iface,
@@ -334,15 +329,9 @@ static void iface_set_passphrase(struct connman_iface *iface,
 
 	printf("[802.11] set passphrase %s\n", data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_disconnect(iface);
-
 	g_free(data->passphrase);
 
 	data->passphrase = g_strdup(passphrase);
-
-	if (data->network != NULL)
-		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void parse_genie(struct station_data *station,
@@ -420,6 +409,9 @@ static void parse_scan_results(struct connman_iface *iface,
 			break;
 		case SIOCGIWENCODE:
 			if (station != NULL) {
+				if (!event->u.data.pointer)
+					event->u.data.flags |= IW_ENCODE_NOKEY;
+
 				if (!(event->u.data.flags & IW_ENCODE_DISABLED))
 					station->has_wep = 1;
 			}

commit 31aa9d82e49506eb06210ea000e1eb69893292f9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 27 11:18:48 2008 +0100

    Update state machine for interfaces

diff --git a/src/iface.c b/src/iface.c
index 2d45a223..c88408df 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -126,6 +126,23 @@ static void append_entry(DBusMessageIter *dict,
 	dbus_message_iter_close_container(dict, &entry);
 }
 
+static gboolean scan_timeout(gpointer user_data)
+{
+	struct connman_iface *iface = user_data;
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_SCANNING:
+	case CONNMAN_IFACE_STATE_READY:
+		if (iface->driver->scan)
+			iface->driver->scan(iface);
+		return TRUE;
+	default:
+		break;
+	}
+
+	return FALSE;
+}
+
 static void state_changed(struct connman_iface *iface)
 {
 	const char *str = __connman_iface_state2string(iface->state);
@@ -145,13 +162,16 @@ static void state_changed(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_ENABLED:
 		__connman_dhcp_release(iface);
 		connman_iface_clear_ipv4(iface);
-		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
 			state = CONNMAN_IFACE_STATE_SCANNING;
-			if (iface->driver->connect) {
-				iface->driver->connect(iface, NULL);
-				state = CONNMAN_IFACE_STATE_CONNECT;
-			}
-		}
+		break;
+
+	case CONNMAN_IFACE_STATE_SCANNING:
+		if (iface->driver->scan)
+			iface->driver->scan(iface);
+		g_timeout_add(8000, scan_timeout, iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
@@ -171,6 +191,11 @@ static void state_changed(struct connman_iface *iface)
 			state = CONNMAN_IFACE_STATE_OFF;
 		break;
 
+	case CONNMAN_IFACE_STATE_READY:
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
+			g_timeout_add(20000, scan_timeout, iface);
+		break;
+
 	default:
 		break;
 	}
@@ -225,7 +250,11 @@ void connman_iface_indicate_disabled(struct connman_iface *iface)
 {
 	DBG("iface %p state %d", iface, iface->state);
 
-	iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+		__connman_iface_up(iface);
+	} else
+		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 	state_changed(iface);
 }
 
@@ -267,7 +296,14 @@ void connman_iface_indicate_carrier_off(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_CARRIER:
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 	case CONNMAN_IFACE_STATE_READY:
-		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+#if 0
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING) {
+			if (iface->driver->disconnect)
+				iface->driver->disconnect(iface);
+			iface->state = CONNMAN_IFACE_STATE_SCANNING;
+		} else
+#endif
+			iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
 	default:
@@ -330,6 +366,21 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
+
+	if (g_str_equal(name, iface->network.essid) == TRUE &&
+			iface->state == CONNMAN_IFACE_STATE_SCANNING) {
+		if (iface->driver->set_network)
+			iface->driver->set_network(iface, name);
+		if (iface->driver->set_passphrase)
+			iface->driver->set_passphrase(iface,
+						iface->network.psk);
+
+		if (iface->driver->connect) {
+			iface->driver->connect(iface, NULL);
+			iface->state = CONNMAN_IFACE_STATE_CONNECT;
+			state_changed(iface);
+		}
+	}
 }
 
 int connman_iface_get_ipv4(struct connman_iface *iface,
@@ -509,8 +560,8 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->scan)
-		driver->scan(iface);
+	//if (driver->scan)
+	//	driver->scan(iface);
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
@@ -755,7 +806,7 @@ static DBusMessage *set_network(DBusConnection *conn,
 		if (g_strcasecmp(key, "PSK") == 0) {
 			g_free(iface->network.psk);
 			iface->network.psk = g_strdup(val);
-			if (iface->driver->set_network)
+			if (iface->driver->set_passphrase)
 				iface->driver->set_passphrase(iface, val);
 			changed = TRUE;
 		}
@@ -784,6 +835,33 @@ static DBusMessage *set_network(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *select_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	const char *network;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+							DBUS_TYPE_INVALID);
+
+	g_free(iface->network.essid);
+	iface->network.essid = g_strdup(network);
+
+	if (iface->driver->set_network)
+		iface->driver->set_network(iface, network);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
 {
 	DBusMessageIter array, dict;
@@ -929,6 +1007,7 @@ static GDBusMethodTable iface_methods[] = {
 	{ "SetPolicy",     "s",     "",      set_policy     },
 	{ "GetNetwork",    "",      "a{sv}", get_network    },
 	{ "SetNetwork",    "a{sv}", "",      set_network    },
+	{ "SelectNetwork", "s",     "",      select_network },
 	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
 	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
 	{ },
@@ -1055,6 +1134,9 @@ static int probe_device(LibHalContext *ctx,
 
 	__connman_iface_load(iface);
 
+	DBG("iface %p network %s secret %s", iface,
+				iface->network.essid, iface->network.psk);
+
 	conn = libhal_ctx_get_dbus_connection(ctx);
 
 	g_dbus_register_object(conn, iface->path, iface, device_free);

commit 658e0e6d8699510d8ea94f0bb6e44718f9956e96
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 07:47:49 2008 +0100

    Fix endless loop in wireless event parsing

diff --git a/plugins/80211.c b/plugins/80211.c
index 2e8968e8..6b2a6fde 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -434,6 +434,8 @@ static void parse_scan_results(struct connman_iface *iface,
 		default:
 			printf("[802.11] scan element 0x%04x (len %d)\n",
 						event->cmd, event->len);
+			if (event->len == 0)
+				len = 0;
 			break;
 		}
 

commit e3db50a2ec3968dc31b780ad0bb794b908c227bb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 07:53:50 2008 +0100

    Add callbacks for starting and stopping interface

diff --git a/include/iface.h b/include/iface.h
index e5fb05d4..b9ade5eb 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -115,9 +115,13 @@ struct connman_iface {
 struct connman_iface_driver {
 	const char *name;
 	const char *capability;
+
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
 
+	int (*start) (struct connman_iface *iface);
+	int (*stop) (struct connman_iface *iface);
+
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
diff --git a/src/iface-inet.c b/src/iface-inet.c
index a09ba312..a0915af4 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -140,8 +140,13 @@ int __connman_iface_up(struct connman_iface *iface)
 
 	ifr.ifr_flags |= IFF_UP;
 
-	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
 		err = -errno;
+		goto done;
+	}
+
+	if (iface->driver->start)
+		err = iface->driver->start(iface);
 	else
 		err = 0;
 
@@ -158,6 +163,12 @@ int __connman_iface_down(struct connman_iface *iface)
 
 	DBG("iface %p", iface);
 
+	if (iface->driver->stop) {
+		err = iface->driver->stop(iface);
+		if (err < 0)
+			return err;
+	}
+
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return -errno;

commit 5018853676931bf252d81439a6d3da0e3c89d80d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:01:23 2008 +0100

    Update function names of 802.03 plugin

diff --git a/plugins/80203.c b/plugins/80203.c
index b4d67457..4d085c0a 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -29,13 +29,14 @@
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
+#include <connman/log.h>
 
-static int iface_probe(struct connman_iface *iface)
+static int ethernet_probe(struct connman_iface *iface)
 {
 	char sysfs_path[PATH_MAX];
 	struct stat st;
 
-	printf("[802.03] probe interface index %d\n", iface->index);
+	DBG("iface %p", iface);
 
 	snprintf(sysfs_path, PATH_MAX, "%s/bridge", iface->sysfs);
 
@@ -50,29 +51,27 @@ static int iface_probe(struct connman_iface *iface)
 	return 0;
 }
 
-static void iface_remove(struct connman_iface *iface)
+static void ethernet_remove(struct connman_iface *iface)
 {
-	printf("[802.03] remove interface index %d\n", iface->index);
+	DBG("iface %p", iface);
 }
 
-static struct connman_iface_driver iface_driver = {
+static struct connman_iface_driver ethernet_driver = {
 	.name		= "80203",
 	.capability	= "net.80203",
-	.probe		= iface_probe,
-	.remove		= iface_remove,
+	.probe		= ethernet_probe,
+	.remove		= ethernet_remove,
 };
 
-static int plugin_init(void)
+static int ethernet_init(void)
 {
-	connman_iface_register(&iface_driver);
-
-	return 0;
+	return connman_iface_register(&ethernet_driver);
 }
 
-static void plugin_exit(void)
+static void ethernet_exit(void)
 {
-	connman_iface_unregister(&iface_driver);
+	connman_iface_unregister(&ethernet_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE("80203", "IEEE 802.03 interface plugin", VERSION,
-						plugin_init, plugin_exit)
+						ethernet_init, ethernet_exit)

commit 7b4a94fd76ef38acecb278536eea9ad57de6dc08
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:09:17 2008 +0100

    Update function names of 802.11 plugin

diff --git a/plugins/80211.c b/plugins/80211.c
index 6b2a6fde..f71cd6a9 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -39,6 +39,7 @@
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
+#include <connman/log.h>
 
 #include "supplicant.h"
 
@@ -188,7 +189,7 @@ static void print_stations(struct iface_data *iface)
 	g_key_file_free(keyfile);
 }
 
-static int iface_probe(struct connman_iface *iface)
+static int wifi_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
 	struct ifreq ifr;
@@ -208,7 +209,7 @@ static int iface_probe(struct connman_iface *iface)
 	if (err < 0)
 		return -EIO;
 
-	printf("[802.11] probe %s\n", ifr.ifr_name);
+	DBG("iface %p %s", iface, ifr.ifr_name);
 
 	data = malloc(sizeof(*data));
 	if (data == NULL)
@@ -231,11 +232,11 @@ static int iface_probe(struct connman_iface *iface)
 	return 0;
 }
 
-static void iface_remove(struct connman_iface *iface)
+static void wifi_remove(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] remove %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	__supplicant_stop(iface);
 
@@ -247,14 +248,14 @@ static void iface_remove(struct connman_iface *iface)
 	free(data);
 }
 
-static int iface_scan(struct connman_iface *iface)
+static int wifi_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 	struct iwreq iwr;
 	struct iw_scan_req iws;
 	int sk, err;
 
-	printf("[802.11] scanning %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
@@ -276,17 +277,18 @@ static int iface_scan(struct connman_iface *iface)
 	close(sk);
 
 	if (err < 0)
-		printf("[802.11] scan initiate error %d\n", errno);
+		connman_error("%s: scan initiate error %d",
+						data->ifname, errno);
 
 	return err;
 }
 
-static int iface_connect(struct connman_iface *iface,
+static int wifi_connect(struct connman_iface *iface,
 					struct connman_network *network)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] connect %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	__supplicant_start(iface);
 
@@ -296,11 +298,11 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
-static int iface_disconnect(struct connman_iface *iface)
+static int wifi_disconnect(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] disconnect %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	if (data->network != NULL)
 		__supplicant_disconnect(iface);
@@ -310,24 +312,24 @@ static int iface_disconnect(struct connman_iface *iface)
 	return 0;
 }
 
-static void iface_set_network(struct connman_iface *iface,
+static void wifi_set_network(struct connman_iface *iface,
 						const char *network)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] set network %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	g_free(data->network);
 
 	data->network = g_strdup(network);
 }
 
-static void iface_set_passphrase(struct connman_iface *iface,
+static void wifi_set_passphrase(struct connman_iface *iface,
 						const char *passphrase)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] set passphrase %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	g_free(data->passphrase);
 
@@ -448,7 +450,7 @@ static void parse_scan_results(struct connman_iface *iface,
 	printf("[802.11] found %d networks\n", num);
 }
 
-static void iface_scan_results(struct connman_iface *iface)
+static void scan_results(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 	struct iwreq iwr;
@@ -503,7 +505,7 @@ static void iface_scan_results(struct connman_iface *iface)
 	print_stations(data);
 }
 
-static void iface_wireless(struct connman_iface *iface,
+static void wifi_wireless(struct connman_iface *iface,
 					void *data, unsigned short len)
 {
 	struct iw_event *event = data;
@@ -545,7 +547,7 @@ static void iface_wireless(struct connman_iface *iface,
 		printf("[802.11] New Access Point %s\n", addr);
 		break;
 	case SIOCGIWSCAN:
-		iface_scan_results(iface);
+		scan_results(iface);
 		break;
 	default:
 		printf("[802.11] Wireless event (cmd 0x%04x len %d)\n",
@@ -554,30 +556,28 @@ static void iface_wireless(struct connman_iface *iface,
 	}
 }
 
-static struct connman_iface_driver iface_driver = {
+static struct connman_iface_driver wifi_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
-	.probe		= iface_probe,
-	.remove		= iface_remove,
-	.scan		= iface_scan,
-	.connect	= iface_connect,
-	.disconnect	= iface_disconnect,
-	.set_network	= iface_set_network,
-	.set_passphrase	= iface_set_passphrase,
-	.rtnl_wireless	= iface_wireless,
+	.probe		= wifi_probe,
+	.remove		= wifi_remove,
+	.scan		= wifi_scan,
+	.connect	= wifi_connect,
+	.disconnect	= wifi_disconnect,
+	.set_network	= wifi_set_network,
+	.set_passphrase	= wifi_set_passphrase,
+	.rtnl_wireless	= wifi_wireless,
 };
 
-static int plugin_init(void)
+static int wifi_init(void)
 {
-	connman_iface_register(&iface_driver);
-
-	return 0;
+	return connman_iface_register(&wifi_driver);
 }
 
-static void plugin_exit(void)
+static void wifi_exit(void)
 {
-	connman_iface_unregister(&iface_driver);
+	connman_iface_unregister(&wifi_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE("80211", "IEEE 802.11 interface plugin", VERSION,
-						plugin_init, plugin_exit)
+							wifi_init, wifi_exit)

commit 58f36e8b742afc500d5a2330999f51afe8ac0877
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:13:01 2008 +0100

    Implement start and stop callbacks for 802.11

diff --git a/plugins/80211.c b/plugins/80211.c
index f71cd6a9..963fb02e 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -248,6 +248,28 @@ static void wifi_remove(struct connman_iface *iface)
 	free(data);
 }
 
+static int wifi_start(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	DBG("iface %p %s", iface, data->ifname);
+
+	__supplicant_start(iface);
+
+	return 0;
+}
+
+static int wifi_stop(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	DBG("iface %p %s", iface, data->ifname);
+
+	__supplicant_stop(iface);
+
+	return 0;
+}
+
 static int wifi_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
@@ -290,8 +312,6 @@ static int wifi_connect(struct connman_iface *iface,
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	__supplicant_start(iface);
-
 	if (data->network != NULL)
 		__supplicant_connect(iface, data->network, data->passphrase);
 
@@ -307,8 +327,6 @@ static int wifi_disconnect(struct connman_iface *iface)
 	if (data->network != NULL)
 		__supplicant_disconnect(iface);
 
-	__supplicant_stop(iface);
-
 	return 0;
 }
 
@@ -561,6 +579,8 @@ static struct connman_iface_driver wifi_driver = {
 	.capability	= "net.80211",
 	.probe		= wifi_probe,
 	.remove		= wifi_remove,
+	.start		= wifi_start,
+	.stop		= wifi_stop,
 	.scan		= wifi_scan,
 	.connect	= wifi_connect,
 	.disconnect	= wifi_disconnect,

commit d7d0cc2a73eef733e792873caa35862e902d3ce4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:33:00 2008 +0100

    Add system activation support

diff --git a/.gitignore b/.gitignore
index d2429679..06c10588 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,5 +23,6 @@ autom4te.cache
 
 include/connman
 src/connmand
+src/connman.service
 scripts/connman
 scripts/dhclient-script
diff --git a/configure.in b/configure.in
index 0c61409f..119ac713 100644
--- a/configure.in
+++ b/configure.in
@@ -62,4 +62,5 @@ AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
-			plugins/Makefile scripts/Makefile scripts/connman)
+					plugins/Makefile scripts/Makefile
+					scripts/connman src/connman.service)
diff --git a/src/Makefile.am b/src/Makefile.am
index 516c1b8b..7faf6a22 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -3,6 +3,12 @@ dbusdir = $(sysconfdir)/dbus-1/system.d
 
 dbus_DATA = connman.conf
 
+servicedir = $(datarootdir)/dbus-1/system-services
+
+service_DATA = connman.service
+
+DISTCLEANFILES = $(service_DATA)
+
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
diff --git a/src/connman.service.in b/src/connman.service.in
new file mode 100644
index 00000000..8c2368a7
--- /dev/null
+++ b/src/connman.service.in
@@ -0,0 +1,4 @@
+[D-BUS Service]
+Name=org.freedesktop.connman
+Exec=@prefix@/sbin/connmand
+User=root

commit 957896b6bbeae6dc4efef26da8bfe48fece916ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:33:54 2008 +0100

    Add first draft of plugin API description

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 04bffe2b..3155148a 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt
+EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt plugin-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/plugin-api.txt b/doc/plugin-api.txt
new file mode 100644
index 00000000..f8dded07
--- /dev/null
+++ b/doc/plugin-api.txt
@@ -0,0 +1,22 @@
+Plugin programming interface
+****************************
+
+Plugin basics
+=============
+The Connection Manager supports plugins for various actions. The basic plugin
+contains of plugin description via CONNMAN_PLUGIN_DEFINE and also init/exit
+callbacks definied through that description.
+
+#include <connman/plugin.h>
+
+static int example_init(void)
+{
+	return 0;
+}
+
+static void example_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE("example", "Example plugin", VERSION,
+						example_init, example_exit)

commit 7de39040b6b37028e899ae624c9f50b0a3d5df2e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 2 11:34:25 2008 +0100

    Add support for pkg-config

diff --git a/.gitignore b/.gitignore
index 06c10588..4fb1449a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,6 +21,7 @@ missing
 stamp-h1
 autom4te.cache
 
+connman.pc
 include/connman
 src/connmand
 src/connman.service
diff --git a/Makefile.am b/Makefile.am
index 35d8c884..071be42c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,6 +1,12 @@
 
 SUBDIRS = include src doc test plugins scripts
 
+pkgconfigdir = $(libdir)/pkgconfig
+
+noinst_DATA = connman.pc
+
+DISTCLEANFILES = $(noinst_DATA)
+
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
 	ltmain.sh depcomp missing install-sh mkinstalldirs
diff --git a/configure.in b/configure.in
index 119ac713..81144ec1 100644
--- a/configure.in
+++ b/configure.in
@@ -61,6 +61,6 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
-					plugins/Makefile scripts/Makefile
-					scripts/connman src/connman.service)
+AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
+			test/Makefile plugins/Makefile scripts/Makefile
+			scripts/connman src/connman.service connman.pc)
diff --git a/connman.pc.in b/connman.pc.in
new file mode 100644
index 00000000..96f1abc4
--- /dev/null
+++ b/connman.pc.in
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+ 
+Name: connman
+Description: Connection Manager
+Version: @VERSION@
+Libs: -module -avoid-version -export-symbols-regex connman_plugin_desc
+Cflags: -I${includedir}

commit 93378be22c081eb09cefa1cb982a0e74b6350730
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 3 15:28:29 2008 +0100

    Rename package from connman-core to connman

diff --git a/configure.in b/configure.in
index 81144ec1..ba478e16 100644
--- a/configure.in
+++ b/configure.in
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman-core, 0.0)
+AM_INIT_AUTOMAKE(connman, 0.0)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 25ff366326749b0d82c3bf3e7def61dcc7d85b25
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 3 15:46:55 2008 +0100

    Add plugin and script directories to pkg-config

diff --git a/connman.pc.in b/connman.pc.in
index 96f1abc4..fd86152c 100644
--- a/connman.pc.in
+++ b/connman.pc.in
@@ -3,6 +3,9 @@ exec_prefix=@exec_prefix@
 libdir=@libdir@
 includedir=@includedir@
  
+plugindir=${libdir}/connman/plugins
+scriptdir=${libdir}/connman/scripts
+
 Name: connman
 Description: Connection Manager
 Version: @VERSION@

commit c016ac34da91eef334844f43fbcb2639ed17bf8e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 7 13:53:54 2008 +0100

    Disable unused RTNL address handling for now

diff --git a/src/iface.c b/src/iface.c
index c88408df..ea8b47ba 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -386,6 +386,7 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4)
 {
+#if 0
 	struct {
 		struct nlmsghdr hdr;
 		struct rtgenmsg msg;
@@ -405,6 +406,7 @@ int connman_iface_get_ipv4(struct connman_iface *iface,
 	req.msg.rtgen_family = AF_INET;
 
 	__connman_rtnl_send(&req, sizeof(req));
+#endif
 
 	return 0;
 }
diff --git a/src/rtnl.c b/src/rtnl.c
index 952f09b3..e4996fb9 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -403,7 +403,8 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
+	addr.nl_groups = RTMGRP_LINK;
+	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {

commit 3d6fb4828d617c822cb260e6e6d3f9aae51979d9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 7 14:16:32 2008 +0100

    Fix compiler warning

diff --git a/src/iface.c b/src/iface.c
index ea8b47ba..b91c1973 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -562,8 +562,9 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	//if (driver->scan)
-	//	driver->scan(iface);
+	if (driver->scan) {
+		//driver->scan(iface);
+	}
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 

commit 0c42162c98c45373b2e9759021361eda40bb5f7e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 7 14:28:33 2008 +0100

    Fix missing IW_EV_LCP_PK_LEN definition on some distributions

diff --git a/plugins/80211.c b/plugins/80211.c
index 963fb02e..1bada4fc 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -43,6 +43,10 @@
 
 #include "supplicant.h"
 
+#ifndef IW_EV_LCP_PK_LEN
+#define IW_EV_LCP_PK_LEN	(4)
+#endif
+
 struct station_data {
 	char *address;
 	char *name;

commit 79280d0cf6a006988cb3c6394da44b2aa4c38271
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 11 14:54:48 2008 +0100

    Use start/stop callbacks if provided

diff --git a/src/iface-inet.c b/src/iface-inet.c
index a0915af4..927f5689 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -145,10 +145,7 @@ int __connman_iface_up(struct connman_iface *iface)
 		goto done;
 	}
 
-	if (iface->driver->start)
-		err = iface->driver->start(iface);
-	else
-		err = 0;
+	err = 0;
 
 done:
 	close(sk);
@@ -163,12 +160,6 @@ int __connman_iface_down(struct connman_iface *iface)
 
 	DBG("iface %p", iface);
 
-	if (iface->driver->stop) {
-		err = iface->driver->stop(iface);
-		if (err < 0)
-			return err;
-	}
-
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return -errno;
diff --git a/src/iface.c b/src/iface.c
index b91c1973..65e4cdd0 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -215,14 +215,20 @@ static void switch_policy(struct connman_iface *iface)
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 		state_changed(iface);
 		connman_iface_clear_ipv4(iface);
-		__connman_iface_down(iface);
+		if (iface->driver->stop)
+			iface->driver->stop(iface);
+		else
+			__connman_iface_down(iface);
 		break;
 
 	case CONNMAN_IFACE_POLICY_IGNORE:
 		break;
 
 	case CONNMAN_IFACE_POLICY_AUTO:
-		__connman_iface_up(iface);
+		if (iface->driver->start)
+			iface->driver->start(iface);
+		else
+			__connman_iface_up(iface);
 		state_changed(iface);
 		break;
 
@@ -252,9 +258,13 @@ void connman_iface_indicate_disabled(struct connman_iface *iface)
 
 	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-		__connman_iface_up(iface);
+		if (iface->driver->start)
+			iface->driver->start(iface);
+		else
+			__connman_iface_up(iface);
 	} else
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+
 	state_changed(iface);
 }
 

commit c1925f58614237c3ecd8adce5c0b3f7d82b847cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:48:31 2008 +0100

    Add option for interface limitation

diff --git a/src/connman.h b/src/connman.h
index 76bffe55..c253a8e3 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -59,7 +59,7 @@ void __connman_plugin_cleanup(void);
 
 #include <connman/iface.h>
 
-int __connman_iface_init(DBusConnection *conn);
+int __connman_iface_init(DBusConnection *conn, const char *interface);
 void __connman_iface_cleanup(void);
 
 struct connman_iface *__connman_iface_find(int index);
diff --git a/src/iface.c b/src/iface.c
index 65e4cdd0..18c44f66 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -47,6 +47,8 @@
 
 static DBusConnection *connection = NULL;
 
+static gchar *ifname_filter = NULL;
+
 static GSList *drivers = NULL;
 
 int connman_iface_register(struct connman_iface_driver *driver)
@@ -1095,7 +1097,7 @@ static int probe_device(LibHalContext *ctx,
 {
 	DBusConnection *conn;
 	struct connman_iface *iface;
-	char *temp, *sysfs;
+	char *temp, *sysfs, *ifname;
 	int err;
 
 	DBG("ctx %p driver %p udi %s", ctx, driver, udi);
@@ -1124,10 +1126,20 @@ static int probe_device(LibHalContext *ctx,
 
 	iface->index = -1;
 
-	if (g_str_has_prefix(driver->capability, "net") == TRUE)
+	if (g_str_has_prefix(driver->capability, "net") == TRUE) {
 		iface->index = libhal_device_get_property_int(ctx, udi,
 						"net.linux.ifindex", NULL);
 
+		ifname = libhal_device_get_property_string(ctx, udi,
+						"net.interface", NULL);
+		if (ifname != NULL && ifname_filter != NULL &&
+						*ifname_filter != '\0' &&
+				g_str_equal(ifname, ifname_filter) == FALSE) {
+			device_free(iface);
+			return -1;
+		}
+	}
+
 	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
 	iface->flags = 0;
 	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
@@ -1340,7 +1352,7 @@ static void hal_cleanup(void *data)
 
 static guint hal_watch = 0;
 
-int __connman_iface_init(DBusConnection *conn)
+int __connman_iface_init(DBusConnection *conn, const char *interface)
 {
 	DBG("conn %p", conn);
 
@@ -1348,6 +1360,9 @@ int __connman_iface_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -1;
 
+	if (interface != NULL)
+		ifname_filter = g_strdup(interface);
+
 	hal_init(connection);
 
 	hal_watch = g_dbus_add_watch(connection, "org.freedesktop.Hal",
@@ -1364,5 +1379,7 @@ void __connman_iface_cleanup(void)
 
 	hal_cleanup(connection);
 
+	g_free(ifname_filter);
+
 	dbus_connection_unref(connection);
 }
diff --git a/src/main.c b/src/main.c
index a4962b2a..e9174401 100644
--- a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include <signal.h>
 #include <getopt.h>
 #include <sys/stat.h>
+#include <net/if.h>
 
 #include <gdbus.h>
 
@@ -47,7 +48,7 @@ static void usage(void)
 	printf("Connection Manager version %s\n\n", VERSION);
 
 	printf("Usage:\n"
-		"\tconnmand [options]\n"
+		"\tconnmand [-i <interface>] [options]\n"
 		"\n");
 
 	printf("Options:\n"
@@ -58,10 +59,11 @@ static void usage(void)
 }
 
 static struct option options[] = {
-	{ "nodaemon", 0, 0, 'n' },
-	{ "compat",   0, 0, 'c' },
-	{ "debug",    0, 0, 'd' },
-	{ "help",     0, 0, 'h' },
+	{ "interface", 1, 0, 'i' },
+	{ "nodaemon",  0, 0, 'n' },
+	{ "compat",    0, 0, 'c' },
+	{ "debug",     0, 0, 'd' },
+	{ "help",      0, 0, 'h' },
 	{ }
 };
 
@@ -70,10 +72,16 @@ int main(int argc, char *argv[])
 	DBusConnection *conn;
 	DBusError err;
 	struct sigaction sa;
+	char interface[IFNAMSIZ];
 	int opt, detach = 1, compat = 0, debug = 0;
 
-	while ((opt = getopt_long(argc, argv, "+ncdh", options, NULL)) != EOF) {
+	memset(interface, 0, IFNAMSIZ);
+
+	while ((opt = getopt_long(argc, argv, "+i:ncdh", options, NULL)) != EOF) {
 		switch (opt) {
+		case 'i':
+			snprintf(interface, IFNAMSIZ, "%s", optarg);
+			break;
 		case 'n':
 			detach = 0;
 			break;
@@ -136,7 +144,7 @@ int main(int argc, char *argv[])
 
 	__connman_rtnl_init();
 
-	__connman_iface_init(conn);
+	__connman_iface_init(conn, interface);
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;

commit c1fdd4bf06398f2b277bd5d8e5a11cadba6508b8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:49:14 2008 +0100

    Change variables inside the network structure

diff --git a/include/iface.h b/include/iface.h
index b9ade5eb..37e60672 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -83,8 +83,8 @@ struct connman_ipv4 {
 };
 
 struct connman_network {
-	char *essid;
-	char *psk;
+	char *identifier;
+	char *passphrase;
 };
 
 struct connman_iface {
@@ -127,11 +127,6 @@ struct connman_iface_driver {
 					struct connman_network *network);
 	int (*disconnect) (struct connman_iface *iface);
 
-	void (*set_network) (struct connman_iface *iface,
-						const char *network);
-	void (*set_passphrase) (struct connman_iface *iface,
-						const char *passphrase);
-
 	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
 	void (*rtnl_wireless) (struct connman_iface *iface,
 					void *data, unsigned short len);
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 750aa43e..a5b57a38 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -63,18 +63,14 @@ int __connman_iface_load(struct connman_iface *iface)
 
 	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Network", NULL);
 	if (str != NULL) {
-		g_free(iface->network.essid);
-		iface->network.essid = str;
-		if (iface->driver->set_network)
-			iface->driver->set_network(iface, str);
+		g_free(iface->network.identifier);
+		iface->network.identifier = str;
 
-		str = g_key_file_get_string(keyfile, iface->network.essid,
-								"PSK", NULL);
+		str = g_key_file_get_string(keyfile,
+				iface->network.identifier, "PSK", NULL);
 		if (str != NULL) {
-			g_free(iface->network.psk);
-			iface->network.psk = str;
-			if (iface->driver->set_passphrase)
-				iface->driver->set_passphrase(iface, str);
+			g_free(iface->network.passphrase);
+			iface->network.passphrase = str;
 		}
 	}
 
@@ -95,15 +91,15 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	str = __connman_iface_policy2string(iface->policy);
 	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
 
-	if (iface->network.essid != NULL) {
+	if (iface->network.identifier != NULL) {
 		g_key_file_set_string(keyfile, GROUP_CONFIG,
-					"Network", iface->network.essid);
+				"Network", iface->network.identifier);
 	} else
 		g_key_file_remove_key(keyfile, GROUP_CONFIG, "Network", NULL);
 
-	if (iface->network.essid != NULL)
-		g_key_file_set_string(keyfile, iface->network.essid,
-						"PSK", iface->network.psk);
+	if (iface->network.identifier != NULL)
+		g_key_file_set_string(keyfile, iface->network.identifier,
+					"PSK", iface->network.passphrase);
 }
 
 int __connman_iface_store(struct connman_iface *iface)
diff --git a/src/iface.c b/src/iface.c
index 18c44f66..b9fe5133 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -134,7 +134,6 @@ static gboolean scan_timeout(gpointer user_data)
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_SCANNING:
-	case CONNMAN_IFACE_STATE_READY:
 		if (iface->driver->scan)
 			iface->driver->scan(iface);
 		return TRUE;
@@ -194,8 +193,6 @@ static void state_changed(struct connman_iface *iface)
 		break;
 
 	case CONNMAN_IFACE_STATE_READY:
-		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
-			g_timeout_add(20000, scan_timeout, iface);
 		break;
 
 	default:
@@ -379,16 +376,12 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
 
-	if (g_str_equal(name, iface->network.essid) == TRUE &&
+	if (g_str_equal(name, iface->network.identifier) == TRUE &&
 			iface->state == CONNMAN_IFACE_STATE_SCANNING) {
-		if (iface->driver->set_network)
-			iface->driver->set_network(iface, name);
-		if (iface->driver->set_passphrase)
-			iface->driver->set_passphrase(iface,
-						iface->network.psk);
+		iface->network.identifier = g_strdup(name);
 
 		if (iface->driver->connect) {
-			iface->driver->connect(iface, NULL);
+			iface->driver->connect(iface, &iface->network);
 			iface->state = CONNMAN_IFACE_STATE_CONNECT;
 			state_changed(iface);
 		}
@@ -574,9 +567,8 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->scan) {
-		//driver->scan(iface);
-	}
+	if (driver->scan)
+		driver->scan(iface);
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
@@ -751,12 +743,12 @@ static void append_network(DBusMessage *reply,
 
 	switch (iface->type) {
 	case CONNMAN_IFACE_TYPE_80211:
-		if (iface->network.essid != NULL)
+		if (iface->network.identifier != NULL)
 			append_entry(&dict, "ESSID",
-				DBUS_TYPE_STRING, &iface->network.essid);
-		if (secrets == TRUE && iface->network.psk != NULL)
+				DBUS_TYPE_STRING, &iface->network.identifier);
+		if (secrets == TRUE && iface->network.passphrase != NULL)
 			append_entry(&dict, "PSK",
-				DBUS_TYPE_STRING, &iface->network.psk);
+				DBUS_TYPE_STRING, &iface->network.passphrase);
 		break;
 	default:
 		break;
@@ -811,18 +803,14 @@ static DBusMessage *set_network(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &val);
 
 		if (g_strcasecmp(key, "ESSID") == 0) {
-			g_free(iface->network.essid);
-			iface->network.essid = g_strdup(val);
-			if (iface->driver->set_network)
-				iface->driver->set_network(iface, val);
+			g_free(iface->network.identifier);
+			iface->network.identifier = g_strdup(val);
 			changed = TRUE;
 		}
 
 		if (g_strcasecmp(key, "PSK") == 0) {
-			g_free(iface->network.psk);
-			iface->network.psk = g_strdup(val);
-			if (iface->driver->set_passphrase)
-				iface->driver->set_passphrase(iface, val);
+			g_free(iface->network.passphrase);
+			iface->network.passphrase = g_strdup(val);
 			changed = TRUE;
 		}
 
@@ -845,6 +833,12 @@ static DBusMessage *set_network(DBusConnection *conn,
 			dbus_connection_send(conn, signal, NULL);
 			dbus_message_unref(signal);
 		}
+
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+
+		if (iface->driver->connect)
+			iface->driver->connect(iface, &iface->network);
 	}
 
 	return reply;
@@ -862,11 +856,14 @@ static DBusMessage *select_network(DBusConnection *conn,
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
 							DBUS_TYPE_INVALID);
 
-	g_free(iface->network.essid);
-	iface->network.essid = g_strdup(network);
+	g_free(iface->network.identifier);
+	iface->network.identifier = g_strdup(network);
+
+	if (iface->driver->disconnect)
+		iface->driver->disconnect(iface);
 
-	if (iface->driver->set_network)
-		iface->driver->set_network(iface, network);
+	if (iface->driver->connect)
+		iface->driver->connect(iface, &iface->network);
 
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
@@ -1053,7 +1050,8 @@ static void device_free(void *data)
 	g_free(iface->udi);
 	g_free(iface->sysfs);
 	g_free(iface->identifier);
-	g_free(iface->network.essid);
+	g_free(iface->network.identifier);
+	g_free(iface->network.passphrase);
 	g_free(iface->device.driver);
 	g_free(iface->device.vendor);
 	g_free(iface->device.product);
@@ -1160,7 +1158,8 @@ static int probe_device(LibHalContext *ctx,
 	__connman_iface_load(iface);
 
 	DBG("iface %p network %s secret %s", iface,
-				iface->network.essid, iface->network.psk);
+					iface->network.identifier,
+					iface->network.passphrase);
 
 	conn = libhal_ctx_get_dbus_connection(ctx);
 

commit 451d80c342f0ed95363b7056221544207323bbaa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:51:59 2008 +0100

    Change 802.11 plugin to use D-Bus interface of supplicant

diff --git a/plugins/80211.c b/plugins/80211.c
index 1bada4fc..d21eec64 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -43,156 +43,10 @@
 
 #include "supplicant.h"
 
-#ifndef IW_EV_LCP_PK_LEN
-#define IW_EV_LCP_PK_LEN	(4)
-#endif
-
-struct station_data {
-	char *address;
-	char *name;
-	int mode;
-	int qual;
-	int noise;
-	int level;
-
-	unsigned char wpa_ie[40];
-	int wpa_ie_len;
-	unsigned char rsn_ie[40];
-	int rsn_ie_len;
-
-	int has_wep;
-	int has_wpa;
-	int has_rsn;
-};
-
 struct iface_data {
 	char ifname[IFNAMSIZ];
-	GSList *stations;
-
-	gchar *network;
-	gchar *passphrase;
 };
 
-static void report_station(struct connman_iface *iface,
-						struct station_data *station)
-{
-	int security = 0;
-
-	if (station == NULL)
-		return;
-
-	if (station->name == NULL)
-		return;
-
-	if (station->has_wep)
-		security |= 0x01;
-	if (station->has_wpa)
-		security |= 0x02;
-	if (station->has_rsn)
-		security |= 0x04;
-
-	connman_iface_indicate_station(iface, station->name,
-						station->qual, security);
-}
-
-static struct station_data *create_station(struct iface_data *iface,
-							const char *address)
-{
-	struct station_data *station;
-	GSList *list;
-
-	for (list = iface->stations; list; list = list->next) {
-		station = list->data;
-
-		if (g_ascii_strcasecmp(station->address, address) == 0)
-			return station;
-	}
-
-	station = g_try_new0(struct station_data, 1);
-	if (station == NULL)
-		return NULL;
-
-	station->address = g_strdup(address);
-	if (station->address == NULL) {
-		g_free(station);
-		return NULL;
-	}
-
-	iface->stations = g_slist_append(iface->stations, station);
-
-	return station;
-}
-
-static void load_stations(struct iface_data *iface)
-{
-	GKeyFile *keyfile;
-	gchar **groups, **group;
-	gsize length;
-
-	keyfile = g_key_file_new();
-
-	if (g_key_file_load_from_file(keyfile, "/tmp/stations.list",
-				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
-		goto done;
-
-	groups = g_key_file_get_groups(keyfile, &length);
-
-	for (group = groups; *group; group++) {
-		struct station_data *station;
-
-		station = create_station(iface, *group);
-		if (station == NULL)
-			continue;
-
-		station->name = g_key_file_get_string(keyfile,
-						*group, "Name", NULL);
-	
-		station->mode = g_key_file_get_integer(keyfile,
-						*group, "Mode", NULL);
-	}
-
-	g_strfreev(groups);
-
-done:
-	g_key_file_free(keyfile);
-
-	printf("[802.11] loaded %d stations\n",
-				g_slist_length(iface->stations));
-}
-
-static void print_stations(struct iface_data *iface)
-{
-	GKeyFile *keyfile;
-	gchar *data;
-	gsize length;
-	GSList *list;
-
-	keyfile = g_key_file_new();
-
-	for (list = iface->stations; list; list = list->next) {
-		struct station_data *station = list->data;
-
-		//printf("Address:%s Mode:%d ESSID:\"%s\" Quality:%d/100\n",
-		//			station->address, station->mode,
-		//				station->name, station->qual);
-
-		if (station->name == NULL)
-			continue;
-
-		g_key_file_set_string(keyfile, station->address,
-						"Name", station->name);
-
-		g_key_file_set_integer(keyfile, station->address,
-						"Mode", station->mode);
-	}
-
-	data = g_key_file_to_data(keyfile, &length, NULL);
-
-	g_file_set_contents("/tmp/stations.list", data, length, NULL);
-
-	g_key_file_free(keyfile);
-}
-
 static int wifi_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
@@ -231,8 +85,6 @@ static int wifi_probe(struct connman_iface *iface)
 
 	connman_iface_set_data(iface, data);
 
-	load_stations(data);
-
 	return 0;
 }
 
@@ -246,9 +98,6 @@ static void wifi_remove(struct connman_iface *iface)
 
 	connman_iface_set_data(iface, NULL);
 
-	g_free(data->network);
-	g_free(data->passphrase);
-
 	free(data);
 }
 
@@ -277,36 +126,12 @@ static int wifi_stop(struct connman_iface *iface)
 static int wifi_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
-	struct iwreq iwr;
-	struct iw_scan_req iws;
-	int sk, err;
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&iws, 0, sizeof(iws));
-	iws.scan_type = IW_SCAN_TYPE_PASSIVE;
-	//iws.scan_type = IW_SCAN_TYPE_ACTIVE;
-
-	memset(&iwr, 0, sizeof(iwr));
-	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
+	__supplicant_scan(iface);
 
-	iwr.u.data.pointer = (caddr_t ) &iws;
-	iwr.u.data.length = sizeof(iws);
-	iwr.u.data.flags = IW_SCAN_DEFAULT;
-
-	err = ioctl(sk, SIOCSIWSCAN, &iwr);
-
-	close(sk);
-
-	if (err < 0)
-		connman_error("%s: scan initiate error %d",
-						data->ifname, errno);
-
-	return err;
+	return 0;
 }
 
 static int wifi_connect(struct connman_iface *iface,
@@ -316,8 +141,7 @@ static int wifi_connect(struct connman_iface *iface,
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_connect(iface, data->network, data->passphrase);
+	__supplicant_connect(iface, network->identifier, network->passphrase);
 
 	return 0;
 }
@@ -328,256 +152,11 @@ static int wifi_disconnect(struct connman_iface *iface)
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_disconnect(iface);
+	__supplicant_disconnect(iface);
 
 	return 0;
 }
 
-static void wifi_set_network(struct connman_iface *iface,
-						const char *network)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	g_free(data->network);
-
-	data->network = g_strdup(network);
-}
-
-static void wifi_set_passphrase(struct connman_iface *iface,
-						const char *passphrase)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	g_free(data->passphrase);
-
-	data->passphrase = g_strdup(passphrase);
-}
-
-static void parse_genie(struct station_data *station,
-					unsigned char *data, int len)
-{
-	int offset = 0;
-
-	while (offset <= len - 2) {
-		//int i;
-
-		switch (data[offset]) {
-		case 0xdd:	/* WPA1 (and other) */
-			station->has_wpa = 1;
-			break;
-		case 0x30:	/* WPA2 (RSN) */
-			station->has_rsn = 1;
-			break;
-		default:
-			break;
-		}
-
-		//for (i = 0; i < len; i++)
-		//	printf(" %02x", data[i]);
-		//printf("\n");
-
-		offset += data[offset + 1] + 2;
-	}
-}
-
-static void parse_scan_results(struct connman_iface *iface,
-					unsigned char *data, int len)
-{
-	unsigned char *ptr = data;
-	struct station_data *station = NULL;
-	struct ether_addr *eth;
-	char addr[18];
-	int num = 0;
-
-	while (len > IW_EV_LCP_PK_LEN) {
-		struct iw_event *event = (void *) ptr;
-
-		switch (event->cmd) {
-		case SIOCGIWAP:
-			report_station(iface, station);
-			eth = (void *) &event->u.ap_addr.sa_data;
-			sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-			station = create_station(connman_iface_get_data(iface),
-									addr);
-			num++;
-			break;
-		case SIOCGIWESSID:
-			if (station != NULL) {
-				station->name = malloc(event->len - IW_EV_POINT_LEN + 1);
-				if (station->name != NULL) {
-					memset(station->name, 0,
-						event->len - IW_EV_POINT_LEN + 1);
-					memcpy(station->name, ptr + IW_EV_POINT_LEN,
-						event->len - IW_EV_POINT_LEN);
-				}
-			}
-			break;
-		case SIOCGIWNAME:
-			break;
-		case SIOCGIWMODE:
-			if (station != NULL)
-				station->mode = event->u.mode;
-			break;
-		case SIOCGIWFREQ:
-			break;
-		case SIOCGIWENCODE:
-			if (station != NULL) {
-				if (!event->u.data.pointer)
-					event->u.data.flags |= IW_ENCODE_NOKEY;
-
-				if (!(event->u.data.flags & IW_ENCODE_DISABLED))
-					station->has_wep = 1;
-			}
-			break;
-		case SIOCGIWRATE:
-			break;
-		case IWEVQUAL:
-			if (station != NULL) {
-				station->qual = event->u.qual.qual;
-				station->noise = event->u.qual.noise;
-				station->level = event->u.qual.level;
-			}
-			break;
-		case IWEVGENIE:
-			if (station != NULL)
-				parse_genie(station, ptr + 8, event->len - 8);
-			break;
-		case IWEVCUSTOM:
-			break;
-		default:
-			printf("[802.11] scan element 0x%04x (len %d)\n",
-						event->cmd, event->len);
-			if (event->len == 0)
-				len = 0;
-			break;
-		}
-
-		ptr += event->len;
-		len -= event->len;
-	}
-
-	report_station(iface, station);
-
-	printf("[802.11] found %d networks\n", num);
-}
-
-static void scan_results(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-	struct iwreq iwr;
-	void *buf;
-	size_t size;
-	int sk, err, done = 0;
-
-	if (data == NULL)
-		return;
-
-	memset(&iwr, 0, sizeof(iwr));
-	memcpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return;
-
-	buf = NULL;
-	size = 1024;
-
-	while (!done) {
-		void *newbuf;
-
-		newbuf = g_realloc(buf, size);
-		if (newbuf == NULL) {
-			close(sk);
-			return;
-		}
-
-		buf = newbuf;
-		iwr.u.data.pointer = buf;
-		iwr.u.data.length = size;
-		iwr.u.data.flags = 0;
-
-		err = ioctl(sk, SIOCGIWSCAN, &iwr);
-		if (err < 0) {
-			if (errno == E2BIG)
-				size *= 2;
-			else
-				done = 1;
-		} else {
-			parse_scan_results(iface, iwr.u.data.pointer,
-							iwr.u.data.length);
-			done = 1;
-		}
-	}
-
-	g_free(buf);
-
-	close(sk);
-
-	print_stations(data);
-}
-
-static void wifi_wireless(struct connman_iface *iface,
-					void *data, unsigned short len)
-{
-	struct iw_event *event = data;
-	struct iw_point point;
-	struct ether_addr *eth;
-	char addr[18];
-
-	switch (event->cmd) {
-	case SIOCSIWFREQ:
-		printf("[802.11] Set Frequency (flags %d)\n",
-							event->u.freq.flags);
-		break;
-	case SIOCSIWMODE:
-		printf("[802.11] Set Mode (mode %d)\n", event->u.mode);
-		break;
-	case SIOCSIWESSID:
-		memcpy(&point, data + IW_EV_LCP_LEN -
-					IW_EV_POINT_OFF, sizeof(point));
-		point.pointer = data + IW_EV_LCP_LEN +
-					sizeof(point) - IW_EV_POINT_OFF;
-		printf("[802.11] Set ESSID (length %d flags %d) \"%s\"\n",
-					point.length, point.flags,
-						(char *) point.pointer);
-		break;
-	case SIOCSIWENCODE:
-		printf("[802.11] Set Encryption key (flags %d)\n",
-							event->u.data.flags);
-		break;
-
-	case SIOCGIWAP:
-		eth = (void *) &event->u.ap_addr.sa_data;
-		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-		printf("[802.11] New Access Point %s\n", addr);
-		break;
-	case SIOCGIWSCAN:
-		scan_results(iface);
-		break;
-	default:
-		printf("[802.11] Wireless event (cmd 0x%04x len %d)\n",
-						event->cmd, event->len);
-		break;
-	}
-}
-
 static struct connman_iface_driver wifi_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
@@ -588,9 +167,6 @@ static struct connman_iface_driver wifi_driver = {
 	.scan		= wifi_scan,
 	.connect	= wifi_connect,
 	.disconnect	= wifi_disconnect,
-	.set_network	= wifi_set_network,
-	.set_passphrase	= wifi_set_passphrase,
-	.rtnl_wireless	= wifi_wireless,
 };
 
 static int wifi_init(void)
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b30b16cb..c8853e12 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -33,21 +33,62 @@
 #include <sys/un.h>
 #include <net/if.h>
 
-#include <glib.h>
+#include <dbus/dbus.h>
+#include <gdbus.h>
+
+#include <connman/log.h>
 
 #include "supplicant.h"
 
+enum supplicant_state {
+	STATE_INACTIVE,
+	STATE_SCANNING,
+	STATE_ASSOCIATING,
+	STATE_ASSOCIATED,
+	STATE_4WAY_HANDSHAKE,
+	STATE_GROUP_HANDSHAKE,
+	STATE_COMPLETED,
+	STATE_DISCONNECTED,
+};
+
+// COMPLETED       ==> ASSOCIATING
+// ASSOCIATED      ==> DISCONNECTED
+// DISCONNECTED    ==> INACTIVE
+
+// DISCONNECTED    ==> SCANNING
+// SCANNING        ==> ASSOCIATED
+
+// ASSOCIATING     ==> ASSOCIATED
+// ASSOCIATED      ==> 4WAY_HANDSHAKE
+// 4WAY_HANDSHAKE  ==> GROUP_HANDSHAKE
+// GROUP_HANDSHAKE ==> COMPLETED
+
 struct supplicant_task {
-	GPid pid;
+	DBusConnection *conn;
 	int ifindex;
-	char *ifname;
+	gchar *ifname;
 	struct connman_iface *iface;
-	int socket;
-	GIOChannel *channel;
+	gchar *path;
+	gboolean created;
+	gchar *network;
+	enum supplicant_state state;
 };
 
 static GSList *tasks = NULL;
 
+struct supplicant_ap {
+	gchar *identifier;
+	GByteArray *ssid;
+	guint capabilities;
+	gboolean has_wep;
+	gboolean has_wpa;
+	gboolean has_rsn;
+};
+
+#define IEEE80211_CAP_ESS       0x0001
+#define IEEE80211_CAP_IBSS      0x0002
+#define IEEE80211_CAP_PRIVACY   0x0010
+
 static struct supplicant_task *find_task(int ifindex)
 {
 	GSList *list;
@@ -62,95 +103,715 @@ static struct supplicant_task *find_task(int ifindex)
 	return NULL;
 }
 
-static int exec_cmd(struct supplicant_task *task, char *cmd)
+static int get_interface(struct supplicant_task *task)
 {
-	return write(task->socket, cmd, strlen(cmd));
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "getInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to get interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for interface");
+		dbus_message_unref(reply);
+		return -EIO;
+	}
+
+	DBG("path %s", path);
+
+	task->path = g_strdup(path);
+	task->created = FALSE;
+
+	dbus_message_unref(reply);
+
+	return 0;
 }
 
-static gboolean control_event(GIOChannel *chan,
-				GIOCondition cond, gpointer data)
+static int add_interface(struct supplicant_task *task)
 {
-	struct supplicant_task *task = data;
-	char buf[256];
-	gsize len;
-	GIOError err;
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
 
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
-		return FALSE;
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "addInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
 
-	memset(buf, 0, sizeof(buf));
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
 
-	err = g_io_channel_read(chan, buf, sizeof(buf), &len);
-	if (err) {
-		if (err == G_IO_ERROR_AGAIN)
-			return TRUE;
-		return FALSE;
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to add interface");
+		dbus_message_unref(message);
+		return -EIO;
 	}
 
-	if (buf[0] != '<')
-		return TRUE;
+	dbus_message_unref(message);
 
-	printf("[SUPPLICANT] %s\n", buf + 3);
+	dbus_error_init(&error);
 
-	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
-		printf("[SUPPLICANT] connected\n");
-		connman_iface_indicate_connected(task->iface);
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for interface");
+		dbus_message_unref(reply);
+		return -EIO;
 	}
 
-	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
-		printf("[SUPPLICANT] disconnected\n");
+	DBG("path %s", path);
+
+	task->path = g_strdup(path);
+	task->created = TRUE;
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int add_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "addNetwork");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to add network");
+		dbus_message_unref(message);
+		return -EIO;
 	}
 
-	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-TERMINATING") == TRUE) {
-		printf("[SUPPLICANT] terminating\n");
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for network");
+		dbus_message_unref(reply);
+		return -EIO;
 	}
 
-	return TRUE;
+	DBG("path %s", path);
+
+	task->network = g_strdup(path);
+
+	dbus_message_unref(reply);
+
+	return 0;
 }
 
-static int open_control(struct supplicant_task *task)
+static int remove_network(struct supplicant_task *task)
 {
-	struct sockaddr_un addr;
-	int sk;
+	DBusMessage *message, *reply;
+	DBusError error;
 
-	printf("[SUPPLICANT] open control for %s\n", task->ifname);
+	DBG("task %p", task);
 
-	sk = socket(PF_UNIX, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "removeNetwork");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->network,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to remove network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int select_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
 
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
-	snprintf(addr.sun_path, sizeof(addr.sun_path),
-					"%s/%s.cli", STATEDIR, task->ifname);
-	//unlink(addr.sun_path);
+	DBG("task %p", task);
 
-	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		close(sk);
-		return -1;
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "selectNetwork");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->network,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to select network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int enable_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+					SUPPLICANT_INTF ".Network", "enable");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to enable network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int disable_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+					SUPPLICANT_INTF ".Network", "disable");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to disable network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
 	}
 
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
-	snprintf(addr.sun_path, sizeof(addr.sun_path),
-					"%s/%s", STATEDIR, task->ifname);
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
 
-	if (connect(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		close(sk);
-		return -1;
+static int set_network(struct supplicant_task *task, const char *network,
+						const char *passphrase)
+{
+	DBusMessage *message, *reply;
+	DBusMessageIter array, dict;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+					SUPPLICANT_INTF ".Network", "set");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_iter_init_append(message, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_entry(&dict, "ssid", DBUS_TYPE_STRING, &network);
+
+	if (passphrase && strlen(passphrase) > 0) {
+		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		//exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
+
+		append_entry(&dict, "psk", DBUS_TYPE_STRING, &passphrase);
+	} else {
+		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		//exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
 	}
 
-	task->socket = sk;
+	dbus_message_iter_close_container(&array, &dict);
 
-	task->channel = g_io_channel_unix_new(sk);
-	g_io_channel_set_close_on_unref(task->channel, TRUE);
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to set network options");
+		dbus_message_unref(message);
+		return -EIO;
+	}
 
-	g_io_add_watch(task->channel,
-			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
-						control_event, task);
+	dbus_message_unref(message);
 
-	exec_cmd(task, "ATTACH");
-	exec_cmd(task, "ADD_NETWORK");
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int initiate_scan(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+					SUPPLICANT_INTF ".Interface", "scan");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to initiate scan");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static void extract_ssid(struct supplicant_ap *ap, DBusMessageIter *value)
+{
+	DBusMessageIter array;
+	unsigned char *ssid;
+	int ssid_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ssid, &ssid_len);
+
+	ap->identifier = g_strdup((char *) ssid);
+}
+
+static void extract_wpaie(struct supplicant_ap *ap, DBusMessageIter *value)
+{
+	DBusMessageIter array;
+	unsigned char *ie;
+	int ie_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
+
+	if (ie_len > 0)
+		ap->has_wpa = TRUE;
+}
+
+static void extract_rsnie(struct supplicant_ap *ap, DBusMessageIter *value)
+{
+	DBusMessageIter array;
+	unsigned char *ie;
+	int ie_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
+
+	if (ie_len > 0)
+		ap->has_rsn = TRUE;
+}
+
+static void extract_capabilites(struct supplicant_ap *ap,
+						DBusMessageIter *value)
+{
+	guint capabilities;
+
+	dbus_message_iter_get_basic(value, &capabilities);
+
+	ap->capabilities = capabilities;
+
+	if (capabilities & IEEE80211_CAP_PRIVACY)
+		ap->has_wep = TRUE;
+}
+
+static int parse_network_properties(struct supplicant_task *task,
+							DBusMessage *message)
+{
+	DBusMessageIter array, dict;
+	struct supplicant_ap *ap;
+	int security = 0;
+
+	DBG("task %p", task);
+
+	ap = g_try_new0(struct supplicant_ap, 1);
+	if (ap == NULL)
+		return -ENOMEM;
+
+	dbus_message_iter_init(message, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		//dbus_message_iter_get_basic(&value, &val);
+
+		if (g_str_equal(key, "ssid") == TRUE)
+			extract_ssid(ap, &value);
+		else if (g_str_equal(key, "wpaie") == TRUE)
+			extract_wpaie(ap, &value);
+		else if (g_str_equal(key, "rsnie") == TRUE)
+			extract_rsnie(ap, &value);
+		else if (g_str_equal(key, "capabilities") == TRUE)
+			extract_capabilites(ap, &value);
+
+		dbus_message_iter_next(&dict);
+	}
+
+	DBG("SSID %s", ap->identifier);
+
+	if (ap->has_wep)
+		security |= 0x01;
+	if (ap->has_wpa)
+		security |= 0x02;
+	if (ap->has_rsn)
+		security |= 0x04;
+
+	connman_iface_indicate_station(task->iface,
+					ap->identifier, 25, security);
+
+	g_free(ap);
+
+	return 0;
+}
+
+static int get_network_properties(struct supplicant_task *task,
+							const char *path)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, path,
+						SUPPLICANT_INTF ".BSSID",
+								"properties");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to get network properties");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	parse_network_properties(task, reply);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int scan_results_available(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	char **results;
+	int i, num_results;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+						SUPPLICANT_INTF ".Interface",
+							"scanResults");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to request scan result");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error,
+				DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+						&results, &num_results,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for scan result");
+		dbus_message_unref(reply);
+		return -EIO;
+	}
+
+	for (i = 0; i < num_results; i++)
+		get_network_properties(task, results[i]);
+
+	g_strfreev(results);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static void state_change(struct supplicant_task *task, DBusMessage *msg)
+{
+	DBusError error;
+	const char *state, *previous;
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(msg, &error, DBUS_TYPE_STRING, &state,
+						DBUS_TYPE_STRING, &previous,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for state change");
+		return;
+	}
+
+	DBG("state %s ==> %s", previous, state);
+
+	if (g_str_equal(state, "INACTIVE") == TRUE)
+		task->state = STATE_INACTIVE;
+	else if (g_str_equal(state, "SCANNING") == TRUE)
+		task->state = STATE_SCANNING;
+	else if (g_str_equal(state, "ASSOCIATING") == TRUE)
+		task->state = STATE_ASSOCIATING;
+	else if (g_str_equal(state, "ASSOCIATED") == TRUE)
+		task->state = STATE_ASSOCIATED;
+	else if (g_str_equal(state, "GROUP_HANDSHAKE") == TRUE)
+		task->state = STATE_4WAY_HANDSHAKE;
+	else if (g_str_equal(state, "4WAY_HANDSHAKE") == TRUE)
+		task->state = STATE_4WAY_HANDSHAKE;
+	else if (g_str_equal(state, "COMPLETED") == TRUE)
+		task->state = STATE_COMPLETED;
+	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
+		task->state = STATE_DISCONNECTED;
+}
+
+static DBusHandlerResult supplicant_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
+{
+	struct supplicant_task *task = data;
+	const char *member;
+
+	if (dbus_message_has_interface(msg,
+				SUPPLICANT_INTF ".Interface") == FALSE)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	member = dbus_message_get_member(msg);
+	if (member == NULL)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	DBG("task %p member %s", task, member);
+
+	if (g_str_equal(member, "ScanResultsAvailable") == TRUE)
+		scan_results_available(task);
+	else if (g_str_equal(member, "StateChange") == TRUE)
+		state_change(task, msg);
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static int add_filter(struct supplicant_task *task)
+{
+	DBusError error;
+	gchar *filter;
+
+	if (dbus_connection_add_filter(task->conn,
+				supplicant_filter, task, NULL) == FALSE)
+		return -EIO;
+
+	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
+						SUPPLICANT_INTF, task->path);
+
+	DBG("filter %s", filter);
+
+	dbus_error_init(&error);
+
+	dbus_bus_add_match(task->conn, filter, &error);
+
+	g_free(filter);
+
+	if (dbus_error_is_set(&error) == TRUE) {
+		connman_error("Can't add match: %s", error.message);
+		dbus_error_free(&error);
+	}
 
 	return 0;
 }
@@ -159,7 +820,6 @@ int __supplicant_start(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct supplicant_task *task;
-	char *argv[9];
 	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
@@ -176,14 +836,14 @@ int __supplicant_start(struct connman_iface *iface)
 	if (err < 0)
 		return -EIO;
 
-	printf("[SUPPLICANT] start %s\n", ifr.ifr_name);
+	DBG("interface %s", ifr.ifr_name);
 
 	task = g_try_new0(struct supplicant_task, 1);
 	if (task == NULL)
 		return -ENOMEM;
 
 	task->ifindex = iface->index;
-	task->ifname = strdup(ifr.ifr_name);
+	task->ifname = g_strdup(ifr.ifr_name);
 	task->iface = iface;
 
 	if (task->ifname == NULL) {
@@ -191,32 +851,33 @@ int __supplicant_start(struct connman_iface *iface)
 		return -ENOMEM;
 	}
 
-	argv[0] = "/sbin/wpa_supplicant";
-	argv[1] = "-qq";
-	argv[2] = "-C";
-	argv[3] = STATEDIR;
-	argv[4] = "-D";
-	argv[5] = "wext";
-	argv[6] = "-i";
-	argv[7] = task->ifname;
-	argv[8] = NULL;
-
-	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
-				NULL, NULL, &task->pid, NULL) == FALSE) {
-		printf("Failed to spawn wpa_supplicant\n");
-		return -1;
+	task->conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (task->conn == NULL) {
+		g_free(task);
+		return -EIO;
+	}
+
+	task->created = FALSE;
+
+	err = get_interface(task);
+	if (err < 0) {
+		err = add_interface(task);
+		if (err < 0) {
+			g_free(task);
+			return err;
+		}
 	}
 
-	tasks = g_slist_append(tasks, task);
+	task->state = STATE_INACTIVE;
 
-	printf("[SUPPLICANT] executed with pid %d\n", task->pid);
+	tasks = g_slist_append(tasks, task);
 
-	sleep(1);
+	add_filter(task);
 
-	task->socket = -1;
+	add_network(task);
 
-	if (open_control(task) < 0)
-		printf("[SUPPLICANT] control failed\n");
+	select_network(task);
+	disable_network(task);
 
 	return 0;
 }
@@ -224,33 +885,51 @@ int __supplicant_start(struct connman_iface *iface)
 int __supplicant_stop(struct connman_iface *iface)
 {
 	struct supplicant_task *task;
-	char pathname[PATH_MAX];
 
 	task = find_task(iface->index);
 	if (task == NULL)
 		return -ENODEV;
 
-	printf("[SUPPLICANT] stop %s\n", task->ifname);
+	DBG("interface %s", task->ifname);
 
 	tasks = g_slist_remove(tasks, task);
 
-	exec_cmd(task, "DISABLE_NETWORK 0");
-	exec_cmd(task, "DETACH");
+	remove_network(task);
 
-	sleep(1);
+	dbus_connection_unref(task->conn);
+
+	g_free(task->ifname);
+	g_free(task->network);
+	g_free(task->path);
+	g_free(task);
 
-	kill(task->pid, SIGTERM);
+	return 0;
+}
 
-	g_io_channel_shutdown(task->channel, TRUE, NULL);
-	g_io_channel_unref(task->channel);
+int __supplicant_scan(struct connman_iface *iface)
+{
+	struct supplicant_task *task;
+	int err;
 
-	snprintf(pathname, sizeof(pathname),
-					"%s/%s.cli", STATEDIR, task->ifname);
-	unlink(pathname);
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
 
-	free(task->ifname);
+	DBG("interface %s", task->ifname);
+
+	switch (task->state) {
+	case STATE_SCANNING:
+		return -EALREADY;
+	case STATE_ASSOCIATING:
+	case STATE_ASSOCIATED:
+	case STATE_4WAY_HANDSHAKE:
+	case STATE_GROUP_HANDSHAKE:
+		return -EBUSY;
+	default:
+		break;
+	}
 
-	g_free(task);
+	err = initiate_scan(task);
 
 	return 0;
 }
@@ -259,34 +938,16 @@ int __supplicant_connect(struct connman_iface *iface,
 				const char *network, const char *passphrase)
 {
 	struct supplicant_task *task;
-	char cmd[128];
 
 	task = find_task(iface->index);
 	if (task == NULL)
 		return -ENODEV;
 
-	printf("[SUPPLICANT] connect %s\n", task->ifname);
-
-	exec_cmd(task, "DISABLE_NETWORK 0");
-
-	if (network == NULL)
-		return 0;
-
-	sprintf(cmd, "SET_NETWORK 0 ssid \"%s\"", network);
-	exec_cmd(task, cmd);
+	DBG("interface %s", task->ifname);
 
-	if (passphrase && strlen(passphrase) > 0) {
-		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
-
-		sprintf(cmd, "SET_NETWORK 0 psk \"%s\"", passphrase);
-		exec_cmd(task, cmd);
-	} else {
-		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
-	}
+	set_network(task, network, passphrase);
 
-	exec_cmd(task, "ENABLE_NETWORK 0");
+	enable_network(task);
 
 	return 0;
 }
@@ -299,9 +960,9 @@ int __supplicant_disconnect(struct connman_iface *iface)
 	if (task == NULL)
 		return -ENODEV;
 
-	printf("[SUPPLICANT] disconnect %s\n", task->ifname);
+	DBG("interface %s", task->ifname);
 
-	exec_cmd(task, "DISABLE_NETWORK 0");
+	disable_network(task);
 
 	return 0;
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index dc015ed7..59e4dfe9 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -21,9 +21,15 @@
 
 #include <connman/iface.h>
 
+#define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
+
 int __supplicant_start(struct connman_iface *iface);
 int __supplicant_stop(struct connman_iface *iface);
 
+int __supplicant_scan(struct connman_iface *iface);
+
 int __supplicant_connect(struct connman_iface *iface,
 				const char *network, const char *passphrase);
 int __supplicant_disconnect(struct connman_iface *iface);

commit 7294e829c825e0f7b56b4fdb83dbc2939c33ca71
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:53:14 2008 +0100

    Add simple test script for D-Bus supplicant

diff --git a/test/Makefile.am b/test/Makefile.am
index f3ae1831..02760295 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,5 @@
 
-EXTRA_DIST = list-interfaces start-scanning simple-agent show-introspection
+EXTRA_DIST = list-interfaces start-scanning simple-agent \
+				show-introspection test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/test-supplicant b/test/test-supplicant
new file mode 100755
index 00000000..e79228dd
--- /dev/null
+++ b/test/test-supplicant
@@ -0,0 +1,59 @@
+#!/usr/bin/python
+
+import dbus
+import time
+
+WPA_NAME='fi.epitest.hostap.WPASupplicant'
+WPA_INTF='fi.epitest.hostap.WPASupplicant'
+WPA_PATH='/fi/epitest/hostap/WPASupplicant'
+
+bus = dbus.SystemBus()
+
+dummy = dbus.Interface(bus.get_object(WPA_NAME, WPA_PATH),
+				'org.freedesktop.DBus.Introspectable')
+
+#print dummy.Introspect()
+
+manager = dbus.Interface(bus.get_object(WPA_NAME, WPA_PATH), WPA_INTF)
+
+try:
+	path = manager.getInterface("wlan0")
+except:
+	path = manager.addInterface("wlan0")
+
+interface = dbus.Interface(bus.get_object(WPA_NAME, path),
+					WPA_INTF + ".Interface")
+
+print interface.state()
+
+print interface.scan()
+
+print "[ %s ]" % (path)
+
+capabilities = interface.capabilities()
+
+for key in capabilities.keys():
+	list = ""
+	for value in capabilities[key]:
+		list += " " + value
+	print "    %s =%s" % (key, list)
+
+time.sleep(2)
+
+print interface.state()
+
+results = interface.scanResults()
+
+print results
+
+path = results[0]
+
+print "[ %s ]" % (path)
+
+bssid = dbus.Interface(bus.get_object(WPA_NAME, path),
+					WPA_INTF + ".BSSID")
+
+properties = bssid.properties()
+
+for key in properties.keys():
+	print "    %s = %s" % (key, properties[key])

commit 7b820de508eeac0f7a38dc795dd224e7f283df52
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 15:11:31 2008 +0100

    Add D-Bus configuration files for supplicant

diff --git a/.gitignore b/.gitignore
index 4fb1449a..722951ea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,3 +27,4 @@ src/connmand
 src/connman.service
 scripts/connman
 scripts/dhclient-script
+scripts/fi.epitest.hostap.WPASupplicant.service
diff --git a/configure.in b/configure.in
index ba478e16..9918d72f 100644
--- a/configure.in
+++ b/configure.in
@@ -41,6 +41,8 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
+AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
+
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
 				AC_MSG_ERROR(gmodule is required))
 AC_SUBST(GMODULE_CFLAGS)
@@ -63,4 +65,6 @@ AC_SUBST(HAL_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
 			test/Makefile plugins/Makefile scripts/Makefile
+			scripts/fi.epitest.hostap.WPASupplicant.service
 			scripts/connman src/connman.service connman.pc)
+			
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 1247398f..b860d5bd 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -3,7 +3,15 @@ initdir = $(sysconfdir)/init.d
 
 init_SCRIPTS = connman
 
-DISTCLEANFILES = $(init_SCRIPTS)
+dbusdir = $(sysconfdir)/dbus-1/system.d
+
+dbus_DATA = fi.epitest.hostap.WPASupplicant.conf
+
+servicedir = $(datadir)/dbus-1/system-services
+
+service_DATA = fi.epitest.hostap.WPASupplicant.service
+
+DISTCLEANFILES = $(init_SCRIPTS) $(service_DATA)
 
 scriptdir = $(libdir)/connman/scripts
 
@@ -15,6 +23,6 @@ dhclient_script_LDADD = @DBUS_LIBS@
 
 AM_CFLAGS = @DBUS_CFLAGS@
 
-EXTRA_DIST = $(script_DATA)
+EXTRA_DIST = $(script_DATA) $(dbus_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/scripts/fi.epitest.hostap.WPASupplicant.conf b/scripts/fi.epitest.hostap.WPASupplicant.conf
new file mode 100644
index 00000000..fa7afca0
--- /dev/null
+++ b/scripts/fi.epitest.hostap.WPASupplicant.conf
@@ -0,0 +1,10 @@
+<!DOCTYPE busconfig PUBLIC
+ "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+	<policy user="root">
+		<allow own="fi.epitest.hostap.WPASupplicant"/>
+		<allow send_destination="fi.epitest.hostap.WPASupplicant"/>
+		<allow send_interface="fi.epitest.hostap.WPASupplicant"/>
+	</policy>
+</busconfig>
diff --git a/scripts/fi.epitest.hostap.WPASupplicant.service.in b/scripts/fi.epitest.hostap.WPASupplicant.service.in
new file mode 100644
index 00000000..cdd2a030
--- /dev/null
+++ b/scripts/fi.epitest.hostap.WPASupplicant.service.in
@@ -0,0 +1,4 @@
+[D-BUS Service]
+Name=fi.epitest.hostap.WPASupplicant
+Exec=@WPASUPPLICANT@ -u
+User=root

commit 044f4199fa31ff8ec4f9c91c051e05fc3cf14d0f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 13 23:27:05 2008 +0100

    Use list of known networks to re-connect to

diff --git a/src/connman.h b/src/connman.h
index c253a8e3..f9416d2f 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -70,6 +70,8 @@ int __connman_iface_init_via_inet(struct connman_iface *iface);
 int __connman_iface_up(struct connman_iface *iface);
 int __connman_iface_down(struct connman_iface *iface);
 
+char *__connman_iface_find_passphrase(struct connman_iface *iface,
+							const char *network);
 int __connman_iface_load(struct connman_iface *iface);
 int __connman_iface_store(struct connman_iface *iface);
 
diff --git a/src/iface-storage.c b/src/iface-storage.c
index a5b57a38..7872f7cc 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -32,10 +32,62 @@
 
 #define GROUP_CONFIG  "Config"
 
+char *__connman_iface_find_passphrase(struct connman_iface *iface,
+							const char *network)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *result = NULL;
+	gchar **list;
+	gsize list_len;
+	int i;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return NULL;
+
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
+	if (pathname == NULL)
+		return NULL;
+
+	keyfile = g_key_file_new();
+
+	g_key_file_set_list_separator(keyfile, ',');
+
+	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
+		goto done;
+
+	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
+		goto done;
+
+	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
+					"KnownNetworks", &list_len, NULL);
+	for (i = 0; i < list_len; i++)
+		if (g_str_equal(list[i], network) == TRUE) {
+			result = g_key_file_get_string(keyfile, network,
+								"PSK", NULL);
+			if (result == NULL)
+				result = g_strdup("");
+			break;
+		}
+
+	g_strfreev(list);
+
+done:
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return result;
+}
+
 int __connman_iface_load(struct connman_iface *iface)
 {
 	GKeyFile *keyfile;
 	gchar *pathname, *str;
+	gchar **list;
+	gsize list_len;
 
 	DBG("iface %p", iface);
 
@@ -49,6 +101,8 @@ int __connman_iface_load(struct connman_iface *iface)
 
 	keyfile = g_key_file_new();
 
+	g_key_file_set_list_separator(keyfile, ',');
+
 	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
 		goto done;
 
@@ -61,7 +115,13 @@ int __connman_iface_load(struct connman_iface *iface)
 		g_free(str);
 	}
 
-	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Network", NULL);
+	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
+					"KnownNetworks", &list_len, NULL);
+
+	g_strfreev(list);
+
+	str = g_key_file_get_string(keyfile, GROUP_CONFIG,
+						"LastNetwork", NULL);
 	if (str != NULL) {
 		g_free(iface->network.identifier);
 		iface->network.identifier = str;
@@ -93,9 +153,10 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 
 	if (iface->network.identifier != NULL) {
 		g_key_file_set_string(keyfile, GROUP_CONFIG,
-				"Network", iface->network.identifier);
+				"LastNetwork", iface->network.identifier);
 	} else
-		g_key_file_remove_key(keyfile, GROUP_CONFIG, "Network", NULL);
+		g_key_file_remove_key(keyfile, GROUP_CONFIG,
+						"LastNetwork", NULL);
 
 	if (iface->network.identifier != NULL)
 		g_key_file_set_string(keyfile, iface->network.identifier,
diff --git a/src/iface.c b/src/iface.c
index b9fe5133..a35d22aa 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -360,6 +360,7 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 				const char *name, int strength, int security)
 {
 	DBusMessage *signal;
+	char *passphrase;
 
 	DBG("iface %p security %d name %s", iface, security, name);
 
@@ -376,9 +377,15 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
 
-	if (g_str_equal(name, iface->network.identifier) == TRUE &&
-			iface->state == CONNMAN_IFACE_STATE_SCANNING) {
+	if (iface->state != CONNMAN_IFACE_STATE_SCANNING)
+		return;
+
+	passphrase = __connman_iface_find_passphrase(iface, name);
+	if (passphrase != NULL) {
+		g_free(iface->network.identifier);
 		iface->network.identifier = g_strdup(name);
+		g_free(iface->network.passphrase);
+		iface->network.passphrase = passphrase;
 
 		if (iface->driver->connect) {
 			iface->driver->connect(iface, &iface->network);

commit 33cb960a324fd72da810168b4fe5e234802cd70f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 13 23:34:03 2008 +0100

    Use debug helper for the RTNL debugging output

diff --git a/src/rtnl.c b/src/rtnl.c
index e4996fb9..c4fbf447 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -23,7 +23,6 @@
 #include <config.h>
 #endif
 
-#include <stdio.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/socket.h>
@@ -57,30 +56,30 @@ static inline void print_inet(struct rtattr *attr, const char *name, int family)
 	if (family == AF_INET) {
 		struct in_addr addr;
 		addr = *((struct in_addr *) RTA_DATA(attr));
-		printf("  attr %s (len %jd) %s\n",
+		DBG("  attr %s (len %jd) %s\n",
 				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
 	} else
-		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
+		DBG("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 }
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
+	DBG("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_byte(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
+	DBG("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
 					*((unsigned char *) RTA_DATA(attr)));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
+		DBG("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 	else
-		printf("  attr %d (len %jd)\n",
+		DBG("  attr %d (len %jd)\n",
 					attr->rta_type, RTA_PAYLOAD(attr));
 }
 

commit 50d81ec56ebdc56fc72d80c189751b40f76738e2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 10:44:57 2008 +0100

    Add debug line for found passphrases

diff --git a/src/iface.c b/src/iface.c
index a35d22aa..4a655a14 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -382,6 +382,8 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 
 	passphrase = __connman_iface_find_passphrase(iface, name);
 	if (passphrase != NULL) {
+		DBG("network %s passphrase %s", name, passphrase);
+
 		g_free(iface->network.identifier);
 		iface->network.identifier = g_strdup(name);
 		g_free(iface->network.passphrase);

commit 1b42fcf6db8cbbcc8cb67dab136b97249c0f0329
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:02:06 2008 +0100

    Add abstraction for resolver modifications

diff --git a/include/Makefile.am b/include/Makefile.am
index ecca9287..4c10f173 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h
+noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h resolver.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/resolver.h b/include/resolver.h
new file mode 100644
index 00000000..3d9f9902
--- /dev/null
+++ b/include/resolver.h
@@ -0,0 +1,44 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_RESOLVER_H
+#define __CONNMAN_RESOLVER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/iface.h>
+
+struct connman_resolver_driver {
+	const char *name;
+	int (*append) (struct connman_iface *iface, const char *nameserver);
+	int (*remove) (struct connman_iface *iface);
+};
+
+extern int connman_resolver_register(struct connman_resolver_driver *driver);
+extern void connman_resolver_unregister(struct connman_resolver_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_RESOLVER_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 7faf6a22..f430368f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -13,7 +13,7 @@ sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
 				iface.c iface-storage.c iface-helper.c \
-						iface-inet.c rtnl.c dhcp.c
+					iface-inet.c rtnl.c dhcp.c resolver.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index f9416d2f..9f1262a0 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -94,3 +94,9 @@ int __connman_rtnl_send(const void *buf, size_t len);
 
 int __connman_dhcp_request(struct connman_iface *iface);
 int __connman_dhcp_release(struct connman_iface *iface);
+
+#include <connman/resolver.h>
+
+int __connman_resolver_append(struct connman_iface *iface,
+						const char *nameserver);
+int __connman_resolver_remove(struct connman_iface *iface);
diff --git a/src/iface.c b/src/iface.c
index 4a655a14..89763aaf 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -431,7 +431,6 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 	struct ifreq ifr;
 	struct rtentry rt;
 	struct sockaddr_in *addr;
-	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -504,12 +503,7 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 		return -1;
 	}
 
-	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
-				inet_ntoa(ipv4->nameserver), ifr.ifr_name);
-
-	DBG("%s", cmd);
-
-	err = system(cmd);
+	__connman_resolver_append(iface, inet_ntoa(ipv4->nameserver));
 
 	return 0;
 }
@@ -518,7 +512,6 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct sockaddr_in *addr;
-	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -554,11 +547,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 		return -1;
 	}
 
-	sprintf(cmd, "resolvconf -d %s", ifr.ifr_name);
-
-	DBG("%s", cmd);
-
-	err = system(cmd);
+	__connman_resolver_remove(iface);
 
 	return 0;
 }
diff --git a/src/resolver.c b/src/resolver.c
new file mode 100644
index 00000000..f2443d76
--- /dev/null
+++ b/src/resolver.c
@@ -0,0 +1,67 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+
+#include "connman.h"
+
+static GSList *drivers = NULL;
+
+int connman_resolver_register(struct connman_resolver_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_append(drivers, driver);
+
+	return 0;
+}
+
+void connman_resolver_unregister(struct connman_resolver_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_remove(drivers, driver);
+}
+
+int __connman_resolver_append(struct connman_iface *iface,
+						const char *nameserver)
+{
+	struct connman_resolver_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->append)
+		return driver->append(iface, nameserver);
+
+	return -1;
+}
+
+int __connman_resolver_remove(struct connman_iface *iface)
+{
+	struct connman_resolver_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->remove)
+		return driver->remove(iface);
+
+	return -1;
+}

commit a5541065ee14e6582402ce586009c3144fcff33f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:02:49 2008 +0100

    Add resolver plugin using resolvconf helper tool

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2f789ec3..87464b04 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,7 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
-			libconnman-dhclient.la
+			libconnman-dhclient.la libconnman-resolvconf.la
 
 libconnman_80203_la_SOURCES = 80203.c
 
@@ -11,6 +11,8 @@ libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
 
+libconnman_resolvconf_la_SOURCES = resolvconf.c
+
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
 statedir = $(localstatedir)/run/connman
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
new file mode 100644
index 00000000..732db4f0
--- /dev/null
+++ b/plugins/resolvconf.c
@@ -0,0 +1,118 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+
+#include <connman/plugin.h>
+#include <connman/resolver.h>
+#include <connman/log.h>
+
+static int resolvconf_append(struct connman_iface *iface, const char *nameserver)
+{
+	struct ifreq ifr;
+	char cmd[128];
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -1;
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	snprintf(cmd, sizeof(cmd), "echo \"nameserver %s\" | resolvconf -a %s",
+						nameserver, ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	err = system(cmd);
+
+	return 0;
+}
+
+static int resolvconf_remove(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	char cmd[128];
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -1;
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	snprintf(cmd, sizeof(cmd), "resolvconf -d %s", ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	err = system(cmd);
+
+	return 0;
+}
+
+static struct connman_resolver_driver resolvconf_driver = {
+	.name		= "resolvconf",
+	.append		= resolvconf_append,
+	.remove		= resolvconf_remove,
+};
+
+static int resolvconf_init(void)
+{
+	return connman_resolver_register(&resolvconf_driver);
+}
+
+static void resolvconf_exit(void)
+{
+	connman_resolver_unregister(&resolvconf_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("resolvconf", "Name resolver plugin", VERSION,
+					resolvconf_init, resolvconf_exit)

commit b0bb819c7fbc262118cdf3645079a8f867a03b21
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:29:05 2008 +0100

    Add more debug output for known networks

diff --git a/src/iface-storage.c b/src/iface-storage.c
index 7872f7cc..6694d992 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -63,14 +63,19 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 
 	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
 					"KnownNetworks", &list_len, NULL);
-	for (i = 0; i < list_len; i++)
+	for (i = 0; i < list_len; i++) {
+		DBG("known network %s", list[i]);
+
 		if (g_str_equal(list[i], network) == TRUE) {
+			DBG("found network %s", network);
+
 			result = g_key_file_get_string(keyfile, network,
 								"PSK", NULL);
 			if (result == NULL)
 				result = g_strdup("");
 			break;
 		}
+	}
 
 	g_strfreev(list);
 

commit 22d523336fe891bd57af03e919d8fc59be4b2609
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:30:08 2008 +0100

    Fix handling of networks without security

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index c8853e12..0ec9304d 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -51,18 +51,6 @@ enum supplicant_state {
 	STATE_DISCONNECTED,
 };
 
-// COMPLETED       ==> ASSOCIATING
-// ASSOCIATED      ==> DISCONNECTED
-// DISCONNECTED    ==> INACTIVE
-
-// DISCONNECTED    ==> SCANNING
-// SCANNING        ==> ASSOCIATED
-
-// ASSOCIATING     ==> ASSOCIATED
-// ASSOCIATED      ==> 4WAY_HANDSHAKE
-// 4WAY_HANDSHAKE  ==> GROUP_HANDSHAKE
-// GROUP_HANDSHAKE ==> COMPLETED
-
 struct supplicant_task {
 	DBusConnection *conn;
 	int ifindex;
@@ -457,13 +445,12 @@ static int set_network(struct supplicant_task *task, const char *network,
 	append_entry(&dict, "ssid", DBUS_TYPE_STRING, &network);
 
 	if (passphrase && strlen(passphrase) > 0) {
-		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		//exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
-
+		const char *key_mgmt = "WPA-PSK";
+		append_entry(&dict, "key_mgmt", DBUS_TYPE_STRING, &key_mgmt);
 		append_entry(&dict, "psk", DBUS_TYPE_STRING, &passphrase);
 	} else {
-		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		//exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
+		const char *key_mgmt = "NONE";
+		append_entry(&dict, "key_mgmt", DBUS_TYPE_STRING, &key_mgmt);
 	}
 
 	dbus_message_iter_close_container(&array, &dict);

commit dc405c55dc7e4a4cc2533e8103adac7340d6d8de
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 13:33:56 2008 +0100

    Update DHCP plugin to use D-Bus low-level calls

diff --git a/configure.in b/configure.in
index 9918d72f..68301053 100644
--- a/configure.in
+++ b/configure.in
@@ -41,6 +41,7 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
+AC_PATH_PROG(DHCLIENT, [dhclient])
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
 
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 87464b04..3ecb1aef 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -10,6 +10,8 @@ libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
 libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
+libconnman_dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
+		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
 libconnman_resolvconf_la_SOURCES = resolvconf.c
 
@@ -23,8 +25,7 @@ else
 scriptdir = $(libdir)/connman/scripts
 endif
 
-AM_CFLAGS = @GDBUS_CFLAGS@ \
-		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
+AM_CFLAGS = @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 211b84ef..8847a1de 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -29,6 +29,7 @@
 #include <stdlib.h>
 #include <signal.h>
 #include <string.h>
+#include <sys/wait.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
@@ -40,6 +41,9 @@
 #include <connman/plugin.h>
 #include <connman/dhcp.h>
 
+#define DHCLIENT_INTF "org.isc.dhclient"
+#define DHCLIENT_PATH "/org/isc/dhclient"
+
 static const char *busname;
 
 struct dhclient_task {
@@ -83,7 +87,8 @@ static void kill_task(struct dhclient_task *task)
 {
 	char pathname[PATH_MAX];
 
-	kill(task->pid, SIGTERM);
+	if (task->pid > 0)
+		kill(task->pid, SIGTERM);
 
 	snprintf(pathname, sizeof(pathname) - 1,
 			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
@@ -98,11 +103,37 @@ static void kill_task(struct dhclient_task *task)
 	g_free(task);
 }
 
+static void task_died(GPid pid, gint status, gpointer data)
+{
+	struct dhclient_task *task = data;
+
+	if (WIFEXITED(status))
+		printf("[DHCP] exit status %d for %s\n",
+					WEXITSTATUS(status), task->ifname);
+	else
+		printf("[DHCP] signal %d killed %s\n",
+					WTERMSIG(status), task->ifname);
+
+	g_spawn_close_pid(pid);
+	task->pid = 0;
+
+	tasks = g_slist_remove(tasks, task);
+
+	kill_task(task);
+}
+
+static void task_setup(gpointer data)
+{
+	struct dhclient_task *task = data;
+
+	printf("[DHCP] setup %s\n", task->ifname);
+}
+
 static int dhclient_request(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct dhclient_task *task;
-	char *argv[16], address[128], pidfile[PATH_MAX];
+	char *argv[16], *envp[1], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
 	int sk, err;
 
@@ -143,7 +174,7 @@ static int dhclient_request(struct connman_iface *iface)
 	snprintf(config, sizeof(config) - 1, "%s/dhclient.conf", SCRIPTDIR);
 	snprintf(script, sizeof(script) - 1, "%s/dhclient-script", SCRIPTDIR);
 
-	argv[0] = "/sbin/dhclient";
+	argv[0] = DHCLIENT;
 	argv[1] = "-d";
 	argv[2] = "-q";
 	argv[3] = "-n";
@@ -160,15 +191,19 @@ static int dhclient_request(struct connman_iface *iface)
 	argv[14] = task->ifname;
 	argv[15] = NULL;
 
-	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
-				NULL, NULL, &task->pid, NULL) == FALSE) {
+	envp[0] = NULL;
+
+	if (g_spawn_async(NULL, argv, envp, G_SPAWN_DO_NOT_REAP_CHILD,
+				task_setup, task, &task->pid, NULL) == FALSE) {
 		printf("Failed to spawn dhclient\n");
 		return -1;
 	}
 
 	tasks = g_slist_append(tasks, task);
 
-	printf("[DHCP] executed with pid %d\n", task->pid);
+	g_child_watch_add(task->pid, task_died, task);
+
+	printf("[DHCP] executed %s with pid %d\n", DHCLIENT, task->pid);
 
 	return 0;
 }
@@ -196,8 +231,8 @@ static struct connman_dhcp_driver dhclient_driver = {
 	.release	= dhclient_release,
 };
 
-static DBusMessage *notify_method(DBusConnection *conn,
-					DBusMessage *msg, void *data)
+static DBusHandlerResult dhclient_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
 {
 	DBusMessageIter iter, dict;
 	dbus_uint32_t pid;
@@ -205,6 +240,9 @@ static DBusMessage *notify_method(DBusConnection *conn,
 	struct connman_ipv4 ipv4;
 	const char *text, *key, *value;
 
+	if (dbus_message_is_method_call(msg, DHCLIENT_INTF, "notify") == FALSE)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
 	memset(&ipv4, 0, sizeof(ipv4));
 
 	dbus_message_iter_init(msg, &iter);
@@ -219,7 +257,7 @@ static DBusMessage *notify_method(DBusConnection *conn,
 
 	task = find_task_by_pid(pid);
 	if (task == NULL)
-		return NULL;
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
 	dbus_message_iter_recurse(&iter, &dict);
 
@@ -267,27 +305,29 @@ static DBusMessage *notify_method(DBusConnection *conn,
 		connman_dhcp_update(task->iface,
 					CONNMAN_DHCP_STATE_FAILED, NULL);
 
-	return NULL;
+	return DBUS_HANDLER_RESULT_HANDLED;
 }
 
-static GDBusMethodTable dhclient_methods[] = {
-	{ "notify", "usa{ss}", "", notify_method, G_DBUS_METHOD_FLAG_NOREPLY },
-	{ },
-};
-
 static DBusConnection *connection;
 
 static int plugin_init(void)
 {
-	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL, NULL);
+	gchar *filter;
+
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 
 	busname = dbus_bus_get_unique_name(connection);
 
-	g_dbus_register_object(connection, "/org/isc/dhclient", NULL, NULL);
+	busname = "org.freedesktop.connman";
+
+	dbus_connection_add_filter(connection, dhclient_filter, NULL, NULL);
+
+	filter = g_strdup_printf("interface=%s,path=%s",
+						DHCLIENT_INTF, DHCLIENT_PATH);
+
+	dbus_bus_add_match(connection, filter, NULL);
 
-	g_dbus_register_interface(connection, "/org/isc/dhclient",
-					"org.isc.dhclient",
-					dhclient_methods, NULL, NULL);
+	g_free(filter);
 
 	connman_dhcp_register(&dhclient_driver);
 
@@ -310,7 +350,7 @@ static void plugin_exit(void)
 
 	connman_dhcp_unregister(&dhclient_driver);
 
-	g_dbus_cleanup_connection(connection);
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("dhclient", "ISC DHCP client plugin", VERSION,
diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
index 39b235c7..f4a8431f 100644
--- a/scripts/dhclient-script.c
+++ b/scripts/dhclient-script.c
@@ -56,6 +56,7 @@ static void append(DBusMessageIter *dict, const char *pattern)
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
+	DBusError error;
 	DBusMessage *msg;
 	DBusMessageIter iter, dict;
 	dbus_uint32_t pid;
@@ -67,17 +68,28 @@ int main(int argc, char *argv[])
 	reason = getenv("reason");
 	interface = getenv("interface");
 
-	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
-	if (conn == NULL)
-		exit(1);
+	dbus_error_init(&error);
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+	if (conn == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			fprintf(stderr, "%s\n", error.message);
+			dbus_error_free(&error);
+		} else
+			fprintf(stderr, "Failed to get on system bus\n");
+		return 0;
+	}
 
 	msg = dbus_message_new_method_call(busname, "/org/isc/dhclient",
 						"org.isc.dhclient", "notify");
 	if (msg == NULL) {
 		dbus_connection_unref(conn);
-		exit(1);
+		fprintf(stderr, "Failed to allocate method call\n");
+		return 0;
 	}
 
+	dbus_message_set_no_reply(msg, TRUE);
+
 	dbus_message_append_args(msg, DBUS_TYPE_UINT32, &pid,
 				DBUS_TYPE_STRING, &reason, DBUS_TYPE_INVALID);
 
@@ -100,7 +112,8 @@ int main(int argc, char *argv[])
 
 	dbus_message_iter_close_container(&iter, &dict);
 
-	dbus_connection_send(conn, msg, NULL);
+	if (dbus_connection_send(conn, msg, NULL) == FALSE)
+		fprintf(stderr, "Failed to send message\n");
 
 	dbus_message_unref(msg);
 

commit 2d73c3b7cff221f5778ee8f82c3f2a44e96984d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 13:34:33 2008 +0100

    Add allow policy for org.isc.dhclient

diff --git a/src/connman.conf b/src/connman.conf
index 4e83980e..4e3567e6 100644
--- a/src/connman.conf
+++ b/src/connman.conf
@@ -3,9 +3,11 @@
 <busconfig>
     <policy user="root">
         <allow own="org.freedesktop.connman"/>
+        <allow send_destination="org.freedesktop.connman"/>
+        <allow send_interface="org.isc.dhclient"/>
     </policy>
     <policy at_console="true">
-        <allow send_interface="org.freedesktop.connman"/>
         <allow send_destination="org.freedesktop.connman"/>
+        <allow send_interface="org.freedesktop.connman"/>
     </policy>
 </busconfig>

commit 610964c498aa86bed1086abafabdd2496ebafbc9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 13:42:13 2008 +0100

    The only supported IPv4 method is DHCP at the moment

diff --git a/src/connman.h b/src/connman.h
index 9f1262a0..fbba1e69 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -25,6 +25,8 @@
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
+#define CONNMAN_ERROR_INTERFACE  CONNMAN_SERVICE ".Error"
+
 #define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
 
 #define CONNMAN_MANAGER_PATH       "/"
diff --git a/src/iface.c b/src/iface.c
index 89763aaf..3632a685 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -884,7 +884,7 @@ static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	str = __connman_ipv4_method2string(iface->ipv4.method);
+	str = __connman_ipv4_method2string(CONNMAN_IPV4_METHOD_DHCP);
 	append_entry(&dict, "Method", DBUS_TYPE_STRING, &str);
 
 	if (iface->ipv4.address.s_addr != INADDR_ANY) {
@@ -932,6 +932,9 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	return dbus_message_new_error(msg, CONNMAN_ERROR_INTERFACE
+						".NotImplemented", "");
+
 	dbus_message_iter_init(msg, &array);
 
 	dbus_message_iter_recurse(&array, &dict);

commit 15e9803aefdf8996a9b4bdb0388500adef9577ed
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 26 21:47:24 2008 +0100

    Add workaround for my D-Link access point

diff --git a/src/iface.c b/src/iface.c
index 3632a685..6a9aa847 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -360,7 +360,8 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 				const char *name, int strength, int security)
 {
 	DBusMessage *signal;
-	char *passphrase;
+	char *ssid, *passphrase;
+	int len;
 
 	DBG("iface %p security %d name %s", iface, security, name);
 
@@ -380,12 +381,21 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	if (iface->state != CONNMAN_IFACE_STATE_SCANNING)
 		return;
 
-	passphrase = __connman_iface_find_passphrase(iface, name);
+	len = strlen(name);
+	ssid = strdup(name);
+	if (ssid == NULL)
+		return;
+
+	/* The D-Link access points return a 0x05 at the end of the SSID */
+	if (ssid[len - 1] == '\05')
+		ssid[len - 1] = '\0';
+
+	passphrase = __connman_iface_find_passphrase(iface, ssid);
 	if (passphrase != NULL) {
-		DBG("network %s passphrase %s", name, passphrase);
+		DBG("network %s passphrase %s", ssid, passphrase);
 
 		g_free(iface->network.identifier);
-		iface->network.identifier = g_strdup(name);
+		iface->network.identifier = g_strdup(ssid);
 		g_free(iface->network.passphrase);
 		iface->network.passphrase = passphrase;
 
@@ -395,6 +405,8 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 			state_changed(iface);
 		}
 	}
+
+	free(ssid);
 }
 
 int connman_iface_get_ipv4(struct connman_iface *iface,

commit f665a9a97091d30616d84a055a0af3a1df5449f2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 28 21:34:34 2008 +0100

    Fix DHCP release and dhclient termination

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 8847a1de..c37e6888 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -85,27 +85,14 @@ static struct dhclient_task *find_task_by_index(int index)
 
 static void kill_task(struct dhclient_task *task)
 {
-	char pathname[PATH_MAX];
-
 	if (task->pid > 0)
 		kill(task->pid, SIGTERM);
-
-	snprintf(pathname, sizeof(pathname) - 1,
-			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
-	unlink(pathname);
-
-	snprintf(pathname, sizeof(pathname) - 1,
-			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
-	unlink(pathname);
-
-	free(task->ifname);
-
-	g_free(task);
 }
 
 static void task_died(GPid pid, gint status, gpointer data)
 {
 	struct dhclient_task *task = data;
+	char pathname[PATH_MAX];
 
 	if (WIFEXITED(status))
 		printf("[DHCP] exit status %d for %s\n",
@@ -119,7 +106,17 @@ static void task_died(GPid pid, gint status, gpointer data)
 
 	tasks = g_slist_remove(tasks, task);
 
-	kill_task(task);
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	free(task->ifname);
+
+	g_free(task);
 }
 
 static void task_setup(gpointer data)

commit f84146ee1dcbf0942097937909c5875748d7108b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 28 21:37:55 2008 +0100

    Also check for the plugin suffix

diff --git a/src/Makefile.am b/src/Makefile.am
index f430368f..83eb87f9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -22,7 +22,7 @@ statedir = $(localstatedir)/run/connman
 storagedir = $(localstatedir)/lib/connman
 
 if MAINTAINER_MODE
-plugindir = $(abs_top_srcdir)/plugins
+plugindir = $(abs_top_srcdir)/plugins/.libs
 else
 plugindir = $(libdir)/connman/plugins
 endif
diff --git a/src/plugin.c b/src/plugin.c
index 8e164e1e..801df8b4 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -69,7 +69,8 @@ static void load_plugins(const gchar *path)
 			GModule *module;
 			struct connman_plugin_desc *desc;
 
-			if (g_str_has_prefix(file, "libconnman") == FALSE)
+			if (g_str_has_prefix(file, "libconnman") == FALSE ||
+					g_str_has_suffix(file, ".so") == FALSE)
 				continue;
 
 			filename = g_build_filename(path, file, NULL);

commit d3b8d6bdccf7640a4bf2f4b958ac80577d5bb281
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 28 22:55:09 2008 +0100

    Remove filter on device removal

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 0ec9304d..ad97f001 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -803,6 +803,32 @@ static int add_filter(struct supplicant_task *task)
 	return 0;
 }
 
+static int remove_filter(struct supplicant_task *task)
+{
+	DBusError error;
+	gchar *filter;
+
+	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
+						SUPPLICANT_INTF, task->path);
+
+	DBG("filter %s", filter);
+
+	dbus_error_init(&error);
+
+	dbus_bus_add_match(task->conn, filter, &error);
+
+	g_free(filter);
+
+	if (dbus_error_is_set(&error) == TRUE) {
+		connman_error("Can't add match: %s", error.message);
+		dbus_error_free(&error);
+	}
+
+	dbus_connection_remove_filter(task->conn, supplicant_filter, task);
+
+	return 0;
+}
+
 int __supplicant_start(struct connman_iface *iface)
 {
 	struct ifreq ifr;
@@ -881,6 +907,8 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	tasks = g_slist_remove(tasks, task);
 
+	remove_filter(task);
+
 	remove_network(task);
 
 	dbus_connection_unref(task->conn);

commit 53d969dd73a36b57bbcb705e325d2b68a2ba1e23
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 1 22:48:16 2008 +0200

    Don't return IPv4 settings when in off or ignore policy

diff --git a/src/iface.c b/src/iface.c
index 6a9aa847..a4e154e9 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -925,6 +925,15 @@ static DBusMessage *get_ipv4(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	switch (iface->policy) {
+	case CONNMAN_IFACE_POLICY_OFF:
+	case CONNMAN_IFACE_POLICY_IGNORE:
+		return dbus_message_new_error(msg, CONNMAN_ERROR_INTERFACE
+						".NotAvailable", "");
+	default:
+		break;
+	}
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;

commit 45541d278519384fe25be74a196254d281012019
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 06:01:07 2008 +0200

    Update state machine handling for wireless networks

diff --git a/include/iface.h b/include/iface.h
index 37e60672..8b0e6c8f 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -38,10 +38,15 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_RTNL     = (1 << 0),
-	CONNMAN_IFACE_FLAG_IPV4     = (1 << 1),
-	CONNMAN_IFACE_FLAG_IPV6     = (1 << 2),
-	CONNMAN_IFACE_FLAG_SCANNING = (1 << 3),
+	CONNMAN_IFACE_FLAG_RTNL      = (1 << 0),
+	CONNMAN_IFACE_FLAG_IPV4      = (1 << 1),
+	CONNMAN_IFACE_FLAG_IPV6      = (1 << 2),
+	CONNMAN_IFACE_FLAG_SCANNING  = (1 << 3),
+	CONNMAN_IFACE_FLAG_NOCARRIER = (1 << 4),
+
+	CONNMAN_IFACE_FLAG_STARTED   = (1 << 16),
+	CONNMAN_IFACE_FLAG_RUNNING   = (1 << 17),
+	CONNMAN_IFACE_FLAG_DHCP      = (1 << 18),
 };
 
 enum connman_iface_state {
@@ -94,7 +99,7 @@ struct connman_iface {
 	char *identifier;
 	int index;
 	enum connman_iface_type type;
-	enum connman_iface_flags flags;
+	unsigned long flags;
 	enum connman_iface_state state;
 	enum connman_iface_policy policy;
 	struct connman_network network;
@@ -146,8 +151,8 @@ static inline void connman_iface_set_data(struct connman_iface *iface,
 	iface->driver_data = data;
 }
 
-extern void connman_iface_indicate_enabled(struct connman_iface *iface);
-extern void connman_iface_indicate_disabled(struct connman_iface *iface);
+extern void connman_iface_indicate_ifup(struct connman_iface *iface);
+extern void connman_iface_indicate_ifdown(struct connman_iface *iface);
 extern void connman_iface_indicate_connected(struct connman_iface *iface);
 extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
 extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
diff --git a/src/connman.h b/src/connman.h
index fbba1e69..e8ca3e73 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -69,8 +69,11 @@ void __connman_iface_list(DBusMessageIter *iter);
 
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
-int __connman_iface_up(struct connman_iface *iface);
-int __connman_iface_down(struct connman_iface *iface);
+int __connman_iface_start(struct connman_iface *iface);
+int __connman_iface_stop(struct connman_iface *iface);
+int __connman_iface_connect(struct connman_iface *iface,
+					struct connman_network *network);
+int __connman_iface_disconnect(struct connman_iface *iface);
 
 char *__connman_iface_find_passphrase(struct connman_iface *iface,
 							const char *network);
diff --git a/src/dhcp.c b/src/dhcp.c
index ecf61f2b..3b6ba637 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -76,8 +76,13 @@ int __connman_dhcp_request(struct connman_iface *iface)
 {
 	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
 
-	if (driver && driver->request)
+	if (iface->flags & CONNMAN_IFACE_FLAG_DHCP)
+		return -1;
+
+	if (driver && driver->request) {
+		iface->flags |= CONNMAN_IFACE_FLAG_DHCP;
 		return driver->request(iface);
+	}
 
 	return -1;
 }
@@ -86,8 +91,13 @@ int __connman_dhcp_release(struct connman_iface *iface)
 {
 	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
 
-	if (driver && driver->release)
+	if (!(iface->flags & CONNMAN_IFACE_FLAG_DHCP))
+		return -1;
+
+	if (driver && driver->release) {
+		iface->flags &= ~CONNMAN_IFACE_FLAG_DHCP;
 		return driver->release(iface);
+	}
 
 	return -1;
 }
diff --git a/src/iface-inet.c b/src/iface-inet.c
index 927f5689..7fd74895 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -103,13 +103,15 @@ int __connman_iface_init_via_inet(struct connman_iface *iface)
 	else
 		iface->state = CONNMAN_IFACE_STATE_OFF;
 
-	if (ifr.ifr_flags & IFF_RUNNING)
-		iface->state = CONNMAN_IFACE_STATE_CARRIER;
+	if (ifr.ifr_flags & IFF_RUNNING) {
+		if (!(iface->flags & CONNMAN_IFACE_FLAG_NOCARRIER))
+			iface->state = CONNMAN_IFACE_STATE_CARRIER;
+	}
 
 	return 0;
 }
 
-int __connman_iface_up(struct connman_iface *iface)
+static int __connman_iface_up(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	int sk, err;
@@ -153,7 +155,7 @@ done:
 	return err;
 }
 
-int __connman_iface_down(struct connman_iface *iface)
+static int __connman_iface_down(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	int sk, err;
@@ -194,3 +196,103 @@ done:
 
 	return err;
 }
+
+int __connman_iface_start(struct connman_iface *iface)
+{
+	int err;
+
+	DBG("iface %p", iface);
+
+	if (iface->flags & CONNMAN_IFACE_FLAG_STARTED)
+		return -EALREADY;
+
+	err = __connman_iface_up(iface);
+
+	if (iface->driver->start) {
+		err = iface->driver->start(iface);
+		if (err < 0)
+			return err;
+	}
+
+	iface->flags |= CONNMAN_IFACE_FLAG_STARTED;
+
+	return 0;
+}
+
+int __connman_iface_stop(struct connman_iface *iface)
+{
+	int err;
+
+	DBG("iface %p", iface);
+
+	__connman_dhcp_release(iface);
+
+	connman_iface_clear_ipv4(iface);
+
+	if (iface->flags & CONNMAN_IFACE_FLAG_RUNNING) {
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+		iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
+	}
+
+	if (!(iface->flags & CONNMAN_IFACE_FLAG_STARTED))
+		return -EINVAL;
+
+	if (iface->driver->stop) {
+		err = iface->driver->stop(iface);
+		if (err < 0)
+			return err;
+	}
+
+	iface->flags &= ~CONNMAN_IFACE_FLAG_STARTED;
+
+	err = __connman_iface_down(iface);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+int __connman_iface_connect(struct connman_iface *iface,
+					struct connman_network *network)
+{
+	DBG("iface %p name %s passphrase %s", iface,
+				network->identifier, network->passphrase);
+
+	if (iface->flags & CONNMAN_IFACE_FLAG_RUNNING) {
+		__connman_dhcp_release(iface);
+
+		connman_iface_clear_ipv4(iface);
+
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+
+		iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
+	}
+
+	if (iface->driver->connect)
+		iface->driver->connect(iface, network);
+
+	iface->flags |= CONNMAN_IFACE_FLAG_RUNNING;
+
+	return 0;
+}
+
+int __connman_iface_disconnect(struct connman_iface *iface)
+{
+	DBG("iface %p", iface);
+
+	__connman_dhcp_release(iface);
+
+	connman_iface_clear_ipv4(iface);
+
+	if (!(iface->flags & CONNMAN_IFACE_FLAG_RUNNING))
+		return -EINVAL;
+
+	if (iface->driver->disconnect)
+		iface->driver->disconnect(iface);
+
+	iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
+
+	return 0;
+}
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 6694d992..8d2895f4 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -41,8 +41,6 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 	gsize list_len;
 	int i;
 
-	DBG("iface %p", iface);
-
 	if (iface->identifier == NULL)
 		return NULL;
 
diff --git a/src/iface.c b/src/iface.c
index a4e154e9..f5753d8b 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -157,14 +157,11 @@ static void state_changed(struct connman_iface *iface)
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
-		__connman_dhcp_release(iface);
+		__connman_iface_stop(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
-		__connman_dhcp_release(iface);
-		connman_iface_clear_ipv4(iface);
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
+		__connman_iface_start(iface);
 		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
 			state = CONNMAN_IFACE_STATE_SCANNING;
 		break;
@@ -185,9 +182,7 @@ static void state_changed(struct connman_iface *iface)
 		break;
 
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
-		__connman_dhcp_release(iface);
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
+		__connman_iface_stop(iface);
 		if (iface->policy != CONNMAN_IFACE_POLICY_AUTO)
 			state = CONNMAN_IFACE_STATE_OFF;
 		break;
@@ -207,28 +202,19 @@ static void state_changed(struct connman_iface *iface)
 
 static void switch_policy(struct connman_iface *iface)
 {
-	DBG("iface %p", iface);
+	DBG("iface %p policy %d", iface, iface->policy);
 
 	switch (iface->policy) {
 	case CONNMAN_IFACE_POLICY_OFF:
-		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
-		state_changed(iface);
-		connman_iface_clear_ipv4(iface);
-		if (iface->driver->stop)
-			iface->driver->stop(iface);
-		else
-			__connman_iface_down(iface);
+		__connman_iface_stop(iface);
 		break;
 
 	case CONNMAN_IFACE_POLICY_IGNORE:
 		break;
 
 	case CONNMAN_IFACE_POLICY_AUTO:
-		if (iface->driver->start)
-			iface->driver->start(iface);
-		else
-			__connman_iface_up(iface);
-		state_changed(iface);
+	case CONNMAN_IFACE_POLICY_ASK:
+		__connman_iface_start(iface);
 		break;
 
 	default:
@@ -236,13 +222,12 @@ static void switch_policy(struct connman_iface *iface)
 	}
 }
 
-void connman_iface_indicate_enabled(struct connman_iface *iface)
+void connman_iface_indicate_ifup(struct connman_iface *iface)
 {
 	DBG("iface %p state %d", iface, iface->state);
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
-	case CONNMAN_IFACE_STATE_CARRIER:
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
@@ -251,17 +236,13 @@ void connman_iface_indicate_enabled(struct connman_iface *iface)
 	}
 }
 
-void connman_iface_indicate_disabled(struct connman_iface *iface)
+void connman_iface_indicate_ifdown(struct connman_iface *iface)
 {
 	DBG("iface %p state %d", iface, iface->state);
 
-	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
+	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO)
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-		if (iface->driver->start)
-			iface->driver->start(iface);
-		else
-			__connman_iface_up(iface);
-	} else
+	else
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 
 	state_changed(iface);
@@ -305,13 +286,10 @@ void connman_iface_indicate_carrier_off(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_CARRIER:
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 	case CONNMAN_IFACE_STATE_READY:
-#if 0
-		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING) {
-			if (iface->driver->disconnect)
-				iface->driver->disconnect(iface);
+		__connman_iface_disconnect(iface);
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
 			iface->state = CONNMAN_IFACE_STATE_SCANNING;
-		} else
-#endif
+		else
 			iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
@@ -378,8 +356,16 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
 
-	if (iface->state != CONNMAN_IFACE_STATE_SCANNING)
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONNECT:
+	case CONNMAN_IFACE_STATE_CONNECTED:
+	case CONNMAN_IFACE_STATE_CARRIER:
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+	case CONNMAN_IFACE_STATE_READY:
 		return;
+	default:
+		break;
+	}
 
 	len = strlen(name);
 	ssid = strdup(name);
@@ -399,11 +385,10 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 		g_free(iface->network.passphrase);
 		iface->network.passphrase = passphrase;
 
-		if (iface->driver->connect) {
-			iface->driver->connect(iface, &iface->network);
-			iface->state = CONNMAN_IFACE_STATE_CONNECT;
-			state_changed(iface);
-		}
+		__connman_iface_connect(iface, &iface->network);
+
+		iface->state = CONNMAN_IFACE_STATE_CONNECT;
+		state_changed(iface);
 	}
 
 	free(ssid);
@@ -577,11 +562,19 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONNECT:
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+			return reply;
+	default:
+		break;
+	}
+
 	if (driver->scan)
 		driver->scan(iface);
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
 	return reply;
 }
 
@@ -844,11 +837,7 @@ static DBusMessage *set_network(DBusConnection *conn,
 			dbus_message_unref(signal);
 		}
 
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
-
-		if (iface->driver->connect)
