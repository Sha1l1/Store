commit ba189b000c4c5ab4d15c6b155a7dbf8bd46c42d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 20:47:27 2007 +0100

    Initial revision

diff --git a/AUTHORS b/AUTHORS
new file mode 100644
index 00000000..48482e80
--- /dev/null
+++ b/AUTHORS
@@ -0,0 +1 @@
+Marcel Holtmann <marcel@holtmann.org>
diff --git a/COPYING b/COPYING
new file mode 100644
index 00000000..3912109b
--- /dev/null
+++ b/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/ChangeLog b/ChangeLog
new file mode 100644
index 00000000..e69de29b
diff --git a/INSTALL b/INSTALL
new file mode 100644
index 00000000..56b077d6
--- /dev/null
+++ b/INSTALL
@@ -0,0 +1,236 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005 Free
+Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' will install the package's files in
+`/usr/local/bin', `/usr/local/man', etc.  You can specify an
+installation prefix other than `/usr/local' by giving `configure' the
+option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+give `configure' the option `--exec-prefix=PREFIX', the package will
+use PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files will still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the `--target=TYPE' option to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).  Here is a another example:
+
+     /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+Here the `CONFIG_SHELL=/bin/bash' operand causes subsequent
+configuration-related scripts to be executed by `/bin/bash'.
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+
diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 00000000..4a0cec8e
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,4 @@
+
+MAINTAINERCLEANFILES = Makefile.in \
+	aclocal.m4 configure config.h.in config.sub config.guess \
+	ltmain.sh depcomp missing install-sh mkinstalldirs
diff --git a/NEWS b/NEWS
new file mode 100644
index 00000000..e69de29b
diff --git a/README b/README
new file mode 100644
index 00000000..e69de29b
diff --git a/acinclude.m4 b/acinclude.m4
new file mode 100644
index 00000000..95486c3d
--- /dev/null
+++ b/acinclude.m4
@@ -0,0 +1,11 @@
+AC_DEFUN([AC_PROG_CC_PIE], [
+	AC_CACHE_CHECK([whether ${CC-cc} accepts -fPIE], ac_cv_prog_cc_pie, [
+		echo 'void f(){}' > conftest.c
+		if test -z "`${CC-cc} -fPIE -pie -c conftest.c 2>&1`"; then
+			ac_cv_prog_cc_pie=yes
+		else
+			ac_cv_prog_cc_pie=no
+		fi
+		rm -rf conftest*
+	])
+])
diff --git a/bootstrap b/bootstrap
new file mode 100755
index 00000000..053f5c8f
--- /dev/null
+++ b/bootstrap
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+aclocal && \
+    autoheader && \
+        libtoolize --automake --copy --force &&
+	    automake --add-missing --copy && \
+		autoconf
diff --git a/bootstrap-configure b/bootstrap-configure
new file mode 100755
index 00000000..2d56ff31
--- /dev/null
+++ b/bootstrap-configure
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+if [ -f config.status ]; then
+	make maintainer-clean
+fi
+
+./bootstrap && \
+    ./configure --enable-maintainer-mode \
+		--prefix=/usr \
+		--mandir=/usr/share/man \
+		--sysconfdir=/etc
diff --git a/configure.in b/configure.in
new file mode 100644
index 00000000..645032c2
--- /dev/null
+++ b/configure.in
@@ -0,0 +1,21 @@
+AC_PREREQ(2.50)
+AC_INIT()
+
+AM_INIT_AUTOMAKE(connman-core, 0.0)
+AM_CONFIG_HEADER(config.h)
+
+AM_MAINTAINER_MODE
+
+AC_PREFIX_DEFAULT(/usr/local)
+
+if (test "${CFLAGS}" = ""); then
+	CFLAGS="-Wall -O2"
+fi
+
+AC_LANG_C
+
+AC_PROG_CC
+AC_PROG_CC_PIE
+AC_PROG_INSTALL
+
+AC_OUTPUT(Makefile)

commit e8f7754e312aeac4aaca74d304ed6e36ed2f6a0d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 20:49:15 2007 +0100

    Add skeleton for daemon and D-Bus registration

diff --git a/Makefile.am b/Makefile.am
index 4a0cec8e..baa76129 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,6 @@
 
+SUBDIRS = src
+
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
 	ltmain.sh depcomp missing install-sh mkinstalldirs
diff --git a/configure.in b/configure.in
index 645032c2..7cddb933 100644
--- a/configure.in
+++ b/configure.in
@@ -18,4 +18,9 @@ AC_PROG_CC
 AC_PROG_CC_PIE
 AC_PROG_INSTALL
 
-AC_OUTPUT(Makefile)
+PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
+				AC_MSG_ERROR(libgdbus is required))
+AC_SUBST(GDBUS_CFLAGS)
+AC_SUBST(GDBUS_LIBS)
+
+AC_OUTPUT(Makefile src/Makefile)
diff --git a/src/Makefile.am b/src/Makefile.am
new file mode 100644
index 00000000..87a6e78a
--- /dev/null
+++ b/src/Makefile.am
@@ -0,0 +1,16 @@
+
+dbusdir = $(sysconfdir)/dbus-1/system.d
+
+dbus_DATA = connman.conf
+
+sbin_PROGRAMS = connmand
+
+connmand_SOURCES = main.c connman.h
+
+connmand_LDADD = @GDBUS_LIBS@
+
+AM_CFLAGS = @GDBUS_CFLAGS@
+
+EXTRA_DIST = $(dbus_DATA)
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/src/connman.conf b/src/connman.conf
new file mode 100644
index 00000000..4e83980e
--- /dev/null
+++ b/src/connman.conf
@@ -0,0 +1,11 @@
+<!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+    <policy user="root">
+        <allow own="org.freedesktop.connman"/>
+    </policy>
+    <policy at_console="true">
+        <allow send_interface="org.freedesktop.connman"/>
+        <allow send_destination="org.freedesktop.connman"/>
+    </policy>
+</busconfig>
diff --git a/src/connman.h b/src/connman.h
new file mode 100644
index 00000000..5282d144
--- /dev/null
+++ b/src/connman.h
@@ -0,0 +1,25 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#define CONNMAN_SERVICE  "org.freedesktop.connman"
+
+#define CONNMAN_MANAGER_PATH "/"
+#define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 00000000..76af50a6
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,71 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+
+#include <gdbus.h>
+
+#include "connman.h"
+
+static GMainLoop *main_loop = NULL;
+
+static void sig_term(int sig)
+{
+	g_main_loop_quit(main_loop);
+}
+
+int main(int argc, char *argv[])
+{
+	DBusConnection *conn;
+	struct sigaction sa;
+
+	main_loop = g_main_loop_new(NULL, FALSE);
+
+	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
+	if (conn == NULL) {
+		fprintf(stderr, "Can't register with system bus\n");
+		exit(1);
+	}
+
+	g_dbus_register_object(conn, CONNMAN_MANAGER_PATH, NULL, NULL);
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_handler = sig_term;
+	sigaction(SIGINT, &sa, NULL);
+	sigaction(SIGTERM, &sa, NULL);
+
+	g_main_loop_run(main_loop);
+
+	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);
+
+	g_dbus_cleanup_connection(conn);
+
+	g_main_loop_unref(main_loop);
+
+	return 0;
+}

commit c33b387b3ed16bce4058b9088260c4ece1ff6342
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 20:51:05 2007 +0100

    Add plugin infrastructure

diff --git a/Makefile.am b/Makefile.am
index baa76129..0a0969fa 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = src
+SUBDIRS = include src plugins
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index 7cddb933..ecf67c43 100644
--- a/configure.in
+++ b/configure.in
@@ -18,9 +18,20 @@ AC_PROG_CC
 AC_PROG_CC_PIE
 AC_PROG_INSTALL
 
+m4_define([_LT_AC_TAGCONFIG], [])
+m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
+
+AC_DISABLE_STATIC
+AC_PROG_LIBTOOL
+
+PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
+				AC_MSG_ERROR(gmodule is required))
+AC_SUBST(GMODULE_CFLAGS)
+AC_SUBST(GMODULE_LIBS)
+
 PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
 				AC_MSG_ERROR(libgdbus is required))
 AC_SUBST(GDBUS_CFLAGS)
 AC_SUBST(GDBUS_LIBS)
 
-AC_OUTPUT(Makefile src/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile plugins/Makefile)
diff --git a/include/Makefile.am b/include/Makefile.am
new file mode 100644
index 00000000..55bf6b5a
--- /dev/null
+++ b/include/Makefile.am
@@ -0,0 +1,12 @@
+
+includedir = @includedir@/connman
+
+noinst_HEADERS = plugin.h
+
+MAINTAINERCLEANFILES = Makefile.in
+
+all-local:
+	@if [ ! -e connman ] ; then $(LN_S) $(top_srcdir)/include connman ; fi
+
+clean-local:
+	@rm -f connman
diff --git a/include/plugin.h b/include/plugin.h
new file mode 100644
index 00000000..b7f1eb3a
--- /dev/null
+++ b/include/plugin.h
@@ -0,0 +1,46 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_PLUGIN_H
+#define __CONNMAN_PLUGIN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct connman_plugin_desc {
+	const char *name;
+	const char *description;
+	const char *version;
+	int (*init) (void);
+	void (*exit) (void);
+};
+
+#define CONNMAN_PLUGIN_DEFINE(name,description,version,init,exit) \
+		struct connman_plugin_desc connman_plugin_desc = { \
+			name, description, version, init, exit \
+		};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_PLUGIN_H */
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/plugins/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/src/Makefile.am b/src/Makefile.am
index 87a6e78a..9f15cf37 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,11 +5,20 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h
+connmand_SOURCES = main.c connman.h plugin.c
 
-connmand_LDADD = @GDBUS_LIBS@
+connmand_LDADD = @GDBUS_LIBS@ @GMODULE_LIBS@
+ 
+if MAINTAINER_MODE
+plugindir = $(abs_top_srcdir)/plugins
+else
+plugindir = $(libdir)/connman
+endif
 
-AM_CFLAGS = @GDBUS_CFLAGS@
+AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ \
+			-DPLUGINDIR=\""$(plugindir)"\"
+
+INCLUDES = -I$(top_builddir)/include
 
 EXTRA_DIST = $(dbus_DATA)
 
diff --git a/src/connman.h b/src/connman.h
index 5282d144..f81ecd08 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -19,7 +19,17 @@
  *
  */
 
+#include <stdio.h>
+
+#define DBG(fmt, arg...)  printf("%s: " fmt "\n" , __FUNCTION__ , ## arg)
+//#define DBG(fmt, arg...)
+
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
 #define CONNMAN_MANAGER_PATH "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
+
+#include <connman/plugin.h>
+
+int __connman_plugin_init(void);
+void __connman_plugin_cleanup(void);
diff --git a/src/main.c b/src/main.c
index 76af50a6..74378029 100644
--- a/src/main.c
+++ b/src/main.c
@@ -54,6 +54,8 @@ int main(int argc, char *argv[])
 
 	g_dbus_register_object(conn, CONNMAN_MANAGER_PATH, NULL, NULL);
 
+	__connman_plugin_init();
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -61,6 +63,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_plugin_cleanup();
+
 	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);
 
 	g_dbus_cleanup_connection(conn);
diff --git a/src/plugin.c b/src/plugin.c
new file mode 100644
index 00000000..8e164e1e
--- /dev/null
+++ b/src/plugin.c
@@ -0,0 +1,141 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <dbus/dbus.h>
+
+#include <glib.h>
+#include <gmodule.h>
+
+#include <connman/plugin.h>
+
+#include "connman.h"
+
+static GSList *plugins = NULL;
+
+struct connman_plugin {
+	GModule *module;
+	struct connman_plugin_desc *desc;
+};
+
+static gboolean add_plugin(GModule *module, struct connman_plugin_desc *desc)
+{
+	struct connman_plugin *plugin;
+
+	plugin = g_try_new0(struct connman_plugin, 1);
+	if (plugin == NULL)
+		return FALSE;
+
+	plugin->module = module;
+	plugin->desc = desc;
+
+	plugins = g_slist_append(plugins, plugin);
+
+	desc->init();
+
+	return TRUE;
+}
+
+static void load_plugins(const gchar *path)
+{
+	GDir *dir;
+	const gchar *file;
+	gchar *filename;
+
+	dir = g_dir_open(path, 0, NULL);
+	if (dir != NULL) {
+		while ((file = g_dir_read_name(dir)) != NULL) {
+			GModule *module;
+			struct connman_plugin_desc *desc;
+
+			if (g_str_has_prefix(file, "libconnman") == FALSE)
+				continue;
+
+			filename = g_build_filename(path, file, NULL);
+
+			module = g_module_open(filename, 0);
+			if (module == NULL) {
+				g_warning("Can't load %s", filename);
+				continue;
+			}
+
+			g_free(filename);
+
+			DBG("%s", g_module_name(module));
+
+			if (g_module_symbol(module, "connman_plugin_desc",
+						(gpointer) &desc) == FALSE) {
+				g_warning("Can't load symbol");
+				g_module_close(module);
+				continue;
+			}
+
+			if (desc == NULL || desc->init == NULL) {
+				g_module_close(module);
+				continue;
+			}
+
+			if (add_plugin(module, desc) == FALSE)
+				g_module_close(module);
+		}
+
+		g_dir_close(dir);
+	}
+}
+
+int __connman_plugin_init(void)
+{
+	DBG("");
+
+	if (g_module_supported() == FALSE) {
+		g_warning("Modules not supported: %s", g_module_error());
+		return FALSE;
+	}
+
+	load_plugins(PLUGINDIR);
+
+	return 0;
+}
+
+void __connman_plugin_cleanup(void)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = plugins; list; list = list->next) {
+		struct connman_plugin *plugin = list->data;
+
+		DBG("%s", g_module_name(plugin->module));
+
+		if (plugin->desc->exit)
+			plugin->desc->exit();
+
+		g_module_close(plugin->module);
+
+		g_free(plugin);
+	}
+
+	g_slist_free(plugins);
+}

commit 56cf3e5a8c9403db1f1dd5c86367aba995d5fe7d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 22:10:15 2007 +0100

    Add interface infrastructure

diff --git a/configure.in b/configure.in
index ecf67c43..930691af 100644
--- a/configure.in
+++ b/configure.in
@@ -34,4 +34,9 @@ PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
 AC_SUBST(GDBUS_CFLAGS)
 AC_SUBST(GDBUS_LIBS)
 
+PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
+				AC_MSG_ERROR(libhal is required))
+AC_SUBST(HAL_CFLAGS)
+AC_SUBST(HAL_LIBS)
+
 AC_OUTPUT(Makefile include/Makefile src/Makefile plugins/Makefile)
diff --git a/include/Makefile.am b/include/Makefile.am
index 55bf6b5a..ece5af1b 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h
+noinst_HEADERS = plugin.h iface.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/iface.h b/include/iface.h
new file mode 100644
index 00000000..cc3ab0ce
--- /dev/null
+++ b/include/iface.h
@@ -0,0 +1,66 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_IFACE_H
+#define __CONNMAN_IFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum connman_iface_type {
+	CONNMAN_IFACE_TYPE_UNKNOWN   = 0,
+	CONNMAN_IFACE_TYPE_80203     = 1,
+	CONNMAN_IFACE_TYPE_80211     = 2,
+	CONNMAN_IFACE_TYPE_WIMAX     = 3,
+	CONNMAN_IFACE_TYPE_BLUETOOTH = 4,
+};
+
+enum connman_iface_flags {
+	CONNMAN_IFACE_FLAGS_CARRIER_DETECT	= (1 << 0),
+	CONNMAN_IFACE_FLAGS_IPV4		= (1 << 1),
+	CONNMAN_IFACE_FLAGS_IPV6		= (1 << 2),
+};
+
+struct connman_iface {
+	struct connman_iface_driver *driver;
+	char *path;
+	char *udi;
+	char *sysfs;
+	enum connman_iface_type type;
+	enum connman_iface_flags flags;
+};
+
+struct connman_iface_driver {
+	const char *name;
+	const char *capability;
+	int (*probe) (struct connman_iface *iface);
+	void (*remove) (struct connman_iface *iface);
+};
+
+extern int connman_iface_register(struct connman_iface_driver *driver);
+extern void connman_iface_unregister(struct connman_iface_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_IFACE_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 9f15cf37..5233c0b4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,17 +5,17 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c
+connmand_SOURCES = main.c connman.h plugin.c iface.c
 
-connmand_LDADD = @GDBUS_LIBS@ @GMODULE_LIBS@
+connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
 if MAINTAINER_MODE
 plugindir = $(abs_top_srcdir)/plugins
 else
-plugindir = $(libdir)/connman
+plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ \
+AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
 			-DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
diff --git a/src/connman.h b/src/connman.h
index f81ecd08..641b0a26 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -29,7 +29,15 @@
 #define CONNMAN_MANAGER_PATH "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 
+#define CONNMAN_IFACE_BASEPATH  "/interface"
+#define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
 void __connman_plugin_cleanup(void);
+
+#include <connman/iface.h>
+
+int __connman_iface_init(DBusConnection *conn);
+void __connman_iface_cleanup(void);
diff --git a/src/iface.c b/src/iface.c
new file mode 100644
index 00000000..ce6ab380
--- /dev/null
+++ b/src/iface.c
@@ -0,0 +1,293 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+
+#include <glib.h>
+#include <gdbus.h>
+
+#include <hal/libhal.h>
+
+#include "connman.h"
+
+static GSList *drivers = NULL;
+
+int connman_iface_register(struct connman_iface_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_append(drivers, driver);
+
+	return 0;
+}
+
+void connman_iface_unregister(struct connman_iface_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_remove(drivers, driver);
+}
+
+static GSList *interfaces = NULL;
+
+static void device_free(void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->driver && iface->driver->remove)
+		iface->driver->remove(iface);
+
+	g_free(iface->path);
+	g_free(iface->udi);
+	g_free(iface->sysfs);
+	g_free(iface);
+}
+
+static int probe_device(LibHalContext *ctx,
+			struct connman_iface_driver *driver, const char *udi)
+{
+	DBusConnection *conn;
+	struct connman_iface *iface;
+	char *temp, *sysfs;
+	int err;
+
+	DBG("ctx %p driver %p udi %s", ctx, driver, udi);
+
+	if (!driver->probe)
+		return -1;
+
+	iface = g_try_new0(struct connman_iface, 1);
+	if (iface == NULL)
+		return -1;
+
+	temp = g_path_get_basename(udi);
+	iface->path = g_strdup_printf("%s/%s", CONNMAN_IFACE_BASEPATH, temp);
+	g_free(temp);
+
+	iface->udi = g_strdup(udi);
+
+	DBG("path %s", iface->path);
+
+	sysfs = libhal_device_get_property_string(ctx, udi,
+						"linux.sysfs_path", NULL);
+	if (sysfs != NULL)
+		iface->sysfs = g_strdup(sysfs);
+
+	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
+	iface->flags = 0;
+
+	DBG("iface %p", iface);
+
+	err = driver->probe(iface);
+	if (err < 0) {
+		device_free(iface);
+		return -1;
+	}
+
+	iface->driver = driver;
+
+	conn = libhal_ctx_get_dbus_connection(ctx);
+
+	g_dbus_register_object(conn, iface->path, iface, device_free);
+
+	interfaces = g_slist_append(interfaces, iface);
+
+	return 0;
+}
+
+static void device_added(LibHalContext *ctx, const char *udi)
+{
+	GSList *list;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	for (list = drivers; list; list = list->next) {
+		struct connman_iface_driver *driver = list->data;
+
+		if (driver->capability == NULL)
+			continue;
+
+		if (libhal_device_query_capability(ctx, udi,
+					driver->capability, NULL) == TRUE) {
+			if (probe_device(ctx, driver, udi) == 0)
+				break;
+		}
+	}
+}
+
+static void device_removed(LibHalContext *ctx, const char *udi)
+{
+	DBusConnection *conn;
+	GSList *list;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	conn = libhal_ctx_get_dbus_connection(ctx);
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		if (strcmp(udi, iface->udi) == 0) {
+			interfaces = g_slist_remove(interfaces, iface);
+			g_dbus_unregister_object(conn, iface->path);
+			break;
+		}
+	}
+}
+
+static void probe_driver(LibHalContext *ctx,
+				struct connman_iface_driver *driver)
+{
+	char **list;
+	int num;
+
+	DBG("ctx %p driver %p", ctx, driver);
+
+	list = libhal_find_device_by_capability(ctx,
+					driver->capability, &num, NULL);
+	if (list) {
+		char **tmp = list;
+
+		while (*tmp) {
+			probe_device(ctx, driver, *tmp);
+			tmp++;
+		}
+
+		libhal_free_string_array(list);
+	}
+}
+
+static void find_devices(LibHalContext *ctx)
+{
+	GSList *list;
+
+	DBG("ctx %p", ctx);
+
+	for (list = drivers; list; list = list->next) {
+		struct connman_iface_driver *driver = list->data;
+
+		DBG("driver %p", driver);
+
+		if (driver->capability == NULL)
+			continue;
+
+		probe_driver(ctx, driver);
+	}
+}
+
+static LibHalContext *hal_ctx = NULL;
+
+static void hal_init(void *data)
+{
+	DBusConnection *conn = data;
+
+	DBG("conn %p", conn);
+
+	if (hal_ctx != NULL)
+		return;
+
+	hal_ctx = libhal_ctx_new();
+	if (hal_ctx == NULL)
+		return;
+
+	if (libhal_ctx_set_dbus_connection(hal_ctx, conn) == FALSE) {
+		libhal_ctx_free(hal_ctx);
+		return;
+	}
+
+	if (libhal_ctx_init(hal_ctx, NULL) == FALSE) {
+		libhal_ctx_free(hal_ctx);
+		return ;
+	}
+
+	libhal_ctx_set_device_added(hal_ctx, device_added);
+	libhal_ctx_set_device_removed(hal_ctx, device_removed);
+
+	//libhal_ctx_set_device_new_capability(hal_ctx, new_capability);
+	//libhal_ctx_set_device_lost_capability(hal_ctx, lost_capability);
+
+	find_devices(hal_ctx);
+}
+
+static void hal_cleanup(void *data)
+{
+	DBusConnection *conn = data;
+	GSList *list;
+
+	DBG("conn %p", conn);
+
+	if (hal_ctx == NULL)
+		return;
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		DBG("path %s", iface->path);
+
+		g_dbus_unregister_object(conn, iface->path);
+	}
+
+	g_slist_free(interfaces);
+
+	interfaces = NULL;
+
+	libhal_ctx_shutdown(hal_ctx, NULL);
+
+	libhal_ctx_free(hal_ctx);
+
+	hal_ctx = NULL;
+}
+
+static DBusConnection *connection = NULL;
+static guint hal_watch = 0;
+
+int __connman_iface_init(DBusConnection *conn)
+{
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
+
+	hal_init(connection);
+
+	hal_watch = g_dbus_add_watch(connection, "org.freedesktop.Hal",
+				hal_init, hal_cleanup, connection, NULL);
+
+	return 0;
+}
+
+void __connman_iface_cleanup(void)
+{
+	DBG("conn %p", connection);
+
+	g_dbus_remove_watch(connection, hal_watch);
+
+	hal_cleanup(connection);
+
+	dbus_connection_unref(connection);
+}
diff --git a/src/main.c b/src/main.c
index 74378029..89c49fdb 100644
--- a/src/main.c
+++ b/src/main.c
@@ -56,6 +56,8 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
+	__connman_iface_init(conn);
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -63,6 +65,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_iface_cleanup();
+
 	__connman_plugin_cleanup();
 
 	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);

commit 369edde7e8054b798f9a70d20f98864a1f324e05
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 22:10:30 2007 +0100

    Add skeletons for 802.03 and 802.11 interface plugins

diff --git a/plugins/80203.c b/plugins/80203.c
new file mode 100644
index 00000000..7921d9c2
--- /dev/null
+++ b/plugins/80203.c
@@ -0,0 +1,68 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <connman/plugin.h>
+#include <connman/iface.h>
+
+static int iface_probe(struct connman_iface *iface)
+{
+	printf("[802.03] probe interface %s\n", iface->udi);
+
+	iface->type = CONNMAN_IFACE_TYPE_80203;
+
+	iface->flags = CONNMAN_IFACE_FLAGS_CARRIER_DETECT |
+						CONNMAN_IFACE_FLAGS_IPV4;
+
+	return 0;
+}
+
+static void iface_remove(struct connman_iface *iface)
+{
+	printf("[802.03] remove interface %s\n", iface->udi);
+}
+
+static struct connman_iface_driver iface_driver = {
+	.name		= "80203",
+	.capability	= "net.80203",
+	.probe		= iface_probe,
+	.remove		= iface_remove,
+};
+
+static int plugin_init(void)
+{
+	connman_iface_register(&iface_driver);
+
+	return 0;
+}
+
+static void plugin_exit(void)
+{
+	connman_iface_unregister(&iface_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("80203", "IEEE 802.03 interface plugin", VERSION,
+						plugin_init, plugin_exit)
diff --git a/plugins/80211.c b/plugins/80211.c
new file mode 100644
index 00000000..eea416ba
--- /dev/null
+++ b/plugins/80211.c
@@ -0,0 +1,67 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <connman/plugin.h>
+#include <connman/iface.h>
+
+static int iface_probe(struct connman_iface *iface)
+{
+	printf("[802.11] probe interface %s\n", iface->udi);
+
+	iface->type = CONNMAN_IFACE_TYPE_80211;
+
+	iface->flags = CONNMAN_IFACE_FLAGS_IPV4;
+
+	return 0;
+}
+
+static void iface_remove(struct connman_iface *iface)
+{
+	printf("[802.11] remove interface %s\n", iface->udi);
+}
+
+static struct connman_iface_driver iface_driver = {
+	.name		= "80211",
+	.capability	= "net.80211",
+	.probe		= iface_probe,
+	.remove		= iface_remove,
+};
+
+static int plugin_init(void)
+{
+	connman_iface_register(&iface_driver);
+
+	return 0;
+}
+
+static void plugin_exit(void)
+{
+	connman_iface_unregister(&iface_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("80211", "IEEE 802.11 interface plugin", VERSION,
+						plugin_init, plugin_exit)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 02742923..aa9ed779 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,2 +1,14 @@
 
+plugindir = $(libdir)/connman/plugins
+
+plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la
+
+libconnman_80203_la_SOURCES = 80203.c
+
+libconnman_80211_la_SOURCES = 80211.c
+
+AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
+
+INCLUDES = -I$(top_builddir)/include
+
 MAINTAINERCLEANFILES = Makefile.in

commit 0446b9206238e24a5019483a2e2aea27d41f75dc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 22 22:36:10 2007 +0100

    Add basic DHCP infrastructure

diff --git a/include/Makefile.am b/include/Makefile.am
index ece5af1b..627ab0a0 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h iface.h
+noinst_HEADERS = plugin.h iface.h dhcp.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/dhcp.h b/include/dhcp.h
new file mode 100644
index 00000000..337746b3
--- /dev/null
+++ b/include/dhcp.h
@@ -0,0 +1,44 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_DHCP_H
+#define __CONNMAN_DHCP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/iface.h>
+
+struct connman_dhcp_driver {
+	const char *name;
+	int (*request) (struct connman_iface *iface);
+	int (*release) (struct connman_iface *iface);
+};
+
+extern int connman_dhcp_register(struct connman_dhcp_driver *driver);
+extern void connman_dhcp_unregister(struct connman_dhcp_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_DHCP_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 5233c0b4..05f342b9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c iface.c
+connmand_SOURCES = main.c connman.h plugin.c iface.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 641b0a26..1cd6c163 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -24,6 +24,8 @@
 #define DBG(fmt, arg...)  printf("%s: " fmt "\n" , __FUNCTION__ , ## arg)
 //#define DBG(fmt, arg...)
 
+#include <dbus/dbus.h>
+
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
 #define CONNMAN_MANAGER_PATH "/"
@@ -41,3 +43,8 @@ void __connman_plugin_cleanup(void);
 
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
+
+#include <connman/dhcp.h>
+
+int __connman_dhcp_request(struct connman_iface *iface);
+int __connman_dhcp_release(struct connman_iface *iface);
diff --git a/src/dhcp.c b/src/dhcp.c
new file mode 100644
index 00000000..5a6e5c9b
--- /dev/null
+++ b/src/dhcp.c
@@ -0,0 +1,66 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+
+#include "connman.h"
+
+static GSList *drivers = NULL;
+
+int connman_dhcp_register(struct connman_dhcp_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_append(drivers, driver);
+
+	return 0;
+}
+
+void connman_dhcp_unregister(struct connman_dhcp_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_remove(drivers, driver);
+}
+
+int __connman_dhcp_request(struct connman_iface *iface)
+{
+	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->request)
+		return driver->request(iface);
+
+	return -1;
+}
+
+int __connman_dhcp_release(struct connman_iface *iface)
+{
+	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->release)
+		return driver->release(iface);
+
+	return -1;
+}

commit e6adbd6658b15bb8dd9504fec86424382b443ab4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 23 00:07:39 2007 +0100

    Add network interface helper functions

diff --git a/plugins/80203.c b/plugins/80203.c
index 7921d9c2..6c9f9507 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -28,21 +28,39 @@
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
+#include "net.h"
+
 static int iface_probe(struct connman_iface *iface)
 {
-	printf("[802.03] probe interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	printf("[802.03] probe interface %s\n", ifname);
 
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
 	iface->flags = CONNMAN_IFACE_FLAGS_CARRIER_DETECT |
 						CONNMAN_IFACE_FLAGS_IPV4;
 
+	__net_free(ifname);
+
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.03] remove interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return;
+
+	printf("[802.03] remove interface %s\n", ifname);
+
+	__net_free(ifname);
 }
 
 static struct connman_iface_driver iface_driver = {
diff --git a/plugins/80211.c b/plugins/80211.c
index eea416ba..74438db4 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -28,20 +28,38 @@
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
+#include "net.h"
+
 static int iface_probe(struct connman_iface *iface)
 {
-	printf("[802.11] probe interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	printf("[802.11] probe interface %s\n", ifname);
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAGS_IPV4;
 
+	__net_free(ifname);
+
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.11] remove interface %s\n", iface->udi);
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return;
+
+	printf("[802.11] remove interface %s\n", ifname);
+
+	__net_free(ifname);
 }
 
 static struct connman_iface_driver iface_driver = {
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index aa9ed779..2d7d5df0 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -3,9 +3,9 @@ plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la
 
-libconnman_80203_la_SOURCES = 80203.c
+libconnman_80203_la_SOURCES = 80203.c net.h net.c
 
-libconnman_80211_la_SOURCES = 80211.c
+libconnman_80211_la_SOURCES = 80211.c net.h net.c
 
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
diff --git a/plugins/net.c b/plugins/net.c
new file mode 100644
index 00000000..627b4c56
--- /dev/null
+++ b/plugins/net.c
@@ -0,0 +1,107 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "net.h"
+
+static int __net_ifindex(const char *sysfs)
+{
+	char *pathname;
+	char buf[8];
+	size_t size;
+	ssize_t len;
+	int fd, val = -EIO;
+
+	if (sysfs == NULL)
+		return -1;
+
+	size = strlen(sysfs) + 9;
+
+	pathname = malloc(size);
+
+	sprintf(pathname, "%s/ifindex", sysfs);
+
+	fd = open(pathname, O_RDONLY);
+
+	free(pathname);
+
+	if (fd < 0)
+		return -errno;
+
+	memset(buf, 0, sizeof(buf));
+
+	len = read(fd, buf, sizeof(buf) - 1);
+	if (len < 0) {
+		val = -errno;
+		goto done;
+	}
+
+	val = atoi(buf);
+
+done:
+	close(fd);
+
+	return val;
+}
+
+char *__net_ifname(const char *sysfs)
+{
+	struct ifreq ifr;
+	int sk, err, ifindex;
+
+	ifindex = __net_ifindex(sysfs);
+	if (ifindex < 0)
+		return NULL;
+
+	sk = socket (PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = ifindex;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	return strdup(ifr.ifr_name);
+}
+
+void __net_free(void *ptr)
+{
+	if (ptr)
+		free(ptr);
+}
diff --git a/plugins/net.h b/plugins/net.h
new file mode 100644
index 00000000..10f46fff
--- /dev/null
+++ b/plugins/net.h
@@ -0,0 +1,23 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+char *__net_ifname(const char *sysfs);
+void __net_free(void *ptr);

commit b93a99e200eaec8c8b0943531e11bffe86d3122d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:22:43 2007 +0100

    Add experimental IPv4 support

diff --git a/include/iface.h b/include/iface.h
index cc3ab0ce..daeaf172 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -26,6 +26,8 @@
 extern "C" {
 #endif
 
+#include <netinet/in.h>
+
 enum connman_iface_type {
 	CONNMAN_IFACE_TYPE_UNKNOWN   = 0,
 	CONNMAN_IFACE_TYPE_80203     = 1,
@@ -40,6 +42,15 @@ enum connman_iface_flags {
 	CONNMAN_IFACE_FLAGS_IPV6		= (1 << 2),
 };
 
+struct connman_ipv4 {
+	struct in_addr address;
+	struct in_addr netmask;
+	struct in_addr gateway;
+	struct in_addr network;
+	struct in_addr broadcast;
+	struct in_addr nameserver;
+};
+
 struct connman_iface {
 	struct connman_iface_driver *driver;
 	char *path;
@@ -47,6 +58,7 @@ struct connman_iface {
 	char *sysfs;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
+	struct connman_ipv4 ipv4;
 };
 
 struct connman_iface_driver {
@@ -54,6 +66,10 @@ struct connman_iface_driver {
 	const char *capability;
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
+	int (*get_ipv4) (struct connman_iface *iface,
+					struct connman_ipv4 *ipv4);
+	int (*set_ipv4) (struct connman_iface *iface,
+					struct connman_ipv4 *ipv4);
 };
 
 extern int connman_iface_register(struct connman_iface_driver *driver);
diff --git a/plugins/80203.c b/plugins/80203.c
index 6c9f9507..e39fcdc4 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <stdio.h>
+#include <arpa/inet.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
@@ -52,15 +53,34 @@ static int iface_probe(struct connman_iface *iface)
 
 static void iface_remove(struct connman_iface *iface)
 {
-	char *ifname;
+	printf("[802.03] remove interface\n");
 
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return;
+	__net_clear(iface->sysfs);
+}
 
-	printf("[802.03] remove interface %s\n", ifname);
+static int iface_get_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+		return -1;
 
-	__net_free(ifname);
+	printf("[802.03] get address %s\n", inet_ntoa(ipv4->address));
+
+	return 0;
+}
+
+static int iface_set_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	printf("[802.03] set address %s\n", inet_ntoa(ipv4->address));
+	printf("[802.03] set netmask %s\n", inet_ntoa(ipv4->netmask));
+	printf("[802.03] set gateway %s\n", inet_ntoa(ipv4->gateway));
+
+	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+				&ipv4->gateway, &ipv4->broadcast,
+						&ipv4->nameserver);
+
+	return 0;
 }
 
 static struct connman_iface_driver iface_driver = {
@@ -68,6 +88,8 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80203",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
+	.get_ipv4	= iface_get_ipv4,
+	.set_ipv4	= iface_set_ipv4,
 };
 
 static int plugin_init(void)
diff --git a/plugins/80211.c b/plugins/80211.c
index 74438db4..1fd5aaf5 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <stdio.h>
+#include <arpa/inet.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
@@ -51,15 +52,34 @@ static int iface_probe(struct connman_iface *iface)
 
 static void iface_remove(struct connman_iface *iface)
 {
-	char *ifname;
+	printf("[802.11] remove interface\n");
 
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return;
+	__net_clear(iface->sysfs);
+}
 
-	printf("[802.11] remove interface %s\n", ifname);
+static int iface_get_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+		return -1;
 
-	__net_free(ifname);
+	printf("[802.11] get address %s\n", inet_ntoa(ipv4->address));
+
+	return 0;
+}
+
+static int iface_set_ipv4(struct connman_iface *iface,
+					struct connman_ipv4 *ipv4)
+{
+	printf("[802.11] set address %s\n", inet_ntoa(ipv4->address));
+	printf("[802.11] set netmask %s\n", inet_ntoa(ipv4->netmask));
+	printf("[802.11] set gateway %s\n", inet_ntoa(ipv4->gateway));
+
+	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+				&ipv4->gateway, &ipv4->broadcast,
+						&ipv4->nameserver);
+
+	return 0;
 }
 
 static struct connman_iface_driver iface_driver = {
@@ -67,6 +87,8 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
+	.get_ipv4	= iface_get_ipv4,
+	.set_ipv4	= iface_set_ipv4,
 };
 
 static int plugin_init(void)
diff --git a/plugins/net.c b/plugins/net.c
index 627b4c56..e0aa5a4e 100644
--- a/plugins/net.c
+++ b/plugins/net.c
@@ -30,6 +30,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
 #include <net/if.h>
 
 #include "net.h"
@@ -74,6 +76,39 @@ done:
 	return val;
 }
 
+int __net_ifaddr(const char *sysfs, struct in_addr *addr)
+{
+	struct ifreq ifr;
+	int sk, ifindex;
+
+	ifindex = __net_ifindex(sysfs);
+	if (ifindex < 0)
+		return ifindex;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = ifindex;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -errno;
+	}
+
+	if (ioctl(sk, SIOCGIFADDR, &ifr) < 0) {
+		close(sk);
+		return -errno;
+	}
+
+	close(sk);
+
+	*addr = ((struct sockaddr_in *) (&ifr.ifr_addr))->sin_addr;
+
+	return 0;
+}
+
 char *__net_ifname(const char *sysfs)
 {
 	struct ifreq ifr;
@@ -83,7 +118,7 @@ char *__net_ifname(const char *sysfs)
 	if (ifindex < 0)
 		return NULL;
 
-	sk = socket (PF_INET, SOCK_DGRAM, 0);
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return NULL;
 
@@ -105,3 +140,58 @@ void __net_free(void *ptr)
 	if (ptr)
 		free(ptr);
 }
+
+int __net_clear(const char *sysfs)
+{
+	char *ifname, cmd[128];
+
+	ifname = __net_ifname(sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	sprintf(cmd, "resolvconf -d %s", ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	sprintf(cmd, "ip addr flush dev %s", ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	__net_free(ifname);
+
+	return 0;
+}
+
+int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+				struct in_addr *route, struct in_addr *bcast,
+						struct in_addr *namesrv)
+{
+	char *ifname, cmd[128], msk[32], brd[32];
+
+	ifname = __net_ifname(sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	__net_clear(sysfs);
+
+	sprintf(msk, "%s", "24");
+	sprintf(brd, "%s", inet_ntoa(*bcast));
+	sprintf(cmd, "ip addr add %s/%s brd %s dev %s",
+				inet_ntoa(*addr), msk, brd, ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	sprintf(cmd, "ip route add default via %s dev %s",
+					inet_ntoa(*route), ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
+					inet_ntoa(*namesrv), ifname);
+	printf("[NET] %s\n", cmd);
+	system(cmd);
+
+	__net_free(ifname);
+
+	return 0;
+}
diff --git a/plugins/net.h b/plugins/net.h
index 10f46fff..b30ae7c0 100644
--- a/plugins/net.h
+++ b/plugins/net.h
@@ -19,5 +19,11 @@
  *
  */
 
+int __net_ifaddr(const char *sysfs, struct in_addr *addr);
 char *__net_ifname(const char *sysfs);
 void __net_free(void *ptr);
+
+int __net_clear(const char *sysfs);
+int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+				struct in_addr *route, struct in_addr *bcast,
+						struct in_addr *namesrv);

commit fb83ef710615f3239e1a9ce48363bf215359eb78
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:25:21 2007 +0100

    Add support for state directory

diff --git a/bootstrap-configure b/bootstrap-configure
index 2d56ff31..1da77dae 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -8,4 +8,5 @@ fi
     ./configure --enable-maintainer-mode \
 		--prefix=/usr \
 		--mandir=/usr/share/man \
+		--localstatedir=/var \
 		--sysconfdir=/etc
diff --git a/src/Makefile.am b/src/Makefile.am
index 05f342b9..d693035f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -9,6 +9,8 @@ connmand_SOURCES = main.c connman.h plugin.c iface.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
+statedir = $(localstatedir)/run/connman
+
 if MAINTAINER_MODE
 plugindir = $(abs_top_srcdir)/plugins
 else
@@ -16,7 +18,7 @@ plugindir = $(libdir)/connman/plugins
 endif
 
 AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
-			-DPLUGINDIR=\""$(plugindir)"\"
+		-DSTATEDIR=\""$(statedir)"\" -DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/src/main.c b/src/main.c
index 89c49fdb..245dece0 100644
--- a/src/main.c
+++ b/src/main.c
@@ -25,8 +25,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <string.h>
 #include <signal.h>
+#include <sys/stat.h>
 
 #include <gdbus.h>
 
@@ -44,6 +46,9 @@ int main(int argc, char *argv[])
 	DBusConnection *conn;
 	struct sigaction sa;
 
+	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
+			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+
 	main_loop = g_main_loop_new(NULL, FALSE);
 
 	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
@@ -75,5 +80,7 @@ int main(int argc, char *argv[])
 
 	g_main_loop_unref(main_loop);
 
+	rmdir(STATEDIR);
+
 	return 0;
 }

commit afd6d12088afd2ddcfcc23ec6060bc3216ac6977
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:29:59 2007 +0100

    Add support for initial IPv4 address retrieval

diff --git a/src/iface.c b/src/iface.c
index ce6ab380..39de81dc 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <string.h>
+#include <arpa/inet.h>
 
 #include <glib.h>
 #include <gdbus.h>
@@ -116,6 +117,13 @@ static int probe_device(LibHalContext *ctx,
 
 	interfaces = g_slist_append(interfaces, iface);
 
+	if ((iface->flags & CONNMAN_IFACE_FLAGS_IPV4) &&
+						driver->get_ipv4) {
+		driver->get_ipv4(iface, &iface->ipv4);
+
+		DBG("address %s", inet_ntoa(iface->ipv4.address));
+	}
+
 	return 0;
 }
 

commit 743f1f56acd3622f93d339370ea923c18814d241
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 01:43:47 2007 +0100

    Fix naming of interface flags

diff --git a/include/iface.h b/include/iface.h
index daeaf172..db0dec50 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -37,9 +37,9 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAGS_CARRIER_DETECT	= (1 << 0),
-	CONNMAN_IFACE_FLAGS_IPV4		= (1 << 1),
-	CONNMAN_IFACE_FLAGS_IPV6		= (1 << 2),
+	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 0),
+	CONNMAN_IFACE_FLAG_IPV4           = (1 << 1),
+	CONNMAN_IFACE_FLAG_IPV6           = (1 << 2),
 };
 
 struct connman_ipv4 {
diff --git a/plugins/80203.c b/plugins/80203.c
index e39fcdc4..826dd818 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -43,8 +43,8 @@ static int iface_probe(struct connman_iface *iface)
 
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
-	iface->flags = CONNMAN_IFACE_FLAGS_CARRIER_DETECT |
-						CONNMAN_IFACE_FLAGS_IPV4;
+	iface->flags = CONNMAN_IFACE_FLAG_CARRIER_DETECT |
+					CONNMAN_IFACE_FLAG_IPV4;
 
 	__net_free(ifname);
 
diff --git a/plugins/80211.c b/plugins/80211.c
index 1fd5aaf5..091a3a06 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -43,7 +43,7 @@ static int iface_probe(struct connman_iface *iface)
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
-	iface->flags = CONNMAN_IFACE_FLAGS_IPV4;
+	iface->flags = CONNMAN_IFACE_FLAG_IPV4;
 
 	__net_free(ifname);
 
diff --git a/src/iface.c b/src/iface.c
index 39de81dc..69da8fe0 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -117,7 +117,7 @@ static int probe_device(LibHalContext *ctx,
 
 	interfaces = g_slist_append(interfaces, iface);
 
-	if ((iface->flags & CONNMAN_IFACE_FLAGS_IPV4) &&
+	if ((iface->flags & CONNMAN_IFACE_FLAG_IPV4) &&
 						driver->get_ipv4) {
 		driver->get_ipv4(iface, &iface->ipv4);
 

commit 5bc520d3b5025d29a1782fc093d2f8532580e767
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 03:00:36 2007 +0100

    Add helper script and configuration file for DHCP support

diff --git a/Makefile.am b/Makefile.am
index 0a0969fa..52247b98 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src plugins
+SUBDIRS = include src plugins scripts
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index 930691af..8f13afcd 100644
--- a/configure.in
+++ b/configure.in
@@ -34,9 +34,15 @@ PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
 AC_SUBST(GDBUS_CFLAGS)
 AC_SUBST(GDBUS_LIBS)
 
+PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
+				AC_MSG_ERROR(libdbus is required))
+AC_SUBST(DBUS_CFLAGS)
+AC_SUBST(DBUS_LIBS)
+
 PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 				AC_MSG_ERROR(libhal is required))
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile plugins/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile
+			plugins/Makefile scripts/Makefile)
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
new file mode 100644
index 00000000..bb79358e
--- /dev/null
+++ b/scripts/Makefile.am
@@ -0,0 +1,14 @@
+
+scriptdir = $(libdir)/connman/scripts
+
+script_DATA = dhclient.conf
+
+script_PROGRAMS = dhclient-script
+
+dhclient_script_LDADD = @DBUS_LIBS@
+
+AM_CFLAGS = @DBUS_CFLAGS@
+
+EXTRA_DIST = $(script_DATA)
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
new file mode 100644
index 00000000..39b235c7
--- /dev/null
+++ b/scripts/dhclient-script.c
@@ -0,0 +1,110 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dbus/dbus.h>
+
+extern char **environ;
+
+static void append(DBusMessageIter *dict, const char *pattern)
+{
+	DBusMessageIter entry;
+	const char *key, *value;
+	char *delim;
+
+	delim = strchr(pattern, '=');
+	*delim = '\0';
+
+	key = pattern;
+	value = delim + 1;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+							NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+int main(int argc, char *argv[])
+{
+	DBusConnection *conn;
+	DBusMessage *msg;
+	DBusMessageIter iter, dict;
+	dbus_uint32_t pid;
+	char **envp, *busname, *reason, *interface;
+
+	busname = getenv("BUSNAME");
+
+	pid = atoi(getenv("pid"));
+	reason = getenv("reason");
+	interface = getenv("interface");
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (conn == NULL)
+		exit(1);
+
+	msg = dbus_message_new_method_call(busname, "/org/isc/dhclient",
+						"org.isc.dhclient", "notify");
+	if (msg == NULL) {
+		dbus_connection_unref(conn);
+		exit(1);
+	}
+
+	dbus_message_append_args(msg, DBUS_TYPE_UINT32, &pid,
+				DBUS_TYPE_STRING, &reason, DBUS_TYPE_INVALID);
+
+	dbus_message_iter_init_append(msg, &iter);
+
+	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_STRING_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	for (envp = environ; envp && *envp; envp++) {
+		if (strlen(*envp) < 5)
+			continue;
+
+		if (strncmp(*envp, "new_", 4) == 0 ||
+				strncmp(*envp, "old_", 4) == 0 ||
+					strncmp(*envp, "alia", 4) == 0)
+			append(&dict, *envp);
+	}
+
+	dbus_message_iter_close_container(&iter, &dict);
+
+	dbus_connection_send(conn, msg, NULL);
+
+	dbus_message_unref(msg);
+
+	dbus_connection_unref(conn);
+
+	return 0;
+}
diff --git a/scripts/dhclient.conf b/scripts/dhclient.conf
new file mode 100644
index 00000000..4b206a3b
--- /dev/null
+++ b/scripts/dhclient.conf
@@ -0,0 +1,3 @@
+send host-name "<hostname>";
+request subnet-mask, broadcast-address, time-offset, routers,
+	domain-name, domain-name-servers, host-name;

commit e1ec0cf683d35746dd4e94abfab6ad5aa2de10fe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 24 03:04:10 2007 +0100

    Add experimental DHCP plugin

diff --git a/include/dhcp.h b/include/dhcp.h
index 337746b3..f817e0a1 100644
--- a/include/dhcp.h
+++ b/include/dhcp.h
@@ -28,6 +28,14 @@ extern "C" {
 
 #include <connman/iface.h>
 
+enum connman_dhcp_state {
+	CONNMAN_DHCP_STATE_UNKNOWN = 0,
+	CONNMAN_DHCP_STATE_INIT    = 1,
+	CONNMAN_DHCP_STATE_BOUND   = 2,
+	CONNMAN_DHCP_STATE_RENEW   = 3,
+	CONNMAN_DHCP_STATE_FAILED  = 4,
+};
+
 struct connman_dhcp_driver {
 	const char *name;
 	int (*request) (struct connman_iface *iface);
@@ -37,6 +45,10 @@ struct connman_dhcp_driver {
 extern int connman_dhcp_register(struct connman_dhcp_driver *driver);
 extern void connman_dhcp_unregister(struct connman_dhcp_driver *driver);
 
+extern int connman_dhcp_update(struct connman_iface *iface,
+				enum connman_dhcp_state state,
+					struct connman_ipv4 *ipv4);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2d7d5df0..a0a387de 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,14 +1,29 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la
+plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
+			libconnman-dhclient.la
 
 libconnman_80203_la_SOURCES = 80203.c net.h net.c
 
 libconnman_80211_la_SOURCES = 80211.c net.h net.c
 
+libconnman_dhclient_la_SOURCES = dhclient.c net.h net.c
+libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
+
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
+statedir = $(localstatedir)/run/connman
+
+if MAINTAINER_MODE
+scriptdir = $(abs_top_srcdir)/scripts
+else
+scriptdir = $(libdir)/connman/scripts
+endif
+
+AM_CFLAGS = @GDBUS_CFLAGS@ \
+		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
+
 INCLUDES = -I$(top_builddir)/include
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
new file mode 100644
index 00000000..dbf6e6d9
--- /dev/null
+++ b/plugins/dhclient.c
@@ -0,0 +1,273 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#include <arpa/inet.h>
+
+#include <glib.h>
+#include <gdbus.h>
+
+#include <connman/plugin.h>
+#include <connman/dhcp.h>
+
+#include "net.h"
+
+static const char *busname;
+
+struct dhclient_task {
+	GPid pid;
+	char *ifname;
+	struct connman_iface *iface;
+};
+
+static GSList *tasks = NULL;
+
+static struct dhclient_task *find_task(GPid pid)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct dhclient_task *task = list->data;
+
+		if (task->pid == pid)
+			return task;
+	}
+
+	return NULL;
+}
+
+static int dhclient_request(struct connman_iface *iface)
+{
+	struct dhclient_task *task;
+	char *ifname, *argv[16], address[128], pidfile[PATH_MAX];
+	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	task = g_try_new0(struct dhclient_task, 1);
+	if (task == NULL)
+		return -1;
+
+	task->ifname = ifname;
+	task->iface = iface;
+
+	printf("[DHCP] request for %s\n", ifname);
+
+	snprintf(address, sizeof(address) - 1, "BUSNAME=%s", busname);
+	snprintf(pidfile, sizeof(pidfile) - 1,
+				"%s/dhclient.%s.pid", STATEDIR, ifname);
+	snprintf(leases, sizeof(leases) - 1,
+				"%s/dhclient.%s.leases", STATEDIR, ifname);
+	snprintf(config, sizeof(config) - 1, "%s/dhclient.conf", SCRIPTDIR);
+	snprintf(script, sizeof(script) - 1, "%s/dhclient-script", SCRIPTDIR);
+
+	argv[0] = "/sbin/dhclient";
+	argv[1] = "-d";
+	argv[2] = "-q";
+	argv[3] = "-n";
+	argv[4] = "-e";
+	argv[5] = address;
+	argv[6] = "-pf";
+	argv[7] = pidfile;
+	argv[8] = "-lf";
+	argv[9] = leases;
+	argv[10] = "-cf";
+	argv[11] = config;
+	argv[12] = "-sf";
+	argv[13] = script;
+	argv[14] = ifname;
+	argv[15] = NULL;
+
+	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+				NULL, NULL, &task->pid, NULL) == FALSE) {
+		printf("Failed to spawn dhclient\n");
+		return -1;
+	}
+
+	tasks = g_slist_append(tasks, task);
+
+	printf("[DHCP] executed with pid %d\n", task->pid);
+
+	return 0;
+}
+
+static int dhclient_release(struct connman_iface *iface)
+{
+	char *ifname;
+
+	ifname = __net_ifname(iface->sysfs);
+	if (ifname == NULL)
+		return -1;
+
+	printf("[DHCP] release for %s\n", ifname);
+
+	__net_free(ifname);
+
+	return 0;
+}
+
+static struct connman_dhcp_driver dhclient_driver = {
+	.name		= "dhclient",
+	.request	= dhclient_request,
+	.release	= dhclient_release,
+};
+
+static DBusMessage *notify_method(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessageIter iter, dict;
+	dbus_uint32_t pid;
+	struct dhclient_task *task;
+	struct connman_ipv4 ipv4;
+	const char *text, *key, *value;
+
+	memset(&ipv4, 0, sizeof(ipv4));
+
+	dbus_message_iter_init(msg, &iter);
+
+	dbus_message_iter_get_basic(&iter, &pid);
+	dbus_message_iter_next(&iter);
+
+	dbus_message_iter_get_basic(&iter, &text);
+	dbus_message_iter_next(&iter);
+
+	printf("[DHCP] change %d to %s\n", pid, text);
+
+	task = find_task(pid);
+	if (task == NULL)
+		return NULL;
+
+	dbus_message_iter_recurse(&iter, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+		dbus_message_iter_next(&entry);
+		dbus_message_iter_get_basic(&entry, &value);
+
+		printf("[DHCP] %s = %s\n", key, value);
+
+		if (strcmp(key, "new_ip_address") == 0)
+			inet_aton(value, &ipv4.address);
+
+		if (strcmp(key, "new_subnet_mask") == 0)
+			inet_aton(value, &ipv4.netmask);
+
+		if (strcmp(key, "new_routers") == 0)
+			inet_aton(value, &ipv4.gateway);
+
+		if (strcmp(key, "new_network_number") == 0)
+			inet_aton(value, &ipv4.network);
+
+		if (strcmp(key, "new_broadcast_address") == 0)
+			inet_aton(value, &ipv4.broadcast);
+
+		if (strcmp(key, "new_domain_name_servers") == 0)
+			inet_aton(value, &ipv4.nameserver);
+
+		dbus_message_iter_next(&dict);
+	}
+
+	if (strcmp(text, "PREINIT") == 0)
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_INIT, &ipv4);
+	else if (strcmp(text, "BOUND") == 0 || strcmp(text, "REBOOT") == 0)
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_BOUND, &ipv4);
+	else if (strcmp(text, "RENEW") == 0 || strcmp(text, "REBIND") == 0)
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_RENEW, &ipv4);
+	else
+		connman_dhcp_update(task->iface,
+					CONNMAN_DHCP_STATE_FAILED, NULL);
+
+	return NULL;
+}
+
+static GDBusMethodTable dhclient_methods[] = {
+	{ "notify", "usa{ss}", "", notify_method, G_DBUS_METHOD_FLAG_NOREPLY },
+	{ },
+};
+
+static DBusConnection *connection;
+
+static int plugin_init(void)
+{
+	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL);
+
+	busname = dbus_bus_get_unique_name(connection);
+
+	g_dbus_register_object(connection, "/org/isc/dhclient", NULL, NULL);
+
+	g_dbus_register_interface(connection, "/org/isc/dhclient",
+					"org.isc.dhclient",
+					dhclient_methods, NULL, NULL);
+
+	connman_dhcp_register(&dhclient_driver);
+
+	return 0;
+}
+
+static void plugin_exit(void)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct dhclient_task *task = list->data;
+		char pathname[PATH_MAX];
+
+		printf("[DHCP] killing process %d\n", task->pid);
+
+		kill(task->pid, SIGTERM);
+
+		snprintf(pathname, sizeof(pathname) - 1,
+				"%s/dhclient.%s.pid", STATEDIR, task->ifname);
+		unlink(pathname);
+
+		snprintf(pathname, sizeof(pathname) - 1,
+				"%s/dhclient.%s.leases", STATEDIR, task->ifname);
+		unlink(pathname);
+
+		__net_free(task->ifname);
+
+		g_free(task);
+	}
+
+	g_slist_free(tasks);
+
+	connman_dhcp_unregister(&dhclient_driver);
+
+	g_dbus_cleanup_connection(connection);
+}
+
+CONNMAN_PLUGIN_DEFINE("dhclient", "ISC DHCP client plugin", VERSION,
+						plugin_init, plugin_exit)
diff --git a/src/dhcp.c b/src/dhcp.c
index 5a6e5c9b..8af6dab3 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <arpa/inet.h>
+
 #include <glib.h>
 
 #include "connman.h"
@@ -45,6 +47,29 @@ void connman_dhcp_unregister(struct connman_dhcp_driver *driver)
 	drivers = g_slist_remove(drivers, driver);
 }
 
+int connman_dhcp_update(struct connman_iface *iface,
+				enum connman_dhcp_state state,
+					struct connman_ipv4 *ipv4)
+{
+	DBG("iface %p state %d", iface, state);
+
+	if (state == CONNMAN_DHCP_STATE_BOUND) {
+		DBG("address %s", inet_ntoa(ipv4->address));
+		DBG("netmask %s", inet_ntoa(ipv4->netmask));
+		DBG("gateway %s", inet_ntoa(ipv4->gateway));
+		DBG("network %s", inet_ntoa(ipv4->network));
+		DBG("broadcast %s", inet_ntoa(ipv4->broadcast));
+		DBG("nameserver %s", inet_ntoa(ipv4->nameserver));
+
+		if (iface->driver->set_ipv4) {
+			iface->driver->set_ipv4(iface, ipv4);
+			iface->ipv4 = *ipv4;
+		}
+	}
+
+	return 0;
+}
+
 int __connman_dhcp_request(struct connman_iface *iface)
 {
 	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);

commit 1f883743506f40054c29b33021948cdb4e765ba6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 09:27:23 2007 +0100

    Add interface index and state variables

diff --git a/include/iface.h b/include/iface.h
index db0dec50..9f3e5e06 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -37,9 +37,17 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 0),
+	CONNMAN_IFACE_FLAG_RTNL           = (1 << 0),
 	CONNMAN_IFACE_FLAG_IPV4           = (1 << 1),
 	CONNMAN_IFACE_FLAG_IPV6           = (1 << 2),
+	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 3),
+};
+
+enum connman_iface_state {
+	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
+	CONNMAN_IFACE_STATE_ACTIVE    = 1,
+	CONNMAN_IFACE_STATE_CONNECTED = 2,
+	CONNMAN_IFACE_STATE_READY     = 3,
 };
 
 struct connman_ipv4 {
@@ -51,13 +59,18 @@ struct connman_ipv4 {
 	struct in_addr nameserver;
 };
 
+struct connman_network {
+};
+
 struct connman_iface {
 	struct connman_iface_driver *driver;
 	char *path;
 	char *udi;
 	char *sysfs;
+	int index;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
+	enum connman_iface_state state;
 	struct connman_ipv4 ipv4;
 };
 
@@ -66,15 +79,23 @@ struct connman_iface_driver {
 	const char *capability;
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
+	int (*activate) (struct connman_iface *iface);
+	int (*shutdown) (struct connman_iface *iface);
 	int (*get_ipv4) (struct connman_iface *iface,
 					struct connman_ipv4 *ipv4);
 	int (*set_ipv4) (struct connman_iface *iface,
 					struct connman_ipv4 *ipv4);
+	int (*scan) (struct connman_iface *iface);
+	int (*connect) (struct connman_iface *iface,
+					struct connman_network *network);
 };
 
 extern int connman_iface_register(struct connman_iface_driver *driver);
 extern void connman_iface_unregister(struct connman_iface_driver *driver);
 
+extern int connman_iface_update(struct connman_iface *iface,
+					enum connman_iface_state state);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/plugins/80203.c b/plugins/80203.c
index 826dd818..785c441e 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -33,35 +33,28 @@
 
 static int iface_probe(struct connman_iface *iface)
 {
-	char *ifname;
-
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return -1;
-
-	printf("[802.03] probe interface %s\n", ifname);
+	printf("[802.03] probe interface index %d\n", iface->index);
 
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
-	iface->flags = CONNMAN_IFACE_FLAG_CARRIER_DETECT |
-					CONNMAN_IFACE_FLAG_IPV4;
-
-	__net_free(ifname);
+	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
+				CONNMAN_IFACE_FLAG_IPV4 |
+				CONNMAN_IFACE_FLAG_CARRIER_DETECT;
 
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.03] remove interface\n");
+	printf("[802.03] remove interface index %d\n", iface->index);
 
-	__net_clear(iface->sysfs);
+	__net_clear(iface->index);
 }
 
 static int iface_get_ipv4(struct connman_iface *iface,
 					struct connman_ipv4 *ipv4)
 {
-	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
 		return -1;
 
 	printf("[802.03] get address %s\n", inet_ntoa(ipv4->address));
@@ -76,7 +69,7 @@ static int iface_set_ipv4(struct connman_iface *iface,
 	printf("[802.03] set netmask %s\n", inet_ntoa(ipv4->netmask));
 	printf("[802.03] set gateway %s\n", inet_ntoa(ipv4->gateway));
 
-	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
 				&ipv4->gateway, &ipv4->broadcast,
 						&ipv4->nameserver);
 
diff --git a/plugins/80211.c b/plugins/80211.c
index 091a3a06..56306860 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -33,34 +33,36 @@
 
 static int iface_probe(struct connman_iface *iface)
 {
-	char *ifname;
-
-	ifname = __net_ifname(iface->sysfs);
-	if (ifname == NULL)
-		return -1;
-
-	printf("[802.11] probe interface %s\n", ifname);
+	printf("[802.11] probe interface index %d\n", iface->index);
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
-	iface->flags = CONNMAN_IFACE_FLAG_IPV4;
-
-	__net_free(ifname);
+	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
+				CONNMAN_IFACE_FLAG_IPV4;
 
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.11] remove interface\n");
+	printf("[802.11] remove interface index %d\n", iface->index);
+
+	__net_clear(iface->index);
+}
+
+static int iface_activate(struct connman_iface *iface)
+{
+	printf("[802.11] activate interface index %d\n", iface->index);
 
-	__net_clear(iface->sysfs);
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
+
+	return 0;
 }
 
 static int iface_get_ipv4(struct connman_iface *iface,
 					struct connman_ipv4 *ipv4)
 {
-	if (__net_ifaddr(iface->sysfs, &ipv4->address) < 0)
+	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
 		return -1;
 
 	printf("[802.11] get address %s\n", inet_ntoa(ipv4->address));
@@ -75,20 +77,38 @@ static int iface_set_ipv4(struct connman_iface *iface,
 	printf("[802.11] set netmask %s\n", inet_ntoa(ipv4->netmask));
 	printf("[802.11] set gateway %s\n", inet_ntoa(ipv4->gateway));
 
-	__net_set(iface->sysfs, &ipv4->address, &ipv4->netmask,
+	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
 				&ipv4->gateway, &ipv4->broadcast,
 						&ipv4->nameserver);
 
 	return 0;
 }
 
+static int iface_scan(struct connman_iface *iface)
+{
+	printf("[802.11] scanning interface index %d\n", iface->index);
+
+	return 0;
+}
+
+static int iface_connect(struct connman_iface *iface,
+					struct connman_network *network)
+{
+	printf("[802.11] connect interface index %d\n", iface->index);
+
+	return 0;
+}
+
 static struct connman_iface_driver iface_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
+	.activate	= iface_activate,
 	.get_ipv4	= iface_get_ipv4,
 	.set_ipv4	= iface_set_ipv4,
+	.scan		= iface_scan,
+	.connect	= iface_connect,
 };
 
 static int plugin_init(void)
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index dbf6e6d9..d32f68a7 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -67,7 +67,7 @@ static int dhclient_request(struct connman_iface *iface)
 	char *ifname, *argv[16], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
 
-	ifname = __net_ifname(iface->sysfs);
+	ifname = __net_ifname(iface->index);
 	if (ifname == NULL)
 		return -1;
 
@@ -122,7 +122,7 @@ static int dhclient_release(struct connman_iface *iface)
 {
 	char *ifname;
 
-	ifname = __net_ifname(iface->sysfs);
+	ifname = __net_ifname(iface->index);
 	if (ifname == NULL)
 		return -1;
 
diff --git a/plugins/net.c b/plugins/net.c
index e0aa5a4e..18927eed 100644
--- a/plugins/net.c
+++ b/plugins/net.c
@@ -36,54 +36,10 @@
 
 #include "net.h"
 
-static int __net_ifindex(const char *sysfs)
-{
-	char *pathname;
-	char buf[8];
-	size_t size;
-	ssize_t len;
-	int fd, val = -EIO;
-
-	if (sysfs == NULL)
-		return -1;
-
-	size = strlen(sysfs) + 9;
-
-	pathname = malloc(size);
-
-	sprintf(pathname, "%s/ifindex", sysfs);
-
-	fd = open(pathname, O_RDONLY);
-
-	free(pathname);
-
-	if (fd < 0)
-		return -errno;
-
-	memset(buf, 0, sizeof(buf));
-
-	len = read(fd, buf, sizeof(buf) - 1);
-	if (len < 0) {
-		val = -errno;
-		goto done;
-	}
-
-	val = atoi(buf);
-
-done:
-	close(fd);
-
-	return val;
-}
-
-int __net_ifaddr(const char *sysfs, struct in_addr *addr)
+int __net_ifaddr(int ifindex, struct in_addr *addr)
 {
 	struct ifreq ifr;
-	int sk, ifindex;
-
-	ifindex = __net_ifindex(sysfs);
-	if (ifindex < 0)
-		return ifindex;
+	int sk;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
@@ -109,14 +65,10 @@ int __net_ifaddr(const char *sysfs, struct in_addr *addr)
 	return 0;
 }
 
-char *__net_ifname(const char *sysfs)
+char *__net_ifname(int ifindex)
 {
 	struct ifreq ifr;
-	int sk, err, ifindex;
-
-	ifindex = __net_ifindex(sysfs);
-	if (ifindex < 0)
-		return NULL;
+	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
@@ -141,11 +93,11 @@ void __net_free(void *ptr)
 		free(ptr);
 }
 
-int __net_clear(const char *sysfs)
+int __net_clear(int ifindex)
 {
 	char *ifname, cmd[128];
 
-	ifname = __net_ifname(sysfs);
+	ifname = __net_ifname(ifindex);
 	if (ifname == NULL)
 		return -1;
 
@@ -162,17 +114,17 @@ int __net_clear(const char *sysfs)
 	return 0;
 }
 
-int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
 				struct in_addr *route, struct in_addr *bcast,
 						struct in_addr *namesrv)
 {
 	char *ifname, cmd[128], msk[32], brd[32];
 
-	ifname = __net_ifname(sysfs);
+	ifname = __net_ifname(ifindex);
 	if (ifname == NULL)
 		return -1;
 
-	__net_clear(sysfs);
+	__net_clear(ifindex);
 
 	sprintf(msk, "%s", "24");
 	sprintf(brd, "%s", inet_ntoa(*bcast));
diff --git a/plugins/net.h b/plugins/net.h
index b30ae7c0..83de416e 100644
--- a/plugins/net.h
+++ b/plugins/net.h
@@ -19,11 +19,13 @@
  *
  */
 
-int __net_ifaddr(const char *sysfs, struct in_addr *addr);
-char *__net_ifname(const char *sysfs);
+#include <arpa/inet.h>
+
+int __net_ifaddr(int ifindex, struct in_addr *addr);
+char *__net_ifname(int ifindex);
 void __net_free(void *ptr);
 
-int __net_clear(const char *sysfs);
-int __net_set(const char *sysfs, struct in_addr *addr, struct in_addr *mask,
+int __net_clear(int ifindex);
+int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
 				struct in_addr *route, struct in_addr *bcast,
 						struct in_addr *namesrv);
diff --git a/src/dhcp.c b/src/dhcp.c
index 8af6dab3..b4e921e3 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -65,6 +65,8 @@ int connman_dhcp_update(struct connman_iface *iface,
 			iface->driver->set_ipv4(iface, ipv4);
 			iface->ipv4 = *ipv4;
 		}
+
+		connman_iface_update(iface, CONNMAN_IFACE_STATE_READY);
 	}
 
 	return 0;
diff --git a/src/iface.c b/src/iface.c
index 69da8fe0..9dc0c801 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -53,6 +53,33 @@ void connman_iface_unregister(struct connman_iface_driver *driver)
 
 static GSList *interfaces = NULL;
 
+int connman_iface_update(struct connman_iface *iface,
+                                        enum connman_iface_state state)
+{
+	switch (state) {
+	case CONNMAN_IFACE_STATE_ACTIVE:
+		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
+			if (iface->driver->scan)
+				iface->driver->scan(iface);
+
+			if (iface->driver->connect)
+				iface->driver->connect(iface, NULL);
+		}
+		break;
+
+	case CONNMAN_IFACE_STATE_CONNECTED:
+		__connman_dhcp_request(iface);
+		break;
+
+	default:
+		break;
+        }
+
+	iface->state = state;
+
+	return 0;
+}
+
 static void device_free(void *data)
 {
 	struct connman_iface *iface = data;
@@ -98,8 +125,15 @@ static int probe_device(LibHalContext *ctx,
 	if (sysfs != NULL)
 		iface->sysfs = g_strdup(sysfs);
 
+	iface->index = -1;
+
+	if (g_str_has_prefix(driver->capability, "net") == TRUE)
+		iface->index = libhal_device_get_property_int(ctx, udi,
+						"net.linux.ifindex", NULL);
+
 	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
 	iface->flags = 0;
+	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
 
 	DBG("iface %p", iface);
 
@@ -124,6 +158,9 @@ static int probe_device(LibHalContext *ctx,
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
 
+	if (driver->activate)
+		driver->activate(iface);
+
 	return 0;
 }
 

commit cd577016d4d7730bb612c6a5771122b68a2e1664
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 09:45:07 2007 +0100

    Add experimental netlink support

diff --git a/include/Makefile.am b/include/Makefile.am
index 627ab0a0..2d28a822 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h iface.h dhcp.h
+noinst_HEADERS = plugin.h iface.h rtnl.h dhcp.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/rtnl.h b/include/rtnl.h
new file mode 100644
index 00000000..4b3e6925
--- /dev/null
+++ b/include/rtnl.h
@@ -0,0 +1,33 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_RTNL_H
+#define __CONNMAN_RTNL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_RTNL_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index d693035f..65636af4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c iface.c dhcp.c
+connmand_SOURCES = main.c connman.h plugin.c iface.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 1cd6c163..b1b6cbea 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -44,6 +44,11 @@ void __connman_plugin_cleanup(void);
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
 
+#include <connman/rtnl.h>
+
+int __connman_rtnl_init(void);
+void __connman_rtnl_cleanup(void);
+
 #include <connman/dhcp.h>
 
 int __connman_dhcp_request(struct connman_iface *iface);
diff --git a/src/main.c b/src/main.c
index 245dece0..40d6e072 100644
--- a/src/main.c
+++ b/src/main.c
@@ -63,6 +63,8 @@ int main(int argc, char *argv[])
 
 	__connman_iface_init(conn);
 
+	__connman_rtnl_init();
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -70,6 +72,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_rtnl_cleanup();
+
 	__connman_iface_cleanup();
 
 	__connman_plugin_cleanup();
diff --git a/src/rtnl.c b/src/rtnl.c
new file mode 100644
index 00000000..c88aad10
--- /dev/null
+++ b/src/rtnl.c
@@ -0,0 +1,336 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include <glib.h>
+
+#include "connman.h"
+
+static void parse_link(struct nlmsghdr *hdr)
+{
+	struct ifinfomsg *msg;
+	struct rtattr *attr;
+	int bytes;
+
+	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
+	bytes = IFLA_PAYLOAD(hdr);
+
+	DBG("ifi_index %d ifi_flags %d", msg->ifi_index, msg->ifi_flags);
+
+	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		int len = RTA_PAYLOAD(attr);
+
+		switch (attr->rta_type) {
+		case IFLA_ADDRESS:
+			DBG("  rta_type address len %d", len);
+			break;
+		case IFLA_BROADCAST:
+			DBG("  rta_type broadcast len %d", len);
+			break;
+		case IFLA_IFNAME:
+			DBG("  rta_type ifname %s", (char *) RTA_DATA(attr));
+			break;
+		case IFLA_MTU:
+			DBG("  rta_type mtu len %d", len);
+			break;
+		case IFLA_LINK:
+			DBG("  rta_type link len %d", len);
+			break;
+		case IFLA_QDISC:
+			DBG("  rta_type qdisc len %d", len);
+			break;
+		case IFLA_STATS:
+			DBG("  rta_type stats len %d", len);
+			break;
+		case IFLA_COST:
+			DBG("  rta_type cost len %d", len);
+			break;
+		case IFLA_PRIORITY:
+			DBG("  rta_type priority len %d", len);
+			break;
+		case IFLA_MASTER:
+			DBG("  rta_type master len %d", len);
+			break;
+		case IFLA_WIRELESS:
+			DBG("  rta_type wireless len %d", len);
+			{
+				unsigned char *data = RTA_DATA(attr);
+				int i;
+				for (i = 0; i < len; i++)
+					printf(" %02x", data[i]);
+				printf("\n");
+			}
+			break;
+		case IFLA_PROTINFO:
+			DBG("  rta_type protinfo len %d", len);
+			break;
+		case IFLA_TXQLEN:
+			DBG("  rta_type txqlen len %d", len);
+			break;
+		case IFLA_MAP:
+			DBG("  rta_type map len %d", len);
+			break;
+		case IFLA_WEIGHT:
+			DBG("  rta_type widght len %d", len);
+			break;
+		case IFLA_OPERSTATE:
+			DBG("  rta_type operstate len %d", len);
+			break;
+		case IFLA_LINKMODE:
+			DBG("  rta_type linkmode len %d", len);
+			break;
+		default:
+			DBG("  rta_type %d len %d", attr->rta_type, len);
+			break;
+		}
+	}
+}
+
+static void parse_addr(struct nlmsghdr *hdr)
+{
+	struct ifaddrmsg *msg;
+	struct rtattr *attr;
+	int bytes;
+
+	msg = (struct ifaddrmsg *) NLMSG_DATA(hdr);
+	bytes = IFA_PAYLOAD(hdr);
+
+	DBG("ifa_family %d ifa_index %d", msg->ifa_family, msg->ifa_index);
+
+	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		int len = RTA_PAYLOAD(attr);
+
+		switch (attr->rta_type) {
+		case IFA_ADDRESS:
+			DBG("  rta_type address len %d", len);
+			if (msg->ifa_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case IFA_LOCAL:
+			DBG("  rta_type local len %d", len);
+			if (msg->ifa_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case IFA_LABEL:
+			DBG("  rta_type label %s", (char *) RTA_DATA(attr));
+			break;
+		case IFA_BROADCAST:
+			DBG("  rta_type broadcast len %d", len);
+			if (msg->ifa_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case IFA_ANYCAST:
+			DBG("  rta_type anycast len %d", len);
+			break;
+		case IFA_CACHEINFO:
+			DBG("  rta_type cacheinfo len %d", len);
+			break;
+		case IFA_MULTICAST:
+			DBG("  rta_type multicast len %d", len);
+			break;
+		default:
+			DBG("  rta_type %d len %d", attr->rta_type, len);
+			break;
+		}
+	}
+}
+
+static void parse_route(struct nlmsghdr *hdr)
+{
+	struct rtmsg *msg;
+	struct rtattr *attr;
+	int bytes;
+
+	msg = (struct rtmsg *) NLMSG_DATA(hdr);
+	bytes = IFA_PAYLOAD(hdr);
+
+	DBG("rtm_family %d rtm_flags %d", msg->rtm_family, msg->rtm_flags);
+
+	for (attr = RTA_DATA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		int len = RTA_PAYLOAD(attr);
+
+		switch (attr->rta_type) {
+		case RTA_DST:
+			DBG("  rta_type dst len %d", len);
+			break;
+		case RTA_SRC:
+			DBG("  rta_type src len %d", len);
+			break;
+		case RTA_IIF:
+			DBG("  rta_type iff len %d", len);
+			break;
+		case RTA_OIF:
+			DBG("  rta_type oif len %d", len);
+			break;
+		case RTA_GATEWAY:
+			DBG("  rta_type gateway len %d", len);
+			break;
+		default:
+			DBG("  rta_type %d len %d", attr->rta_type, len);
+			break;
+		}
+	}
+}
+
+static void parse_message(unsigned char *buf, size_t size)
+{
+	struct nlmsghdr *hdr = (void *) buf;
+
+	if (!NLMSG_OK(hdr, size))
+		return;
+
+	switch (hdr->nlmsg_type) {
+	case NLMSG_DONE:
+		DBG("nlmsg_type done");
+		return;
+	case NLMSG_NOOP:
+		DBG("nlmsg_type noop");
+		return;
+	case NLMSG_OVERRUN:
+		DBG("nlmsg_type overrun");
+		return;
+	case NLMSG_ERROR:
+		DBG("nlmsg_type error");
+		return;
+	case RTM_NEWLINK:
+		DBG("nlmsg_type RTM_NEWLINK");
+		parse_link(hdr);
+		break;
+	case RTM_DELLINK:
+		DBG("nlmsg_type RTM_DELLINK");
+		parse_link(hdr);
+		break;
+	case RTM_NEWADDR:
+		DBG("nlmsg_type RTM_NEWADDR");
+		parse_addr(hdr);
+		break;
+	case RTM_DELADDR:
+		DBG("nlmsg_type RTM_DELADDR");
+		parse_addr(hdr);
+		break;
+	case RTM_NEWROUTE:
+		DBG("nlmsg_type RTM_NEWROUTE");
+		parse_route(hdr);
+		break;
+	case RTM_DELROUTE:
+		DBG("nlmsg_type RTM_DELROUTE");
+		parse_route(hdr);
+		break;
+	default:
+		DBG("nlmsg_type %d", hdr->nlmsg_type);
+		break;
+	}
+}
+
+static gboolean netlink_event(GIOChannel *chan,
+				GIOCondition cond, gpointer data)
+{
+	unsigned char buf[256];
+	gsize len;
+	GIOError err;
+
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	memset(buf, 0, sizeof(buf));
+
+	err = g_io_channel_read(chan, (gchar *) buf, sizeof(buf), &len);
+	if (err) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	parse_message(buf, len);
+
+	return TRUE;
+}
+
+static GIOChannel *channel = NULL;
+
+int __connman_rtnl_init(void)
+{
+	struct sockaddr_nl addr;
+	int sk;
+
+	DBG("");
+
+	sk = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);
+	if (sk < 0)
+		return -1;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
+	addr.nl_pid = getpid();
+
+	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	channel = g_io_channel_unix_new(sk);
+	g_io_channel_set_close_on_unref(channel, TRUE);
+
+	g_io_add_watch(channel,
+			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+						netlink_event, NULL);
+
+	g_io_channel_unref(channel);
+
+	return 0;
+}
+
+void __connman_rtnl_cleanup(void)
+{
+	DBG("");
+
+	g_io_channel_unref(channel);
+
+	channel = NULL;
+}

commit e61188bfd0bf715afd472ab04867ae53cf38c647
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 09:50:33 2007 +0100

    Add skeleton for supplicant infrastructure

diff --git a/plugins/80211.c b/plugins/80211.c
index 56306860..5d52ed9b 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -30,6 +30,7 @@
 #include <connman/iface.h>
 
 #include "net.h"
+#include "supplicant.h"
 
 static int iface_probe(struct connman_iface *iface)
 {
@@ -48,12 +49,16 @@ static void iface_remove(struct connman_iface *iface)
 	printf("[802.11] remove interface index %d\n", iface->index);
 
 	__net_clear(iface->index);
+
+	__supplicant_stop(iface);
 }
 
 static int iface_activate(struct connman_iface *iface)
 {
 	printf("[802.11] activate interface index %d\n", iface->index);
 
+	__supplicant_start(iface);
+
 	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
 
 	return 0;
@@ -96,6 +101,8 @@ static int iface_connect(struct connman_iface *iface,
 {
 	printf("[802.11] connect interface index %d\n", iface->index);
 
+	__supplicant_connect(iface);
+
 	return 0;
 }
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index a0a387de..24e4433f 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -6,7 +6,8 @@ plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
 
 libconnman_80203_la_SOURCES = 80203.c net.h net.c
 
-libconnman_80211_la_SOURCES = 80211.c net.h net.c
+libconnman_80211_la_SOURCES = 80211.c net.h net.c \
+				supplicant.h supplicant.c
 
 libconnman_dhclient_la_SOURCES = dhclient.c net.h net.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
new file mode 100644
index 00000000..b83f290a
--- /dev/null
+++ b/plugins/supplicant.c
@@ -0,0 +1,49 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include "supplicant.h"
+
+int __supplicant_start(struct connman_iface *iface)
+{
+	printf("[SUPPLICANT] start for index %d\n", iface->index);
+
+	return 0;
+}
+
+int __supplicant_stop(struct connman_iface *iface)
+{
+	printf("[SUPPLICANT] stop for index %d\n", iface->index);
+
+	return 0;
+}
+
+int __supplicant_connect(struct connman_iface *iface)
+{
+	printf("[SUPPLICANT] connect for index %d\n", iface->index);
+
+	return 0;
+}
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
new file mode 100644
index 00000000..ed753a88
--- /dev/null
+++ b/plugins/supplicant.h
@@ -0,0 +1,27 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <connman/iface.h>
+
+int __supplicant_start(struct connman_iface *iface);
+int __supplicant_stop(struct connman_iface *iface);
+
+int __supplicant_connect(struct connman_iface *iface);

commit 20f5610e7d3214bd96ba976d0cafcd0a20743dde
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 25 10:06:17 2007 +0100

    Fix parsing of netlink messages for routing

diff --git a/src/rtnl.c b/src/rtnl.c
index c88aad10..1657c9ae 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -183,20 +183,30 @@ static void parse_route(struct nlmsghdr *hdr)
 	int bytes;
 
 	msg = (struct rtmsg *) NLMSG_DATA(hdr);
-	bytes = IFA_PAYLOAD(hdr);
+	bytes = RTM_PAYLOAD(hdr);
 
 	DBG("rtm_family %d rtm_flags %d", msg->rtm_family, msg->rtm_flags);
 
-	for (attr = RTA_DATA(msg); RTA_OK(attr, bytes);
+	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		int len = RTA_PAYLOAD(attr);
 
 		switch (attr->rta_type) {
 		case RTA_DST:
 			DBG("  rta_type dst len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
 			break;
 		case RTA_SRC:
 			DBG("  rta_type src len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
 			break;
 		case RTA_IIF:
 			DBG("  rta_type iff len %d", len);
@@ -206,6 +216,28 @@ static void parse_route(struct nlmsghdr *hdr)
 			break;
 		case RTA_GATEWAY:
 			DBG("  rta_type gateway len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case RTA_PRIORITY:
+			DBG("  rta_type priority len %d", len);
+			break;
+		case RTA_PREFSRC:
+			DBG("  rta_type prefsrc len %d", len);
+			if (msg->rtm_family == AF_INET) {
+				struct in_addr addr;
+				addr = *((struct in_addr *) RTA_DATA(attr));
+				DBG("    address %s", inet_ntoa(addr));
+			}
+			break;
+		case RTA_METRICS:
+			DBG("  rta_type metrics len %d", len);
+			break;
+		case RTA_TABLE:
+			DBG("  rta_type table len %d", len);
 			break;
 		default:
 			DBG("  rta_type %d len %d", attr->rta_type, len);

commit c00282b78a8c8eee17f65fb75f7f9eaa89c1925a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 26 09:47:00 2007 +0100

    Add skeleton for manager interface

diff --git a/src/Makefile.am b/src/Makefile.am
index 65636af4..b78d4b38 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h plugin.c iface.c rtnl.c dhcp.c
+connmand_SOURCES = main.c connman.h manager.c plugin.c iface.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index b1b6cbea..cff8f8f6 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -34,6 +34,9 @@
 #define CONNMAN_IFACE_BASEPATH  "/interface"
 #define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
 
+int __connman_manager_init(DBusConnection *conn);
+void __connman_manager_cleanup(void);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/main.c b/src/main.c
index 40d6e072..21a0513f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -57,7 +57,7 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 
-	g_dbus_register_object(conn, CONNMAN_MANAGER_PATH, NULL, NULL);
+	__connman_manager_init(conn);
 
 	__connman_plugin_init();
 
@@ -78,7 +78,7 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_cleanup();
 
-	g_dbus_unregister_object(conn, CONNMAN_MANAGER_PATH);
+	__connman_manager_cleanup();
 
 	g_dbus_cleanup_connection(conn);
 
diff --git a/src/manager.c b/src/manager.c
new file mode 100644
index 00000000..5fa60cc2
--- /dev/null
+++ b/src/manager.c
@@ -0,0 +1,52 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gdbus.h>
+
+#include "connman.h"
+
+static DBusConnection *connection = NULL;
+
+int __connman_manager_init(DBusConnection *conn)
+{
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
+
+	g_dbus_register_object(connection, CONNMAN_MANAGER_PATH, NULL, NULL);
+
+	return 0;
+}
+
+void __connman_manager_cleanup(void)
+{
+	DBG("conn %p", connection);
+
+	g_dbus_unregister_object(connection, CONNMAN_MANAGER_PATH);
+
+	dbus_connection_unref(connection);
+}

commit e5ea9b79443b759f6d3086d40b57a94213604352
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 26 10:13:30 2007 +0100

    Add basic methods and signals for manager interface

diff --git a/src/connman.h b/src/connman.h
index cff8f8f6..b5f0e48f 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -47,6 +47,8 @@ void __connman_plugin_cleanup(void);
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
 
+void __connman_iface_list(DBusMessageIter *iter);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/iface.c b/src/iface.c
index 9dc0c801..6825c51d 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -53,8 +53,22 @@ void connman_iface_unregister(struct connman_iface_driver *driver)
 
 static GSList *interfaces = NULL;
 
+void __connman_iface_list(DBusMessageIter *iter)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		dbus_message_iter_append_basic(iter,
+				DBUS_TYPE_OBJECT_PATH, &iface->path);
+	}
+}
+
 int connman_iface_update(struct connman_iface *iface,
-                                        enum connman_iface_state state)
+					enum connman_iface_state state)
 {
 	switch (state) {
 	case CONNMAN_IFACE_STATE_ACTIVE:
@@ -158,6 +172,12 @@ static int probe_device(LibHalContext *ctx,
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
 
+	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
+					CONNMAN_MANAGER_INTERFACE,
+					"InterfaceAdded",
+					DBUS_TYPE_OBJECT_PATH, &iface->path,
+					DBUS_TYPE_INVALID);
+
 	if (driver->activate)
 		driver->activate(iface);
 
@@ -197,6 +217,11 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 		struct connman_iface *iface = list->data;
 
 		if (strcmp(udi, iface->udi) == 0) {
+			g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
+					CONNMAN_MANAGER_INTERFACE,
+					"InterfaceRemoved",
+					DBUS_TYPE_OBJECT_PATH, &iface->path,
+					DBUS_TYPE_INVALID);
 			interfaces = g_slist_remove(interfaces, iface);
 			g_dbus_unregister_object(conn, iface->path);
 			break;
@@ -293,6 +318,12 @@ static void hal_cleanup(void *data)
 
 		DBG("path %s", iface->path);
 
+		g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
+					CONNMAN_MANAGER_INTERFACE,
+					"InterfaceRemoved",
+					DBUS_TYPE_OBJECT_PATH, &iface->path,
+					DBUS_TYPE_INVALID);
+
 		g_dbus_unregister_object(conn, iface->path);
 	}
 
diff --git a/src/manager.c b/src/manager.c
index 5fa60cc2..1afecc88 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,6 +27,41 @@
 
 #include "connman.h"
 
+static DBusMessage *list_interfaces(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, iter;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_iface_list(&iter);
+
+	dbus_message_iter_close_container(&array, &iter);
+
+	return reply;
+}
+
+static GDBusMethodTable manager_methods[] = {
+	{ "ListInterfaces", "", "ao", list_interfaces },
+	{ },
+};
+
+static GDBusSignalTable manager_signals[] = {
+	{ "InterfaceAdded",   "o" },
+	{ "InterfaceRemoved", "o" },
+	{ },
+};
+
 static DBusConnection *connection = NULL;
 
 int __connman_manager_init(DBusConnection *conn)
@@ -39,6 +74,11 @@ int __connman_manager_init(DBusConnection *conn)
 
 	g_dbus_register_object(connection, CONNMAN_MANAGER_PATH, NULL, NULL);
 
+	g_dbus_register_interface(connection, CONNMAN_MANAGER_PATH,
+						CONNMAN_MANAGER_INTERFACE,
+						manager_methods,
+						manager_signals, NULL);
+
 	return 0;
 }
 
@@ -46,6 +86,9 @@ void __connman_manager_cleanup(void)
 {
 	DBG("conn %p", connection);
 
+	g_dbus_unregister_interface(connection, CONNMAN_MANAGER_PATH,
+						CONNMAN_MANAGER_INTERFACE);
+
 	g_dbus_unregister_object(connection, CONNMAN_MANAGER_PATH);
 
 	dbus_connection_unref(connection);

commit 08647078e04d94f58155e4735fe0585fead881e3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 26 10:29:31 2007 +0100

    Add basic methods and signals for interfaces

diff --git a/src/iface.c b/src/iface.c
index 6825c51d..31763b74 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -94,6 +94,68 @@ int connman_iface_update(struct connman_iface *iface,
 	return 0;
 }
 
+static DBusMessage *enable_iface(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->activate)
+		driver->activate(iface);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static GDBusMethodTable iface_methods[] = {
+	{ "Enable", "", "", enable_iface },
+	{ },
+};
+
+static dbus_bool_t get_type(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+	const char *type;
+
+	DBG("iface %p", iface);
+
+	switch (iface->type) {
+	case CONNMAN_IFACE_TYPE_80203:
+		type = "80203";
+		break;
+	case CONNMAN_IFACE_TYPE_80211:
+		type = "80211";
+		break;
+	case CONNMAN_IFACE_TYPE_WIMAX:
+		type = "wimax";
+		break;
+	case CONNMAN_IFACE_TYPE_BLUETOOTH:
+		type = "bluetooth";
+		break;
+	default:
+		type = "unknown";
+		break;
+	}
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &type);
+
+	return TRUE;
+}
+
+static GDBusPropertyTable iface_properties[] = {
+	{ "Type", "s", get_type },
+	{ },
+};
+
 static void device_free(void *data)
 {
 	struct connman_iface *iface = data;
@@ -172,15 +234,16 @@ static int probe_device(LibHalContext *ctx,
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
 
+	g_dbus_register_interface(conn, iface->path,
+					CONNMAN_IFACE_INTERFACE,
+					iface_methods, NULL, iface_properties);
+
 	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
 					CONNMAN_MANAGER_INTERFACE,
 					"InterfaceAdded",
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
-	if (driver->activate)
-		driver->activate(iface);
-
 	return 0;
 }
 
@@ -223,6 +286,8 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 			interfaces = g_slist_remove(interfaces, iface);
+			g_dbus_unregister_interface(conn, iface->path,
+						CONNMAN_IFACE_INTERFACE);
 			g_dbus_unregister_object(conn, iface->path);
 			break;
 		}
@@ -324,6 +389,9 @@ static void hal_cleanup(void *data)
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
+		g_dbus_unregister_interface(conn, iface->path,
+						CONNMAN_IFACE_INTERFACE);
+
 		g_dbus_unregister_object(conn, iface->path);
 	}
 

commit c3a32686d0a50746e152967fd6f4912aec336f66
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 29 07:28:59 2007 +0100

    Add callback for wireless netlink events

diff --git a/include/iface.h b/include/iface.h
index 9f3e5e06..4fc51879 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -88,6 +88,9 @@ struct connman_iface_driver {
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
+
+	void (*rtnl_wireless) (struct connman_iface *iface,
+					void *data, unsigned short len);
 };
 
 extern int connman_iface_register(struct connman_iface_driver *driver);
diff --git a/src/connman.h b/src/connman.h
index b5f0e48f..6f361c86 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -47,6 +47,7 @@ void __connman_plugin_cleanup(void);
 int __connman_iface_init(DBusConnection *conn);
 void __connman_iface_cleanup(void);
 
+struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
 
 #include <connman/rtnl.h>
diff --git a/src/iface.c b/src/iface.c
index 31763b74..72bc142c 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -53,6 +53,20 @@ void connman_iface_unregister(struct connman_iface_driver *driver)
 
 static GSList *interfaces = NULL;
 
+struct connman_iface *__connman_iface_find(int index)
+{
+	GSList *list;
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		if (iface->index == index)
+			return iface;
+	}
+
+	return NULL;
+}
+
 void __connman_iface_list(DBusMessageIter *iter)
 {
 	GSList *list;
diff --git a/src/rtnl.c b/src/rtnl.c
index 1657c9ae..5b245497 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -36,8 +36,23 @@
 
 #include "connman.h"
 
-static void parse_link(struct nlmsghdr *hdr)
+static inline void print_char(struct rtattr *attr, const char *name)
 {
+	printf("  attr %s (len %d) %s", name, RTA_PAYLOAD(attr),
+						(char *) RTA_DATA(attr));
+}
+
+static inline void print_attr(struct rtattr *attr, const char *name)
+{
+	if (name)
+		printf("  attr %s (len %d)", name, RTA_PAYLOAD(attr));
+	else
+		printf("  attr %d (len %d)", attr->rta_type, RTA_PAYLOAD(attr));
+}
+
+static void rtnl_link(struct nlmsghdr *hdr)
+{
+	struct connman_iface *iface;
 	struct ifinfomsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -47,78 +62,79 @@ static void parse_link(struct nlmsghdr *hdr)
 
 	DBG("ifi_index %d ifi_flags %d", msg->ifi_index, msg->ifi_flags);
 
+	iface = __connman_iface_find(msg->ifi_index);
+	if (iface == NULL)
+		return;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return;
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
-		int len = RTA_PAYLOAD(attr);
-
 		switch (attr->rta_type) {
 		case IFLA_ADDRESS:
-			DBG("  rta_type address len %d", len);
+			print_attr(attr, "address");
 			break;
 		case IFLA_BROADCAST:
-			DBG("  rta_type broadcast len %d", len);
+			print_attr(attr, "broadcast");
 			break;
 		case IFLA_IFNAME:
-			DBG("  rta_type ifname %s", (char *) RTA_DATA(attr));
+			print_char(attr, "ifname");
 			break;
 		case IFLA_MTU:
-			DBG("  rta_type mtu len %d", len);
+			print_attr(attr, "mtu");
 			break;
 		case IFLA_LINK:
-			DBG("  rta_type link len %d", len);
+			print_attr(attr, "link");
 			break;
 		case IFLA_QDISC:
-			DBG("  rta_type qdisc len %d", len);
+			print_attr(attr, "qdisc");
 			break;
 		case IFLA_STATS:
-			DBG("  rta_type stats len %d", len);
+			print_attr(attr, "stats");
 			break;
 		case IFLA_COST:
-			DBG("  rta_type cost len %d", len);
+			print_attr(attr, "cost");
 			break;
 		case IFLA_PRIORITY:
-			DBG("  rta_type priority len %d", len);
+			print_attr(attr, "priority");
 			break;
 		case IFLA_MASTER:
-			DBG("  rta_type master len %d", len);
+			print_attr(attr, "master");
 			break;
 		case IFLA_WIRELESS:
-			DBG("  rta_type wireless len %d", len);
-			{
-				unsigned char *data = RTA_DATA(attr);
-				int i;
-				for (i = 0; i < len; i++)
-					printf(" %02x", data[i]);
-				printf("\n");
-			}
+			if (iface->driver->rtnl_wireless)
+				iface->driver->rtnl_wireless(iface,
+					RTA_DATA(attr), RTA_PAYLOAD(attr));
 			break;
 		case IFLA_PROTINFO:
-			DBG("  rta_type protinfo len %d", len);
+			print_attr(attr, "protinfo");
 			break;
 		case IFLA_TXQLEN:
-			DBG("  rta_type txqlen len %d", len);
+			print_attr(attr, "txqlen");
 			break;
 		case IFLA_MAP:
-			DBG("  rta_type map len %d", len);
+			print_attr(attr, "map");
 			break;
 		case IFLA_WEIGHT:
-			DBG("  rta_type widght len %d", len);
+			print_attr(attr, "weight");
 			break;
 		case IFLA_OPERSTATE:
-			DBG("  rta_type operstate len %d", len);
+			print_attr(attr, "operstate");
 			break;
 		case IFLA_LINKMODE:
-			DBG("  rta_type linkmode len %d", len);
+			print_attr(attr, "linkmode");
 			break;
 		default:
-			DBG("  rta_type %d len %d", attr->rta_type, len);
+			print_attr(attr, NULL);
 			break;
 		}
 	}
 }
 
-static void parse_addr(struct nlmsghdr *hdr)
+static void rtnl_addr(struct nlmsghdr *hdr)
 {
+	struct connman_iface *iface;
 	struct ifaddrmsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -128,13 +144,18 @@ static void parse_addr(struct nlmsghdr *hdr)
 
 	DBG("ifa_family %d ifa_index %d", msg->ifa_family, msg->ifa_index);
 
+	iface = __connman_iface_find(msg->ifa_index);
+	if (iface == NULL)
+		return;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return;
+
 	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
-		int len = RTA_PAYLOAD(attr);
-
 		switch (attr->rta_type) {
 		case IFA_ADDRESS:
-			DBG("  rta_type address len %d", len);
+			print_attr(attr, "address");
 			if (msg->ifa_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -142,7 +163,7 @@ static void parse_addr(struct nlmsghdr *hdr)
 			}
 			break;
 		case IFA_LOCAL:
-			DBG("  rta_type local len %d", len);
+			print_attr(attr, "local");
 			if (msg->ifa_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -150,10 +171,10 @@ static void parse_addr(struct nlmsghdr *hdr)
 			}
 			break;
 		case IFA_LABEL:
-			DBG("  rta_type label %s", (char *) RTA_DATA(attr));
+			print_char(attr, "label");
 			break;
 		case IFA_BROADCAST:
-			DBG("  rta_type broadcast len %d", len);
+			print_attr(attr, "broadcast");
 			if (msg->ifa_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -161,22 +182,22 @@ static void parse_addr(struct nlmsghdr *hdr)
 			}
 			break;
 		case IFA_ANYCAST:
-			DBG("  rta_type anycast len %d", len);
+			print_attr(attr, "anycast");
 			break;
 		case IFA_CACHEINFO:
-			DBG("  rta_type cacheinfo len %d", len);
+			print_attr(attr, "cacheinfo");
 			break;
 		case IFA_MULTICAST:
-			DBG("  rta_type multicast len %d", len);
+			print_attr(attr, "multicast");
 			break;
 		default:
-			DBG("  rta_type %d len %d", attr->rta_type, len);
+			print_attr(attr, NULL);
 			break;
 		}
 	}
 }
 
-static void parse_route(struct nlmsghdr *hdr)
+static void rtnl_route(struct nlmsghdr *hdr)
 {
 	struct rtmsg *msg;
 	struct rtattr *attr;
@@ -189,11 +210,9 @@ static void parse_route(struct nlmsghdr *hdr)
 
 	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
-		int len = RTA_PAYLOAD(attr);
-
 		switch (attr->rta_type) {
 		case RTA_DST:
-			DBG("  rta_type dst len %d", len);
+			print_attr(attr, "dst");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -201,7 +220,7 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_SRC:
-			DBG("  rta_type src len %d", len);
+			print_attr(attr, "src");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -209,13 +228,13 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_IIF:
-			DBG("  rta_type iff len %d", len);
+			print_char(attr, "iif");
 			break;
 		case RTA_OIF:
-			DBG("  rta_type oif len %d", len);
+			print_attr(attr, "oif");
 			break;
 		case RTA_GATEWAY:
-			DBG("  rta_type gateway len %d", len);
+			print_attr(attr, "gateway");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -223,10 +242,10 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_PRIORITY:
-			DBG("  rta_type priority len %d", len);
+			print_attr(attr, "priority");
 			break;
 		case RTA_PREFSRC:
-			DBG("  rta_type prefsrc len %d", len);
+			print_attr(attr, "prefsrc");
 			if (msg->rtm_family == AF_INET) {
 				struct in_addr addr;
 				addr = *((struct in_addr *) RTA_DATA(attr));
@@ -234,19 +253,19 @@ static void parse_route(struct nlmsghdr *hdr)
 			}
 			break;
 		case RTA_METRICS:
-			DBG("  rta_type metrics len %d", len);
+			print_attr(attr, "metrics");
 			break;
 		case RTA_TABLE:
-			DBG("  rta_type table len %d", len);
+			print_attr(attr, "table");
 			break;
 		default:
-			DBG("  rta_type %d len %d", attr->rta_type, len);
+			print_attr(attr, NULL);
 			break;
 		}
 	}
 }
 
-static void parse_message(unsigned char *buf, size_t size)
+static void rtnl_message(unsigned char *buf, size_t size)
 {
 	struct nlmsghdr *hdr = (void *) buf;
 
@@ -255,43 +274,37 @@ static void parse_message(unsigned char *buf, size_t size)
 
 	switch (hdr->nlmsg_type) {
 	case NLMSG_DONE:
-		DBG("nlmsg_type done");
+		DBG("done");
 		return;
 	case NLMSG_NOOP:
-		DBG("nlmsg_type noop");
+		DBG("noop");
 		return;
 	case NLMSG_OVERRUN:
-		DBG("nlmsg_type overrun");
+		DBG("overrun");
 		return;
 	case NLMSG_ERROR:
-		DBG("nlmsg_type error");
+		DBG("error");
 		return;
 	case RTM_NEWLINK:
-		DBG("nlmsg_type RTM_NEWLINK");
-		parse_link(hdr);
+		rtnl_link(hdr);
 		break;
 	case RTM_DELLINK:
-		DBG("nlmsg_type RTM_DELLINK");
-		parse_link(hdr);
+		rtnl_link(hdr);
 		break;
 	case RTM_NEWADDR:
-		DBG("nlmsg_type RTM_NEWADDR");
-		parse_addr(hdr);
+		rtnl_addr(hdr);
 		break;
 	case RTM_DELADDR:
-		DBG("nlmsg_type RTM_DELADDR");
-		parse_addr(hdr);
+		rtnl_addr(hdr);
 		break;
 	case RTM_NEWROUTE:
-		DBG("nlmsg_type RTM_NEWROUTE");
-		parse_route(hdr);
+		rtnl_route(hdr);
 		break;
 	case RTM_DELROUTE:
-		DBG("nlmsg_type RTM_DELROUTE");
-		parse_route(hdr);
+		rtnl_route(hdr);
 		break;
 	default:
-		DBG("nlmsg_type %d", hdr->nlmsg_type);
+		DBG("type %d", hdr->nlmsg_type);
 		break;
 	}
 }
@@ -318,7 +331,7 @@ static gboolean netlink_event(GIOChannel *chan,
 		return FALSE;
 	}
 
-	parse_message(buf, len);
+	rtnl_message(buf, len);
 
 	return TRUE;
 }
@@ -338,7 +351,8 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
+	addr.nl_groups = RTMGRP_LINK;
+	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 	addr.nl_pid = getpid();
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {

commit 0c2d46245dd190dc80872bd1627bfd908dfa8c14
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 29 08:02:19 2007 +0100

    Add basic carrier detection

diff --git a/include/iface.h b/include/iface.h
index 4fc51879..930abe79 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -68,6 +68,7 @@ struct connman_iface {
 	char *udi;
 	char *sysfs;
 	int index;
+	int carrier;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
diff --git a/src/rtnl.c b/src/rtnl.c
index 5b245497..726d4917 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -29,6 +29,7 @@
 #include <sys/socket.h>
 #include <arpa/inet.h>
 
+#include <linux/if.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 
@@ -38,16 +39,17 @@
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %d) %s", name, RTA_PAYLOAD(attr),
+	printf("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		printf("  attr %s (len %d)", name, RTA_PAYLOAD(attr));
+		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
 	else
-		printf("  attr %d (len %d)", attr->rta_type, RTA_PAYLOAD(attr));
+		printf("  attr %d (len %d)\n",
+					attr->rta_type, RTA_PAYLOAD(attr));
 }
 
 static void rtnl_link(struct nlmsghdr *hdr)
@@ -60,7 +62,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
 	bytes = IFLA_PAYLOAD(hdr);
 
-	DBG("ifi_index %d ifi_flags %d", msg->ifi_index, msg->ifi_flags);
+	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
 
 	iface = __connman_iface_find(msg->ifi_index);
 	if (iface == NULL)
@@ -69,6 +71,11 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
 		return;
 
+	if (iface->carrier != (msg->ifi_flags & IFF_RUNNING)) {
+		iface->carrier = (msg->ifi_flags & IFF_RUNNING);
+		DBG("carrier %s", iface->carrier ? "on" : "off");
+	}
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
@@ -206,7 +213,7 @@ static void rtnl_route(struct nlmsghdr *hdr)
 	msg = (struct rtmsg *) NLMSG_DATA(hdr);
 	bytes = RTM_PAYLOAD(hdr);
 
-	DBG("rtm_family %d rtm_flags %d", msg->rtm_family, msg->rtm_flags);
+	DBG("rtm_family %d rtm_flags 0x%04x", msg->rtm_family, msg->rtm_flags);
 
 	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {

commit aa844c538bf698eba5799526ca1d246fec9503eb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 30 04:12:04 2007 +0100

    Add carrier detection callbacks and driver data functions

diff --git a/include/iface.h b/include/iface.h
index 930abe79..d4eb2134 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -63,7 +63,6 @@ struct connman_network {
 };
 
 struct connman_iface {
-	struct connman_iface_driver *driver;
 	char *path;
 	char *udi;
 	char *sysfs;
@@ -73,6 +72,9 @@ struct connman_iface {
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
 	struct connman_ipv4 ipv4;
+
+	struct connman_iface_driver *driver;
+	void *driver_data;
 };
 
 struct connman_iface_driver {
@@ -90,6 +92,7 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
+	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
 	void (*rtnl_wireless) (struct connman_iface *iface,
 					void *data, unsigned short len);
 };
@@ -97,9 +100,23 @@ struct connman_iface_driver {
 extern int connman_iface_register(struct connman_iface_driver *driver);
 extern void connman_iface_unregister(struct connman_iface_driver *driver);
 
+static inline void *connman_iface_get_data(struct connman_iface *iface)
+{
+	return iface->driver_data;
+}
+
+static inline void connman_iface_set_data(struct connman_iface *iface,
+								void *data)
+{
+	iface->driver_data = data;
+}
+
 extern int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state);
 
+extern void connman_iface_indicate_carrier(struct connman_iface *iface,
+							int carrier);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/iface.c b/src/iface.c
index 72bc142c..a641bf33 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -108,6 +108,11 @@ int connman_iface_update(struct connman_iface *iface,
 	return 0;
 }
 
+void connman_iface_indicate_carrier(struct connman_iface *iface, int carrier)
+{
+	DBG("iface %p carrier %d", iface, carrier);
+}
+
 static DBusMessage *enable_iface(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
diff --git a/src/rtnl.c b/src/rtnl.c
index 726d4917..33031ffc 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -43,6 +43,12 @@ static inline void print_char(struct rtattr *attr, const char *name)
 						(char *) RTA_DATA(attr));
 }
 
+static inline void print_byte(struct rtattr *attr, const char *name)
+{
+	printf("  attr %s (len %d) 0x%02x\n", name, RTA_PAYLOAD(attr),
+					*((unsigned char *) RTA_DATA(attr)));
+}
+
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
@@ -71,9 +77,12 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
 		return;
 
-	if (iface->carrier != (msg->ifi_flags & IFF_RUNNING)) {
-		iface->carrier = (msg->ifi_flags & IFF_RUNNING);
-		DBG("carrier %s", iface->carrier ? "on" : "off");
+	if (iface->carrier != ((msg->ifi_flags & IFF_RUNNING) != 0)) {
+		iface->carrier = ((msg->ifi_flags & IFF_RUNNING) != 0);
+		if (iface->driver->rtnl_carrier)
+			iface->driver->rtnl_carrier(iface, iface->carrier);
+		else
+			connman_iface_indicate_carrier(iface, iface->carrier);
 	}
 
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
@@ -127,10 +136,10 @@ static void rtnl_link(struct nlmsghdr *hdr)
 			print_attr(attr, "weight");
 			break;
 		case IFLA_OPERSTATE:
-			print_attr(attr, "operstate");
+			print_byte(attr, "operstate");
 			break;
 		case IFLA_LINKMODE:
-			print_attr(attr, "linkmode");
+			print_byte(attr, "linkmode");
 			break;
 		default:
 			print_attr(attr, NULL);

commit cdaa2829f53e2476bab667fd2330cde19bdfb7b4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 05:22:46 2008 +0100

    Add experimental supplicant support

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b83f290a..ec0b7e73 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -24,26 +24,253 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <net/if.h>
+
+#include <glib.h>
 
 #include "supplicant.h"
 
+struct supplicant_task {
+	GPid pid;
+	int ifindex;
+	char *ifname;
+	struct connman_iface *iface;
+	int socket;
+	GIOChannel *channel;
+};
+
+static GSList *tasks = NULL;
+
+static struct supplicant_task *find_task(int ifindex)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct supplicant_task *task = list->data;
+
+		if (task->ifindex == ifindex) 
+			return task;
+	}
+
+	return NULL;
+}
+
+static int exec_cmd(struct supplicant_task *task, char *cmd)
+{
+	write(task->socket, cmd, strlen(cmd));
+
+	return 0;
+}
+
+static gboolean control_event(GIOChannel *chan,
+				GIOCondition cond, gpointer data)
+{
+	struct supplicant_task *task = data;
+	char buf[256];
+	gsize len;
+	GIOError err;
+
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	memset(buf, 0, sizeof(buf));
+
+	err = g_io_channel_read(chan, buf, sizeof(buf), &len);
+	if (err) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	if (buf[0] != '<')
+		return TRUE;
+
+	printf("[SUPPLICANT] %s\n", buf + 3);
+
+	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
+		printf("[SUPPLICANT] connected\n");
+		connman_iface_update(task->iface,
+					CONNMAN_IFACE_STATE_CONNECTED);
+	}
+
+	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
+		printf("[SUPPLICANT] disconnected\n");
+	}
+
+	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-TERMINATING") == TRUE) {
+		printf("[SUPPLICANT] terminating\n");
+	}
+
+	return TRUE;
+}
+
+static int open_control(struct supplicant_task *task)
+{
+	struct sockaddr_un addr;
+	int sk;
+
+	printf("[SUPPLICANT] open control for %s\n", task->ifname);
+
+	sk = socket(PF_UNIX, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_UNIX;
+	snprintf(addr.sun_path, sizeof(addr.sun_path),
+					"%s/%s.cli", STATEDIR, task->ifname);
+	//unlink(addr.sun_path);
+
+	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_UNIX;
+	snprintf(addr.sun_path, sizeof(addr.sun_path),
+					"%s/%s", STATEDIR, task->ifname);
+
+	if (connect(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	task->socket = sk;
+
+	task->channel = g_io_channel_unix_new(sk);
+	g_io_channel_set_close_on_unref(task->channel, TRUE);
+
+	g_io_add_watch(task->channel,
+			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+						control_event, task);
+
+	exec_cmd(task, "ATTACH");
+	exec_cmd(task, "ADD_NETWORK");
+
+	g_io_channel_unref(task->channel);
+
+	return 0;
+}
+
 int __supplicant_start(struct connman_iface *iface)
 {
-	printf("[SUPPLICANT] start for index %d\n", iface->index);
+	struct ifreq ifr;
+	struct supplicant_task *task;
+	char *argv[9];
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	printf("[SUPPLICANT] start %s\n", ifr.ifr_name);
+
+	task = g_try_new0(struct supplicant_task, 1);
+	if (task == NULL)
+		return -ENOMEM;
+
+	task->ifindex = iface->index;
+	task->ifname = strdup(ifr.ifr_name);
+	task->iface = iface;
+
+	if (task->ifname == NULL) {
+		g_free(task);
+		return -ENOMEM;
+	}
+
+	argv[0] = "/sbin/wpa_supplicant";
+	argv[1] = "-qq";
+	argv[2] = "-C";
+	argv[3] = STATEDIR;
+	argv[4] = "-D";
+	argv[5] = "wext";
+	argv[6] = "-i";
+	argv[7] = task->ifname;
+	argv[8] = NULL;
+
+	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+				NULL, NULL, &task->pid, NULL) == FALSE) {
+		printf("Failed to spawn wpa_supplicant\n");
+		return -1;
+	}
+
+	tasks = g_slist_append(tasks, task);
+
+	printf("[SUPPLICANT] executed with pid %d\n", task->pid);
+
+	sleep(1);
+
+	task->socket = -1;
+
+	if (open_control(task) < 0)
+		printf("[SUPPLICANT] control failed\n");
 
 	return 0;
 }
 
 int __supplicant_stop(struct connman_iface *iface)
 {
-	printf("[SUPPLICANT] stop for index %d\n", iface->index);
+	struct supplicant_task *task;
+	char pathname[PATH_MAX];
+
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
+
+	printf("[SUPPLICANT] stop %s\n", task->ifname);
+
+	tasks = g_slist_remove(tasks, task);
+
+	exec_cmd(task, "DETACH");
+
+	//close(task->socket);
+	g_io_channel_unref(task->channel);
+
+	snprintf(pathname, sizeof(pathname),
+					"%s/%s.cli", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	kill(task->pid, SIGTERM);
+
+	free(task->ifname);
+
+	g_free(task);
 
 	return 0;
 }
 
 int __supplicant_connect(struct connman_iface *iface)
 {
-	printf("[SUPPLICANT] connect for index %d\n", iface->index);
+	struct supplicant_task *task;
+
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
+
+	printf("[SUPPLICANT] connect %s\n", task->ifname);
+
+	exec_cmd(task, "DISABLE_NETWORK 0");
 
 	return 0;
 }

commit 921f79feea506fd3e44ea980c6aad04c9aac7955
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 05:34:18 2008 +0100

    Add independent interface name retrieval

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index d32f68a7..8506c633 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -24,10 +24,15 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <signal.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
 #include <arpa/inet.h>
+#include <net/if.h>
 
 #include <glib.h>
 #include <gdbus.h>
@@ -35,12 +40,11 @@
 #include <connman/plugin.h>
 #include <connman/dhcp.h>
 
-#include "net.h"
-
 static const char *busname;
 
 struct dhclient_task {
 	GPid pid;
+	int ifindex;
 	char *ifname;
 	struct connman_iface *iface;
 };
@@ -63,28 +67,46 @@ static struct dhclient_task *find_task(GPid pid)
 
 static int dhclient_request(struct connman_iface *iface)
 {
+	struct ifreq ifr;
 	struct dhclient_task *task;
-	char *ifname, *argv[16], address[128], pidfile[PATH_MAX];
+	char *argv[16], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
+	int sk, err;
 
-	ifname = __net_ifname(iface->index);
-	if (ifname == NULL)
-		return -1;
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
 
 	task = g_try_new0(struct dhclient_task, 1);
 	if (task == NULL)
-		return -1;
+		return -ENOMEM;
 
-	task->ifname = ifname;
+	task->ifindex = iface->index;
+	task->ifname = strdup(ifr.ifr_name);
 	task->iface = iface;
 
-	printf("[DHCP] request for %s\n", ifname);
+	if (task->ifname == NULL) {
+		g_free(task);
+		return -ENOMEM;
+	}
+
+	printf("[DHCP] request %s\n", task->ifname);
 
 	snprintf(address, sizeof(address) - 1, "BUSNAME=%s", busname);
 	snprintf(pidfile, sizeof(pidfile) - 1,
-				"%s/dhclient.%s.pid", STATEDIR, ifname);
+			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
 	snprintf(leases, sizeof(leases) - 1,
-				"%s/dhclient.%s.leases", STATEDIR, ifname);
+			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
 	snprintf(config, sizeof(config) - 1, "%s/dhclient.conf", SCRIPTDIR);
 	snprintf(script, sizeof(script) - 1, "%s/dhclient-script", SCRIPTDIR);
 
@@ -102,7 +124,7 @@ static int dhclient_request(struct connman_iface *iface)
 	argv[11] = config;
 	argv[12] = "-sf";
 	argv[13] = script;
-	argv[14] = ifname;
+	argv[14] = task->ifname;
 	argv[15] = NULL;
 
 	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
@@ -120,15 +142,7 @@ static int dhclient_request(struct connman_iface *iface)
 
 static int dhclient_release(struct connman_iface *iface)
 {
-	char *ifname;
-
-	ifname = __net_ifname(iface->index);
-	if (ifname == NULL)
-		return -1;
-
-	printf("[DHCP] release for %s\n", ifname);
-
-	__net_free(ifname);
+	printf("[DHCP] release\n");
 
 	return 0;
 }
@@ -257,7 +271,7 @@ static void plugin_exit(void)
 				"%s/dhclient.%s.leases", STATEDIR, task->ifname);
 		unlink(pathname);
 
-		__net_free(task->ifname);
+		free(task->ifname);
 
 		g_free(task);
 	}

commit 95dcef8b866aa9effbbde4c1103d960420cf5fff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 07:20:26 2008 +0100

    Add handling of scanning and stations

diff --git a/plugins/80211.c b/plugins/80211.c
index 5d52ed9b..d4c63dcc 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -24,76 +24,236 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
 #include <arpa/inet.h>
+#include <net/if.h>
+#include <net/ethernet.h>
+#include <linux/wireless.h>
+
+#include <glib.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
-#include "net.h"
 #include "supplicant.h"
 
+struct station_data {
+	char *address;
+	char *name;
+	int mode;
+	int qual;
+	int noise;
+	int level;
+
+	unsigned char wpa_ie[40];
+	int wpa_ie_len;
+	unsigned char rsn_ie[40];
+	int rsn_ie_len;
+};
+
+struct iface_data {
+	char ifname[IFNAMSIZ];
+	GSList *stations;
+};
+
+static struct station_data *create_station(struct iface_data *iface,
+							const char *address)
+{
+	struct station_data *station;
+	GSList *list;
+
+	for (list = iface->stations; list; list = list->next) {
+		station = list->data;
+
+		if (g_ascii_strcasecmp(station->address, address) == 0)
+			return station;
+	}
+
+	station = g_try_new0(struct station_data, 1);
+	if (station == NULL)
+		return NULL;
+
+	station->address = g_strdup(address);
+	if (station->address == NULL) {
+		g_free(station);
+		return NULL;
+	}
+
+	iface->stations = g_slist_append(iface->stations, station);
+
+	return station;
+}
+
+static void load_stations(struct iface_data *iface)
+{
+	GKeyFile *keyfile;
+	gchar **groups, **group;
+	gsize length;
+
+	keyfile = g_key_file_new();
+
+	if (g_key_file_load_from_file(keyfile, "/tmp/stations.list",
+				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+		goto done;
+
+	groups = g_key_file_get_groups(keyfile, &length);
+
+	for (group = groups; *group; group++) {
+		struct station_data *station;
+
+		station = create_station(iface, *group);
+		if (station == NULL)
+			continue;
+
+		station->name = g_key_file_get_string(keyfile,
+						*group, "Name", NULL);
+	
+		station->mode = g_key_file_get_integer(keyfile,
+						*group, "Mode", NULL);
+	}
+
+	g_strfreev(groups);
+
+done:
+	g_key_file_free(keyfile);
+
+	printf("[802.11] loaded %d stations\n",
+				g_slist_length(iface->stations));
+}
+
+static void print_stations(struct iface_data *iface)
+{
+	GKeyFile *keyfile;
+	gchar *data;
+	gsize length;
+	GSList *list;
+
+	keyfile = g_key_file_new();
+
+	for (list = iface->stations; list; list = list->next) {
+		struct station_data *station = list->data;
+
+		//printf("Address:%s Mode:%d ESSID:\"%s\" Quality:%d/100\n",
+		//			station->address, station->mode,
+		//				station->name, station->qual);
+
+		g_key_file_set_string(keyfile, station->address,
+						"Name", station->name);
+
+		g_key_file_set_integer(keyfile, station->address,
+						"Mode", station->mode);
+	}
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents("/tmp/stations.list", data, length, NULL);
+
+	g_key_file_free(keyfile);
+}
+
 static int iface_probe(struct connman_iface *iface)
 {
-	printf("[802.11] probe interface index %d\n", iface->index);
+	struct iface_data *data;
+	struct ifreq ifr;
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	printf("[802.11] probe %s\n", ifr.ifr_name);
+
+	data = malloc(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	memset(data, 0, sizeof(*data));
+
+	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
 
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
 				CONNMAN_IFACE_FLAG_IPV4;
 
+	connman_iface_set_data(iface, data);
+
+	load_stations(data);
+
 	return 0;
 }
 
 static void iface_remove(struct connman_iface *iface)
 {
-	printf("[802.11] remove interface index %d\n", iface->index);
+	struct iface_data *data = connman_iface_get_data(iface);
 
-	__net_clear(iface->index);
+	printf("[802.11] remove %s\n", data->ifname);
 
 	__supplicant_stop(iface);
+
+	connman_iface_set_data(iface, NULL);
+
+	free(data);
 }
 
 static int iface_activate(struct connman_iface *iface)
 {
-	printf("[802.11] activate interface index %d\n", iface->index);
+	struct iface_data *data = connman_iface_get_data(iface);
 
-	__supplicant_start(iface);
+	printf("[802.11] activate %s\n", data->ifname);
 
 	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
 
 	return 0;
 }
 
-static int iface_get_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
+static int iface_scan(struct connman_iface *iface)
 {
-	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
-		return -1;
+	struct iface_data *data = connman_iface_get_data(iface);
+	struct iwreq iwr;
+	struct iw_scan_req iws;
+	int sk, err;
 
-	printf("[802.11] get address %s\n", inet_ntoa(ipv4->address));
+	printf("[802.11] scanning %s\n", data->ifname);
 
-	return 0;
-}
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
 
-static int iface_set_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
-{
-	printf("[802.11] set address %s\n", inet_ntoa(ipv4->address));
-	printf("[802.11] set netmask %s\n", inet_ntoa(ipv4->netmask));
-	printf("[802.11] set gateway %s\n", inet_ntoa(ipv4->gateway));
+	memset(&iws, 0, sizeof(iws));
+	iws.scan_type = IW_SCAN_TYPE_PASSIVE;
+	//iws.scan_type = IW_SCAN_TYPE_ACTIVE;
 
-	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
-				&ipv4->gateway, &ipv4->broadcast,
-						&ipv4->nameserver);
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
 
-	return 0;
-}
+	iwr.u.data.pointer = (caddr_t ) &iws;
+	iwr.u.data.length = sizeof(iws);
+	iwr.u.data.flags = IW_SCAN_DEFAULT;
 
-static int iface_scan(struct connman_iface *iface)
-{
-	printf("[802.11] scanning interface index %d\n", iface->index);
+	err = ioctl(sk, SIOCSIWSCAN, &iwr);
 
-	return 0;
+	close(sk);
+
+	if (err < 0)
+		printf("[802.11] scan initiate error %d\n", errno);
+
+	return err;
 }
 
 static int iface_connect(struct connman_iface *iface,
@@ -101,21 +261,227 @@ static int iface_connect(struct connman_iface *iface,
 {
 	printf("[802.11] connect interface index %d\n", iface->index);
 
+	__supplicant_start(iface);
+
 	__supplicant_connect(iface);
 
 	return 0;
 }
 
+static void iface_carrier(struct connman_iface *iface, int carrier)
+{
+	printf("[802.11] carrier %s\n", carrier ? "on" : "off");
+
+	connman_iface_indicate_carrier(iface, carrier);
+}
+
+static void parse_genie(struct station_data *station,
+					unsigned char *data, int len)
+{
+	int offset = 0;
+
+	while (offset <= len - 2) {
+		//int i;
+
+		switch (data[offset]) {
+		case 0xdd:	/* WPA1 (and other) */
+			break;
+		case 0x30:	/* WPA2 (RSN) */
+			break;
+		default:
+			break;
+		}
+
+		//for (i = 0; i < len; i++)
+		//	printf(" %02x", data[i]);
+		//printf("\n");
+
+		offset += data[offset + 1] + 2;
+	}
+}
+
+static void parse_scan_results(struct connman_iface *iface,
+					unsigned char *data, int len)
+{
+	unsigned char *ptr = data;
+	struct station_data *station = NULL;
+	struct ether_addr *eth;
+	char addr[18];
+	int num = 0;
+
+	while (len > IW_EV_LCP_PK_LEN) {
+		struct iw_event *event = (void *) ptr;
+
+		switch (event->cmd) {
+		case SIOCGIWAP:
+			eth = (void *) &event->u.ap_addr.sa_data;
+			sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+			station = create_station(connman_iface_get_data(iface),
+									addr);
+			num++;
+			break;
+		case SIOCGIWESSID:
+			if (station != NULL) {
+				station->name = malloc(event->len - 7);
+				if (station->name != NULL) {
+					memset(station->name, 0, event->len - 7);
+					memcpy(station->name, ptr + 8,
+								event->len - 8);
+				}
+			}
+			break;
+		case SIOCGIWNAME:
+			break;
+		case SIOCGIWMODE:
+			if (station != NULL)
+				station->mode = event->u.mode;
+			break;
+		case SIOCGIWFREQ:
+			break;
+		case SIOCGIWENCODE:
+			if (station != NULL) {
+				if (!(event->u.data.flags & IW_ENCODE_DISABLED)) {
+					/* privacy */
+				}
+			}
+			break;
+		case SIOCGIWRATE:
+			break;
+		case IWEVQUAL:
+			if (station != NULL) {
+				station->qual = event->u.qual.qual;
+				station->noise = event->u.qual.noise;
+				station->level = event->u.qual.level;
+			}
+			break;
+		case IWEVGENIE:
+			if (station != NULL)
+				parse_genie(station, ptr + 8, event->len - 8);
+			break;
+		case IWEVCUSTOM:
+			break;
+		default:
+			printf("[802.11] scan element 0x%04x (len %d)\n",
+						event->cmd, event->len);
+			break;
+		}
+
+		ptr += event->len;
+		len -= event->len;
+	}
+
+	printf("[802.11] found %d networks\n", num);
+}
+
+static void iface_scan_results(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+	struct iwreq iwr;
+	unsigned char *buf;
+	int sk, err, size = 1024;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return;
+
+retrieve:
+	buf = malloc(size);
+	if (buf == NULL) {
+		close(sk);
+		return;
+	}
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = buf;
+	iwr.u.data.length = size;
+	iwr.u.data.flags = 0;
+
+	err = ioctl(sk, SIOCGIWSCAN, &iwr);
+	if (err < 0) {
+		if (errno == E2BIG) {
+			free(buf);
+			size *= 2;
+			goto retrieve;
+		}
+	} else
+		parse_scan_results(iface, iwr.u.data.pointer,
+						iwr.u.data.length);
+
+	close(sk);
+
+	free(buf);
+
+	print_stations(data);
+}
+
+static void iface_wireless(struct connman_iface *iface,
+					void *data, unsigned short len)
+{
+	struct iw_event *event = data;
+	struct iw_point point;
+	struct ether_addr *eth;
+	char addr[18];
+
+	switch (event->cmd) {
+	case SIOCSIWFREQ:
+		printf("[802.11] Set Frequency (flags %d)\n",
+							event->u.freq.flags);
+		break;
+	case SIOCSIWMODE:
+		printf("[802.11] Set Mode (mode %d)\n", event->u.mode);
+		break;
+	case SIOCSIWESSID:
+		memcpy(&point, data + IW_EV_LCP_LEN -
+					IW_EV_POINT_OFF, sizeof(point));
+		point.pointer = data + IW_EV_LCP_LEN +
+					sizeof(point) - IW_EV_POINT_OFF;
+		printf("[802.11] Set ESSID (length %d flags %d) \"%s\"\n",
+					point.length, point.flags,
+						(char *) point.pointer);
+		break;
+	case SIOCSIWENCODE:
+		printf("[802.11] Set Encryption key (flags %d)\n",
+							event->u.data.flags);
+		break;
+
+	case SIOCGIWAP:
+		eth = (void *) &event->u.ap_addr.sa_data;
+		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+		printf("[802.11] New Access Point %s\n", addr);
+		break;
+	case SIOCGIWSCAN:
+		iface_scan_results(iface);
+		break;
+	default:
+		printf("[802.11] Wireless event (cmd 0x%04x len %d)\n",
+						event->cmd, event->len);
+		break;
+	}
+}
+
 static struct connman_iface_driver iface_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
 	.activate	= iface_activate,
-	.get_ipv4	= iface_get_ipv4,
-	.set_ipv4	= iface_set_ipv4,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.rtnl_carrier	= iface_carrier,
+	.rtnl_wireless	= iface_wireless,
 };
 
 static int plugin_init(void)

commit 352f418dd03cd3ac1aac6dc52d9f69209ba98744
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 1 20:43:34 2008 +0100

    Add experimental IPv4 address retrieval over netlink

diff --git a/include/iface.h b/include/iface.h
index d4eb2134..a128e062 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -117,6 +117,11 @@ extern int connman_iface_update(struct connman_iface *iface,
 extern void connman_iface_indicate_carrier(struct connman_iface *iface,
 							int carrier);
 
+extern int connman_iface_get_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4);
+extern int connman_iface_set_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/connman.h b/src/connman.h
index 6f361c86..fdb9fa83 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -55,6 +55,8 @@ void __connman_iface_list(DBusMessageIter *iter);
 int __connman_rtnl_init(void);
 void __connman_rtnl_cleanup(void);
 
+int __connman_rtnl_send(const void *buf, size_t len);
+
 #include <connman/dhcp.h>
 
 int __connman_dhcp_request(struct connman_iface *iface);
diff --git a/src/dhcp.c b/src/dhcp.c
index b4e921e3..2fa3f1fe 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -64,6 +64,9 @@ int connman_dhcp_update(struct connman_iface *iface,
 		if (iface->driver->set_ipv4) {
 			iface->driver->set_ipv4(iface, ipv4);
 			iface->ipv4 = *ipv4;
+		} else {
+			connman_iface_set_ipv4(iface, ipv4);
+			iface->ipv4 = *ipv4;
 		}
 
 		connman_iface_update(iface, CONNMAN_IFACE_STATE_READY);
diff --git a/src/iface.c b/src/iface.c
index a641bf33..be7f261e 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -26,6 +26,9 @@
 #include <string.h>
 #include <arpa/inet.h>
 
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
 #include <glib.h>
 #include <gdbus.h>
 
@@ -101,7 +104,7 @@ int connman_iface_update(struct connman_iface *iface,
 
 	default:
 		break;
-        }
+	}
 
 	iface->state = state;
 
@@ -113,6 +116,43 @@ void connman_iface_indicate_carrier(struct connman_iface *iface, int carrier)
 	DBG("iface %p carrier %d", iface, carrier);
 }
 
+int connman_iface_get_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4)
+{
+	struct {
+		struct nlmsghdr hdr;
+		struct rtgenmsg msg;
+	} req;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return -1;
+
+	DBG("iface %p ipv4 %p", iface, ipv4);
+
+	memset(&req, 0, sizeof(req));
+	req.hdr.nlmsg_len = sizeof(req);
+	req.hdr.nlmsg_type = RTM_GETADDR;
+	req.hdr.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.hdr.nlmsg_pid = 0;
+	req.hdr.nlmsg_seq = 4711;
+	req.msg.rtgen_family = AF_INET;
+
+	__connman_rtnl_send(&req, sizeof(req));
+
+	return 0;
+}
+
+int connman_iface_set_ipv4(struct connman_iface *iface,
+						struct connman_ipv4 *ipv4)
+{
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return -1;
+
+	DBG("iface %p ipv4 %p", iface, ipv4);
+
+	return 0;
+}
+
 static DBusMessage *enable_iface(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -246,9 +286,11 @@ static int probe_device(LibHalContext *ctx,
 
 	interfaces = g_slist_append(interfaces, iface);
 
-	if ((iface->flags & CONNMAN_IFACE_FLAG_IPV4) &&
-						driver->get_ipv4) {
-		driver->get_ipv4(iface, &iface->ipv4);
+	if (iface->flags & CONNMAN_IFACE_FLAG_IPV4) {
+		if (driver->get_ipv4)
+			driver->get_ipv4(iface, &iface->ipv4);
+		else
+			connman_iface_get_ipv4(iface, &iface->ipv4);
 
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
diff --git a/src/main.c b/src/main.c
index 21a0513f..14198cd4 100644
--- a/src/main.c
+++ b/src/main.c
@@ -61,10 +61,10 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
-	__connman_iface_init(conn);
-
 	__connman_rtnl_init();
 
+	__connman_iface_init(conn);
+
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
 	sigaction(SIGINT, &sa, NULL);
@@ -72,10 +72,10 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
-	__connman_rtnl_cleanup();
-
 	__connman_iface_cleanup();
 
+	__connman_rtnl_cleanup();
+
 	__connman_plugin_cleanup();
 
 	__connman_manager_cleanup();
diff --git a/src/rtnl.c b/src/rtnl.c
index 33031ffc..d678aa70 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -37,6 +37,17 @@
 
 #include "connman.h"
 
+static inline void print_inet(struct rtattr *attr, const char *name, int family)
+{
+	if (family == AF_INET) {
+		struct in_addr addr;
+		addr = *((struct in_addr *) RTA_DATA(attr));
+		printf("  attr %s (len %d) %s\n",
+				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
+	} else
+		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
+}
+
 static inline void print_char(struct rtattr *attr, const char *name)
 {
 	printf("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
@@ -171,31 +182,16 @@ static void rtnl_addr(struct nlmsghdr *hdr)
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
 		case IFA_ADDRESS:
-			print_attr(attr, "address");
-			if (msg->ifa_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "address", msg->ifa_family);
 			break;
 		case IFA_LOCAL:
-			print_attr(attr, "local");
-			if (msg->ifa_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "local", msg->ifa_family);
 			break;
 		case IFA_LABEL:
 			print_char(attr, "label");
 			break;
 		case IFA_BROADCAST:
-			print_attr(attr, "broadcast");
-			if (msg->ifa_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "broadcast", msg->ifa_family);
 			break;
 		case IFA_ANYCAST:
 			print_attr(attr, "anycast");
@@ -228,20 +224,10 @@ static void rtnl_route(struct nlmsghdr *hdr)
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
 		case RTA_DST:
-			print_attr(attr, "dst");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "dst", msg->rtm_family);
 			break;
 		case RTA_SRC:
-			print_attr(attr, "src");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "src", msg->rtm_family);
 			break;
 		case RTA_IIF:
 			print_char(attr, "iif");
@@ -250,23 +236,13 @@ static void rtnl_route(struct nlmsghdr *hdr)
 			print_attr(attr, "oif");
 			break;
 		case RTA_GATEWAY:
-			print_attr(attr, "gateway");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "gateway", msg->rtm_family);
 			break;
 		case RTA_PRIORITY:
 			print_attr(attr, "priority");
 			break;
 		case RTA_PREFSRC:
-			print_attr(attr, "prefsrc");
-			if (msg->rtm_family == AF_INET) {
-				struct in_addr addr;
-				addr = *((struct in_addr *) RTA_DATA(attr));
-				DBG("    address %s", inet_ntoa(addr));
-			}
+			print_inet(attr, "prefsrc", msg->rtm_family);
 			break;
 		case RTA_METRICS:
 			print_attr(attr, "metrics");
@@ -281,47 +257,57 @@ static void rtnl_route(struct nlmsghdr *hdr)
 	}
 }
 
-static void rtnl_message(unsigned char *buf, size_t size)
+static void rtnl_message(void *buf, size_t len)
 {
-	struct nlmsghdr *hdr = (void *) buf;
+	DBG("buf %p len %d", buf, len);
 
-	if (!NLMSG_OK(hdr, size))
-		return;
+	while (len > 0) {
+		struct nlmsghdr *hdr = buf;
 
-	switch (hdr->nlmsg_type) {
-	case NLMSG_DONE:
-		DBG("done");
-		return;
-	case NLMSG_NOOP:
-		DBG("noop");
-		return;
-	case NLMSG_OVERRUN:
-		DBG("overrun");
-		return;
-	case NLMSG_ERROR:
-		DBG("error");
-		return;
-	case RTM_NEWLINK:
-		rtnl_link(hdr);
-		break;
-	case RTM_DELLINK:
-		rtnl_link(hdr);
-		break;
-	case RTM_NEWADDR:
-		rtnl_addr(hdr);
-		break;
-	case RTM_DELADDR:
-		rtnl_addr(hdr);
-		break;
-	case RTM_NEWROUTE:
-		rtnl_route(hdr);
-		break;
-	case RTM_DELROUTE:
-		rtnl_route(hdr);
-		break;
-	default:
-		DBG("type %d", hdr->nlmsg_type);
-		break;
+		if (!NLMSG_OK(hdr, len))
+			break;
+
+		DBG("len %d type %d flags 0x%04x",
+			hdr->nlmsg_len, hdr->nlmsg_type, hdr->nlmsg_flags);
+
+		switch (hdr->nlmsg_type) {
+		case NLMSG_DONE:
+			DBG("done");
+			return;
+		case NLMSG_NOOP:
+			DBG("noop");
+			return;
+		case NLMSG_OVERRUN:
+			DBG("overrun");
+			return;
+		case NLMSG_ERROR:
+			DBG("error");
+			return;
+		case RTM_NEWLINK:
+			rtnl_link(hdr);
+			break;
+		case RTM_DELLINK:
+			rtnl_link(hdr);
+			break;
+		case RTM_NEWADDR:
+			rtnl_addr(hdr);
+			break;
+		case RTM_DELADDR:
+			rtnl_addr(hdr);
+			break;
+		case RTM_NEWROUTE:
+			rtnl_route(hdr);
+			break;
+		case RTM_DELROUTE:
+			rtnl_route(hdr);
+			break;
+		default:
+			DBG("type %d", hdr->nlmsg_type);
+			break;
+		}
+
+		len -= hdr->nlmsg_len;
+		buf += hdr->nlmsg_len;
 	}
 }
 
@@ -354,6 +340,22 @@ static gboolean netlink_event(GIOChannel *chan,
 
 static GIOChannel *channel = NULL;
 
+int __connman_rtnl_send(const void *buf, size_t len)
+{
+	struct sockaddr_nl addr;
+	int sk;
+
+	DBG("buf %p len %d", buf, len);
+
+	sk = g_io_channel_unix_get_fd(channel);
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+
+	return sendto(sk, buf, len, 0,
+			(struct sockaddr *) &addr, sizeof(addr));
+}
+
 int __connman_rtnl_init(void)
 {
 	struct sockaddr_nl addr;

commit f24401eee00df645f2f676381c947487b4ddf6ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 2 18:30:19 2008 +0100

    Add more netlink debugging

diff --git a/src/rtnl.c b/src/rtnl.c
index d678aa70..a8131d08 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -263,12 +263,14 @@ static void rtnl_message(void *buf, size_t len)
 
 	while (len > 0) {
 		struct nlmsghdr *hdr = buf;
+		struct nlmsgerr *err;
 
 		if (!NLMSG_OK(hdr, len))
 			break;
 
-		DBG("len %d type %d flags 0x%04x",
-			hdr->nlmsg_len, hdr->nlmsg_type, hdr->nlmsg_flags);
+		DBG("len %d type %d flags 0x%04x seq %d",
+					hdr->nlmsg_len, hdr->nlmsg_type,
+					hdr->nlmsg_flags, hdr->nlmsg_seq);
 
 		switch (hdr->nlmsg_type) {
 		case NLMSG_DONE:
@@ -281,7 +283,9 @@ static void rtnl_message(void *buf, size_t len)
 			DBG("overrun");
 			return;
 		case NLMSG_ERROR:
-			DBG("error");
+			err = NLMSG_DATA(hdr);
+			DBG("error %d (%s)", -err->error,
+						strerror(-err->error));
 			return;
 		case RTM_NEWLINK:
 			rtnl_link(hdr);
@@ -371,7 +375,6 @@ int __connman_rtnl_init(void)
 	addr.nl_family = AF_NETLINK;
 	addr.nl_groups = RTMGRP_LINK;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
-	addr.nl_pid = getpid();
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 		close(sk);

commit 5057d6849ddaead7b1f5f614d58670122f2fde6f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:32:12 2008 +0100

    Fix netlink debugging and enable IPv4 address notifications

diff --git a/src/rtnl.c b/src/rtnl.c
index a8131d08..fd61d0dc 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -273,36 +273,42 @@ static void rtnl_message(void *buf, size_t len)
 					hdr->nlmsg_flags, hdr->nlmsg_seq);
 
 		switch (hdr->nlmsg_type) {
-		case NLMSG_DONE:
-			DBG("done");
-			return;
 		case NLMSG_NOOP:
-			DBG("noop");
-			return;
-		case NLMSG_OVERRUN:
-			DBG("overrun");
+			DBG("NOOP");
 			return;
 		case NLMSG_ERROR:
 			err = NLMSG_DATA(hdr);
-			DBG("error %d (%s)", -err->error,
+			DBG("ERROR %d (%s)", -err->error,
 						strerror(-err->error));
 			return;
+		case NLMSG_DONE:
+			DBG("DONE");
+			return;
+		case NLMSG_OVERRUN:
+			DBG("OVERRUN");
+			return;
 		case RTM_NEWLINK:
+			DBG("NEWLINK");
 			rtnl_link(hdr);
 			break;
 		case RTM_DELLINK:
+			DBG("DELLINK");
 			rtnl_link(hdr);
 			break;
 		case RTM_NEWADDR:
+			DBG("NEWADDR");
 			rtnl_addr(hdr);
 			break;
 		case RTM_DELADDR:
+			DBG("DELADDR");
 			rtnl_addr(hdr);
 			break;
 		case RTM_NEWROUTE:
+			DBG("NEWROUTE");
 			rtnl_route(hdr);
 			break;
 		case RTM_DELROUTE:
+			DBG("DELROUTE");
 			rtnl_route(hdr);
 			break;
 		default:
@@ -373,7 +379,7 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK;
+	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {

commit 3b0fee6fcf0de532b1b115341e53ac3ec5c5768a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:35:18 2008 +0100

    Add generic setting of IPv4 addresses and the default route

diff --git a/include/iface.h b/include/iface.h
index a128e062..d6b67932 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -121,6 +121,7 @@ extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
 extern int connman_iface_set_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
+extern int connman_iface_clear_ipv4(struct connman_iface *iface);
 
 #ifdef __cplusplus
 }
diff --git a/src/iface.c b/src/iface.c
index be7f261e..2446d125 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -23,8 +23,16 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
 #include <arpa/inet.h>
+#include <net/if.h>
+#include <net/route.h>
 
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
@@ -130,9 +138,9 @@ int connman_iface_get_ipv4(struct connman_iface *iface,
 	DBG("iface %p ipv4 %p", iface, ipv4);
 
 	memset(&req, 0, sizeof(req));
-	req.hdr.nlmsg_len = sizeof(req);
+	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
 	req.hdr.nlmsg_type = RTM_GETADDR;
-	req.hdr.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
 	req.hdr.nlmsg_pid = 0;
 	req.hdr.nlmsg_seq = 4711;
 	req.msg.rtgen_family = AF_INET;
@@ -145,11 +153,123 @@ int connman_iface_get_ipv4(struct connman_iface *iface,
 int connman_iface_set_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4)
 {
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
 		return -1;
 
 	DBG("iface %p ipv4 %p", iface, ipv4);
 
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->address;
+
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+
+	if (err < 0)
+		DBG("address setting failed (%s)", strerror(errno));
+
+	addr = (struct sockaddr_in *) &ifr.ifr_netmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->netmask;
+
+	err = ioctl(sk, SIOCSIFNETMASK, &ifr);
+
+	if (err < 0)
+		DBG("netmask setting failed (%s)", strerror(errno));
+
+	addr = (struct sockaddr_in *) &ifr.ifr_broadaddr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->broadcast;
+
+	err = ioctl(sk, SIOCSIFBRDADDR, &ifr);
+
+	if (err < 0)
+		DBG("broadcast setting failed (%s)", strerror(errno));
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->gateway;
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCADDRT, &rt);
+
+	close(sk);
+
+	if (err < 0) {
+		DBG("default route failed (%s)", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+int connman_iface_clear_ipv4(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return -1;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	//err = ioctl(sk, SIOCDIFADDR, &ifr);
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0 && errno != EADDRNOTAVAIL) {
+		DBG("address removal failed (%s)", strerror(errno));
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -221,6 +341,8 @@ static void device_free(void *data)
 
 	DBG("iface %p", iface);
 
+	connman_iface_clear_ipv4(iface);
+
 	if (iface->driver && iface->driver->remove)
 		iface->driver->remove(iface);
 

commit 0e3c123c9fc860de733b4df6647efe70c4780add
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:37:29 2008 +0100

    Add experimental method for scanning activation

diff --git a/src/iface.c b/src/iface.c
index 2446d125..5fc4eaf5 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -98,9 +98,6 @@ int connman_iface_update(struct connman_iface *iface,
 	switch (state) {
 	case CONNMAN_IFACE_STATE_ACTIVE:
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
-			if (iface->driver->scan)
-				iface->driver->scan(iface);
-
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
 		}
@@ -294,8 +291,30 @@ static DBusMessage *enable_iface(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *scan_iface(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->scan)
+		driver->scan(iface);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static GDBusMethodTable iface_methods[] = {
 	{ "Enable", "", "", enable_iface },
+	{ "Scan",   "", "", scan_iface   },
 	{ },
 };
 

commit 7a580c5a50681601db10786f327899b309879009
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:48:25 2008 +0100

    Add support for setting the nameserver using resolvconf

diff --git a/src/iface.c b/src/iface.c
index 5fc4eaf5..53031f62 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -26,6 +26,7 @@
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
@@ -153,6 +154,7 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 	struct ifreq ifr;
 	struct rtentry rt;
 	struct sockaddr_in *addr;
+	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -225,6 +227,13 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 		return -1;
 	}
 
+	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
+				inet_ntoa(ipv4->nameserver), ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	system(cmd);
+
 	return 0;
 }
 
@@ -232,6 +241,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct sockaddr_in *addr;
+	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -267,6 +277,12 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 		return -1;
 	}
 
+	sprintf(cmd, "resolvconf -d %s", ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	system(cmd);
+
 	return 0;
 }
 

commit 047005ba15de74a21a39240d85ba37927db9cdb0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 07:51:19 2008 +0100

    Remove network interface helpers

diff --git a/plugins/80203.c b/plugins/80203.c
index 785c441e..65a22aa1 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -29,8 +29,6 @@
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
-#include "net.h"
-
 static int iface_probe(struct connman_iface *iface)
 {
 	printf("[802.03] probe interface index %d\n", iface->index);
@@ -47,33 +45,6 @@ static int iface_probe(struct connman_iface *iface)
 static void iface_remove(struct connman_iface *iface)
 {
 	printf("[802.03] remove interface index %d\n", iface->index);
-
-	__net_clear(iface->index);
-}
-
-static int iface_get_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
-{
-	if (__net_ifaddr(iface->index, &ipv4->address) < 0)
-		return -1;
-
-	printf("[802.03] get address %s\n", inet_ntoa(ipv4->address));
-
-	return 0;
-}
-
-static int iface_set_ipv4(struct connman_iface *iface,
-					struct connman_ipv4 *ipv4)
-{
-	printf("[802.03] set address %s\n", inet_ntoa(ipv4->address));
-	printf("[802.03] set netmask %s\n", inet_ntoa(ipv4->netmask));
-	printf("[802.03] set gateway %s\n", inet_ntoa(ipv4->gateway));
-
-	__net_set(iface->index, &ipv4->address, &ipv4->netmask,
-				&ipv4->gateway, &ipv4->broadcast,
-						&ipv4->nameserver);
-
-	return 0;
 }
 
 static struct connman_iface_driver iface_driver = {
@@ -81,8 +52,6 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80203",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
-	.get_ipv4	= iface_get_ipv4,
-	.set_ipv4	= iface_set_ipv4,
 };
 
 static int plugin_init(void)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 24e4433f..2f789ec3 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -4,12 +4,11 @@ plugindir = $(libdir)/connman/plugins
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
 			libconnman-dhclient.la
 
-libconnman_80203_la_SOURCES = 80203.c net.h net.c
+libconnman_80203_la_SOURCES = 80203.c
 
-libconnman_80211_la_SOURCES = 80211.c net.h net.c \
-				supplicant.h supplicant.c
+libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
-libconnman_dhclient_la_SOURCES = dhclient.c net.h net.c
+libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
 
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
diff --git a/plugins/net.c b/plugins/net.c
deleted file mode 100644
index 18927eed..00000000
--- a/plugins/net.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <net/if.h>
-
-#include "net.h"
-
-int __net_ifaddr(int ifindex, struct in_addr *addr)
-{
-	struct ifreq ifr;
-	int sk;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -errno;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = ifindex;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		close(sk);
-		return -errno;
-	}
-
-	if (ioctl(sk, SIOCGIFADDR, &ifr) < 0) {
-		close(sk);
-		return -errno;
-	}
-
-	close(sk);
-
-	*addr = ((struct sockaddr_in *) (&ifr.ifr_addr))->sin_addr;
-
-	return 0;
-}
-
-char *__net_ifname(int ifindex)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return NULL;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = ifindex;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return NULL;
-
-	return strdup(ifr.ifr_name);
-}
-
-void __net_free(void *ptr)
-{
-	if (ptr)
-		free(ptr);
-}
-
-int __net_clear(int ifindex)
-{
-	char *ifname, cmd[128];
-
-	ifname = __net_ifname(ifindex);
-	if (ifname == NULL)
-		return -1;
-
-	sprintf(cmd, "resolvconf -d %s", ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	sprintf(cmd, "ip addr flush dev %s", ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	__net_free(ifname);
-
-	return 0;
-}
-
-int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
-				struct in_addr *route, struct in_addr *bcast,
-						struct in_addr *namesrv)
-{
-	char *ifname, cmd[128], msk[32], brd[32];
-
-	ifname = __net_ifname(ifindex);
-	if (ifname == NULL)
-		return -1;
-
-	__net_clear(ifindex);
-
-	sprintf(msk, "%s", "24");
-	sprintf(brd, "%s", inet_ntoa(*bcast));
-	sprintf(cmd, "ip addr add %s/%s brd %s dev %s",
-				inet_ntoa(*addr), msk, brd, ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	sprintf(cmd, "ip route add default via %s dev %s",
-					inet_ntoa(*route), ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
-					inet_ntoa(*namesrv), ifname);
-	printf("[NET] %s\n", cmd);
-	system(cmd);
-
-	__net_free(ifname);
-
-	return 0;
-}
diff --git a/plugins/net.h b/plugins/net.h
deleted file mode 100644
index 83de416e..00000000
--- a/plugins/net.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#include <arpa/inet.h>
-
-int __net_ifaddr(int ifindex, struct in_addr *addr);
-char *__net_ifname(int ifindex);
-void __net_free(void *ptr);
-
-int __net_clear(int ifindex);
-int __net_set(int ifindex, struct in_addr *addr, struct in_addr *mask,
-				struct in_addr *route, struct in_addr *bcast,
-						struct in_addr *namesrv);

commit 8af2802c979ac2d63df1885c247a1cb387cab3bd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 09:11:41 2008 +0100

    Add callbacks for setting network name and passphrase

diff --git a/include/iface.h b/include/iface.h
index d6b67932..cc79a4d5 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -92,6 +92,11 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
+	void (*set_network) (struct connman_iface *iface,
+						const char *network);
+	void (*set_passphrase) (struct connman_iface *iface,
+						const char *passphrase);
+
 	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
 	void (*rtnl_wireless) (struct connman_iface *iface,
 					void *data, unsigned short len);
diff --git a/src/iface.c b/src/iface.c
index 53031f62..82fbdda9 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -328,9 +328,61 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *set_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+	const char *network;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->set_network)
+		driver->set_network(iface, network);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_passphrase(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	struct connman_iface_driver *driver = iface->driver;
+	DBusMessage *reply;
+	const char *passphrase;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &passphrase,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	if (driver->set_passphrase)
+		driver->set_passphrase(iface, passphrase);
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static GDBusMethodTable iface_methods[] = {
-	{ "Enable", "", "", enable_iface },
-	{ "Scan",   "", "", scan_iface   },
+	{ "Enable",        "",  "", enable_iface   },
+	{ "Scan",          "",  "", scan_iface     },
+	{ "SetNetwork",    "s", "", set_network    },
+	{ "SetPassphrase", "s", "", set_passphrase },
 	{ },
 };
 

commit a53b633f9df38ad25b06b79e94e8fe21d1543c1b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 09:28:21 2008 +0100

    Add methods for setting 802.11 network name and passphrase

diff --git a/plugins/80211.c b/plugins/80211.c
index d4c63dcc..5a74de5a 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -59,6 +59,9 @@ struct station_data {
 struct iface_data {
 	char ifname[IFNAMSIZ];
 	GSList *stations;
+
+	gchar *network;
+	gchar *passphrase;
 };
 
 static struct station_data *create_station(struct iface_data *iface,
@@ -208,6 +211,9 @@ static void iface_remove(struct connman_iface *iface)
 
 	connman_iface_set_data(iface, NULL);
 
+	g_free(data->network);
+	g_free(data->passphrase);
+
 	free(data);
 }
 
@@ -259,15 +265,41 @@ static int iface_scan(struct connman_iface *iface)
 static int iface_connect(struct connman_iface *iface,
 					struct connman_network *network)
 {
-	printf("[802.11] connect interface index %d\n", iface->index);
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] connect %s\n", data->ifname);
 
 	__supplicant_start(iface);
 
-	__supplicant_connect(iface);
+	__supplicant_connect(iface, data->network, data->passphrase);
 
 	return 0;
 }
 
+static void iface_set_network(struct connman_iface *iface,
+						const char *network)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] set network %s\n", data->ifname);
+
+	g_free(data->network);
+
+	data->network = g_strdup(network);
+}
+
+static void iface_set_passphrase(struct connman_iface *iface,
+						const char *passphrase)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] set passphrase %s\n", data->ifname);
+
+	g_free(data->passphrase);
+
+	data->passphrase = g_strdup(passphrase);
+}
+
 static void iface_carrier(struct connman_iface *iface, int carrier)
 {
 	printf("[802.11] carrier %s\n", carrier ? "on" : "off");
@@ -480,6 +512,8 @@ static struct connman_iface_driver iface_driver = {
 	.activate	= iface_activate,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.set_network	= iface_set_network,
+	.set_passphrase	= iface_set_passphrase,
 	.rtnl_carrier	= iface_carrier,
 	.rtnl_wireless	= iface_wireless,
 };
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index ec0b7e73..1eb729bc 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -260,9 +260,11 @@ int __supplicant_stop(struct connman_iface *iface)
 	return 0;
 }
 
-int __supplicant_connect(struct connman_iface *iface)
+int __supplicant_connect(struct connman_iface *iface,
+				const char *network, const char *passphrase)
 {
 	struct supplicant_task *task;
+	char cmd[128];
 
 	task = find_task(iface->index);
 	if (task == NULL)
@@ -272,5 +274,21 @@ int __supplicant_connect(struct connman_iface *iface)
 
 	exec_cmd(task, "DISABLE_NETWORK 0");
 
+	sprintf(cmd, "SET_NETWORK 0 ssid \"%s\"", network);
+	exec_cmd(task, cmd);
+
+	if (passphrase && strlen(passphrase) > 0) {
+		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
+
+		sprintf(cmd, "SET_NETWORK 0 psk \"%s\"", passphrase);
+		exec_cmd(task, cmd);
+	} else {
+		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
+	}
+
+	exec_cmd(task, "ENABLE_NETWORK 0");
+
 	return 0;
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index ed753a88..9e5ebc67 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -24,4 +24,5 @@
 int __supplicant_start(struct connman_iface *iface);
 int __supplicant_stop(struct connman_iface *iface);
 
-int __supplicant_connect(struct connman_iface *iface);
+int __supplicant_connect(struct connman_iface *iface,
+				const char *network, const char *passphrase);

commit 986cc2bccd53c801a9c15a0e1367dd1d63f2ca30
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 3 22:56:58 2008 +0100

    Add preparation for Network Manager compatibility

diff --git a/src/connman.h b/src/connman.h
index fdb9fa83..ec7a1f3e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -28,13 +28,18 @@
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
-#define CONNMAN_MANAGER_PATH "/"
+#define CONNMAN_MANAGER_PATH       "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 
 #define CONNMAN_IFACE_BASEPATH  "/interface"
 #define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
 
-int __connman_manager_init(DBusConnection *conn);
+#define NM_SERVICE    "org.freedesktop.NetworkManager"
+#define NM_PATH       "/org/freedesktop/NetworkManager"
+#define NM_INTERFACE  NM_SERVICE
+#define NM_DEVICE     NM_SERVICE ".Devices"
+
+int __connman_manager_init(DBusConnection *conn, int compat);
 void __connman_manager_cleanup(void);
 
 #include <connman/plugin.h>
diff --git a/src/main.c b/src/main.c
index 14198cd4..1f30cb48 100644
--- a/src/main.c
+++ b/src/main.c
@@ -27,7 +27,9 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
+#include <syslog.h>
 #include <signal.h>
+#include <getopt.h>
 #include <sys/stat.h>
 
 #include <gdbus.h>
@@ -41,10 +43,63 @@ static void sig_term(int sig)
 	g_main_loop_quit(main_loop);
 }
 
+static void usage(void)
+{
+	printf("Connection Manager version %s\n\n", VERSION);
+
+	printf("Usage:\n"
+		"\tconnmand [options]\n"
+		"\n");
+
+	printf("Options:\n"
+		"\t-c, --compat         Enable Network Manager compatibility\n"
+		"\t-n, --nodaemon       Don't fork daemon to background\n"
+		"\t-h, --help           Display help\n"
+		"\n");
+}
+
+static struct option options[] = {
+	{ "nodaemon", 0, 0, 'n' },
+	{ "compat",   0, 0, 'c' },
+	{ "help",     0, 0, 'h' },
+	{ }
+};
+
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
 	struct sigaction sa;
+	int log_option = LOG_NDELAY | LOG_PID;
+	int opt, detach = 1, compat = 0;
+
+	while ((opt = getopt_long(argc, argv, "+nch", options, NULL)) != EOF) {
+		switch(opt) {
+		case 'n':
+			detach = 0;
+			break;
+		case 'c':
+			compat = 1;
+			break;
+		case 'h':
+		default:
+			usage();
+			exit(0);
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+	optind = 0;
+
+	if (detach) {
+		if (daemon(0, 0)) {
+			perror("Can't start daemon");
+			exit(1);
+		}
+	} else
+		log_option |= LOG_PERROR;
+
+	openlog("connmand", log_option, LOG_DAEMON);
 
 	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
@@ -57,7 +112,12 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 
-	__connman_manager_init(conn);
+	if (compat) {
+		if (g_dbus_request_name(conn, NM_SERVICE) == FALSE)
+			compat = 0;
+	}
+
+	__connman_manager_init(conn, compat);
 
 	__connman_plugin_init();
 
@@ -86,5 +146,7 @@ int main(int argc, char *argv[])
 
 	rmdir(STATEDIR);
 
+	closelog();
+
 	return 0;
 }
diff --git a/src/manager.c b/src/manager.c
index 1afecc88..d8c6a5a7 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -62,9 +62,139 @@ static GDBusSignalTable manager_signals[] = {
 	{ },
 };
 
+static DBusMessage *activate_device(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	DBG("device %s", path);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_wireless(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	dbus_bool_t enabled;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_BOOLEAN, &enabled,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *get_wireless(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	dbus_bool_t enabled = TRUE;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &enabled,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *do_sleep(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *do_wake(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+enum {
+	NM_STATE_UNKNOWN = 0,
+	NM_STATE_ASLEEP,
+	NM_STATE_CONNECTING,
+	NM_STATE_CONNECTED,
+	NM_STATE_DISCONNECTED
+};
+
+static DBusMessage *get_state(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	dbus_uint32_t state = NM_STATE_DISCONNECTED;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_UINT32, &state,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static GDBusMethodTable nm_methods[] = {
+	{ "getDevices",            "",  "ao", list_interfaces },
+	{ "setActiveDevice",       "o", "",   activate_device },
+	{ "setWirelessEnabled",    "b", "",   set_wireless    },
+	{ "getWirelessEnabled",    "",  "b",  get_wireless    },
+	{ "sleep",                 "",  "",   do_sleep        },
+	{ "wake",                  "",  "",   do_wake         },
+	{ "state",                 "",  "u",  get_state       },
+	{ },
+};
+
 static DBusConnection *connection = NULL;
+static int nm_compat = 0;
 
-int __connman_manager_init(DBusConnection *conn)
+int __connman_manager_init(DBusConnection *conn, int compat)
 {
 	DBG("conn %p", conn);
 
@@ -79,6 +209,15 @@ int __connman_manager_init(DBusConnection *conn)
 						manager_methods,
 						manager_signals, NULL);
 
+	if (compat) {
+		g_dbus_register_object(connection, NM_PATH, NULL, NULL);
+
+		g_dbus_register_interface(connection, NM_PATH, NM_INTERFACE,
+						nm_methods, NULL, NULL);
+
+		nm_compat = 1;
+	}
+
 	return 0;
 }
 
@@ -86,6 +225,12 @@ void __connman_manager_cleanup(void)
 {
 	DBG("conn %p", connection);
 
+	if (nm_compat) {
+		g_dbus_unregister_interface(connection, NM_PATH, NM_INTERFACE);
+
+		g_dbus_unregister_object(connection, NM_PATH);
+	}
+
 	g_dbus_unregister_interface(connection, CONNMAN_MANAGER_PATH,
 						CONNMAN_MANAGER_INTERFACE);
 

commit e0979df838ec942c23d8a5bad23a1e7f87d666ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 4 02:37:34 2008 +0100

    Add interface properties for device details

diff --git a/include/iface.h b/include/iface.h
index cc79a4d5..a916cd16 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -75,6 +75,12 @@ struct connman_iface {
 
 	struct connman_iface_driver *driver;
 	void *driver_data;
+
+	struct {
+		char *driver;
+		char *vendor;
+		char *product;
+	} device;
 };
 
 struct connman_iface_driver {
@@ -92,6 +98,8 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
+	const char * (*get_address) (struct connman_iface *iface);
+
 	void (*set_network) (struct connman_iface *iface,
 						const char *network);
 	void (*set_passphrase) (struct connman_iface *iface,
diff --git a/plugins/80211.c b/plugins/80211.c
index 5a74de5a..5aebe964 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -58,6 +58,7 @@ struct station_data {
 
 struct iface_data {
 	char ifname[IFNAMSIZ];
+	char ifaddr[18];
 	GSList *stations;
 
 	gchar *network;
@@ -163,6 +164,7 @@ static int iface_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
 	struct ifreq ifr;
+	struct ether_addr *eth;
 	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
@@ -174,6 +176,9 @@ static int iface_probe(struct connman_iface *iface)
 
 	err = ioctl(sk, SIOCGIFNAME, &ifr);
 
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
 	close(sk);
 
 	if (err < 0)
@@ -189,6 +194,15 @@ static int iface_probe(struct connman_iface *iface)
 
 	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
 
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	sprintf(data->ifaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
@@ -276,6 +290,15 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
+static const char *iface_get_address(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] get address %s\n", data->ifname);
+
+	return data->ifaddr;
+}
+
 static void iface_set_network(struct connman_iface *iface,
 						const char *network)
 {
@@ -512,6 +535,7 @@ static struct connman_iface_driver iface_driver = {
 	.activate	= iface_activate,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.get_address	= iface_get_address,
 	.set_network	= iface_set_network,
 	.set_passphrase	= iface_set_passphrase,
 	.rtnl_carrier	= iface_carrier,
diff --git a/src/iface.c b/src/iface.c
index 82fbdda9..b08fdb8f 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -417,8 +417,80 @@ static dbus_bool_t get_type(DBusConnection *conn,
 	return TRUE;
 }
 
+static dbus_bool_t get_address(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+	const char *address;
+
+	DBG("iface %p", iface);
+
+	if (!iface->driver->get_address)
+		return FALSE;
+
+	address = iface->driver->get_address(iface);
+	if (address == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &address);
+
+	return TRUE;
+}
+
+static dbus_bool_t get_driver(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->device.driver == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+						&iface->device.driver);
+
+	return TRUE;
+}
+
+static dbus_bool_t get_vendor(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->device.vendor == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+						&iface->device.vendor);
+
+	return TRUE;
+}
+
+static dbus_bool_t get_product(DBusConnection *conn,
+					DBusMessageIter *iter, void *data)
+{
+	struct connman_iface *iface = data;
+
+	DBG("iface %p", iface);
+
+	if (iface->device.product == NULL)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+						&iface->device.product);
+
+	return TRUE;
+}
+
 static GDBusPropertyTable iface_properties[] = {
-	{ "Type", "s", get_type },
+	{ "Type",    "s", get_type    },
+	{ "Address", "s", get_address },
+	{ "Driver",  "s", get_driver  },
+	{ "Vendor",  "s", get_vendor  },
+	{ "Product", "s", get_product },
 	{ },
 };
 
@@ -436,9 +508,44 @@ static void device_free(void *data)
 	g_free(iface->path);
 	g_free(iface->udi);
 	g_free(iface->sysfs);
+	g_free(iface->device.driver);
+	g_free(iface->device.vendor);
+	g_free(iface->device.product);
 	g_free(iface);
 }
 
+static void detect_device_info(LibHalContext *ctx, struct connman_iface *iface)
+{
+	char *parent, *subsys, *value;
+
+	parent = libhal_device_get_property_string(ctx, iface->udi,
+						"info.parent", NULL);
+
+	subsys = libhal_device_get_property_string(ctx, iface->udi,
+						"linux.subsystem", NULL);
+
+	value = libhal_device_get_property_string(ctx, iface->udi,
+						"info.linux.driver", NULL);
+	if (value == NULL) {
+		value = libhal_device_get_property_string(ctx, parent,
+						"info.linux.driver", NULL);
+		if (value != NULL)
+			iface->device.driver = g_strdup(value);
+	}
+
+	if (strcmp(subsys, "net") == 0) {
+		value = libhal_device_get_property_string(ctx, parent,
+							"info.vendor", NULL);
+		if (value != NULL)
+			iface->device.vendor = g_strdup(value);
+
+		value = libhal_device_get_property_string(ctx, parent,
+							"info.product", NULL);
+		if (value != NULL)
+			iface->device.product = g_strdup(value);
+	}
+}
+
 static int probe_device(LibHalContext *ctx,
 			struct connman_iface_driver *driver, const char *udi)
 {
@@ -469,6 +576,8 @@ static int probe_device(LibHalContext *ctx,
 	if (sysfs != NULL)
 		iface->sysfs = g_strdup(sysfs);
 
+	detect_device_info(ctx, iface);
+
 	iface->index = -1;
 
 	if (g_str_has_prefix(driver->capability, "net") == TRUE)

commit 77b9f324261f3482b3c0bc89c1d5c734a624a590
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:30:16 2008 +0100

    Add method and signal for master state

diff --git a/src/manager.c b/src/manager.c
index d8c6a5a7..b11d805e 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,6 +27,8 @@
 
 #include "connman.h"
 
+static const char *master_state = "unknown";
+
 static DBusMessage *list_interfaces(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -51,14 +53,33 @@ static DBusMessage *list_interfaces(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *get_state(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &master_state,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static GDBusMethodTable manager_methods[] = {
 	{ "ListInterfaces", "", "ao", list_interfaces },
+	{ "GetState",       "", "s",  get_state       },
 	{ },
 };
 
 static GDBusSignalTable manager_signals[] = {
 	{ "InterfaceAdded",   "o" },
 	{ "InterfaceRemoved", "o" },
+	{ "StateChanged",     "s" },
 	{ },
 };
 
@@ -162,7 +183,7 @@ enum {
 	NM_STATE_DISCONNECTED
 };
 
-static DBusMessage *get_state(DBusConnection *conn,
+static DBusMessage *do_state(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
@@ -187,7 +208,7 @@ static GDBusMethodTable nm_methods[] = {
 	{ "getWirelessEnabled",    "",  "b",  get_wireless    },
 	{ "sleep",                 "",  "",   do_sleep        },
 	{ "wake",                  "",  "",   do_wake         },
-	{ "state",                 "",  "u",  get_state       },
+	{ "state",                 "",  "u",  do_state        },
 	{ },
 };
 

commit 82907b261ddc17ea7c4b838d927a6c9c9b00e6a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:34:25 2008 +0100

    Add creation of the storage directory

diff --git a/src/Makefile.am b/src/Makefile.am
index b78d4b38..66d2f1c8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,6 +11,8 @@ connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
 statedir = $(localstatedir)/run/connman
 
+storagedir = $(localstatedir)/lib/connman
+
 if MAINTAINER_MODE
 plugindir = $(abs_top_srcdir)/plugins
 else
@@ -18,7 +20,9 @@ plugindir = $(libdir)/connman/plugins
 endif
 
 AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
-		-DSTATEDIR=\""$(statedir)"\" -DPLUGINDIR=\""$(plugindir)"\"
+			-DSTATEDIR=\""$(statedir)"\" \
+			-DSTORAGEDIR=\""$(storagedir)\"" \
+			-DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/src/main.c b/src/main.c
index 1f30cb48..8de7fbed 100644
--- a/src/main.c
+++ b/src/main.c
@@ -104,6 +104,9 @@ int main(int argc, char *argv[])
 	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
 
+	mkdir(STORAGEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
+			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+
 	main_loop = g_main_loop_new(NULL, FALSE);
 
 	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
@@ -144,6 +147,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_unref(main_loop);
 
+	rmdir(STORAGEDIR);
+
 	rmdir(STATEDIR);
 
 	closelog();

commit d66283df5765240c23665e9825539af88b7c8167
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:46:58 2008 +0100

    Remove interface property callbacks

diff --git a/src/iface.c b/src/iface.c
index b08fdb8f..9c9d7350 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -386,114 +386,6 @@ static GDBusMethodTable iface_methods[] = {
 	{ },
 };
 
-static dbus_bool_t get_type(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-	const char *type;
-
-	DBG("iface %p", iface);
-
-	switch (iface->type) {
-	case CONNMAN_IFACE_TYPE_80203:
-		type = "80203";
-		break;
-	case CONNMAN_IFACE_TYPE_80211:
-		type = "80211";
-		break;
-	case CONNMAN_IFACE_TYPE_WIMAX:
-		type = "wimax";
-		break;
-	case CONNMAN_IFACE_TYPE_BLUETOOTH:
-		type = "bluetooth";
-		break;
-	default:
-		type = "unknown";
-		break;
-	}
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &type);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_address(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-	const char *address;
-
-	DBG("iface %p", iface);
-
-	if (!iface->driver->get_address)
-		return FALSE;
-
-	address = iface->driver->get_address(iface);
-	if (address == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &address);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_driver(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	if (iface->device.driver == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-						&iface->device.driver);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_vendor(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	if (iface->device.vendor == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-						&iface->device.vendor);
-
-	return TRUE;
-}
-
-static dbus_bool_t get_product(DBusConnection *conn,
-					DBusMessageIter *iter, void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	if (iface->device.product == NULL)
-		return FALSE;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
-						&iface->device.product);
-
-	return TRUE;
-}
-
-static GDBusPropertyTable iface_properties[] = {
-	{ "Type",    "s", get_type    },
-	{ "Address", "s", get_address },
-	{ "Driver",  "s", get_driver  },
-	{ "Vendor",  "s", get_vendor  },
-	{ "Product", "s", get_product },
-	{ },
-};
-
 static void device_free(void *data)
 {
 	struct connman_iface *iface = data;
@@ -615,7 +507,7 @@ static int probe_device(LibHalContext *ctx,
 
 	g_dbus_register_interface(conn, iface->path,
 					CONNMAN_IFACE_INTERFACE,
-					iface_methods, NULL, iface_properties);
+					iface_methods, NULL, NULL);
 
 	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
 					CONNMAN_MANAGER_INTERFACE,

commit ca2197bc2724ed4534fc052d99d8815845d9315e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 10:55:49 2008 +0100

    Remove callback for getting the hardware address

diff --git a/include/iface.h b/include/iface.h
index a916cd16..ed85984b 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -98,8 +98,6 @@ struct connman_iface_driver {
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
 
-	const char * (*get_address) (struct connman_iface *iface);
-
 	void (*set_network) (struct connman_iface *iface,
 						const char *network);
 	void (*set_passphrase) (struct connman_iface *iface,
diff --git a/plugins/80211.c b/plugins/80211.c
index 5aebe964..5a74de5a 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -58,7 +58,6 @@ struct station_data {
 
 struct iface_data {
 	char ifname[IFNAMSIZ];
-	char ifaddr[18];
 	GSList *stations;
 
 	gchar *network;
@@ -164,7 +163,6 @@ static int iface_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
 	struct ifreq ifr;
-	struct ether_addr *eth;
 	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
@@ -176,9 +174,6 @@ static int iface_probe(struct connman_iface *iface)
 
 	err = ioctl(sk, SIOCGIFNAME, &ifr);
 
-	if (err == 0)
-		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
-
 	close(sk);
 
 	if (err < 0)
@@ -194,15 +189,6 @@ static int iface_probe(struct connman_iface *iface)
 
 	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
 
-	eth = (void *) &ifr.ifr_hwaddr.sa_data;
-	sprintf(data->ifaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
@@ -290,15 +276,6 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
-static const char *iface_get_address(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	printf("[802.11] get address %s\n", data->ifname);
-
-	return data->ifaddr;
-}
-
 static void iface_set_network(struct connman_iface *iface,
 						const char *network)
 {
@@ -535,7 +512,6 @@ static struct connman_iface_driver iface_driver = {
 	.activate	= iface_activate,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
-	.get_address	= iface_get_address,
 	.set_network	= iface_set_network,
 	.set_passphrase	= iface_set_passphrase,
 	.rtnl_carrier	= iface_carrier,

commit 3dce61ceefbe49774724917d1e61ad1d41640f52
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 11:08:07 2008 +0100

    Update interface constants and definitions

diff --git a/include/iface.h b/include/iface.h
index ed85984b..4e2a30c0 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -33,7 +33,8 @@ enum connman_iface_type {
 	CONNMAN_IFACE_TYPE_80203     = 1,
 	CONNMAN_IFACE_TYPE_80211     = 2,
 	CONNMAN_IFACE_TYPE_WIMAX     = 3,
-	CONNMAN_IFACE_TYPE_BLUETOOTH = 4,
+	CONNMAN_IFACE_TYPE_MODEM     = 4,
+	CONNMAN_IFACE_TYPE_BLUETOOTH = 5,
 };
 
 enum connman_iface_flags {
@@ -45,12 +46,31 @@ enum connman_iface_flags {
 
 enum connman_iface_state {
 	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
-	CONNMAN_IFACE_STATE_ACTIVE    = 1,
-	CONNMAN_IFACE_STATE_CONNECTED = 2,
-	CONNMAN_IFACE_STATE_READY     = 3,
+	CONNMAN_IFACE_STATE_OFF       = 1,
+	CONNMAN_IFACE_STATE_ENABLED   = 2,
+	CONNMAN_IFACE_STATE_CONNECT   = 3,
+	CONNMAN_IFACE_STATE_CONFIG    = 4,
+	CONNMAN_IFACE_STATE_CARRIER   = 5,
+	CONNMAN_IFACE_STATE_READY     = 6,
+	CONNMAN_IFACE_STATE_SHUTDOWN  = 7,
+};
+
+enum connman_iface_policy {
+	CONNMAN_IFACE_POLICY_UNKNOWN = 0,
+	CONNMAN_IFACE_POLICY_OFF     = 1,
+	CONNMAN_IFACE_POLICY_IGNORE  = 2,
+	CONNMAN_IFACE_POLICY_AUTO    = 3,
+};
+
+enum connman_ipv4_method {
+	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
+	CONNMAN_IPV4_METHOD_OFF     = 1,
+	CONNMAN_IPV4_METHOD_STATIC  = 2,
+	CONNMAN_IPV4_METHOD_DHCP    = 3,
 };
 
 struct connman_ipv4 {
+	enum connman_ipv4_method method;
 	struct in_addr address;
 	struct in_addr netmask;
 	struct in_addr gateway;
@@ -66,11 +86,13 @@ struct connman_iface {
 	char *path;
 	char *udi;
 	char *sysfs;
+	char *identifier;
 	int index;
 	int carrier;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
+	enum connman_iface_policy policy;
 	struct connman_ipv4 ipv4;
 
 	struct connman_iface_driver *driver;
diff --git a/plugins/80211.c b/plugins/80211.c
index 5a74de5a..558dd971 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -223,7 +223,18 @@ static int iface_activate(struct connman_iface *iface)
 
 	printf("[802.11] activate %s\n", data->ifname);
 
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_ACTIVE);
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_ENABLED);
+
+	return 0;
+}
+
+static int iface_shutdown(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] shutdown %s\n", data->ifname);
+
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_SHUTDOWN);
 
 	return 0;
 }
@@ -510,6 +521,7 @@ static struct connman_iface_driver iface_driver = {
 	.probe		= iface_probe,
 	.remove		= iface_remove,
 	.activate	= iface_activate,
+	.shutdown	= iface_shutdown,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
 	.set_network	= iface_set_network,
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 1eb729bc..4787f435 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -100,7 +100,7 @@ static gboolean control_event(GIOChannel *chan,
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
 		printf("[SUPPLICANT] connected\n");
 		connman_iface_update(task->iface,
-					CONNMAN_IFACE_STATE_CONNECTED);
+					CONNMAN_IFACE_STATE_CARRIER);
 	}
 
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
diff --git a/src/iface.c b/src/iface.c
index 9c9d7350..fce6dd0f 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -97,14 +97,14 @@ int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state)
 {
 	switch (state) {
-	case CONNMAN_IFACE_STATE_ACTIVE:
+	case CONNMAN_IFACE_STATE_ENABLED:
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
 		}
 		break;
 
-	case CONNMAN_IFACE_STATE_CONNECTED:
+	case CONNMAN_IFACE_STATE_CARRIER:
 		__connman_dhcp_request(iface);
 		break;
 

commit 5c1b3864d4c0be14a181594bba6d871ea84b8985
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 11:21:39 2008 +0100

    Add string conversion helper functions

diff --git a/src/Makefile.am b/src/Makefile.am
index 66d2f1c8..cd80c8d2 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,8 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h manager.c plugin.c iface.c rtnl.c dhcp.c
+connmand_SOURCES = main.c connman.h manager.c plugin.c \
+			iface.c iface-helper.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index ec7a1f3e..7f789fe8 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -55,6 +55,14 @@ void __connman_iface_cleanup(void);
 struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
 
+const char *__connman_iface_type2string(enum connman_iface_type type);
+const char *__connman_iface_state2string(enum connman_iface_state state);
+const char *__connman_iface_policy2string(enum connman_iface_policy policy);
+enum connman_iface_policy __connman_iface_string2policy(const char *policy);
+
+const char *__connman_ipv4_method2string(enum connman_ipv4_method method);
+enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/iface-helper.c b/src/iface-helper.c
new file mode 100644
index 00000000..4fe4b649
--- /dev/null
+++ b/src/iface-helper.c
@@ -0,0 +1,128 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+
+#include "connman.h"
+
+const char *__connman_iface_type2string(enum connman_iface_type type)
+{
+	switch (type) {
+	case CONNMAN_IFACE_TYPE_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IFACE_TYPE_80203:
+		return "80203";
+	case CONNMAN_IFACE_TYPE_80211:
+		return "80211";
+	case CONNMAN_IFACE_TYPE_WIMAX:
+		return "wimax";
+	case CONNMAN_IFACE_TYPE_MODEM:
+		return "modem";
+	case CONNMAN_IFACE_TYPE_BLUETOOTH:
+		return "bluetooth";
+	}
+
+	return "unknown";
+}
+
+const char *__connman_iface_state2string(enum connman_iface_state state)
+{
+	switch (state) {
+	case CONNMAN_IFACE_STATE_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IFACE_STATE_OFF:
+		return "off";
+	case CONNMAN_IFACE_STATE_ENABLED:
+		return "enabled";
+	case CONNMAN_IFACE_STATE_CONNECT:
+		return "connect";
+	case CONNMAN_IFACE_STATE_CONFIG:
+		return "config";
+	case CONNMAN_IFACE_STATE_CARRIER:
+		return "carrier";
+	case CONNMAN_IFACE_STATE_READY:
+		return "ready";
+	case CONNMAN_IFACE_STATE_SHUTDOWN:
+		return "shutdown";
+	}
+
+	return "unknown";
+}
+
+const char *__connman_iface_policy2string(enum connman_iface_policy policy)
+{
+	switch (policy) {
+	case CONNMAN_IFACE_POLICY_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IFACE_POLICY_OFF:
+		return "off";
+	case CONNMAN_IFACE_POLICY_IGNORE:
+		return "ignore";
+	case CONNMAN_IFACE_POLICY_AUTO:
+		return "auto";
+	}
+
+	return "unknown";
+}
+
+enum connman_iface_policy __connman_iface_string2policy(const char *policy)
+{
+	if (strcasecmp(policy, "off") == 0)
+		return CONNMAN_IFACE_POLICY_OFF;
+	else if (strcasecmp(policy, "ignore") == 0)
+		return CONNMAN_IFACE_POLICY_IGNORE;
+	else if (strcasecmp(policy, "auto") == 0)
+		return CONNMAN_IFACE_POLICY_AUTO;
+	else
+		return CONNMAN_IFACE_POLICY_UNKNOWN;
+}
+
+const char *__connman_ipv4_method2string(enum connman_ipv4_method method)
+{
+	switch (method) {
+	case CONNMAN_IPV4_METHOD_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IPV4_METHOD_OFF:
+		return "off";
+	case CONNMAN_IPV4_METHOD_STATIC:
+		return "static";
+	case CONNMAN_IPV4_METHOD_DHCP:
+		return "dhcp";
+	}
+
+	return "unknown";
+}
+
+enum connman_ipv4_method __connman_ipv4_string2method(const char *method)
+{
+	if (strcasecmp(method, "off") == 0)
+		return CONNMAN_IPV4_METHOD_OFF;
+	else if (strcasecmp(method, "static") == 0)
+		return CONNMAN_IPV4_METHOD_STATIC;
+	else if (strcasecmp(method, "dhcp") == 0)
+		return CONNMAN_IPV4_METHOD_DHCP;
+	else
+		return CONNMAN_IPV4_METHOD_UNKNOWN;
+}

commit f4292c41c31dc7d0bb9fb3ed6061b6e9ef6ac484
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 11:41:12 2008 +0100

    Add new method and signal implementation

diff --git a/src/iface.c b/src/iface.c
index fce6dd0f..1c0c8823 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -45,6 +45,8 @@
 
 #include "connman.h"
 
+static DBusConnection *connection = NULL;
+
 static GSList *drivers = NULL;
 
 int connman_iface_register(struct connman_iface_driver *driver)
@@ -96,8 +98,11 @@ void __connman_iface_list(DBusMessageIter *iter)
 int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state)
 {
+	const char *str = NULL;
+
 	switch (state) {
 	case CONNMAN_IFACE_STATE_ENABLED:
+		str = "enabled";
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
@@ -105,15 +110,29 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
+		str = "carrier";
 		__connman_dhcp_request(iface);
 		break;
 
+	case CONNMAN_IFACE_STATE_READY:
+		str = "ready";
+		break;
+
+	case CONNMAN_IFACE_STATE_SHUTDOWN:
+		break;
+
 	default:
 		break;
 	}
 
 	iface->state = state;
 
+	if (str != NULL) {
+		g_dbus_emit_signal(connection, iface->path,
+				CONNMAN_IFACE_INTERFACE, "StateChanged",
+				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
+	}
+
 	return 0;
 }
 
@@ -286,7 +305,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 	return 0;
 }
 
-static DBusMessage *enable_iface(DBusConnection *conn,
+static DBusMessage *scan_iface(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
@@ -299,20 +318,52 @@ static DBusMessage *enable_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->activate)
-		driver->activate(iface);
+	if (driver->scan)
+		driver->scan(iface);
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	return reply;
 }
 
-static DBusMessage *scan_iface(DBusConnection *conn,
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
 	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -320,58 +371,332 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->scan)
-		driver->scan(iface);
+	dbus_message_iter_init_append(reply, &array);
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	str = __connman_iface_type2string(iface->type);
+	append_entry(&dict, "Type", DBUS_TYPE_STRING, &str);
+
+	str = __connman_iface_state2string(iface->state);
+	append_entry(&dict, "State", DBUS_TYPE_STRING, &str);
+
+	if (iface->type == CONNMAN_IFACE_TYPE_80211) {
+		dbus_uint16_t signal = 75;
+		append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
+	}
+
+	str = __connman_iface_policy2string(iface->policy);
+	append_entry(&dict, "Policy", DBUS_TYPE_STRING, &str);
+
+	if (iface->device.driver != NULL)
+		append_entry(&dict, "Driver",
+				DBUS_TYPE_STRING, &iface->device.driver);
+
+	if (iface->device.vendor != NULL)
+		append_entry(&dict, "Vendor",
+				DBUS_TYPE_STRING, &iface->device.vendor);
+
+	if (iface->device.product != NULL)
+		append_entry(&dict, "Product",
+				DBUS_TYPE_STRING, &iface->device.product);
+
+	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
 }
 
-static DBusMessage *set_network(DBusConnection *conn,
+static DBusMessage *get_state(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
 	DBusMessage *reply;
-	const char *network;
+	const char *state;
 
 	DBG("conn %p", conn);
 
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	state = __connman_iface_state2string(iface->state);
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &state,
 							DBUS_TYPE_INVALID);
 
+	return reply;
+}
+
+static DBusMessage *get_signal(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	dbus_uint16_t signal;
+
+	DBG("conn %p", conn);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->set_network)
-		driver->set_network(iface, network);
+	if (iface->type == CONNMAN_IFACE_TYPE_80211)
+		signal = 75;
+	else
+		signal = 0;
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+	dbus_message_append_args(reply, DBUS_TYPE_UINT16, &signal,
+							DBUS_TYPE_INVALID);
 
 	return reply;
 }
 
-static DBusMessage *set_passphrase(DBusConnection *conn,
+static DBusMessage *get_policy(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	const char *policy;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	policy = __connman_iface_policy2string(iface->policy);
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &policy,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *set_policy(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
 	DBusMessage *reply;
-	const char *passphrase;
+	enum connman_iface_policy new_policy;
+	const char *path, *policy;
 
 	DBG("conn %p", conn);
 
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &passphrase,
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &policy,
 							DBUS_TYPE_INVALID);
 
+	new_policy = __connman_iface_string2policy(policy);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	if (iface->policy != new_policy) {
+		path = dbus_message_get_path(msg);
+
+		iface->policy = new_policy;
+
+		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
+			if (iface->driver->activate)
+				iface->driver->activate(iface);
+		} else {
+			if (iface->driver->shutdown)
+				iface->driver->shutdown(iface);
+		}
+
+		g_dbus_emit_signal(conn, path, CONNMAN_IFACE_INTERFACE,
+				"PolicyChanged", DBUS_TYPE_STRING, &policy,
+							DBUS_TYPE_INVALID);
+	}
+
+	return reply;
+}
+
+static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
+{
+	DBusMessageIter array, dict;
+	const char *str;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	str = __connman_ipv4_method2string(iface->ipv4.method);
+	append_entry(&dict, "Method", DBUS_TYPE_STRING, &str);
+
+	if (iface->ipv4.address.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.address);
+		append_entry(&dict, "Address", DBUS_TYPE_STRING, &str);
+	}
+
+	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.netmask);
+		append_entry(&dict, "Netmask", DBUS_TYPE_STRING, &str);
+	}
+
+	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.gateway);
+		append_entry(&dict, "Gateway", DBUS_TYPE_STRING, &str);
+	}
+
+	dbus_message_iter_close_container(&array, &dict);
+}
+
+static DBusMessage *get_ipv4(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->set_passphrase)
-		driver->set_passphrase(iface, passphrase);
+	append_ipv4(reply, iface);
+
+	return reply;
+}
+
+static DBusMessage *set_ipv4(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply, *signal;
+	DBusMessageIter array, dict;
+	const char *path;
+	gboolean changed = FALSE;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+		enum connman_ipv4_method method;
+		in_addr_t addr;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "Method") == 0) {
+			method = __connman_ipv4_string2method(val);
+			if (iface->ipv4.method != method) {
+				iface->ipv4.method = method;
+				changed = TRUE;
+			}
+		}
+
+		if (g_strcasecmp(key, "Address") == 0) {
+			addr = inet_addr(val);
+			if (iface->ipv4.address.s_addr != addr) {
+				iface->ipv4.address.s_addr = addr;
+				changed = TRUE;
+			}
+		}
+
+		if (g_strcasecmp(key, "Netmask") == 0) {
+			addr = inet_addr(val);
+			if (iface->ipv4.netmask.s_addr != addr) {
+				iface->ipv4.netmask.s_addr = addr;
+				changed = TRUE;
+			}
+		}
+
+		if (g_strcasecmp(key, "Gateway") == 0) {
+			addr = inet_addr(val);
+			if (iface->ipv4.gateway.s_addr != addr) {
+				iface->ipv4.gateway.s_addr = addr;
+				changed = TRUE;
+			}
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	path = dbus_message_get_path(msg);
+
+	if (changed == TRUE) {
+		signal = dbus_message_new_signal(path,
+				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
+		if (signal != NULL) {
+			append_ipv4(signal, iface);
+			dbus_connection_send(conn, signal, NULL);
+			dbus_message_unref(signal);
+		}
+	}
+
+	return reply;
+}
+
+static DBusMessage *set_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "ESSID") == 0) {
+			if (iface->driver->set_network)
+				iface->driver->set_network(iface, val);
+		}
+
+		if (g_strcasecmp(key, "PSK") == 0) {
+			if (iface->driver->set_network)
+				iface->driver->set_passphrase(iface, val);
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
@@ -379,10 +704,24 @@ static DBusMessage *set_passphrase(DBusConnection *conn,
 }
 
 static GDBusMethodTable iface_methods[] = {
-	{ "Enable",        "",  "", enable_iface   },
-	{ "Scan",          "",  "", scan_iface     },
-	{ "SetNetwork",    "s", "", set_network    },
-	{ "SetPassphrase", "s", "", set_passphrase },
+	{ "Scan",          "",      "",      scan_iface     },
+	{ "GetProperties", "",      "a{sv}", get_properties },
+	{ "GetState",      "",      "s",     get_state      },
+	{ "GetSignal",     "",      "q",     get_signal     },
+	{ "GetPolicy",     "",      "s",     get_policy     },
+	{ "SetPolicy",     "s",     "",      set_policy     },
+	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
+	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
+	{ "SetNetwork",    "a{sv}", "",      set_network    },
+	{ },
+};
+
+static GDBusSignalTable iface_signals[] = {
+	{ "StateChanged",   "s"     },
+	{ "SignalChanged",  "q"     },
+	{ "PolicyChanged",  "s"     },
+	{ "IPv4Changed",    "a{sv}" },
+	{ "NetworkChanged", "a{sv}" },
 	{ },
 };
 
@@ -400,6 +739,7 @@ static void device_free(void *data)
 	g_free(iface->path);
 	g_free(iface->udi);
 	g_free(iface->sysfs);
+	g_free(iface->identifier);
 	g_free(iface->device.driver);
 	g_free(iface->device.vendor);
 	g_free(iface->device.product);
@@ -461,7 +801,7 @@ static int probe_device(LibHalContext *ctx,
 
 	iface->udi = g_strdup(udi);
 
-	DBG("path %s", iface->path);
+	DBG("iface %p path %s", iface, iface->path);
 
 	sysfs = libhal_device_get_property_string(ctx, udi,
 						"linux.sysfs_path", NULL);
@@ -479,8 +819,7 @@ static int probe_device(LibHalContext *ctx,
 	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
 	iface->flags = 0;
 	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
-
-	DBG("iface %p", iface);
+	iface->policy = CONNMAN_IFACE_POLICY_UNKNOWN;
 
 	err = driver->probe(iface);
 	if (err < 0) {
@@ -507,7 +846,9 @@ static int probe_device(LibHalContext *ctx,
 
 	g_dbus_register_interface(conn, iface->path,
 					CONNMAN_IFACE_INTERFACE,
-					iface_methods, NULL, NULL);
+					iface_methods, iface_signals, NULL);
+
+	DBG("iface %p identifier %s", iface, iface->identifier);
 
 	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
 					CONNMAN_MANAGER_INTERFACE,
@@ -515,6 +856,11 @@ static int probe_device(LibHalContext *ctx,
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
+	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
+		if (driver->activate)
+			driver->activate(iface);
+	}
+
 	return 0;
 }
 
@@ -677,7 +1023,6 @@ static void hal_cleanup(void *data)
 	hal_ctx = NULL;
 }
 
-static DBusConnection *connection = NULL;
 static guint hal_watch = 0;
 
 int __connman_iface_init(DBusConnection *conn)

commit 588882dd73aa475dd262d117c71dcabcde5e6d9c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 12:08:23 2008 +0100

    Add generic handling for hardware addresses and setup

diff --git a/src/Makefile.am b/src/Makefile.am
index cd80c8d2..e207525b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -6,7 +6,7 @@ dbus_DATA = connman.conf
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h manager.c plugin.c \
-			iface.c iface-helper.c rtnl.c dhcp.c
+			iface.c iface-helper.c iface-inet.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 7f789fe8..98d8ea80 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -55,6 +55,9 @@ void __connman_iface_cleanup(void);
 struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
 
+int __connman_iface_create_identifier(struct connman_iface *iface);
+int __connman_iface_init_via_inet(struct connman_iface *iface);
+
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
 const char *__connman_iface_policy2string(enum connman_iface_policy policy);
diff --git a/src/iface-inet.c b/src/iface-inet.c
new file mode 100644
index 00000000..664d2980
--- /dev/null
+++ b/src/iface-inet.c
@@ -0,0 +1,110 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <net/ethernet.h>
+
+#include "connman.h"
+
+int __connman_iface_create_identifier(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	struct ether_addr *eth;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	iface->identifier = malloc(18);
+	if (iface->identifier == NULL)
+		return -ENOMEM;
+
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	sprintf(iface->identifier, "%02X-%02X-%02X-%02X-%02X-%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
+	return 0;
+}
+
+int __connman_iface_init_via_inet(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -EIO;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFFLAGS, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -EIO;
+
+	if (ifr.ifr_flags & IFF_UP)
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+	else
+		iface->state = CONNMAN_IFACE_STATE_OFF;
+
+	if (ifr.ifr_flags & IFF_RUNNING)
+		iface->state = CONNMAN_IFACE_STATE_CARRIER;
+
+	return 0;
+}
diff --git a/src/iface.c b/src/iface.c
index 1c0c8823..c9d25951 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -827,6 +827,10 @@ static int probe_device(LibHalContext *ctx,
 		return -1;
 	}
 
+	__connman_iface_create_identifier(iface);
+
+	__connman_iface_init_via_inet(iface);
+
 	iface->driver = driver;
 
 	conn = libhal_ctx_get_dbus_connection(ctx);

commit 8efebe4ff9af283939fc4587cc3f36c4599c964a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 12:27:05 2008 +0100

    Add support for storing interface settings

diff --git a/src/Makefile.am b/src/Makefile.am
index e207525b..4da752e5 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -6,7 +6,8 @@ dbus_DATA = connman.conf
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h manager.c plugin.c \
-			iface.c iface-helper.c iface-inet.c rtnl.c dhcp.c
+			iface.c iface-storage.c iface-helper.c \
+					iface-inet.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 98d8ea80..26931ff5 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -58,6 +58,9 @@ void __connman_iface_list(DBusMessageIter *iter);
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
 
+int __connman_iface_load(struct connman_iface *iface);
+int __connman_iface_store(struct connman_iface *iface);
+
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
 const char *__connman_iface_policy2string(enum connman_iface_policy policy);
diff --git a/src/iface-storage.c b/src/iface-storage.c
new file mode 100644
index 00000000..b7c84c38
--- /dev/null
+++ b/src/iface-storage.c
@@ -0,0 +1,192 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <arpa/inet.h>
+
+#include <glib.h>
+
+#include "connman.h"
+
+int __connman_iface_load(struct connman_iface *iface)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *str;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return -EIO;
+
+	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
+		goto done;
+
+	if (g_key_file_has_group(keyfile, iface->identifier) == FALSE)
+		goto done;
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"Policy", NULL);
+	if (str != NULL) {
+		iface->policy = __connman_iface_string2policy(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Method", NULL);
+	if (str != NULL) {
+		iface->ipv4.method = __connman_ipv4_string2method(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Address", NULL);
+	if (str != NULL) {
+		iface->ipv4.address.s_addr = inet_addr(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Netmask", NULL);
+	if (str != NULL) {
+		iface->ipv4.netmask.s_addr = inet_addr(str);
+		g_free(str);
+	}
+
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"IPv4.Gateway", NULL);
+	if (str != NULL) {
+		iface->ipv4.gateway.s_addr = inet_addr(str);
+		g_free(str);
+	}
+
+done:
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return 0;
+}
+
+static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
+{
+	const char *str;
+	gchar *comment;
+
+	DBG("iface %p", iface);
+
+	comment = g_key_file_get_comment(keyfile,
+					iface->identifier, NULL, NULL);
+	if (comment == NULL || *comment == '\0') {
+		if (iface->device.product != NULL)
+			g_key_file_set_comment(keyfile, iface->identifier,
+					NULL, iface->device.product, NULL);
+	}
+	g_free(comment);
+
+	str = __connman_iface_policy2string(iface->policy);
+	g_key_file_set_string(keyfile, iface->identifier, "Policy", str);
+
+	if (iface->ipv4.method != CONNMAN_IPV4_METHOD_UNKNOWN) {
+		str = __connman_ipv4_method2string(iface->ipv4.method);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Method", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Method", NULL);
+
+	if (iface->ipv4.address.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.address);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Address", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Address", NULL);
+
+	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.netmask);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Netmask", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Netmask", NULL);
+
+	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
+		str = inet_ntoa(iface->ipv4.gateway);
+		g_key_file_set_string(keyfile, iface->identifier,
+							"IPv4.Gateway", str);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"IPv4.Gateway", NULL);
+}
+
+int __connman_iface_store(struct connman_iface *iface)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return -EIO;
+
+	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
+		goto done;
+
+	if (length > 0) {
+		if (g_key_file_load_from_data(keyfile, data, length,
+				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+			goto done;
+	}
+
+	g_free(data);
+
+	do_update(keyfile, iface);
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents(pathname, data, length, NULL);
+
+done:
+	g_free(data);
+
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return 0;
+}
diff --git a/src/iface.c b/src/iface.c
index c9d25951..df020a3a 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -500,6 +500,7 @@ static DBusMessage *set_policy(DBusConnection *conn,
 		path = dbus_message_get_path(msg);
 
 		iface->policy = new_policy;
+		__connman_iface_store(iface);
 
 		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
 			if (iface->driver->activate)
@@ -642,6 +643,8 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	path = dbus_message_get_path(msg);
 
 	if (changed == TRUE) {
+		__connman_iface_store(iface);
+
 		signal = dbus_message_new_signal(path,
 				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
 		if (signal != NULL) {
@@ -831,6 +834,8 @@ static int probe_device(LibHalContext *ctx,
 
 	__connman_iface_init_via_inet(iface);
 
+	__connman_iface_load(iface);
+
 	iface->driver = driver;
 
 	conn = libhal_ctx_get_dbus_connection(ctx);

commit 0ebfa46648f633da5d933af0c67277ad49ae4376
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 8 12:48:05 2008 +0100

    Add support for storing the network identifier

diff --git a/include/iface.h b/include/iface.h
index 4e2a30c0..a7c9f094 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -80,6 +80,7 @@ struct connman_ipv4 {
 };
 
 struct connman_network {
+	char *essid;
 };
 
 struct connman_iface {
@@ -93,6 +94,7 @@ struct connman_iface {
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
 	enum connman_iface_policy policy;
+	struct connman_network network;
 	struct connman_ipv4 ipv4;
 
 	struct connman_iface_driver *driver;
diff --git a/src/iface-storage.c b/src/iface-storage.c
index b7c84c38..ad2cfc5a 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -59,6 +59,15 @@ int __connman_iface_load(struct connman_iface *iface)
 		g_free(str);
 	}
 
+	str = g_key_file_get_string(keyfile, iface->identifier,
+							"Network.ESSID", NULL);
+	if (str != NULL) {
+		g_free(iface->network.essid);
+		iface->network.essid = str;
+		if (iface->driver->set_network)
+			iface->driver->set_network(iface, str);
+	}
+
 	str = g_key_file_get_string(keyfile, iface->identifier,
 							"IPv4.Method", NULL);
 	if (str != NULL) {
@@ -114,6 +123,13 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	str = __connman_iface_policy2string(iface->policy);
 	g_key_file_set_string(keyfile, iface->identifier, "Policy", str);
 
+	if (iface->network.essid != NULL) {
+		g_key_file_set_string(keyfile, iface->identifier,
+					"Network.ESSID", iface->network.essid);
+	} else
+		g_key_file_remove_key(keyfile, iface->identifier,
+							"Network.ESSID", NULL);
+
 	if (iface->ipv4.method != CONNMAN_IPV4_METHOD_UNKNOWN) {
 		str = __connman_ipv4_method2string(iface->ipv4.method);
 		g_key_file_set_string(keyfile, iface->identifier,
diff --git a/src/iface.c b/src/iface.c
index df020a3a..b440d528 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -663,6 +663,7 @@ static DBusMessage *set_network(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	gboolean changed = FALSE;
 
 	DBG("conn %p", conn);
 
@@ -685,8 +686,11 @@ static DBusMessage *set_network(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &val);
 
 		if (g_strcasecmp(key, "ESSID") == 0) {
+			g_free(iface->network.essid);
+			iface->network.essid = g_strdup(val);
 			if (iface->driver->set_network)
 				iface->driver->set_network(iface, val);
+			changed = TRUE;
 		}
 
 		if (g_strcasecmp(key, "PSK") == 0) {
@@ -703,6 +707,9 @@ static DBusMessage *set_network(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
+	if (changed == TRUE)
+		__connman_iface_store(iface);
+
 	return reply;
 }
 
@@ -743,6 +750,7 @@ static void device_free(void *data)
 	g_free(iface->udi);
 	g_free(iface->sysfs);
 	g_free(iface->identifier);
+	g_free(iface->network.essid);
 	g_free(iface->device.driver);
 	g_free(iface->device.vendor);
 	g_free(iface->device.product);
@@ -834,10 +842,10 @@ static int probe_device(LibHalContext *ctx,
 
 	__connman_iface_init_via_inet(iface);
 
-	__connman_iface_load(iface);
-
 	iface->driver = driver;
 
+	__connman_iface_load(iface);
+
 	conn = libhal_ctx_get_dbus_connection(ctx);
 
 	g_dbus_register_object(conn, iface->path, iface, device_free);

commit baf41b9cfdb124c9369c7da522ec024625f877b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:43:50 2008 +0100

    Add support for terminating dhclient

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 8506c633..139eb8ff 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -51,7 +51,7 @@ struct dhclient_task {
 
 static GSList *tasks = NULL;
 
-static struct dhclient_task *find_task(GPid pid)
+static struct dhclient_task *find_task_by_pid(GPid pid)
 {
 	GSList *list;
 
@@ -65,6 +65,39 @@ static struct dhclient_task *find_task(GPid pid)
 	return NULL;
 }
 
+static struct dhclient_task *find_task_by_index(int index)
+{
+	GSList *list;
+
+	for (list = tasks; list; list = list->next) {
+		struct dhclient_task *task = list->data;
+
+		if (task->ifindex == index)
+			return task;
+	}
+
+	return NULL;
+}
+
+static void kill_task(struct dhclient_task *task)
+{
+	char pathname[PATH_MAX];
+
+	kill(task->pid, SIGTERM);
+
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	free(task->ifname);
+
+	g_free(task);
+}
+
 static int dhclient_request(struct connman_iface *iface)
 {
 	struct ifreq ifr;
@@ -142,7 +175,17 @@ static int dhclient_request(struct connman_iface *iface)
 
 static int dhclient_release(struct connman_iface *iface)
 {
-	printf("[DHCP] release\n");
+	struct dhclient_task *task;
+
+	task = find_task_by_index(iface->index);
+	if (task == NULL)
+		return NULL;
+
+	printf("[DHCP] release %s\n", task->ifname);
+
+	tasks = g_slist_remove(tasks, task);
+
+	kill_task(task);
 
 	return 0;
 }
@@ -174,7 +217,7 @@ static DBusMessage *notify_method(DBusConnection *conn,
 
 	printf("[DHCP] change %d to %s\n", pid, text);
 
-	task = find_task(pid);
+	task = find_task_by_pid(pid);
 	if (task == NULL)
 		return NULL;
 
@@ -257,23 +300,10 @@ static void plugin_exit(void)
 
 	for (list = tasks; list; list = list->next) {
 		struct dhclient_task *task = list->data;
-		char pathname[PATH_MAX];
 
 		printf("[DHCP] killing process %d\n", task->pid);
 
-		kill(task->pid, SIGTERM);
-
-		snprintf(pathname, sizeof(pathname) - 1,
-				"%s/dhclient.%s.pid", STATEDIR, task->ifname);
-		unlink(pathname);
-
-		snprintf(pathname, sizeof(pathname) - 1,
-				"%s/dhclient.%s.leases", STATEDIR, task->ifname);
-		unlink(pathname);
-
-		free(task->ifname);
-
-		g_free(task);
+		kill_task(task);
 	}
 
 	g_slist_free(tasks);

commit c9ca5f2f6d9b10adec431e01472afb4c197e9f2a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:47:18 2008 +0100

    Update handling of shutdown procedure

diff --git a/src/iface.c b/src/iface.c
index b440d528..a5327f51 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -101,6 +101,10 @@ int connman_iface_update(struct connman_iface *iface,
 	const char *str = NULL;
 
 	switch (state) {
+	case CONNMAN_IFACE_STATE_OFF:
+		str = "off";
+		break;
+
 	case CONNMAN_IFACE_STATE_ENABLED:
 		str = "enabled";
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
@@ -119,6 +123,10 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
+		str = "shutdown";
+		__connman_dhcp_release(iface);
+		if (iface->driver->shutdown)
+			iface->driver->shutdown(iface);
 		break;
 
 	default:
@@ -505,10 +513,9 @@ static DBusMessage *set_policy(DBusConnection *conn,
 		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
 			if (iface->driver->activate)
 				iface->driver->activate(iface);
-		} else {
-			if (iface->driver->shutdown)
-				iface->driver->shutdown(iface);
-		}
+		} else
+			connman_iface_update(iface,
+					CONNMAN_IFACE_STATE_SHUTDOWN);
 
 		g_dbus_emit_signal(conn, path, CONNMAN_IFACE_INTERFACE,
 				"PolicyChanged", DBUS_TYPE_STRING, &policy,

commit 83bd9d00ec580988e38178ea1526505241535fdd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:48:33 2008 +0100

    Add support for retrieving network settings

diff --git a/include/iface.h b/include/iface.h
index a7c9f094..601253d3 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -81,6 +81,7 @@ struct connman_ipv4 {
 
 struct connman_network {
 	char *essid;
+	char *psk;
 };
 
 struct connman_iface {
diff --git a/src/iface.c b/src/iface.c
index a5327f51..f3098932 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -525,6 +525,116 @@ static DBusMessage *set_policy(DBusConnection *conn,
 	return reply;
 }
 
+static void append_network(DBusMessage *reply,
+				struct connman_iface *iface, gboolean secrets)
+{
+	DBusMessageIter array, dict;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	if (iface->network.essid != NULL)
+		append_entry(&dict, "ESSID",
+				DBUS_TYPE_STRING, &iface->network.essid);
+
+	if (secrets == TRUE && iface->network.psk != NULL)
+		append_entry(&dict, "PSK",
+				DBUS_TYPE_STRING, &iface->network.psk);
+
+	dbus_message_iter_close_container(&array, &dict);
+}
+
+static DBusMessage *get_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	append_network(reply, iface, TRUE);
+
+	return reply;
+}
+
+static DBusMessage *set_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply, *signal;
+	DBusMessageIter array, dict;
+	gboolean changed = FALSE;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "ESSID") == 0) {
+			g_free(iface->network.essid);
+			iface->network.essid = g_strdup(val);
+			if (iface->driver->set_network)
+				iface->driver->set_network(iface, val);
+			changed = TRUE;
+		}
+
+		if (g_strcasecmp(key, "PSK") == 0) {
+			g_free(iface->network.psk);
+			iface->network.psk = g_strdup(val);
+			if (iface->driver->set_network)
+				iface->driver->set_passphrase(iface, val);
+			changed = TRUE;
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	if (changed == TRUE) {
+		const char *path = dbus_message_get_path(msg);
+
+		__connman_iface_store(iface);
+
+		signal = dbus_message_new_signal(path,
+				CONNMAN_IFACE_INTERFACE, "NetworkChanged");
+		if (signal != NULL) {
+			append_network(signal, iface, FALSE);
+			dbus_connection_send(conn, signal, NULL);
+			dbus_message_unref(signal);
+		}
+	}
+
+	return reply;
+}
+
 static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
 {
 	DBusMessageIter array, dict;
@@ -581,7 +691,6 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply, *signal;
 	DBusMessageIter array, dict;
-	const char *path;
 	gboolean changed = FALSE;
 
 	DBG("conn %p", conn);
@@ -647,9 +756,9 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	path = dbus_message_get_path(msg);
-
 	if (changed == TRUE) {
+		const char *path = dbus_message_get_path(msg);
+
 		__connman_iface_store(iface);
 
 		signal = dbus_message_new_signal(path,
@@ -664,62 +773,6 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *set_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	gboolean changed = FALSE;
-
-	DBG("conn %p", conn);
-
-	dbus_message_iter_init(msg, &array);
-
-	dbus_message_iter_recurse(&array, &dict);
-
-	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key, *val;
-
-		dbus_message_iter_recurse(&dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-
-		dbus_message_iter_recurse(&entry, &value);
-
-		//type = dbus_message_iter_get_arg_type(&value);
-		dbus_message_iter_get_basic(&value, &val);
-
-		if (g_strcasecmp(key, "ESSID") == 0) {
-			g_free(iface->network.essid);
-			iface->network.essid = g_strdup(val);
-			if (iface->driver->set_network)
-				iface->driver->set_network(iface, val);
-			changed = TRUE;
-		}
-
-		if (g_strcasecmp(key, "PSK") == 0) {
-			if (iface->driver->set_network)
-				iface->driver->set_passphrase(iface, val);
-		}
-
-		dbus_message_iter_next(&dict);
-	}
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	if (changed == TRUE)
-		__connman_iface_store(iface);
-
-	return reply;
-}
-
 static GDBusMethodTable iface_methods[] = {
 	{ "Scan",          "",      "",      scan_iface     },
 	{ "GetProperties", "",      "a{sv}", get_properties },
@@ -727,9 +780,10 @@ static GDBusMethodTable iface_methods[] = {
 	{ "GetSignal",     "",      "q",     get_signal     },
 	{ "GetPolicy",     "",      "s",     get_policy     },
 	{ "SetPolicy",     "s",     "",      set_policy     },
+	{ "GetNetwork",    "",      "a{sv}", get_network    },
+	{ "SetNetwork",    "a{sv}", "",      set_network    },
 	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
 	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
-	{ "SetNetwork",    "a{sv}", "",      set_network    },
 	{ },
 };
 
@@ -737,8 +791,8 @@ static GDBusSignalTable iface_signals[] = {
 	{ "StateChanged",   "s"     },
 	{ "SignalChanged",  "q"     },
 	{ "PolicyChanged",  "s"     },
-	{ "IPv4Changed",    "a{sv}" },
 	{ "NetworkChanged", "a{sv}" },
+	{ "IPv4Changed",    "a{sv}" },
 	{ },
 };
 

commit ab8a6e3f5c4c10bac6a09887603f5d8ccbd0530b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 16:50:44 2008 +0100

    Fix wrong return value

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 139eb8ff..cc5efd86 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -179,7 +179,7 @@ static int dhclient_release(struct connman_iface *iface)
 
 	task = find_task_by_index(iface->index);
 	if (task == NULL)
-		return NULL;
+		return -ENODEV;
 
 	printf("[DHCP] release %s\n", task->ifname);
 

commit 98844b88980e2001ae3d8cd10f99d8ae9ac32b75
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:01:48 2008 +0100

    Fix shutdown procedure

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 4787f435..583b1f78 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -244,6 +244,10 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	exec_cmd(task, "DETACH");
 
+	sleep(1);
+
+	kill(task->pid, SIGTERM);
+
 	//close(task->socket);
 	g_io_channel_unref(task->channel);
 
@@ -251,8 +255,6 @@ int __supplicant_stop(struct connman_iface *iface)
 					"%s/%s.cli", STATEDIR, task->ifname);
 	unlink(pathname);
 
-	kill(task->pid, SIGTERM);
-
 	free(task->ifname);
 
 	g_free(task);

commit 56cf1fc63cdc201587b0bf7e1e06902acb090d6c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:02:17 2008 +0100

    Set the IPv4 method to DHCP in case of DHCP udpates

diff --git a/src/dhcp.c b/src/dhcp.c
index 2fa3f1fe..36132244 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -61,6 +61,8 @@ int connman_dhcp_update(struct connman_iface *iface,
 		DBG("broadcast %s", inet_ntoa(ipv4->broadcast));
 		DBG("nameserver %s", inet_ntoa(ipv4->nameserver));
 
+		ipv4->method = CONNMAN_IPV4_METHOD_DHCP;
+
 		if (iface->driver->set_ipv4) {
 			iface->driver->set_ipv4(iface, ipv4);
 			iface->ipv4 = *ipv4;

commit d48fb5d6e8c22200de560c430180bdb06a6e254b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:07:50 2008 +0100

    Stop supplicant on shutdown

diff --git a/plugins/80211.c b/plugins/80211.c
index 558dd971..6915a78b 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -234,7 +234,9 @@ static int iface_shutdown(struct connman_iface *iface)
 
 	printf("[802.11] shutdown %s\n", data->ifname);
 
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_SHUTDOWN);
+	__supplicant_stop(iface);
+
+	connman_iface_update(iface, CONNMAN_IFACE_STATE_OFF);
 
 	return 0;
 }

commit 359571dd492865b5a8eefdc4d4c44e34d92568f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 9 17:08:34 2008 +0100

    Update scan result handling routine

diff --git a/plugins/80211.c b/plugins/80211.c
index 6915a78b..d8decec1 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -428,40 +428,53 @@ static void iface_scan_results(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 	struct iwreq iwr;
-	unsigned char *buf;
-	int sk, err, size = 1024;
+	void *buf;
+	size_t size;
+	int sk, err, done = 0;
+
+	if (data == NULL)
+		return;
+
+	memset(&iwr, 0, sizeof(iwr));
+	memcpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return;
 
-retrieve:
-	buf = malloc(size);
-	if (buf == NULL) {
-		close(sk);
-		return;
-	}
+	buf = NULL;
+	size = 1024;
 
-	memset(&iwr, 0, sizeof(iwr));
-	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
-	iwr.u.data.pointer = buf;
-	iwr.u.data.length = size;
-	iwr.u.data.flags = 0;
-
-	err = ioctl(sk, SIOCGIWSCAN, &iwr);
-	if (err < 0) {
-		if (errno == E2BIG) {
-			free(buf);
-			size *= 2;
-			goto retrieve;
+	while (!done) {
+		void *newbuf;
+
+		newbuf = g_realloc(buf, size);
+		if (newbuf == NULL) {
+			close(sk);
+			return;
 		}
-	} else
-		parse_scan_results(iface, iwr.u.data.pointer,
+
+		buf = newbuf;
+		iwr.u.data.pointer = buf;
+		iwr.u.data.length = size;
+		iwr.u.data.flags = 0;
+
+		err = ioctl(sk, SIOCGIWSCAN, &iwr);
+		if (err < 0) {
+			if (errno == E2BIG)
+				size *= 2;
+			else
+				done = 1;
+		} else {
+			parse_scan_results(iface, iwr.u.data.pointer,
 						iwr.u.data.length);
+			done = 1;
+		}
+	}
 
-	close(sk);
+	g_free(buf);
 
-	free(buf);
+	close(sk);
 
 	print_stations(data);
 }

commit e66c4ceb3685bc93ca067994f083f18d39f42aa7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 11 19:54:40 2008 +0100

    Fix IO handling for the control channel

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 583b1f78..e58415c1 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -77,10 +77,8 @@ static gboolean control_event(GIOChannel *chan,
 	gsize len;
 	GIOError err;
 
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
-		g_io_channel_unref(chan);
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
 		return FALSE;
-	}
 
 	memset(buf, 0, sizeof(buf));
 
@@ -88,7 +86,6 @@ static gboolean control_event(GIOChannel *chan,
 	if (err) {
 		if (err == G_IO_ERROR_AGAIN)
 			return TRUE;
-		g_io_channel_unref(chan);
 		return FALSE;
 	}
 
@@ -158,8 +155,6 @@ static int open_control(struct supplicant_task *task)
 	exec_cmd(task, "ATTACH");
 	exec_cmd(task, "ADD_NETWORK");
 
-	g_io_channel_unref(task->channel);
-
 	return 0;
 }
 
@@ -242,13 +237,14 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	tasks = g_slist_remove(tasks, task);
 
+	exec_cmd(task, "DISABLE_NETWORK 0");
 	exec_cmd(task, "DETACH");
 
 	sleep(1);
 
 	kill(task->pid, SIGTERM);
 
-	//close(task->socket);
+	g_io_channel_shutdown(task->channel, TRUE, NULL);
 	g_io_channel_unref(task->channel);
 
 	snprintf(pathname, sizeof(pathname),

commit be3d7a2524a2526ed6a3a9064307ee1dd60dfa34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 11 19:55:33 2008 +0100

    Update state machine handling

diff --git a/src/iface.c b/src/iface.c
index f3098932..2c7fdfea 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -98,15 +98,22 @@ void __connman_iface_list(DBusMessageIter *iter)
 int connman_iface_update(struct connman_iface *iface,
 					enum connman_iface_state state)
 {
-	const char *str = NULL;
+	const char *str;
+
+	iface->state = state;
+
+	str = __connman_iface_state2string(iface->state);
+
+	g_dbus_emit_signal(connection, iface->path,
+				CONNMAN_IFACE_INTERFACE, "StateChanged",
+				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
 
 	switch (state) {
 	case CONNMAN_IFACE_STATE_OFF:
-		str = "off";
+		__connman_dhcp_release(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
-		str = "enabled";
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			if (iface->driver->connect)
 				iface->driver->connect(iface, NULL);
@@ -114,16 +121,10 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
-		str = "carrier";
 		__connman_dhcp_request(iface);
 		break;
 
-	case CONNMAN_IFACE_STATE_READY:
-		str = "ready";
-		break;
-
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
-		str = "shutdown";
 		__connman_dhcp_release(iface);
 		if (iface->driver->shutdown)
 			iface->driver->shutdown(iface);
@@ -133,14 +134,6 @@ int connman_iface_update(struct connman_iface *iface,
 		break;
 	}
 
-	iface->state = state;
-
-	if (str != NULL) {
-		g_dbus_emit_signal(connection, iface->path,
-				CONNMAN_IFACE_INTERFACE, "StateChanged",
-				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
-	}
-
 	return 0;
 }
 
@@ -489,7 +482,7 @@ static DBusMessage *set_policy(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply;
 	enum connman_iface_policy new_policy;
-	const char *path, *policy;
+	const char *policy;
 
 	DBG("conn %p", conn);
 
@@ -505,8 +498,6 @@ static DBusMessage *set_policy(DBusConnection *conn,
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	if (iface->policy != new_policy) {
-		path = dbus_message_get_path(msg);
-
 		iface->policy = new_policy;
 		__connman_iface_store(iface);
 
@@ -517,7 +508,9 @@ static DBusMessage *set_policy(DBusConnection *conn,
 			connman_iface_update(iface,
 					CONNMAN_IFACE_STATE_SHUTDOWN);
 
-		g_dbus_emit_signal(conn, path, CONNMAN_IFACE_INTERFACE,
+		policy = __connman_iface_policy2string(new_policy);
+
+		g_dbus_emit_signal(conn, iface->path, CONNMAN_IFACE_INTERFACE,
 				"PolicyChanged", DBUS_TYPE_STRING, &policy,
 							DBUS_TYPE_INVALID);
 	}
@@ -537,13 +530,18 @@ static void append_network(DBusMessage *reply,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	if (iface->network.essid != NULL)
-		append_entry(&dict, "ESSID",
+	switch (iface->type) {
+	case CONNMAN_IFACE_TYPE_80211:
+		if (iface->network.essid != NULL)
+			append_entry(&dict, "ESSID",
 				DBUS_TYPE_STRING, &iface->network.essid);
-
-	if (secrets == TRUE && iface->network.psk != NULL)
-		append_entry(&dict, "PSK",
+		if (secrets == TRUE && iface->network.psk != NULL)
+			append_entry(&dict, "PSK",
 				DBUS_TYPE_STRING, &iface->network.psk);
+		break;
+	default:
+		break;
+	}
 
 	dbus_message_iter_close_container(&array, &dict);
 }
@@ -619,11 +617,9 @@ static DBusMessage *set_network(DBusConnection *conn,
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	if (changed == TRUE) {
-		const char *path = dbus_message_get_path(msg);
-
 		__connman_iface_store(iface);
 
-		signal = dbus_message_new_signal(path,
+		signal = dbus_message_new_signal(iface->path,
 				CONNMAN_IFACE_INTERFACE, "NetworkChanged");
 		if (signal != NULL) {
 			append_network(signal, iface, FALSE);
@@ -757,11 +753,9 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
 	if (changed == TRUE) {
-		const char *path = dbus_message_get_path(msg);
-
 		__connman_iface_store(iface);
 
-		signal = dbus_message_new_signal(path,
+		signal = dbus_message_new_signal(iface->path,
 				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
 		if (signal != NULL) {
 			append_ipv4(signal, iface);

commit 7677b1bdb5df04b2e780d1bacf76f9de3f64d478
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 13 23:32:43 2008 +0100

    Add options for debug and PIE support

diff --git a/bootstrap-configure b/bootstrap-configure
index 1da77dae..2b8dc78e 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -6,6 +6,7 @@ fi
 
 ./bootstrap && \
     ./configure --enable-maintainer-mode \
+		--enable-debug \
 		--prefix=/usr \
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
diff --git a/configure.in b/configure.in
index 8f13afcd..0cbb0ad9 100644
--- a/configure.in
+++ b/configure.in
@@ -9,7 +9,7 @@ AM_MAINTAINER_MODE
 AC_PREFIX_DEFAULT(/usr/local)
 
 if (test "${CFLAGS}" = ""); then
-	CFLAGS="-Wall -O2"
+	CFLAGS="-Wall -O2 -D_FORTIFY_SOURCE=2"
 fi
 
 AC_LANG_C
@@ -24,6 +24,23 @@ m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 
+AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
+			[enable compiling with debugging information]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_prog_cc_g}" = "yes"); then
+		CFLAGS="$CFLAGS -g"
+	fi
+])
+
+AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
+			[enable position independent executables flag]), [
+	if (test "${enableval}" = "yes" &&
+				test "${ac_cv_prog_cc_pie}" = "yes"); then
+		CFLAGS="$CFLAGS -fPIE"
+		LDFLAGS="$LDFLAGS -pie"
+	fi
+])
+
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
 				AC_MSG_ERROR(gmodule is required))
 AC_SUBST(GMODULE_CFLAGS)

commit 6c6a470f8d4b2c5ec4725b13e7bfcf4ca0c04f41
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:00:15 2008 +0100

    Add generic helpers for device start and shutdown

diff --git a/src/connman.h b/src/connman.h
index 26931ff5..8756034c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -57,6 +57,8 @@ void __connman_iface_list(DBusMessageIter *iter);
 
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
+int __connman_iface_up(struct connman_iface *iface);
+int __connman_iface_down(struct connman_iface *iface);
 
 int __connman_iface_load(struct connman_iface *iface);
 int __connman_iface_store(struct connman_iface *iface);
diff --git a/src/iface-inet.c b/src/iface-inet.c
index 664d2980..a09ba312 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -108,3 +108,87 @@ int __connman_iface_init_via_inet(struct connman_iface *iface)
 
 	return 0;
 }
+
+int __connman_iface_up(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ifr.ifr_flags & IFF_UP) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags |= IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+		err = -errno;
+	else
+		err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}
+
+int __connman_iface_down(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("iface %p", iface);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (!(ifr.ifr_flags & IFF_UP)) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags &= ~IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+		err = -errno;
+	else
+		err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}

commit 2f088e1e27e0905da6d9b527bfff2a569bdef458
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:06:50 2008 +0100

    Remove unneeded callbacks from 802.03 and 802.11 plugins

diff --git a/include/iface.h b/include/iface.h
index 601253d3..96e9c4f0 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -38,10 +38,10 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_RTNL           = (1 << 0),
-	CONNMAN_IFACE_FLAG_IPV4           = (1 << 1),
-	CONNMAN_IFACE_FLAG_IPV6           = (1 << 2),
-	CONNMAN_IFACE_FLAG_CARRIER_DETECT = (1 << 3),
+	CONNMAN_IFACE_FLAG_RTNL     = (1 << 0),
+	CONNMAN_IFACE_FLAG_IPV4     = (1 << 1),
+	CONNMAN_IFACE_FLAG_IPV6     = (1 << 2),
+	CONNMAN_IFACE_FLAG_SCANNING = (1 << 3),
 };
 
 enum connman_iface_state {
@@ -122,6 +122,7 @@ struct connman_iface_driver {
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
+	int (*disconnect) (struct connman_iface *iface);
 
 	void (*set_network) (struct connman_iface *iface,
 						const char *network);
diff --git a/plugins/80203.c b/plugins/80203.c
index 65a22aa1..d916c970 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -24,7 +24,6 @@
 #endif
 
 #include <stdio.h>
-#include <arpa/inet.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
@@ -36,8 +35,7 @@ static int iface_probe(struct connman_iface *iface)
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4 |
-				CONNMAN_IFACE_FLAG_CARRIER_DETECT;
+				CONNMAN_IFACE_FLAG_IPV4;
 
 	return 0;
 }
diff --git a/plugins/80211.c b/plugins/80211.c
index d8decec1..3327d107 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -217,30 +217,6 @@ static void iface_remove(struct connman_iface *iface)
 	free(data);
 }
 
-static int iface_activate(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	printf("[802.11] activate %s\n", data->ifname);
-
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_ENABLED);
-
-	return 0;
-}
-
-static int iface_shutdown(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	printf("[802.11] shutdown %s\n", data->ifname);
-
-	__supplicant_stop(iface);
-
-	connman_iface_update(iface, CONNMAN_IFACE_STATE_OFF);
-
-	return 0;
-}
-
 static int iface_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
@@ -289,6 +265,17 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
+static int iface_disconnect(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	printf("[802.11] disconnect %s\n", data->ifname);
+
+	__supplicant_stop(iface);
+
+	return 0;
+}
+
 static void iface_set_network(struct connman_iface *iface,
 						const char *network)
 {
@@ -313,13 +300,6 @@ static void iface_set_passphrase(struct connman_iface *iface,
 	data->passphrase = g_strdup(passphrase);
 }
 
-static void iface_carrier(struct connman_iface *iface, int carrier)
-{
-	printf("[802.11] carrier %s\n", carrier ? "on" : "off");
-
-	connman_iface_indicate_carrier(iface, carrier);
-}
-
 static void parse_genie(struct station_data *station,
 					unsigned char *data, int len)
 {
@@ -535,13 +515,11 @@ static struct connman_iface_driver iface_driver = {
 	.capability	= "net.80211",
 	.probe		= iface_probe,
 	.remove		= iface_remove,
-	.activate	= iface_activate,
-	.shutdown	= iface_shutdown,
 	.scan		= iface_scan,
 	.connect	= iface_connect,
+	.disconnect	= iface_disconnect,
 	.set_network	= iface_set_network,
 	.set_passphrase	= iface_set_passphrase,
-	.rtnl_carrier	= iface_carrier,
 	.rtnl_wireless	= iface_wireless,
 };
 

commit 88be168553c2345349c614fbf7a208a32d0ca970
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:11:57 2008 +0100

    Handle return values of system calls

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index e58415c1..de74ce56 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -64,9 +64,7 @@ static struct supplicant_task *find_task(int ifindex)
 
 static int exec_cmd(struct supplicant_task *task, char *cmd)
 {
-	write(task->socket, cmd, strlen(cmd));
-
-	return 0;
+	return write(task->socket, cmd, strlen(cmd));
 }
 
 static gboolean control_event(GIOChannel *chan,
diff --git a/src/iface.c b/src/iface.c
index 2c7fdfea..a6b0ba24 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -252,7 +252,7 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 
 	DBG("%s", cmd);
 
-	system(cmd);
+	err = system(cmd);
 
 	return 0;
 }
@@ -301,7 +301,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 
 	DBG("%s", cmd);
 
-	system(cmd);
+	err = system(cmd);
 
 	return 0;
 }

commit d3ad57f2adff903961edfdec45b60e5813107eff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:17:23 2008 +0100

    Add more detailed interface state machine

diff --git a/include/iface.h b/include/iface.h
index 96e9c4f0..57a4d72e 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -48,11 +48,13 @@ enum connman_iface_state {
 	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
 	CONNMAN_IFACE_STATE_OFF       = 1,
 	CONNMAN_IFACE_STATE_ENABLED   = 2,
-	CONNMAN_IFACE_STATE_CONNECT   = 3,
-	CONNMAN_IFACE_STATE_CONFIG    = 4,
-	CONNMAN_IFACE_STATE_CARRIER   = 5,
-	CONNMAN_IFACE_STATE_READY     = 6,
-	CONNMAN_IFACE_STATE_SHUTDOWN  = 7,
+	CONNMAN_IFACE_STATE_SCANNING  = 3,
+	CONNMAN_IFACE_STATE_CONNECT   = 4,
+	CONNMAN_IFACE_STATE_CONNECTED = 5,
+	CONNMAN_IFACE_STATE_CARRIER   = 6,
+	CONNMAN_IFACE_STATE_CONFIGURE = 7,
+	CONNMAN_IFACE_STATE_READY     = 8,
+	CONNMAN_IFACE_STATE_SHUTDOWN  = 9,
 };
 
 enum connman_iface_policy {
@@ -90,7 +92,6 @@ struct connman_iface {
 	char *sysfs;
 	char *identifier;
 	int index;
-	int carrier;
 	enum connman_iface_type type;
 	enum connman_iface_flags flags;
 	enum connman_iface_state state;
@@ -101,6 +102,8 @@ struct connman_iface {
 	struct connman_iface_driver *driver;
 	void *driver_data;
 
+	void *rtnl_data;
+
 	struct {
 		char *driver;
 		char *vendor;
@@ -113,12 +116,7 @@ struct connman_iface_driver {
 	const char *capability;
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
-	int (*activate) (struct connman_iface *iface);
-	int (*shutdown) (struct connman_iface *iface);
-	int (*get_ipv4) (struct connman_iface *iface,
-					struct connman_ipv4 *ipv4);
-	int (*set_ipv4) (struct connman_iface *iface,
-					struct connman_ipv4 *ipv4);
+
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
@@ -148,11 +146,12 @@ static inline void connman_iface_set_data(struct connman_iface *iface,
 	iface->driver_data = data;
 }
 
-extern int connman_iface_update(struct connman_iface *iface,
-					enum connman_iface_state state);
-
-extern void connman_iface_indicate_carrier(struct connman_iface *iface,
-							int carrier);
+extern void connman_iface_indicate_enabled(struct connman_iface *iface);
+extern void connman_iface_indicate_disabled(struct connman_iface *iface);
+extern void connman_iface_indicate_connected(struct connman_iface *iface);
+extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
+extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
+extern void connman_iface_indicate_configured(struct connman_iface *iface);
 
 extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index de74ce56..3c02abd8 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -94,8 +94,7 @@ static gboolean control_event(GIOChannel *chan,
 
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
 		printf("[SUPPLICANT] connected\n");
-		connman_iface_update(task->iface,
-					CONNMAN_IFACE_STATE_CARRIER);
+		connman_iface_indicate_connected(task->iface);
 	}
 
 	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
diff --git a/src/dhcp.c b/src/dhcp.c
index 36132244..ecf61f2b 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -63,15 +63,10 @@ int connman_dhcp_update(struct connman_iface *iface,
 
 		ipv4->method = CONNMAN_IPV4_METHOD_DHCP;
 
-		if (iface->driver->set_ipv4) {
-			iface->driver->set_ipv4(iface, ipv4);
-			iface->ipv4 = *ipv4;
-		} else {
-			connman_iface_set_ipv4(iface, ipv4);
-			iface->ipv4 = *ipv4;
-		}
-
-		connman_iface_update(iface, CONNMAN_IFACE_STATE_READY);
+		connman_iface_set_ipv4(iface, ipv4);
+		iface->ipv4 = *ipv4;
+
+		connman_iface_indicate_configured(iface);
 	}
 
 	return 0;
diff --git a/src/iface-helper.c b/src/iface-helper.c
index 4fe4b649..06642fb5 100644
--- a/src/iface-helper.c
+++ b/src/iface-helper.c
@@ -56,12 +56,16 @@ const char *__connman_iface_state2string(enum connman_iface_state state)
 		return "off";
 	case CONNMAN_IFACE_STATE_ENABLED:
 		return "enabled";
+	case CONNMAN_IFACE_STATE_SCANNING:
+		return "scanning";
 	case CONNMAN_IFACE_STATE_CONNECT:
 		return "connect";
-	case CONNMAN_IFACE_STATE_CONFIG:
-		return "config";
+	case CONNMAN_IFACE_STATE_CONNECTED:
+		return "connected";
 	case CONNMAN_IFACE_STATE_CARRIER:
 		return "carrier";
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+		return "configure";
 	case CONNMAN_IFACE_STATE_READY:
 		return "ready";
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
diff --git a/src/iface.c b/src/iface.c
index a6b0ba24..2e638663 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -95,51 +95,161 @@ void __connman_iface_list(DBusMessageIter *iter)
 	}
 }
 
-int connman_iface_update(struct connman_iface *iface,
-					enum connman_iface_state state)
+static void state_changed(struct connman_iface *iface)
 {
-	const char *str;
-
-	iface->state = state;
+	const char *str = __connman_iface_state2string(iface->state);
+	enum connman_iface_state state = iface->state;
 
-	str = __connman_iface_state2string(iface->state);
+	DBG("%s", str);
 
 	g_dbus_emit_signal(connection, iface->path,
 				CONNMAN_IFACE_INTERFACE, "StateChanged",
 				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
 
-	switch (state) {
+	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
 		__connman_dhcp_release(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
-			if (iface->driver->connect)
+			state = CONNMAN_IFACE_STATE_SCANNING;
+			if (iface->driver->connect) {
 				iface->driver->connect(iface, NULL);
+				state = CONNMAN_IFACE_STATE_CONNECT;
+			}
 		}
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
+		if (iface->policy == CONNMAN_IFACE_POLICY_AUTO)
+			state = CONNMAN_IFACE_STATE_CONFIGURE;
+		break;
+
+	case CONNMAN_IFACE_STATE_CONFIGURE:
 		__connman_dhcp_request(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
 		__connman_dhcp_release(iface);
-		if (iface->driver->shutdown)
-			iface->driver->shutdown(iface);
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+		if (iface->policy != CONNMAN_IFACE_POLICY_AUTO)
+			state = CONNMAN_IFACE_STATE_OFF;
 		break;
 
 	default:
 		break;
 	}
 
-	return 0;
+	if (iface->state != state) {
+		iface->state = state;
+		state_changed(iface);
+	}
+}
+
+static void switch_policy(struct connman_iface *iface)
+{
+	DBG("iface %p", iface);
+
+	switch (iface->policy) {
+	case CONNMAN_IFACE_POLICY_OFF:
+		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+		state_changed(iface);
+		__connman_iface_down(iface);
+		break;
+
+	case CONNMAN_IFACE_POLICY_IGNORE:
+		break;
+
+	case CONNMAN_IFACE_POLICY_AUTO:
+		__connman_iface_up(iface);
+		break;
+
+	default:
+		break;
+	}
 }
 
-void connman_iface_indicate_carrier(struct connman_iface *iface, int carrier)
+void connman_iface_indicate_enabled(struct connman_iface *iface)
 {
-	DBG("iface %p carrier %d", iface, carrier);
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_OFF:
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_disabled(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+	state_changed(iface);
+}
+
+void connman_iface_indicate_connected(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONNECT:
+		iface->state = CONNMAN_IFACE_STATE_CONNECTED;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_carrier_on(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_ENABLED:
+	case CONNMAN_IFACE_STATE_CONNECT:
+	case CONNMAN_IFACE_STATE_CONNECTED:
+		iface->state = CONNMAN_IFACE_STATE_CARRIER;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_carrier_off(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+	case CONNMAN_IFACE_STATE_READY:
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
+}
+
+void connman_iface_indicate_configured(struct connman_iface *iface)
+{
+	DBG("iface %p state %d", iface, iface->state);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+		iface->state = CONNMAN_IFACE_STATE_READY;
+		state_changed(iface);
+		break;
+	default:
+		break;
+	}
 }
 
 int connman_iface_get_ipv4(struct connman_iface *iface,
@@ -501,13 +611,7 @@ static DBusMessage *set_policy(DBusConnection *conn,
 		iface->policy = new_policy;
 		__connman_iface_store(iface);
 
-		if (new_policy == CONNMAN_IFACE_POLICY_AUTO) {
-			if (iface->driver->activate)
-				iface->driver->activate(iface);
-		} else
-			connman_iface_update(iface,
-					CONNMAN_IFACE_STATE_SHUTDOWN);
-
+		switch_policy(iface);
 		policy = __connman_iface_policy2string(new_policy);
 
 		g_dbus_emit_signal(conn, iface->path, CONNMAN_IFACE_INTERFACE,
@@ -908,10 +1012,7 @@ static int probe_device(LibHalContext *ctx,
 	interfaces = g_slist_append(interfaces, iface);
 
 	if (iface->flags & CONNMAN_IFACE_FLAG_IPV4) {
-		if (driver->get_ipv4)
-			driver->get_ipv4(iface, &iface->ipv4);
-		else
-			connman_iface_get_ipv4(iface, &iface->ipv4);
+		connman_iface_get_ipv4(iface, &iface->ipv4);
 
 		DBG("address %s", inet_ntoa(iface->ipv4.address));
 	}
@@ -928,10 +1029,7 @@ static int probe_device(LibHalContext *ctx,
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
-	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
-		if (driver->activate)
-			driver->activate(iface);
-	}
+	switch_policy(iface);
 
 	return 0;
 }
diff --git a/src/rtnl.c b/src/rtnl.c
index fd61d0dc..3e26dbff 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -37,6 +37,21 @@
 
 #include "connman.h"
 
+struct rtnl_data {
+	unsigned ifi_flags;
+};
+
+static struct rtnl_data *get_rtnl_data(struct connman_iface *iface)
+{
+	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+		return NULL;
+
+	if (iface->rtnl_data == NULL)
+		iface->rtnl_data = g_try_new0(struct rtnl_data, 1);
+
+	return iface->rtnl_data;
+}
+
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
 {
 	if (family == AF_INET) {
@@ -72,6 +87,7 @@ static inline void print_attr(struct rtattr *attr, const char *name)
 static void rtnl_link(struct nlmsghdr *hdr)
 {
 	struct connman_iface *iface;
+	struct rtnl_data *data;
 	struct ifinfomsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -85,17 +101,26 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	if (iface == NULL)
 		return;
 
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+	data = get_rtnl_data(iface);
+	if (data == NULL)
 		return;
 
-	if (iface->carrier != ((msg->ifi_flags & IFF_RUNNING) != 0)) {
-		iface->carrier = ((msg->ifi_flags & IFF_RUNNING) != 0);
-		if (iface->driver->rtnl_carrier)
-			iface->driver->rtnl_carrier(iface, iface->carrier);
+	if ((data->ifi_flags & IFF_RUNNING) != (msg->ifi_flags & IFF_RUNNING)) {
+		if (msg->ifi_flags & IFF_RUNNING)
+			connman_iface_indicate_carrier_on(iface);
 		else
-			connman_iface_indicate_carrier(iface, iface->carrier);
+			connman_iface_indicate_carrier_off(iface);
 	}
 
+	if ((data->ifi_flags & IFF_UP) != (msg->ifi_flags & IFF_UP)) {
+		if (msg->ifi_flags & IFF_UP)
+			connman_iface_indicate_enabled(iface);
+		else
+			connman_iface_indicate_disabled(iface);
+	}
+
+	data->ifi_flags = msg->ifi_flags;
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
@@ -162,6 +187,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 static void rtnl_addr(struct nlmsghdr *hdr)
 {
 	struct connman_iface *iface;
+	struct rtnl_data *data;
 	struct ifaddrmsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -175,7 +201,8 @@ static void rtnl_addr(struct nlmsghdr *hdr)
 	if (iface == NULL)
 		return;
 
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
+	data = get_rtnl_data(iface);
+	if (data == NULL)
 		return;
 
 	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
@@ -328,10 +355,8 @@ static gboolean netlink_event(GIOChannel *chan,
 	gsize len;
 	GIOError err;
 
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR)) {
-		g_io_channel_unref(chan);
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
 		return FALSE;
-	}
 
 	memset(buf, 0, sizeof(buf));
 
@@ -339,7 +364,6 @@ static gboolean netlink_event(GIOChannel *chan,
 	if (err) {
 		if (err == G_IO_ERROR_AGAIN)
 			return TRUE;
-		g_io_channel_unref(chan);
 		return FALSE;
 	}
 
@@ -394,8 +418,6 @@ int __connman_rtnl_init(void)
 			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
 						netlink_event, NULL);
 
-	g_io_channel_unref(channel);
-
 	return 0;
 }
 
@@ -403,6 +425,7 @@ void __connman_rtnl_cleanup(void)
 {
 	DBG("");
 
+	g_io_channel_shutdown(channel, TRUE, NULL);
 	g_io_channel_unref(channel);
 
 	channel = NULL;

commit d9bc76c98cfd933d365bdfb7b5fcfc5061aa6fb8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 06:25:40 2008 +0100

    Release DHCP lease when carrier off

diff --git a/src/iface.c b/src/iface.c
index 2e638663..ec790ade 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -112,6 +112,7 @@ static void state_changed(struct connman_iface *iface)
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
+		__connman_dhcp_release(iface);
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			state = CONNMAN_IFACE_STATE_SCANNING;
 			if (iface->driver->connect) {

commit 5554ad583523b6bea46c104999e1b5b00102594a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 14 07:24:03 2008 +0100

    Remove IP addresses on shutdown and fix carrier detect

diff --git a/src/iface.c b/src/iface.c
index ec790ade..c3ca6e2b 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -100,7 +100,7 @@ static void state_changed(struct connman_iface *iface)
 	const char *str = __connman_iface_state2string(iface->state);
 	enum connman_iface_state state = iface->state;
 
-	DBG("%s", str);
+	DBG("iface %p state %s", iface, str);
 
 	g_dbus_emit_signal(connection, iface->path,
 				CONNMAN_IFACE_INTERFACE, "StateChanged",
@@ -113,6 +113,7 @@ static void state_changed(struct connman_iface *iface)
 
 	case CONNMAN_IFACE_STATE_ENABLED:
 		__connman_dhcp_release(iface);
+		connman_iface_clear_ipv4(iface);
 		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
 			state = CONNMAN_IFACE_STATE_SCANNING;
 			if (iface->driver->connect) {
@@ -157,6 +158,7 @@ static void switch_policy(struct connman_iface *iface)
 	case CONNMAN_IFACE_POLICY_OFF:
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 		state_changed(iface);
+		connman_iface_clear_ipv4(iface);
 		__connman_iface_down(iface);
 		break;
 
@@ -165,6 +167,7 @@ static void switch_policy(struct connman_iface *iface)
 
 	case CONNMAN_IFACE_POLICY_AUTO:
 		__connman_iface_up(iface);
+		state_changed(iface);
 		break;
 
 	default:
@@ -178,6 +181,7 @@ void connman_iface_indicate_enabled(struct connman_iface *iface)
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
+	case CONNMAN_IFACE_STATE_CARRIER:
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
@@ -229,6 +233,7 @@ void connman_iface_indicate_carrier_off(struct connman_iface *iface)
 	DBG("iface %p state %d", iface, iface->state);
 
 	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CARRIER:
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 	case CONNMAN_IFACE_STATE_READY:
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;

commit b6af353282ffb3a90f9cce4aa408ac2347117f11
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 16 03:33:04 2008 +0100

    Report found networks and send out updates

diff --git a/plugins/80211.c b/plugins/80211.c
index 3327d107..a94551dd 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -64,6 +64,16 @@ struct iface_data {
 	gchar *passphrase;
 };
 
+static void report_station(struct connman_iface *iface,
+						struct station_data *station)
+{
+	if (station == NULL)
+		return;
+
+	if (station->name)
+		connman_iface_indicate_station(iface, station->name);
+}
+
 static struct station_data *create_station(struct iface_data *iface,
 							const char *address)
 {
@@ -339,6 +349,7 @@ static void parse_scan_results(struct connman_iface *iface,
 
 		switch (event->cmd) {
 		case SIOCGIWAP:
+			report_station(iface, station);
 			eth = (void *) &event->u.ap_addr.sa_data;
 			sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
 						eth->ether_addr_octet[0],
@@ -401,6 +412,8 @@ static void parse_scan_results(struct connman_iface *iface,
 		len -= event->len;
 	}
 
+	report_station(iface, station);
+
 	printf("[802.11] found %d networks\n", num);
 }
 
diff --git a/src/iface.c b/src/iface.c
index c3ca6e2b..1662fb7a 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -95,6 +95,37 @@ void __connman_iface_list(DBusMessageIter *iter)
 	}
 }
 
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
 static void state_changed(struct connman_iface *iface)
 {
 	const char *str = __connman_iface_state2string(iface->state);
@@ -258,6 +289,40 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	}
 }
 
+static void append_station(DBusMessage *reply, const char *name)
+{
+	DBusMessageIter array, dict;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
+
+	dbus_message_iter_close_container(&array, &dict);
+}
+
+void connman_iface_indicate_station(struct connman_iface *iface,
+							const char *name)
+{
+	DBusMessage *signal;
+
+	DBG("iface %p name %s", iface, name);
+
+	signal = dbus_message_new_signal(iface->path,
+				CONNMAN_IFACE_INTERFACE, "NetworkFound");
+	if (signal == NULL)
+		return;
+
+	append_station(signal, name);
+
+	dbus_connection_send(connection, signal, NULL);
+	dbus_message_unref(signal);
+}
+
 int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4)
 {
@@ -443,37 +508,6 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	return reply;
 }
 
-static void append_entry(DBusMessageIter *dict,
-				const char *key, int type, void *val)
-{
-	DBusMessageIter entry, value;
-	const char *signature;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	switch (type) {
-	case DBUS_TYPE_STRING:
-		signature = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT16:
-		signature = DBUS_TYPE_UINT16_AS_STRING;
-		break;
-	default:
-		signature = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							signature, &value);
-	dbus_message_iter_append_basic(&value, type, val);
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -895,6 +929,7 @@ static GDBusSignalTable iface_signals[] = {
 	{ "StateChanged",   "s"     },
 	{ "SignalChanged",  "q"     },
 	{ "PolicyChanged",  "s"     },
+	{ "NetworkFound",   "a{sv}" },
 	{ "NetworkChanged", "a{sv}" },
 	{ "IPv4Changed",    "a{sv}" },
 	{ },

commit 199daf70bac7eb1d2d7fdafc66b2a1baba188bdc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 16 06:59:22 2008 +0100

    Include signal strength for reported networks

diff --git a/include/iface.h b/include/iface.h
index 57a4d72e..6a80178a 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -153,6 +153,9 @@ extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
 extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
 extern void connman_iface_indicate_configured(struct connman_iface *iface);
 
+extern void connman_iface_indicate_station(struct connman_iface *iface,
+						const char *name, int strength);
+
 extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
 extern int connman_iface_set_ipv4(struct connman_iface *iface,
diff --git a/plugins/80211.c b/plugins/80211.c
index a94551dd..53b36b60 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -70,8 +70,10 @@ static void report_station(struct connman_iface *iface,
 	if (station == NULL)
 		return;
 
-	if (station->name)
-		connman_iface_indicate_station(iface, station->name);
+	if (station->name == NULL)
+		return;
+
+	connman_iface_indicate_station(iface, station->name, station->qual);
 }
 
 static struct station_data *create_station(struct iface_data *iface,
diff --git a/src/iface.c b/src/iface.c
index 1662fb7a..a412dab4 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -289,7 +289,7 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	}
 }
 
-static void append_station(DBusMessage *reply, const char *name)
+static void append_station(DBusMessage *reply, const char *name, int signal)
 {
 	DBusMessageIter array, dict;
 
@@ -301,12 +301,13 @@ static void append_station(DBusMessage *reply, const char *name)
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
 	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
+	append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
 
 	dbus_message_iter_close_container(&array, &dict);
 }
 
 void connman_iface_indicate_station(struct connman_iface *iface,
-							const char *name)
+						const char *name, int strength)
 {
 	DBusMessage *signal;
 
@@ -317,7 +318,7 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	if (signal == NULL)
 		return;
 
-	append_station(signal, name);
+	append_station(signal, name, strength);
 
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);

commit 7aac03f81d1a9e3d0e5c476b22ca883f839e6d1c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 24 12:07:55 2008 +0100

    Add skeleton for agent infrastructure

diff --git a/src/Makefile.am b/src/Makefile.am
index 4da752e5..1a09a0f8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,7 +5,7 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h manager.c plugin.c \
+connmand_SOURCES = main.c connman.h manager.c agent.c plugin.c \
 			iface.c iface-storage.c iface-helper.c \
 					iface-inet.c rtnl.c dhcp.c
 
diff --git a/src/agent.c b/src/agent.c
new file mode 100644
index 00000000..d3a27463
--- /dev/null
+++ b/src/agent.c
@@ -0,0 +1,52 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+int __connman_agent_init(void)
+{
+	DBG("");
+
+	return 0;
+}
+
+void __connman_agent_cleanup(void)
+{
+	DBG("");
+}
+
+int __connman_agent_register(const char *path)
+{
+	DBG("");
+
+	return 0;
+}
+
+int __connman_agent_unregister(const char *path)
+{
+	DBG("");
+
+	return 0;
+}
diff --git a/src/connman.h b/src/connman.h
index 8756034c..ff33489e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -42,6 +42,12 @@
 int __connman_manager_init(DBusConnection *conn, int compat);
 void __connman_manager_cleanup(void);
 
+int __connman_agent_init(void);
+void __connman_agent_cleanup(void);
+
+int __connman_agent_register(const char *path);
+int __connman_agent_unregister(const char *path);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/main.c b/src/main.c
index 8de7fbed..1b314db8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -120,6 +120,8 @@ int main(int argc, char *argv[])
 			compat = 0;
 	}
 
+	__connman_agent_init();
+
 	__connman_manager_init(conn, compat);
 
 	__connman_plugin_init();
@@ -143,6 +145,8 @@ int main(int argc, char *argv[])
 
 	__connman_manager_cleanup();
 
+	__connman_agent_cleanup();
+
 	g_dbus_cleanup_connection(conn);
 
 	g_main_loop_unref(main_loop);
diff --git a/src/manager.c b/src/manager.c
index b11d805e..2a1a738f 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -70,9 +70,55 @@ static DBusMessage *get_state(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *register_agent(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	__connman_agent_register(path);
+
+	return reply;
+}
+
+static DBusMessage *unregister_agent(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	__connman_agent_unregister(path);
+
+	return reply;
+}
+
 static GDBusMethodTable manager_methods[] = {
-	{ "ListInterfaces", "", "ao", list_interfaces },
-	{ "GetState",       "", "s",  get_state       },
+	{ "ListInterfaces",  "",  "ao", list_interfaces  },
+	{ "GetState",        "",  "s",  get_state        },
+	{ "RegisterAgent",   "o", "",   register_agent   },
+	{ "UnregisterAgent", "o", "",   unregister_agent },
 	{ },
 };
 

commit 6908741e0b2291a32ae9aafe556f2a021e23c5af
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 24 14:05:43 2008 +0100

    Add directory for example applications

diff --git a/Makefile.am b/Makefile.am
index 52247b98..de0e19be 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src plugins scripts
+SUBDIRS = include src test plugins scripts
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index 0cbb0ad9..a5991e4d 100644
--- a/configure.in
+++ b/configure.in
@@ -61,5 +61,5 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile
-			plugins/Makefile scripts/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile test/Makefile
+				plugins/Makefile scripts/Makefile)
diff --git a/test/Makefile.am b/test/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/test/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in

commit 99983be83b0f1c0ecbce00276fd21ba05b4d681f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 24 15:01:28 2008 +0100

    Add handling for agent registration and monitoring

diff --git a/src/agent.c b/src/agent.c
index d3a27463..4765868d 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -23,30 +23,100 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <gdbus.h>
+
 #include "connman.h"
 
-int __connman_agent_init(void)
+static DBusConnection *connection = NULL;
+static guint agent_watch = 0;
+static gchar *agent_path = NULL;
+static gchar *agent_sender = NULL;
+
+static void agent_free(void)
 {
-	DBG("");
+	agent_watch = 0;
 
-	return 0;
+	g_free(agent_sender);
+	agent_sender = NULL;
+
+	g_free(agent_path);
+	agent_path = NULL;
 }
 
-void __connman_agent_cleanup(void)
+static gboolean agent_disconnect(void *data)
+{
+	DBG("data %p", data);
+
+	agent_free();
+
+	return TRUE;
+}
+
+int __connman_agent_register(const char *sender, const char *path)
 {
-	DBG("");
+	DBG("sender %s path %s", sender, path);
+
+	if (agent_path != NULL)
+		return -EEXIST;
+
+	agent_sender = g_strdup(sender);
+	agent_path = g_strdup(path);
+
+	agent_watch = g_dbus_add_disconnect_watch(connection, sender,
+						agent_disconnect, NULL, NULL);
+
+	return 0;
 }
 
-int __connman_agent_register(const char *path)
+int __connman_agent_unregister(const char *sender, const char *path)
 {
-	DBG("");
+	DBG("sender %s path %s", sender, path);
+
+	if (agent_path == NULL)
+		return -ENOENT;
+
+	if (agent_watch > 0)
+		g_dbus_remove_watch(connection, agent_watch);
+
+	agent_free();
 
 	return 0;
 }
 
-int __connman_agent_unregister(const char *path)
+int __connman_agent_init(DBusConnection *conn)
 {
-	DBG("");
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
 
 	return 0;
 }
+
+void __connman_agent_cleanup(void)
+{
+	DBusMessage *msg;
+
+	DBG("conn %p", connection);
+
+	if (agent_watch > 0)
+		g_dbus_remove_watch(connection, agent_watch);
+
+	msg = dbus_message_new_method_call(agent_sender, agent_path,
+					CONNMAN_AGENT_INTERFACE, "Release");
+
+	dbus_message_set_no_reply(msg, TRUE);
+
+	dbus_connection_send(connection, msg, NULL);
+
+	dbus_message_unref(msg);
+
+	agent_free();
+
+	dbus_connection_unref(connection);
+}
diff --git a/src/connman.h b/src/connman.h
index ff33489e..703b8c9c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -28,6 +28,8 @@
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
+#define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
+
 #define CONNMAN_MANAGER_PATH       "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 
@@ -42,11 +44,11 @@
 int __connman_manager_init(DBusConnection *conn, int compat);
 void __connman_manager_cleanup(void);
 
-int __connman_agent_init(void);
+int __connman_agent_init(DBusConnection *conn);
 void __connman_agent_cleanup(void);
 
-int __connman_agent_register(const char *path);
-int __connman_agent_unregister(const char *path);
+int __connman_agent_register(const char *sender, const char *path);
+int __connman_agent_unregister(const char *sender, const char *path);
 
 #include <connman/plugin.h>
 
diff --git a/src/main.c b/src/main.c
index 1b314db8..a54eaf6b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -120,7 +120,7 @@ int main(int argc, char *argv[])
 			compat = 0;
 	}
 
-	__connman_agent_init();
+	__connman_agent_init(conn);
 
 	__connman_manager_init(conn, compat);
 
diff --git a/src/manager.c b/src/manager.c
index 2a1a738f..11c25572 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -74,10 +74,12 @@ static DBusMessage *register_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *path;
+	const char *sender, *path;
 
 	DBG("conn %p", conn);
 
+	sender = dbus_message_get_sender(msg);
+
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
 
@@ -87,7 +89,7 @@ static DBusMessage *register_agent(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	__connman_agent_register(path);
+	__connman_agent_register(sender, path);
 
 	return reply;
 }
@@ -96,10 +98,12 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *path;
+	const char *sender, *path;
 
 	DBG("conn %p", conn);
 
+	sender = dbus_message_get_sender(msg);
+
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
 
@@ -109,7 +113,7 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	__connman_agent_unregister(path);
+	__connman_agent_unregister(sender, path);
 
 	return reply;
 }

commit 97697ebc4f19a72938252ea856d9e13a043ce0d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 16:10:56 2008 +0100

    Add documentation directory

diff --git a/Makefile.am b/Makefile.am
index de0e19be..35d8c884 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src test plugins scripts
+SUBDIRS = include src doc test plugins scripts
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
diff --git a/configure.in b/configure.in
index a5991e4d..9ecec4d6 100644
--- a/configure.in
+++ b/configure.in
@@ -61,5 +61,5 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile test/Makefile
-				plugins/Makefile scripts/Makefile)
+AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
+					plugins/Makefile scripts/Makefile)
diff --git a/doc/Makefile.am b/doc/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/doc/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in

commit 439bdfd6882e3632a4fe67f0d19801524a1c7d8d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 16:34:54 2008 +0100

    Add manager documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 02742923..fadc659d 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,2 +1,4 @@
 
+EXTRA_DIST = manager-api.txt
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
new file mode 100644
index 00000000..0d5fbfb8
--- /dev/null
+++ b/doc/manager-api.txt
@@ -0,0 +1,47 @@
+Manager hierarchy
+*****************
+
+Service name	org.freedesktop.connman
+Interface name	org.freedesktop.connman.Manager
+Object path	/
+
+Methods		array{object} ListInterfaces()
+		void RegisterAgent(object path)
+		void UnregisterAgent(object path)
+
+Signals		InterfaceAdded(object)
+		InterfaceRemoved(object)
+
+
+Method: ListInferfaces
+======================
+This method lists all available interfaces. The return value is an array of
+object paths. Every attached network interface (eth0, wlan0 etc.) of the
+system is presented by an object path with additional interfaces on it. The
+main interface is org.freedesktop.connman.Interface.
+
+Method: RegisterAgent
+=====================
+This method allows the user interace to register an agent. There can be only
+one agent registered at a time. The parameter of the method is the object
+path the agent has been registered for the callback method. The agent has
+to implement org.freedesktop.connman.Agent interface on this object path.
+
+Method: UnregisterAgent
+=======================
+This method unregisters a previously registered agent. In case the agent
+application exits the core will automatically unregister the agent. However
+for a clean agent application it is important to call the unregister method.
+
+Signal: InterfaceAdded
+======================
+This signal is emitted every time a new interface has been found by the
+core and successfully activated. The signal is also emitted on startup
+or at anytime at runtime in case of hotplug devices.
+
+Signal: InterfaceRemoved
+========================
+This signal is emitted every time an interface has been removed. This can
+happen at any time in case of hotplug devices. When the system shuts down,
+this signal is also emitted.
+

commit 2eed628fda87ad562d765c87a2d8330ee707ca3a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 19:18:50 2008 +0100

    Add initial interface documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index fadc659d..33cc0bdd 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt
+EXTRA_DIST = manager-api.txt interface-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/interface-api.txt b/doc/interface-api.txt
new file mode 100644
index 00000000..1b0d468a
--- /dev/null
+++ b/doc/interface-api.txt
@@ -0,0 +1,24 @@
+Interface hierarchy
+*******************
+
+Service name	org.freedesktop.connman
+Interface name	org.freedesktop.connman.Interface
+Object path	[interface object]
+
+Methods		dict GetProperties()
+		string GetState()
+		uint16 GetSignal()
+		string GetPolicy()
+		void SetPolicy(string policy)
+		dict GetNetwork()
+		void SetNetwork(dict network)
+		dict GetIPv4()
+		void SetIPv4(dict ipv4)
+
+Signals		StateChanged(string state)
+		SignalChanged(uint16 signal)
+		PolicyChanged(string policy)
+		NetworkFound(dict network)
+		NetworkChanged(dict network)
+		IPv4Changed(dict ipv4)
+

commit b627f1b548160dd36aa2edcb98aae210f483babe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 19:26:48 2008 +0100

    Add agent documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 33cc0bdd..04bffe2b 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt interface-api.txt
+EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/agent-api.txt b/doc/agent-api.txt
new file mode 100644
index 00000000..6a805e8d
--- /dev/null
+++ b/doc/agent-api.txt
@@ -0,0 +1,18 @@
+Agent hierarchy
+***************
+
+Service name	[unique name]
+Interface name	org.freedesktop.connman.Agent
+Object path	[random object]
+
+Methods		void Release()
+
+
+Method: Release
+===============
+This method will be called when the core releases the agent. This normally
+happens when the core shuts down.
+
+To get notified when the core exits, an agent should also watch out for the
+NameOwnerChanged from org.freedesktop.connman service.
+

commit cce41dad8e37117fa45bbc8e40f7c866612c6500
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 30 19:27:54 2008 +0100

    Remove last empty lines

diff --git a/doc/agent-api.txt b/doc/agent-api.txt
index 6a805e8d..27bd3219 100644
--- a/doc/agent-api.txt
+++ b/doc/agent-api.txt
@@ -15,4 +15,3 @@ happens when the core shuts down.
 
 To get notified when the core exits, an agent should also watch out for the
 NameOwnerChanged from org.freedesktop.connman service.
-
diff --git a/doc/interface-api.txt b/doc/interface-api.txt
index 1b0d468a..faee2033 100644
--- a/doc/interface-api.txt
+++ b/doc/interface-api.txt
@@ -21,4 +21,3 @@ Signals		StateChanged(string state)
 		NetworkFound(dict network)
 		NetworkChanged(dict network)
 		IPv4Changed(dict ipv4)
-
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 0d5fbfb8..9de15c30 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -44,4 +44,3 @@ Signal: InterfaceRemoved
 This signal is emitted every time an interface has been removed. This can
 happen at any time in case of hotplug devices. When the system shuts down,
 this signal is also emitted.
-

commit d9e03f2642a100bad7aeb290f68293abba21be2a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 18 22:45:31 2008 +0100

    Update for libgdbus API change

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index cc5efd86..211b84ef 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -279,7 +279,7 @@ static DBusConnection *connection;
 
 static int plugin_init(void)
 {
-	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL);
+	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL, NULL);
 
 	busname = dbus_bus_get_unique_name(connection);
 
diff --git a/src/main.c b/src/main.c
index a54eaf6b..0fcf614d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -68,6 +68,7 @@ static struct option options[] = {
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
+	DBusError err;
 	struct sigaction sa;
 	int log_option = LOG_NDELAY | LOG_PID;
 	int opt, detach = 1, compat = 0;
@@ -109,14 +110,20 @@ int main(int argc, char *argv[])
 
 	main_loop = g_main_loop_new(NULL, FALSE);
 
-	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE);
+	dbus_error_init(&err);
+
+	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE, &err);
 	if (conn == NULL) {
-		fprintf(stderr, "Can't register with system bus\n");
+		if (dbus_error_is_set(&err) == TRUE) {
+			fprintf(stderr, "%s\n", err.message);
+			dbus_error_free(&err);
+		} else
+			fprintf(stderr, "Can't register with system bus\n");
 		exit(1);
 	}
 
 	if (compat) {
-		if (g_dbus_request_name(conn, NM_SERVICE) == FALSE)
+		if (g_dbus_request_name(conn, NM_SERVICE, NULL) == FALSE)
 			compat = 0;
 	}
 

commit 5892fc367065eb79210359008da69887322327fa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 18 22:48:34 2008 +0100

    Fix 32-bit/64-bit format string issues

diff --git a/src/rtnl.c b/src/rtnl.c
index 3e26dbff..952f09b3 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -57,30 +57,30 @@ static inline void print_inet(struct rtattr *attr, const char *name, int family)
 	if (family == AF_INET) {
 		struct in_addr addr;
 		addr = *((struct in_addr *) RTA_DATA(attr));
-		printf("  attr %s (len %d) %s\n",
+		printf("  attr %s (len %jd) %s\n",
 				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
 	} else
-		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
+		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 }
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
+	printf("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_byte(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %d) 0x%02x\n", name, RTA_PAYLOAD(attr),
+	printf("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
 					*((unsigned char *) RTA_DATA(attr)));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		printf("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
+		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 	else
-		printf("  attr %d (len %d)\n",
+		printf("  attr %d (len %jd)\n",
 					attr->rta_type, RTA_PAYLOAD(attr));
 }
 
@@ -286,7 +286,7 @@ static void rtnl_route(struct nlmsghdr *hdr)
 
 static void rtnl_message(void *buf, size_t len)
 {
-	DBG("buf %p len %d", buf, len);
+	DBG("buf %p len %zd", buf, len);
 
 	while (len > 0) {
 		struct nlmsghdr *hdr = buf;
@@ -379,7 +379,7 @@ int __connman_rtnl_send(const void *buf, size_t len)
 	struct sockaddr_nl addr;
 	int sk;
 
-	DBG("buf %p len %d", buf, len);
+	DBG("buf %p len %zd", buf, len);
 
 	sk = g_io_channel_unix_get_fd(channel);
 

commit 828ad7d4f5f678c2c92b9400a58f62bfaa0cd64f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 20 03:08:15 2008 +0100

    Add .gitignore file

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..f29ae7f0
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,26 @@
+*.o
+*.lo
+*.la
+.deps
+.libs
+Makefile
+Makefile.in
+aclocal.m4
+config.guess
+config.h
+config.h.in
+config.log
+config.status
+config.sub
+configure
+depcomp
+install-sh
+libtool
+ltmain.sh
+missing
+stamp-h1
+autom4te.cache
+
+include/connman
+src/connmand
+scripts/dhclient-script

commit 84deb674a0c3511dd4eee17d47ca07a4f51ba396
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 22 05:36:19 2008 +0100

    Add basic init script

diff --git a/.gitignore b/.gitignore
index f29ae7f0..d2429679 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,4 +23,5 @@ autom4te.cache
 
 include/connman
 src/connmand
+scripts/connman
 scripts/dhclient-script
diff --git a/configure.in b/configure.in
index 9ecec4d6..0c61409f 100644
--- a/configure.in
+++ b/configure.in
@@ -62,4 +62,4 @@ AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
-					plugins/Makefile scripts/Makefile)
+			plugins/Makefile scripts/Makefile scripts/connman)
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index bb79358e..1247398f 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -1,4 +1,10 @@
 
+initdir = $(sysconfdir)/init.d
+
+init_SCRIPTS = connman
+
+DISTCLEANFILES = $(init_SCRIPTS)
+
 scriptdir = $(libdir)/connman/scripts
 
 script_DATA = dhclient.conf
diff --git a/scripts/connman.in b/scripts/connman.in
new file mode 100644
index 00000000..a67f6673
--- /dev/null
+++ b/scripts/connman.in
@@ -0,0 +1,49 @@
+#!/bin/sh
+
+DAEMON=@prefix@/sbin/connmand
+PIDFILE=@localstatedir@/run/connmand.pid
+DESC="Connection Manager"
+
+. /lib/lsb/init-functions
+
+if [ -f @sysconfdir@/default/connman ] ; then
+	. @sysconfdir@/default/connman
+fi
+
+set -e
+
+do_start() {
+	start-stop-daemon --start --oknodo \
+		--pidfile $PIDFILE --exec $DAEMON -- $DAEMON_OPTS
+}
+
+do_stop() {
+	start-stop-daemon --stop --oknodo --quiet \
+		--pidfile $PIDFILE --exec $DAEMON
+}
+
+case "$1" in
+  start)
+	log_daemon_msg "Starting $DESC"
+	do_start
+	log_end_msg $?
+	;;
+  stop)
+	log_daemon_msg "Stopping $DESC"
+	do_stop
+	log_end_msg $?
+	;;
+  restart|force-reload)
+	log_daemon_msg "Restarting $DESC"
+	do_stop
+	sleep 1
+	do_start
+	log_end_msg $?
+	;;
+  *)
+	log_success_msg "Usage: $0 {start|stop|restart|force-reload}" >&2
+	exit 1
+	;;
+esac
+
+exit 0

commit dafd72419a43e2b5a0243d4b61372ca83747883f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 22 08:42:19 2008 +0100

    Add logging infrastructure

diff --git a/include/Makefile.am b/include/Makefile.am
index 2d28a822..ecca9287 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = plugin.h iface.h rtnl.h dhcp.h
+noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/log.h b/include/log.h
new file mode 100644
index 00000000..e87e38ad
--- /dev/null
+++ b/include/log.h
@@ -0,0 +1,39 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_LOG_H
+#define __CONNMAN_LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DBG(fmt, arg...) connman_debug(fmt, ## arg)
+
+extern void connman_info(const char *format, ...);
+extern void connman_error(const char *format, ...);
+extern void connman_debug(const char *format, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_LOG_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 1a09a0f8..516c1b8b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,9 +5,9 @@ dbus_DATA = connman.conf
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h manager.c agent.c plugin.c \
-			iface.c iface-storage.c iface-helper.c \
-					iface-inet.c rtnl.c dhcp.c
+connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
+				iface.c iface-storage.c iface-helper.c \
+						iface-inet.c rtnl.c dhcp.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index 703b8c9c..da1693b1 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -21,9 +21,6 @@
 
 #include <stdio.h>
 
-#define DBG(fmt, arg...)  printf("%s: " fmt "\n" , __FUNCTION__ , ## arg)
-//#define DBG(fmt, arg...)
-
 #include <dbus/dbus.h>
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
@@ -50,6 +47,11 @@ void __connman_agent_cleanup(void);
 int __connman_agent_register(const char *sender, const char *path);
 int __connman_agent_unregister(const char *sender, const char *path);
 
+#include <connman/log.h>
+
+int __connman_log_init(int syslog, int debug);
+void __connman_log_cleanup(void);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/log.c b/src/log.c
new file mode 100644
index 00000000..867928ce
--- /dev/null
+++ b/src/log.c
@@ -0,0 +1,90 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdarg.h>
+#include <syslog.h>
+
+#include "connman.h"
+
+static volatile int debug_enabled = 0;
+
+void connman_info(const char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+
+	vsyslog(LOG_INFO, format, ap);
+
+	va_end(ap);
+}
+
+void connman_error(const char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+
+	vsyslog(LOG_ERR, format, ap);
+
+	va_end(ap);
+}
+
+void connman_debug(const char *format, ...)
+{
+	va_list ap;
+
+	if (!debug_enabled)
+		return;
+
+	va_start(ap, format);
+
+	vsyslog(LOG_DEBUG, format, ap);
+
+	va_end(ap);
+}
+
+int __connman_log_init(int syslog, int debug)
+{
+	int option = LOG_NDELAY | LOG_PID;
+
+	if (!syslog)
+		option |= LOG_PERROR;
+
+	openlog("connmand", option, LOG_DAEMON);
+
+	syslog(LOG_INFO, "Connection Manager version %s", VERSION);
+
+	debug_enabled = debug;
+
+	return 0;
+}
+
+void __connman_log_cleanup(void)
+{
+	syslog(LOG_INFO, "Exit");
+
+	closelog();
+}
diff --git a/src/main.c b/src/main.c
index 0fcf614d..a4962b2a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -27,7 +27,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
-#include <syslog.h>
 #include <signal.h>
 #include <getopt.h>
 #include <sys/stat.h>
@@ -61,6 +60,7 @@ static void usage(void)
 static struct option options[] = {
 	{ "nodaemon", 0, 0, 'n' },
 	{ "compat",   0, 0, 'c' },
+	{ "debug",    0, 0, 'd' },
 	{ "help",     0, 0, 'h' },
 	{ }
 };
@@ -70,17 +70,19 @@ int main(int argc, char *argv[])
 	DBusConnection *conn;
 	DBusError err;
 	struct sigaction sa;
-	int log_option = LOG_NDELAY | LOG_PID;
-	int opt, detach = 1, compat = 0;
+	int opt, detach = 1, compat = 0, debug = 0;
 
-	while ((opt = getopt_long(argc, argv, "+nch", options, NULL)) != EOF) {
-		switch(opt) {
+	while ((opt = getopt_long(argc, argv, "+ncdh", options, NULL)) != EOF) {
+		switch (opt) {
 		case 'n':
 			detach = 0;
 			break;
 		case 'c':
 			compat = 1;
 			break;
+		case 'd':
+			debug = 1;
+			break;
 		case 'h':
 		default:
 			usage();
@@ -97,10 +99,7 @@ int main(int argc, char *argv[])
 			perror("Can't start daemon");
 			exit(1);
 		}
-	} else
-		log_option |= LOG_PERROR;
-
-	openlog("connmand", log_option, LOG_DAEMON);
+	}
 
 	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
@@ -127,6 +126,8 @@ int main(int argc, char *argv[])
 			compat = 0;
 	}
 
+	__connman_log_init(detach, debug);
+
 	__connman_agent_init(conn);
 
 	__connman_manager_init(conn, compat);
@@ -154,6 +155,8 @@ int main(int argc, char *argv[])
 
 	__connman_agent_cleanup();
 
+	__connman_log_cleanup();
+
 	g_dbus_cleanup_connection(conn);
 
 	g_main_loop_unref(main_loop);
@@ -162,7 +165,5 @@ int main(int argc, char *argv[])
 
 	rmdir(STATEDIR);
 
-	closelog();
-
 	return 0;
 }

commit 46a64b472133cce416bd49e00a2cd3c7a2bd7c53
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 05:26:36 2008 +0100

    Include function name in debug message

diff --git a/include/log.h b/include/log.h
index e87e38ad..bf0dab50 100644
--- a/include/log.h
+++ b/include/log.h
@@ -26,7 +26,7 @@
 extern "C" {
 #endif
 
-#define DBG(fmt, arg...) connman_debug(fmt, ## arg)
+#define DBG(fmt, arg...) connman_debug("%s: " fmt, __FUNCTION__ , ## arg)
 
 extern void connman_info(const char *format, ...);
 extern void connman_error(const char *format, ...);

commit aa987a9aea8a69d172bee003261abe7859a5ad7d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 05:29:33 2008 +0100

    Detect bridge interfaces and ignore them

diff --git a/plugins/80203.c b/plugins/80203.c
index d916c970..b4d67457 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -24,14 +24,24 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
+#include <sys/stat.h>
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
 
 static int iface_probe(struct connman_iface *iface)
 {
+	char sysfs_path[PATH_MAX];
+	struct stat st;
+
 	printf("[802.03] probe interface index %d\n", iface->index);
 
+	snprintf(sysfs_path, PATH_MAX, "%s/bridge", iface->sysfs);
+
+	if (stat(sysfs_path, &st) == 0 && (st.st_mode & S_IFDIR))
+		return -ENODEV;
+
 	iface->type = CONNMAN_IFACE_TYPE_80203;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |

commit ba0da2f37c8a562684c58595e9a21c1cf96a3765
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 06:00:50 2008 +0100

    Use separate storage files for each interface

diff --git a/src/iface-storage.c b/src/iface-storage.c
index ad2cfc5a..0f14ebd0 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -30,6 +30,8 @@
 
 #include "connman.h"
 
+#define GROUP_CONFIG  "Config"
+
 int __connman_iface_load(struct connman_iface *iface)
 {
 	GKeyFile *keyfile;
@@ -40,7 +42,8 @@ int __connman_iface_load(struct connman_iface *iface)
 	if (iface->identifier == NULL)
 		return -EIO;
 
-	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
 	if (pathname == NULL)
 		return -ENOMEM;
 
@@ -49,16 +52,16 @@ int __connman_iface_load(struct connman_iface *iface)
 	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
 		goto done;
 
-	if (g_key_file_has_group(keyfile, iface->identifier) == FALSE)
+	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
 		goto done;
 
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"Policy", NULL);
+	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Policy", NULL);
 	if (str != NULL) {
 		iface->policy = __connman_iface_string2policy(str);
 		g_free(str);
 	}
 
+#if 0
 	str = g_key_file_get_string(keyfile, iface->identifier,
 							"Network.ESSID", NULL);
 	if (str != NULL) {
@@ -95,6 +98,7 @@ int __connman_iface_load(struct connman_iface *iface)
 		iface->ipv4.gateway.s_addr = inet_addr(str);
 		g_free(str);
 	}
+#endif
 
 done:
 	g_key_file_free(keyfile);
@@ -107,22 +111,13 @@ done:
 static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 {
 	const char *str;
-	gchar *comment;
 
 	DBG("iface %p", iface);
 
-	comment = g_key_file_get_comment(keyfile,
-					iface->identifier, NULL, NULL);
-	if (comment == NULL || *comment == '\0') {
-		if (iface->device.product != NULL)
-			g_key_file_set_comment(keyfile, iface->identifier,
-					NULL, iface->device.product, NULL);
-	}
-	g_free(comment);
-
 	str = __connman_iface_policy2string(iface->policy);
-	g_key_file_set_string(keyfile, iface->identifier, "Policy", str);
+	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
 
+#if 0
 	if (iface->network.essid != NULL) {
 		g_key_file_set_string(keyfile, iface->identifier,
 					"Network.ESSID", iface->network.essid);
@@ -161,6 +156,7 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	} else
 		g_key_file_remove_key(keyfile, iface->identifier,
 							"IPv4.Gateway", NULL);
+#endif
 }
 
 int __connman_iface_store(struct connman_iface *iface)
@@ -174,14 +170,15 @@ int __connman_iface_store(struct connman_iface *iface)
 	if (iface->identifier == NULL)
 		return -EIO;
 
-	pathname = g_strdup_printf("%s/interfaces.conf", STORAGEDIR);
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
 	if (pathname == NULL)
 		return -ENOMEM;
 
 	keyfile = g_key_file_new();
 
 	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
-		goto done;
+		goto update;
 
 	if (length > 0) {
 		if (g_key_file_load_from_data(keyfile, data, length,
@@ -191,6 +188,7 @@ int __connman_iface_store(struct connman_iface *iface)
 
 	g_free(data);
 
+update:
 	do_update(keyfile, iface);
 
 	data = g_key_file_to_data(keyfile, &length, NULL);

commit 09f4164cb5a096a6200736247c9ba4493d50e270
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 06:42:59 2008 +0100

    Fix agent cleanup function

diff --git a/src/agent.c b/src/agent.c
index 4765868d..b7db03c6 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -107,8 +107,13 @@ void __connman_agent_cleanup(void)
 	if (agent_watch > 0)
 		g_dbus_remove_watch(connection, agent_watch);
 
+	if (agent_path == NULL)
+		return;
+
 	msg = dbus_message_new_method_call(agent_sender, agent_path,
 					CONNMAN_AGENT_INTERFACE, "Release");
+	if (msg == NULL)
+		return;
 
 	dbus_message_set_no_reply(msg, TRUE);
 

commit 9d5d36d8f73dcf43fa562c327b33653ef7f7cdf9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:15:00 2008 +0100

    Add example for showing interfaces

diff --git a/test/Makefile.am b/test/Makefile.am
index 02742923..0649dab2 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,2 +1,4 @@
 
+EXTRA_DIST = list-interfaces
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/list-interfaces b/test/list-interfaces
new file mode 100755
index 00000000..2cd0424d
--- /dev/null
+++ b/test/list-interfaces
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	print "[ %s ]" % (path)
+
+	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.connman.Interface')
+
+	properties = interface.GetProperties()
+	for key in properties.keys():
+		print "    %s = %s" % (key, properties[key])
+
+	ipv4 = interface.GetIPv4()
+	for key in ipv4.keys():
+		print "    IPv4.%s = %s" % (key, ipv4[key])
+
+	print

commit b530bfa969ba35511a206dd2aca3e6bd0d4d0aea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:17:53 2008 +0100

    Add example for starting scanning

diff --git a/test/Makefile.am b/test/Makefile.am
index 0649dab2..ca88b98b 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = list-interfaces
+EXTRA_DIST = list-interfaces start-scanning
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/start-scanning b/test/start-scanning
new file mode 100755
index 00000000..712b3e93
--- /dev/null
+++ b/test/start-scanning
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	print "[ %s ]" % (path)
+
+	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.connman.Interface')
+
+	properties = interface.GetProperties()
+
+	if (properties["Type"] == "80211"):
+		print "   Started scanning"
+		interface.Scan()
+	else:
+		print "   No scanning"
+
+	print

commit 99cf3b6bbc863da93dc5af464e0211217d280ccb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:21:55 2008 +0100

    Add example for a simple agent

diff --git a/test/Makefile.am b/test/Makefile.am
index ca88b98b..8f8214f4 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = list-interfaces start-scanning
+EXTRA_DIST = list-interfaces start-scanning simple-agent
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/simple-agent b/test/simple-agent
new file mode 100755
index 00000000..47a61f62
--- /dev/null
+++ b/test/simple-agent
@@ -0,0 +1,31 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+
+class Agent(dbus.service.Object):
+	@dbus.service.method("org.freedesktop.connman.Agent",
+					in_signature='', out_signature='')
+	def Release(self):
+		print("Release")
+		mainloop.quit()
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+	manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+	path = "/test/agent"
+	object = Agent(bus, path)
+
+	manager.RegisterAgent(path)
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()
+
+	#manager.UnregisterAgent(path)

commit 2363421b798c295d226037defb96583ecf153b34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:26:42 2008 +0100

    Add constant for user confirmation policy

diff --git a/include/iface.h b/include/iface.h
index 6a80178a..5d0a7e7a 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -62,6 +62,7 @@ enum connman_iface_policy {
 	CONNMAN_IFACE_POLICY_OFF     = 1,
 	CONNMAN_IFACE_POLICY_IGNORE  = 2,
 	CONNMAN_IFACE_POLICY_AUTO    = 3,
+	CONNMAN_IFACE_POLICY_ASK     = 4,
 };
 
 enum connman_ipv4_method {
diff --git a/src/iface-helper.c b/src/iface-helper.c
index 06642fb5..7e177198 100644
--- a/src/iface-helper.c
+++ b/src/iface-helper.c
@@ -86,6 +86,8 @@ const char *__connman_iface_policy2string(enum connman_iface_policy policy)
 		return "ignore";
 	case CONNMAN_IFACE_POLICY_AUTO:
 		return "auto";
+	case CONNMAN_IFACE_POLICY_ASK:
+		return "ask";
 	}
 
 	return "unknown";
@@ -99,6 +101,8 @@ enum connman_iface_policy __connman_iface_string2policy(const char *policy)
 		return CONNMAN_IFACE_POLICY_IGNORE;
 	else if (strcasecmp(policy, "auto") == 0)
 		return CONNMAN_IFACE_POLICY_AUTO;
+	else if (strcasecmp(policy, "ask") == 0)
+		return CONNMAN_IFACE_POLICY_ASK;
 	else
 		return CONNMAN_IFACE_POLICY_UNKNOWN;
 }

commit 01dbb962cbb1ea6871ad1ee0c73461cd68511745
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 07:41:16 2008 +0100

    Rename syslog parameter

diff --git a/src/connman.h b/src/connman.h
index da1693b1..76bffe55 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -49,7 +49,7 @@ int __connman_agent_unregister(const char *sender, const char *path);
 
 #include <connman/log.h>
 
-int __connman_log_init(int syslog, int debug);
+int __connman_log_init(int detach, int debug);
 void __connman_log_cleanup(void);
 
 #include <connman/plugin.h>
diff --git a/src/log.c b/src/log.c
index 867928ce..83466d22 100644
--- a/src/log.c
+++ b/src/log.c
@@ -66,11 +66,11 @@ void connman_debug(const char *format, ...)
 	va_end(ap);
 }
 
-int __connman_log_init(int syslog, int debug)
+int __connman_log_init(int detach, int debug)
 {
 	int option = LOG_NDELAY | LOG_PID;
 
-	if (!syslog)
+	if (!detach)
 		option |= LOG_PERROR;
 
 	openlog("connmand", option, LOG_DAEMON);

commit 49b002eae97659e1ffc06fd7d49a1413b6a8296c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:22:00 2008 +0100

    Fix ESSID parsing on 64-bit architectures

diff --git a/plugins/80211.c b/plugins/80211.c
index 53b36b60..0434b8c1 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -366,11 +366,12 @@ static void parse_scan_results(struct connman_iface *iface,
 			break;
 		case SIOCGIWESSID:
 			if (station != NULL) {
-				station->name = malloc(event->len - 7);
+				station->name = malloc(event->len - IW_EV_POINT_LEN + 1);
 				if (station->name != NULL) {
-					memset(station->name, 0, event->len - 7);
-					memcpy(station->name, ptr + 8,
-								event->len - 8);
+					memset(station->name, 0,
+						event->len - IW_EV_POINT_LEN + 1);
+					memcpy(station->name, ptr + IW_EV_POINT_LEN,
+						event->len - IW_EV_POINT_LEN);
 				}
 			}
 			break;
@@ -462,7 +463,7 @@ static void iface_scan_results(struct connman_iface *iface)
 				done = 1;
 		} else {
 			parse_scan_results(iface, iwr.u.data.pointer,
-						iwr.u.data.length);
+							iwr.u.data.length);
 			done = 1;
 		}
 	}

commit 0b7a3348208dfc4981a48bc22bf783c5d55e5b96
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:33:18 2008 +0100

    Add support for storing last network and passphrases

diff --git a/src/iface-storage.c b/src/iface-storage.c
index 0f14ebd0..750aa43e 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -61,44 +61,22 @@ int __connman_iface_load(struct connman_iface *iface)
 		g_free(str);
 	}
 
-#if 0
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"Network.ESSID", NULL);
+	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Network", NULL);
 	if (str != NULL) {
 		g_free(iface->network.essid);
 		iface->network.essid = str;
 		if (iface->driver->set_network)
 			iface->driver->set_network(iface, str);
-	}
-
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Method", NULL);
-	if (str != NULL) {
-		iface->ipv4.method = __connman_ipv4_string2method(str);
-		g_free(str);
-	}
-
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Address", NULL);
-	if (str != NULL) {
-		iface->ipv4.address.s_addr = inet_addr(str);
-		g_free(str);
-	}
-
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Netmask", NULL);
-	if (str != NULL) {
-		iface->ipv4.netmask.s_addr = inet_addr(str);
-		g_free(str);
-	}
 
-	str = g_key_file_get_string(keyfile, iface->identifier,
-							"IPv4.Gateway", NULL);
-	if (str != NULL) {
-		iface->ipv4.gateway.s_addr = inet_addr(str);
-		g_free(str);
+		str = g_key_file_get_string(keyfile, iface->network.essid,
+								"PSK", NULL);
+		if (str != NULL) {
+			g_free(iface->network.psk);
+			iface->network.psk = str;
+			if (iface->driver->set_passphrase)
+				iface->driver->set_passphrase(iface, str);
+		}
 	}
-#endif
 
 done:
 	g_key_file_free(keyfile);
@@ -117,46 +95,15 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	str = __connman_iface_policy2string(iface->policy);
 	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
 
-#if 0
 	if (iface->network.essid != NULL) {
-		g_key_file_set_string(keyfile, iface->identifier,
-					"Network.ESSID", iface->network.essid);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"Network.ESSID", NULL);
-
-	if (iface->ipv4.method != CONNMAN_IPV4_METHOD_UNKNOWN) {
-		str = __connman_ipv4_method2string(iface->ipv4.method);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Method", str);
+		g_key_file_set_string(keyfile, GROUP_CONFIG,
+					"Network", iface->network.essid);
 	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Method", NULL);
+		g_key_file_remove_key(keyfile, GROUP_CONFIG, "Network", NULL);
 
-	if (iface->ipv4.address.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.address);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Address", str);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Address", NULL);
-
-	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.netmask);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Netmask", str);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Netmask", NULL);
-
-	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.gateway);
-		g_key_file_set_string(keyfile, iface->identifier,
-							"IPv4.Gateway", str);
-	} else
-		g_key_file_remove_key(keyfile, iface->identifier,
-							"IPv4.Gateway", NULL);
-#endif
+	if (iface->network.essid != NULL)
+		g_key_file_set_string(keyfile, iface->network.essid,
+						"PSK", iface->network.psk);
 }
 
 int __connman_iface_store(struct connman_iface *iface)

commit a88c950e23edd63ba4b3e8db414633f2a9449de4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:39:36 2008 +0100

    Add supplicant disconnect function

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 3c02abd8..b30b16cb 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -269,6 +269,9 @@ int __supplicant_connect(struct connman_iface *iface,
 
 	exec_cmd(task, "DISABLE_NETWORK 0");
 
+	if (network == NULL)
+		return 0;
+
 	sprintf(cmd, "SET_NETWORK 0 ssid \"%s\"", network);
 	exec_cmd(task, cmd);
 
@@ -287,3 +290,18 @@ int __supplicant_connect(struct connman_iface *iface,
 
 	return 0;
 }
+
+int __supplicant_disconnect(struct connman_iface *iface)
+{
+	struct supplicant_task *task;
+
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
+
+	printf("[SUPPLICANT] disconnect %s\n", task->ifname);
+
+	exec_cmd(task, "DISABLE_NETWORK 0");
+
+	return 0;
+}
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 9e5ebc67..dc015ed7 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -26,3 +26,4 @@ int __supplicant_stop(struct connman_iface *iface);
 
 int __supplicant_connect(struct connman_iface *iface,
 				const char *network, const char *passphrase);
+int __supplicant_disconnect(struct connman_iface *iface);

commit b9ff5385d914dbfde5543675569ee8b32c5d5a85
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 08:48:13 2008 +0100

    Fix reconnect case when ESSID or PSK changes

diff --git a/plugins/80211.c b/plugins/80211.c
index 0434b8c1..a3d5111a 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -272,7 +272,8 @@ static int iface_connect(struct connman_iface *iface,
 
 	__supplicant_start(iface);
 
-	__supplicant_connect(iface, data->network, data->passphrase);
+	if (data->network != NULL)
+		__supplicant_connect(iface, data->network, data->passphrase);
 
 	return 0;
 }
@@ -283,6 +284,9 @@ static int iface_disconnect(struct connman_iface *iface)
 
 	printf("[802.11] disconnect %s\n", data->ifname);
 
+	if (data->network != NULL)
+		__supplicant_disconnect(iface);
+
 	__supplicant_stop(iface);
 
 	return 0;
@@ -295,9 +299,15 @@ static void iface_set_network(struct connman_iface *iface,
 
 	printf("[802.11] set network %s\n", data->ifname);
 
+	if (data->network != NULL)
+		__supplicant_disconnect(iface);
+
 	g_free(data->network);
 
 	data->network = g_strdup(network);
+
+	if (data->network != NULL)
+		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void iface_set_passphrase(struct connman_iface *iface,
@@ -307,9 +317,15 @@ static void iface_set_passphrase(struct connman_iface *iface,
 
 	printf("[802.11] set passphrase %s\n", data->ifname);
 
+	if (data->network != NULL)
+		__supplicant_disconnect(iface);
+
 	g_free(data->passphrase);
 
 	data->passphrase = g_strdup(passphrase);
+
+	if (data->network != NULL)
+		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void parse_genie(struct station_data *station,

commit 225ed69e17d41b06aa293b05387cd82924f30705
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 09:35:34 2008 +0100

    Add support for indicating security methods

diff --git a/include/iface.h b/include/iface.h
index 5d0a7e7a..e5fb05d4 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -155,7 +155,7 @@ extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
 extern void connman_iface_indicate_configured(struct connman_iface *iface);
 
 extern void connman_iface_indicate_station(struct connman_iface *iface,
-						const char *name, int strength);
+				const char *name, int strength, int security);
 
 extern int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4);
diff --git a/plugins/80211.c b/plugins/80211.c
index a3d5111a..eaec342d 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -54,6 +54,10 @@ struct station_data {
 	int wpa_ie_len;
 	unsigned char rsn_ie[40];
 	int rsn_ie_len;
+
+	int has_wep;
+	int has_wpa;
+	int has_rsn;
 };
 
 struct iface_data {
@@ -67,13 +71,23 @@ struct iface_data {
 static void report_station(struct connman_iface *iface,
 						struct station_data *station)
 {
+	int security = 0;
+
 	if (station == NULL)
 		return;
 
 	if (station->name == NULL)
 		return;
 
-	connman_iface_indicate_station(iface, station->name, station->qual);
+	if (station->has_wep)
+		security |= 0x01;
+	if (station->has_wpa)
+		security |= 0x02;
+	if (station->has_rsn)
+		security |= 0x04;
+
+	connman_iface_indicate_station(iface, station->name,
+						station->qual, security);
 }
 
 static struct station_data *create_station(struct iface_data *iface,
@@ -157,6 +171,9 @@ static void print_stations(struct iface_data *iface)
 		//			station->address, station->mode,
 		//				station->name, station->qual);
 
+		if (station->name == NULL)
+			continue;
+
 		g_key_file_set_string(keyfile, station->address,
 						"Name", station->name);
 
@@ -338,8 +355,10 @@ static void parse_genie(struct station_data *station,
 
 		switch (data[offset]) {
 		case 0xdd:	/* WPA1 (and other) */
+			station->has_wpa = 1;
 			break;
 		case 0x30:	/* WPA2 (RSN) */
+			station->has_rsn = 1;
 			break;
 		default:
 			break;
@@ -401,9 +420,8 @@ static void parse_scan_results(struct connman_iface *iface,
 			break;
 		case SIOCGIWENCODE:
 			if (station != NULL) {
-				if (!(event->u.data.flags & IW_ENCODE_DISABLED)) {
-					/* privacy */
-				}
+				if (!(event->u.data.flags & IW_ENCODE_DISABLED))
+					station->has_wep = 1;
 			}
 			break;
 		case SIOCGIWRATE:
diff --git a/src/iface.c b/src/iface.c
index a412dab4..2d45a223 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -289,9 +289,11 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	}
 }
 
-static void append_station(DBusMessage *reply, const char *name, int signal)
+static void append_station(DBusMessage *reply, const char *name,
+						int signal, int security)
 {
 	DBusMessageIter array, dict;
+	const char *wpa = "WPA";
 
 	dbus_message_iter_init_append(reply, &array);
 
@@ -303,22 +305,28 @@ static void append_station(DBusMessage *reply, const char *name, int signal)
 	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
 	append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
 
+	if (security > 0)
+		append_entry(&dict, "Security", DBUS_TYPE_STRING, &wpa);
+
 	dbus_message_iter_close_container(&array, &dict);
 }
 
 void connman_iface_indicate_station(struct connman_iface *iface,
-						const char *name, int strength)
+				const char *name, int strength, int security)
 {
 	DBusMessage *signal;
 
-	DBG("iface %p name %s", iface, name);
+	DBG("iface %p security %d name %s", iface, security, name);
+
+	if (name == NULL || strlen(name) == 0)
+		return;
 
 	signal = dbus_message_new_signal(iface->path,
 				CONNMAN_IFACE_INTERFACE, "NetworkFound");
 	if (signal == NULL)
 		return;
 
-	append_station(signal, name, strength);
+	append_station(signal, name, strength, security);
 
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);

commit 4bfbc81069e03dd3533ddae2e435cbf5d4eada65
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 26 10:36:58 2008 +0100

    Add example for showing the full introspection data

diff --git a/test/Makefile.am b/test/Makefile.am
index 8f8214f4..f3ae1831 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = list-interfaces start-scanning simple-agent
+EXTRA_DIST = list-interfaces start-scanning simple-agent show-introspection
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/show-introspection b/test/show-introspection
new file mode 100755
index 00000000..9acdd112
--- /dev/null
+++ b/test/show-introspection
@@ -0,0 +1,21 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+object = dbus.Interface(bus.get_object('org.freedesktop.connman', '/'),
+				'org.freedesktop.DBus.Introspectable')
+
+print object.Introspect()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	object = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.DBus.Introspectable')
+
+	print object.Introspect()

commit 2cb57fdad6fa5716d8cd89d691857484a615ce37
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 27 03:17:54 2008 +0100

    Enable scanning flag and fix connect/disconnect handling

diff --git a/plugins/80211.c b/plugins/80211.c
index eaec342d..2e8968e8 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -221,7 +221,8 @@ static int iface_probe(struct connman_iface *iface)
 	iface->type = CONNMAN_IFACE_TYPE_80211;
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4;
+				CONNMAN_IFACE_FLAG_IPV4 |
+				CONNMAN_IFACE_FLAG_SCANNING;
 
 	connman_iface_set_data(iface, data);
 
@@ -316,15 +317,9 @@ static void iface_set_network(struct connman_iface *iface,
 
 	printf("[802.11] set network %s\n", data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_disconnect(iface);
-
 	g_free(data->network);
 
 	data->network = g_strdup(network);
-
-	if (data->network != NULL)
-		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void iface_set_passphrase(struct connman_iface *iface,
@@ -334,15 +329,9 @@ static void iface_set_passphrase(struct connman_iface *iface,
 
 	printf("[802.11] set passphrase %s\n", data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_disconnect(iface);
-
 	g_free(data->passphrase);
 
 	data->passphrase = g_strdup(passphrase);
-
-	if (data->network != NULL)
-		__supplicant_connect(iface, data->network, data->passphrase);
 }
 
 static void parse_genie(struct station_data *station,
@@ -420,6 +409,9 @@ static void parse_scan_results(struct connman_iface *iface,
 			break;
 		case SIOCGIWENCODE:
 			if (station != NULL) {
+				if (!event->u.data.pointer)
+					event->u.data.flags |= IW_ENCODE_NOKEY;
+
 				if (!(event->u.data.flags & IW_ENCODE_DISABLED))
 					station->has_wep = 1;
 			}

commit 31aa9d82e49506eb06210ea000e1eb69893292f9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 27 11:18:48 2008 +0100

    Update state machine for interfaces

diff --git a/src/iface.c b/src/iface.c
index 2d45a223..c88408df 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -126,6 +126,23 @@ static void append_entry(DBusMessageIter *dict,
 	dbus_message_iter_close_container(dict, &entry);
 }
 
+static gboolean scan_timeout(gpointer user_data)
+{
+	struct connman_iface *iface = user_data;
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_SCANNING:
+	case CONNMAN_IFACE_STATE_READY:
+		if (iface->driver->scan)
+			iface->driver->scan(iface);
+		return TRUE;
+	default:
+		break;
+	}
+
+	return FALSE;
+}
+
 static void state_changed(struct connman_iface *iface)
 {
 	const char *str = __connman_iface_state2string(iface->state);
@@ -145,13 +162,16 @@ static void state_changed(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_ENABLED:
 		__connman_dhcp_release(iface);
 		connman_iface_clear_ipv4(iface);
-		if (iface->type == CONNMAN_IFACE_TYPE_80211) {
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
 			state = CONNMAN_IFACE_STATE_SCANNING;
-			if (iface->driver->connect) {
-				iface->driver->connect(iface, NULL);
-				state = CONNMAN_IFACE_STATE_CONNECT;
-			}
-		}
+		break;
+
+	case CONNMAN_IFACE_STATE_SCANNING:
+		if (iface->driver->scan)
+			iface->driver->scan(iface);
+		g_timeout_add(8000, scan_timeout, iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_CARRIER:
@@ -171,6 +191,11 @@ static void state_changed(struct connman_iface *iface)
 			state = CONNMAN_IFACE_STATE_OFF;
 		break;
 
+	case CONNMAN_IFACE_STATE_READY:
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
+			g_timeout_add(20000, scan_timeout, iface);
+		break;
+
 	default:
 		break;
 	}
@@ -225,7 +250,11 @@ void connman_iface_indicate_disabled(struct connman_iface *iface)
 {
 	DBG("iface %p state %d", iface, iface->state);
 
-	iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
+		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+		__connman_iface_up(iface);
+	} else
+		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 	state_changed(iface);
 }
 
@@ -267,7 +296,14 @@ void connman_iface_indicate_carrier_off(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_CARRIER:
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 	case CONNMAN_IFACE_STATE_READY:
-		iface->state = CONNMAN_IFACE_STATE_ENABLED;
+#if 0
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING) {
+			if (iface->driver->disconnect)
+				iface->driver->disconnect(iface);
+			iface->state = CONNMAN_IFACE_STATE_SCANNING;
+		} else
+#endif
+			iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
 	default:
@@ -330,6 +366,21 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
+
+	if (g_str_equal(name, iface->network.essid) == TRUE &&
+			iface->state == CONNMAN_IFACE_STATE_SCANNING) {
+		if (iface->driver->set_network)
+			iface->driver->set_network(iface, name);
+		if (iface->driver->set_passphrase)
+			iface->driver->set_passphrase(iface,
+						iface->network.psk);
+
+		if (iface->driver->connect) {
+			iface->driver->connect(iface, NULL);
+			iface->state = CONNMAN_IFACE_STATE_CONNECT;
+			state_changed(iface);
+		}
+	}
 }
 
 int connman_iface_get_ipv4(struct connman_iface *iface,
@@ -509,8 +560,8 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->scan)
-		driver->scan(iface);
+	//if (driver->scan)
+	//	driver->scan(iface);
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
@@ -755,7 +806,7 @@ static DBusMessage *set_network(DBusConnection *conn,
 		if (g_strcasecmp(key, "PSK") == 0) {
 			g_free(iface->network.psk);
 			iface->network.psk = g_strdup(val);
-			if (iface->driver->set_network)
+			if (iface->driver->set_passphrase)
 				iface->driver->set_passphrase(iface, val);
 			changed = TRUE;
 		}
@@ -784,6 +835,33 @@ static DBusMessage *set_network(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *select_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	const char *network;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+							DBUS_TYPE_INVALID);
+
+	g_free(iface->network.essid);
+	iface->network.essid = g_strdup(network);
+
+	if (iface->driver->set_network)
+		iface->driver->set_network(iface, network);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
 {
 	DBusMessageIter array, dict;
@@ -929,6 +1007,7 @@ static GDBusMethodTable iface_methods[] = {
 	{ "SetPolicy",     "s",     "",      set_policy     },
 	{ "GetNetwork",    "",      "a{sv}", get_network    },
 	{ "SetNetwork",    "a{sv}", "",      set_network    },
+	{ "SelectNetwork", "s",     "",      select_network },
 	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
 	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
 	{ },
@@ -1055,6 +1134,9 @@ static int probe_device(LibHalContext *ctx,
 
 	__connman_iface_load(iface);
 
+	DBG("iface %p network %s secret %s", iface,
+				iface->network.essid, iface->network.psk);
+
 	conn = libhal_ctx_get_dbus_connection(ctx);
 
 	g_dbus_register_object(conn, iface->path, iface, device_free);

commit 658e0e6d8699510d8ea94f0bb6e44718f9956e96
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 07:47:49 2008 +0100

    Fix endless loop in wireless event parsing

diff --git a/plugins/80211.c b/plugins/80211.c
index 2e8968e8..6b2a6fde 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -434,6 +434,8 @@ static void parse_scan_results(struct connman_iface *iface,
 		default:
 			printf("[802.11] scan element 0x%04x (len %d)\n",
 						event->cmd, event->len);
+			if (event->len == 0)
+				len = 0;
 			break;
 		}
 

commit e3db50a2ec3968dc31b780ad0bb794b908c227bb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 07:53:50 2008 +0100

    Add callbacks for starting and stopping interface

diff --git a/include/iface.h b/include/iface.h
index e5fb05d4..b9ade5eb 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -115,9 +115,13 @@ struct connman_iface {
 struct connman_iface_driver {
 	const char *name;
 	const char *capability;
+
 	int (*probe) (struct connman_iface *iface);
 	void (*remove) (struct connman_iface *iface);
 
+	int (*start) (struct connman_iface *iface);
+	int (*stop) (struct connman_iface *iface);
+
 	int (*scan) (struct connman_iface *iface);
 	int (*connect) (struct connman_iface *iface,
 					struct connman_network *network);
diff --git a/src/iface-inet.c b/src/iface-inet.c
index a09ba312..a0915af4 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -140,8 +140,13 @@ int __connman_iface_up(struct connman_iface *iface)
 
 	ifr.ifr_flags |= IFF_UP;
 
-	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
 		err = -errno;
+		goto done;
+	}
+
+	if (iface->driver->start)
+		err = iface->driver->start(iface);
 	else
 		err = 0;
 
@@ -158,6 +163,12 @@ int __connman_iface_down(struct connman_iface *iface)
 
 	DBG("iface %p", iface);
 
+	if (iface->driver->stop) {
+		err = iface->driver->stop(iface);
+		if (err < 0)
+			return err;
+	}
+
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return -errno;

commit 5018853676931bf252d81439a6d3da0e3c89d80d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:01:23 2008 +0100

    Update function names of 802.03 plugin

diff --git a/plugins/80203.c b/plugins/80203.c
index b4d67457..4d085c0a 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -29,13 +29,14 @@
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
+#include <connman/log.h>
 
-static int iface_probe(struct connman_iface *iface)
+static int ethernet_probe(struct connman_iface *iface)
 {
 	char sysfs_path[PATH_MAX];
 	struct stat st;
 
-	printf("[802.03] probe interface index %d\n", iface->index);
+	DBG("iface %p", iface);
 
 	snprintf(sysfs_path, PATH_MAX, "%s/bridge", iface->sysfs);
 
@@ -50,29 +51,27 @@ static int iface_probe(struct connman_iface *iface)
 	return 0;
 }
 
-static void iface_remove(struct connman_iface *iface)
+static void ethernet_remove(struct connman_iface *iface)
 {
-	printf("[802.03] remove interface index %d\n", iface->index);
+	DBG("iface %p", iface);
 }
 
-static struct connman_iface_driver iface_driver = {
+static struct connman_iface_driver ethernet_driver = {
 	.name		= "80203",
 	.capability	= "net.80203",
-	.probe		= iface_probe,
-	.remove		= iface_remove,
+	.probe		= ethernet_probe,
+	.remove		= ethernet_remove,
 };
 
-static int plugin_init(void)
+static int ethernet_init(void)
 {
-	connman_iface_register(&iface_driver);
-
-	return 0;
+	return connman_iface_register(&ethernet_driver);
 }
 
-static void plugin_exit(void)
+static void ethernet_exit(void)
 {
-	connman_iface_unregister(&iface_driver);
+	connman_iface_unregister(&ethernet_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE("80203", "IEEE 802.03 interface plugin", VERSION,
-						plugin_init, plugin_exit)
+						ethernet_init, ethernet_exit)

commit 7b4a94fd76ef38acecb278536eea9ad57de6dc08
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:09:17 2008 +0100

    Update function names of 802.11 plugin

diff --git a/plugins/80211.c b/plugins/80211.c
index 6b2a6fde..f71cd6a9 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -39,6 +39,7 @@
 
 #include <connman/plugin.h>
 #include <connman/iface.h>
+#include <connman/log.h>
 
 #include "supplicant.h"
 
@@ -188,7 +189,7 @@ static void print_stations(struct iface_data *iface)
 	g_key_file_free(keyfile);
 }
 
-static int iface_probe(struct connman_iface *iface)
+static int wifi_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
 	struct ifreq ifr;
@@ -208,7 +209,7 @@ static int iface_probe(struct connman_iface *iface)
 	if (err < 0)
 		return -EIO;
 
-	printf("[802.11] probe %s\n", ifr.ifr_name);
+	DBG("iface %p %s", iface, ifr.ifr_name);
 
 	data = malloc(sizeof(*data));
 	if (data == NULL)
@@ -231,11 +232,11 @@ static int iface_probe(struct connman_iface *iface)
 	return 0;
 }
 
-static void iface_remove(struct connman_iface *iface)
+static void wifi_remove(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] remove %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	__supplicant_stop(iface);
 
@@ -247,14 +248,14 @@ static void iface_remove(struct connman_iface *iface)
 	free(data);
 }
 
-static int iface_scan(struct connman_iface *iface)
+static int wifi_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 	struct iwreq iwr;
 	struct iw_scan_req iws;
 	int sk, err;
 
-	printf("[802.11] scanning %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
@@ -276,17 +277,18 @@ static int iface_scan(struct connman_iface *iface)
 	close(sk);
 
 	if (err < 0)
-		printf("[802.11] scan initiate error %d\n", errno);
+		connman_error("%s: scan initiate error %d",
+						data->ifname, errno);
 
 	return err;
 }
 
-static int iface_connect(struct connman_iface *iface,
+static int wifi_connect(struct connman_iface *iface,
 					struct connman_network *network)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] connect %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	__supplicant_start(iface);
 
@@ -296,11 +298,11 @@ static int iface_connect(struct connman_iface *iface,
 	return 0;
 }
 
-static int iface_disconnect(struct connman_iface *iface)
+static int wifi_disconnect(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] disconnect %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	if (data->network != NULL)
 		__supplicant_disconnect(iface);
@@ -310,24 +312,24 @@ static int iface_disconnect(struct connman_iface *iface)
 	return 0;
 }
 
-static void iface_set_network(struct connman_iface *iface,
+static void wifi_set_network(struct connman_iface *iface,
 						const char *network)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] set network %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	g_free(data->network);
 
 	data->network = g_strdup(network);
 }
 
-static void iface_set_passphrase(struct connman_iface *iface,
+static void wifi_set_passphrase(struct connman_iface *iface,
 						const char *passphrase)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 
-	printf("[802.11] set passphrase %s\n", data->ifname);
+	DBG("iface %p %s", iface, data->ifname);
 
 	g_free(data->passphrase);
 
@@ -448,7 +450,7 @@ static void parse_scan_results(struct connman_iface *iface,
 	printf("[802.11] found %d networks\n", num);
 }
 
-static void iface_scan_results(struct connman_iface *iface)
+static void scan_results(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
 	struct iwreq iwr;
@@ -503,7 +505,7 @@ static void iface_scan_results(struct connman_iface *iface)
 	print_stations(data);
 }
 
-static void iface_wireless(struct connman_iface *iface,
+static void wifi_wireless(struct connman_iface *iface,
 					void *data, unsigned short len)
 {
 	struct iw_event *event = data;
@@ -545,7 +547,7 @@ static void iface_wireless(struct connman_iface *iface,
 		printf("[802.11] New Access Point %s\n", addr);
 		break;
 	case SIOCGIWSCAN:
-		iface_scan_results(iface);
+		scan_results(iface);
 		break;
 	default:
 		printf("[802.11] Wireless event (cmd 0x%04x len %d)\n",
@@ -554,30 +556,28 @@ static void iface_wireless(struct connman_iface *iface,
 	}
 }
 
-static struct connman_iface_driver iface_driver = {
+static struct connman_iface_driver wifi_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
-	.probe		= iface_probe,
-	.remove		= iface_remove,
-	.scan		= iface_scan,
-	.connect	= iface_connect,
-	.disconnect	= iface_disconnect,
-	.set_network	= iface_set_network,
-	.set_passphrase	= iface_set_passphrase,
-	.rtnl_wireless	= iface_wireless,
+	.probe		= wifi_probe,
+	.remove		= wifi_remove,
+	.scan		= wifi_scan,
+	.connect	= wifi_connect,
+	.disconnect	= wifi_disconnect,
+	.set_network	= wifi_set_network,
+	.set_passphrase	= wifi_set_passphrase,
+	.rtnl_wireless	= wifi_wireless,
 };
 
-static int plugin_init(void)
+static int wifi_init(void)
 {
-	connman_iface_register(&iface_driver);
-
-	return 0;
+	return connman_iface_register(&wifi_driver);
 }
 
-static void plugin_exit(void)
+static void wifi_exit(void)
 {
-	connman_iface_unregister(&iface_driver);
+	connman_iface_unregister(&wifi_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE("80211", "IEEE 802.11 interface plugin", VERSION,
-						plugin_init, plugin_exit)
+							wifi_init, wifi_exit)

commit 58f36e8b742afc500d5a2330999f51afe8ac0877
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:13:01 2008 +0100

    Implement start and stop callbacks for 802.11

diff --git a/plugins/80211.c b/plugins/80211.c
index f71cd6a9..963fb02e 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -248,6 +248,28 @@ static void wifi_remove(struct connman_iface *iface)
 	free(data);
 }
 
+static int wifi_start(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	DBG("iface %p %s", iface, data->ifname);
+
+	__supplicant_start(iface);
+
+	return 0;
+}
+
+static int wifi_stop(struct connman_iface *iface)
+{
+	struct iface_data *data = connman_iface_get_data(iface);
+
+	DBG("iface %p %s", iface, data->ifname);
+
+	__supplicant_stop(iface);
+
+	return 0;
+}
+
 static int wifi_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
@@ -290,8 +312,6 @@ static int wifi_connect(struct connman_iface *iface,
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	__supplicant_start(iface);
-
 	if (data->network != NULL)
 		__supplicant_connect(iface, data->network, data->passphrase);
 
@@ -307,8 +327,6 @@ static int wifi_disconnect(struct connman_iface *iface)
 	if (data->network != NULL)
 		__supplicant_disconnect(iface);
 
-	__supplicant_stop(iface);
-
 	return 0;
 }
 
@@ -561,6 +579,8 @@ static struct connman_iface_driver wifi_driver = {
 	.capability	= "net.80211",
 	.probe		= wifi_probe,
 	.remove		= wifi_remove,
+	.start		= wifi_start,
+	.stop		= wifi_stop,
 	.scan		= wifi_scan,
 	.connect	= wifi_connect,
 	.disconnect	= wifi_disconnect,

commit d7d0cc2a73eef733e792873caa35862e902d3ce4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:33:00 2008 +0100

    Add system activation support

diff --git a/.gitignore b/.gitignore
index d2429679..06c10588 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,5 +23,6 @@ autom4te.cache
 
 include/connman
 src/connmand
+src/connman.service
 scripts/connman
 scripts/dhclient-script
diff --git a/configure.in b/configure.in
index 0c61409f..119ac713 100644
--- a/configure.in
+++ b/configure.in
@@ -62,4 +62,5 @@ AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
-			plugins/Makefile scripts/Makefile scripts/connman)
+					plugins/Makefile scripts/Makefile
+					scripts/connman src/connman.service)
diff --git a/src/Makefile.am b/src/Makefile.am
index 516c1b8b..7faf6a22 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -3,6 +3,12 @@ dbusdir = $(sysconfdir)/dbus-1/system.d
 
 dbus_DATA = connman.conf
 
+servicedir = $(datarootdir)/dbus-1/system-services
+
+service_DATA = connman.service
+
+DISTCLEANFILES = $(service_DATA)
+
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
diff --git a/src/connman.service.in b/src/connman.service.in
new file mode 100644
index 00000000..8c2368a7
--- /dev/null
+++ b/src/connman.service.in
@@ -0,0 +1,4 @@
+[D-BUS Service]
+Name=org.freedesktop.connman
+Exec=@prefix@/sbin/connmand
+User=root

commit 957896b6bbeae6dc4efef26da8bfe48fece916ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 1 08:33:54 2008 +0100

    Add first draft of plugin API description

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 04bffe2b..3155148a 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt
+EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt plugin-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/doc/plugin-api.txt b/doc/plugin-api.txt
new file mode 100644
index 00000000..f8dded07
--- /dev/null
+++ b/doc/plugin-api.txt
@@ -0,0 +1,22 @@
+Plugin programming interface
+****************************
+
+Plugin basics
+=============
+The Connection Manager supports plugins for various actions. The basic plugin
+contains of plugin description via CONNMAN_PLUGIN_DEFINE and also init/exit
+callbacks definied through that description.
+
+#include <connman/plugin.h>
+
+static int example_init(void)
+{
+	return 0;
+}
+
+static void example_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE("example", "Example plugin", VERSION,
+						example_init, example_exit)

commit 7de39040b6b37028e899ae624c9f50b0a3d5df2e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 2 11:34:25 2008 +0100

    Add support for pkg-config

diff --git a/.gitignore b/.gitignore
index 06c10588..4fb1449a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,6 +21,7 @@ missing
 stamp-h1
 autom4te.cache
 
+connman.pc
 include/connman
 src/connmand
 src/connman.service
diff --git a/Makefile.am b/Makefile.am
index 35d8c884..071be42c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,6 +1,12 @@
 
 SUBDIRS = include src doc test plugins scripts
 
+pkgconfigdir = $(libdir)/pkgconfig
+
+noinst_DATA = connman.pc
+
+DISTCLEANFILES = $(noinst_DATA)
+
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
 	ltmain.sh depcomp missing install-sh mkinstalldirs
diff --git a/configure.in b/configure.in
index 119ac713..81144ec1 100644
--- a/configure.in
+++ b/configure.in
@@ -61,6 +61,6 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile test/Makefile
-					plugins/Makefile scripts/Makefile
-					scripts/connman src/connman.service)
+AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
+			test/Makefile plugins/Makefile scripts/Makefile
+			scripts/connman src/connman.service connman.pc)
diff --git a/connman.pc.in b/connman.pc.in
new file mode 100644
index 00000000..96f1abc4
--- /dev/null
+++ b/connman.pc.in
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+ 
+Name: connman
+Description: Connection Manager
+Version: @VERSION@
+Libs: -module -avoid-version -export-symbols-regex connman_plugin_desc
+Cflags: -I${includedir}

commit 93378be22c081eb09cefa1cb982a0e74b6350730
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 3 15:28:29 2008 +0100

    Rename package from connman-core to connman

diff --git a/configure.in b/configure.in
index 81144ec1..ba478e16 100644
--- a/configure.in
+++ b/configure.in
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman-core, 0.0)
+AM_INIT_AUTOMAKE(connman, 0.0)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 25ff366326749b0d82c3bf3e7def61dcc7d85b25
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 3 15:46:55 2008 +0100

    Add plugin and script directories to pkg-config

diff --git a/connman.pc.in b/connman.pc.in
index 96f1abc4..fd86152c 100644
--- a/connman.pc.in
+++ b/connman.pc.in
@@ -3,6 +3,9 @@ exec_prefix=@exec_prefix@
 libdir=@libdir@
 includedir=@includedir@
  
+plugindir=${libdir}/connman/plugins
+scriptdir=${libdir}/connman/scripts
+
 Name: connman
 Description: Connection Manager
 Version: @VERSION@

commit c016ac34da91eef334844f43fbcb2639ed17bf8e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 7 13:53:54 2008 +0100

    Disable unused RTNL address handling for now

diff --git a/src/iface.c b/src/iface.c
index c88408df..ea8b47ba 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -386,6 +386,7 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 int connman_iface_get_ipv4(struct connman_iface *iface,
 						struct connman_ipv4 *ipv4)
 {
+#if 0
 	struct {
 		struct nlmsghdr hdr;
 		struct rtgenmsg msg;
@@ -405,6 +406,7 @@ int connman_iface_get_ipv4(struct connman_iface *iface,
 	req.msg.rtgen_family = AF_INET;
 
 	__connman_rtnl_send(&req, sizeof(req));
+#endif
 
 	return 0;
 }
diff --git a/src/rtnl.c b/src/rtnl.c
index 952f09b3..e4996fb9 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -403,7 +403,8 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
+	addr.nl_groups = RTMGRP_LINK;
+	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 
 	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {

commit 3d6fb4828d617c822cb260e6e6d3f9aae51979d9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 7 14:16:32 2008 +0100

    Fix compiler warning

diff --git a/src/iface.c b/src/iface.c
index ea8b47ba..b91c1973 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -562,8 +562,9 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	//if (driver->scan)
-	//	driver->scan(iface);
+	if (driver->scan) {
+		//driver->scan(iface);
+	}
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 

commit 0c42162c98c45373b2e9759021361eda40bb5f7e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 7 14:28:33 2008 +0100

    Fix missing IW_EV_LCP_PK_LEN definition on some distributions

diff --git a/plugins/80211.c b/plugins/80211.c
index 963fb02e..1bada4fc 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -43,6 +43,10 @@
 
 #include "supplicant.h"
 
+#ifndef IW_EV_LCP_PK_LEN
+#define IW_EV_LCP_PK_LEN	(4)
+#endif
+
 struct station_data {
 	char *address;
 	char *name;

commit 79280d0cf6a006988cb3c6394da44b2aa4c38271
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 11 14:54:48 2008 +0100

    Use start/stop callbacks if provided

diff --git a/src/iface-inet.c b/src/iface-inet.c
index a0915af4..927f5689 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -145,10 +145,7 @@ int __connman_iface_up(struct connman_iface *iface)
 		goto done;
 	}
 
-	if (iface->driver->start)
-		err = iface->driver->start(iface);
-	else
-		err = 0;
+	err = 0;
 
 done:
 	close(sk);
@@ -163,12 +160,6 @@ int __connman_iface_down(struct connman_iface *iface)
 
 	DBG("iface %p", iface);
 
-	if (iface->driver->stop) {
-		err = iface->driver->stop(iface);
-		if (err < 0)
-			return err;
-	}
-
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return -errno;
diff --git a/src/iface.c b/src/iface.c
index b91c1973..65e4cdd0 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -215,14 +215,20 @@ static void switch_policy(struct connman_iface *iface)
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 		state_changed(iface);
 		connman_iface_clear_ipv4(iface);
-		__connman_iface_down(iface);
+		if (iface->driver->stop)
+			iface->driver->stop(iface);
+		else
+			__connman_iface_down(iface);
 		break;
 
 	case CONNMAN_IFACE_POLICY_IGNORE:
 		break;
 
 	case CONNMAN_IFACE_POLICY_AUTO:
-		__connman_iface_up(iface);
+		if (iface->driver->start)
+			iface->driver->start(iface);
+		else
+			__connman_iface_up(iface);
 		state_changed(iface);
 		break;
 
@@ -252,9 +258,13 @@ void connman_iface_indicate_disabled(struct connman_iface *iface)
 
 	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-		__connman_iface_up(iface);
+		if (iface->driver->start)
+			iface->driver->start(iface);
+		else
+			__connman_iface_up(iface);
 	} else
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
+
 	state_changed(iface);
 }
 

commit c1925f58614237c3ecd8adce5c0b3f7d82b847cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:48:31 2008 +0100

    Add option for interface limitation

diff --git a/src/connman.h b/src/connman.h
index 76bffe55..c253a8e3 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -59,7 +59,7 @@ void __connman_plugin_cleanup(void);
 
 #include <connman/iface.h>
 
-int __connman_iface_init(DBusConnection *conn);
+int __connman_iface_init(DBusConnection *conn, const char *interface);
 void __connman_iface_cleanup(void);
 
 struct connman_iface *__connman_iface_find(int index);
diff --git a/src/iface.c b/src/iface.c
index 65e4cdd0..18c44f66 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -47,6 +47,8 @@
 
 static DBusConnection *connection = NULL;
 
+static gchar *ifname_filter = NULL;
+
 static GSList *drivers = NULL;
 
 int connman_iface_register(struct connman_iface_driver *driver)
@@ -1095,7 +1097,7 @@ static int probe_device(LibHalContext *ctx,
 {
 	DBusConnection *conn;
 	struct connman_iface *iface;
-	char *temp, *sysfs;
+	char *temp, *sysfs, *ifname;
 	int err;
 
 	DBG("ctx %p driver %p udi %s", ctx, driver, udi);
@@ -1124,10 +1126,20 @@ static int probe_device(LibHalContext *ctx,
 
 	iface->index = -1;
 
-	if (g_str_has_prefix(driver->capability, "net") == TRUE)
+	if (g_str_has_prefix(driver->capability, "net") == TRUE) {
 		iface->index = libhal_device_get_property_int(ctx, udi,
 						"net.linux.ifindex", NULL);
 
+		ifname = libhal_device_get_property_string(ctx, udi,
+						"net.interface", NULL);
+		if (ifname != NULL && ifname_filter != NULL &&
+						*ifname_filter != '\0' &&
+				g_str_equal(ifname, ifname_filter) == FALSE) {
+			device_free(iface);
+			return -1;
+		}
+	}
+
 	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
 	iface->flags = 0;
 	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
@@ -1340,7 +1352,7 @@ static void hal_cleanup(void *data)
 
 static guint hal_watch = 0;
 
-int __connman_iface_init(DBusConnection *conn)
+int __connman_iface_init(DBusConnection *conn, const char *interface)
 {
 	DBG("conn %p", conn);
 
@@ -1348,6 +1360,9 @@ int __connman_iface_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -1;
 
+	if (interface != NULL)
+		ifname_filter = g_strdup(interface);
+
 	hal_init(connection);
 
 	hal_watch = g_dbus_add_watch(connection, "org.freedesktop.Hal",
@@ -1364,5 +1379,7 @@ void __connman_iface_cleanup(void)
 
 	hal_cleanup(connection);
 
+	g_free(ifname_filter);
+
 	dbus_connection_unref(connection);
 }
diff --git a/src/main.c b/src/main.c
index a4962b2a..e9174401 100644
--- a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include <signal.h>
 #include <getopt.h>
 #include <sys/stat.h>
+#include <net/if.h>
 
 #include <gdbus.h>
 
@@ -47,7 +48,7 @@ static void usage(void)
 	printf("Connection Manager version %s\n\n", VERSION);
 
 	printf("Usage:\n"
-		"\tconnmand [options]\n"
+		"\tconnmand [-i <interface>] [options]\n"
 		"\n");
 
 	printf("Options:\n"
@@ -58,10 +59,11 @@ static void usage(void)
 }
 
 static struct option options[] = {
-	{ "nodaemon", 0, 0, 'n' },
-	{ "compat",   0, 0, 'c' },
-	{ "debug",    0, 0, 'd' },
-	{ "help",     0, 0, 'h' },
+	{ "interface", 1, 0, 'i' },
+	{ "nodaemon",  0, 0, 'n' },
+	{ "compat",    0, 0, 'c' },
+	{ "debug",     0, 0, 'd' },
+	{ "help",      0, 0, 'h' },
 	{ }
 };
 
@@ -70,10 +72,16 @@ int main(int argc, char *argv[])
 	DBusConnection *conn;
 	DBusError err;
 	struct sigaction sa;
+	char interface[IFNAMSIZ];
 	int opt, detach = 1, compat = 0, debug = 0;
 
-	while ((opt = getopt_long(argc, argv, "+ncdh", options, NULL)) != EOF) {
+	memset(interface, 0, IFNAMSIZ);
+
+	while ((opt = getopt_long(argc, argv, "+i:ncdh", options, NULL)) != EOF) {
 		switch (opt) {
+		case 'i':
+			snprintf(interface, IFNAMSIZ, "%s", optarg);
+			break;
 		case 'n':
 			detach = 0;
 			break;
@@ -136,7 +144,7 @@ int main(int argc, char *argv[])
 
 	__connman_rtnl_init();
 
-	__connman_iface_init(conn);
+	__connman_iface_init(conn, interface);
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;

commit c1fdd4bf06398f2b277bd5d8e5a11cadba6508b8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:49:14 2008 +0100

    Change variables inside the network structure

diff --git a/include/iface.h b/include/iface.h
index b9ade5eb..37e60672 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -83,8 +83,8 @@ struct connman_ipv4 {
 };
 
 struct connman_network {
-	char *essid;
-	char *psk;
+	char *identifier;
+	char *passphrase;
 };
 
 struct connman_iface {
@@ -127,11 +127,6 @@ struct connman_iface_driver {
 					struct connman_network *network);
 	int (*disconnect) (struct connman_iface *iface);
 
-	void (*set_network) (struct connman_iface *iface,
-						const char *network);
-	void (*set_passphrase) (struct connman_iface *iface,
-						const char *passphrase);
-
 	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
 	void (*rtnl_wireless) (struct connman_iface *iface,
 					void *data, unsigned short len);
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 750aa43e..a5b57a38 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -63,18 +63,14 @@ int __connman_iface_load(struct connman_iface *iface)
 
 	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Network", NULL);
 	if (str != NULL) {
-		g_free(iface->network.essid);
-		iface->network.essid = str;
-		if (iface->driver->set_network)
-			iface->driver->set_network(iface, str);
+		g_free(iface->network.identifier);
+		iface->network.identifier = str;
 
-		str = g_key_file_get_string(keyfile, iface->network.essid,
-								"PSK", NULL);
+		str = g_key_file_get_string(keyfile,
+				iface->network.identifier, "PSK", NULL);
 		if (str != NULL) {
-			g_free(iface->network.psk);
-			iface->network.psk = str;
-			if (iface->driver->set_passphrase)
-				iface->driver->set_passphrase(iface, str);
+			g_free(iface->network.passphrase);
+			iface->network.passphrase = str;
 		}
 	}
 
@@ -95,15 +91,15 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 	str = __connman_iface_policy2string(iface->policy);
 	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
 
-	if (iface->network.essid != NULL) {
+	if (iface->network.identifier != NULL) {
 		g_key_file_set_string(keyfile, GROUP_CONFIG,
-					"Network", iface->network.essid);
+				"Network", iface->network.identifier);
 	} else
 		g_key_file_remove_key(keyfile, GROUP_CONFIG, "Network", NULL);
 
-	if (iface->network.essid != NULL)
-		g_key_file_set_string(keyfile, iface->network.essid,
-						"PSK", iface->network.psk);
+	if (iface->network.identifier != NULL)
+		g_key_file_set_string(keyfile, iface->network.identifier,
+					"PSK", iface->network.passphrase);
 }
 
 int __connman_iface_store(struct connman_iface *iface)
diff --git a/src/iface.c b/src/iface.c
index 18c44f66..b9fe5133 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -134,7 +134,6 @@ static gboolean scan_timeout(gpointer user_data)
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_SCANNING:
-	case CONNMAN_IFACE_STATE_READY:
 		if (iface->driver->scan)
 			iface->driver->scan(iface);
 		return TRUE;
@@ -194,8 +193,6 @@ static void state_changed(struct connman_iface *iface)
 		break;
 
 	case CONNMAN_IFACE_STATE_READY:
-		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
-			g_timeout_add(20000, scan_timeout, iface);
 		break;
 
 	default:
@@ -379,16 +376,12 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
 
-	if (g_str_equal(name, iface->network.essid) == TRUE &&
+	if (g_str_equal(name, iface->network.identifier) == TRUE &&
 			iface->state == CONNMAN_IFACE_STATE_SCANNING) {
-		if (iface->driver->set_network)
-			iface->driver->set_network(iface, name);
-		if (iface->driver->set_passphrase)
-			iface->driver->set_passphrase(iface,
-						iface->network.psk);
+		iface->network.identifier = g_strdup(name);
 
 		if (iface->driver->connect) {
-			iface->driver->connect(iface, NULL);
+			iface->driver->connect(iface, &iface->network);
 			iface->state = CONNMAN_IFACE_STATE_CONNECT;
 			state_changed(iface);
 		}
@@ -574,9 +567,8 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (driver->scan) {
-		//driver->scan(iface);
-	}
+	if (driver->scan)
+		driver->scan(iface);
 
 	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
@@ -751,12 +743,12 @@ static void append_network(DBusMessage *reply,
 
 	switch (iface->type) {
 	case CONNMAN_IFACE_TYPE_80211:
-		if (iface->network.essid != NULL)
+		if (iface->network.identifier != NULL)
 			append_entry(&dict, "ESSID",
-				DBUS_TYPE_STRING, &iface->network.essid);
-		if (secrets == TRUE && iface->network.psk != NULL)
+				DBUS_TYPE_STRING, &iface->network.identifier);
+		if (secrets == TRUE && iface->network.passphrase != NULL)
 			append_entry(&dict, "PSK",
-				DBUS_TYPE_STRING, &iface->network.psk);
+				DBUS_TYPE_STRING, &iface->network.passphrase);
 		break;
 	default:
 		break;
@@ -811,18 +803,14 @@ static DBusMessage *set_network(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &val);
 
 		if (g_strcasecmp(key, "ESSID") == 0) {
-			g_free(iface->network.essid);
-			iface->network.essid = g_strdup(val);
-			if (iface->driver->set_network)
-				iface->driver->set_network(iface, val);
+			g_free(iface->network.identifier);
+			iface->network.identifier = g_strdup(val);
 			changed = TRUE;
 		}
 
 		if (g_strcasecmp(key, "PSK") == 0) {
-			g_free(iface->network.psk);
-			iface->network.psk = g_strdup(val);
-			if (iface->driver->set_passphrase)
-				iface->driver->set_passphrase(iface, val);
+			g_free(iface->network.passphrase);
+			iface->network.passphrase = g_strdup(val);
 			changed = TRUE;
 		}
 
@@ -845,6 +833,12 @@ static DBusMessage *set_network(DBusConnection *conn,
 			dbus_connection_send(conn, signal, NULL);
 			dbus_message_unref(signal);
 		}
+
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+
+		if (iface->driver->connect)
+			iface->driver->connect(iface, &iface->network);
 	}
 
 	return reply;
@@ -862,11 +856,14 @@ static DBusMessage *select_network(DBusConnection *conn,
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
 							DBUS_TYPE_INVALID);
 
-	g_free(iface->network.essid);
-	iface->network.essid = g_strdup(network);
+	g_free(iface->network.identifier);
+	iface->network.identifier = g_strdup(network);
+
+	if (iface->driver->disconnect)
+		iface->driver->disconnect(iface);
 
-	if (iface->driver->set_network)
-		iface->driver->set_network(iface, network);
+	if (iface->driver->connect)
+		iface->driver->connect(iface, &iface->network);
 
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
@@ -1053,7 +1050,8 @@ static void device_free(void *data)
 	g_free(iface->udi);
 	g_free(iface->sysfs);
 	g_free(iface->identifier);
-	g_free(iface->network.essid);
+	g_free(iface->network.identifier);
+	g_free(iface->network.passphrase);
 	g_free(iface->device.driver);
 	g_free(iface->device.vendor);
 	g_free(iface->device.product);
@@ -1160,7 +1158,8 @@ static int probe_device(LibHalContext *ctx,
 	__connman_iface_load(iface);
 
 	DBG("iface %p network %s secret %s", iface,
-				iface->network.essid, iface->network.psk);
+					iface->network.identifier,
+					iface->network.passphrase);
 
 	conn = libhal_ctx_get_dbus_connection(ctx);
 

commit 451d80c342f0ed95363b7056221544207323bbaa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:51:59 2008 +0100

    Change 802.11 plugin to use D-Bus interface of supplicant

diff --git a/plugins/80211.c b/plugins/80211.c
index 1bada4fc..d21eec64 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -43,156 +43,10 @@
 
 #include "supplicant.h"
 
-#ifndef IW_EV_LCP_PK_LEN
-#define IW_EV_LCP_PK_LEN	(4)
-#endif
-
-struct station_data {
-	char *address;
-	char *name;
-	int mode;
-	int qual;
-	int noise;
-	int level;
-
-	unsigned char wpa_ie[40];
-	int wpa_ie_len;
-	unsigned char rsn_ie[40];
-	int rsn_ie_len;
-
-	int has_wep;
-	int has_wpa;
-	int has_rsn;
-};
-
 struct iface_data {
 	char ifname[IFNAMSIZ];
-	GSList *stations;
-
-	gchar *network;
-	gchar *passphrase;
 };
 
-static void report_station(struct connman_iface *iface,
-						struct station_data *station)
-{
-	int security = 0;
-
-	if (station == NULL)
-		return;
-
-	if (station->name == NULL)
-		return;
-
-	if (station->has_wep)
-		security |= 0x01;
-	if (station->has_wpa)
-		security |= 0x02;
-	if (station->has_rsn)
-		security |= 0x04;
-
-	connman_iface_indicate_station(iface, station->name,
-						station->qual, security);
-}
-
-static struct station_data *create_station(struct iface_data *iface,
-							const char *address)
-{
-	struct station_data *station;
-	GSList *list;
-
-	for (list = iface->stations; list; list = list->next) {
-		station = list->data;
-
-		if (g_ascii_strcasecmp(station->address, address) == 0)
-			return station;
-	}
-
-	station = g_try_new0(struct station_data, 1);
-	if (station == NULL)
-		return NULL;
-
-	station->address = g_strdup(address);
-	if (station->address == NULL) {
-		g_free(station);
-		return NULL;
-	}
-
-	iface->stations = g_slist_append(iface->stations, station);
-
-	return station;
-}
-
-static void load_stations(struct iface_data *iface)
-{
-	GKeyFile *keyfile;
-	gchar **groups, **group;
-	gsize length;
-
-	keyfile = g_key_file_new();
-
-	if (g_key_file_load_from_file(keyfile, "/tmp/stations.list",
-				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
-		goto done;
-
-	groups = g_key_file_get_groups(keyfile, &length);
-
-	for (group = groups; *group; group++) {
-		struct station_data *station;
-
-		station = create_station(iface, *group);
-		if (station == NULL)
-			continue;
-
-		station->name = g_key_file_get_string(keyfile,
-						*group, "Name", NULL);
-	
-		station->mode = g_key_file_get_integer(keyfile,
-						*group, "Mode", NULL);
-	}
-
-	g_strfreev(groups);
-
-done:
-	g_key_file_free(keyfile);
-
-	printf("[802.11] loaded %d stations\n",
-				g_slist_length(iface->stations));
-}
-
-static void print_stations(struct iface_data *iface)
-{
-	GKeyFile *keyfile;
-	gchar *data;
-	gsize length;
-	GSList *list;
-
-	keyfile = g_key_file_new();
-
-	for (list = iface->stations; list; list = list->next) {
-		struct station_data *station = list->data;
-
-		//printf("Address:%s Mode:%d ESSID:\"%s\" Quality:%d/100\n",
-		//			station->address, station->mode,
-		//				station->name, station->qual);
-
-		if (station->name == NULL)
-			continue;
-
-		g_key_file_set_string(keyfile, station->address,
-						"Name", station->name);
-
-		g_key_file_set_integer(keyfile, station->address,
-						"Mode", station->mode);
-	}
-
-	data = g_key_file_to_data(keyfile, &length, NULL);
-
-	g_file_set_contents("/tmp/stations.list", data, length, NULL);
-
-	g_key_file_free(keyfile);
-}
-
 static int wifi_probe(struct connman_iface *iface)
 {
 	struct iface_data *data;
@@ -231,8 +85,6 @@ static int wifi_probe(struct connman_iface *iface)
 
 	connman_iface_set_data(iface, data);
 
-	load_stations(data);
-
 	return 0;
 }
 
@@ -246,9 +98,6 @@ static void wifi_remove(struct connman_iface *iface)
 
 	connman_iface_set_data(iface, NULL);
 
-	g_free(data->network);
-	g_free(data->passphrase);
-
 	free(data);
 }
 
@@ -277,36 +126,12 @@ static int wifi_stop(struct connman_iface *iface)
 static int wifi_scan(struct connman_iface *iface)
 {
 	struct iface_data *data = connman_iface_get_data(iface);
-	struct iwreq iwr;
-	struct iw_scan_req iws;
-	int sk, err;
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&iws, 0, sizeof(iws));
-	iws.scan_type = IW_SCAN_TYPE_PASSIVE;
-	//iws.scan_type = IW_SCAN_TYPE_ACTIVE;
-
-	memset(&iwr, 0, sizeof(iwr));
-	strncpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
+	__supplicant_scan(iface);
 
-	iwr.u.data.pointer = (caddr_t ) &iws;
-	iwr.u.data.length = sizeof(iws);
-	iwr.u.data.flags = IW_SCAN_DEFAULT;
-
-	err = ioctl(sk, SIOCSIWSCAN, &iwr);
-
-	close(sk);
-
-	if (err < 0)
-		connman_error("%s: scan initiate error %d",
-						data->ifname, errno);
-
-	return err;
+	return 0;
 }
 
 static int wifi_connect(struct connman_iface *iface,
@@ -316,8 +141,7 @@ static int wifi_connect(struct connman_iface *iface,
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_connect(iface, data->network, data->passphrase);
+	__supplicant_connect(iface, network->identifier, network->passphrase);
 
 	return 0;
 }
@@ -328,256 +152,11 @@ static int wifi_disconnect(struct connman_iface *iface)
 
 	DBG("iface %p %s", iface, data->ifname);
 
-	if (data->network != NULL)
-		__supplicant_disconnect(iface);
+	__supplicant_disconnect(iface);
 
 	return 0;
 }
 
-static void wifi_set_network(struct connman_iface *iface,
-						const char *network)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	g_free(data->network);
-
-	data->network = g_strdup(network);
-}
-
-static void wifi_set_passphrase(struct connman_iface *iface,
-						const char *passphrase)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	g_free(data->passphrase);
-
-	data->passphrase = g_strdup(passphrase);
-}
-
-static void parse_genie(struct station_data *station,
-					unsigned char *data, int len)
-{
-	int offset = 0;
-
-	while (offset <= len - 2) {
-		//int i;
-
-		switch (data[offset]) {
-		case 0xdd:	/* WPA1 (and other) */
-			station->has_wpa = 1;
-			break;
-		case 0x30:	/* WPA2 (RSN) */
-			station->has_rsn = 1;
-			break;
-		default:
-			break;
-		}
-
-		//for (i = 0; i < len; i++)
-		//	printf(" %02x", data[i]);
-		//printf("\n");
-
-		offset += data[offset + 1] + 2;
-	}
-}
-
-static void parse_scan_results(struct connman_iface *iface,
-					unsigned char *data, int len)
-{
-	unsigned char *ptr = data;
-	struct station_data *station = NULL;
-	struct ether_addr *eth;
-	char addr[18];
-	int num = 0;
-
-	while (len > IW_EV_LCP_PK_LEN) {
-		struct iw_event *event = (void *) ptr;
-
-		switch (event->cmd) {
-		case SIOCGIWAP:
-			report_station(iface, station);
-			eth = (void *) &event->u.ap_addr.sa_data;
-			sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-			station = create_station(connman_iface_get_data(iface),
-									addr);
-			num++;
-			break;
-		case SIOCGIWESSID:
-			if (station != NULL) {
-				station->name = malloc(event->len - IW_EV_POINT_LEN + 1);
-				if (station->name != NULL) {
-					memset(station->name, 0,
-						event->len - IW_EV_POINT_LEN + 1);
-					memcpy(station->name, ptr + IW_EV_POINT_LEN,
-						event->len - IW_EV_POINT_LEN);
-				}
-			}
-			break;
-		case SIOCGIWNAME:
-			break;
-		case SIOCGIWMODE:
-			if (station != NULL)
-				station->mode = event->u.mode;
-			break;
-		case SIOCGIWFREQ:
-			break;
-		case SIOCGIWENCODE:
-			if (station != NULL) {
-				if (!event->u.data.pointer)
-					event->u.data.flags |= IW_ENCODE_NOKEY;
-
-				if (!(event->u.data.flags & IW_ENCODE_DISABLED))
-					station->has_wep = 1;
-			}
-			break;
-		case SIOCGIWRATE:
-			break;
-		case IWEVQUAL:
-			if (station != NULL) {
-				station->qual = event->u.qual.qual;
-				station->noise = event->u.qual.noise;
-				station->level = event->u.qual.level;
-			}
-			break;
-		case IWEVGENIE:
-			if (station != NULL)
-				parse_genie(station, ptr + 8, event->len - 8);
-			break;
-		case IWEVCUSTOM:
-			break;
-		default:
-			printf("[802.11] scan element 0x%04x (len %d)\n",
-						event->cmd, event->len);
-			if (event->len == 0)
-				len = 0;
-			break;
-		}
-
-		ptr += event->len;
-		len -= event->len;
-	}
-
-	report_station(iface, station);
-
-	printf("[802.11] found %d networks\n", num);
-}
-
-static void scan_results(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-	struct iwreq iwr;
-	void *buf;
-	size_t size;
-	int sk, err, done = 0;
-
-	if (data == NULL)
-		return;
-
-	memset(&iwr, 0, sizeof(iwr));
-	memcpy(iwr.ifr_name, data->ifname, IFNAMSIZ);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return;
-
-	buf = NULL;
-	size = 1024;
-
-	while (!done) {
-		void *newbuf;
-
-		newbuf = g_realloc(buf, size);
-		if (newbuf == NULL) {
-			close(sk);
-			return;
-		}
-
-		buf = newbuf;
-		iwr.u.data.pointer = buf;
-		iwr.u.data.length = size;
-		iwr.u.data.flags = 0;
-
-		err = ioctl(sk, SIOCGIWSCAN, &iwr);
-		if (err < 0) {
-			if (errno == E2BIG)
-				size *= 2;
-			else
-				done = 1;
-		} else {
-			parse_scan_results(iface, iwr.u.data.pointer,
-							iwr.u.data.length);
-			done = 1;
-		}
-	}
-
-	g_free(buf);
-
-	close(sk);
-
-	print_stations(data);
-}
-
-static void wifi_wireless(struct connman_iface *iface,
-					void *data, unsigned short len)
-{
-	struct iw_event *event = data;
-	struct iw_point point;
-	struct ether_addr *eth;
-	char addr[18];
-
-	switch (event->cmd) {
-	case SIOCSIWFREQ:
-		printf("[802.11] Set Frequency (flags %d)\n",
-							event->u.freq.flags);
-		break;
-	case SIOCSIWMODE:
-		printf("[802.11] Set Mode (mode %d)\n", event->u.mode);
-		break;
-	case SIOCSIWESSID:
-		memcpy(&point, data + IW_EV_LCP_LEN -
-					IW_EV_POINT_OFF, sizeof(point));
-		point.pointer = data + IW_EV_LCP_LEN +
-					sizeof(point) - IW_EV_POINT_OFF;
-		printf("[802.11] Set ESSID (length %d flags %d) \"%s\"\n",
-					point.length, point.flags,
-						(char *) point.pointer);
-		break;
-	case SIOCSIWENCODE:
-		printf("[802.11] Set Encryption key (flags %d)\n",
-							event->u.data.flags);
-		break;
-
-	case SIOCGIWAP:
-		eth = (void *) &event->u.ap_addr.sa_data;
-		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-		printf("[802.11] New Access Point %s\n", addr);
-		break;
-	case SIOCGIWSCAN:
-		scan_results(iface);
-		break;
-	default:
-		printf("[802.11] Wireless event (cmd 0x%04x len %d)\n",
-						event->cmd, event->len);
-		break;
-	}
-}
-
 static struct connman_iface_driver wifi_driver = {
 	.name		= "80211",
 	.capability	= "net.80211",
@@ -588,9 +167,6 @@ static struct connman_iface_driver wifi_driver = {
 	.scan		= wifi_scan,
 	.connect	= wifi_connect,
 	.disconnect	= wifi_disconnect,
-	.set_network	= wifi_set_network,
-	.set_passphrase	= wifi_set_passphrase,
-	.rtnl_wireless	= wifi_wireless,
 };
 
 static int wifi_init(void)
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b30b16cb..c8853e12 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -33,21 +33,62 @@
 #include <sys/un.h>
 #include <net/if.h>
 
-#include <glib.h>
+#include <dbus/dbus.h>
+#include <gdbus.h>
+
+#include <connman/log.h>
 
 #include "supplicant.h"
 
+enum supplicant_state {
+	STATE_INACTIVE,
+	STATE_SCANNING,
+	STATE_ASSOCIATING,
+	STATE_ASSOCIATED,
+	STATE_4WAY_HANDSHAKE,
+	STATE_GROUP_HANDSHAKE,
+	STATE_COMPLETED,
+	STATE_DISCONNECTED,
+};
+
+// COMPLETED       ==> ASSOCIATING
+// ASSOCIATED      ==> DISCONNECTED
+// DISCONNECTED    ==> INACTIVE
+
+// DISCONNECTED    ==> SCANNING
+// SCANNING        ==> ASSOCIATED
+
+// ASSOCIATING     ==> ASSOCIATED
+// ASSOCIATED      ==> 4WAY_HANDSHAKE
+// 4WAY_HANDSHAKE  ==> GROUP_HANDSHAKE
+// GROUP_HANDSHAKE ==> COMPLETED
+
 struct supplicant_task {
-	GPid pid;
+	DBusConnection *conn;
 	int ifindex;
-	char *ifname;
+	gchar *ifname;
 	struct connman_iface *iface;
-	int socket;
-	GIOChannel *channel;
+	gchar *path;
+	gboolean created;
+	gchar *network;
+	enum supplicant_state state;
 };
 
 static GSList *tasks = NULL;
 
+struct supplicant_ap {
+	gchar *identifier;
+	GByteArray *ssid;
+	guint capabilities;
+	gboolean has_wep;
+	gboolean has_wpa;
+	gboolean has_rsn;
+};
+
+#define IEEE80211_CAP_ESS       0x0001
+#define IEEE80211_CAP_IBSS      0x0002
+#define IEEE80211_CAP_PRIVACY   0x0010
+
 static struct supplicant_task *find_task(int ifindex)
 {
 	GSList *list;
@@ -62,95 +103,715 @@ static struct supplicant_task *find_task(int ifindex)
 	return NULL;
 }
 
-static int exec_cmd(struct supplicant_task *task, char *cmd)
+static int get_interface(struct supplicant_task *task)
 {
-	return write(task->socket, cmd, strlen(cmd));
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "getInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to get interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for interface");
+		dbus_message_unref(reply);
+		return -EIO;
+	}
+
+	DBG("path %s", path);
+
+	task->path = g_strdup(path);
+	task->created = FALSE;
+
+	dbus_message_unref(reply);
+
+	return 0;
 }
 
-static gboolean control_event(GIOChannel *chan,
-				GIOCondition cond, gpointer data)
+static int add_interface(struct supplicant_task *task)
 {
-	struct supplicant_task *task = data;
-	char buf[256];
-	gsize len;
-	GIOError err;
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
 
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
-		return FALSE;
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "addInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
 
-	memset(buf, 0, sizeof(buf));
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
 
-	err = g_io_channel_read(chan, buf, sizeof(buf), &len);
-	if (err) {
-		if (err == G_IO_ERROR_AGAIN)
-			return TRUE;
-		return FALSE;
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to add interface");
+		dbus_message_unref(message);
+		return -EIO;
 	}
 
-	if (buf[0] != '<')
-		return TRUE;
+	dbus_message_unref(message);
 
-	printf("[SUPPLICANT] %s\n", buf + 3);
+	dbus_error_init(&error);
 
-	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-CONNECTED") == TRUE) {
-		printf("[SUPPLICANT] connected\n");
-		connman_iface_indicate_connected(task->iface);
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for interface");
+		dbus_message_unref(reply);
+		return -EIO;
 	}
 
-	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-DISCONNECTED") == TRUE) {
-		printf("[SUPPLICANT] disconnected\n");
+	DBG("path %s", path);
+
+	task->path = g_strdup(path);
+	task->created = TRUE;
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int add_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "addNetwork");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to add network");
+		dbus_message_unref(message);
+		return -EIO;
 	}
 
-	if (g_str_has_prefix(buf + 3, "CTRL-EVENT-TERMINATING") == TRUE) {
-		printf("[SUPPLICANT] terminating\n");
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for network");
+		dbus_message_unref(reply);
+		return -EIO;
 	}
 
-	return TRUE;
+	DBG("path %s", path);
+
+	task->network = g_strdup(path);
+
+	dbus_message_unref(reply);
+
+	return 0;
 }
 
-static int open_control(struct supplicant_task *task)
+static int remove_network(struct supplicant_task *task)
 {
-	struct sockaddr_un addr;
-	int sk;
+	DBusMessage *message, *reply;
+	DBusError error;
 
-	printf("[SUPPLICANT] open control for %s\n", task->ifname);
+	DBG("task %p", task);
 
-	sk = socket(PF_UNIX, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "removeNetwork");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->network,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to remove network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int select_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
 
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
-	snprintf(addr.sun_path, sizeof(addr.sun_path),
-					"%s/%s.cli", STATEDIR, task->ifname);
-	//unlink(addr.sun_path);
+	DBG("task %p", task);
 
-	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		close(sk);
-		return -1;
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "selectNetwork");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->network,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to select network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int enable_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+					SUPPLICANT_INTF ".Network", "enable");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to enable network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int disable_network(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+					SUPPLICANT_INTF ".Network", "disable");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to disable network");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
 	}
 
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
-	snprintf(addr.sun_path, sizeof(addr.sun_path),
-					"%s/%s", STATEDIR, task->ifname);
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
 
-	if (connect(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		close(sk);
-		return -1;
+static int set_network(struct supplicant_task *task, const char *network,
+						const char *passphrase)
+{
+	DBusMessage *message, *reply;
+	DBusMessageIter array, dict;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+					SUPPLICANT_INTF ".Network", "set");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_iter_init_append(message, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_entry(&dict, "ssid", DBUS_TYPE_STRING, &network);
+
+	if (passphrase && strlen(passphrase) > 0) {
+		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		//exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
+
+		append_entry(&dict, "psk", DBUS_TYPE_STRING, &passphrase);
+	} else {
+		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
+		//exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
 	}
 
-	task->socket = sk;
+	dbus_message_iter_close_container(&array, &dict);
 
-	task->channel = g_io_channel_unix_new(sk);
-	g_io_channel_set_close_on_unref(task->channel, TRUE);
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to set network options");
+		dbus_message_unref(message);
+		return -EIO;
+	}
 
-	g_io_add_watch(task->channel,
-			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
-						control_event, task);
+	dbus_message_unref(message);
 
-	exec_cmd(task, "ATTACH");
-	exec_cmd(task, "ADD_NETWORK");
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int initiate_scan(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+					SUPPLICANT_INTF ".Interface", "scan");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to initiate scan");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static void extract_ssid(struct supplicant_ap *ap, DBusMessageIter *value)
+{
+	DBusMessageIter array;
+	unsigned char *ssid;
+	int ssid_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ssid, &ssid_len);
+
+	ap->identifier = g_strdup((char *) ssid);
+}
+
+static void extract_wpaie(struct supplicant_ap *ap, DBusMessageIter *value)
+{
+	DBusMessageIter array;
+	unsigned char *ie;
+	int ie_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
+
+	if (ie_len > 0)
+		ap->has_wpa = TRUE;
+}
+
+static void extract_rsnie(struct supplicant_ap *ap, DBusMessageIter *value)
+{
+	DBusMessageIter array;
+	unsigned char *ie;
+	int ie_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
+
+	if (ie_len > 0)
+		ap->has_rsn = TRUE;
+}
+
+static void extract_capabilites(struct supplicant_ap *ap,
+						DBusMessageIter *value)
+{
+	guint capabilities;
+
+	dbus_message_iter_get_basic(value, &capabilities);
+
+	ap->capabilities = capabilities;
+
+	if (capabilities & IEEE80211_CAP_PRIVACY)
+		ap->has_wep = TRUE;
+}
+
+static int parse_network_properties(struct supplicant_task *task,
+							DBusMessage *message)
+{
+	DBusMessageIter array, dict;
+	struct supplicant_ap *ap;
+	int security = 0;
+
+	DBG("task %p", task);
+
+	ap = g_try_new0(struct supplicant_ap, 1);
+	if (ap == NULL)
+		return -ENOMEM;
+
+	dbus_message_iter_init(message, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		//dbus_message_iter_get_basic(&value, &val);
+
+		if (g_str_equal(key, "ssid") == TRUE)
+			extract_ssid(ap, &value);
+		else if (g_str_equal(key, "wpaie") == TRUE)
+			extract_wpaie(ap, &value);
+		else if (g_str_equal(key, "rsnie") == TRUE)
+			extract_rsnie(ap, &value);
+		else if (g_str_equal(key, "capabilities") == TRUE)
+			extract_capabilites(ap, &value);
+
+		dbus_message_iter_next(&dict);
+	}
+
+	DBG("SSID %s", ap->identifier);
+
+	if (ap->has_wep)
+		security |= 0x01;
+	if (ap->has_wpa)
+		security |= 0x02;
+	if (ap->has_rsn)
+		security |= 0x04;
+
+	connman_iface_indicate_station(task->iface,
+					ap->identifier, 25, security);
+
+	g_free(ap);
+
+	return 0;
+}
+
+static int get_network_properties(struct supplicant_task *task,
+							const char *path)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, path,
+						SUPPLICANT_INTF ".BSSID",
+								"properties");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to get network properties");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	parse_network_properties(task, reply);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int scan_results_available(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	char **results;
+	int i, num_results;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+						SUPPLICANT_INTF ".Interface",
+							"scanResults");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to request scan result");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error,
+				DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+						&results, &num_results,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for scan result");
+		dbus_message_unref(reply);
+		return -EIO;
+	}
+
+	for (i = 0; i < num_results; i++)
+		get_network_properties(task, results[i]);
+
+	g_strfreev(results);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static void state_change(struct supplicant_task *task, DBusMessage *msg)
+{
+	DBusError error;
+	const char *state, *previous;
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(msg, &error, DBUS_TYPE_STRING, &state,
+						DBUS_TYPE_STRING, &previous,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for state change");
+		return;
+	}
+
+	DBG("state %s ==> %s", previous, state);
+
+	if (g_str_equal(state, "INACTIVE") == TRUE)
+		task->state = STATE_INACTIVE;
+	else if (g_str_equal(state, "SCANNING") == TRUE)
+		task->state = STATE_SCANNING;
+	else if (g_str_equal(state, "ASSOCIATING") == TRUE)
+		task->state = STATE_ASSOCIATING;
+	else if (g_str_equal(state, "ASSOCIATED") == TRUE)
+		task->state = STATE_ASSOCIATED;
+	else if (g_str_equal(state, "GROUP_HANDSHAKE") == TRUE)
+		task->state = STATE_4WAY_HANDSHAKE;
+	else if (g_str_equal(state, "4WAY_HANDSHAKE") == TRUE)
+		task->state = STATE_4WAY_HANDSHAKE;
+	else if (g_str_equal(state, "COMPLETED") == TRUE)
+		task->state = STATE_COMPLETED;
+	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
+		task->state = STATE_DISCONNECTED;
+}
+
+static DBusHandlerResult supplicant_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
+{
+	struct supplicant_task *task = data;
+	const char *member;
+
+	if (dbus_message_has_interface(msg,
+				SUPPLICANT_INTF ".Interface") == FALSE)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	member = dbus_message_get_member(msg);
+	if (member == NULL)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	DBG("task %p member %s", task, member);
+
+	if (g_str_equal(member, "ScanResultsAvailable") == TRUE)
+		scan_results_available(task);
+	else if (g_str_equal(member, "StateChange") == TRUE)
+		state_change(task, msg);
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static int add_filter(struct supplicant_task *task)
+{
+	DBusError error;
+	gchar *filter;
+
+	if (dbus_connection_add_filter(task->conn,
+				supplicant_filter, task, NULL) == FALSE)
+		return -EIO;
+
+	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
+						SUPPLICANT_INTF, task->path);
+
+	DBG("filter %s", filter);
+
+	dbus_error_init(&error);
+
+	dbus_bus_add_match(task->conn, filter, &error);
+
+	g_free(filter);
+
+	if (dbus_error_is_set(&error) == TRUE) {
+		connman_error("Can't add match: %s", error.message);
+		dbus_error_free(&error);
+	}
 
 	return 0;
 }
@@ -159,7 +820,6 @@ int __supplicant_start(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct supplicant_task *task;
-	char *argv[9];
 	int sk, err;
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
@@ -176,14 +836,14 @@ int __supplicant_start(struct connman_iface *iface)
 	if (err < 0)
 		return -EIO;
 
-	printf("[SUPPLICANT] start %s\n", ifr.ifr_name);
+	DBG("interface %s", ifr.ifr_name);
 
 	task = g_try_new0(struct supplicant_task, 1);
 	if (task == NULL)
 		return -ENOMEM;
 
 	task->ifindex = iface->index;
-	task->ifname = strdup(ifr.ifr_name);
+	task->ifname = g_strdup(ifr.ifr_name);
 	task->iface = iface;
 
 	if (task->ifname == NULL) {
@@ -191,32 +851,33 @@ int __supplicant_start(struct connman_iface *iface)
 		return -ENOMEM;
 	}
 
-	argv[0] = "/sbin/wpa_supplicant";
-	argv[1] = "-qq";
-	argv[2] = "-C";
-	argv[3] = STATEDIR;
-	argv[4] = "-D";
-	argv[5] = "wext";
-	argv[6] = "-i";
-	argv[7] = task->ifname;
-	argv[8] = NULL;
-
-	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
-				NULL, NULL, &task->pid, NULL) == FALSE) {
-		printf("Failed to spawn wpa_supplicant\n");
-		return -1;
+	task->conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (task->conn == NULL) {
+		g_free(task);
+		return -EIO;
+	}
+
+	task->created = FALSE;
+
+	err = get_interface(task);
+	if (err < 0) {
+		err = add_interface(task);
+		if (err < 0) {
+			g_free(task);
+			return err;
+		}
 	}
 
-	tasks = g_slist_append(tasks, task);
+	task->state = STATE_INACTIVE;
 
-	printf("[SUPPLICANT] executed with pid %d\n", task->pid);
+	tasks = g_slist_append(tasks, task);
 
-	sleep(1);
+	add_filter(task);
 
-	task->socket = -1;
+	add_network(task);
 
-	if (open_control(task) < 0)
-		printf("[SUPPLICANT] control failed\n");
+	select_network(task);
+	disable_network(task);
 
 	return 0;
 }
@@ -224,33 +885,51 @@ int __supplicant_start(struct connman_iface *iface)
 int __supplicant_stop(struct connman_iface *iface)
 {
 	struct supplicant_task *task;
-	char pathname[PATH_MAX];
 
 	task = find_task(iface->index);
 	if (task == NULL)
 		return -ENODEV;
 
-	printf("[SUPPLICANT] stop %s\n", task->ifname);
+	DBG("interface %s", task->ifname);
 
 	tasks = g_slist_remove(tasks, task);
 
-	exec_cmd(task, "DISABLE_NETWORK 0");
-	exec_cmd(task, "DETACH");
+	remove_network(task);
 
-	sleep(1);
+	dbus_connection_unref(task->conn);
+
+	g_free(task->ifname);
+	g_free(task->network);
+	g_free(task->path);
+	g_free(task);
 
-	kill(task->pid, SIGTERM);
+	return 0;
+}
 
-	g_io_channel_shutdown(task->channel, TRUE, NULL);
-	g_io_channel_unref(task->channel);
+int __supplicant_scan(struct connman_iface *iface)
+{
+	struct supplicant_task *task;
+	int err;
 
-	snprintf(pathname, sizeof(pathname),
-					"%s/%s.cli", STATEDIR, task->ifname);
-	unlink(pathname);
+	task = find_task(iface->index);
+	if (task == NULL)
+		return -ENODEV;
 
-	free(task->ifname);
+	DBG("interface %s", task->ifname);
+
+	switch (task->state) {
+	case STATE_SCANNING:
+		return -EALREADY;
+	case STATE_ASSOCIATING:
+	case STATE_ASSOCIATED:
+	case STATE_4WAY_HANDSHAKE:
+	case STATE_GROUP_HANDSHAKE:
+		return -EBUSY;
+	default:
+		break;
+	}
 
-	g_free(task);
+	err = initiate_scan(task);
 
 	return 0;
 }
@@ -259,34 +938,16 @@ int __supplicant_connect(struct connman_iface *iface,
 				const char *network, const char *passphrase)
 {
 	struct supplicant_task *task;
-	char cmd[128];
 
 	task = find_task(iface->index);
 	if (task == NULL)
 		return -ENODEV;
 
-	printf("[SUPPLICANT] connect %s\n", task->ifname);
-
-	exec_cmd(task, "DISABLE_NETWORK 0");
-
-	if (network == NULL)
-		return 0;
-
-	sprintf(cmd, "SET_NETWORK 0 ssid \"%s\"", network);
-	exec_cmd(task, cmd);
+	DBG("interface %s", task->ifname);
 
-	if (passphrase && strlen(passphrase) > 0) {
-		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
-
-		sprintf(cmd, "SET_NETWORK 0 psk \"%s\"", passphrase);
-		exec_cmd(task, cmd);
-	} else {
-		exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
-	}
+	set_network(task, network, passphrase);
 
-	exec_cmd(task, "ENABLE_NETWORK 0");
+	enable_network(task);
 
 	return 0;
 }
@@ -299,9 +960,9 @@ int __supplicant_disconnect(struct connman_iface *iface)
 	if (task == NULL)
 		return -ENODEV;
 
-	printf("[SUPPLICANT] disconnect %s\n", task->ifname);
+	DBG("interface %s", task->ifname);
 
-	exec_cmd(task, "DISABLE_NETWORK 0");
+	disable_network(task);
 
 	return 0;
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index dc015ed7..59e4dfe9 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -21,9 +21,15 @@
 
 #include <connman/iface.h>
 
+#define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
+
 int __supplicant_start(struct connman_iface *iface);
 int __supplicant_stop(struct connman_iface *iface);
 
+int __supplicant_scan(struct connman_iface *iface);
+
 int __supplicant_connect(struct connman_iface *iface,
 				const char *network, const char *passphrase);
 int __supplicant_disconnect(struct connman_iface *iface);

commit 7294e829c825e0f7b56b4fdb83dbc2939c33ca71
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 14:53:14 2008 +0100

    Add simple test script for D-Bus supplicant

diff --git a/test/Makefile.am b/test/Makefile.am
index f3ae1831..02760295 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,4 +1,5 @@
 
-EXTRA_DIST = list-interfaces start-scanning simple-agent show-introspection
+EXTRA_DIST = list-interfaces start-scanning simple-agent \
+				show-introspection test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/test-supplicant b/test/test-supplicant
new file mode 100755
index 00000000..e79228dd
--- /dev/null
+++ b/test/test-supplicant
@@ -0,0 +1,59 @@
+#!/usr/bin/python
+
+import dbus
+import time
+
+WPA_NAME='fi.epitest.hostap.WPASupplicant'
+WPA_INTF='fi.epitest.hostap.WPASupplicant'
+WPA_PATH='/fi/epitest/hostap/WPASupplicant'
+
+bus = dbus.SystemBus()
+
+dummy = dbus.Interface(bus.get_object(WPA_NAME, WPA_PATH),
+				'org.freedesktop.DBus.Introspectable')
+
+#print dummy.Introspect()
+
+manager = dbus.Interface(bus.get_object(WPA_NAME, WPA_PATH), WPA_INTF)
+
+try:
+	path = manager.getInterface("wlan0")
+except:
+	path = manager.addInterface("wlan0")
+
+interface = dbus.Interface(bus.get_object(WPA_NAME, path),
+					WPA_INTF + ".Interface")
+
+print interface.state()
+
+print interface.scan()
+
+print "[ %s ]" % (path)
+
+capabilities = interface.capabilities()
+
+for key in capabilities.keys():
+	list = ""
+	for value in capabilities[key]:
+		list += " " + value
+	print "    %s =%s" % (key, list)
+
+time.sleep(2)
+
+print interface.state()
+
+results = interface.scanResults()
+
+print results
+
+path = results[0]
+
+print "[ %s ]" % (path)
+
+bssid = dbus.Interface(bus.get_object(WPA_NAME, path),
+					WPA_INTF + ".BSSID")
+
+properties = bssid.properties()
+
+for key in properties.keys():
+	print "    %s = %s" % (key, properties[key])

commit 7b820de508eeac0f7a38dc795dd224e7f283df52
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 12 15:11:31 2008 +0100

    Add D-Bus configuration files for supplicant

diff --git a/.gitignore b/.gitignore
index 4fb1449a..722951ea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,3 +27,4 @@ src/connmand
 src/connman.service
 scripts/connman
 scripts/dhclient-script
+scripts/fi.epitest.hostap.WPASupplicant.service
diff --git a/configure.in b/configure.in
index ba478e16..9918d72f 100644
--- a/configure.in
+++ b/configure.in
@@ -41,6 +41,8 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
+AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
+
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
 				AC_MSG_ERROR(gmodule is required))
 AC_SUBST(GMODULE_CFLAGS)
@@ -63,4 +65,6 @@ AC_SUBST(HAL_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
 			test/Makefile plugins/Makefile scripts/Makefile
+			scripts/fi.epitest.hostap.WPASupplicant.service
 			scripts/connman src/connman.service connman.pc)
+			
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 1247398f..b860d5bd 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -3,7 +3,15 @@ initdir = $(sysconfdir)/init.d
 
 init_SCRIPTS = connman
 
-DISTCLEANFILES = $(init_SCRIPTS)
+dbusdir = $(sysconfdir)/dbus-1/system.d
+
+dbus_DATA = fi.epitest.hostap.WPASupplicant.conf
+
+servicedir = $(datadir)/dbus-1/system-services
+
+service_DATA = fi.epitest.hostap.WPASupplicant.service
+
+DISTCLEANFILES = $(init_SCRIPTS) $(service_DATA)
 
 scriptdir = $(libdir)/connman/scripts
 
@@ -15,6 +23,6 @@ dhclient_script_LDADD = @DBUS_LIBS@
 
 AM_CFLAGS = @DBUS_CFLAGS@
 
-EXTRA_DIST = $(script_DATA)
+EXTRA_DIST = $(script_DATA) $(dbus_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/scripts/fi.epitest.hostap.WPASupplicant.conf b/scripts/fi.epitest.hostap.WPASupplicant.conf
new file mode 100644
index 00000000..fa7afca0
--- /dev/null
+++ b/scripts/fi.epitest.hostap.WPASupplicant.conf
@@ -0,0 +1,10 @@
+<!DOCTYPE busconfig PUBLIC
+ "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+	<policy user="root">
+		<allow own="fi.epitest.hostap.WPASupplicant"/>
+		<allow send_destination="fi.epitest.hostap.WPASupplicant"/>
+		<allow send_interface="fi.epitest.hostap.WPASupplicant"/>
+	</policy>
+</busconfig>
diff --git a/scripts/fi.epitest.hostap.WPASupplicant.service.in b/scripts/fi.epitest.hostap.WPASupplicant.service.in
new file mode 100644
index 00000000..cdd2a030
--- /dev/null
+++ b/scripts/fi.epitest.hostap.WPASupplicant.service.in
@@ -0,0 +1,4 @@
+[D-BUS Service]
+Name=fi.epitest.hostap.WPASupplicant
+Exec=@WPASUPPLICANT@ -u
+User=root

commit 044f4199fa31ff8ec4f9c91c051e05fc3cf14d0f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 13 23:27:05 2008 +0100

    Use list of known networks to re-connect to

diff --git a/src/connman.h b/src/connman.h
index c253a8e3..f9416d2f 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -70,6 +70,8 @@ int __connman_iface_init_via_inet(struct connman_iface *iface);
 int __connman_iface_up(struct connman_iface *iface);
 int __connman_iface_down(struct connman_iface *iface);
 
+char *__connman_iface_find_passphrase(struct connman_iface *iface,
+							const char *network);
 int __connman_iface_load(struct connman_iface *iface);
 int __connman_iface_store(struct connman_iface *iface);
 
diff --git a/src/iface-storage.c b/src/iface-storage.c
index a5b57a38..7872f7cc 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -32,10 +32,62 @@
 
 #define GROUP_CONFIG  "Config"
 
+char *__connman_iface_find_passphrase(struct connman_iface *iface,
+							const char *network)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *result = NULL;
+	gchar **list;
+	gsize list_len;
+	int i;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return NULL;
+
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
+	if (pathname == NULL)
+		return NULL;
+
+	keyfile = g_key_file_new();
+
+	g_key_file_set_list_separator(keyfile, ',');
+
+	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
+		goto done;
+
+	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
+		goto done;
+
+	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
+					"KnownNetworks", &list_len, NULL);
+	for (i = 0; i < list_len; i++)
+		if (g_str_equal(list[i], network) == TRUE) {
+			result = g_key_file_get_string(keyfile, network,
+								"PSK", NULL);
+			if (result == NULL)
+				result = g_strdup("");
+			break;
+		}
+
+	g_strfreev(list);
+
+done:
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return result;
+}
+
 int __connman_iface_load(struct connman_iface *iface)
 {
 	GKeyFile *keyfile;
 	gchar *pathname, *str;
+	gchar **list;
+	gsize list_len;
 
 	DBG("iface %p", iface);
 
@@ -49,6 +101,8 @@ int __connman_iface_load(struct connman_iface *iface)
 
 	keyfile = g_key_file_new();
 
+	g_key_file_set_list_separator(keyfile, ',');
+
 	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
 		goto done;
 
@@ -61,7 +115,13 @@ int __connman_iface_load(struct connman_iface *iface)
 		g_free(str);
 	}
 
-	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Network", NULL);
+	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
+					"KnownNetworks", &list_len, NULL);
+
+	g_strfreev(list);
+
+	str = g_key_file_get_string(keyfile, GROUP_CONFIG,
+						"LastNetwork", NULL);
 	if (str != NULL) {
 		g_free(iface->network.identifier);
 		iface->network.identifier = str;
@@ -93,9 +153,10 @@ static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
 
 	if (iface->network.identifier != NULL) {
 		g_key_file_set_string(keyfile, GROUP_CONFIG,
-				"Network", iface->network.identifier);
+				"LastNetwork", iface->network.identifier);
 	} else
-		g_key_file_remove_key(keyfile, GROUP_CONFIG, "Network", NULL);
+		g_key_file_remove_key(keyfile, GROUP_CONFIG,
+						"LastNetwork", NULL);
 
 	if (iface->network.identifier != NULL)
 		g_key_file_set_string(keyfile, iface->network.identifier,
diff --git a/src/iface.c b/src/iface.c
index b9fe5133..a35d22aa 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -360,6 +360,7 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 				const char *name, int strength, int security)
 {
 	DBusMessage *signal;
+	char *passphrase;
 
 	DBG("iface %p security %d name %s", iface, security, name);
 
@@ -376,9 +377,15 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
 
-	if (g_str_equal(name, iface->network.identifier) == TRUE &&
-			iface->state == CONNMAN_IFACE_STATE_SCANNING) {
+	if (iface->state != CONNMAN_IFACE_STATE_SCANNING)
+		return;
+
+	passphrase = __connman_iface_find_passphrase(iface, name);
+	if (passphrase != NULL) {
+		g_free(iface->network.identifier);
 		iface->network.identifier = g_strdup(name);
+		g_free(iface->network.passphrase);
+		iface->network.passphrase = passphrase;
 
 		if (iface->driver->connect) {
 			iface->driver->connect(iface, &iface->network);

commit 33cb960a324fd72da810168b4fe5e234802cd70f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 13 23:34:03 2008 +0100

    Use debug helper for the RTNL debugging output

diff --git a/src/rtnl.c b/src/rtnl.c
index e4996fb9..c4fbf447 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -23,7 +23,6 @@
 #include <config.h>
 #endif
 
-#include <stdio.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/socket.h>
@@ -57,30 +56,30 @@ static inline void print_inet(struct rtattr *attr, const char *name, int family)
 	if (family == AF_INET) {
 		struct in_addr addr;
 		addr = *((struct in_addr *) RTA_DATA(attr));
-		printf("  attr %s (len %jd) %s\n",
+		DBG("  attr %s (len %jd) %s\n",
 				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
 	} else
-		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
+		DBG("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 }
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
+	DBG("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_byte(struct rtattr *attr, const char *name)
 {
-	printf("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
+	DBG("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
 					*((unsigned char *) RTA_DATA(attr)));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		printf("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
+		DBG("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
 	else
-		printf("  attr %d (len %jd)\n",
+		DBG("  attr %d (len %jd)\n",
 					attr->rta_type, RTA_PAYLOAD(attr));
 }
 

commit 50d81ec56ebdc56fc72d80c189751b40f76738e2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 10:44:57 2008 +0100

    Add debug line for found passphrases

diff --git a/src/iface.c b/src/iface.c
index a35d22aa..4a655a14 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -382,6 +382,8 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 
 	passphrase = __connman_iface_find_passphrase(iface, name);
 	if (passphrase != NULL) {
+		DBG("network %s passphrase %s", name, passphrase);
+
 		g_free(iface->network.identifier);
 		iface->network.identifier = g_strdup(name);
 		g_free(iface->network.passphrase);

commit 1b42fcf6db8cbbcc8cb67dab136b97249c0f0329
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:02:06 2008 +0100

    Add abstraction for resolver modifications

diff --git a/include/Makefile.am b/include/Makefile.am
index ecca9287..4c10f173 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h
+noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h resolver.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/resolver.h b/include/resolver.h
new file mode 100644
index 00000000..3d9f9902
--- /dev/null
+++ b/include/resolver.h
@@ -0,0 +1,44 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_RESOLVER_H
+#define __CONNMAN_RESOLVER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/iface.h>
+
+struct connman_resolver_driver {
+	const char *name;
+	int (*append) (struct connman_iface *iface, const char *nameserver);
+	int (*remove) (struct connman_iface *iface);
+};
+
+extern int connman_resolver_register(struct connman_resolver_driver *driver);
+extern void connman_resolver_unregister(struct connman_resolver_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_RESOLVER_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 7faf6a22..f430368f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -13,7 +13,7 @@ sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
 				iface.c iface-storage.c iface-helper.c \
-						iface-inet.c rtnl.c dhcp.c
+					iface-inet.c rtnl.c dhcp.c resolver.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/connman.h b/src/connman.h
index f9416d2f..9f1262a0 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -94,3 +94,9 @@ int __connman_rtnl_send(const void *buf, size_t len);
 
 int __connman_dhcp_request(struct connman_iface *iface);
 int __connman_dhcp_release(struct connman_iface *iface);
+
+#include <connman/resolver.h>
+
+int __connman_resolver_append(struct connman_iface *iface,
+						const char *nameserver);
+int __connman_resolver_remove(struct connman_iface *iface);
diff --git a/src/iface.c b/src/iface.c
index 4a655a14..89763aaf 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -431,7 +431,6 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 	struct ifreq ifr;
 	struct rtentry rt;
 	struct sockaddr_in *addr;
-	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -504,12 +503,7 @@ int connman_iface_set_ipv4(struct connman_iface *iface,
 		return -1;
 	}
 
-	sprintf(cmd, "echo \"nameserver %s\" | resolvconf -a %s",
-				inet_ntoa(ipv4->nameserver), ifr.ifr_name);
-
-	DBG("%s", cmd);
-
-	err = system(cmd);
+	__connman_resolver_append(iface, inet_ntoa(ipv4->nameserver));
 
 	return 0;
 }
@@ -518,7 +512,6 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct sockaddr_in *addr;
-	char cmd[128];
 	int sk, err;
 
 	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
@@ -554,11 +547,7 @@ int connman_iface_clear_ipv4(struct connman_iface *iface)
 		return -1;
 	}
 
-	sprintf(cmd, "resolvconf -d %s", ifr.ifr_name);
-
-	DBG("%s", cmd);
-
-	err = system(cmd);
+	__connman_resolver_remove(iface);
 
 	return 0;
 }
diff --git a/src/resolver.c b/src/resolver.c
new file mode 100644
index 00000000..f2443d76
--- /dev/null
+++ b/src/resolver.c
@@ -0,0 +1,67 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+
+#include "connman.h"
+
+static GSList *drivers = NULL;
+
+int connman_resolver_register(struct connman_resolver_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_append(drivers, driver);
+
+	return 0;
+}
+
+void connman_resolver_unregister(struct connman_resolver_driver *driver)
+{
+	DBG("driver %p", driver);
+
+	drivers = g_slist_remove(drivers, driver);
+}
+
+int __connman_resolver_append(struct connman_iface *iface,
+						const char *nameserver)
+{
+	struct connman_resolver_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->append)
+		return driver->append(iface, nameserver);
+
+	return -1;
+}
+
+int __connman_resolver_remove(struct connman_iface *iface)
+{
+	struct connman_resolver_driver *driver = g_slist_nth_data(drivers, 0);
+
+	if (driver && driver->remove)
+		return driver->remove(iface);
+
+	return -1;
+}

commit a5541065ee14e6582402ce586009c3144fcff33f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:02:49 2008 +0100

    Add resolver plugin using resolvconf helper tool

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2f789ec3..87464b04 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,7 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
-			libconnman-dhclient.la
+			libconnman-dhclient.la libconnman-resolvconf.la
 
 libconnman_80203_la_SOURCES = 80203.c
 
@@ -11,6 +11,8 @@ libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
 
+libconnman_resolvconf_la_SOURCES = resolvconf.c
+
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
 statedir = $(localstatedir)/run/connman
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
new file mode 100644
index 00000000..732db4f0
--- /dev/null
+++ b/plugins/resolvconf.c
@@ -0,0 +1,118 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+
+#include <connman/plugin.h>
+#include <connman/resolver.h>
+#include <connman/log.h>
+
+static int resolvconf_append(struct connman_iface *iface, const char *nameserver)
+{
+	struct ifreq ifr;
+	char cmd[128];
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -1;
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	snprintf(cmd, sizeof(cmd), "echo \"nameserver %s\" | resolvconf -a %s",
+						nameserver, ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	err = system(cmd);
+
+	return 0;
+}
+
+static int resolvconf_remove(struct connman_iface *iface)
+{
+	struct ifreq ifr;
+	char cmd[128];
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = iface->index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -1;
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	snprintf(cmd, sizeof(cmd), "resolvconf -d %s", ifr.ifr_name);
+
+	DBG("%s", cmd);
+
+	err = system(cmd);
+
+	return 0;
+}
+
+static struct connman_resolver_driver resolvconf_driver = {
+	.name		= "resolvconf",
+	.append		= resolvconf_append,
+	.remove		= resolvconf_remove,
+};
+
+static int resolvconf_init(void)
+{
+	return connman_resolver_register(&resolvconf_driver);
+}
+
+static void resolvconf_exit(void)
+{
+	connman_resolver_unregister(&resolvconf_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("resolvconf", "Name resolver plugin", VERSION,
+					resolvconf_init, resolvconf_exit)

commit b0bb819c7fbc262118cdf3645079a8f867a03b21
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:29:05 2008 +0100

    Add more debug output for known networks

diff --git a/src/iface-storage.c b/src/iface-storage.c
index 7872f7cc..6694d992 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -63,14 +63,19 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 
 	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
 					"KnownNetworks", &list_len, NULL);
-	for (i = 0; i < list_len; i++)
+	for (i = 0; i < list_len; i++) {
+		DBG("known network %s", list[i]);
+
 		if (g_str_equal(list[i], network) == TRUE) {
+			DBG("found network %s", network);
+
 			result = g_key_file_get_string(keyfile, network,
 								"PSK", NULL);
 			if (result == NULL)
 				result = g_strdup("");
 			break;
 		}
+	}
 
 	g_strfreev(list);
 

commit 22d523336fe891bd57af03e919d8fc59be4b2609
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 11:30:08 2008 +0100

    Fix handling of networks without security

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index c8853e12..0ec9304d 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -51,18 +51,6 @@ enum supplicant_state {
 	STATE_DISCONNECTED,
 };
 
-// COMPLETED       ==> ASSOCIATING
-// ASSOCIATED      ==> DISCONNECTED
-// DISCONNECTED    ==> INACTIVE
-
-// DISCONNECTED    ==> SCANNING
-// SCANNING        ==> ASSOCIATED
-
-// ASSOCIATING     ==> ASSOCIATED
-// ASSOCIATED      ==> 4WAY_HANDSHAKE
-// 4WAY_HANDSHAKE  ==> GROUP_HANDSHAKE
-// GROUP_HANDSHAKE ==> COMPLETED
-
 struct supplicant_task {
 	DBusConnection *conn;
 	int ifindex;
@@ -457,13 +445,12 @@ static int set_network(struct supplicant_task *task, const char *network,
 	append_entry(&dict, "ssid", DBUS_TYPE_STRING, &network);
 
 	if (passphrase && strlen(passphrase) > 0) {
-		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		//exec_cmd(task, "SET_NETWORK 0 key_mgmt WPA-PSK");
-
+		const char *key_mgmt = "WPA-PSK";
+		append_entry(&dict, "key_mgmt", DBUS_TYPE_STRING, &key_mgmt);
 		append_entry(&dict, "psk", DBUS_TYPE_STRING, &passphrase);
 	} else {
-		//exec_cmd(task, "SET_NETWORK 0 proto RSN WPA");
-		//exec_cmd(task, "SET_NETWORK 0 key_mgmt NONE");
+		const char *key_mgmt = "NONE";
+		append_entry(&dict, "key_mgmt", DBUS_TYPE_STRING, &key_mgmt);
 	}
 
 	dbus_message_iter_close_container(&array, &dict);

commit dc405c55dc7e4a4cc2533e8103adac7340d6d8de
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 13:33:56 2008 +0100

    Update DHCP plugin to use D-Bus low-level calls

diff --git a/configure.in b/configure.in
index 9918d72f..68301053 100644
--- a/configure.in
+++ b/configure.in
@@ -41,6 +41,7 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
+AC_PATH_PROG(DHCLIENT, [dhclient])
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
 
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 87464b04..3ecb1aef 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -10,6 +10,8 @@ libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
 libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
+libconnman_dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
+		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
 libconnman_resolvconf_la_SOURCES = resolvconf.c
 
@@ -23,8 +25,7 @@ else
 scriptdir = $(libdir)/connman/scripts
 endif
 
-AM_CFLAGS = @GDBUS_CFLAGS@ \
-		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
+AM_CFLAGS = @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 211b84ef..8847a1de 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -29,6 +29,7 @@
 #include <stdlib.h>
 #include <signal.h>
 #include <string.h>
+#include <sys/wait.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
@@ -40,6 +41,9 @@
 #include <connman/plugin.h>
 #include <connman/dhcp.h>
 
+#define DHCLIENT_INTF "org.isc.dhclient"
+#define DHCLIENT_PATH "/org/isc/dhclient"
+
 static const char *busname;
 
 struct dhclient_task {
@@ -83,7 +87,8 @@ static void kill_task(struct dhclient_task *task)
 {
 	char pathname[PATH_MAX];
 
-	kill(task->pid, SIGTERM);
+	if (task->pid > 0)
+		kill(task->pid, SIGTERM);
 
 	snprintf(pathname, sizeof(pathname) - 1,
 			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
@@ -98,11 +103,37 @@ static void kill_task(struct dhclient_task *task)
 	g_free(task);
 }
 
+static void task_died(GPid pid, gint status, gpointer data)
+{
+	struct dhclient_task *task = data;
+
+	if (WIFEXITED(status))
+		printf("[DHCP] exit status %d for %s\n",
+					WEXITSTATUS(status), task->ifname);
+	else
+		printf("[DHCP] signal %d killed %s\n",
+					WTERMSIG(status), task->ifname);
+
+	g_spawn_close_pid(pid);
+	task->pid = 0;
+
+	tasks = g_slist_remove(tasks, task);
+
+	kill_task(task);
+}
+
+static void task_setup(gpointer data)
+{
+	struct dhclient_task *task = data;
+
+	printf("[DHCP] setup %s\n", task->ifname);
+}
+
 static int dhclient_request(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	struct dhclient_task *task;
-	char *argv[16], address[128], pidfile[PATH_MAX];
+	char *argv[16], *envp[1], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
 	int sk, err;
 
@@ -143,7 +174,7 @@ static int dhclient_request(struct connman_iface *iface)
 	snprintf(config, sizeof(config) - 1, "%s/dhclient.conf", SCRIPTDIR);
 	snprintf(script, sizeof(script) - 1, "%s/dhclient-script", SCRIPTDIR);
 
-	argv[0] = "/sbin/dhclient";
+	argv[0] = DHCLIENT;
 	argv[1] = "-d";
 	argv[2] = "-q";
 	argv[3] = "-n";
@@ -160,15 +191,19 @@ static int dhclient_request(struct connman_iface *iface)
 	argv[14] = task->ifname;
 	argv[15] = NULL;
 
-	if (g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
-				NULL, NULL, &task->pid, NULL) == FALSE) {
+	envp[0] = NULL;
+
+	if (g_spawn_async(NULL, argv, envp, G_SPAWN_DO_NOT_REAP_CHILD,
+				task_setup, task, &task->pid, NULL) == FALSE) {
 		printf("Failed to spawn dhclient\n");
 		return -1;
 	}
 
 	tasks = g_slist_append(tasks, task);
 
-	printf("[DHCP] executed with pid %d\n", task->pid);
+	g_child_watch_add(task->pid, task_died, task);
+
+	printf("[DHCP] executed %s with pid %d\n", DHCLIENT, task->pid);
 
 	return 0;
 }
@@ -196,8 +231,8 @@ static struct connman_dhcp_driver dhclient_driver = {
 	.release	= dhclient_release,
 };
 
-static DBusMessage *notify_method(DBusConnection *conn,
-					DBusMessage *msg, void *data)
+static DBusHandlerResult dhclient_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
 {
 	DBusMessageIter iter, dict;
 	dbus_uint32_t pid;
@@ -205,6 +240,9 @@ static DBusMessage *notify_method(DBusConnection *conn,
 	struct connman_ipv4 ipv4;
 	const char *text, *key, *value;
 
+	if (dbus_message_is_method_call(msg, DHCLIENT_INTF, "notify") == FALSE)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
 	memset(&ipv4, 0, sizeof(ipv4));
 
 	dbus_message_iter_init(msg, &iter);
@@ -219,7 +257,7 @@ static DBusMessage *notify_method(DBusConnection *conn,
 
 	task = find_task_by_pid(pid);
 	if (task == NULL)
-		return NULL;
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
 	dbus_message_iter_recurse(&iter, &dict);
 
@@ -267,27 +305,29 @@ static DBusMessage *notify_method(DBusConnection *conn,
 		connman_dhcp_update(task->iface,
 					CONNMAN_DHCP_STATE_FAILED, NULL);
 
-	return NULL;
+	return DBUS_HANDLER_RESULT_HANDLED;
 }
 
-static GDBusMethodTable dhclient_methods[] = {
-	{ "notify", "usa{ss}", "", notify_method, G_DBUS_METHOD_FLAG_NOREPLY },
-	{ },
-};
-
 static DBusConnection *connection;
 
 static int plugin_init(void)
 {
-	connection = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL, NULL);
+	gchar *filter;
+
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 
 	busname = dbus_bus_get_unique_name(connection);
 
-	g_dbus_register_object(connection, "/org/isc/dhclient", NULL, NULL);
+	busname = "org.freedesktop.connman";
+
+	dbus_connection_add_filter(connection, dhclient_filter, NULL, NULL);
+
+	filter = g_strdup_printf("interface=%s,path=%s",
+						DHCLIENT_INTF, DHCLIENT_PATH);
+
+	dbus_bus_add_match(connection, filter, NULL);
 
-	g_dbus_register_interface(connection, "/org/isc/dhclient",
-					"org.isc.dhclient",
-					dhclient_methods, NULL, NULL);
+	g_free(filter);
 
 	connman_dhcp_register(&dhclient_driver);
 
@@ -310,7 +350,7 @@ static void plugin_exit(void)
 
 	connman_dhcp_unregister(&dhclient_driver);
 
-	g_dbus_cleanup_connection(connection);
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("dhclient", "ISC DHCP client plugin", VERSION,
diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
index 39b235c7..f4a8431f 100644
--- a/scripts/dhclient-script.c
+++ b/scripts/dhclient-script.c
@@ -56,6 +56,7 @@ static void append(DBusMessageIter *dict, const char *pattern)
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
+	DBusError error;
 	DBusMessage *msg;
 	DBusMessageIter iter, dict;
 	dbus_uint32_t pid;
@@ -67,17 +68,28 @@ int main(int argc, char *argv[])
 	reason = getenv("reason");
 	interface = getenv("interface");
 
-	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
-	if (conn == NULL)
-		exit(1);
+	dbus_error_init(&error);
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+	if (conn == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			fprintf(stderr, "%s\n", error.message);
+			dbus_error_free(&error);
+		} else
+			fprintf(stderr, "Failed to get on system bus\n");
+		return 0;
+	}
 
 	msg = dbus_message_new_method_call(busname, "/org/isc/dhclient",
 						"org.isc.dhclient", "notify");
 	if (msg == NULL) {
 		dbus_connection_unref(conn);
-		exit(1);
+		fprintf(stderr, "Failed to allocate method call\n");
+		return 0;
 	}
 
+	dbus_message_set_no_reply(msg, TRUE);
+
 	dbus_message_append_args(msg, DBUS_TYPE_UINT32, &pid,
 				DBUS_TYPE_STRING, &reason, DBUS_TYPE_INVALID);
 
@@ -100,7 +112,8 @@ int main(int argc, char *argv[])
 
 	dbus_message_iter_close_container(&iter, &dict);
 
-	dbus_connection_send(conn, msg, NULL);
+	if (dbus_connection_send(conn, msg, NULL) == FALSE)
+		fprintf(stderr, "Failed to send message\n");
 
 	dbus_message_unref(msg);
 

commit 2d73c3b7cff221f5778ee8f82c3f2a44e96984d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 13:34:33 2008 +0100

    Add allow policy for org.isc.dhclient

diff --git a/src/connman.conf b/src/connman.conf
index 4e83980e..4e3567e6 100644
--- a/src/connman.conf
+++ b/src/connman.conf
@@ -3,9 +3,11 @@
 <busconfig>
     <policy user="root">
         <allow own="org.freedesktop.connman"/>
+        <allow send_destination="org.freedesktop.connman"/>
+        <allow send_interface="org.isc.dhclient"/>
     </policy>
     <policy at_console="true">
-        <allow send_interface="org.freedesktop.connman"/>
         <allow send_destination="org.freedesktop.connman"/>
+        <allow send_interface="org.freedesktop.connman"/>
     </policy>
 </busconfig>

commit 610964c498aa86bed1086abafabdd2496ebafbc9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 24 13:42:13 2008 +0100

    The only supported IPv4 method is DHCP at the moment

diff --git a/src/connman.h b/src/connman.h
index 9f1262a0..fbba1e69 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -25,6 +25,8 @@
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
 
+#define CONNMAN_ERROR_INTERFACE  CONNMAN_SERVICE ".Error"
+
 #define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
 
 #define CONNMAN_MANAGER_PATH       "/"
diff --git a/src/iface.c b/src/iface.c
index 89763aaf..3632a685 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -884,7 +884,7 @@ static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	str = __connman_ipv4_method2string(iface->ipv4.method);
+	str = __connman_ipv4_method2string(CONNMAN_IPV4_METHOD_DHCP);
 	append_entry(&dict, "Method", DBUS_TYPE_STRING, &str);
 
 	if (iface->ipv4.address.s_addr != INADDR_ANY) {
@@ -932,6 +932,9 @@ static DBusMessage *set_ipv4(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	return dbus_message_new_error(msg, CONNMAN_ERROR_INTERFACE
+						".NotImplemented", "");
+
 	dbus_message_iter_init(msg, &array);
 
 	dbus_message_iter_recurse(&array, &dict);

commit 15e9803aefdf8996a9b4bdb0388500adef9577ed
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 26 21:47:24 2008 +0100

    Add workaround for my D-Link access point

diff --git a/src/iface.c b/src/iface.c
index 3632a685..6a9aa847 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -360,7 +360,8 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 				const char *name, int strength, int security)
 {
 	DBusMessage *signal;
-	char *passphrase;
+	char *ssid, *passphrase;
+	int len;
 
 	DBG("iface %p security %d name %s", iface, security, name);
 
@@ -380,12 +381,21 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	if (iface->state != CONNMAN_IFACE_STATE_SCANNING)
 		return;
 
-	passphrase = __connman_iface_find_passphrase(iface, name);
+	len = strlen(name);
+	ssid = strdup(name);
+	if (ssid == NULL)
+		return;
+
+	/* The D-Link access points return a 0x05 at the end of the SSID */
+	if (ssid[len - 1] == '\05')
+		ssid[len - 1] = '\0';
+
+	passphrase = __connman_iface_find_passphrase(iface, ssid);
 	if (passphrase != NULL) {
-		DBG("network %s passphrase %s", name, passphrase);
+		DBG("network %s passphrase %s", ssid, passphrase);
 
 		g_free(iface->network.identifier);
-		iface->network.identifier = g_strdup(name);
+		iface->network.identifier = g_strdup(ssid);
 		g_free(iface->network.passphrase);
 		iface->network.passphrase = passphrase;
 
@@ -395,6 +405,8 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 			state_changed(iface);
 		}
 	}
+
+	free(ssid);
 }
 
 int connman_iface_get_ipv4(struct connman_iface *iface,

commit f665a9a97091d30616d84a055a0af3a1df5449f2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 28 21:34:34 2008 +0100

    Fix DHCP release and dhclient termination

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 8847a1de..c37e6888 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -85,27 +85,14 @@ static struct dhclient_task *find_task_by_index(int index)
 
 static void kill_task(struct dhclient_task *task)
 {
-	char pathname[PATH_MAX];
-
 	if (task->pid > 0)
 		kill(task->pid, SIGTERM);
-
-	snprintf(pathname, sizeof(pathname) - 1,
-			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
-	unlink(pathname);
-
-	snprintf(pathname, sizeof(pathname) - 1,
-			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
-	unlink(pathname);
-
-	free(task->ifname);
-
-	g_free(task);
 }
 
 static void task_died(GPid pid, gint status, gpointer data)
 {
 	struct dhclient_task *task = data;
+	char pathname[PATH_MAX];
 
 	if (WIFEXITED(status))
 		printf("[DHCP] exit status %d for %s\n",
@@ -119,7 +106,17 @@ static void task_died(GPid pid, gint status, gpointer data)
 
 	tasks = g_slist_remove(tasks, task);
 
-	kill_task(task);
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	snprintf(pathname, sizeof(pathname) - 1,
+			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
+	unlink(pathname);
+
+	free(task->ifname);
+
+	g_free(task);
 }
 
 static void task_setup(gpointer data)

commit f84146ee1dcbf0942097937909c5875748d7108b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 28 21:37:55 2008 +0100

    Also check for the plugin suffix

diff --git a/src/Makefile.am b/src/Makefile.am
index f430368f..83eb87f9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -22,7 +22,7 @@ statedir = $(localstatedir)/run/connman
 storagedir = $(localstatedir)/lib/connman
 
 if MAINTAINER_MODE
-plugindir = $(abs_top_srcdir)/plugins
+plugindir = $(abs_top_srcdir)/plugins/.libs
 else
 plugindir = $(libdir)/connman/plugins
 endif
diff --git a/src/plugin.c b/src/plugin.c
index 8e164e1e..801df8b4 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -69,7 +69,8 @@ static void load_plugins(const gchar *path)
 			GModule *module;
 			struct connman_plugin_desc *desc;
 
-			if (g_str_has_prefix(file, "libconnman") == FALSE)
+			if (g_str_has_prefix(file, "libconnman") == FALSE ||
+					g_str_has_suffix(file, ".so") == FALSE)
 				continue;
 
 			filename = g_build_filename(path, file, NULL);

commit d3b8d6bdccf7640a4bf2f4b958ac80577d5bb281
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 28 22:55:09 2008 +0100

    Remove filter on device removal

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 0ec9304d..ad97f001 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -803,6 +803,32 @@ static int add_filter(struct supplicant_task *task)
 	return 0;
 }
 
+static int remove_filter(struct supplicant_task *task)
+{
+	DBusError error;
+	gchar *filter;
+
+	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
+						SUPPLICANT_INTF, task->path);
+
+	DBG("filter %s", filter);
+
+	dbus_error_init(&error);
+
+	dbus_bus_add_match(task->conn, filter, &error);
+
+	g_free(filter);
+
+	if (dbus_error_is_set(&error) == TRUE) {
+		connman_error("Can't add match: %s", error.message);
+		dbus_error_free(&error);
+	}
+
+	dbus_connection_remove_filter(task->conn, supplicant_filter, task);
+
+	return 0;
+}
+
 int __supplicant_start(struct connman_iface *iface)
 {
 	struct ifreq ifr;
@@ -881,6 +907,8 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	tasks = g_slist_remove(tasks, task);
 
+	remove_filter(task);
+
 	remove_network(task);
 
 	dbus_connection_unref(task->conn);

commit 53d969dd73a36b57bbcb705e325d2b68a2ba1e23
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 1 22:48:16 2008 +0200

    Don't return IPv4 settings when in off or ignore policy

diff --git a/src/iface.c b/src/iface.c
index 6a9aa847..a4e154e9 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -925,6 +925,15 @@ static DBusMessage *get_ipv4(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	switch (iface->policy) {
+	case CONNMAN_IFACE_POLICY_OFF:
+	case CONNMAN_IFACE_POLICY_IGNORE:
+		return dbus_message_new_error(msg, CONNMAN_ERROR_INTERFACE
+						".NotAvailable", "");
+	default:
+		break;
+	}
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;

commit 45541d278519384fe25be74a196254d281012019
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 06:01:07 2008 +0200

    Update state machine handling for wireless networks

diff --git a/include/iface.h b/include/iface.h
index 37e60672..8b0e6c8f 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -38,10 +38,15 @@ enum connman_iface_type {
 };
 
 enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_RTNL     = (1 << 0),
-	CONNMAN_IFACE_FLAG_IPV4     = (1 << 1),
-	CONNMAN_IFACE_FLAG_IPV6     = (1 << 2),
-	CONNMAN_IFACE_FLAG_SCANNING = (1 << 3),
+	CONNMAN_IFACE_FLAG_RTNL      = (1 << 0),
+	CONNMAN_IFACE_FLAG_IPV4      = (1 << 1),
+	CONNMAN_IFACE_FLAG_IPV6      = (1 << 2),
+	CONNMAN_IFACE_FLAG_SCANNING  = (1 << 3),
+	CONNMAN_IFACE_FLAG_NOCARRIER = (1 << 4),
+
+	CONNMAN_IFACE_FLAG_STARTED   = (1 << 16),
+	CONNMAN_IFACE_FLAG_RUNNING   = (1 << 17),
+	CONNMAN_IFACE_FLAG_DHCP      = (1 << 18),
 };
 
 enum connman_iface_state {
@@ -94,7 +99,7 @@ struct connman_iface {
 	char *identifier;
 	int index;
 	enum connman_iface_type type;
-	enum connman_iface_flags flags;
+	unsigned long flags;
 	enum connman_iface_state state;
 	enum connman_iface_policy policy;
 	struct connman_network network;
@@ -146,8 +151,8 @@ static inline void connman_iface_set_data(struct connman_iface *iface,
 	iface->driver_data = data;
 }
 
-extern void connman_iface_indicate_enabled(struct connman_iface *iface);
-extern void connman_iface_indicate_disabled(struct connman_iface *iface);
+extern void connman_iface_indicate_ifup(struct connman_iface *iface);
+extern void connman_iface_indicate_ifdown(struct connman_iface *iface);
 extern void connman_iface_indicate_connected(struct connman_iface *iface);
 extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
 extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
diff --git a/src/connman.h b/src/connman.h
index fbba1e69..e8ca3e73 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -69,8 +69,11 @@ void __connman_iface_list(DBusMessageIter *iter);
 
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
-int __connman_iface_up(struct connman_iface *iface);
-int __connman_iface_down(struct connman_iface *iface);
+int __connman_iface_start(struct connman_iface *iface);
+int __connman_iface_stop(struct connman_iface *iface);
+int __connman_iface_connect(struct connman_iface *iface,
+					struct connman_network *network);
+int __connman_iface_disconnect(struct connman_iface *iface);
 
 char *__connman_iface_find_passphrase(struct connman_iface *iface,
 							const char *network);
diff --git a/src/dhcp.c b/src/dhcp.c
index ecf61f2b..3b6ba637 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -76,8 +76,13 @@ int __connman_dhcp_request(struct connman_iface *iface)
 {
 	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
 
-	if (driver && driver->request)
+	if (iface->flags & CONNMAN_IFACE_FLAG_DHCP)
+		return -1;
+
+	if (driver && driver->request) {
+		iface->flags |= CONNMAN_IFACE_FLAG_DHCP;
 		return driver->request(iface);
+	}
 
 	return -1;
 }
@@ -86,8 +91,13 @@ int __connman_dhcp_release(struct connman_iface *iface)
 {
 	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
 
-	if (driver && driver->release)
+	if (!(iface->flags & CONNMAN_IFACE_FLAG_DHCP))
+		return -1;
+
+	if (driver && driver->release) {
+		iface->flags &= ~CONNMAN_IFACE_FLAG_DHCP;
 		return driver->release(iface);
+	}
 
 	return -1;
 }
diff --git a/src/iface-inet.c b/src/iface-inet.c
index 927f5689..7fd74895 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -103,13 +103,15 @@ int __connman_iface_init_via_inet(struct connman_iface *iface)
 	else
 		iface->state = CONNMAN_IFACE_STATE_OFF;
 
-	if (ifr.ifr_flags & IFF_RUNNING)
-		iface->state = CONNMAN_IFACE_STATE_CARRIER;
+	if (ifr.ifr_flags & IFF_RUNNING) {
+		if (!(iface->flags & CONNMAN_IFACE_FLAG_NOCARRIER))
+			iface->state = CONNMAN_IFACE_STATE_CARRIER;
+	}
 
 	return 0;
 }
 
-int __connman_iface_up(struct connman_iface *iface)
+static int __connman_iface_up(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	int sk, err;
@@ -153,7 +155,7 @@ done:
 	return err;
 }
 
-int __connman_iface_down(struct connman_iface *iface)
+static int __connman_iface_down(struct connman_iface *iface)
 {
 	struct ifreq ifr;
 	int sk, err;
@@ -194,3 +196,103 @@ done:
 
 	return err;
 }
+
+int __connman_iface_start(struct connman_iface *iface)
+{
+	int err;
+
+	DBG("iface %p", iface);
+
+	if (iface->flags & CONNMAN_IFACE_FLAG_STARTED)
+		return -EALREADY;
+
+	err = __connman_iface_up(iface);
+
+	if (iface->driver->start) {
+		err = iface->driver->start(iface);
+		if (err < 0)
+			return err;
+	}
+
+	iface->flags |= CONNMAN_IFACE_FLAG_STARTED;
+
+	return 0;
+}
+
+int __connman_iface_stop(struct connman_iface *iface)
+{
+	int err;
+
+	DBG("iface %p", iface);
+
+	__connman_dhcp_release(iface);
+
+	connman_iface_clear_ipv4(iface);
+
+	if (iface->flags & CONNMAN_IFACE_FLAG_RUNNING) {
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+		iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
+	}
+
+	if (!(iface->flags & CONNMAN_IFACE_FLAG_STARTED))
+		return -EINVAL;
+
+	if (iface->driver->stop) {
+		err = iface->driver->stop(iface);
+		if (err < 0)
+			return err;
+	}
+
+	iface->flags &= ~CONNMAN_IFACE_FLAG_STARTED;
+
+	err = __connman_iface_down(iface);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+int __connman_iface_connect(struct connman_iface *iface,
+					struct connman_network *network)
+{
+	DBG("iface %p name %s passphrase %s", iface,
+				network->identifier, network->passphrase);
+
+	if (iface->flags & CONNMAN_IFACE_FLAG_RUNNING) {
+		__connman_dhcp_release(iface);
+
+		connman_iface_clear_ipv4(iface);
+
+		if (iface->driver->disconnect)
+			iface->driver->disconnect(iface);
+
+		iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
+	}
+
+	if (iface->driver->connect)
+		iface->driver->connect(iface, network);
+
+	iface->flags |= CONNMAN_IFACE_FLAG_RUNNING;
+
+	return 0;
+}
+
+int __connman_iface_disconnect(struct connman_iface *iface)
+{
+	DBG("iface %p", iface);
+
+	__connman_dhcp_release(iface);
+
+	connman_iface_clear_ipv4(iface);
+
+	if (!(iface->flags & CONNMAN_IFACE_FLAG_RUNNING))
+		return -EINVAL;
+
+	if (iface->driver->disconnect)
+		iface->driver->disconnect(iface);
+
+	iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
+
+	return 0;
+}
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 6694d992..8d2895f4 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -41,8 +41,6 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 	gsize list_len;
 	int i;
 
-	DBG("iface %p", iface);
-
 	if (iface->identifier == NULL)
 		return NULL;
 
diff --git a/src/iface.c b/src/iface.c
index a4e154e9..f5753d8b 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -157,14 +157,11 @@ static void state_changed(struct connman_iface *iface)
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
-		__connman_dhcp_release(iface);
+		__connman_iface_stop(iface);
 		break;
 
 	case CONNMAN_IFACE_STATE_ENABLED:
-		__connman_dhcp_release(iface);
-		connman_iface_clear_ipv4(iface);
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
+		__connman_iface_start(iface);
 		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
 			state = CONNMAN_IFACE_STATE_SCANNING;
 		break;
@@ -185,9 +182,7 @@ static void state_changed(struct connman_iface *iface)
 		break;
 
 	case CONNMAN_IFACE_STATE_SHUTDOWN:
-		__connman_dhcp_release(iface);
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
+		__connman_iface_stop(iface);
 		if (iface->policy != CONNMAN_IFACE_POLICY_AUTO)
 			state = CONNMAN_IFACE_STATE_OFF;
 		break;
@@ -207,28 +202,19 @@ static void state_changed(struct connman_iface *iface)
 
 static void switch_policy(struct connman_iface *iface)
 {
-	DBG("iface %p", iface);
+	DBG("iface %p policy %d", iface, iface->policy);
 
 	switch (iface->policy) {
 	case CONNMAN_IFACE_POLICY_OFF:
-		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
-		state_changed(iface);
-		connman_iface_clear_ipv4(iface);
-		if (iface->driver->stop)
-			iface->driver->stop(iface);
-		else
-			__connman_iface_down(iface);
+		__connman_iface_stop(iface);
 		break;
 
 	case CONNMAN_IFACE_POLICY_IGNORE:
 		break;
 
 	case CONNMAN_IFACE_POLICY_AUTO:
-		if (iface->driver->start)
-			iface->driver->start(iface);
-		else
-			__connman_iface_up(iface);
-		state_changed(iface);
+	case CONNMAN_IFACE_POLICY_ASK:
+		__connman_iface_start(iface);
 		break;
 
 	default:
@@ -236,13 +222,12 @@ static void switch_policy(struct connman_iface *iface)
 	}
 }
 
-void connman_iface_indicate_enabled(struct connman_iface *iface)
+void connman_iface_indicate_ifup(struct connman_iface *iface)
 {
 	DBG("iface %p state %d", iface, iface->state);
 
 	switch (iface->state) {
 	case CONNMAN_IFACE_STATE_OFF:
-	case CONNMAN_IFACE_STATE_CARRIER:
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
@@ -251,17 +236,13 @@ void connman_iface_indicate_enabled(struct connman_iface *iface)
 	}
 }
 
-void connman_iface_indicate_disabled(struct connman_iface *iface)
+void connman_iface_indicate_ifdown(struct connman_iface *iface)
 {
 	DBG("iface %p state %d", iface, iface->state);
 
-	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO) {
+	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO)
 		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-		if (iface->driver->start)
-			iface->driver->start(iface);
-		else
-			__connman_iface_up(iface);
-	} else
+	else
 		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
 
 	state_changed(iface);
@@ -305,13 +286,10 @@ void connman_iface_indicate_carrier_off(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_CARRIER:
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 	case CONNMAN_IFACE_STATE_READY:
-#if 0
-		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING) {
-			if (iface->driver->disconnect)
-				iface->driver->disconnect(iface);
+		__connman_iface_disconnect(iface);
+		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
 			iface->state = CONNMAN_IFACE_STATE_SCANNING;
-		} else
-#endif
+		else
 			iface->state = CONNMAN_IFACE_STATE_ENABLED;
 		state_changed(iface);
 		break;
@@ -378,8 +356,16 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 	dbus_connection_send(connection, signal, NULL);
 	dbus_message_unref(signal);
 
-	if (iface->state != CONNMAN_IFACE_STATE_SCANNING)
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONNECT:
+	case CONNMAN_IFACE_STATE_CONNECTED:
+	case CONNMAN_IFACE_STATE_CARRIER:
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+	case CONNMAN_IFACE_STATE_READY:
 		return;
+	default:
+		break;
+	}
 
 	len = strlen(name);
 	ssid = strdup(name);
@@ -399,11 +385,10 @@ void connman_iface_indicate_station(struct connman_iface *iface,
 		g_free(iface->network.passphrase);
 		iface->network.passphrase = passphrase;
 
-		if (iface->driver->connect) {
-			iface->driver->connect(iface, &iface->network);
-			iface->state = CONNMAN_IFACE_STATE_CONNECT;
-			state_changed(iface);
-		}
+		__connman_iface_connect(iface, &iface->network);
+
+		iface->state = CONNMAN_IFACE_STATE_CONNECT;
+		state_changed(iface);
 	}
 
 	free(ssid);
@@ -577,11 +562,19 @@ static DBusMessage *scan_iface(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	switch (iface->state) {
+	case CONNMAN_IFACE_STATE_CONNECT:
+	case CONNMAN_IFACE_STATE_CONFIGURE:
+			return reply;
+	default:
+		break;
+	}
+
 	if (driver->scan)
 		driver->scan(iface);
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
 	return reply;
 }
 
@@ -844,11 +837,7 @@ static DBusMessage *set_network(DBusConnection *conn,
 			dbus_message_unref(signal);
 		}
 
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
-
-		if (iface->driver->connect)
-			iface->driver->connect(iface, &iface->network);
+		__connman_iface_connect(iface, &iface->network);
 	}
 
 	return reply;
@@ -869,11 +858,7 @@ static DBusMessage *select_network(DBusConnection *conn,
 	g_free(iface->network.identifier);
 	iface->network.identifier = g_strdup(network);
 
-	if (iface->driver->disconnect)
-		iface->driver->disconnect(iface);
-
-	if (iface->driver->connect)
-		iface->driver->connect(iface, &iface->network);
+	__connman_iface_connect(iface, &iface->network);
 
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
@@ -1177,6 +1162,8 @@ static int probe_device(LibHalContext *ctx,
 
 	iface->driver = driver;
 
+	iface->policy = CONNMAN_IFACE_POLICY_AUTO;
+
 	__connman_iface_load(iface);
 
 	DBG("iface %p network %s secret %s", iface,
@@ -1209,6 +1196,8 @@ static int probe_device(LibHalContext *ctx,
 
 	switch_policy(iface);
 
+	state_changed(iface);
+
 	return 0;
 }
 
diff --git a/src/rtnl.c b/src/rtnl.c
index c4fbf447..b18465d4 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -105,21 +105,25 @@ static void rtnl_link(struct nlmsghdr *hdr)
 		return;
 
 	if ((data->ifi_flags & IFF_RUNNING) != (msg->ifi_flags & IFF_RUNNING)) {
-		if (msg->ifi_flags & IFF_RUNNING)
-			connman_iface_indicate_carrier_on(iface);
-		else
-			connman_iface_indicate_carrier_off(iface);
+		if (!(iface->flags & CONNMAN_IFACE_FLAG_NOCARRIER)) {
+			if (msg->ifi_flags & IFF_RUNNING)
+				connman_iface_indicate_carrier_on(iface);
+			else
+				connman_iface_indicate_carrier_off(iface);
+		}
 	}
 
 	if ((data->ifi_flags & IFF_UP) != (msg->ifi_flags & IFF_UP)) {
 		if (msg->ifi_flags & IFF_UP)
-			connman_iface_indicate_enabled(iface);
+			connman_iface_indicate_ifup(iface);
 		else
-			connman_iface_indicate_disabled(iface);
+			connman_iface_indicate_ifdown(iface);
 	}
 
 	data->ifi_flags = msg->ifi_flags;
 
+	return;
+
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {

commit e645e0bf2a8c6f72494d5ef678c7f7a61f7b52dd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 06:01:37 2008 +0200

    Give wpa_supplicant more hints on what is going on

diff --git a/plugins/80211.c b/plugins/80211.c
index d21eec64..f3093bf2 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -81,7 +81,8 @@ static int wifi_probe(struct connman_iface *iface)
 
 	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
 				CONNMAN_IFACE_FLAG_IPV4 |
-				CONNMAN_IFACE_FLAG_SCANNING;
+				CONNMAN_IFACE_FLAG_SCANNING |
+				CONNMAN_IFACE_FLAG_NOCARRIER;
 
 	connman_iface_set_data(iface, data);
 
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index ad97f001..2668ab7e 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -201,6 +201,82 @@ static int add_interface(struct supplicant_task *task)
 	return 0;
 }
 
+static int remove_interface(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	if (task->created == FALSE)
+		return -EINVAL;
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "removeInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->path,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to remove interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int set_ap_scan(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	guint32 ap_scan = 1;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+				SUPPLICANT_INTF ".Interface", "setAPScan");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_UINT32, &ap_scan,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(task->conn,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to set AP scan");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
 static int add_network(struct supplicant_task *task)
 {
 	DBusMessage *message, *reply;
@@ -209,6 +285,9 @@ static int add_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
+	if (task->network != NULL)
+		return -EALREADY;
+
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
 				SUPPLICANT_INTF ".Interface", "addNetwork");
 	if (message == NULL)
@@ -259,6 +338,9 @@ static int remove_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
+	if (task->network == NULL)
+		return -EINVAL;
+
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
 				SUPPLICANT_INTF ".Interface", "removeNetwork");
 	if (message == NULL)
@@ -285,6 +367,9 @@ static int remove_network(struct supplicant_task *task)
 
 	dbus_message_unref(reply);
 
+	g_free(task->network);
+	task->network = NULL;
+
 	return 0;
 }
 
@@ -295,6 +380,9 @@ static int select_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
+	if (task->network == NULL)
+		return -EINVAL;
+
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
 				SUPPLICANT_INTF ".Interface", "selectNetwork");
 	if (message == NULL)
@@ -331,6 +419,9 @@ static int enable_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
+	if (task->network == NULL)
+		return -EINVAL;
+
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
 					SUPPLICANT_INTF ".Network", "enable");
 	if (message == NULL)
@@ -364,6 +455,9 @@ static int disable_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
+	if (task->network == NULL)
+		return -EINVAL;
+
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
 					SUPPLICANT_INTF ".Network", "disable");
 	if (message == NULL)
@@ -430,6 +524,9 @@ static int set_network(struct supplicant_task *task, const char *network,
 
 	DBG("task %p", task);
 
+	if (task->network == NULL)
+		return -EINVAL;
+
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
 					SUPPLICANT_INTF ".Network", "set");
 	if (message == NULL)
@@ -567,8 +664,6 @@ static int parse_network_properties(struct supplicant_task *task,
 	struct supplicant_ap *ap;
 	int security = 0;
 
-	DBG("task %p", task);
-
 	ap = g_try_new0(struct supplicant_ap, 1);
 	if (ap == NULL)
 		return -ENOMEM;
@@ -603,8 +698,6 @@ static int parse_network_properties(struct supplicant_task *task,
 		dbus_message_iter_next(&dict);
 	}
 
-	DBG("SSID %s", ap->identifier);
-
 	if (ap->has_wep)
 		security |= 0x01;
 	if (ap->has_wpa)
@@ -626,8 +719,6 @@ static int get_network_properties(struct supplicant_task *task,
 	DBusMessage *message, *reply;
 	DBusError error;
 
-	DBG("task %p", task);
-
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, path,
 						SUPPLICANT_INTF ".BSSID",
 								"properties");
@@ -749,6 +840,17 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 		task->state = STATE_COMPLETED;
 	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
 		task->state = STATE_DISCONNECTED;
+
+	switch (task->state) {
+	case STATE_COMPLETED:
+		connman_iface_indicate_carrier_on(task->iface);
+		break;
+	case STATE_DISCONNECTED:
+		connman_iface_indicate_carrier_off(task->iface);
+		break;
+	default:
+		break;
+	}
 }
 
 static DBusHandlerResult supplicant_filter(DBusConnection *conn,
@@ -887,10 +989,7 @@ int __supplicant_start(struct connman_iface *iface)
 
 	add_filter(task);
 
-	add_network(task);
-
-	select_network(task);
-	disable_network(task);
+	set_ap_scan(task);
 
 	return 0;
 }
@@ -907,14 +1006,17 @@ int __supplicant_stop(struct connman_iface *iface)
 
 	tasks = g_slist_remove(tasks, task);
 
-	remove_filter(task);
+	disable_network(task);
 
 	remove_network(task);
 
+	remove_filter(task);
+
+	remove_interface(task);
+
 	dbus_connection_unref(task->conn);
 
 	g_free(task->ifname);
-	g_free(task->network);
 	g_free(task->path);
 	g_free(task);
 
@@ -960,6 +1062,11 @@ int __supplicant_connect(struct connman_iface *iface,
 
 	DBG("interface %s", task->ifname);
 
+	add_network(task);
+
+	select_network(task);
+	disable_network(task);
+
 	set_network(task, network, passphrase);
 
 	enable_network(task);
@@ -979,5 +1086,7 @@ int __supplicant_disconnect(struct connman_iface *iface)
 
 	disable_network(task);
 
+	remove_network(task);
+
 	return 0;
 }

commit 5cc1f98aff5fa7f36ab38d0536ba32ab706ffe8d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 06:14:31 2008 +0200

    On successful connect store the network identifier

diff --git a/src/connman.h b/src/connman.h
index e8ca3e73..4232616b 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -79,6 +79,7 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 							const char *network);
 int __connman_iface_load(struct connman_iface *iface);
 int __connman_iface_store(struct connman_iface *iface);
+int __connman_iface_store_current_network(struct connman_iface *iface);
 
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 8d2895f4..d73ef6a5 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -211,3 +211,50 @@ done:
 
 	return 0;
 }
+
+int __connman_iface_store_current_network(struct connman_iface *iface)
+{
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+
+	DBG("iface %p", iface);
+
+	if (iface->identifier == NULL)
+		return -EIO;
+
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
+		goto update;
+
+	if (length > 0) {
+		if (g_key_file_load_from_data(keyfile, data, length,
+				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+			goto done;
+	}
+
+	g_free(data);
+
+update:
+	g_key_file_set_string(keyfile, GROUP_CONFIG,
+				"LastNetwork", iface->network.identifier);
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents(pathname, data, length, NULL);
+
+done:
+	g_free(data);
+
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return 0;
+}
diff --git a/src/iface.c b/src/iface.c
index f5753d8b..a1e136df 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -306,6 +306,7 @@ void connman_iface_indicate_configured(struct connman_iface *iface)
 	case CONNMAN_IFACE_STATE_CONFIGURE:
 		iface->state = CONNMAN_IFACE_STATE_READY;
 		state_changed(iface);
+		__connman_iface_store_current_network(iface);
 		break;
 	default:
 		break;

commit 4b7adf27379eb4652c650a8882333c77e9d1a07b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 08:12:26 2008 +0200

    Add script for seleting networks

diff --git a/test/Makefile.am b/test/Makefile.am
index 02760295..21ceba69 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,5 +1,5 @@
 
-EXTRA_DIST = list-interfaces start-scanning simple-agent \
-				show-introspection test-supplicant
+EXTRA_DIST = list-interfaces start-scanning select-network simple-agent \
+					show-introspection test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/select-network b/test/select-network
new file mode 100755
index 00000000..0d48ad30
--- /dev/null
+++ b/test/select-network
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+interfaces = manager.ListInterfaces()
+
+for path in interfaces:
+	print "[ %s ]" % (path)
+
+	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+					'org.freedesktop.connman.Interface')
+
+	properties = interface.GetProperties()
+
+	if (properties["Type"] == "80211"):
+		print "   Selecting network"
+		interface.SelectNetwork("ConnMan Testing")
+	else:
+		print "   No networks"
+
+	print

commit ada412ae85949172658aadfc80baf02b8f4a1736
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 08:13:06 2008 +0200

    Improve selecting of networks

diff --git a/src/iface-storage.c b/src/iface-storage.c
index d73ef6a5..ec59490c 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -62,11 +62,7 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
 					"KnownNetworks", &list_len, NULL);
 	for (i = 0; i < list_len; i++) {
-		DBG("known network %s", list[i]);
-
 		if (g_str_equal(list[i], network) == TRUE) {
-			DBG("found network %s", network);
-
 			result = g_key_file_get_string(keyfile, network,
 								"PSK", NULL);
 			if (result == NULL)
diff --git a/src/iface.c b/src/iface.c
index a1e136df..27bae8f1 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -850,17 +850,25 @@ static DBusMessage *select_network(DBusConnection *conn,
 	struct connman_iface *iface = data;
 	DBusMessage *reply;
 	const char *network;
+	gchar *passphrase;
 
 	DBG("conn %p", conn);
 
 	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
 							DBUS_TYPE_INVALID);
 
+	passphrase = __connman_iface_find_passphrase(iface, network);
+	if (passphrase == NULL)
+		goto done;
+
 	g_free(iface->network.identifier);
 	iface->network.identifier = g_strdup(network);
+	g_free(iface->network.passphrase);
+	iface->network.passphrase = passphrase;
 
 	__connman_iface_connect(iface, &iface->network);
 
+done:
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;

commit 52ecd928d7c84ad694f1c977c981ab01784d228e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 08:59:37 2008 +0200

    Add skeleton for network functions

diff --git a/src/Makefile.am b/src/Makefile.am
index 83eb87f9..1637b247 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,8 +12,8 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
-				iface.c iface-storage.c iface-helper.c \
-					iface-inet.c rtnl.c dhcp.c resolver.c
+			iface.c iface-storage.c iface-helper.c iface-inet.c \
+					network.c rtnl.c dhcp.c resolver.c
 
 connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
  
diff --git a/src/network.c b/src/network.c
new file mode 100644
index 00000000..641bff0e
--- /dev/null
+++ b/src/network.c
@@ -0,0 +1,26 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"

commit ef19693f6f7ba2bc47241204e52dbdbe54a12019
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 4 09:02:30 2008 +0200

    Add callbacks for loading known networks

diff --git a/src/connman.h b/src/connman.h
index 4232616b..c989fcb4 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -80,6 +80,7 @@ char *__connman_iface_find_passphrase(struct connman_iface *iface,
 int __connman_iface_load(struct connman_iface *iface);
 int __connman_iface_store(struct connman_iface *iface);
 int __connman_iface_store_current_network(struct connman_iface *iface);
+int __connman_iface_load_networks(struct connman_iface *iface);
 
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
diff --git a/src/iface-storage.c b/src/iface-storage.c
index ec59490c..29a1eff2 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -254,3 +254,45 @@ done:
 
 	return 0;
 }
+
+int __connman_iface_load_networks(struct connman_iface *iface)
+{
+	GKeyFile *keyfile;
+	gchar *pathname;
+	gchar **list;
+	gsize list_len;
+	int i;
+
+	if (iface->identifier == NULL)
+		return -1;
+
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							iface->identifier);
+	if (pathname == NULL)
+		return -1;
+
+	keyfile = g_key_file_new();
+
+	g_key_file_set_list_separator(keyfile, ',');
+
+	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
+		goto done;
+
+	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
+		goto done;
+
+	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
+					"KnownNetworks", &list_len, NULL);
+	for (i = 0; i < list_len; i++) {
+		DBG("Known network %s", list[i]);
+	}
+
+	g_strfreev(list);
+
+done:
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
+	return 0;
+}
diff --git a/src/iface.c b/src/iface.c
index 27bae8f1..e6e88ce6 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -1203,6 +1203,8 @@ static int probe_device(LibHalContext *ctx,
 					DBUS_TYPE_OBJECT_PATH, &iface->path,
 					DBUS_TYPE_INVALID);
 
+	__connman_iface_load_networks(iface);
+
 	switch_policy(iface);
 
 	state_changed(iface);

commit 425dafdb4b29c2dc415bb6e299cd575103481b04
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 7 03:59:08 2008 +0200

    Always unregister the whole object hierarchy

diff --git a/src/iface.c b/src/iface.c
index e6e88ce6..dc24dd26 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -1253,7 +1253,7 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 			interfaces = g_slist_remove(interfaces, iface);
 			g_dbus_unregister_interface(conn, iface->path,
 						CONNMAN_IFACE_INTERFACE);
-			g_dbus_unregister_object(conn, iface->path);
+			g_dbus_unregister_object_hierarchy(conn, iface->path);
 			break;
 		}
 	}
@@ -1357,7 +1357,7 @@ static void hal_cleanup(void *data)
 		g_dbus_unregister_interface(conn, iface->path,
 						CONNMAN_IFACE_INTERFACE);
 
-		g_dbus_unregister_object(conn, iface->path);
+		g_dbus_unregister_object_hierarchy(conn, iface->path);
 	}
 
 	g_slist_free(interfaces);

commit 56b36256ff076ccc319b0d591c96fef98e3ce893
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 7 04:01:28 2008 +0200

    Implement master state and fix Network Manager compat methods

diff --git a/src/connman.h b/src/connman.h
index c989fcb4..90a70d9a 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -21,6 +21,8 @@
 
 #include <stdio.h>
 
+#include <glib.h>
+
 #include <dbus/dbus.h>
 
 #define CONNMAN_SERVICE  "org.freedesktop.connman"
@@ -66,6 +68,7 @@ void __connman_iface_cleanup(void);
 
 struct connman_iface *__connman_iface_find(int index);
 void __connman_iface_list(DBusMessageIter *iter);
+gboolean __connman_iface_is_connected(void);
 
 int __connman_iface_create_identifier(struct connman_iface *iface);
 int __connman_iface_init_via_inet(struct connman_iface *iface);
diff --git a/src/iface.c b/src/iface.c
index dc24dd26..a29c9019 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -97,6 +97,25 @@ void __connman_iface_list(DBusMessageIter *iter)
 	}
 }
 
+gboolean __connman_iface_is_connected(void)
+{
+	GSList *list;
+	gboolean connected = FALSE;
+
+	DBG("");
+
+	for (list = interfaces; list; list = list->next) {
+		struct connman_iface *iface = list->data;
+
+		if (iface->state == CONNMAN_IFACE_STATE_READY) {
+			connected = TRUE;
+			break;
+		}
+	}
+
+	return connected;
+}
+
 static void append_entry(DBusMessageIter *dict,
 				const char *key, int type, void *val)
 {
diff --git a/src/manager.c b/src/manager.c
index 11c25572..3b2430a3 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,8 +27,6 @@
 
 #include "connman.h"
 
-static const char *master_state = "unknown";
-
 static DBusMessage *list_interfaces(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -57,6 +55,7 @@ static DBusMessage *get_state(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
+	const char *state;
 
 	DBG("conn %p", conn);
 
@@ -64,7 +63,12 @@ static DBusMessage *get_state(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	dbus_message_append_args(reply, DBUS_TYPE_STRING, &master_state,
+	if (__connman_iface_is_connected() == TRUE)
+		state = "online";
+	else
+		state = "offline";
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &state,
 							DBUS_TYPE_INVALID);
 
 	return reply;
@@ -133,67 +137,7 @@ static GDBusSignalTable manager_signals[] = {
 	{ },
 };
 
-static DBusMessage *activate_device(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	DBusMessage *reply;
-	const char *path;
-
-	DBG("conn %p", conn);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
-							DBUS_TYPE_INVALID);
-
-	DBG("device %s", path);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *set_wireless(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	DBusMessage *reply;
-	dbus_bool_t enabled;
-
-	DBG("conn %p", conn);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_BOOLEAN, &enabled,
-							DBUS_TYPE_INVALID);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *get_wireless(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	DBusMessage *reply;
-	dbus_bool_t enabled = TRUE;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &enabled,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *do_sleep(DBusConnection *conn,
+static DBusMessage *nm_sleep(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
@@ -209,7 +153,7 @@ static DBusMessage *do_sleep(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *do_wake(DBusConnection *conn,
+static DBusMessage *nm_wake(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
@@ -233,11 +177,11 @@ enum {
 	NM_STATE_DISCONNECTED
 };
 
-static DBusMessage *do_state(DBusConnection *conn,
+static DBusMessage *nm_state(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	dbus_uint32_t state = NM_STATE_DISCONNECTED;
+	dbus_uint32_t state;
 
 	DBG("conn %p", conn);
 
@@ -245,6 +189,11 @@ static DBusMessage *do_state(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
+	if (__connman_iface_is_connected() == TRUE)
+		state = NM_STATE_CONNECTED;
+	else
+		state = NM_STATE_DISCONNECTED;
+
 	dbus_message_append_args(reply, DBUS_TYPE_UINT32, &state,
 							DBUS_TYPE_INVALID);
 
@@ -252,13 +201,9 @@ static DBusMessage *do_state(DBusConnection *conn,
 }
 
 static GDBusMethodTable nm_methods[] = {
-	{ "getDevices",            "",  "ao", list_interfaces },
-	{ "setActiveDevice",       "o", "",   activate_device },
-	{ "setWirelessEnabled",    "b", "",   set_wireless    },
-	{ "getWirelessEnabled",    "",  "b",  get_wireless    },
-	{ "sleep",                 "",  "",   do_sleep        },
-	{ "wake",                  "",  "",   do_wake         },
-	{ "state",                 "",  "u",  do_state        },
+	{ "sleep",                 "",  "",   nm_sleep        },
+	{ "wake",                  "",  "",   nm_wake         },
+	{ "state",                 "",  "u",  nm_state        },
 	{ },
 };
 

commit b55e7165b179c3c97a372647ef0a889e4ef81675
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 7 04:07:46 2008 +0200

    Add documentation for GetState method and StateChanged signal

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 9de15c30..0c4de41b 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -6,11 +6,13 @@ Interface name	org.freedesktop.connman.Manager
 Object path	/
 
 Methods		array{object} ListInterfaces()
+		string GetState()
 		void RegisterAgent(object path)
 		void UnregisterAgent(object path)
 
 Signals		InterfaceAdded(object)
 		InterfaceRemoved(object)
+		StateChanged(string state)
 
 
 Method: ListInferfaces
@@ -20,6 +22,12 @@ object paths. Every attached network interface (eth0, wlan0 etc.) of the
 system is presented by an object path with additional interfaces on it. The
 main interface is org.freedesktop.connman.Interface.
 
+Method: GetState
+================
+This method gets the overall master state of the Internet connection. Possible
+return values are "offline" and "online". If at least one interface is
+connected it will return "online".
+
 Method: RegisterAgent
 =====================
 This method allows the user interace to register an agent. There can be only
@@ -44,3 +52,8 @@ Signal: InterfaceRemoved
 This signal is emitted every time an interface has been removed. This can
 happen at any time in case of hotplug devices. When the system shuts down,
 this signal is also emitted.
+
+Signal: StateChanged
+====================
+This signal is emitted every time the master state changes. Possible values
+are "offline" and "online" and reflect the state of the Internet connection.

commit 7a2572623c022fd36f6e34f33d47fa90b479a5c0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 7 04:26:38 2008 +0200

    Add simple script to show the master state

diff --git a/test/Makefile.am b/test/Makefile.am
index 21ceba69..d5638122 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,5 +1,5 @@
 
 EXTRA_DIST = list-interfaces start-scanning select-network simple-agent \
-					show-introspection test-supplicant
+				get-state show-introspection test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/get-state b/test/get-state
new file mode 100755
index 00000000..e5b130c8
--- /dev/null
+++ b/test/get-state
@@ -0,0 +1,12 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
+					'org.freedesktop.connman.Manager')
+
+state = manager.GetState()
+
+print "System is %s" % (state)

commit ebf293f4d8b72271775fac455c1e1a0de825193e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 7 07:20:07 2008 +0200

    Add script to check the Network Manager compat layer

diff --git a/test/Makefile.am b/test/Makefile.am
index d5638122..332c3bdb 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,5 +1,5 @@
 
 EXTRA_DIST = list-interfaces start-scanning select-network simple-agent \
-				get-state show-introspection test-supplicant
+		get-state show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/test-compat b/test/test-compat
new file mode 100755
index 00000000..b1149b9d
--- /dev/null
+++ b/test/test-compat
@@ -0,0 +1,13 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.freedesktop.NetworkManager',
+				'/org/freedesktop/NetworkManager'),
+					'org.freedesktop.NetworkManager')
+
+state = manager.state()
+
+print "System is %d" % (state)

commit 85752761aeb96f074968e84c7979f58c2a1010e0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 7 07:23:10 2008 +0200

    Decode Network Manager states into strings

diff --git a/test/test-compat b/test/test-compat
index b1149b9d..cd1ca7a7 100755
--- a/test/test-compat
+++ b/test/test-compat
@@ -8,6 +8,8 @@ manager = dbus.Interface(bus.get_object('org.freedesktop.NetworkManager',
 				'/org/freedesktop/NetworkManager'),
 					'org.freedesktop.NetworkManager')
 
+states = [ "unknown", "asleep", "connecting", "connected", "disconnected" ]
+
 state = manager.state()
 
-print "System is %d" % (state)
+print "System is %s" % (states[state])

commit 48dad19c8128b6da9666182520674f9b612a3e85
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 8 07:36:44 2008 +0200

    Update scripts to handle new network methods

diff --git a/test/list-interfaces b/test/list-interfaces
index 2cd0424d..5a1d28fa 100755
--- a/test/list-interfaces
+++ b/test/list-interfaces
@@ -23,4 +23,14 @@ for path in interfaces:
 	for key in ipv4.keys():
 		print "    IPv4.%s = %s" % (key, ipv4[key])
 
+	networks = interface.ListNetworks()
+	for i in networks:
+		print "    Network.Path = %s" % (i)
+
+		network = dbus.Interface(bus.get_object('org.freedesktop.connman', i),
+						'org.freedesktop.connman.Network')
+
+		print "    Network.Identifier = %s" % (network.GetIdentifier())
+		print "    Network.Passphrase = %s" % (network.GetPassphrase())
+
 	print
diff --git a/test/select-network b/test/select-network
index 0d48ad30..e009d75b 100755
--- a/test/select-network
+++ b/test/select-network
@@ -18,8 +18,14 @@ for path in interfaces:
 	properties = interface.GetProperties()
 
 	if (properties["Type"] == "80211"):
-		print "   Selecting network"
-		interface.SelectNetwork("ConnMan Testing")
+		networks = interface.ListNetworks()
+		for i in networks:
+			network = dbus.Interface(bus.get_object('org.freedesktop.connman', i),
+						'org.freedesktop.connman.Network')
+
+			if (network.GetIdentifier() == "ConnMan Testing"):
+				print "   Selecting network %s" % (i)
+				interface.SelectNetwork(i)
 	else:
 		print "   No networks"
 

commit 250e3e349b0d48af495a8944e0f828c9b6350ced
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 8 07:38:33 2008 +0200

    Add support for creating and removing networks

diff --git a/include/iface.h b/include/iface.h
index 8b0e6c8f..2123fea3 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -88,6 +88,8 @@ struct connman_ipv4 {
 };
 
 struct connman_network {
+	struct connman_iface *iface;
+	char *path;
 	char *identifier;
 	char *passphrase;
 };
diff --git a/src/connman.h b/src/connman.h
index 90a70d9a..9f9862aa 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -37,6 +37,8 @@
 #define CONNMAN_IFACE_BASEPATH  "/interface"
 #define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
 
+#define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
+
 #define NM_SERVICE    "org.freedesktop.NetworkManager"
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
@@ -85,6 +87,17 @@ int __connman_iface_store(struct connman_iface *iface);
 int __connman_iface_store_current_network(struct connman_iface *iface);
 int __connman_iface_load_networks(struct connman_iface *iface);
 
+void __connman_iface_network_list(struct connman_iface *iface,
+						DBusMessageIter *iter);
+struct connman_network *__connman_iface_find_network(struct connman_iface *iface,
+								const char *path);
+int __connman_iface_remove_network(struct connman_iface *iface, const char *path);
+const char *__connman_iface_add_network(struct connman_iface *iface,
+				const char *identifier, const char *passphrase);
+
+int __connman_network_init(DBusConnection *conn);
+void __connman_network_cleanup(void);
+
 const char *__connman_iface_type2string(enum connman_iface_type type);
 const char *__connman_iface_state2string(enum connman_iface_state state);
 const char *__connman_iface_policy2string(enum connman_iface_policy policy);
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 29a1eff2..2c8ff559 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -284,7 +284,13 @@ int __connman_iface_load_networks(struct connman_iface *iface)
 	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
 					"KnownNetworks", &list_len, NULL);
 	for (i = 0; i < list_len; i++) {
+		gchar *psk;
+
 		DBG("Known network %s", list[i]);
+
+		psk = g_key_file_get_string(keyfile, list[i], "PSK", NULL);
+
+		__connman_iface_add_network(iface, list[i], psk);
 	}
 
 	g_strfreev(list);
diff --git a/src/iface.c b/src/iface.c
index a29c9019..6be7b876 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -863,27 +863,126 @@ static DBusMessage *set_network(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *list_networks(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	DBusMessageIter array, iter;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_iface_network_list(iface, &iter);
+
+	dbus_message_iter_close_container(&array, &iter);
+
+	return reply;
+}
+
+static DBusMessage *create_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *path, *identifier = NULL, *passphrase = NULL;
+
+	DBG("conn %p", conn);
+
+	dbus_message_iter_init(msg, &array);
+
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *val;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		dbus_message_iter_get_basic(&value, &val);
+
+		if (g_strcasecmp(key, "Identifier") == 0)
+			identifier = val;
+
+		if (g_strcasecmp(key, "Passphrase") == 0)
+			passphrase = val;
+
+		dbus_message_iter_next(&dict);
+	}
+
+	DBG("identifier %s passphrase %s", identifier, passphrase);
+
+	path = __connman_iface_add_network(iface, identifier, passphrase);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *remove_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_iface *iface = data;
+	DBusMessage *reply;
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	__connman_iface_remove_network(iface, path);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
 static DBusMessage *select_network(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_iface *iface = data;
+	struct connman_network *network;
 	DBusMessage *reply;
-	const char *network;
-	gchar *passphrase;
+	const char *path;
 
 	DBG("conn %p", conn);
 
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &network,
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
 
-	passphrase = __connman_iface_find_passphrase(iface, network);
-	if (passphrase == NULL)
+	network = __connman_iface_find_network(iface, path);
+	if (network == NULL)
 		goto done;
 
 	g_free(iface->network.identifier);
-	iface->network.identifier = g_strdup(network);
+	iface->network.identifier = g_strdup(network->identifier);
 	g_free(iface->network.passphrase);
-	iface->network.passphrase = passphrase;
+	iface->network.passphrase = g_strdup(network->passphrase);
 
 	__connman_iface_connect(iface, &iface->network);
 
@@ -1054,7 +1153,10 @@ static GDBusMethodTable iface_methods[] = {
 	{ "SetPolicy",     "s",     "",      set_policy     },
 	{ "GetNetwork",    "",      "a{sv}", get_network    },
 	{ "SetNetwork",    "a{sv}", "",      set_network    },
-	{ "SelectNetwork", "s",     "",      select_network },
+	{ "ListNetworks",  "",      "ao",    list_networks  },
+	{ "CreateNetwork", "a{av}", "o",     create_network },
+	{ "RemoveNetwork", "o",     "",      remove_network },
+	{ "SelectNetwork", "o",     "",      select_network },
 	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
 	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
 	{ },
diff --git a/src/main.c b/src/main.c
index e9174401..e7d54c23 100644
--- a/src/main.c
+++ b/src/main.c
@@ -130,8 +130,10 @@ int main(int argc, char *argv[])
 	}
 
 	if (compat) {
-		if (g_dbus_request_name(conn, NM_SERVICE, NULL) == FALSE)
+		if (g_dbus_request_name(conn, NM_SERVICE, NULL) == FALSE) {
+			fprintf(stderr, "Can't register compat service\n");
 			compat = 0;
+		}
 	}
 
 	__connman_log_init(detach, debug);
@@ -144,6 +146,8 @@ int main(int argc, char *argv[])
 
 	__connman_rtnl_init();
 
+	__connman_network_init(conn);
+
 	__connman_iface_init(conn, interface);
 
 	memset(&sa, 0, sizeof(sa));
@@ -155,6 +159,8 @@ int main(int argc, char *argv[])
 
 	__connman_iface_cleanup();
 
+	__connman_network_cleanup();
+
 	__connman_rtnl_cleanup();
 
 	__connman_plugin_cleanup();
diff --git a/src/network.c b/src/network.c
index 641bff0e..1a080b98 100644
--- a/src/network.c
+++ b/src/network.c
@@ -23,4 +23,162 @@
 #include <config.h>
 #endif
 
+#include <gdbus.h>
+
 #include "connman.h"
+
+static DBusConnection *connection = NULL;
+static unsigned int index = 0;
+
+static GSList *networks = NULL;
+
+void __connman_iface_network_list(struct connman_iface *iface,
+						DBusMessageIter *iter)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = networks; list; list = list->next) {
+		struct connman_network *network = list->data;
+
+		if (network->iface != iface)
+			continue;
+
+		dbus_message_iter_append_basic(iter,
+				DBUS_TYPE_OBJECT_PATH, &network->path);
+	}
+}
+
+struct connman_network *__connman_iface_find_network(struct connman_iface *iface,
+								const char *path)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = networks; list; list = list->next) {
+		struct connman_network *network = list->data;
+
+		if (network->iface == iface &&
+				g_str_equal(network->path, path) == TRUE)
+			return network;
+	}
+
+	return NULL;
+}
+
+int __connman_iface_remove_network(struct connman_iface *iface, const char *path)
+{
+	g_dbus_unregister_object(connection, path);
+
+	return 0;
+}
+
+static DBusMessage *get_identifier(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_network *network = data;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &network->identifier,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static DBusMessage *get_passphrase(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_network *network = data;
+	DBusMessage *reply;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &network->passphrase,
+							DBUS_TYPE_INVALID);
+
+	return reply;
+}
+
+static GDBusMethodTable network_methods[] = {
+	{ "GetIdentifier", "", "s", get_identifier },
+	{ "GetPassphrase", "", "s", get_passphrase },
+	{ },
+};
+
+static void network_free(void *data)
+{
+	struct connman_network *network = data;
+
+	DBG("");
+
+	networks = g_slist_remove(networks, network);
+
+	g_free(network->path);
+	g_free(network->identifier);
+	g_free(network->passphrase);
+	g_free(network);
+}
+
+const char *__connman_iface_add_network(struct connman_iface *iface,
+				const char *identifier, const char *passphrase)
+{
+	struct connman_network *network;
+	gchar *path;
+
+	DBG("iface %p", iface);
+
+	network = g_try_new0(struct connman_network, 1);
+	if (network == NULL)
+		return NULL;
+
+	path = g_strdup_printf("%s/net_%d", iface->path, index++);
+	if (path == NULL) {
+		g_free(network);
+		return NULL;
+	}
+
+	network->iface = iface;
+
+	network->path = path;
+	network->identifier = g_strdup(identifier);
+	network->passphrase = g_strdup(passphrase ? passphrase : "");
+
+	networks = g_slist_append(networks, network);
+
+	g_dbus_register_object(connection, path, network, network_free);
+
+	g_dbus_register_interface(connection, path, CONNMAN_NETWORK_INTERFACE,
+						network_methods, NULL, NULL);
+
+	return path;
+}
+
+int __connman_network_init(DBusConnection *conn)
+{
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
+
+	return 0;
+}
+
+void __connman_network_cleanup(void)
+{
+	DBG("conn %p", connection);
+
+	dbus_connection_unref(connection);
+}

commit 249a12194decb4b7a06d717bcd5284d1467e759b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 14 00:18:08 2008 +0200

    Update copyright information

diff --git a/include/dhcp.h b/include/dhcp.h
index f817e0a1..7863af1f 100644
--- a/include/dhcp.h
+++ b/include/dhcp.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/iface.h b/include/iface.h
index 2123fea3..3530f23b 100644
--- a/include/iface.h
+++ b/include/iface.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/log.h b/include/log.h
index bf0dab50..ec0d6481 100644
--- a/include/log.h
+++ b/include/log.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/plugin.h b/include/plugin.h
index b7f1eb3a..387a48c0 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/resolver.h b/include/resolver.h
index 3d9f9902..e3c368e2 100644
--- a/include/resolver.h
+++ b/include/resolver.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/rtnl.h b/include/rtnl.h
index 4b3e6925..f167a16d 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/80203.c b/plugins/80203.c
index 4d085c0a..753e4741 100644
--- a/plugins/80203.c
+++ b/plugins/80203.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/80211.c b/plugins/80211.c
index f3093bf2..b4bd65ab 100644
--- a/plugins/80211.c
+++ b/plugins/80211.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index c37e6888..612d02af 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 732db4f0..ba6eef18 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 2668ab7e..cba93cd9 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 59e4dfe9..1ef96d7e 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
index f4a8431f..70687fd2 100644
--- a/scripts/dhclient-script.c
+++ b/scripts/dhclient-script.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/agent.c b/src/agent.c
index b7db03c6..586dd14f 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/connman.h b/src/connman.h
index 9f9862aa..66dd487b 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/dhcp.c b/src/dhcp.c
index 3b6ba637..1b7bd876 100644
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/iface-helper.c b/src/iface-helper.c
index 7e177198..23c26051 100644
--- a/src/iface-helper.c
+++ b/src/iface-helper.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/iface-inet.c b/src/iface-inet.c
index 7fd74895..82a1e8cb 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/iface-storage.c b/src/iface-storage.c
index 2c8ff559..7aa64619 100644
--- a/src/iface-storage.c
+++ b/src/iface-storage.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/iface.c b/src/iface.c
index 6be7b876..51b8e017 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/log.c b/src/log.c
index 83466d22..0b94fd60 100644
--- a/src/log.c
+++ b/src/log.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/main.c b/src/main.c
index e7d54c23..402ccf43 100644
--- a/src/main.c
+++ b/src/main.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/manager.c b/src/manager.c
index 3b2430a3..218d34e7 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/network.c b/src/network.c
index 1a080b98..9da8fead 100644
--- a/src/network.c
+++ b/src/network.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/plugin.c b/src/plugin.c
index 801df8b4..404ef9ec 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/resolver.c b/src/resolver.c
index f2443d76..7c7d2f60 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/rtnl.c b/src/rtnl.c
index b18465d4..f100c213 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as

commit 882010ac603c63cbbe36fff9d6e6fd38d0001009
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 14 00:23:00 2008 +0200

    Add skeleton for Bluetooth plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 3ecb1aef..b34d79d7 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,12 +2,15 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
+			libconnman-bluetooth.la \
 			libconnman-dhclient.la libconnman-resolvconf.la
 
 libconnman_80203_la_SOURCES = 80203.c
 
 libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
+libconnman_bluetooth_la_SOURCES = bluetooth.c
+
 libconnman_dhclient_la_SOURCES = dhclient.c
 libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
 libconnman_dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
new file mode 100644
index 00000000..7c75529f
--- /dev/null
+++ b/plugins/bluetooth.c
@@ -0,0 +1,65 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/iface.h>
+#include <connman/log.h>
+
+static int bluetooth_probe(struct connman_iface *iface)
+{
+	DBG("iface %p", iface);
+
+	iface->type = CONNMAN_IFACE_TYPE_BLUETOOTH;
+
+	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
+				CONNMAN_IFACE_FLAG_IPV4;
+
+	return 0;
+}
+
+static void bluetooth_remove(struct connman_iface *iface)
+{
+	DBG("iface %p", iface);
+}
+
+static struct connman_iface_driver bluetooth_driver = {
+	.name		= "bluetooth",
+	.capability	= "bluetooth_hci",
+	.probe		= bluetooth_probe,
+	.remove		= bluetooth_remove,
+};
+
+static int bluetooth_init(void)
+{
+	return connman_iface_register(&bluetooth_driver);
+}
+
+static void bluetooth_exit(void)
+{
+	connman_iface_unregister(&bluetooth_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("bluetooth", "Bluetooth interface plugin", VERSION,
+						bluetooth_init, bluetooth_exit)

commit 4b4e384e215fa0479325629a9c26b9325a1dae91
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 14 01:08:08 2008 +0200

    Setup GLib and D-Bus threading support

diff --git a/configure.in b/configure.in
index 68301053..402120de 100644
--- a/configure.in
+++ b/configure.in
@@ -44,6 +44,11 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 AC_PATH_PROG(DHCLIENT, [dhclient])
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
 
+PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
+				AC_MSG_ERROR(gthread is required))
+AC_SUBST(GTHREAD_CFLAGS)
+AC_SUBST(GTHREAD_LIBS)
+
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
 				AC_MSG_ERROR(gmodule is required))
 AC_SUBST(GMODULE_CFLAGS)
diff --git a/src/Makefile.am b/src/Makefile.am
index 1637b247..1f585c7b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -15,7 +15,7 @@ connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
 			iface.c iface-storage.c iface-helper.c iface-inet.c \
 					network.c rtnl.c dhcp.c resolver.c
 
-connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@
+connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
  
 statedir = $(localstatedir)/run/connman
 
@@ -27,7 +27,7 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
+AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
 			-DSTATEDIR=\""$(statedir)"\" \
 			-DSTORAGEDIR=\""$(storagedir)\"" \
 			-DPLUGINDIR=\""$(plugindir)"\"
diff --git a/src/main.c b/src/main.c
index 402ccf43..dc8439df 100644
--- a/src/main.c
+++ b/src/main.c
@@ -115,8 +115,16 @@ int main(int argc, char *argv[])
 	mkdir(STORAGEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
 
+	if (g_thread_supported() == FALSE)
+		g_thread_init(NULL);
+
 	main_loop = g_main_loop_new(NULL, FALSE);
 
+	if (dbus_threads_init_default() == FALSE) {
+		fprintf(stderr, "Can't init usage of threads\n");
+		exit(1);
+	}
+
 	dbus_error_init(&err);
 
 	conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, CONNMAN_SERVICE, &err);

commit f9f84ccfa0cd338e2de22878f277352436570b83
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 14 01:50:19 2008 +0200

    Use GLib option parsing

diff --git a/src/connman.h b/src/connman.h
index 66dd487b..866f9c9e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -44,7 +44,7 @@
 #define NM_INTERFACE  NM_SERVICE
 #define NM_DEVICE     NM_SERVICE ".Devices"
 
-int __connman_manager_init(DBusConnection *conn, int compat);
+int __connman_manager_init(DBusConnection *conn, gboolean compat);
 void __connman_manager_cleanup(void);
 
 int __connman_agent_init(DBusConnection *conn);
@@ -55,7 +55,7 @@ int __connman_agent_unregister(const char *sender, const char *path);
 
 #include <connman/log.h>
 
-int __connman_log_init(int detach, int debug);
+int __connman_log_init(gboolean detach, gboolean debug);
 void __connman_log_cleanup(void);
 
 #include <connman/plugin.h>
diff --git a/src/iface.c b/src/iface.c
index 51b8e017..b2fd6d10 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -1268,7 +1268,6 @@ static int probe_device(LibHalContext *ctx,
 		ifname = libhal_device_get_property_string(ctx, udi,
 						"net.interface", NULL);
 		if (ifname != NULL && ifname_filter != NULL &&
-						*ifname_filter != '\0' &&
 				g_str_equal(ifname, ifname_filter) == FALSE) {
 			device_free(iface);
 			return -1;
diff --git a/src/log.c b/src/log.c
index 0b94fd60..93026d53 100644
--- a/src/log.c
+++ b/src/log.c
@@ -28,7 +28,7 @@
 
 #include "connman.h"
 
-static volatile int debug_enabled = 0;
+static volatile gboolean debug_enabled = FALSE;
 
 void connman_info(const char *format, ...)
 {
@@ -56,7 +56,7 @@ void connman_debug(const char *format, ...)
 {
 	va_list ap;
 
-	if (!debug_enabled)
+	if (debug_enabled == FALSE)
 		return;
 
 	va_start(ap, format);
@@ -66,11 +66,11 @@ void connman_debug(const char *format, ...)
 	va_end(ap);
 }
 
-int __connman_log_init(int detach, int debug)
+int __connman_log_init(gboolean detach, gboolean debug)
 {
 	int option = LOG_NDELAY | LOG_PID;
 
-	if (!detach)
+	if (detach == FALSE)
 		option |= LOG_PERROR;
 
 	openlog("connmand", option, LOG_DAEMON);
diff --git a/src/main.c b/src/main.c
index dc8439df..9bfb3bc1 100644
--- a/src/main.c
+++ b/src/main.c
@@ -43,66 +43,50 @@ static void sig_term(int sig)
 	g_main_loop_quit(main_loop);
 }
 
-static void usage(void)
-{
-	printf("Connection Manager version %s\n\n", VERSION);
-
-	printf("Usage:\n"
-		"\tconnmand [-i <interface>] [options]\n"
-		"\n");
-
-	printf("Options:\n"
-		"\t-c, --compat         Enable Network Manager compatibility\n"
-		"\t-n, --nodaemon       Don't fork daemon to background\n"
-		"\t-h, --help           Display help\n"
-		"\n");
-}
-
-static struct option options[] = {
-	{ "interface", 1, 0, 'i' },
-	{ "nodaemon",  0, 0, 'n' },
-	{ "compat",    0, 0, 'c' },
-	{ "debug",     0, 0, 'd' },
-	{ "help",      0, 0, 'h' },
-	{ }
+static gchar *option_interface = NULL;
+static gboolean option_detach = TRUE;
+static gboolean option_compat = FALSE;
+static gboolean option_debug = FALSE;
+
+static GOptionEntry options[] = {
+	{ "interface", 'i', 0, G_OPTION_ARG_STRING, &option_interface,
+				"Specify network interface", "IFACE" },
+	{ "nodaemon", 'n', G_OPTION_FLAG_REVERSE,
+				G_OPTION_ARG_NONE, &option_detach,
+				"Don't fork daemon to background" },
+	{ "compat", 'c', 0, G_OPTION_ARG_NONE, &option_compat,
+				"Enable Network Manager compatibility" },
+	{ "debug", 'd', 0, G_OPTION_ARG_NONE, &option_debug,
+				"Enable debug information output" },
+	{ NULL },
 };
 
 int main(int argc, char *argv[])
 {
+	GOptionContext *context;
+	GError *error = NULL;
 	DBusConnection *conn;
 	DBusError err;
 	struct sigaction sa;
-	char interface[IFNAMSIZ];
-	int opt, detach = 1, compat = 0, debug = 0;
-
-	memset(interface, 0, IFNAMSIZ);
-
-	while ((opt = getopt_long(argc, argv, "+i:ncdh", options, NULL)) != EOF) {
-		switch (opt) {
-		case 'i':
-			snprintf(interface, IFNAMSIZ, "%s", optarg);
-			break;
-		case 'n':
-			detach = 0;
-			break;
-		case 'c':
-			compat = 1;
-			break;
-		case 'd':
-			debug = 1;
-			break;
-		case 'h':
-		default:
-			usage();
-			exit(0);
-		}
+
+	if (g_thread_supported() == FALSE)
+		g_thread_init(NULL);
+
+	context = g_option_context_new(NULL);
+	g_option_context_add_main_entries(context, options, NULL);
+
+	if (g_option_context_parse(context, &argc, &argv, &error) == FALSE) {
+		if (error != NULL) {
+			g_printerr("%s\n", error->message);
+			g_error_free(error);
+		} else
+			g_printerr("An unknown error occurred\n");
+		exit(1);
 	}
 
-	argc -= optind;
-	argv += optind;
-	optind = 0;
+	g_option_context_free(context);
 
-	if (detach) {
+	if (option_detach == TRUE) {
 		if (daemon(0, 0)) {
 			perror("Can't start daemon");
 			exit(1);
@@ -115,9 +99,6 @@ int main(int argc, char *argv[])
 	mkdir(STORAGEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
 			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
 
-	if (g_thread_supported() == FALSE)
-		g_thread_init(NULL);
-
 	main_loop = g_main_loop_new(NULL, FALSE);
 
 	if (dbus_threads_init_default() == FALSE) {
@@ -137,18 +118,18 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 
-	if (compat) {
+	if (option_compat == TRUE) {
 		if (g_dbus_request_name(conn, NM_SERVICE, NULL) == FALSE) {
 			fprintf(stderr, "Can't register compat service\n");
-			compat = 0;
+			option_compat = FALSE;
 		}
 	}
 
-	__connman_log_init(detach, debug);
+	__connman_log_init(option_detach, option_debug);
 
 	__connman_agent_init(conn);
 
-	__connman_manager_init(conn, compat);
+	__connman_manager_init(conn, option_compat);
 
 	__connman_plugin_init();
 
@@ -156,7 +137,9 @@ int main(int argc, char *argv[])
 
 	__connman_network_init(conn);
 
-	__connman_iface_init(conn, interface);
+	__connman_iface_init(conn, option_interface);
+
+	g_free(option_interface);
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
diff --git a/src/manager.c b/src/manager.c
index 218d34e7..9d14cd74 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -208,9 +208,9 @@ static GDBusMethodTable nm_methods[] = {
 };
 
 static DBusConnection *connection = NULL;
-static int nm_compat = 0;
+static gboolean nm_compat = FALSE;
 
-int __connman_manager_init(DBusConnection *conn, int compat)
+int __connman_manager_init(DBusConnection *conn, gboolean compat)
 {
 	DBG("conn %p", conn);
 
@@ -225,13 +225,13 @@ int __connman_manager_init(DBusConnection *conn, int compat)
 						manager_methods,
 						manager_signals, NULL);
 
-	if (compat) {
+	if (compat == TRUE) {
 		g_dbus_register_object(connection, NM_PATH, NULL, NULL);
 
 		g_dbus_register_interface(connection, NM_PATH, NM_INTERFACE,
 						nm_methods, NULL, NULL);
 
-		nm_compat = 1;
+		nm_compat = TRUE;
 	}
 
 	return 0;
@@ -241,7 +241,7 @@ void __connman_manager_cleanup(void)
 {
 	DBG("conn %p", connection);
 
-	if (nm_compat) {
+	if (nm_compat == TRUE) {
 		g_dbus_unregister_interface(connection, NM_PATH, NM_INTERFACE);
 
 		g_dbus_unregister_object(connection, NM_PATH);

commit b9e1ef0522fd3aabc8f8ba9f4403d9301e5e9207
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 20 08:34:02 2008 +0200

    Check for GLib development files

diff --git a/configure.in b/configure.in
index 402120de..042f85b8 100644
--- a/configure.in
+++ b/configure.in
@@ -44,6 +44,11 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 AC_PATH_PROG(DHCLIENT, [dhclient])
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
 
+PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
+                                AC_MSG_ERROR(glib is required))
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GLIB_LIBS)
+
 PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
 				AC_MSG_ERROR(gthread is required))
 AC_SUBST(GTHREAD_CFLAGS)

commit e7fcf53b8b53c0e69996d8881713694b8c48f016
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 20 09:48:56 2008 +0200

    Include filename in debug output

diff --git a/include/log.h b/include/log.h
index ec0d6481..8a0b5a52 100644
--- a/include/log.h
+++ b/include/log.h
@@ -26,12 +26,12 @@
 extern "C" {
 #endif
 
-#define DBG(fmt, arg...) connman_debug("%s: " fmt, __FUNCTION__ , ## arg)
-
 extern void connman_info(const char *format, ...);
 extern void connman_error(const char *format, ...);
 extern void connman_debug(const char *format, ...);
 
+#define DBG(fmt, arg...) connman_debug("%s:%s() " fmt, __FILE__, __FUNCTION__ , ## arg)
+
 #ifdef __cplusplus
 }
 #endif

commit 29e32b19209edcead937e85b0da62746c19ee625
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 09:55:39 2008 +0200

    Don't use libconnman- prefix for plugins

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index b34d79d7..90477393 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,22 +1,20 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = libconnman-80203.la libconnman-80211.la \
-			libconnman-bluetooth.la \
-			libconnman-dhclient.la libconnman-resolvconf.la
+plugin_LTLIBRARIES = 80203.la 80211.la bluetooth.la \
+				dhclient.la resolvconf.la
 
-libconnman_80203_la_SOURCES = 80203.c
+80203_la_SOURCES = 80203.c
 
-libconnman_80211_la_SOURCES = 80211.c supplicant.h supplicant.c
+80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
-libconnman_bluetooth_la_SOURCES = bluetooth.c
+bluetooth_la_SOURCES = bluetooth.c
 
-libconnman_dhclient_la_SOURCES = dhclient.c
-libconnman_dhclient_la_LIBADD = @GDBUS_LIBS@
-libconnman_dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
+dhclient_la_SOURCES = dhclient.c
+dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
-libconnman_resolvconf_la_SOURCES = resolvconf.c
+resolvconf_la_SOURCES = resolvconf.c
 
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
diff --git a/src/plugin.c b/src/plugin.c
index 404ef9ec..7f8b16c4 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -69,8 +69,7 @@ static void load_plugins(const gchar *path)
 			GModule *module;
 			struct connman_plugin_desc *desc;
 
-			if (g_str_has_prefix(file, "libconnman") == FALSE ||
-					g_str_has_suffix(file, ".so") == FALSE)
+			if (g_str_has_suffix(file, ".so") == FALSE)
 				continue;
 
 			filename = g_build_filename(path, file, NULL);

commit f224db20c6ec26122f74a1cb469cd3e0ed1064c5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 09:56:08 2008 +0200

    Fix breakage caused by libgdbus API change

diff --git a/src/agent.c b/src/agent.c
index 586dd14f..2d0f3656 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -47,13 +47,11 @@ static void agent_free(void)
 	agent_path = NULL;
 }
 
-static gboolean agent_disconnect(void *data)
+static void agent_disconnect(void *data)
 {
 	DBG("data %p", data);
 
 	agent_free();
-
-	return TRUE;
 }
 
 int __connman_agent_register(const char *sender, const char *path)
diff --git a/src/iface.c b/src/iface.c
index b2fd6d10..ea52673d 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -1301,8 +1301,6 @@ static int probe_device(LibHalContext *ctx,
 
 	conn = libhal_ctx_get_dbus_connection(ctx);
 
-	g_dbus_register_object(conn, iface->path, iface, device_free);
-
 	interfaces = g_slist_append(interfaces, iface);
 
 	if (iface->flags & CONNMAN_IFACE_FLAG_IPV4) {
@@ -1313,7 +1311,8 @@ static int probe_device(LibHalContext *ctx,
 
 	g_dbus_register_interface(conn, iface->path,
 					CONNMAN_IFACE_INTERFACE,
-					iface_methods, iface_signals, NULL);
+					iface_methods, iface_signals, NULL,
+							iface, device_free);
 
 	DBG("iface %p identifier %s", iface, iface->identifier);
 
@@ -1373,7 +1372,6 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 			interfaces = g_slist_remove(interfaces, iface);
 			g_dbus_unregister_interface(conn, iface->path,
 						CONNMAN_IFACE_INTERFACE);
-			g_dbus_unregister_object_hierarchy(conn, iface->path);
 			break;
 		}
 	}
@@ -1476,8 +1474,6 @@ static void hal_cleanup(void *data)
 
 		g_dbus_unregister_interface(conn, iface->path,
 						CONNMAN_IFACE_INTERFACE);
-
-		g_dbus_unregister_object_hierarchy(conn, iface->path);
 	}
 
 	g_slist_free(interfaces);
diff --git a/src/manager.c b/src/manager.c
index 9d14cd74..7de3668e 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -201,9 +201,9 @@ static DBusMessage *nm_state(DBusConnection *conn,
 }
 
 static GDBusMethodTable nm_methods[] = {
-	{ "sleep",                 "",  "",   nm_sleep        },
-	{ "wake",                  "",  "",   nm_wake         },
-	{ "state",                 "",  "u",  nm_state        },
+	{ "sleep", "",  "",   nm_sleep        },
+	{ "wake",  "",  "",   nm_wake         },
+	{ "state", "",  "u",  nm_state        },
 	{ },
 };
 
@@ -218,18 +218,14 @@ int __connman_manager_init(DBusConnection *conn, gboolean compat)
 	if (connection == NULL)
 		return -1;
 
-	g_dbus_register_object(connection, CONNMAN_MANAGER_PATH, NULL, NULL);
-
 	g_dbus_register_interface(connection, CONNMAN_MANAGER_PATH,
-						CONNMAN_MANAGER_INTERFACE,
-						manager_methods,
-						manager_signals, NULL);
+					CONNMAN_MANAGER_INTERFACE,
+					manager_methods,
+					manager_signals, NULL, NULL, NULL);
 
 	if (compat == TRUE) {
-		g_dbus_register_object(connection, NM_PATH, NULL, NULL);
-
 		g_dbus_register_interface(connection, NM_PATH, NM_INTERFACE,
-						nm_methods, NULL, NULL);
+					nm_methods, NULL, NULL, NULL, NULL);
 
 		nm_compat = TRUE;
 	}
@@ -243,14 +239,10 @@ void __connman_manager_cleanup(void)
 
 	if (nm_compat == TRUE) {
 		g_dbus_unregister_interface(connection, NM_PATH, NM_INTERFACE);
-
-		g_dbus_unregister_object(connection, NM_PATH);
 	}
 
 	g_dbus_unregister_interface(connection, CONNMAN_MANAGER_PATH,
 						CONNMAN_MANAGER_INTERFACE);
 
-	g_dbus_unregister_object(connection, CONNMAN_MANAGER_PATH);
-
 	dbus_connection_unref(connection);
 }
diff --git a/src/network.c b/src/network.c
index 9da8fead..1264d2d7 100644
--- a/src/network.c
+++ b/src/network.c
@@ -70,7 +70,8 @@ struct connman_network *__connman_iface_find_network(struct connman_iface *iface
 
 int __connman_iface_remove_network(struct connman_iface *iface, const char *path)
 {
-	g_dbus_unregister_object(connection, path);
+	g_dbus_unregister_interface(connection, path,
+					CONNMAN_NETWORK_INTERFACE);
 
 	return 0;
 }
@@ -157,10 +158,9 @@ const char *__connman_iface_add_network(struct connman_iface *iface,
 
 	networks = g_slist_append(networks, network);
 
-	g_dbus_register_object(connection, path, network, network_free);
-
 	g_dbus_register_interface(connection, path, CONNMAN_NETWORK_INTERFACE,
-						network_methods, NULL, NULL);
+						network_methods, NULL, NULL,
+							network, network_free);
 
 	return path;
 }

commit 317cefac52b5bde2070893ecc908654099a7a2ad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:01:10 2008 +0200

    Export the D-Bus service and interface constants

diff --git a/include/Makefile.am b/include/Makefile.am
index 4c10f173..15af3746 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,9 @@
 
 includedir = @includedir@/connman
 
-noinst_HEADERS = log.h plugin.h iface.h rtnl.h dhcp.h resolver.h
+include_HEADERS = log.h plugin.h dbus.h
+
+noinst_HEADERS = iface.h rtnl.h dhcp.h resolver.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/dbus.h b/include/dbus.h
new file mode 100644
index 00000000..21efdf52
--- /dev/null
+++ b/include/dbus.h
@@ -0,0 +1,49 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_DBUS_H
+#define __CONNMAN_DBUS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <dbus/dbus.h>
+
+#define CONNMAN_SERVICE  "org.freedesktop.connman"
+
+#define CONNMAN_ERROR_INTERFACE  CONNMAN_SERVICE ".Error"
+
+#define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
+
+#define CONNMAN_MANAGER_PATH       "/"
+#define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
+
+#define CONNMAN_IFACE_BASEPATH  "/interface"
+#define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
+
+#define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_DBUS_H */
diff --git a/src/connman.h b/src/connman.h
index 866f9c9e..e04ddf53 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -19,25 +19,9 @@
  *
  */
 
-#include <stdio.h>
-
 #include <glib.h>
 
-#include <dbus/dbus.h>
-
-#define CONNMAN_SERVICE  "org.freedesktop.connman"
-
-#define CONNMAN_ERROR_INTERFACE  CONNMAN_SERVICE ".Error"
-
-#define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
-
-#define CONNMAN_MANAGER_PATH       "/"
-#define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
-
-#define CONNMAN_IFACE_BASEPATH  "/interface"
-#define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
-
-#define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
+#include <connman/dbus.h>
 
 #define NM_SERVICE    "org.freedesktop.NetworkManager"
 #define NM_PATH       "/org/freedesktop/NetworkManager"
diff --git a/src/iface-inet.c b/src/iface-inet.c
index 82a1e8cb..cd21c137 100644
--- a/src/iface-inet.c
+++ b/src/iface-inet.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
 #include <string.h>

commit 5f5532f926e205921f7c4a5f2bffeeb1d062f1c3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:17:56 2008 +0200

    Use the exported D-Bus service name instead of hardcoded string

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 612d02af..bdf877af 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -40,6 +40,7 @@
 
 #include <connman/plugin.h>
 #include <connman/dhcp.h>
+#include <connman/dbus.h>
 
 #define DHCLIENT_INTF "org.isc.dhclient"
 #define DHCLIENT_PATH "/org/isc/dhclient"
@@ -314,8 +315,7 @@ static int plugin_init(void)
 	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 
 	busname = dbus_bus_get_unique_name(connection);
-
-	busname = "org.freedesktop.connman";
+	busname = CONNMAN_SERVICE;
 
 	dbus_connection_add_filter(connection, dhclient_filter, NULL, NULL);
 

commit ddebf05b54091172088efbf57069f14163ea33c8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:19:02 2008 +0200

    Use constants for the dhclient interface and path values

diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
index 70687fd2..68b755a3 100644
--- a/scripts/dhclient-script.c
+++ b/scripts/dhclient-script.c
@@ -29,6 +29,9 @@
 
 #include <dbus/dbus.h>
 
+#define DHCLIENT_INTF "org.isc.dhclient"
+#define DHCLIENT_PATH "/org/isc/dhclient"
+
 extern char **environ;
 
 static void append(DBusMessageIter *dict, const char *pattern)
@@ -80,8 +83,8 @@ int main(int argc, char *argv[])
 		return 0;
 	}
 
-	msg = dbus_message_new_method_call(busname, "/org/isc/dhclient",
-						"org.isc.dhclient", "notify");
+	msg = dbus_message_new_method_call(busname, DHCLIENT_PATH,
+						DHCLIENT_INTF, "notify");
 	if (msg == NULL) {
 		dbus_connection_unref(conn);
 		fprintf(stderr, "Failed to allocate method call\n");

commit abd3d59620a11ba5c9aec630bf28cf04ea6c3cf6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:27:13 2008 +0200

    Use org.moblin instead of org.freedesktop

diff --git a/include/dbus.h b/include/dbus.h
index 21efdf52..a237e382 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -28,7 +28,7 @@ extern "C" {
 
 #include <dbus/dbus.h>
 
-#define CONNMAN_SERVICE  "org.freedesktop.connman"
+#define CONNMAN_SERVICE  "org.moblin.connman"
 
 #define CONNMAN_ERROR_INTERFACE  CONNMAN_SERVICE ".Error"
 
diff --git a/src/connman.conf b/src/connman.conf
index 4e3567e6..f9da1512 100644
--- a/src/connman.conf
+++ b/src/connman.conf
@@ -2,12 +2,12 @@
  "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
 <busconfig>
     <policy user="root">
-        <allow own="org.freedesktop.connman"/>
-        <allow send_destination="org.freedesktop.connman"/>
+        <allow own="org.moblin.connman"/>
+        <allow send_destination="org.moblin.connman"/>
         <allow send_interface="org.isc.dhclient"/>
     </policy>
     <policy at_console="true">
-        <allow send_destination="org.freedesktop.connman"/>
-        <allow send_interface="org.freedesktop.connman"/>
+        <allow send_destination="org.moblin.connman"/>
+        <allow send_interface="org.moblin.connman"/>
     </policy>
 </busconfig>
diff --git a/src/connman.service.in b/src/connman.service.in
index 8c2368a7..e514c776 100644
--- a/src/connman.service.in
+++ b/src/connman.service.in
@@ -1,4 +1,4 @@
 [D-BUS Service]
-Name=org.freedesktop.connman
+Name=org.moblin.connman
 Exec=@prefix@/sbin/connmand
 User=root
diff --git a/test/get-state b/test/get-state
index e5b130c8..f82b44c5 100755
--- a/test/get-state
+++ b/test/get-state
@@ -4,8 +4,8 @@ import dbus
 
 bus = dbus.SystemBus()
 
-manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
-					'org.freedesktop.connman.Manager')
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
 
 state = manager.GetState()
 
diff --git a/test/list-interfaces b/test/list-interfaces
index 5a1d28fa..3a54a269 100755
--- a/test/list-interfaces
+++ b/test/list-interfaces
@@ -4,16 +4,16 @@ import dbus
 
 bus = dbus.SystemBus()
 
-manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
-					'org.freedesktop.connman.Manager')
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
 
 interfaces = manager.ListInterfaces()
 
 for path in interfaces:
 	print "[ %s ]" % (path)
 
-	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
-					'org.freedesktop.connman.Interface')
+	interface = dbus.Interface(bus.get_object('org.moblin.connman', path),
+					'org.moblin.connman.Interface')
 
 	properties = interface.GetProperties()
 	for key in properties.keys():
@@ -27,8 +27,8 @@ for path in interfaces:
 	for i in networks:
 		print "    Network.Path = %s" % (i)
 
-		network = dbus.Interface(bus.get_object('org.freedesktop.connman', i),
-						'org.freedesktop.connman.Network')
+		network = dbus.Interface(bus.get_object('org.moblin.connman', i),
+						'org.moblin.connman.Network')
 
 		print "    Network.Identifier = %s" % (network.GetIdentifier())
 		print "    Network.Passphrase = %s" % (network.GetPassphrase())
diff --git a/test/select-network b/test/select-network
index e009d75b..7de8d65c 100755
--- a/test/select-network
+++ b/test/select-network
@@ -4,24 +4,24 @@ import dbus
 
 bus = dbus.SystemBus()
 
-manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
-					'org.freedesktop.connman.Manager')
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
 
 interfaces = manager.ListInterfaces()
 
 for path in interfaces:
 	print "[ %s ]" % (path)
 
-	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
-					'org.freedesktop.connman.Interface')
+	interface = dbus.Interface(bus.get_object('org.moblin.connman', path),
+					'org.moblin.connman.Interface')
 
 	properties = interface.GetProperties()
 
 	if (properties["Type"] == "80211"):
 		networks = interface.ListNetworks()
 		for i in networks:
-			network = dbus.Interface(bus.get_object('org.freedesktop.connman', i),
-						'org.freedesktop.connman.Network')
+			network = dbus.Interface(bus.get_object('org.moblin.connman', i),
+						'org.moblin.connman.Network')
 
 			if (network.GetIdentifier() == "ConnMan Testing"):
 				print "   Selecting network %s" % (i)
diff --git a/test/show-introspection b/test/show-introspection
index 9acdd112..c1cb0ef9 100755
--- a/test/show-introspection
+++ b/test/show-introspection
@@ -4,18 +4,18 @@ import dbus
 
 bus = dbus.SystemBus()
 
-object = dbus.Interface(bus.get_object('org.freedesktop.connman', '/'),
+object = dbus.Interface(bus.get_object('org.moblin.connman', '/'),
 				'org.freedesktop.DBus.Introspectable')
 
 print object.Introspect()
 
-manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
-					'org.freedesktop.connman.Manager')
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
 
 interfaces = manager.ListInterfaces()
 
 for path in interfaces:
-	object = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
+	object = dbus.Interface(bus.get_object('org.moblin.connman', path),
 					'org.freedesktop.DBus.Introspectable')
 
 	print object.Introspect()
diff --git a/test/simple-agent b/test/simple-agent
index 47a61f62..cb3a6751 100755
--- a/test/simple-agent
+++ b/test/simple-agent
@@ -7,7 +7,7 @@ import dbus.service
 import dbus.mainloop.glib
 
 class Agent(dbus.service.Object):
-	@dbus.service.method("org.freedesktop.connman.Agent",
+	@dbus.service.method("org.moblin.connman.Agent",
 					in_signature='', out_signature='')
 	def Release(self):
 		print("Release")
@@ -17,8 +17,8 @@ if __name__ == '__main__':
 	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
 
 	bus = dbus.SystemBus()
-	manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
-					'org.freedesktop.connman.Manager')
+	manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
 
 	path = "/test/agent"
 	object = Agent(bus, path)
diff --git a/test/start-scanning b/test/start-scanning
index 712b3e93..b5933231 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -4,16 +4,16 @@ import dbus
 
 bus = dbus.SystemBus()
 
-manager = dbus.Interface(bus.get_object('org.freedesktop.connman', "/"),
-					'org.freedesktop.connman.Manager')
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
 
 interfaces = manager.ListInterfaces()
 
 for path in interfaces:
 	print "[ %s ]" % (path)
 
-	interface = dbus.Interface(bus.get_object('org.freedesktop.connman', path),
-					'org.freedesktop.connman.Interface')
+	interface = dbus.Interface(bus.get_object('org.moblin.connman', path),
+					'org.moblin.connman.Interface')
 
 	properties = interface.GetProperties()
 

commit ffb18df525c7435ec77ecb5ceac14cb357ca57d7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:27:57 2008 +0200

    Add new element infrastructure

diff --git a/include/Makefile.am b/include/Makefile.am
index 15af3746..e2dacdcc 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h dbus.h
+include_HEADERS = log.h plugin.h driver.h element.h dbus.h
 
 noinst_HEADERS = iface.h rtnl.h dhcp.h resolver.h
 
diff --git a/include/driver.h b/include/driver.h
new file mode 100644
index 00000000..3d0ad920
--- /dev/null
+++ b/include/driver.h
@@ -0,0 +1,54 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_DRIVER_H
+#define __CONNMAN_DRIVER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/element.h>
+
+#define CONNMAN_DRIVER_PRIORITY_LOW      -100
+#define CONNMAN_DRIVER_PRIORITY_DEFAULT     0
+#define CONNMAN_DRIVER_PRIORITY_HIGH      100
+
+struct connman_driver {
+	const char *name;
+	enum connman_element_type type;
+	enum connman_element_type subtype;
+	int priority;
+	int (*probe) (struct connman_element *element);
+	void (*remove) (struct connman_element *element);
+	int (*update) (struct connman_element *element);
+	int (*connect) (struct connman_element *element);
+	int (*disconnect) (struct connman_element *element);
+};
+
+extern int connman_driver_register(struct connman_driver *driver);
+extern void connman_driver_unregister(struct connman_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_DRIVER_H */
diff --git a/include/element.h b/include/element.h
new file mode 100644
index 00000000..dfcbd0f0
--- /dev/null
+++ b/include/element.h
@@ -0,0 +1,123 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_ELEMENT_H
+#define __CONNMAN_ELEMENT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <errno.h>
+#include <glib.h>
+
+enum connman_element_state {
+	CONNMAN_ELEMENT_STATE_UNKNOWN   = 0,
+	CONNMAN_ELEMENT_STATE_CONNECT   = 1,
+	CONNMAN_ELEMENT_STATE_CONNECTED = 2,
+	CONNMAN_ELEMENT_STATE_CLOSED    = 3,
+};
+
+enum connman_element_type {
+	CONNMAN_ELEMENT_TYPE_UNKNOWN    = 0,
+	CONNMAN_ELEMENT_TYPE_ROOT       = 1,
+	CONNMAN_ELEMENT_TYPE_DEVICE     = 2,
+	CONNMAN_ELEMENT_TYPE_NETWORK    = 3,
+	CONNMAN_ELEMENT_TYPE_IPV4       = 4,
+	CONNMAN_ELEMENT_TYPE_IPV6       = 5,
+	CONNMAN_ELEMENT_TYPE_DHCP       = 6,
+	CONNMAN_ELEMENT_TYPE_BOOTP      = 7,
+	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 8,
+
+	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
+};
+
+enum connman_element_subtype {
+	CONNMAN_ELEMENT_SUBTYPE_UNKNOWN   = 0,
+	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 1,
+	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 2,
+	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 3,
+	CONNMAN_ELEMENT_SUBTYPE_MODEM     = 4,
+	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 5,
+};
+
+struct connman_driver;
+
+struct connman_element {
+	gint refcount;
+	gchar *name;
+	gchar *path;
+	enum connman_element_type type;
+	enum connman_element_subtype subtype;
+	enum connman_element_state state;
+
+	struct connman_element *parent;
+
+	struct connman_driver *driver;
+	void *driver_data;
+
+	struct {
+		gchar *driver;
+		gchar *vendor;
+		gchar *product;
+	} info;
+
+	struct {
+		int index;
+		short flags;
+		gchar *name;
+	} netdev;
+
+	struct {
+		gchar *address;
+		gchar *netmask;
+		gchar *gateway;
+		gchar *network;
+		gchar *broadcast;
+		gchar *nameserver;
+	} ipv4;
+};
+
+extern struct connman_element *connman_element_create(void);
+extern struct connman_element *connman_element_ref(struct connman_element *element);
+extern void connman_element_unref(struct connman_element *element);
+
+extern int connman_element_register(struct connman_element *element,
+					struct connman_element *parent);
+extern void connman_element_unregister(struct connman_element *element);
+extern void connman_element_update(struct connman_element *element);
+
+static inline void *connman_element_get_data(struct connman_element *element)
+{
+	return element->driver_data;
+}
+
+static inline void connman_element_set_data(struct connman_element *element,
+								void *data)
+{
+	element->driver_data = data;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_ELEMENT_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 1f585c7b..1ab7d7a7 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,7 +11,8 @@ DISTCLEANFILES = $(service_DATA)
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h log.c manager.c agent.c plugin.c \
+connmand_SOURCES = main.c connman.h log.c plugin.c element.c \
+						manager.c agent.c \
 			iface.c iface-storage.c iface-helper.c iface-inet.c \
 					network.c rtnl.c dhcp.c resolver.c
 
diff --git a/src/connman.h b/src/connman.h
index e04ddf53..e4f51df4 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -47,6 +47,14 @@ void __connman_log_cleanup(void);
 int __connman_plugin_init(void);
 void __connman_plugin_cleanup(void);
 
+#include <connman/driver.h>
+#include <connman/element.h>
+
+int __connman_element_init(void);
+void __connman_element_cleanup(void);
+
+void __connman_element_list(DBusMessageIter *iter);
+
 #include <connman/iface.h>
 
 int __connman_iface_init(DBusConnection *conn, const char *interface);
diff --git a/src/element.c b/src/element.c
new file mode 100644
index 00000000..71332d0e
--- /dev/null
+++ b/src/element.c
@@ -0,0 +1,417 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "connman.h"
+
+static GStaticMutex driver_mutex = G_STATIC_MUTEX_INIT;
+static GSList *driver_list = NULL;
+static GThreadPool *driver_thread;
+
+static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
+static GNode *element_root = NULL;
+static GThreadPool *element_thread;
+
+static gboolean append_path(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+	DBusMessageIter *iter = data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter,
+				DBUS_TYPE_OBJECT_PATH, &element->path);
+
+	return FALSE;
+}
+
+void __connman_element_list(DBusMessageIter *iter)
+{
+	DBG("");
+
+	g_static_mutex_lock(&element_mutex);
+	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+							append_path, iter);
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_driver *driver1 = a;
+	const struct connman_driver *driver2 = b;
+
+	return driver2->priority - driver1->priority;
+}
+
+int connman_driver_register(struct connman_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	if (driver->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return -1;
+
+	if (!driver->probe)
+		return -EINVAL;
+
+	g_static_mutex_lock(&driver_mutex);
+	driver_list = g_slist_insert_sorted(driver_list, driver,
+							compare_priority);
+	g_static_mutex_unlock(&driver_mutex);
+
+	g_thread_pool_push(driver_thread, driver, NULL);
+
+	return 0;
+}
+
+static gboolean remove_driver(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+	struct connman_driver *driver = data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->driver == driver) {
+		if (driver->remove)
+			driver->remove(element);
+		element->driver = NULL;
+	}
+
+	return FALSE;
+}
+
+void connman_driver_unregister(struct connman_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	g_static_mutex_lock(&element_mutex);
+	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
+							remove_driver, driver);
+	g_static_mutex_unlock(&element_mutex);
+
+	g_static_mutex_lock(&driver_mutex);
+	driver_list = g_slist_remove(driver_list, driver);
+	g_static_mutex_unlock(&driver_mutex);
+}
+
+struct connman_element *connman_element_create(void)
+{
+	struct connman_element *element;
+
+	element = g_new0(struct connman_element, 1);
+
+	DBG("element %p", element);
+
+	element->refcount = 1;
+
+	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
+	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
+
+	element->netdev.index = -1;
+
+	return element;
+}
+
+struct connman_element *connman_element_ref(struct connman_element *element)
+{
+	DBG("element %p name %s refcount %d", element, element->name,
+				g_atomic_int_get(&element->refcount) + 1);
+
+	g_atomic_int_inc(&element->refcount);
+
+	return element;
+}
+
+void connman_element_unref(struct connman_element *element)
+{
+	DBG("element %p name %s refcount %d", element, element->name,
+				g_atomic_int_get(&element->refcount) - 1);
+
+	if (g_atomic_int_dec_and_test(&element->refcount) == TRUE) {
+		g_free(element->ipv4.address);
+		g_free(element->ipv4.netmask);
+		g_free(element->ipv4.gateway);
+		g_free(element->ipv4.network);
+		g_free(element->ipv4.broadcast);
+		g_free(element->ipv4.nameserver);
+		g_free(element->netdev.name);
+		g_free(element->info.driver);
+		g_free(element->info.vendor);
+		g_free(element->info.product);
+		g_free(element->path);
+		g_free(element->name);
+		g_free(element);
+	}
+}
+
+int connman_element_register(struct connman_element *element,
+					struct connman_element *parent)
+{
+	GNode *node;
+	const gchar *basepath;
+
+	DBG("element %p name %s parent %p", element, element->name, parent);
+
+	if (connman_element_ref(element) == NULL)
+		return -1;
+
+	g_static_mutex_lock(&element_mutex);
+
+	if (parent) {
+		node = g_node_find(element_root, G_PRE_ORDER,
+						G_TRAVERSE_ALL, parent);
+		basepath = parent->path;
+
+		if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
+			element->subtype = parent->subtype;
+	} else {
+		node = element_root;
+		basepath = "";
+	}
+
+	if (element->name == NULL) {
+		switch (element->type) {
+		case CONNMAN_ELEMENT_TYPE_IPV4:
+			element->name = g_strdup("ipv4");
+			break;
+		case CONNMAN_ELEMENT_TYPE_IPV6:
+			element->name = g_strdup("ipv6");
+			break;
+		case CONNMAN_ELEMENT_TYPE_DHCP:
+			element->name = g_strdup("dhcp");
+			break;
+		case CONNMAN_ELEMENT_TYPE_BOOTP:
+			element->name = g_strdup("bootp");
+			break;
+		case CONNMAN_ELEMENT_TYPE_ZEROCONF:
+			element->name = g_strdup("zeroconf");
+			break;
+		default:
+			break;
+		}
+	}
+
+	element->path = g_strdup_printf("%s/%s", basepath, element->name);
+	element->parent = parent;
+
+	DBG("element %p path %s", element, element->path);
+
+	g_node_append_data(node, element);
+
+	g_static_mutex_unlock(&element_mutex);
+
+	g_thread_pool_push(element_thread, element, NULL);
+
+	return 0;
+}
+
+void connman_element_unregister(struct connman_element *element)
+{
+	GNode *node;
+
+	DBG("element %p name %s", element, element->name);
+
+	g_static_mutex_lock(&element_mutex);
+
+	if (element->driver) {
+		if (element->driver->remove)
+			element->driver->remove(element);
+		element->driver = NULL;
+	}
+
+	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
+	if (node != NULL) {
+		g_node_unlink(node);
+		g_node_destroy(node);
+	}
+
+	g_static_mutex_unlock(&element_mutex);
+
+	connman_element_unref(element);
+}
+
+void connman_element_update(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	g_static_mutex_lock(&element_mutex);
+
+	if (element->driver && element->driver->update)
+		element->driver->update(element);
+
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static inline void set_driver(struct connman_element *element,
+						struct connman_driver *driver)
+{
+	g_static_mutex_lock(&element_mutex);
+	element->driver = driver;
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static gboolean match_driver(struct connman_element *element,
+					struct connman_driver *driver)
+{
+	if (element->type != driver->type &&
+			driver->type != CONNMAN_ELEMENT_TYPE_UNKNOWN)
+		return FALSE;
+
+	if (element->subtype == driver->subtype ||
+			driver->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean probe_driver(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+	struct connman_driver *driver = data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (!element->driver && match_driver(element, driver) == TRUE) {
+		element->driver = driver;
+
+		if (driver->probe(element) < 0)
+			element->driver = NULL;
+	}
+
+	return FALSE;
+}
+
+static void driver_probe(gpointer data, gpointer user_data)
+{
+	struct connman_driver *driver = data;
+
+	DBG("driver %p name %s", driver, driver->name);
+
+	g_static_mutex_lock(&element_mutex);
+	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+							probe_driver, driver);
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static void element_probe(gpointer data, gpointer user_data)
+{
+	struct connman_element *element = data;
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (connman_element_ref(element) == NULL)
+		return;
+
+	g_static_mutex_lock(&driver_mutex);
+
+	for (list = driver_list; list; list = list->next) {
+		struct connman_driver *driver = list->data;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		set_driver(element, driver);
+
+		if (match_driver(element, driver) == TRUE &&
+						driver->probe(element) == 0)
+			break;
+
+		set_driver(element, NULL);
+	}
+
+	g_static_mutex_unlock(&driver_mutex);
+
+	connman_element_unref(element);
+}
+
+int __connman_element_init(void)
+{
+	struct connman_element *element;
+
+	DBG("");
+
+	g_static_mutex_lock(&element_mutex);
+
+	element = connman_element_create();
+
+	element->name = g_strdup("root");
+	element->path = g_strdup("/");
+	element->type = CONNMAN_ELEMENT_TYPE_ROOT;
+
+	element_root = g_node_new(element);
+
+	g_static_mutex_unlock(&element_mutex);
+
+	element_thread = g_thread_pool_new(element_probe, NULL, 1, FALSE, NULL);
+
+	driver_thread = g_thread_pool_new(driver_probe, NULL, 1, FALSE, NULL);
+
+	return 0;
+}
+
+static gboolean free_node(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->driver) {
+		if (element->driver->remove)
+			element->driver->remove(element);
+		element->driver = NULL;
+	}
+
+	connman_element_unref(element);
+
+	node->data = NULL;
+
+	return FALSE;
+}
+
+void __connman_element_cleanup(void)
+{
+	DBG("");
+
+	g_thread_pool_free(driver_thread, TRUE, TRUE);
+
+	g_thread_pool_free(element_thread, TRUE, TRUE);
+
+	g_static_mutex_lock(&element_mutex);
+
+	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
+							free_node, NULL);
+
+	g_node_destroy(element_root);
+	element_root = NULL;
+
+	g_static_mutex_unlock(&element_mutex);
+}
diff --git a/src/main.c b/src/main.c
index 9bfb3bc1..da9ba455 100644
--- a/src/main.c
+++ b/src/main.c
@@ -127,6 +127,8 @@ int main(int argc, char *argv[])
 
 	__connman_log_init(option_detach, option_debug);
 
+	__connman_element_init();
+
 	__connman_agent_init(conn);
 
 	__connman_manager_init(conn, option_compat);
@@ -160,6 +162,8 @@ int main(int argc, char *argv[])
 
 	__connman_agent_cleanup();
 
+	__connman_element_cleanup();
+
 	__connman_log_cleanup();
 
 	g_dbus_cleanup_connection(conn);

commit 987077b340cf7b3941d8162f7a41125df1f8890b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:32:59 2008 +0200

    Add HAL based hardware detection plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 90477393..8e5e8585 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,8 +1,12 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = 80203.la 80211.la bluetooth.la \
-				dhclient.la resolvconf.la
+plugin_LTLIBRARIES = hal.la 80203.la 80211.la bluetooth.la \
+					dhclient.la resolvconf.la
+
+hal_la_SOURCES = hal.c
+hal_la_LIBADD = @HAL_LIBS@
+hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
 
 80203_la_SOURCES = 80203.c
 
diff --git a/plugins/hal.c b/plugins/hal.c
new file mode 100644
index 00000000..bb5ad94d
--- /dev/null
+++ b/plugins/hal.c
@@ -0,0 +1,281 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <dbus/dbus.h>
+#include <hal/libhal.h>
+
+#include <connman/plugin.h>
+#include <connman/element.h>
+#include <connman/log.h>
+
+static struct {
+	const char *name;
+	enum connman_element_subtype subtype;
+} capabilities[] = {
+	{ "net.80203", CONNMAN_ELEMENT_SUBTYPE_ETHERNET },
+	{ "net.80211", CONNMAN_ELEMENT_SUBTYPE_WIFI     },
+	{ }
+};
+
+static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
+static GSList *element_list = NULL;
+
+static void device_info(LibHalContext *ctx, const char *udi,
+					struct connman_element *element)
+{
+	char *parent, *subsys, *value;
+
+	parent = libhal_device_get_property_string(ctx, udi,
+						"info.parent", NULL);
+
+	subsys = libhal_device_get_property_string(ctx, udi,
+						"linux.subsystem", NULL);
+
+	value = libhal_device_get_property_string(ctx, udi,
+						"info.linux.driver", NULL);
+	if (value == NULL) {
+		value = libhal_device_get_property_string(ctx, parent,
+						"info.linux.driver", NULL);
+		if (value != NULL)
+			element->info.driver = g_strdup(value);
+	}
+
+	if (g_str_equal(subsys, "net") == TRUE) {
+		value = libhal_device_get_property_string(ctx, parent,
+							"info.vendor", NULL);
+		if (value != NULL)
+			element->info.vendor = g_strdup(value);
+
+		value = libhal_device_get_property_string(ctx, parent,
+							"info.product", NULL);
+		if (value != NULL)
+			element->info.product = g_strdup(value);
+	}
+}
+
+static void device_netdev(LibHalContext *ctx, const char *udi,
+					struct connman_element *element)
+{
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_ETHERNET ||
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI) {
+		element->netdev.index = libhal_device_get_property_int(ctx,
+						udi, "net.linux.ifindex", NULL);
+
+		element->netdev.name = libhal_device_get_property_string(ctx,
+						udi, "net.interface", NULL);
+	}
+}
+
+static void create_element(LibHalContext *ctx, const char *udi,
+					enum connman_element_subtype subtype)
+{
+	struct connman_element *element;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	element = connman_element_create();
+
+	element->name = g_path_get_basename(udi);
+	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	element->subtype = subtype;
+
+	device_info(ctx, udi, element);
+	device_netdev(ctx, udi, element);
+
+	g_static_mutex_lock(&element_mutex);
+
+	connman_element_register(element, NULL);
+
+	element_list = g_slist_append(element_list, element);
+
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static void device_added(LibHalContext *ctx, const char *udi)
+{
+	int i;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	for (i = 0; capabilities[i].name; i++) {
+		if (libhal_device_query_capability(ctx, udi,
+					capabilities[i].name, NULL) == TRUE)
+			create_element(ctx, udi, capabilities[i].subtype);
+	}
+}
+
+static void device_removed(LibHalContext *ctx, const char *udi)
+{
+	GSList *list;
+	gchar *name;
+
+	DBG("ctx %p udi %s", ctx, udi);
+
+	name = g_path_get_basename(udi);
+
+	g_static_mutex_lock(&element_mutex);
+
+	for (list = element_list; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		if (g_str_equal(element->name, name) == TRUE) {
+			element_list = g_slist_remove(element_list, element);
+
+			connman_element_unregister(element);
+			connman_element_unref(element);
+			break;
+		}
+	}
+
+	g_static_mutex_unlock(&element_mutex);
+
+	g_free(name);
+}
+
+static void probe_capability(LibHalContext *ctx, const char *capability,
+					enum connman_element_subtype subtype)
+{
+	char **list;
+	int num;
+
+	DBG("ctx %p capability %s", ctx, capability);
+
+	list = libhal_find_device_by_capability(ctx, capability, &num, NULL);
+	if (list) {
+		char **tmp = list;
+
+		while (*tmp) {
+			create_element(ctx, *tmp, subtype);
+			tmp++;
+		}
+
+		libhal_free_string_array(list);
+	}
+}
+
+static void find_devices(LibHalContext *ctx)
+{
+	int i;
+
+	DBG("ctx %p", ctx);
+
+	for (i = 0; capabilities[i].name; i++)
+		probe_capability(ctx, capabilities[i].name,
+						capabilities[i].subtype);
+}
+
+static LibHalContext *hal_ctx = NULL;
+
+static void libhal_init(void *data)
+{
+	DBusConnection *conn = data;
+
+	DBG("conn %p", conn);
+
+	if (hal_ctx != NULL)
+		return;
+
+	hal_ctx = libhal_ctx_new();
+	if (hal_ctx == NULL)
+		return;
+
+	if (libhal_ctx_set_dbus_connection(hal_ctx, conn) == FALSE) {
+		libhal_ctx_free(hal_ctx);
+		return;
+	}
+
+	if (libhal_ctx_init(hal_ctx, NULL) == FALSE) {
+		libhal_ctx_free(hal_ctx);
+		return ;
+	}
+
+	libhal_ctx_set_device_added(hal_ctx, device_added);
+	libhal_ctx_set_device_removed(hal_ctx, device_removed);
+
+	//libhal_ctx_set_device_new_capability(hal_ctx, new_capability);
+	//libhal_ctx_set_device_lost_capability(hal_ctx, lost_capability);
+
+	find_devices(hal_ctx);
+}
+
+static void libhal_cleanup(void *data)
+{
+	DBusConnection *conn = data;
+	GSList *list;
+
+	DBG("conn %p", conn);
+
+	g_static_mutex_lock(&element_mutex);
+
+	for (list = element_list; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		connman_element_unregister(element);
+		connman_element_unref(element);
+	}
+
+	g_slist_free(element_list);
+	element_list = NULL;
+
+	g_static_mutex_unlock(&element_mutex);
+
+	if (hal_ctx == NULL)
+		return;
+
+	libhal_ctx_shutdown(hal_ctx, NULL);
+
+	libhal_ctx_free(hal_ctx);
+
+	hal_ctx = NULL;
+}
+
+static int hal_init(void)
+{
+	DBusConnection *conn;
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (conn == NULL)
+		return -EIO;
+
+	libhal_init(conn);
+
+	return 0;
+}
+
+static void hal_exit(void)
+{
+	DBusConnection *conn;
+
+	conn = libhal_ctx_get_dbus_connection(hal_ctx);
+	if (conn == NULL)
+		return;
+
+	libhal_cleanup(conn);
+
+	dbus_connection_unref(conn);
+}
+
+CONNMAN_PLUGIN_DEFINE("HAL", "Hardware detection plugin", VERSION,
+							hal_init, hal_exit)

commit 6a5bc0f8c030dc1620657d97e53bd7cabfe72ab5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:36:33 2008 +0200

    Update Bluetooth plugin with hardware detection support

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 7c75529f..167878b3 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -23,43 +23,143 @@
 #include <config.h>
 #endif
 
+#include <dbus/dbus.h>
+
 #include <connman/plugin.h>
-#include <connman/iface.h>
+#include <connman/driver.h>
 #include <connman/log.h>
 
-static int bluetooth_probe(struct connman_iface *iface)
+#define BLUEZ_SERVICE "org.bluez"
+
+#define MANAGER_INTERFACE "org.bluez.Manager"
+#define MANAGER_PATH "/"
+
+static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
+static GSList *element_list = NULL;
+
+static void create_element(DBusConnection *conn, const char *path)
+{
+	struct connman_element *element;
+
+	DBG("conn %p path %s", conn, path);
+
+	element = connman_element_create();
+
+	element->name = g_path_get_basename(path);
+	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	element->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+
+	g_static_mutex_lock(&element_mutex);
+
+	connman_element_register(element, NULL);
+
+	element_list = g_slist_append(element_list, element);
+
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static DBusHandlerResult bluetooth_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
+{
+	DBG("conn %p msg %p", conn, msg);
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static void list_adapters(DBusConnection *conn)
 {
-	DBG("iface %p", iface);
+	DBusMessage *msg, *reply;
+	char **paths = NULL;
+	int i, num = 0;
+
+	DBG("conn %p");
+
+	msg = dbus_message_new_method_call(BLUEZ_SERVICE, MANAGER_PATH,
+					MANAGER_INTERFACE, "ListAdapters");
+	if (!msg) {
+		connman_error("ListAdpaters message alloction failed");
+		return;
+	}
 
-	iface->type = CONNMAN_IFACE_TYPE_BLUETOOTH;
+	reply = dbus_connection_send_with_reply_and_block(conn, msg, -1, NULL);
 
-	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4;
+	dbus_message_unref(msg);
+
+	if (!reply) {
+		connman_error("ListAdapters method call failed");
+		return;
+	}
+
+	dbus_message_get_args(reply, NULL, DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+						&paths, &num, DBUS_TYPE_INVALID);
+
+	for (i = 0; i < num; i++)
+		create_element(conn, paths[i]);
+
+	g_strfreev(paths);
+
+	dbus_message_unref(reply);
+}
+
+static int bluetooth_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
 
 	return 0;
 }
 
-static void bluetooth_remove(struct connman_iface *iface)
+static void bluetooth_remove(struct connman_element *element)
 {
-	DBG("iface %p", iface);
+	DBG("element %p name %s", element, element->name);
 }
 
-static struct connman_iface_driver bluetooth_driver = {
+static struct connman_driver bluetooth_driver = {
 	.name		= "bluetooth",
-	.capability	= "bluetooth_hci",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
 	.probe		= bluetooth_probe,
 	.remove		= bluetooth_remove,
 };
 
+static DBusConnection *connection;
+
 static int bluetooth_init(void)
 {
-	return connman_iface_register(&bluetooth_driver);
+	gchar *match;
+	int err;
+
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (connection == NULL)
+		return -EIO;
+
+	if (dbus_connection_add_filter(connection, bluetooth_filter,
+						NULL, NULL) == FALSE)
+		connman_error("Can't add D-Bus filter for Bluetooth");
+
+	match = g_strdup_printf("sender=%s,interface=%s", "org.bluez",
+							"org.bluez.Manager");
+
+	dbus_bus_add_match(connection, match, NULL);
+
+	g_free(match);
+
+	err = connman_driver_register(&bluetooth_driver);
+	if (err < 0) {
+		dbus_connection_unref(connection);
+		return err;
+	}
+
+	list_adapters(connection);
+
+	return 0;
 }
 
 static void bluetooth_exit(void)
 {
-	connman_iface_unregister(&bluetooth_driver);
+	connman_driver_unregister(&bluetooth_driver);
+
+	dbus_connection_unref(connection);
 }
 
-CONNMAN_PLUGIN_DEFINE("bluetooth", "Bluetooth interface plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE("bluetooth", "Bluetooth technology plugin", VERSION,
 						bluetooth_init, bluetooth_exit)

commit 8c25266db4b4fc1545d537355439a44304b3f348
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 10:58:07 2008 +0200

    Add simple Ethernet plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 8e5e8585..d0ca20ee 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,8 +1,8 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la 80203.la 80211.la bluetooth.la \
-					dhclient.la resolvconf.la
+plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la \
+				80203.la 80211.la dhclient.la resolvconf.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
@@ -12,6 +12,8 @@ hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
 
 80211_la_SOURCES = 80211.c supplicant.h supplicant.c
 
+ethernet_la_SOURCES = ethernet.c
+
 bluetooth_la_SOURCES = bluetooth.c
 
 dhclient_la_SOURCES = dhclient.c
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
new file mode 100644
index 00000000..03c52d26
--- /dev/null
+++ b/plugins/ethernet.c
@@ -0,0 +1,312 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <unistd.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <linux/if.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
+static GSList *ethernet_list = NULL;
+
+static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
+static GSList *element_list = NULL;
+
+static void create_element(struct connman_element *parent,
+					enum connman_element_type type)
+{
+	struct connman_element *element;
+
+	DBG("parent %p name %s", parent, parent->name);
+
+	element = connman_element_create();
+
+	element->type = type;
+	element->netdev.index = parent->netdev.index;
+	element->netdev.name = g_strdup(parent->netdev.name);
+
+	g_static_mutex_lock(&element_mutex);
+	element_list = g_slist_append(element_list, element);
+	g_static_mutex_unlock(&element_mutex);
+
+	connman_element_register(element, parent);
+}
+
+static void remove_elements(struct connman_element *parent)
+{
+	GSList *list;
+
+	DBG("parent %p name %s", parent, parent->name);
+
+	g_static_mutex_lock(&element_mutex);
+
+	for (list = element_list; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		if (element->netdev.index != parent->netdev.index)
+			continue;
+
+		element_list = g_slist_remove(element_list, element);
+
+		connman_element_unregister(element);
+
+		connman_element_unref(element);
+	}
+
+	g_static_mutex_unlock(&element_mutex);
+}
+
+static void rtnl_link(struct nlmsghdr *hdr, const char *type)
+{
+	GSList *list;
+	struct ifinfomsg *msg;
+	int bytes;
+
+	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
+	bytes = IFLA_PAYLOAD(hdr);
+
+	DBG("%s ifi_index %d ifi_flags 0x%04x",
+				type, msg->ifi_index, msg->ifi_flags);
+
+	g_static_mutex_lock(&ethernet_mutex);
+
+	for (list = ethernet_list; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE)
+			continue;
+
+		if (element->netdev.index != msg->ifi_index)
+			continue;
+
+		if ((element->netdev.flags & IFF_RUNNING) ==
+						(msg->ifi_flags & IFF_RUNNING))
+			continue;
+
+		element->netdev.flags = msg->ifi_flags;
+
+		if (msg->ifi_flags & IFF_RUNNING) {
+			DBG("carrier on");
+
+			create_element(element, CONNMAN_ELEMENT_TYPE_DHCP);
+			create_element(element, CONNMAN_ELEMENT_TYPE_ZEROCONF);
+		} else {
+			DBG("carrier off");
+
+			remove_elements(element);
+		}
+	}
+
+	g_static_mutex_unlock(&ethernet_mutex);
+}
+
+static gboolean rtnl_event(GIOChannel *chan, GIOCondition cond, gpointer data)
+{
+	unsigned char buf[1024];
+	void *ptr = buf;
+	gsize len;
+	GIOError err;
+
+	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
+		return FALSE;
+
+	memset(buf, 0, sizeof(buf));
+
+	err = g_io_channel_read(chan, (gchar *) buf, sizeof(buf), &len);
+	if (err) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		return FALSE;
+	}
+
+	DBG("buf %p len %zd", buf, len);
+
+	while (len > 0) {
+		struct nlmsghdr *hdr = ptr;
+		struct nlmsgerr *err;
+
+		if (!NLMSG_OK(hdr, len))
+			break;
+
+		DBG("len %d type %d flags 0x%04x seq %d",
+					hdr->nlmsg_len, hdr->nlmsg_type,
+					hdr->nlmsg_flags, hdr->nlmsg_seq);
+
+		switch (hdr->nlmsg_type) {
+		case NLMSG_ERROR:
+			err = NLMSG_DATA(hdr);
+			DBG("ERROR %d (%s)", -err->error,
+						strerror(-err->error));
+			break;
+
+		case RTM_NEWLINK:
+			rtnl_link(hdr, "NEWLINK");
+			break;
+
+		case RTM_DELLINK:
+			rtnl_link(hdr, "DELLINK");
+			break;
+		}
+
+		len -= hdr->nlmsg_len;
+		ptr += hdr->nlmsg_len;
+	}
+
+	return TRUE;
+}
+
+static GIOChannel *channel = NULL;
+
+static int rtnl_request(void)
+{
+	struct {
+		struct nlmsghdr hdr;
+		struct rtgenmsg msg;
+	} req;
+
+	struct sockaddr_nl addr;
+	int sk;
+
+	DBG("");
+
+	memset(&req, 0, sizeof(req));
+	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
+	req.hdr.nlmsg_type = RTM_GETLINK;
+	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
+	req.hdr.nlmsg_pid = 0;
+	req.hdr.nlmsg_seq = 42;
+	req.msg.rtgen_family = AF_INET;
+
+	sk = g_io_channel_unix_get_fd(channel);
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+
+	return sendto(sk, &req, sizeof(req), 0,
+			(struct sockaddr *) &addr, sizeof(addr));
+}
+
+static int ethernet_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	g_static_mutex_lock(&ethernet_mutex);
+	ethernet_list = g_slist_append(ethernet_list, element);
+	g_static_mutex_unlock(&ethernet_mutex);
+
+	rtnl_request();
+
+	return 0;
+}
+
+static void ethernet_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	g_static_mutex_lock(&ethernet_mutex);
+	ethernet_list = g_slist_remove(ethernet_list, element);
+	g_static_mutex_unlock(&ethernet_mutex);
+}
+
+static struct connman_driver ethernet_driver = {
+	.name		= "ethernet",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_ETHERNET,
+	.probe		= ethernet_probe,
+	.remove		= ethernet_remove,
+};
+
+static int rtnl_init(void)
+{
+	struct sockaddr_nl addr;
+	int sk, err;
+
+	DBG("");
+
+	sk = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);
+	if (sk < 0)
+		return -errno;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+	addr.nl_groups = RTMGRP_LINK;
+
+	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		err = -errno;
+		close(sk);
+		return err;
+	}
+
+	channel = g_io_channel_unix_new(sk);
+	g_io_channel_set_close_on_unref(channel, TRUE);
+
+	g_io_add_watch(channel, G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+							rtnl_event, NULL);
+
+	return 0;
+}
+
+static void rtnl_cleanup(void)
+{
+	DBG("");
+
+	g_io_channel_shutdown(channel, TRUE, NULL);
+	g_io_channel_unref(channel);
+
+	channel = NULL;
+}
+
+static int ethernet_init(void)
+{
+	int err;
+
+	err = rtnl_init();
+	if (err < 0)
+		return err;
+
+	err = connman_driver_register(&ethernet_driver);
+	if (err < 0) {
+		rtnl_cleanup();
+		return err;
+	}
+
+	return 0;
+}
+
+static void ethernet_exit(void)
+{
+	connman_driver_unregister(&ethernet_driver);
+
+	rtnl_cleanup();
+}
+
+CONNMAN_PLUGIN_DEFINE("ethernet", "Ethernet interface plugin", VERSION,
+						ethernet_init, ethernet_exit)

commit 3b478b3a55083774dcd1e409b67274814cca8780
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 11:00:44 2008 +0200

    Update dhclient plugin with support for element infrastructure

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index d0ca20ee..9b73edd0 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,8 +1,8 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la \
-				80203.la 80211.la dhclient.la resolvconf.la
+plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la dhclient.la \
+					80203.la 80211.la resolvconf.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index bdf877af..5dddc638 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -23,24 +23,13 @@
 #include <config.h>
 #endif
 
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <string.h>
 #include <sys/wait.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <net/if.h>
-
-#include <glib.h>
-#include <gdbus.h>
+#include <glib/gstdio.h>
 
 #include <connman/plugin.h>
-#include <connman/dhcp.h>
+#include <connman/driver.h>
 #include <connman/dbus.h>
+#include <connman/log.h>
 
 #define DHCLIENT_INTF "org.isc.dhclient"
 #define DHCLIENT_PATH "/org/isc/dhclient"
@@ -50,17 +39,19 @@ static const char *busname;
 struct dhclient_task {
 	GPid pid;
 	int ifindex;
-	char *ifname;
-	struct connman_iface *iface;
+	gchar *ifname;
+	struct connman_element *parent;
+	struct connman_element *child;
 };
 
-static GSList *tasks = NULL;
+static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
+static GSList *task_list = NULL;
 
 static struct dhclient_task *find_task_by_pid(GPid pid)
 {
 	GSList *list;
 
-	for (list = tasks; list; list = list->next) {
+	for (list = task_list; list; list = list->next) {
 		struct dhclient_task *task = list->data;
 
 		if (task->pid == pid)
@@ -74,7 +65,7 @@ static struct dhclient_task *find_task_by_index(int index)
 {
 	GSList *list;
 
-	for (list = tasks; list; list = list->next) {
+	for (list = task_list; list; list = list->next) {
 		struct dhclient_task *task = list->data;
 
 		if (task->ifindex == index)
@@ -86,37 +77,48 @@ static struct dhclient_task *find_task_by_index(int index)
 
 static void kill_task(struct dhclient_task *task)
 {
+	DBG("task %p name %s pid %d", task, task->ifname, task->pid);
+
 	if (task->pid > 0)
 		kill(task->pid, SIGTERM);
 }
 
+static void unlink_task(struct dhclient_task *task)
+{
+	gchar *pathname;
+
+	DBG("task %p name %s pid %d", task, task->ifname, task->pid);
+
+	pathname = g_strdup_printf("%s/dhclient.%s.pid",
+						STATEDIR, task->ifname);
+	g_unlink(pathname);
+	g_free(pathname);
+
+	pathname = g_strdup_printf("%s/dhclient.%s.leases",
+						STATEDIR, task->ifname);
+	g_unlink(pathname);
+	g_free(pathname);
+}
+
 static void task_died(GPid pid, gint status, gpointer data)
 {
 	struct dhclient_task *task = data;
-	char pathname[PATH_MAX];
 
 	if (WIFEXITED(status))
-		printf("[DHCP] exit status %d for %s\n",
-					WEXITSTATUS(status), task->ifname);
+		DBG("exit status %d for %s", WEXITSTATUS(status), task->ifname);
 	else
-		printf("[DHCP] signal %d killed %s\n",
-					WTERMSIG(status), task->ifname);
+		DBG("signal %d killed %s", WTERMSIG(status), task->ifname);
 
 	g_spawn_close_pid(pid);
 	task->pid = 0;
 
-	tasks = g_slist_remove(tasks, task);
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_remove(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
 
-	snprintf(pathname, sizeof(pathname) - 1,
-			"%s/dhclient.%s.pid", STATEDIR, task->ifname);
-	unlink(pathname);
-
-	snprintf(pathname, sizeof(pathname) - 1,
-			"%s/dhclient.%s.leases", STATEDIR, task->ifname);
-	unlink(pathname);
-
-	free(task->ifname);
+	unlink_task(task);
 
+	g_free(task->ifname);
 	g_free(task);
 }
 
@@ -124,45 +126,32 @@ static void task_setup(gpointer data)
 {
 	struct dhclient_task *task = data;
 
-	printf("[DHCP] setup %s\n", task->ifname);
+	DBG("task %p name %s", task, task->ifname);
 }
 
-static int dhclient_request(struct connman_iface *iface)
+static int dhclient_probe(struct connman_element *element)
 {
-	struct ifreq ifr;
 	struct dhclient_task *task;
 	char *argv[16], *envp[1], address[128], pidfile[PATH_MAX];
 	char leases[PATH_MAX], config[PATH_MAX], script[PATH_MAX];
-	int sk, err;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
 
-	if (err < 0)
-		return -EIO;
+	DBG("element %p name %s", element, element->name);
 
 	task = g_try_new0(struct dhclient_task, 1);
 	if (task == NULL)
 		return -ENOMEM;
 
-	task->ifindex = iface->index;
-	task->ifname = strdup(ifr.ifr_name);
-	task->iface = iface;
+	task->ifindex = element->netdev.index;
+	task->ifname = g_strdup(element->netdev.name);
+	task->parent = element;
+	task->child = NULL;
 
 	if (task->ifname == NULL) {
 		g_free(task);
 		return -ENOMEM;
 	}
 
-	printf("[DHCP] request %s\n", task->ifname);
+	DBG("request %s", task->ifname);
 
 	snprintf(address, sizeof(address) - 1, "BUSNAME=%s", busname);
 	snprintf(pidfile, sizeof(pidfile) - 1,
@@ -193,56 +182,82 @@ static int dhclient_request(struct connman_iface *iface)
 
 	if (g_spawn_async(NULL, argv, envp, G_SPAWN_DO_NOT_REAP_CHILD,
 				task_setup, task, &task->pid, NULL) == FALSE) {
-		printf("Failed to spawn dhclient\n");
+		connman_error("Failed to spawn dhclient");
 		return -1;
 	}
 
-	tasks = g_slist_append(tasks, task);
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_append(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
 
 	g_child_watch_add(task->pid, task_died, task);
 
-	printf("[DHCP] executed %s with pid %d\n", DHCLIENT, task->pid);
+	DBG("executed %s with pid %d", DHCLIENT, task->pid);
 
 	return 0;
 }
 
-static int dhclient_release(struct connman_iface *iface)
+static void dhclient_remove(struct connman_element *element)
 {
 	struct dhclient_task *task;
 
-	task = find_task_by_index(iface->index);
+	DBG("element %p name %s", element, element->name);
+
+	g_static_mutex_lock(&task_mutex);
+	task = find_task_by_index(element->netdev.index);
+	g_static_mutex_unlock(&task_mutex);
+
 	if (task == NULL)
-		return -ENODEV;
+		return;
 
-	printf("[DHCP] release %s\n", task->ifname);
+	DBG("release %s", task->ifname);
 
-	tasks = g_slist_remove(tasks, task);
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_remove(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
 
-	kill_task(task);
+	connman_element_unregister(task->child);
+	connman_element_unref(task->child);
+	task->child = NULL;
 
-	return 0;
+	kill_task(task);
 }
 
-static struct connman_dhcp_driver dhclient_driver = {
+static struct connman_driver dhclient_driver = {
 	.name		= "dhclient",
-	.request	= dhclient_request,
-	.release	= dhclient_release,
+	.type		= CONNMAN_ELEMENT_TYPE_DHCP,
+	.probe		= dhclient_probe,
+	.remove		= dhclient_remove,
 };
 
+static void copy_ipv4(struct connman_element *src, struct connman_element *dst)
+{
+	g_free(dst->ipv4.address);
+	g_free(dst->ipv4.netmask);
+	g_free(dst->ipv4.gateway);
+	g_free(dst->ipv4.network);
+	g_free(dst->ipv4.broadcast);
+	g_free(dst->ipv4.nameserver);
+
+	dst->ipv4.address = g_strdup(src->ipv4.address);
+	dst->ipv4.netmask = g_strdup(src->ipv4.netmask);
+	dst->ipv4.gateway = g_strdup(src->ipv4.gateway);
+	dst->ipv4.network = g_strdup(src->ipv4.network);
+	dst->ipv4.broadcast = g_strdup(src->ipv4.broadcast);
+	dst->ipv4.nameserver = g_strdup(src->ipv4.nameserver);
+}
+
 static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 						DBusMessage *msg, void *data)
 {
 	DBusMessageIter iter, dict;
 	dbus_uint32_t pid;
 	struct dhclient_task *task;
-	struct connman_ipv4 ipv4;
 	const char *text, *key, *value;
 
 	if (dbus_message_is_method_call(msg, DHCLIENT_INTF, "notify") == FALSE)
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-	memset(&ipv4, 0, sizeof(ipv4));
-
 	dbus_message_iter_init(msg, &iter);
 
 	dbus_message_iter_get_basic(&iter, &pid);
@@ -251,9 +266,12 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 	dbus_message_iter_get_basic(&iter, &text);
 	dbus_message_iter_next(&iter);
 
-	printf("[DHCP] change %d to %s\n", pid, text);
+	DBG("change %d to %s", pid, text);
 
+	g_static_mutex_lock(&task_mutex);
 	task = find_task_by_pid(pid);
+	g_static_mutex_unlock(&task_mutex);
+
 	if (task == NULL)
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
@@ -267,50 +285,53 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 		dbus_message_iter_next(&entry);
 		dbus_message_iter_get_basic(&entry, &value);
 
-		printf("[DHCP] %s = %s\n", key, value);
+		DBG("%s = %s", key, value);
 
-		if (strcmp(key, "new_ip_address") == 0)
-			inet_aton(value, &ipv4.address);
+		if (g_ascii_strcasecmp(key, "new_ip_address") == 0)
+			task->parent->ipv4.address = g_strdup(value);
 
-		if (strcmp(key, "new_subnet_mask") == 0)
-			inet_aton(value, &ipv4.netmask);
+		if (g_ascii_strcasecmp(key, "new_subnet_mask") == 0)
+			task->parent->ipv4.netmask = g_strdup(value);
 
-		if (strcmp(key, "new_routers") == 0)
-			inet_aton(value, &ipv4.gateway);
+		if (g_ascii_strcasecmp(key, "new_routers") == 0)
+			task->parent->ipv4.gateway = g_strdup(value);
 
-		if (strcmp(key, "new_network_number") == 0)
-			inet_aton(value, &ipv4.network);
+		if (g_ascii_strcasecmp(key, "new_network_number") == 0)
+			task->parent->ipv4.network = g_strdup(value);
 
-		if (strcmp(key, "new_broadcast_address") == 0)
-			inet_aton(value, &ipv4.broadcast);
+		if (g_ascii_strcasecmp(key, "new_broadcast_address") == 0)
+			task->parent->ipv4.broadcast = g_strdup(value);
 
-		if (strcmp(key, "new_domain_name_servers") == 0)
-			inet_aton(value, &ipv4.nameserver);
+		if (g_ascii_strcasecmp(key, "new_domain_name_servers") == 0)
+			task->parent->ipv4.nameserver = g_strdup(value);
 
 		dbus_message_iter_next(&dict);
 	}
 
-	if (strcmp(text, "PREINIT") == 0)
-		connman_dhcp_update(task->iface,
-					CONNMAN_DHCP_STATE_INIT, &ipv4);
-	else if (strcmp(text, "BOUND") == 0 || strcmp(text, "REBOOT") == 0)
-		connman_dhcp_update(task->iface,
-					CONNMAN_DHCP_STATE_BOUND, &ipv4);
-	else if (strcmp(text, "RENEW") == 0 || strcmp(text, "REBIND") == 0)
-		connman_dhcp_update(task->iface,
-					CONNMAN_DHCP_STATE_RENEW, &ipv4);
-	else
-		connman_dhcp_update(task->iface,
-					CONNMAN_DHCP_STATE_FAILED, NULL);
+	if (g_ascii_strcasecmp(text, "PREINIT") == 0) {
+	} else if (g_ascii_strcasecmp(text, "BOUND") == 0 ||
+				g_ascii_strcasecmp(text, "REBOOT") == 0) {
+		task->child = connman_element_create();
+		task->child->type = CONNMAN_ELEMENT_TYPE_IPV4;
+		task->child->netdev.index = task->ifindex;
+		copy_ipv4(task->parent, task->child);
+		connman_element_register(task->child, task->parent);
+	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
+				g_ascii_strcasecmp(text, "REBIND") == 0) {
+		copy_ipv4(task->parent, task->child);
+		connman_element_update(task->child);
+	} else {
+	}
 
 	return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusConnection *connection;
 
-static int plugin_init(void)
+static int dhclient_init(void)
 {
 	gchar *filter;
+	int err;
 
 	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 
@@ -326,29 +347,44 @@ static int plugin_init(void)
 
 	g_free(filter);
 
-	connman_dhcp_register(&dhclient_driver);
+	err = connman_driver_register(&dhclient_driver);
+	if (err < 0) {
+		dbus_connection_unref(connection);
+		return err;
+	}
 
 	return 0;
 }
 
-static void plugin_exit(void)
+static void dhclient_exit(void)
 {
 	GSList *list;
 
-	for (list = tasks; list; list = list->next) {
+	g_static_mutex_lock(&task_mutex);
+
+	for (list = task_list; list; list = list->next) {
 		struct dhclient_task *task = list->data;
 
-		printf("[DHCP] killing process %d\n", task->pid);
+		if (task->child) {
+			connman_element_unregister(task->child);
+			connman_element_unref(task->child);
+			task->child = NULL;
+		}
+
+		DBG("killing process %d", task->pid);
 
 		kill_task(task);
+		unlink_task(task);
 	}
 
-	g_slist_free(tasks);
+	g_static_mutex_unlock(&task_mutex);
+
+	g_slist_free(task_list);
 
-	connman_dhcp_unregister(&dhclient_driver);
+	connman_driver_unregister(&dhclient_driver);
 
 	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("dhclient", "ISC DHCP client plugin", VERSION,
-						plugin_init, plugin_exit)
+						dhclient_init, dhclient_exit)

commit 86eff58e88de7f5c57a3e7c3f6e3dd136b9b9e9e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 11:02:28 2008 +0200

    Add skeleton for IPv4 configuration plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 9b73edd0..88936e7e 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,17 +1,13 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la dhclient.la \
+plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la dhclient.la ipv4.la \
 					80203.la 80211.la resolvconf.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
 hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
 
-80203_la_SOURCES = 80203.c
-
-80211_la_SOURCES = 80211.c supplicant.h supplicant.c
-
 ethernet_la_SOURCES = ethernet.c
 
 bluetooth_la_SOURCES = bluetooth.c
@@ -20,6 +16,12 @@ dhclient_la_SOURCES = dhclient.c
 dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
+ipv4_la_SOURCES = ipv4.c
+
+80203_la_SOURCES = 80203.c
+
+80211_la_SOURCES = 80211.c supplicant.h supplicant.c
+
 resolvconf_la_SOURCES = resolvconf.c
 
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
new file mode 100644
index 00000000..66e55b9b
--- /dev/null
+++ b/plugins/ipv4.c
@@ -0,0 +1,64 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static int ipv4_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	DBG("address %s", element->ipv4.address);
+	DBG("netmask %s", element->ipv4.netmask);
+	DBG("gateway %s", element->ipv4.gateway);
+
+	return 0;
+}
+
+static void ipv4_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver ipv4_driver = {
+	.name		= "ipv4",
+	.type		= CONNMAN_ELEMENT_TYPE_IPV4,
+	.probe		= ipv4_probe,
+	.remove		= ipv4_remove,
+};
+
+static int ipv4_init(void)
+{
+	return connman_driver_register(&ipv4_driver);
+}
+
+static void ipv4_exit(void)
+{
+	connman_driver_unregister(&ipv4_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("ipv4", "IPv4 configuration plugin", VERSION,
+							ipv4_init, ipv4_exit)

commit d7a7bfd60035ed80f984dfcefac9b4021bd29d03
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 11:06:04 2008 +0200

    Disable setup of RTNL, interfaces and networks

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 88936e7e..7f018960 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,8 +1,9 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la dhclient.la ipv4.la \
-					80203.la 80211.la resolvconf.la
+plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la dhclient.la ipv4.la
+
+noinst_LTLIBRARIES = 80203.la 80211.la resolvconf.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
diff --git a/src/main.c b/src/main.c
index da9ba455..92a97f29 100644
--- a/src/main.c
+++ b/src/main.c
@@ -135,12 +135,6 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
-	__connman_rtnl_init();
-
-	__connman_network_init(conn);
-
-	__connman_iface_init(conn, option_interface);
-
 	g_free(option_interface);
 
 	memset(&sa, 0, sizeof(sa));
@@ -150,12 +144,6 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
-	__connman_iface_cleanup();
-
-	__connman_network_cleanup();
-
-	__connman_rtnl_cleanup();
-
 	__connman_plugin_cleanup();
 
 	__connman_manager_cleanup();

commit 2f1e2f29dcab50d2111009efc505c496aa0ab494
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 28 11:09:17 2008 +0200

    Add skeleton for WiFi interface plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 7f018960..4084410b 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,7 +1,8 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la ethernet.la bluetooth.la dhclient.la ipv4.la
+plugin_LTLIBRARIES = hal.la ethernet.la wifi.la bluetooth.la \
+						dhclient.la ipv4.la
 
 noinst_LTLIBRARIES = 80203.la 80211.la resolvconf.la
 
@@ -11,6 +12,8 @@ hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
 
 ethernet_la_SOURCES = ethernet.c
 
+wifi_la_SOURCES = wifi.c
+
 bluetooth_la_SOURCES = bluetooth.c
 
 dhclient_la_SOURCES = dhclient.c
diff --git a/plugins/wifi.c b/plugins/wifi.c
new file mode 100644
index 00000000..b31fa9f2
--- /dev/null
+++ b/plugins/wifi.c
@@ -0,0 +1,61 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static int wifi_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	return 0;
+}
+
+static void wifi_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver wifi_driver = {
+	.name		= "wifi",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_WIFI,
+	.probe		= wifi_probe,
+	.remove		= wifi_remove,
+};
+
+static int wifi_init(void)
+{
+	return connman_driver_register(&wifi_driver);
+}
+
+static void wifi_exit(void)
+{
+	connman_driver_unregister(&wifi_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("WiFi", "WiFi interface plugin", VERSION,
+							wifi_init, wifi_exit)

commit 85161ed17c46ce91fa768576f54c6e2278c07f34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 04:57:57 2008 +0200

    Add first draft of new D-Bus API

diff --git a/include/dbus.h b/include/dbus.h
index a237e382..be98a4ef 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -30,15 +30,17 @@ extern "C" {
 
 #define CONNMAN_SERVICE  "org.moblin.connman"
 
-#define CONNMAN_ERROR_INTERFACE  CONNMAN_SERVICE ".Error"
+#define CONNMAN_ERROR_INTERFACE    CONNMAN_SERVICE ".Error"
 
-#define CONNMAN_AGENT_INTERFACE  CONNMAN_SERVICE ".Agent"
+#define CONNMAN_AGENT_INTERFACE    CONNMAN_SERVICE ".Agent"
+
+#define CONNMAN_ELEMENT_INTERFACE  CONNMAN_SERVICE ".Element"
 
-#define CONNMAN_MANAGER_PATH       "/"
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
+#define CONNMAN_MANAGER_PATH       "/"
 
-#define CONNMAN_IFACE_BASEPATH  "/interface"
-#define CONNMAN_IFACE_INTERFACE  CONNMAN_SERVICE ".Interface"
+#define CONNMAN_IFACE_INTERFACE    CONNMAN_SERVICE ".Interface"
+#define CONNMAN_IFACE_BASEPATH     "/interface"
 
 #define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
 
diff --git a/src/connman.h b/src/connman.h
index e4f51df4..05bfe362 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -26,7 +26,6 @@
 #define NM_SERVICE    "org.freedesktop.NetworkManager"
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
-#define NM_DEVICE     NM_SERVICE ".Devices"
 
 int __connman_manager_init(DBusConnection *conn, gboolean compat);
 void __connman_manager_cleanup(void);
@@ -50,10 +49,14 @@ void __connman_plugin_cleanup(void);
 #include <connman/driver.h>
 #include <connman/element.h>
 
-int __connman_element_init(void);
+int __connman_element_init(DBusConnection *conn);
 void __connman_element_cleanup(void);
 
-void __connman_element_list(DBusMessageIter *iter);
+void __connman_element_list(enum connman_element_type type,
+						DBusMessageIter *iter);
+
+const char *__connman_element_type2string(enum connman_element_type type);
+const char *__connman_element_subtype2string(enum connman_element_subtype type);
 
 #include <connman/iface.h>
 
diff --git a/src/element.c b/src/element.c
index 71332d0e..a4f0328d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -26,10 +26,12 @@
 #include <errno.h>
 
 #include <glib.h>
-#include <dbus/dbus.h>
+#include <gdbus.h>
 
 #include "connman.h"
 
+static DBusConnection *connection;
+
 static GStaticMutex driver_mutex = G_STATIC_MUTEX_INIT;
 static GSList *driver_list = NULL;
 static GThreadPool *driver_thread;
@@ -38,29 +40,183 @@ static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
 static GNode *element_root = NULL;
 static GThreadPool *element_thread;
 
+static const char *type2string(enum connman_element_type type)
+{
+	switch (type) {
+	case CONNMAN_ELEMENT_TYPE_UNKNOWN:
+		return "unknown";
+	case CONNMAN_ELEMENT_TYPE_ROOT:
+		return "root";
+	case CONNMAN_ELEMENT_TYPE_DEVICE:
+		return "device";
+	case CONNMAN_ELEMENT_TYPE_NETWORK:
+		return "network";
+	case CONNMAN_ELEMENT_TYPE_IPV4:
+		return "ipv4";
+	case CONNMAN_ELEMENT_TYPE_IPV6:
+		return "ipv6";
+	case CONNMAN_ELEMENT_TYPE_DHCP:
+		return "dhcp";
+	case CONNMAN_ELEMENT_TYPE_BOOTP:
+		return "bootp";
+	case CONNMAN_ELEMENT_TYPE_ZEROCONF:
+		return "zeroconf";
+	case CONNMAN_ELEMENT_TYPE_CONNECTION:
+		return "42";
+	}
+
+	return NULL;
+}
+
+static const char *subtype2string(enum connman_element_subtype type)
+{
+	switch (type) {
+	case CONNMAN_ELEMENT_SUBTYPE_UNKNOWN:
+		return "unknown";
+	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:
+		return "ethernet";
+	case CONNMAN_ELEMENT_SUBTYPE_WIFI:
+		return "wifi";
+	case CONNMAN_ELEMENT_SUBTYPE_WIMAX:
+		return "wimax";
+	case CONNMAN_ELEMENT_SUBTYPE_MODEM:
+		return "modem";
+	case CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH:
+		return "bluetooth";
+	}
+
+	return NULL;
+}
+
+static void append_entry(DBusMessageIter *dict,
+				const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *str;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	str = type2string(element->type);
+	if (str != NULL)
+		append_entry(&dict, "Type", DBUS_TYPE_STRING, &str);
+
+	str = subtype2string(element->subtype);
+	if (str != NULL)
+		append_entry(&dict, "Subtype", DBUS_TYPE_STRING, &str);
+
+	if (element->info.driver != NULL)
+		append_entry(&dict, "Driver",
+				DBUS_TYPE_STRING, &element->info.driver);
+
+	if (element->info.vendor != NULL)
+		append_entry(&dict, "Vendor",
+				DBUS_TYPE_STRING, &element->info.vendor);
+
+	if (element->info.product != NULL)
+		append_entry(&dict, "Product",
+				DBUS_TYPE_STRING, &element->info.product);
+
+	if (element->ipv4.address != NULL)
+		append_entry(&dict, "IPv4.Address",
+				DBUS_TYPE_STRING, &element->ipv4.address);
+
+	if (element->ipv4.netmask != NULL)
+		append_entry(&dict, "IPv4.Netmask",
+				DBUS_TYPE_STRING, &element->ipv4.netmask);
+
+	if (element->ipv4.gateway != NULL)
+		append_entry(&dict, "IPv4.Gateway",
+				DBUS_TYPE_STRING, &element->ipv4.gateway);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static GDBusMethodTable element_methods[] = {
+	{ "GetProperties", "", "a{sv}", get_properties },
+	{ },
+};
+
+struct append_filter {
+	enum connman_element_type type;
+	DBusMessageIter *iter;
+};
+
 static gboolean append_path(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
-	DBusMessageIter *iter = data;
+	struct append_filter *filter = data;
 
 	DBG("element %p name %s", element, element->name);
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
 		return FALSE;
 
-	dbus_message_iter_append_basic(iter,
+	if (filter->type != CONNMAN_ELEMENT_TYPE_UNKNOWN &&
+					filter->type != element->type)
+		return FALSE;
+
+	dbus_message_iter_append_basic(filter->iter,
 				DBUS_TYPE_OBJECT_PATH, &element->path);
 
 	return FALSE;
 }
 
-void __connman_element_list(DBusMessageIter *iter)
+void __connman_element_list(enum connman_element_type type,
+						DBusMessageIter *iter)
 {
+	struct append_filter filter = { type, iter };
+
 	DBG("");
 
 	g_static_mutex_lock(&element_mutex);
 	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
-							append_path, iter);
+							append_path, &filter);
 	g_static_mutex_unlock(&element_mutex);
 }
 
@@ -229,6 +385,22 @@ int connman_element_register(struct connman_element *element,
 
 	g_static_mutex_unlock(&element_mutex);
 
+	g_dbus_register_interface(connection, element->path,
+					CONNMAN_ELEMENT_INTERFACE,
+					element_methods, NULL, NULL,
+							element, NULL);
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
+		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "DeviceAdded",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
 	g_thread_pool_push(element_thread, element, NULL);
 
 	return 0;
@@ -240,6 +412,20 @@ void connman_element_unregister(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
+		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "DeviceRemoved",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementRemoved",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_ELEMENT_INTERFACE);
+
 	g_static_mutex_lock(&element_mutex);
 
 	if (element->driver) {
@@ -353,11 +539,15 @@ static void element_probe(gpointer data, gpointer user_data)
 	connman_element_unref(element);
 }
 
-int __connman_element_init(void)
+int __connman_element_init(DBusConnection *conn)
 {
 	struct connman_element *element;
 
-	DBG("");
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -EIO;
 
 	g_static_mutex_lock(&element_mutex);
 
@@ -384,6 +574,9 @@ static gboolean free_node(GNode *node, gpointer data)
 
 	DBG("element %p name %s", element, element->name);
 
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_ELEMENT_INTERFACE);
+
 	if (element->driver) {
 		if (element->driver->remove)
 			element->driver->remove(element);
@@ -414,4 +607,6 @@ void __connman_element_cleanup(void)
 	element_root = NULL;
 
 	g_static_mutex_unlock(&element_mutex);
+
+	dbus_connection_unref(connection);
 }
diff --git a/src/main.c b/src/main.c
index 92a97f29..10f9fe6d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -127,7 +127,7 @@ int main(int argc, char *argv[])
 
 	__connman_log_init(option_detach, option_debug);
 
-	__connman_element_init();
+	__connman_element_init(conn);
 
 	__connman_agent_init(conn);
 
diff --git a/src/manager.c b/src/manager.c
index 7de3668e..8ba4f027 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,113 +27,117 @@
 
 #include "connman.h"
 
-static DBusMessage *list_interfaces(DBusConnection *conn,
+static DBusMessage *register_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	DBusMessageIter array, iter;
+	const char *sender, *path;
 
 	DBG("conn %p", conn);
 
+	sender = dbus_message_get_sender(msg);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
-	__connman_iface_list(&iter);
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	dbus_message_iter_close_container(&array, &iter);
+	__connman_agent_register(sender, path);
 
 	return reply;
 }
 
-static DBusMessage *get_state(DBusConnection *conn,
+static DBusMessage *unregister_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *state;
+	const char *sender, *path;
 
 	DBG("conn %p", conn);
 
+	sender = dbus_message_get_sender(msg);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	if (__connman_iface_is_connected() == TRUE)
-		state = "online";
-	else
-		state = "offline";
+	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
 
-	dbus_message_append_args(reply, DBUS_TYPE_STRING, &state,
-							DBUS_TYPE_INVALID);
+	__connman_agent_unregister(sender, path);
 
 	return reply;
 }
 
-static DBusMessage *register_agent(DBusConnection *conn,
+static DBusMessage *list_elements(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *sender, *path;
+	DBusMessageIter array, iter;
 
 	DBG("conn %p", conn);
 
-	sender = dbus_message_get_sender(msg);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
-							DBUS_TYPE_INVALID);
-
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+	dbus_message_iter_init_append(reply, &array);
 
-	__connman_agent_register(sender, path);
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_UNKNOWN, &iter);
+
+	dbus_message_iter_close_container(&array, &iter);
 
 	return reply;
 }
 
-static DBusMessage *unregister_agent(DBusConnection *conn,
+static DBusMessage *list_devices(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
-	const char *sender, *path;
+	DBusMessageIter array, iter;
 
 	DBG("conn %p", conn);
 
-	sender = dbus_message_get_sender(msg);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
-							DBUS_TYPE_INVALID);
-
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
 
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
+	dbus_message_iter_init_append(reply, &array);
 
-	__connman_agent_unregister(sender, path);
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+
+	dbus_message_iter_close_container(&array, &iter);
 
 	return reply;
 }
 
 static GDBusMethodTable manager_methods[] = {
-	{ "ListInterfaces",  "",  "ao", list_interfaces  },
-	{ "GetState",        "",  "s",  get_state        },
-	{ "RegisterAgent",   "o", "",   register_agent   },
-	{ "UnregisterAgent", "o", "",   unregister_agent },
+	{ "RegisterAgent",   "o", "", register_agent   },
+	{ "UnregisterAgent", "o", "", unregister_agent },
+
+	{ "ListElements", "", "ao", list_elements },
+	{ "ListDevices",  "", "ao", list_devices  },
 	{ },
 };
 
 static GDBusSignalTable manager_signals[] = {
-	{ "InterfaceAdded",   "o" },
-	{ "InterfaceRemoved", "o" },
-	{ "StateChanged",     "s" },
+	{ "ElementAdded",   "o" },
+	{ "ElementUpdated", "o" },
+	{ "ElementRemoved", "o" },
+	{ "DeviceAdded",    "o" },
+	{ "DeviceRemoved",  "o" },
 	{ },
 };
 
@@ -189,10 +193,7 @@ static DBusMessage *nm_state(DBusConnection *conn,
 	if (reply == NULL)
 		return NULL;
 
-	if (__connman_iface_is_connected() == TRUE)
-		state = NM_STATE_CONNECTED;
-	else
-		state = NM_STATE_DISCONNECTED;
+	state = NM_STATE_DISCONNECTED;
 
 	dbus_message_append_args(reply, DBUS_TYPE_UINT32, &state,
 							DBUS_TYPE_INVALID);
diff --git a/test/list-devices b/test/list-devices
new file mode 100755
index 00000000..9b9615bb
--- /dev/null
+++ b/test/list-devices
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+devices = manager.ListDevices()
+
+for path in devices:
+	print "[ %s ]" % (path)
+
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	properties = element.GetProperties()
+	for key in properties.keys():
+		print "    %s = %s" % (key, properties[key])
+
+	print
diff --git a/test/list-elements b/test/list-elements
new file mode 100755
index 00000000..3def8819
--- /dev/null
+++ b/test/list-elements
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+elements = manager.ListElements()
+
+for path in elements:
+	print "[ %s ]" % (path)
+
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	properties = element.GetProperties()
+	for key in properties.keys():
+		print "    %s = %s" % (key, properties[key])
+
+	print
diff --git a/test/list-interfaces b/test/list-interfaces
deleted file mode 100755
index 3a54a269..00000000
--- a/test/list-interfaces
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/usr/bin/python
-
-import dbus
-
-bus = dbus.SystemBus()
-
-manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
-					'org.moblin.connman.Manager')
-
-interfaces = manager.ListInterfaces()
-
-for path in interfaces:
-	print "[ %s ]" % (path)
-
-	interface = dbus.Interface(bus.get_object('org.moblin.connman', path),
-					'org.moblin.connman.Interface')
-
-	properties = interface.GetProperties()
-	for key in properties.keys():
-		print "    %s = %s" % (key, properties[key])
-
-	ipv4 = interface.GetIPv4()
-	for key in ipv4.keys():
-		print "    IPv4.%s = %s" % (key, ipv4[key])
-
-	networks = interface.ListNetworks()
-	for i in networks:
-		print "    Network.Path = %s" % (i)
-
-		network = dbus.Interface(bus.get_object('org.moblin.connman', i),
-						'org.moblin.connman.Network')
-
-		print "    Network.Identifier = %s" % (network.GetIdentifier())
-		print "    Network.Passphrase = %s" % (network.GetPassphrase())
-
-	print
diff --git a/test/monitor-elements b/test/monitor-elements
new file mode 100755
index 00000000..81803952
--- /dev/null
+++ b/test/monitor-elements
@@ -0,0 +1,49 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+
+def element_print(action, path):
+	print "%s [ %s ]" % (action, path)
+
+	if (action == "-"):
+		return
+
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	properties = element.GetProperties()
+	for key in properties.keys():
+		print "      %s = %s" % (key, properties[key])
+
+def element_added(path):
+	element_print("+", path)
+
+def element_updated(path):
+	element_print("*", path)
+
+def element_removed(path):
+	element_print("-", path)
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+
+	bus.add_signal_receiver(element_added,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementAdded")
+
+	bus.add_signal_receiver(element_updated,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementUpdated")
+
+	bus.add_signal_receiver(element_removed,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementRemoved")
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()
diff --git a/test/show-introspection b/test/show-introspection
index c1cb0ef9..86faca18 100755
--- a/test/show-introspection
+++ b/test/show-introspection
@@ -4,18 +4,18 @@ import dbus
 
 bus = dbus.SystemBus()
 
-object = dbus.Interface(bus.get_object('org.moblin.connman', '/'),
-				'org.freedesktop.DBus.Introspectable')
+object = dbus.Interface(bus.get_object("org.moblin.connman", '/'),
+				"org.freedesktop.DBus.Introspectable")
 
 print object.Introspect()
 
-manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
-					'org.moblin.connman.Manager')
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
 
-interfaces = manager.ListInterfaces()
+elements = manager.ListElements()
 
-for path in interfaces:
-	object = dbus.Interface(bus.get_object('org.moblin.connman', path),
-					'org.freedesktop.DBus.Introspectable')
+for path in elements:
+	object = dbus.Interface(bus.get_object("org.moblin.connman", path),
+					"org.freedesktop.DBus.Introspectable")
 
 	print object.Introspect()

commit 6ec36bb5141766e44e4786cb11661e14fbd388a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 07:46:51 2008 +0200

    Add first attempt for the property system

diff --git a/include/Makefile.am b/include/Makefile.am
index e2dacdcc..70c39d27 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h driver.h element.h dbus.h
+include_HEADERS = log.h plugin.h driver.h element.h property.h dbus.h
 
 noinst_HEADERS = iface.h rtnl.h dhcp.h resolver.h
 
diff --git a/include/element.h b/include/element.h
index dfcbd0f0..1d144246 100644
--- a/include/element.h
+++ b/include/element.h
@@ -29,6 +29,8 @@ extern "C" {
 #include <errno.h>
 #include <glib.h>
 
+#include <connman/property.h>
+
 enum connman_element_state {
 	CONNMAN_ELEMENT_STATE_UNKNOWN   = 0,
 	CONNMAN_ELEMENT_STATE_CONNECT   = 1,
@@ -74,11 +76,7 @@ struct connman_element {
 	struct connman_driver *driver;
 	void *driver_data;
 
-	struct {
-		gchar *driver;
-		gchar *vendor;
-		gchar *product;
-	} info;
+	GSList *properties;
 
 	struct {
 		int index;
@@ -100,6 +98,13 @@ extern struct connman_element *connman_element_create(void);
 extern struct connman_element *connman_element_ref(struct connman_element *element);
 extern void connman_element_unref(struct connman_element *element);
 
+extern int connman_element_add_static_property(struct connman_element *element,
+				const char *name, int type, const void *value);
+extern int connman_element_set_property(struct connman_element *element,
+			enum connman_property_type type, const void *value);
+extern int connman_element_get_value(struct connman_element *element,
+				enum connman_property_type type, void *value);
+
 extern int connman_element_register(struct connman_element *element,
 					struct connman_element *parent);
 extern void connman_element_unregister(struct connman_element *element);
diff --git a/include/property.h b/include/property.h
new file mode 100644
index 00000000..76ff04e8
--- /dev/null
+++ b/include/property.h
@@ -0,0 +1,52 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_PROPERTY_H
+#define __CONNMAN_PROPERTY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum connman_property_type {
+	CONNMAN_PROPERTY_TYPE_INVALID = 0,
+
+	CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS,
+	CONNMAN_PROPERTY_TYPE_IPV4_NETMASK,
+	CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY,
+};
+
+enum connman_property_flags {
+	CONNMAN_PROPERTY_FLAG_STATIC = (1 << 0),
+};
+
+struct connman_property {
+	enum connman_property_flags flags;
+	char *name;
+	int type;
+	void *value;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_PROPERTY_H */
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 5dddc638..18022596 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -40,7 +40,7 @@ struct dhclient_task {
 	GPid pid;
 	int ifindex;
 	gchar *ifname;
-	struct connman_element *parent;
+	struct connman_element *element;
 	struct connman_element *child;
 };
 
@@ -143,7 +143,7 @@ static int dhclient_probe(struct connman_element *element)
 
 	task->ifindex = element->netdev.index;
 	task->ifname = g_strdup(element->netdev.name);
-	task->parent = element;
+	task->element = element;
 	task->child = NULL;
 
 	if (task->ifname == NULL) {
@@ -230,23 +230,6 @@ static struct connman_driver dhclient_driver = {
 	.remove		= dhclient_remove,
 };
 
-static void copy_ipv4(struct connman_element *src, struct connman_element *dst)
-{
-	g_free(dst->ipv4.address);
-	g_free(dst->ipv4.netmask);
-	g_free(dst->ipv4.gateway);
-	g_free(dst->ipv4.network);
-	g_free(dst->ipv4.broadcast);
-	g_free(dst->ipv4.nameserver);
-
-	dst->ipv4.address = g_strdup(src->ipv4.address);
-	dst->ipv4.netmask = g_strdup(src->ipv4.netmask);
-	dst->ipv4.gateway = g_strdup(src->ipv4.gateway);
-	dst->ipv4.network = g_strdup(src->ipv4.network);
-	dst->ipv4.broadcast = g_strdup(src->ipv4.broadcast);
-	dst->ipv4.nameserver = g_strdup(src->ipv4.nameserver);
-}
-
 static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 						DBusMessage *msg, void *data)
 {
@@ -287,23 +270,35 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 
 		DBG("%s = %s", key, value);
 
-		if (g_ascii_strcasecmp(key, "new_ip_address") == 0)
-			task->parent->ipv4.address = g_strdup(value);
+		if (g_ascii_strcasecmp(key, "new_ip_address") == 0) {
+			g_free(task->element->ipv4.address);
+			task->element->ipv4.address = g_strdup(value);
+		}
 
-		if (g_ascii_strcasecmp(key, "new_subnet_mask") == 0)
-			task->parent->ipv4.netmask = g_strdup(value);
+		if (g_ascii_strcasecmp(key, "new_subnet_mask") == 0) {
+			g_free(task->element->ipv4.netmask);
+			task->element->ipv4.netmask = g_strdup(value);
+		}
 
-		if (g_ascii_strcasecmp(key, "new_routers") == 0)
-			task->parent->ipv4.gateway = g_strdup(value);
+		if (g_ascii_strcasecmp(key, "new_routers") == 0) {
+			g_free(task->element->ipv4.gateway);
+			task->element->ipv4.gateway = g_strdup(value);
+		}
 
-		if (g_ascii_strcasecmp(key, "new_network_number") == 0)
-			task->parent->ipv4.network = g_strdup(value);
+		if (g_ascii_strcasecmp(key, "new_network_number") == 0) {
+			g_free(task->element->ipv4.network);
+			task->element->ipv4.network = g_strdup(value);
+		}
 
-		if (g_ascii_strcasecmp(key, "new_broadcast_address") == 0)
-			task->parent->ipv4.broadcast = g_strdup(value);
+		if (g_ascii_strcasecmp(key, "new_broadcast_address") == 0) {
+			g_free(task->element->ipv4.broadcast);
+			task->element->ipv4.broadcast = g_strdup(value);
+		}
 
-		if (g_ascii_strcasecmp(key, "new_domain_name_servers") == 0)
-			task->parent->ipv4.nameserver = g_strdup(value);
+		if (g_ascii_strcasecmp(key, "new_domain_name_servers") == 0) {
+			g_free(task->element->ipv4.nameserver);
+			task->element->ipv4.nameserver = g_strdup(value);
+		}
 
 		dbus_message_iter_next(&dict);
 	}
@@ -314,11 +309,11 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 		task->child = connman_element_create();
 		task->child->type = CONNMAN_ELEMENT_TYPE_IPV4;
 		task->child->netdev.index = task->ifindex;
-		copy_ipv4(task->parent, task->child);
-		connman_element_register(task->child, task->parent);
+		connman_element_update(task->element);
+		connman_element_register(task->child, task->element);
 	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
 				g_ascii_strcasecmp(text, "REBIND") == 0) {
-		copy_ipv4(task->parent, task->child);
+		connman_element_update(task->element);
 		connman_element_update(task->child);
 	} else {
 	}
diff --git a/plugins/hal.c b/plugins/hal.c
index bb5ad94d..467e5d32 100644
--- a/plugins/hal.c
+++ b/plugins/hal.c
@@ -59,19 +59,22 @@ static void device_info(LibHalContext *ctx, const char *udi,
 		value = libhal_device_get_property_string(ctx, parent,
 						"info.linux.driver", NULL);
 		if (value != NULL)
-			element->info.driver = g_strdup(value);
+			connman_element_add_static_property(element,
+					"Driver", DBUS_TYPE_STRING, &value);
 	}
 
 	if (g_str_equal(subsys, "net") == TRUE) {
 		value = libhal_device_get_property_string(ctx, parent,
 							"info.vendor", NULL);
 		if (value != NULL)
-			element->info.vendor = g_strdup(value);
+			connman_element_add_static_property(element,
+					"Vendor", DBUS_TYPE_STRING, &value);
 
 		value = libhal_device_get_property_string(ctx, parent,
 							"info.product", NULL);
 		if (value != NULL)
-			element->info.product = g_strdup(value);
+			connman_element_add_static_property(element,
+					"Product", DBUS_TYPE_STRING, &value);
 	}
 }
 
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 66e55b9b..93706449 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -29,11 +29,20 @@
 
 static int ipv4_probe(struct connman_element *element)
 {
+	const char *address = NULL, *netmask = NULL, *gateway = NULL;
+
 	DBG("element %p name %s", element, element->name);
 
-	DBG("address %s", element->ipv4.address);
-	DBG("netmask %s", element->ipv4.netmask);
-	DBG("gateway %s", element->ipv4.gateway);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS, &address);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_TYPE_IPV4_NETMASK, &netmask);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY, &gateway);
+
+	DBG("address %s", address);
+	DBG("netmask %s", netmask);
+	DBG("gateway %s", gateway);
 
 	return 0;
 }
diff --git a/src/element.c b/src/element.c
index a4f0328d..93ae5d19 100644
--- a/src/element.c
+++ b/src/element.c
@@ -106,6 +106,9 @@ static void append_entry(DBusMessageIter *dict,
 	case DBUS_TYPE_UINT16:
 		signature = DBUS_TYPE_UINT16_AS_STRING;
 		break;
+	case DBUS_TYPE_OBJECT_PATH:
+		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
+		break;
 	default:
 		signature = DBUS_TYPE_VARIANT_AS_STRING;
 		break;
@@ -119,10 +122,21 @@ static void append_entry(DBusMessageIter *dict,
 	dbus_message_iter_close_container(dict, &entry);
 }
 
+static void append_property(DBusMessageIter *dict,
+				struct connman_property *property)
+{
+	if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC) {
+		append_entry(dict, property->name, property->type,
+							&property->value);
+		return;
+	}
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
+	GSList *list;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
 	const char *str;
@@ -140,38 +154,33 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	if (element->parent != NULL)
+		append_entry(&dict, "Parent",
+				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
+
 	str = type2string(element->type);
 	if (str != NULL)
 		append_entry(&dict, "Type", DBUS_TYPE_STRING, &str);
-
 	str = subtype2string(element->subtype);
 	if (str != NULL)
 		append_entry(&dict, "Subtype", DBUS_TYPE_STRING, &str);
 
-	if (element->info.driver != NULL)
-		append_entry(&dict, "Driver",
-				DBUS_TYPE_STRING, &element->info.driver);
-
-	if (element->info.vendor != NULL)
-		append_entry(&dict, "Vendor",
-				DBUS_TYPE_STRING, &element->info.vendor);
-
-	if (element->info.product != NULL)
-		append_entry(&dict, "Product",
-				DBUS_TYPE_STRING, &element->info.product);
-
 	if (element->ipv4.address != NULL)
 		append_entry(&dict, "IPv4.Address",
 				DBUS_TYPE_STRING, &element->ipv4.address);
-
 	if (element->ipv4.netmask != NULL)
 		append_entry(&dict, "IPv4.Netmask",
 				DBUS_TYPE_STRING, &element->ipv4.netmask);
-
 	if (element->ipv4.gateway != NULL)
 		append_entry(&dict, "IPv4.Gateway",
 				DBUS_TYPE_STRING, &element->ipv4.gateway);
 
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		append_property(&dict, property);
+	}
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -313,6 +322,18 @@ void connman_element_unref(struct connman_element *element)
 				g_atomic_int_get(&element->refcount) - 1);
 
 	if (g_atomic_int_dec_and_test(&element->refcount) == TRUE) {
+		GSList *list;
+
+		for (list = element->properties; list; list = list->next) {
+			struct connman_property *property = list->data;
+			if ((property->flags & CONNMAN_PROPERTY_FLAG_STATIC) &&
+					property->type == DBUS_TYPE_STRING)
+				g_free(property->value);
+			g_free(property);
+			list->data = NULL;
+		}
+		g_slist_free(element->properties);
+
 		g_free(element->ipv4.address);
 		g_free(element->ipv4.netmask);
 		g_free(element->ipv4.gateway);
@@ -320,15 +341,104 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
 		g_free(element->netdev.name);
-		g_free(element->info.driver);
-		g_free(element->info.vendor);
-		g_free(element->info.product);
 		g_free(element->path);
 		g_free(element->name);
 		g_free(element);
 	}
 }
 
+int connman_element_add_static_property(struct connman_element *element,
+				const char *name, int type, const void *value)
+{
+	struct connman_property *property;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (type != DBUS_TYPE_STRING)
+		return -EINVAL;
+
+	property = g_try_new0(struct connman_property, 1);
+	if (property == NULL)
+		return -ENOMEM;
+
+	property->flags = CONNMAN_PROPERTY_FLAG_STATIC;
+
+	property->name = g_strdup(name);
+	property->type = type;
+
+	DBG("name %s type %d value %p", name, type, value);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		property->value = g_strdup(*((const char **) value));
+		break;
+	}
+
+	element->properties = g_slist_append(element->properties, property);
+
+	return 0;
+}
+
+int connman_element_set_property(struct connman_element *element,
+			enum connman_property_type type, const void *value)
+{
+	switch (type) {
+	case CONNMAN_PROPERTY_TYPE_INVALID:
+		return -EINVAL;
+	case CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS:
+		g_free(element->ipv4.address);
+		element->ipv4.address = g_strdup(*((const char **) value));
+		break;
+	case CONNMAN_PROPERTY_TYPE_IPV4_NETMASK:
+		g_free(element->ipv4.netmask);
+		element->ipv4.netmask = g_strdup(*((const char **) value));
+		break;
+	case CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY:
+		g_free(element->ipv4.gateway);
+		element->ipv4.gateway = g_strdup(*((const char **) value));
+		break;
+	}
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	return 0;
+}
+
+int connman_element_get_value(struct connman_element *element,
+				enum connman_property_type type, void *value)
+{
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return -EINVAL;
+
+	switch (type) {
+	case CONNMAN_PROPERTY_TYPE_INVALID:
+		return -EINVAL;
+	case CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS:
+		if (element->ipv4.address == NULL)
+			return connman_element_get_value(element->parent,
+								type, value);
+		*((char **) value) = element->ipv4.address;
+		break;
+	case CONNMAN_PROPERTY_TYPE_IPV4_NETMASK:
+		if (element->ipv4.netmask == NULL)
+			return connman_element_get_value(element->parent,
+								type, value);
+		*((char **) value) = element->ipv4.netmask;
+		break;
+	case CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY:
+		if (element->ipv4.gateway == NULL)
+			return connman_element_get_value(element->parent,
+								type, value);
+		*((char **) value) = element->ipv4.gateway;
+		break;
+	}
+
+	return 0;
+}
+
 int connman_element_register(struct connman_element *element,
 					struct connman_element *parent)
 {
@@ -455,6 +565,11 @@ void connman_element_update(struct connman_element *element)
 		element->driver->update(element);
 
 	g_static_mutex_unlock(&element_mutex);
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
 }
 
 static inline void set_driver(struct connman_element *element,

commit 6ba29c1f7d994d3594d2094509a0e3a72ffd1f0b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 08:00:08 2008 +0200

    Update the D-Bus API documentation

diff --git a/doc/agent-api.txt b/doc/agent-api.txt
index 27bd3219..ff7aa53b 100644
--- a/doc/agent-api.txt
+++ b/doc/agent-api.txt
@@ -2,7 +2,7 @@ Agent hierarchy
 ***************
 
 Service name	[unique name]
-Interface name	org.freedesktop.connman.Agent
+Interface name	org.moblin.connman.Agent
 Object path	[random object]
 
 Methods		void Release()
@@ -14,4 +14,4 @@ This method will be called when the core releases the agent. This normally
 happens when the core shuts down.
 
 To get notified when the core exits, an agent should also watch out for the
-NameOwnerChanged from org.freedesktop.connman service.
+NameOwnerChanged from org.moblin.connman service.
diff --git a/doc/element-api.txt b/doc/element-api.txt
new file mode 100644
index 00000000..423f1a7b
--- /dev/null
+++ b/doc/element-api.txt
@@ -0,0 +1,50 @@
+Element hierarchy
+*****************
+
+Service name	org.moblin.connman
+Interface name	org.moblin.connman.Element
+Object path	[element object]
+
+Methods		dict GetProperties()
+
+Properties	string Type
+		string Subtype
+		string Driver
+		string Vendor
+		string Product
+
+
+Method: GetProperties
+=====================
+This method allows to retrieve all properties of an element at once. The
+properties are presented in a dictionary.
+
+Property: Type
+==============
+This property represents the main type of an element. It can have the values
+like "device", "network", "ipv4", "ipv6", "dhcp", "bootp" and "zeroconf".
+
+Property: Subtype
+=================
+This property represents the subtype of an element. In the normal case this
+is the hardware type. It can have values like "ethernet", "wifi", "wimax",
+"modem" and "bluetooth".
+
+The element system will inherit the subtype from the parent if not overwritten
+manually and so it should be present in every element.
+
+Property: Driver
+================
+This property represents the driver that is assigned to this element. This
+value will only be present in case of Device elements. On Linux system this
+is the kernel driver name.
+
+Property: Vendor
+================
+This property represent the vendor string for this element. This value is only
+present in case of a Device element. This information are taken from HAL.
+
+Property: Product
+=================
+This property represent the product string for this element. This value is only
+present in case of a Device element. This information are taken from HAL.
diff --git a/doc/interface-api.txt b/doc/interface-api.txt
deleted file mode 100644
index faee2033..00000000
--- a/doc/interface-api.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-Interface hierarchy
-*******************
-
-Service name	org.freedesktop.connman
-Interface name	org.freedesktop.connman.Interface
-Object path	[interface object]
-
-Methods		dict GetProperties()
-		string GetState()
-		uint16 GetSignal()
-		string GetPolicy()
-		void SetPolicy(string policy)
-		dict GetNetwork()
-		void SetNetwork(dict network)
-		dict GetIPv4()
-		void SetIPv4(dict ipv4)
-
-Signals		StateChanged(string state)
-		SignalChanged(uint16 signal)
-		PolicyChanged(string policy)
-		NetworkFound(dict network)
-		NetworkChanged(dict network)
-		IPv4Changed(dict ipv4)
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 0c4de41b..03b39a5c 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -1,39 +1,31 @@
 Manager hierarchy
 *****************
 
-Service name	org.freedesktop.connman
-Interface name	org.freedesktop.connman.Manager
+Service name	org.moblin.connman
+Interface name	org.moblin.connman.Manager
 Object path	/
 
-Methods		array{object} ListInterfaces()
-		string GetState()
+Methods		array{object} ListElements()
 		void RegisterAgent(object path)
 		void UnregisterAgent(object path)
 
-Signals		InterfaceAdded(object)
-		InterfaceRemoved(object)
-		StateChanged(string state)
+Signals		ElementAdded(object)
+		ElementRemoved(object)
 
 
-Method: ListInferfaces
-======================
+Method: ListElements
+====================
 This method lists all available interfaces. The return value is an array of
 object paths. Every attached network interface (eth0, wlan0 etc.) of the
 system is presented by an object path with additional interfaces on it. The
 main interface is org.freedesktop.connman.Interface.
 
-Method: GetState
-================
-This method gets the overall master state of the Internet connection. Possible
-return values are "offline" and "online". If at least one interface is
-connected it will return "online".
-
 Method: RegisterAgent
 =====================
 This method allows the user interace to register an agent. There can be only
 one agent registered at a time. The parameter of the method is the object
 path the agent has been registered for the callback method. The agent has
-to implement org.freedesktop.connman.Agent interface on this object path.
+to implement org.moblin.connman.Agent interface on this object path.
 
 Method: UnregisterAgent
 =======================
@@ -41,19 +33,14 @@ This method unregisters a previously registered agent. In case the agent
 application exits the core will automatically unregister the agent. However
 for a clean agent application it is important to call the unregister method.
 
-Signal: InterfaceAdded
-======================
-This signal is emitted every time a new interface has been found by the
+Signal: ElementAdded
+====================
+This signal is emitted every time a new element has been added by the
 core and successfully activated. The signal is also emitted on startup
 or at anytime at runtime in case of hotplug devices.
 
-Signal: InterfaceRemoved
-========================
-This signal is emitted every time an interface has been removed. This can
+Signal: ElementRemoved
+======================
+This signal is emitted every time an element has been removed. This can
 happen at any time in case of hotplug devices. When the system shuts down,
 this signal is also emitted.
-
-Signal: StateChanged
-====================
-This signal is emitted every time the master state changes. Possible values
-are "offline" and "online" and reflect the state of the Internet connection.

commit a33aac1132ed5061f7ce694a318d1b46a7e3a932
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 07:04:28 2008 +0200

    Use read/write lock for driver list instead of a mutex

diff --git a/src/element.c b/src/element.c
index 93ae5d19..fa06da07 100644
--- a/src/element.c
+++ b/src/element.c
@@ -32,7 +32,7 @@
 
 static DBusConnection *connection;
 
-static GStaticMutex driver_mutex = G_STATIC_MUTEX_INIT;
+static GStaticRWLock driver_lock = G_STATIC_RW_LOCK_INIT;
 static GSList *driver_list = NULL;
 static GThreadPool *driver_thread;
 
@@ -247,10 +247,10 @@ int connman_driver_register(struct connman_driver *driver)
 	if (!driver->probe)
 		return -EINVAL;
 
-	g_static_mutex_lock(&driver_mutex);
+	g_static_rw_lock_writer_lock(&driver_lock);
 	driver_list = g_slist_insert_sorted(driver_list, driver,
 							compare_priority);
-	g_static_mutex_unlock(&driver_mutex);
+	g_static_rw_lock_writer_unlock(&driver_lock);
 
 	g_thread_pool_push(driver_thread, driver, NULL);
 
@@ -282,9 +282,9 @@ void connman_driver_unregister(struct connman_driver *driver)
 							remove_driver, driver);
 	g_static_mutex_unlock(&element_mutex);
 
-	g_static_mutex_lock(&driver_mutex);
+	g_static_rw_lock_writer_lock(&driver_lock);
 	driver_list = g_slist_remove(driver_list, driver);
-	g_static_mutex_unlock(&driver_mutex);
+	g_static_rw_lock_writer_unlock(&driver_lock);
 }
 
 struct connman_element *connman_element_create(void)
@@ -633,7 +633,7 @@ static void element_probe(gpointer data, gpointer user_data)
 	if (connman_element_ref(element) == NULL)
 		return;
 
-	g_static_mutex_lock(&driver_mutex);
+	g_static_rw_lock_reader_lock(&driver_lock);
 
 	for (list = driver_list; list; list = list->next) {
 		struct connman_driver *driver = list->data;
@@ -649,7 +649,7 @@ static void element_probe(gpointer data, gpointer user_data)
 		set_driver(element, NULL);
 	}
 
-	g_static_mutex_unlock(&driver_mutex);
+	g_static_rw_lock_reader_unlock(&driver_lock);
 
 	connman_element_unref(element);
 }

commit 2a62d8af2e38f6ad24bce04219d170e711a35bc0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 07:14:57 2008 +0200

    Fix wrong EXTRA_DIST statements

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 3155148a..62aa9bce 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,4 @@
 
-EXTRA_DIST = manager-api.txt interface-api.txt agent-api.txt plugin-api.txt
+EXTRA_DIST = manager-api.txt element-api.txt agent-api.txt plugin-api.txt
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/Makefile.am b/test/Makefile.am
index 332c3bdb..9a05de97 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,5 +1,6 @@
 
-EXTRA_DIST = list-interfaces start-scanning select-network simple-agent \
+EXTRA_DIST = list-elements monitor-elements \
+		start-scanning select-network simple-agent \
 		get-state show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in

commit 24af3114bab218b45bddfa0c279bd6380ff87b2c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 07:15:34 2008 +0200

    Install the connman.pc for external plugin development

diff --git a/Makefile.am b/Makefile.am
index 071be42c..fe127cd5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -3,9 +3,9 @@ SUBDIRS = include src doc test plugins scripts
 
 pkgconfigdir = $(libdir)/pkgconfig
 
-noinst_DATA = connman.pc
+pkgconfig_DATA = connman.pc
 
-DISTCLEANFILES = $(noinst_DATA)
+DISTCLEANFILES = $(pkgconfig_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \

commit 7b6b9ae35896904a3eaf95b09ab81bf448c2f4ac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 07:39:11 2008 +0200

    Don't load plugins that have lib prefix

diff --git a/src/plugin.c b/src/plugin.c
index 7f8b16c4..d2ee80f6 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -69,7 +69,8 @@ static void load_plugins(const gchar *path)
 			GModule *module;
 			struct connman_plugin_desc *desc;
 
-			if (g_str_has_suffix(file, ".so") == FALSE)
+			if (g_str_has_prefix(file, "lib") == TRUE ||
+					g_str_has_suffix(file, ".so") == FALSE)
 				continue;
 
 			filename = g_build_filename(path, file, NULL);

commit 75a6e88c0ba882f357a083b06ac8ba1436a717bb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 08:13:57 2008 +0200

    Fix removing elements from list

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 03c52d26..8905223c 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -62,23 +62,28 @@ static void create_element(struct connman_element *parent,
 
 static void remove_elements(struct connman_element *parent)
 {
-	GSList *list;
+	GSList *list = element_list;
 
 	DBG("parent %p name %s", parent, parent->name);
 
 	g_static_mutex_lock(&element_mutex);
 
-	for (list = element_list; list; list = list->next) {
+	while (list) {
+		GSList *next = list->next;
 		struct connman_element *element = list->data;
 
-		if (element->netdev.index != parent->netdev.index)
+		if (element->netdev.index != parent->netdev.index) {
+			list = next;
 			continue;
+		}
 
-		element_list = g_slist_remove(element_list, element);
+		element_list = g_slist_delete_link(element_list, list);
 
 		connman_element_unregister(element);
 
 		connman_element_unref(element);
+
+		list = next;
 	}
 
 	g_static_mutex_unlock(&element_mutex);

commit 7ce008be4d80ac8100ab6abdbe8d8b715fa85f96
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 08:29:10 2008 +0200

    Don't unregister elements that are not valid

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 18022596..3a06e3ea 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -216,9 +216,11 @@ static void dhclient_remove(struct connman_element *element)
 	task_list = g_slist_remove(task_list, task);
 	g_static_mutex_unlock(&task_mutex);
 
-	connman_element_unregister(task->child);
-	connman_element_unref(task->child);
-	task->child = NULL;
+	if (task->child != NULL) {
+		connman_element_unregister(task->child);
+		connman_element_unref(task->child);
+		task->child = NULL;
+	}
 
 	kill_task(task);
 }

commit c29260e12d40064a0b406ffbf5b9013a23a35f1a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 09:40:20 2008 +0200

    Deal with another libgdbus API change

diff --git a/src/iface.c b/src/iface.c
index ea52673d..e5b88fa7 100644
--- a/src/iface.c
+++ b/src/iface.c
@@ -1502,7 +1502,7 @@ int __connman_iface_init(DBusConnection *conn, const char *interface)
 
 	hal_init(connection);
 
-	hal_watch = g_dbus_add_watch(connection, "org.freedesktop.Hal",
+	hal_watch = g_dbus_add_service_watch(connection, "org.freedesktop.Hal",
 				hal_init, hal_cleanup, connection, NULL);
 
 	return 0;

commit ec4ebd543107fc705d36a7f7b085bd8b6479cf39
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 09:40:59 2008 +0200

    Use new signal callback function from libgdbus

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 167878b3..6d41fb25 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -23,7 +23,7 @@
 #include <config.h>
 #endif
 
-#include <dbus/dbus.h>
+#include <gdbus.h>
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
@@ -58,12 +58,20 @@ static void create_element(DBusConnection *conn, const char *path)
 	g_static_mutex_unlock(&element_mutex);
 }
 
-static DBusHandlerResult bluetooth_filter(DBusConnection *conn,
-						DBusMessage *msg, void *data)
+static gboolean bluetooth_signal(DBusConnection *conn,
+					DBusMessage *msg, void *data)
 {
+	const char *sender, *interface, *member;
+
 	DBG("conn %p msg %p", conn, msg);
 
-	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	sender = dbus_message_get_sender(msg);
+	interface = dbus_message_get_interface(msg);
+	member = dbus_message_get_member(msg);
+
+	DBG("sender %s name %s.%s", sender, interface, member);
+
+	return TRUE;
 }
 
 static void list_adapters(DBusConnection *conn)
@@ -122,26 +130,18 @@ static struct connman_driver bluetooth_driver = {
 };
 
 static DBusConnection *connection;
+static guint signal;
 
 static int bluetooth_init(void)
 {
-	gchar *match;
 	int err;
 
 	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 	if (connection == NULL)
 		return -EIO;
 
-	if (dbus_connection_add_filter(connection, bluetooth_filter,
-						NULL, NULL) == FALSE)
-		connman_error("Can't add D-Bus filter for Bluetooth");
-
-	match = g_strdup_printf("sender=%s,interface=%s", "org.bluez",
-							"org.bluez.Manager");
-
-	dbus_bus_add_match(connection, match, NULL);
-
-	g_free(match);
+	signal = g_dbus_add_signal_watch(connection, "sender=org.bluez",
+						bluetooth_signal, NULL, NULL);
 
 	err = connman_driver_register(&bluetooth_driver);
 	if (err < 0) {
@@ -158,6 +158,8 @@ static void bluetooth_exit(void)
 {
 	connman_driver_unregister(&bluetooth_driver);
 
+	g_dbus_remove_watch(connection, signal);
+
 	dbus_connection_unref(connection);
 }
 

commit 5773f1d9aead50d0e558445cca965d83c7f38890
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 01:46:17 2008 +0200

    Use read/write lock for element list instead of a mutex

diff --git a/src/element.c b/src/element.c
index fa06da07..0f46d358 100644
--- a/src/element.c
+++ b/src/element.c
@@ -36,7 +36,7 @@ static GStaticRWLock driver_lock = G_STATIC_RW_LOCK_INIT;
 static GSList *driver_list = NULL;
 static GThreadPool *driver_thread;
 
-static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
+static GStaticRWLock element_lock = G_STATIC_RW_LOCK_INIT;
 static GNode *element_root = NULL;
 static GThreadPool *element_thread;
 
@@ -223,10 +223,10 @@ void __connman_element_list(enum connman_element_type type,
 
 	DBG("");
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_reader_lock(&element_lock);
 	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
 							append_path, &filter);
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -277,10 +277,10 @@ void connman_driver_unregister(struct connman_driver *driver)
 {
 	DBG("driver %p name %s", driver, driver->name);
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_reader_lock(&element_lock);
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							remove_driver, driver);
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_reader_unlock(&element_lock);
 
 	g_static_rw_lock_writer_lock(&driver_lock);
 	driver_list = g_slist_remove(driver_list, driver);
@@ -450,7 +450,7 @@ int connman_element_register(struct connman_element *element,
 	if (connman_element_ref(element) == NULL)
 		return -1;
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_writer_lock(&element_lock);
 
 	if (parent) {
 		node = g_node_find(element_root, G_PRE_ORDER,
@@ -493,7 +493,7 @@ int connman_element_register(struct connman_element *element,
 
 	g_node_append_data(node, element);
 
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_writer_unlock(&element_lock);
 
 	g_dbus_register_interface(connection, element->path,
 					CONNMAN_ELEMENT_INTERFACE,
@@ -536,7 +536,7 @@ void connman_element_unregister(struct connman_element *element)
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_ELEMENT_INTERFACE);
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_writer_lock(&element_lock);
 
 	if (element->driver) {
 		if (element->driver->remove)
@@ -550,7 +550,7 @@ void connman_element_unregister(struct connman_element *element)
 		g_node_destroy(node);
 	}
 
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_writer_unlock(&element_lock);
 
 	connman_element_unref(element);
 }
@@ -559,12 +559,12 @@ void connman_element_update(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_reader_lock(&element_lock);
 
 	if (element->driver && element->driver->update)
 		element->driver->update(element);
 
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_reader_unlock(&element_lock);
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
@@ -575,9 +575,9 @@ void connman_element_update(struct connman_element *element)
 static inline void set_driver(struct connman_element *element,
 						struct connman_driver *driver)
 {
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_reader_lock(&element_lock);
 	element->driver = driver;
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
 static gboolean match_driver(struct connman_element *element,
@@ -617,10 +617,10 @@ static void driver_probe(gpointer data, gpointer user_data)
 
 	DBG("driver %p name %s", driver, driver->name);
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_reader_lock(&element_lock);
 	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
 							probe_driver, driver);
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
 static void element_probe(gpointer data, gpointer user_data)
@@ -664,7 +664,7 @@ int __connman_element_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -EIO;
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_writer_lock(&element_lock);
 
 	element = connman_element_create();
 
@@ -674,7 +674,7 @@ int __connman_element_init(DBusConnection *conn)
 
 	element_root = g_node_new(element);
 
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_writer_unlock(&element_lock);
 
 	element_thread = g_thread_pool_new(element_probe, NULL, 1, FALSE, NULL);
 
@@ -713,7 +713,7 @@ void __connman_element_cleanup(void)
 
 	g_thread_pool_free(element_thread, TRUE, TRUE);
 
-	g_static_mutex_lock(&element_mutex);
+	g_static_rw_lock_writer_lock(&element_lock);
 
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_node, NULL);
@@ -721,7 +721,7 @@ void __connman_element_cleanup(void)
 	g_node_destroy(element_root);
 	element_root = NULL;
 
-	g_static_mutex_unlock(&element_mutex);
+	g_static_rw_lock_writer_unlock(&element_lock);
 
 	dbus_connection_unref(connection);
 }

commit 849af5e83ad86a2e9756465c7487a62a133a6600
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 02:30:12 2008 +0200

    First steps into wpa_supplicant integration

diff --git a/plugins/wifi.c b/plugins/wifi.c
index b31fa9f2..6ab59406 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -23,20 +23,300 @@
 #include <config.h>
 #endif
 
+#include <dbus/dbus.h>
+
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/log.h>
 
+static DBusConnection *connection;
+
+#define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
+
+enum supplicant_state {
+	STATE_INACTIVE,
+	STATE_SCANNING,
+	STATE_ASSOCIATING,
+	STATE_ASSOCIATED,
+	STATE_4WAY_HANDSHAKE,
+	STATE_GROUP_HANDSHAKE,
+	STATE_COMPLETED,
+	STATE_DISCONNECTED,
+};
+
+struct supplicant_task {
+	int ifindex;
+	gchar *ifname;
+	enum supplicant_state state;
+	gchar *path;
+	gboolean created;
+};
+
+static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
+static GSList *task_list = NULL;
+
+static struct supplicant_task *find_task_by_index(int index)
+{
+	GSList *list;
+
+	for (list = task_list; list; list = list->next) {
+		struct supplicant_task *task = list->data;
+
+		if (task->ifindex == index)
+			return task;
+	}
+
+	return NULL;
+}
+
+static int get_interface(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "getInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to get interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for interface");
+		dbus_message_unref(reply);
+		return -EIO;
+	}
+
+	DBG("path %s", path);
+
+	task->path = g_strdup(path);
+	task->created = FALSE;
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int add_interface(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "addInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to add interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for interface");
+		dbus_message_unref(reply);
+		return -EIO;
+	}
+
+	DBG("path %s", path);
+
+	task->path = g_strdup(path);
+	task->created = TRUE;
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int remove_interface(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	if (task->created == FALSE)
+		return -EINVAL;
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "removeInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->path,
+							DBUS_TYPE_INVALID);
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to remove interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	g_free(task->path);
+	task->path = NULL;
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
+static int initiate_scan(struct supplicant_task *task)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+					SUPPLICANT_INTF ".Interface", "scan");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to initiate scan");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_message_unref(reply);
+
+	return 0;
+}
+
 static int wifi_probe(struct connman_element *element)
 {
+	struct supplicant_task *task;
+	int err;
+
 	DBG("element %p name %s", element, element->name);
 
+	task = g_try_new0(struct supplicant_task, 1);
+	if (task == NULL)
+		return -ENOMEM;
+
+	task->ifindex = element->netdev.index;
+	task->ifname = g_strdup(element->netdev.name);
+
+	if (task->ifname == NULL) {
+		g_free(task);
+		return -ENOMEM;
+	}
+
+	task->created = FALSE;
+	task->state = STATE_INACTIVE;
+
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_append(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
+
+	err = get_interface(task);
+	if (err < 0) {
+		err = add_interface(task);
+		if (err < 0) {
+			g_free(task);
+			return err;
+		}
+	}
+
+	initiate_scan(task);
+
 	return 0;
 }
 
 static void wifi_remove(struct connman_element *element)
 {
+	struct supplicant_task *task;
+
 	DBG("element %p name %s", element, element->name);
+
+	g_static_mutex_lock(&task_mutex);
+	task = find_task_by_index(element->netdev.index);
+	g_static_mutex_unlock(&task_mutex);
+
+	if (task == NULL)
+		return;
+
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_remove(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
+
+	remove_interface(task);
+
+	g_free(task->ifname);
+	g_free(task);
 }
 
 static struct connman_driver wifi_driver = {
@@ -49,12 +329,26 @@ static struct connman_driver wifi_driver = {
 
 static int wifi_init(void)
 {
-	return connman_driver_register(&wifi_driver);
+	int err;
+
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (connection == NULL)
+		return -EIO;
+
+	err = connman_driver_register(&wifi_driver);
+	if (err < 0) {
+		dbus_connection_unref(connection);
+		return err;
+	}
+
+	return 0;
 }
 
 static void wifi_exit(void)
 {
 	connman_driver_unregister(&wifi_driver);
+
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("WiFi", "WiFi interface plugin", VERSION,

commit f6756e60371e5942db40c2a7aa95f60f781717f8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 08:48:21 2008 +0200

    Add support for detecting modem devices

diff --git a/plugins/hal.c b/plugins/hal.c
index 467e5d32..3b990c3d 100644
--- a/plugins/hal.c
+++ b/plugins/hal.c
@@ -36,6 +36,7 @@ static struct {
 } capabilities[] = {
 	{ "net.80203", CONNMAN_ELEMENT_SUBTYPE_ETHERNET },
 	{ "net.80211", CONNMAN_ELEMENT_SUBTYPE_WIFI     },
+	{ "modem",     CONNMAN_ELEMENT_SUBTYPE_MODEM    },
 	{ }
 };
 
@@ -63,7 +64,8 @@ static void device_info(LibHalContext *ctx, const char *udi,
 					"Driver", DBUS_TYPE_STRING, &value);
 	}
 
-	if (g_str_equal(subsys, "net") == TRUE) {
+	if (g_str_equal(subsys, "net") == TRUE ||
+					g_str_equal(subsys, "tty") == TRUE) {
 		value = libhal_device_get_property_string(ctx, parent,
 							"info.vendor", NULL);
 		if (value != NULL)
@@ -89,6 +91,14 @@ static void device_netdev(LibHalContext *ctx, const char *udi,
 		element->netdev.name = libhal_device_get_property_string(ctx,
 						udi, "net.interface", NULL);
 	}
+
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_MODEM) {
+		element->netdev.index = libhal_device_get_property_int(ctx,
+						udi, "serial.port", NULL);
+
+		element->netdev.name = libhal_device_get_property_string(ctx,
+						udi, "serial.device", NULL);
+	}
 }
 
 static void create_element(LibHalContext *ctx, const char *udi,

commit 90edbef31b1b90d8591b0d1e19dc2151f304a781
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 2 20:49:41 2008 +0200

    Add priority property to elements

diff --git a/include/element.h b/include/element.h
index 1d144246..e5843389 100644
--- a/include/element.h
+++ b/include/element.h
@@ -70,6 +70,7 @@ struct connman_element {
 	enum connman_element_type type;
 	enum connman_element_subtype subtype;
 	enum connman_element_state state;
+	guint16 priority;
 
 	struct connman_element *parent;
 
diff --git a/src/element.c b/src/element.c
index 0f46d358..c21b505d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -106,6 +106,9 @@ static void append_entry(DBusMessageIter *dict,
 	case DBUS_TYPE_UINT16:
 		signature = DBUS_TYPE_UINT16_AS_STRING;
 		break;
+	case DBUS_TYPE_UINT32:
+		signature = DBUS_TYPE_UINT32_AS_STRING;
+		break;
 	case DBUS_TYPE_OBJECT_PATH:
 		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
 		break;
@@ -165,6 +168,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	if (str != NULL)
 		append_entry(&dict, "Subtype", DBUS_TYPE_STRING, &str);
 
+	if (element->priority > 0)
+		append_entry(&dict, "Priority",
+				DBUS_TYPE_UINT16, &element->priority);
+
 	if (element->ipv4.address != NULL)
 		append_entry(&dict, "IPv4.Address",
 				DBUS_TYPE_STRING, &element->ipv4.address);

commit a76452265e0d73fed9d2ad591863b231df30292d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 2 20:53:11 2008 +0200

    Add skeleton for new storage support using SQLite3

diff --git a/configure.in b/configure.in
index 042f85b8..8abdd137 100644
--- a/configure.in
+++ b/configure.in
@@ -74,6 +74,11 @@ PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
+PKG_CHECK_MODULES(SQLITE, sqlite3, dummy=yes,
+				AC_MSG_ERROR(sqlite3 is required))
+AC_SUBST(SQLITE_CFLAGS)
+AC_SUBST(SQLITE_LIBS)
+
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
 			test/Makefile plugins/Makefile scripts/Makefile
 			scripts/fi.epitest.hostap.WPASupplicant.service
diff --git a/src/Makefile.am b/src/Makefile.am
index 1ab7d7a7..fb5d90cf 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,11 +12,12 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c plugin.c element.c \
-						manager.c agent.c \
+					storage.c manager.c agent.c \
 			iface.c iface-storage.c iface-helper.c iface-inet.c \
 					network.c rtnl.c dhcp.c resolver.c
 
-connmand_LDADD = @HAL_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
+connmand_LDADD = @HAL_LIBS@ @SQLITE_LIBS@ \
+			@GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
  
 statedir = $(localstatedir)/run/connman
 
@@ -28,7 +29,8 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @HAL_CFLAGS@ \
+AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ \
+				@SQLITE_CFLAGS@ @HAL_CFLAGS@ \
 			-DSTATEDIR=\""$(statedir)"\" \
 			-DSTORAGEDIR=\""$(storagedir)\"" \
 			-DPLUGINDIR=\""$(plugindir)"\"
diff --git a/src/connman.h b/src/connman.h
index 05bfe362..5f642861 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -27,6 +27,9 @@
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
 
+int __connman_storage_init(void);
+void __connman_storage_cleanup(void);
+
 int __connman_manager_init(DBusConnection *conn, gboolean compat);
 void __connman_manager_cleanup(void);
 
@@ -58,6 +61,9 @@ void __connman_element_list(enum connman_element_type type,
 const char *__connman_element_type2string(enum connman_element_type type);
 const char *__connman_element_subtype2string(enum connman_element_subtype type);
 
+int __connman_element_load(struct connman_element *element);
+int __connman_element_store(struct connman_element *element);
+
 #include <connman/iface.h>
 
 int __connman_iface_init(DBusConnection *conn, const char *interface);
diff --git a/src/element.c b/src/element.c
index c21b505d..58ba06ba 100644
--- a/src/element.c
+++ b/src/element.c
@@ -457,6 +457,8 @@ int connman_element_register(struct connman_element *element,
 	if (connman_element_ref(element) == NULL)
 		return -1;
 
+	__connman_element_load(element);
+
 	g_static_rw_lock_writer_lock(&element_lock);
 
 	if (parent) {
@@ -502,6 +504,8 @@ int connman_element_register(struct connman_element *element,
 
 	g_static_rw_lock_writer_unlock(&element_lock);
 
+	__connman_element_store(element);
+
 	g_dbus_register_interface(connection, element->path,
 					CONNMAN_ELEMENT_INTERFACE,
 					element_methods, NULL, NULL,
diff --git a/src/main.c b/src/main.c
index 10f9fe6d..9e237cc4 100644
--- a/src/main.c
+++ b/src/main.c
@@ -127,6 +127,8 @@ int main(int argc, char *argv[])
 
 	__connman_log_init(option_detach, option_debug);
 
+	__connman_storage_init();
+
 	__connman_element_init(conn);
 
 	__connman_agent_init(conn);
@@ -152,6 +154,8 @@ int main(int argc, char *argv[])
 
 	__connman_element_cleanup();
 
+	__connman_storage_cleanup();
+
 	__connman_log_cleanup();
 
 	g_dbus_cleanup_connection(conn);
diff --git a/src/storage.c b/src/storage.c
new file mode 100644
index 00000000..e093dea3
--- /dev/null
+++ b/src/storage.c
@@ -0,0 +1,111 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sqlite3.h>
+
+#include "connman.h"
+
+static sqlite3 *db = NULL;
+
+static int create_tables(void)
+{
+	char *msg;
+	int err;
+
+	DBG("");
+
+	err = sqlite3_exec(db, "CREATE TABLE properties ("
+					"element TEXT NOT NULL,"
+					"name TEXT NOT NULL,"
+					"value TEXT NOT NULL,"
+					"PRIMARY KEY(element, name))",
+							NULL, NULL, &msg);
+
+	if (err != SQLITE_OK) {
+		connman_error("SQL error: %s", msg);
+		sqlite3_free(msg);
+		return -1;
+	}
+
+	return 0;
+}
+
+int __connman_storage_init(void)
+{
+	int err;
+
+	DBG("");
+
+#if 0
+	if (!sqlite3_threadsafe()) {
+		connman_error("SQLite is missing thread support");
+		return -1;
+	}
+#endif
+
+	err = sqlite3_open(STORAGEDIR "/config.db", &db);
+	if (err != SQLITE_OK) {
+		connman_error("Can't open database: %s", sqlite3_errmsg(db));
+		sqlite3_close(db);
+		return -1;
+	}
+
+	create_tables();
+
+	return 0;
+}
+
+void __connman_storage_cleanup(void)
+{
+	DBG("");
+
+	sqlite3_close(db);
+}
+
+int __connman_element_load(struct connman_element *element)
+{
+	return 0;
+}
+
+int __connman_element_store(struct connman_element *element)
+{
+	char *sql, *msg;
+
+	DBG("");
+
+	if (element->priority > 0) {
+		sql = g_strdup_printf("INSERT INTO properties "
+						"VALUES ('%s','%s','%d')",
+						element->path, "Priority",
+							element->priority);
+
+		if (sqlite3_exec(db, sql, NULL, NULL, &msg) != SQLITE_OK) {
+			connman_error("SQL error: %s", msg);
+			sqlite3_free(msg);
+		}
+	}
+
+	return 0;
+}

commit f19597bf9dc5643ab290cd717d759038d7f29e48
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 2 20:57:27 2008 +0200

    Disable compilation of obsoleted code

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 4084410b..68ea95ad 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -4,8 +4,6 @@ plugindir = $(libdir)/connman/plugins
 plugin_LTLIBRARIES = hal.la ethernet.la wifi.la bluetooth.la \
 						dhclient.la ipv4.la
 
-noinst_LTLIBRARIES = 80203.la 80211.la resolvconf.la
-
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
 hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
@@ -22,12 +20,6 @@ dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 
 ipv4_la_SOURCES = ipv4.c
 
-80203_la_SOURCES = 80203.c
-
-80211_la_SOURCES = 80211.c supplicant.h supplicant.c
-
-resolvconf_la_SOURCES = resolvconf.c
-
 AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
 
 statedir = $(localstatedir)/run/connman
diff --git a/src/Makefile.am b/src/Makefile.am
index fb5d90cf..af26d42e 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,12 +12,9 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c plugin.c element.c \
-					storage.c manager.c agent.c \
-			iface.c iface-storage.c iface-helper.c iface-inet.c \
-					network.c rtnl.c dhcp.c resolver.c
+					storage.c manager.c agent.c
 
-connmand_LDADD = @HAL_LIBS@ @SQLITE_LIBS@ \
-			@GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
+connmand_LDADD = @SQLITE_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
  
 statedir = $(localstatedir)/run/connman
 
@@ -29,8 +26,7 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ \
-				@SQLITE_CFLAGS@ @HAL_CFLAGS@ \
+AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @SQLITE_CFLAGS@ \
 			-DSTATEDIR=\""$(statedir)"\" \
 			-DSTORAGEDIR=\""$(storagedir)\"" \
 			-DPLUGINDIR=\""$(plugindir)"\"

commit e5214a661c18b16040393d5900962f1ac6e76d2e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 03:14:33 2008 +0200

    Only export external functions when building daemon

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 68ea95ad..37ee8622 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -20,7 +20,8 @@ dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 
 ipv4_la_SOURCES = ipv4.c
 
-AM_LDFLAGS = -module -avoid-version -export-symbols-regex connman_plugin_desc
+AM_LDFLAGS = -no-undefined -module -avoid-version \
+				-export-symbols-regex connman_plugin_desc
 
 statedir = $(localstatedir)/run/connman
 
diff --git a/src/Makefile.am b/src/Makefile.am
index af26d42e..a1a7dac8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -15,7 +15,13 @@ connmand_SOURCES = main.c connman.h log.c plugin.c element.c \
 					storage.c manager.c agent.c
 
 connmand_LDADD = @SQLITE_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
- 
+
+connmand_LDFLAGS = -Wl,--version-script=connman.ver
+
+connmand_DEPENDENCIES = connman.ver
+
+CLEANFILES = connman.ver connman.exp
+
 statedir = $(localstatedir)/run/connman
 
 storagedir = $(localstatedir)/lib/connman
@@ -36,3 +42,11 @@ INCLUDES = -I$(top_builddir)/include
 EXTRA_DIST = $(dbus_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in
+
+connman.exp:
+	nm -B *.o | awk '{ print $$3 }' | sort -u | grep -E -e '^connman_' > $@
+
+connman.ver: connman.exp
+	echo "{ global:" > $@
+	cat $< | sed -e "s/\(.*\)/\1;/" >> $@
+	echo "local: *; };" >> $@

commit 5ba85251a318e3c28e723264349698e4ed327e79
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 08:07:09 2008 +0200

    Add the generated symbol lists to ignored files

diff --git a/.gitignore b/.gitignore
index 722951ea..c9a29fbc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -24,6 +24,8 @@ autom4te.cache
 connman.pc
 include/connman
 src/connmand
+src/connman.exp
+src/connman.ver
 src/connman.service
 scripts/connman
 scripts/dhclient-script

commit 016cca4c6be704b306db9551c1f7cb2a91348938
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 09:46:23 2008 +0200

    Rewrite supplicant support for new element infrastructure

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 37ee8622..66daf5d9 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -10,7 +10,7 @@ hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
 
 ethernet_la_SOURCES = ethernet.c
 
-wifi_la_SOURCES = wifi.c
+wifi_la_SOURCES = wifi.c supplicant.h supplicant.c
 
 bluetooth_la_SOURCES = bluetooth.c
 
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index cba93cd9..d387c954 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -23,23 +23,17 @@
 #include <config.h>
 #endif
 
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <net/if.h>
-
+#include <string.h>
 #include <dbus/dbus.h>
-#include <gdbus.h>
 
 #include <connman/log.h>
 
 #include "supplicant.h"
 
+#define IEEE80211_CAP_ESS       0x0001
+#define IEEE80211_CAP_IBSS      0x0002
+#define IEEE80211_CAP_PRIVACY   0x0010
+
 enum supplicant_state {
 	STATE_INACTIVE,
 	STATE_SCANNING,
@@ -55,36 +49,25 @@ struct supplicant_task {
 	DBusConnection *conn;
 	int ifindex;
 	gchar *ifname;
-	struct connman_iface *iface;
+	struct connman_element *element;
+	struct supplicant_callback *callback;
 	gchar *path;
 	gboolean created;
 	gchar *network;
 	enum supplicant_state state;
 };
 
-static GSList *tasks = NULL;
+static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
+static GSList *task_list = NULL;
 
-struct supplicant_ap {
-	gchar *identifier;
-	GByteArray *ssid;
-	guint capabilities;
-	gboolean has_wep;
-	gboolean has_wpa;
-	gboolean has_rsn;
-};
-
-#define IEEE80211_CAP_ESS       0x0001
-#define IEEE80211_CAP_IBSS      0x0002
-#define IEEE80211_CAP_PRIVACY   0x0010
-
-static struct supplicant_task *find_task(int ifindex)
+static struct supplicant_task *find_task_by_index(int index)
 {
 	GSList *list;
 
-	for (list = tasks; list; list = list->next) {
+	for (list = task_list; list; list = list->next) {
 		struct supplicant_task *task = list->data;
 
-		if (task->ifindex == ifindex) 
+		if (task->ifindex == index)
 			return task;
 	}
 
@@ -606,7 +589,8 @@ static int initiate_scan(struct supplicant_task *task)
 	return 0;
 }
 
-static void extract_ssid(struct supplicant_ap *ap, DBusMessageIter *value)
+static void extract_ssid(struct supplicant_network *network,
+						DBusMessageIter *value)
 {
 	DBusMessageIter array;
 	unsigned char *ssid;
@@ -615,10 +599,11 @@ static void extract_ssid(struct supplicant_ap *ap, DBusMessageIter *value)
 	dbus_message_iter_recurse(value, &array);
 	dbus_message_iter_get_fixed_array(&array, &ssid, &ssid_len);
 
-	ap->identifier = g_strdup((char *) ssid);
+	network->identifier = g_strdup((char *) ssid);
 }
 
-static void extract_wpaie(struct supplicant_ap *ap, DBusMessageIter *value)
+static void extract_wpaie(struct supplicant_network *network,
+						DBusMessageIter *value)
 {
 	DBusMessageIter array;
 	unsigned char *ie;
@@ -628,10 +613,11 @@ static void extract_wpaie(struct supplicant_ap *ap, DBusMessageIter *value)
 	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
 
 	if (ie_len > 0)
-		ap->has_wpa = TRUE;
+		network->has_wpa = TRUE;
 }
 
-static void extract_rsnie(struct supplicant_ap *ap, DBusMessageIter *value)
+static void extract_rsnie(struct supplicant_network *network,
+						DBusMessageIter *value)
 {
 	DBusMessageIter array;
 	unsigned char *ie;
@@ -641,31 +627,30 @@ static void extract_rsnie(struct supplicant_ap *ap, DBusMessageIter *value)
 	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
 
 	if (ie_len > 0)
-		ap->has_rsn = TRUE;
+		network->has_rsn = TRUE;
 }
 
-static void extract_capabilites(struct supplicant_ap *ap,
+static void extract_capabilites(struct supplicant_network *network,
 						DBusMessageIter *value)
 {
 	guint capabilities;
 
 	dbus_message_iter_get_basic(value, &capabilities);
 
-	ap->capabilities = capabilities;
+	network->capabilities = capabilities;
 
 	if (capabilities & IEEE80211_CAP_PRIVACY)
-		ap->has_wep = TRUE;
+		network->has_wep = TRUE;
 }
 
 static int parse_network_properties(struct supplicant_task *task,
 							DBusMessage *message)
 {
 	DBusMessageIter array, dict;
-	struct supplicant_ap *ap;
-	int security = 0;
+	struct supplicant_network *network;
 
-	ap = g_try_new0(struct supplicant_ap, 1);
-	if (ap == NULL)
+	network = g_try_new0(struct supplicant_network, 1);
+	if (network == NULL)
 		return -ENOMEM;
 
 	dbus_message_iter_init(message, &array);
@@ -687,28 +672,21 @@ static int parse_network_properties(struct supplicant_task *task,
 		//dbus_message_iter_get_basic(&value, &val);
 
 		if (g_str_equal(key, "ssid") == TRUE)
-			extract_ssid(ap, &value);
+			extract_ssid(network, &value);
 		else if (g_str_equal(key, "wpaie") == TRUE)
-			extract_wpaie(ap, &value);
+			extract_wpaie(network, &value);
 		else if (g_str_equal(key, "rsnie") == TRUE)
-			extract_rsnie(ap, &value);
+			extract_rsnie(network, &value);
 		else if (g_str_equal(key, "capabilities") == TRUE)
-			extract_capabilites(ap, &value);
+			extract_capabilites(network, &value);
 
 		dbus_message_iter_next(&dict);
 	}
 
-	if (ap->has_wep)
-		security |= 0x01;
-	if (ap->has_wpa)
-		security |= 0x02;
-	if (ap->has_rsn)
-		security |= 0x04;
+	if (task->callback && task->callback->scan_result)
+		task->callback->scan_result(task->element, network);
 
-	connman_iface_indicate_station(task->iface,
-					ap->identifier, 25, security);
-
-	g_free(ap);
+	g_free(network);
 
 	return 0;
 }
@@ -843,10 +821,10 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 
 	switch (task->state) {
 	case STATE_COMPLETED:
-		connman_iface_indicate_carrier_on(task->iface);
+		/* carrier on */
 		break;
 	case STATE_DISCONNECTED:
-		connman_iface_indicate_carrier_off(task->iface);
+		/* carrier off */
 		break;
 	default:
 		break;
@@ -931,35 +909,22 @@ static int remove_filter(struct supplicant_task *task)
 	return 0;
 }
 
-int __supplicant_start(struct connman_iface *iface)
+int __supplicant_start(struct connman_element *element,
+					struct supplicant_callback *callback)
 {
-	struct ifreq ifr;
 	struct supplicant_task *task;
-	int sk, err;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return -EIO;
+	int err;
 
-	DBG("interface %s", ifr.ifr_name);
+	DBG("element %p name %s", element, element->name);
 
 	task = g_try_new0(struct supplicant_task, 1);
 	if (task == NULL)
 		return -ENOMEM;
 
-	task->ifindex = iface->index;
-	task->ifname = g_strdup(ifr.ifr_name);
-	task->iface = iface;
+	task->ifindex = element->netdev.index;
+	task->ifname = g_strdup(element->netdev.name);
+	task->element = element;
+	task->callback = callback;
 
 	if (task->ifname == NULL) {
 		g_free(task);
@@ -973,6 +938,11 @@ int __supplicant_start(struct connman_iface *iface)
 	}
 
 	task->created = FALSE;
+	task->state = STATE_INACTIVE;
+
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_append(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
 
 	err = get_interface(task);
 	if (err < 0) {
@@ -983,10 +953,6 @@ int __supplicant_start(struct connman_iface *iface)
 		}
 	}
 
-	task->state = STATE_INACTIVE;
-
-	tasks = g_slist_append(tasks, task);
-
 	add_filter(task);
 
 	set_ap_scan(task);
@@ -994,17 +960,19 @@ int __supplicant_start(struct connman_iface *iface)
 	return 0;
 }
 
-int __supplicant_stop(struct connman_iface *iface)
+int __supplicant_stop(struct connman_element *element)
 {
 	struct supplicant_task *task;
 
-	task = find_task(iface->index);
+	DBG("element %p name %s", element, element->name);
+
+	task = find_task_by_index(element->netdev.index);
 	if (task == NULL)
 		return -ENODEV;
 
-	DBG("interface %s", task->ifname);
-
-	tasks = g_slist_remove(tasks, task);
+	g_static_mutex_lock(&task_mutex);
+	task_list = g_slist_remove(task_list, task);
+	g_static_mutex_unlock(&task_mutex);
 
 	disable_network(task);
 
@@ -1023,17 +991,17 @@ int __supplicant_stop(struct connman_iface *iface)
 	return 0;
 }
 
-int __supplicant_scan(struct connman_iface *iface)
+int __supplicant_scan(struct connman_element *element)
 {
 	struct supplicant_task *task;
 	int err;
 
-	task = find_task(iface->index);
+	DBG("element %p name %s", element, element->name);
+
+	task = find_task_by_index(element->netdev.index);
 	if (task == NULL)
 		return -ENODEV;
 
-	DBG("interface %s", task->ifname);
-
 	switch (task->state) {
 	case STATE_SCANNING:
 		return -EALREADY;
@@ -1051,39 +1019,38 @@ int __supplicant_scan(struct connman_iface *iface)
 	return 0;
 }
 
-int __supplicant_connect(struct connman_iface *iface,
-				const char *network, const char *passphrase)
+int __supplicant_connect(struct connman_element *element)
 {
 	struct supplicant_task *task;
 
-	task = find_task(iface->index);
+	DBG("element %p name %s", element, element->name);
+
+	task = find_task_by_index(element->netdev.index);
 	if (task == NULL)
 		return -ENODEV;
 
-	DBG("interface %s", task->ifname);
-
 	add_network(task);
 
 	select_network(task);
 	disable_network(task);
 
-	set_network(task, network, passphrase);
+	set_network(task, NULL, NULL);
 
 	enable_network(task);
 
 	return 0;
 }
 
-int __supplicant_disconnect(struct connman_iface *iface)
+int __supplicant_disconnect(struct connman_element *element)
 {
 	struct supplicant_task *task;
 
-	task = find_task(iface->index);
+	DBG("element %p name %s", element, element->name);
+
+	task = find_task_by_index(element->netdev.index);
 	if (task == NULL)
 		return -ENODEV;
 
-	DBG("interface %s", task->ifname);
-
 	disable_network(task);
 
 	remove_network(task);
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 1ef96d7e..3ba062a5 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -19,17 +19,31 @@
  *
  */
 
-#include <connman/iface.h>
+#include <connman/element.h>
 
 #define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
 #define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
 #define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
 
-int __supplicant_start(struct connman_iface *iface);
-int __supplicant_stop(struct connman_iface *iface);
+struct supplicant_network {
+	gchar *identifier;
+	GByteArray *ssid;
+	guint capabilities;
+	gboolean has_wep;
+	gboolean has_wpa;
+	gboolean has_rsn;
+};
 
-int __supplicant_scan(struct connman_iface *iface);
+struct supplicant_callback {
+	void (*scan_result) (struct connman_element *element,
+					struct supplicant_network *network);
+};
 
-int __supplicant_connect(struct connman_iface *iface,
-				const char *network, const char *passphrase);
-int __supplicant_disconnect(struct connman_iface *iface);
+int __supplicant_start(struct connman_element *element,
+					struct supplicant_callback *callback);
+int __supplicant_stop(struct connman_element *element);
+
+int __supplicant_scan(struct connman_element *element);
+
+int __supplicant_connect(struct connman_element *element);
+int __supplicant_disconnect(struct connman_element *element);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 6ab59406..40a5913c 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -23,300 +23,44 @@
 #include <config.h>
 #endif
 
-#include <dbus/dbus.h>
-
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/log.h>
 
-static DBusConnection *connection;
-
-#define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
-#define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
-#define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
-
-enum supplicant_state {
-	STATE_INACTIVE,
-	STATE_SCANNING,
-	STATE_ASSOCIATING,
-	STATE_ASSOCIATED,
-	STATE_4WAY_HANDSHAKE,
-	STATE_GROUP_HANDSHAKE,
-	STATE_COMPLETED,
-	STATE_DISCONNECTED,
-};
-
-struct supplicant_task {
-	int ifindex;
-	gchar *ifname;
-	enum supplicant_state state;
-	gchar *path;
-	gboolean created;
-};
-
-static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
-static GSList *task_list = NULL;
-
-static struct supplicant_task *find_task_by_index(int index)
-{
-	GSList *list;
-
-	for (list = task_list; list; list = list->next) {
-		struct supplicant_task *task = list->data;
-
-		if (task->ifindex == index)
-			return task;
-	}
+#include "supplicant.h"
 
-	return NULL;
-}
-
-static int get_interface(struct supplicant_task *task)
+static void scan_result(struct connman_element *element,
+					struct supplicant_network *network)
 {
-	DBusMessage *message, *reply;
-	DBusError error;
-	const char *path;
-
-	DBG("task %p", task);
-
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
-					SUPPLICANT_INTF, "getInterface");
-	if (message == NULL)
-		return -ENOMEM;
-
-	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
-							DBUS_TYPE_INVALID);
-
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to get interface");
-		dbus_message_unref(message);
-		return -EIO;
-	}
-
-	dbus_message_unref(message);
-
-	dbus_error_init(&error);
-
-	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
-						DBUS_TYPE_INVALID) == FALSE) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Wrong arguments for interface");
-		dbus_message_unref(reply);
-		return -EIO;
-	}
-
-	DBG("path %s", path);
-
-	task->path = g_strdup(path);
-	task->created = FALSE;
-
-	dbus_message_unref(reply);
-
-	return 0;
-}
-
-static int add_interface(struct supplicant_task *task)
-{
-	DBusMessage *message, *reply;
-	DBusError error;
-	const char *path;
-
-	DBG("task %p", task);
-
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
-					SUPPLICANT_INTF, "addInterface");
-	if (message == NULL)
-		return -ENOMEM;
-
-	dbus_error_init(&error);
-
-	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
-							DBUS_TYPE_INVALID);
-
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to add interface");
-		dbus_message_unref(message);
-		return -EIO;
-	}
-
-	dbus_message_unref(message);
-
-	dbus_error_init(&error);
-
-	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
-						DBUS_TYPE_INVALID) == FALSE) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Wrong arguments for interface");
-		dbus_message_unref(reply);
-		return -EIO;
-	}
-
-	DBG("path %s", path);
-
-	task->path = g_strdup(path);
-	task->created = TRUE;
-
-	dbus_message_unref(reply);
-
-	return 0;
-}
-
-static int remove_interface(struct supplicant_task *task)
-{
-	DBusMessage *message, *reply;
-	DBusError error;
-
-	DBG("task %p", task);
-
-	if (task->created == FALSE)
-		return -EINVAL;
-
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
-					SUPPLICANT_INTF, "removeInterface");
-	if (message == NULL)
-		return -ENOMEM;
-
-	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->path,
-							DBUS_TYPE_INVALID);
-
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to remove interface");
-		dbus_message_unref(message);
-		return -EIO;
-	}
-
-	dbus_message_unref(message);
-
-	g_free(task->path);
-	task->path = NULL;
-
-	dbus_message_unref(reply);
+	DBG("element %p name %s", element, element->name);
 
-	return 0;
+	DBG("network %p identifier %s", network, network->identifier);
 }
 
-static int initiate_scan(struct supplicant_task *task)
-{
-	DBusMessage *message, *reply;
-	DBusError error;
-
-	DBG("task %p", task);
-
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
-					SUPPLICANT_INTF ".Interface", "scan");
-	if (message == NULL)
-		return -ENOMEM;
-
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to initiate scan");
-		dbus_message_unref(message);
-		return -EIO;
-	}
-
-	dbus_message_unref(message);
-
-	dbus_message_unref(reply);
-
-	return 0;
-}
+static struct supplicant_callback wifi_callback = {
+	.scan_result	= scan_result,
+};
 
 static int wifi_probe(struct connman_element *element)
 {
-	struct supplicant_task *task;
 	int err;
 
 	DBG("element %p name %s", element, element->name);
 
-	task = g_try_new0(struct supplicant_task, 1);
-	if (task == NULL)
-		return -ENOMEM;
-
-	task->ifindex = element->netdev.index;
-	task->ifname = g_strdup(element->netdev.name);
-
-	if (task->ifname == NULL) {
-		g_free(task);
-		return -ENOMEM;
-	}
-
-	task->created = FALSE;
-	task->state = STATE_INACTIVE;
-
-	g_static_mutex_lock(&task_mutex);
-	task_list = g_slist_append(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
-
-	err = get_interface(task);
-	if (err < 0) {
-		err = add_interface(task);
-		if (err < 0) {
-			g_free(task);
-			return err;
-		}
-	}
+	err = __supplicant_start(element, &wifi_callback);
+	if (err < 0)
+		return err;
 
-	initiate_scan(task);
+	__supplicant_scan(element);
 
 	return 0;
 }
 
 static void wifi_remove(struct connman_element *element)
 {
-	struct supplicant_task *task;
-
 	DBG("element %p name %s", element, element->name);
 
-	g_static_mutex_lock(&task_mutex);
-	task = find_task_by_index(element->netdev.index);
-	g_static_mutex_unlock(&task_mutex);
-
-	if (task == NULL)
-		return;
-
-	g_static_mutex_lock(&task_mutex);
-	task_list = g_slist_remove(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
-
-	remove_interface(task);
-
-	g_free(task->ifname);
-	g_free(task);
+	__supplicant_stop(element);
 }
 
 static struct connman_driver wifi_driver = {
@@ -329,26 +73,12 @@ static struct connman_driver wifi_driver = {
 
 static int wifi_init(void)
 {
-	int err;
-
-	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
-	if (connection == NULL)
-		return -EIO;
-
-	err = connman_driver_register(&wifi_driver);
-	if (err < 0) {
-		dbus_connection_unref(connection);
-		return err;
-	}
-
-	return 0;
+	return connman_driver_register(&wifi_driver);
 }
 
 static void wifi_exit(void)
 {
 	connman_driver_unregister(&wifi_driver);
-
-	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("WiFi", "WiFi interface plugin", VERSION,

commit c0940d7ef4663194e71ffd3c64dee1253192b94a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 09:47:36 2008 +0200

    Remove old 802.03 and 802.11 plugins

diff --git a/plugins/80203.c b/plugins/80203.c
deleted file mode 100644
index 753e4741..00000000
--- a/plugins/80203.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <sys/stat.h>
-
-#include <connman/plugin.h>
-#include <connman/iface.h>
-#include <connman/log.h>
-
-static int ethernet_probe(struct connman_iface *iface)
-{
-	char sysfs_path[PATH_MAX];
-	struct stat st;
-
-	DBG("iface %p", iface);
-
-	snprintf(sysfs_path, PATH_MAX, "%s/bridge", iface->sysfs);
-
-	if (stat(sysfs_path, &st) == 0 && (st.st_mode & S_IFDIR))
-		return -ENODEV;
-
-	iface->type = CONNMAN_IFACE_TYPE_80203;
-
-	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4;
-
-	return 0;
-}
-
-static void ethernet_remove(struct connman_iface *iface)
-{
-	DBG("iface %p", iface);
-}
-
-static struct connman_iface_driver ethernet_driver = {
-	.name		= "80203",
-	.capability	= "net.80203",
-	.probe		= ethernet_probe,
-	.remove		= ethernet_remove,
-};
-
-static int ethernet_init(void)
-{
-	return connman_iface_register(&ethernet_driver);
-}
-
-static void ethernet_exit(void)
-{
-	connman_iface_unregister(&ethernet_driver);
-}
-
-CONNMAN_PLUGIN_DEFINE("80203", "IEEE 802.03 interface plugin", VERSION,
-						ethernet_init, ethernet_exit)
diff --git a/plugins/80211.c b/plugins/80211.c
deleted file mode 100644
index b4bd65ab..00000000
--- a/plugins/80211.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <net/if.h>
-#include <net/ethernet.h>
-#include <linux/wireless.h>
-
-#include <glib.h>
-
-#include <connman/plugin.h>
-#include <connman/iface.h>
-#include <connman/log.h>
-
-#include "supplicant.h"
-
-struct iface_data {
-	char ifname[IFNAMSIZ];
-};
-
-static int wifi_probe(struct connman_iface *iface)
-{
-	struct iface_data *data;
-	struct ifreq ifr;
-	int sk, err;
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return -EIO;
-
-	DBG("iface %p %s", iface, ifr.ifr_name);
-
-	data = malloc(sizeof(*data));
-	if (data == NULL)
-		return -ENOMEM;
-
-	memset(data, 0, sizeof(*data));
-
-	memcpy(data->ifname, ifr.ifr_name, IFNAMSIZ);
-
-	iface->type = CONNMAN_IFACE_TYPE_80211;
-
-	iface->flags = CONNMAN_IFACE_FLAG_RTNL |
-				CONNMAN_IFACE_FLAG_IPV4 |
-				CONNMAN_IFACE_FLAG_SCANNING |
-				CONNMAN_IFACE_FLAG_NOCARRIER;
-
-	connman_iface_set_data(iface, data);
-
-	return 0;
-}
-
-static void wifi_remove(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	__supplicant_stop(iface);
-
-	connman_iface_set_data(iface, NULL);
-
-	free(data);
-}
-
-static int wifi_start(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	__supplicant_start(iface);
-
-	return 0;
-}
-
-static int wifi_stop(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	__supplicant_stop(iface);
-
-	return 0;
-}
-
-static int wifi_scan(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	__supplicant_scan(iface);
-
-	return 0;
-}
-
-static int wifi_connect(struct connman_iface *iface,
-					struct connman_network *network)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	__supplicant_connect(iface, network->identifier, network->passphrase);
-
-	return 0;
-}
-
-static int wifi_disconnect(struct connman_iface *iface)
-{
-	struct iface_data *data = connman_iface_get_data(iface);
-
-	DBG("iface %p %s", iface, data->ifname);
-
-	__supplicant_disconnect(iface);
-
-	return 0;
-}
-
-static struct connman_iface_driver wifi_driver = {
-	.name		= "80211",
-	.capability	= "net.80211",
-	.probe		= wifi_probe,
-	.remove		= wifi_remove,
-	.start		= wifi_start,
-	.stop		= wifi_stop,
-	.scan		= wifi_scan,
-	.connect	= wifi_connect,
-	.disconnect	= wifi_disconnect,
-};
-
-static int wifi_init(void)
-{
-	return connman_iface_register(&wifi_driver);
-}
-
-static void wifi_exit(void)
-{
-	connman_iface_unregister(&wifi_driver);
-}
-
-CONNMAN_PLUGIN_DEFINE("80211", "IEEE 802.11 interface plugin", VERSION,
-							wifi_init, wifi_exit)

commit 7010bb4c11d907ac3c7997684dee08991c561f5a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 10:02:23 2008 +0200

    Update resolver plugin infrastructure

diff --git a/include/element.h b/include/element.h
index e5843389..af34da8d 100644
--- a/include/element.h
+++ b/include/element.h
@@ -48,6 +48,7 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_DHCP       = 6,
 	CONNMAN_ELEMENT_TYPE_BOOTP      = 7,
 	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 8,
+	CONNMAN_ELEMENT_TYPE_RESOLVER   = 9,
 
 	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
 };
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 66daf5d9..121e05a5 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,7 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = hal.la ethernet.la wifi.la bluetooth.la \
-						dhclient.la ipv4.la
+					dhclient.la ipv4.la resolvconf.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
@@ -20,6 +20,8 @@ dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 
 ipv4_la_SOURCES = ipv4.c
 
+resolvconf_la_SOURCES = resolvconf.c
+
 AM_LDFLAGS = -no-undefined -module -avoid-version \
 				-export-symbols-regex connman_plugin_desc
 
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index ba6eef18..6f30f8b5 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -23,95 +23,62 @@
 #include <config.h>
 #endif
 
-#include <stdio.h>
-#include <unistd.h>
 #include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <net/if.h>
 
 #include <connman/plugin.h>
-#include <connman/resolver.h>
+#include <connman/driver.h>
 #include <connman/log.h>
 
-static int resolvconf_append(struct connman_iface *iface, const char *nameserver)
+static int resolvconf_probe(struct connman_element *element)
 {
-	struct ifreq ifr;
-	char cmd[128];
-	int sk, err;
+	gchar *cmd;
+	//int err;
 
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
+	DBG("element %p name %s", element, element->name);
 
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return -1;
-
-	DBG("ifname %s", ifr.ifr_name);
-
-	snprintf(cmd, sizeof(cmd), "echo \"nameserver %s\" | resolvconf -a %s",
-						nameserver, ifr.ifr_name);
+	cmd = g_strdup_printf("echo \"nameserver %s\" | resolvconf -a %s",
+					"127.0.0.1", element->netdev.name);
 
 	DBG("%s", cmd);
 
-	err = system(cmd);
+	//err = system(cmd);
+
+	g_free(cmd);
 
 	return 0;
 }
 
-static int resolvconf_remove(struct connman_iface *iface)
+static void resolvconf_remove(struct connman_element *element)
 {
-	struct ifreq ifr;
-	char cmd[128];
-	int sk, err;
+	gchar *cmd;
+	//int err;
 
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
+	DBG("element %p name %s", element, element->name);
 
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return -1;
-
-	DBG("ifname %s", ifr.ifr_name);
-
-	snprintf(cmd, sizeof(cmd), "resolvconf -d %s", ifr.ifr_name);
+	cmd = g_strdup_printf("resolvconf -d %s", element->netdev.name);
 
 	DBG("%s", cmd);
 
-	err = system(cmd);
+	//err = system(cmd);
 
-	return 0;
+	g_free(cmd);
 }
 
-static struct connman_resolver_driver resolvconf_driver = {
+static struct connman_driver resolvconf_driver = {
 	.name		= "resolvconf",
-	.append		= resolvconf_append,
+	.type		= CONNMAN_ELEMENT_TYPE_RESOLVER,
+	.probe		= resolvconf_probe,
 	.remove		= resolvconf_remove,
 };
 
 static int resolvconf_init(void)
 {
-	return connman_resolver_register(&resolvconf_driver);
+	return connman_driver_register(&resolvconf_driver);
 }
 
 static void resolvconf_exit(void)
 {
-	connman_resolver_unregister(&resolvconf_driver);
+	connman_driver_unregister(&resolvconf_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE("resolvconf", "Name resolver plugin", VERSION,
diff --git a/src/element.c b/src/element.c
index 58ba06ba..6305adc5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -61,6 +61,8 @@ static const char *type2string(enum connman_element_type type)
 		return "bootp";
 	case CONNMAN_ELEMENT_TYPE_ZEROCONF:
 		return "zeroconf";
+	case CONNMAN_ELEMENT_TYPE_RESOLVER:
+		return "resolver";
 	case CONNMAN_ELEMENT_TYPE_CONNECTION:
 		return "42";
 	}

commit c6af8b38102a9d53be5fa7a25b4374e4a9f3f4b4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 10:15:27 2008 +0200

    Fully integrate the usage of resolver element

diff --git a/include/property.h b/include/property.h
index 76ff04e8..20d525a0 100644
--- a/include/property.h
+++ b/include/property.h
@@ -32,6 +32,7 @@ enum connman_property_type {
 	CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS,
 	CONNMAN_PROPERTY_TYPE_IPV4_NETMASK,
 	CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY,
+	CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER,
 };
 
 enum connman_property_flags {
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 3a06e3ea..6bffa8f8 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -311,6 +311,7 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 		task->child = connman_element_create();
 		task->child->type = CONNMAN_ELEMENT_TYPE_IPV4;
 		task->child->netdev.index = task->ifindex;
+		task->child->netdev.name = g_strdup(task->ifname);
 		connman_element_update(task->element);
 		connman_element_register(task->child, task->element);
 	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 93706449..8b3457b0 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -29,6 +29,7 @@
 
 static int ipv4_probe(struct connman_element *element)
 {
+	struct connman_element *resolver;
 	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 
 	DBG("element %p name %s", element, element->name);
@@ -44,12 +45,29 @@ static int ipv4_probe(struct connman_element *element)
 	DBG("netmask %s", netmask);
 	DBG("gateway %s", gateway);
 
+	resolver = connman_element_create();
+
+	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
+	resolver->netdev.name = g_strdup(element->netdev.name);
+
+	connman_element_register(resolver, element);
+
+	connman_element_set_data(element, resolver);
+
 	return 0;
 }
 
 static void ipv4_remove(struct connman_element *element)
 {
+	struct connman_element *resolver = connman_element_get_data(element);
+
 	DBG("element %p name %s", element, element->name);
+
+	connman_element_set_data(element, NULL);
+
+	connman_element_unregister(resolver);
+
+	connman_element_unref(resolver);
 }
 
 static struct connman_driver ipv4_driver = {
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 6f30f8b5..45d15c37 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -31,13 +31,20 @@
 
 static int resolvconf_probe(struct connman_element *element)
 {
+	const char *nameserver = NULL;
 	gchar *cmd;
 	//int err;
 
 	DBG("element %p name %s", element, element->name);
 
+	connman_element_get_value(element,
+			CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER, &nameserver);
+
+	if (nameserver == NULL)
+		return -EINVAL;
+
 	cmd = g_strdup_printf("echo \"nameserver %s\" | resolvconf -a %s",
-					"127.0.0.1", element->netdev.name);
+					nameserver, element->netdev.name);
 
 	DBG("%s", cmd);
 
diff --git a/src/element.c b/src/element.c
index 6305adc5..55fa6cba 100644
--- a/src/element.c
+++ b/src/element.c
@@ -406,6 +406,10 @@ int connman_element_set_property(struct connman_element *element,
 		g_free(element->ipv4.gateway);
 		element->ipv4.gateway = g_strdup(*((const char **) value));
 		break;
+	case CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER:
+		g_free(element->ipv4.nameserver);
+		element->ipv4.nameserver = g_strdup(*((const char **) value));
+		break;
 	}
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
@@ -443,6 +447,12 @@ int connman_element_get_value(struct connman_element *element,
 								type, value);
 		*((char **) value) = element->ipv4.gateway;
 		break;
+	case CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER:
+		if (element->ipv4.nameserver == NULL)
+			return connman_element_get_value(element->parent,
+								type, value);
+		*((char **) value) = element->ipv4.nameserver;
+		break;
 	}
 
 	return 0;
@@ -492,6 +502,9 @@ int connman_element_register(struct connman_element *element,
 		case CONNMAN_ELEMENT_TYPE_ZEROCONF:
 			element->name = g_strdup("zeroconf");
 			break;
+		case CONNMAN_ELEMENT_TYPE_RESOLVER:
+			element->name = g_strdup("resolver");
+			break;
 		default:
 			break;
 		}

commit dd1ef7a7020ce9a32c55476e3e9a5587b141537b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 13:32:11 2008 +0200

    Simplify the locking and remove some deadlocks

diff --git a/include/element.h b/include/element.h
index af34da8d..c4d97cc2 100644
--- a/include/element.h
+++ b/include/element.h
@@ -66,6 +66,7 @@ struct connman_driver;
 
 struct connman_element {
 	gint refcount;
+	GStaticMutex mutex;
 	gchar *name;
 	gchar *path;
 	enum connman_element_type type;
@@ -96,6 +97,9 @@ struct connman_element {
 	} ipv4;
 };
 
+#define connman_element_lock(element)    g_static_mutex_lock(&(element)->mutex)
+#define connman_element_unlock(element)  g_static_mutex_unlock(&(element)->mutex)
+
 extern struct connman_element *connman_element_create(void);
 extern struct connman_element *connman_element_ref(struct connman_element *element);
 extern void connman_element_unref(struct connman_element *element);
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 8905223c..21ca7fcb 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -236,6 +236,8 @@ static void ethernet_remove(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
+	remove_elements(element);
+
 	g_static_mutex_lock(&ethernet_mutex);
 	ethernet_list = g_slist_remove(ethernet_list, element);
 	g_static_mutex_unlock(&ethernet_mutex);
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 8b3457b0..6d2e2a8c 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -50,10 +50,10 @@ static int ipv4_probe(struct connman_element *element)
 	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
 	resolver->netdev.name = g_strdup(element->netdev.name);
 
-	connman_element_register(resolver, element);
-
 	connman_element_set_data(element, resolver);
 
+	connman_element_register(resolver, element);
+
 	return 0;
 }
 
diff --git a/src/element.c b/src/element.c
index 55fa6cba..01cae2d0 100644
--- a/src/element.c
+++ b/src/element.c
@@ -32,13 +32,13 @@
 
 static DBusConnection *connection;
 
-static GStaticRWLock driver_lock = G_STATIC_RW_LOCK_INIT;
-static GSList *driver_list = NULL;
-static GThreadPool *driver_thread;
-
 static GStaticRWLock element_lock = G_STATIC_RW_LOCK_INIT;
 static GNode *element_root = NULL;
-static GThreadPool *element_thread;
+
+static GSList *driver_list = NULL;
+
+static GThreadPool *thread_register;
+static GThreadPool *thread_unregister;
 
 static const char *type2string(enum connman_element_type type)
 {
@@ -246,22 +246,59 @@ static gint compare_priority(gconstpointer a, gconstpointer b)
 	return driver2->priority - driver1->priority;
 }
 
+static gboolean match_driver(struct connman_element *element,
+					struct connman_driver *driver)
+{
+	if (element->type != driver->type &&
+			driver->type != CONNMAN_ELEMENT_TYPE_UNKNOWN)
+		return FALSE;
+
+	if (element->subtype == driver->subtype ||
+			driver->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean probe_driver(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+	struct connman_driver *driver = data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (!element->driver && match_driver(element, driver) == TRUE) {
+		if (driver->probe(element) < 0)
+			return FALSE;
+
+		connman_element_lock(element);
+		element->driver = driver;
+		connman_element_unlock(element);
+	}
+
+	return FALSE;
+}
+
 int connman_driver_register(struct connman_driver *driver)
 {
 	DBG("driver %p name %s", driver, driver->name);
 
 	if (driver->type == CONNMAN_ELEMENT_TYPE_ROOT)
-		return -1;
+		return -EINVAL;
 
 	if (!driver->probe)
 		return -EINVAL;
 
-	g_static_rw_lock_writer_lock(&driver_lock);
+	g_static_rw_lock_writer_lock(&element_lock);
+
 	driver_list = g_slist_insert_sorted(driver_list, driver,
 							compare_priority);
-	g_static_rw_lock_writer_unlock(&driver_lock);
 
-	g_thread_pool_push(driver_thread, driver, NULL);
+	if (element_root != NULL)
+		g_node_traverse(element_root, G_PRE_ORDER,
+				G_TRAVERSE_ALL, -1, probe_driver, driver);
+
+	g_static_rw_lock_writer_unlock(&element_lock);
 
 	return 0;
 }
@@ -276,7 +313,10 @@ static gboolean remove_driver(GNode *node, gpointer data)
 	if (element->driver == driver) {
 		if (driver->remove)
 			driver->remove(element);
+
+		connman_element_lock(element);
 		element->driver = NULL;
+		connman_element_unlock(element);
 	}
 
 	return FALSE;
@@ -286,14 +326,15 @@ void connman_driver_unregister(struct connman_driver *driver)
 {
 	DBG("driver %p name %s", driver, driver->name);
 
-	g_static_rw_lock_reader_lock(&element_lock);
-	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
-							remove_driver, driver);
-	g_static_rw_lock_reader_unlock(&element_lock);
+	g_static_rw_lock_writer_lock(&element_lock);
 
-	g_static_rw_lock_writer_lock(&driver_lock);
 	driver_list = g_slist_remove(driver_list, driver);
-	g_static_rw_lock_writer_unlock(&driver_lock);
+
+	if (element_root != NULL)
+		g_node_traverse(element_root, G_POST_ORDER,
+				G_TRAVERSE_ALL, -1, remove_driver, driver);
+
+	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 struct connman_element *connman_element_create(void)
@@ -306,6 +347,8 @@ struct connman_element *connman_element_create(void)
 
 	element->refcount = 1;
 
+	g_static_mutex_init(&element->mutex);
+
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
@@ -383,7 +426,9 @@ int connman_element_add_static_property(struct connman_element *element,
 		break;
 	}
 
+	connman_element_lock(element);
 	element->properties = g_slist_append(element->properties, property);
+	connman_element_unlock(element);
 
 	return 0;
 }
@@ -395,20 +440,28 @@ int connman_element_set_property(struct connman_element *element,
 	case CONNMAN_PROPERTY_TYPE_INVALID:
 		return -EINVAL;
 	case CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS:
+		connman_element_lock(element);
 		g_free(element->ipv4.address);
 		element->ipv4.address = g_strdup(*((const char **) value));
+		connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_TYPE_IPV4_NETMASK:
+		connman_element_lock(element);
 		g_free(element->ipv4.netmask);
 		element->ipv4.netmask = g_strdup(*((const char **) value));
+		connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY:
+		connman_element_lock(element);
 		g_free(element->ipv4.gateway);
 		element->ipv4.gateway = g_strdup(*((const char **) value));
+		connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER:
+		connman_element_lock(element);
 		g_free(element->ipv4.nameserver);
 		element->ipv4.nameserver = g_strdup(*((const char **) value));
+		connman_element_unlock(element);
 		break;
 	}
 
@@ -433,25 +486,33 @@ int connman_element_get_value(struct connman_element *element,
 		if (element->ipv4.address == NULL)
 			return connman_element_get_value(element->parent,
 								type, value);
+		connman_element_lock(element);
 		*((char **) value) = element->ipv4.address;
+		connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_TYPE_IPV4_NETMASK:
 		if (element->ipv4.netmask == NULL)
 			return connman_element_get_value(element->parent,
 								type, value);
+		connman_element_lock(element);
 		*((char **) value) = element->ipv4.netmask;
+		connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY:
 		if (element->ipv4.gateway == NULL)
 			return connman_element_get_value(element->parent,
 								type, value);
+		connman_element_lock(element);
 		*((char **) value) = element->ipv4.gateway;
+		connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER:
 		if (element->ipv4.nameserver == NULL)
 			return connman_element_get_value(element->parent,
 								type, value);
+		connman_element_lock(element);
 		*((char **) value) = element->ipv4.nameserver;
+		connman_element_unlock(element);
 		break;
 	}
 
@@ -461,29 +522,14 @@ int connman_element_get_value(struct connman_element *element,
 int connman_element_register(struct connman_element *element,
 					struct connman_element *parent)
 {
-	GNode *node;
-	const gchar *basepath;
-
 	DBG("element %p name %s parent %p", element, element->name, parent);
 
 	if (connman_element_ref(element) == NULL)
-		return -1;
-
-	__connman_element_load(element);
-
-	g_static_rw_lock_writer_lock(&element_lock);
+		return -EINVAL;
 
-	if (parent) {
-		node = g_node_find(element_root, G_PRE_ORDER,
-						G_TRAVERSE_ALL, parent);
-		basepath = parent->path;
+	connman_element_lock(element);
 
-		if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
-			element->subtype = parent->subtype;
-	} else {
-		node = element_root;
-		basepath = "";
-	}
+	__connman_element_load(element);
 
 	if (element->name == NULL) {
 		switch (element->type) {
@@ -510,75 +556,20 @@ int connman_element_register(struct connman_element *element,
 		}
 	}
 
-	element->path = g_strdup_printf("%s/%s", basepath, element->name);
 	element->parent = parent;
 
-	DBG("element %p path %s", element, element->path);
-
-	g_node_append_data(node, element);
-
-	g_static_rw_lock_writer_unlock(&element_lock);
-
-	__connman_element_store(element);
-
-	g_dbus_register_interface(connection, element->path,
-					CONNMAN_ELEMENT_INTERFACE,
-					element_methods, NULL, NULL,
-							element, NULL);
-
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
-		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "DeviceAdded",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
+	connman_element_unlock(element);
 
-	g_thread_pool_push(element_thread, element, NULL);
+	g_thread_pool_push(thread_register, element, NULL);
 
 	return 0;
 }
 
 void connman_element_unregister(struct connman_element *element)
 {
-	GNode *node;
-
 	DBG("element %p name %s", element, element->name);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
-		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "DeviceRemoved",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementRemoved",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
-	g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_ELEMENT_INTERFACE);
-
-	g_static_rw_lock_writer_lock(&element_lock);
-
-	if (element->driver) {
-		if (element->driver->remove)
-			element->driver->remove(element);
-		element->driver = NULL;
-	}
-
-	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
-	if (node != NULL) {
-		g_node_unlink(node);
-		g_node_destroy(node);
-	}
-
-	g_static_rw_lock_writer_unlock(&element_lock);
-
-	connman_element_unref(element);
+	g_thread_pool_push(thread_unregister, element, NULL);
 }
 
 void connman_element_update(struct connman_element *element)
@@ -598,84 +589,118 @@ void connman_element_update(struct connman_element *element)
 							DBUS_TYPE_INVALID);
 }
 
-static inline void set_driver(struct connman_element *element,
-						struct connman_driver *driver)
+static void register_element(gpointer data, gpointer user_data)
 {
-	g_static_rw_lock_reader_lock(&element_lock);
-	element->driver = driver;
-	g_static_rw_lock_reader_unlock(&element_lock);
-}
+	struct connman_element *element = data;
+	const gchar *basepath;
+	GSList *list;
+	GNode *node;
 
-static gboolean match_driver(struct connman_element *element,
-					struct connman_driver *driver)
-{
-	if (element->type != driver->type &&
-			driver->type != CONNMAN_ELEMENT_TYPE_UNKNOWN)
-		return FALSE;
+	g_static_rw_lock_writer_lock(&element_lock);
 
-	if (element->subtype == driver->subtype ||
-			driver->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
-		return TRUE;
+	connman_element_lock(element);
 
-	return FALSE;
-}
+	if (element->parent) {
+		node = g_node_find(element_root, G_PRE_ORDER,
+					G_TRAVERSE_ALL, element->parent);
+		basepath = element->parent->path;
 
-static gboolean probe_driver(GNode *node, gpointer data)
-{
-	struct connman_element *element = node->data;
-	struct connman_driver *driver = data;
+		if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
+			element->subtype = element->parent->subtype;
+	} else {
+		node = element_root;
+		basepath = "";
+	}
 
-	DBG("element %p name %s", element, element->name);
+	element->path = g_strdup_printf("%s/%s", basepath, element->name);
 
-	if (!element->driver && match_driver(element, driver) == TRUE) {
-		element->driver = driver;
+	connman_element_unlock(element);
 
-		if (driver->probe(element) < 0)
-			element->driver = NULL;
-	}
+	DBG("element %p path %s", element, element->path);
 
-	return FALSE;
-}
+	g_node_append_data(node, element);
 
-static void driver_probe(gpointer data, gpointer user_data)
-{
-	struct connman_driver *driver = data;
+	g_static_rw_lock_writer_unlock(&element_lock);
 
-	DBG("driver %p name %s", driver, driver->name);
+	__connman_element_store(element);
 
-	g_static_rw_lock_reader_lock(&element_lock);
-	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
-							probe_driver, driver);
-	g_static_rw_lock_reader_unlock(&element_lock);
+	g_dbus_register_interface(connection, element->path,
+					CONNMAN_ELEMENT_INTERFACE,
+					element_methods, NULL, NULL,
+							element, NULL);
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
+		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "DeviceAdded",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	g_static_rw_lock_writer_lock(&element_lock);
+
+	for (list = driver_list; list; list = list->next) {
+		struct connman_driver *driver = list->data;
+
+		if (match_driver(element, driver) == FALSE)
+			continue;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		if (driver->probe(element) < 0)
+			continue;
+
+		connman_element_lock(element);
+		element->driver = driver;
+		connman_element_unlock(element);
+	}
+
+	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
-static void element_probe(gpointer data, gpointer user_data)
+static void unregister_element(gpointer data, gpointer user_data)
 {
 	struct connman_element *element = data;
-	GSList *list;
+	GNode *node;
 
 	DBG("element %p name %s", element, element->name);
 
-	if (connman_element_ref(element) == NULL)
-		return;
+	g_static_rw_lock_writer_lock(&element_lock);
 
-	g_static_rw_lock_reader_lock(&driver_lock);
+	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
 
-	for (list = driver_list; list; list = list->next) {
-		struct connman_driver *driver = list->data;
+	if (element->driver) {
+		if (element->driver->remove)
+			element->driver->remove(element);
 
-		DBG("driver %p name %s", driver, driver->name);
+		connman_element_lock(element);
+		element->driver = NULL;
+		connman_element_unlock(element);
+	}
 
-		set_driver(element, driver);
+	if (node != NULL) {
+		g_node_unlink(node);
+		g_node_destroy(node);
+	}
 
-		if (match_driver(element, driver) == TRUE &&
-						driver->probe(element) == 0)
-			break;
+	g_static_rw_lock_writer_unlock(&element_lock);
 
-		set_driver(element, NULL);
-	}
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
+		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "DeviceRemoved",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementRemoved",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
 
-	g_static_rw_lock_reader_unlock(&driver_lock);
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_ELEMENT_INTERFACE);
 
 	connman_element_unref(element);
 }
@@ -702,31 +727,40 @@ int __connman_element_init(DBusConnection *conn)
 
 	g_static_rw_lock_writer_unlock(&element_lock);
 
-	element_thread = g_thread_pool_new(element_probe, NULL, 1, FALSE, NULL);
-
-	driver_thread = g_thread_pool_new(driver_probe, NULL, 1, FALSE, NULL);
+	thread_register = g_thread_pool_new(register_element,
+							NULL, 1, FALSE, NULL);
+	thread_unregister = g_thread_pool_new(unregister_element,
+							NULL, 1, FALSE, NULL);
 
 	return 0;
 }
 
-static gboolean free_node(GNode *node, gpointer data)
+static gboolean free_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
 
 	DBG("element %p name %s", element, element->name);
 
-	g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_ELEMENT_INTERFACE);
-
 	if (element->driver) {
 		if (element->driver->remove)
 			element->driver->remove(element);
+
+		connman_element_lock(element);
 		element->driver = NULL;
+		connman_element_unlock(element);
 	}
 
-	connman_element_unref(element);
+	return FALSE;
+}
+
+static gboolean free_node(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+
+	DBG("element %p name %s", element, element->name);
 
-	node->data = NULL;
+	if (g_node_depth(node) > 1)
+		g_thread_pool_push(thread_unregister, element, NULL);
 
 	return FALSE;
 }
@@ -735,18 +769,23 @@ void __connman_element_cleanup(void)
 {
 	DBG("");
 
-	g_thread_pool_free(driver_thread, TRUE, TRUE);
-
-	g_thread_pool_free(element_thread, TRUE, TRUE);
+	g_thread_pool_free(thread_register, TRUE, TRUE);
 
 	g_static_rw_lock_writer_lock(&element_lock);
+	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
+							free_driver, NULL);
+	g_static_rw_lock_writer_unlock(&element_lock);
 
+	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_node, NULL);
+	g_static_rw_lock_writer_unlock(&element_lock);
 
+	g_thread_pool_free(thread_unregister, FALSE, TRUE);
+
+	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_destroy(element_root);
 	element_root = NULL;
-
 	g_static_rw_lock_writer_unlock(&element_lock);
 
 	dbus_connection_unref(connection);
diff --git a/src/main.c b/src/main.c
index 9e237cc4..f485a41e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -146,16 +146,16 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
-	__connman_plugin_cleanup();
-
-	__connman_manager_cleanup();
-
 	__connman_agent_cleanup();
 
 	__connman_element_cleanup();
 
+	__connman_manager_cleanup();
+
 	__connman_storage_cleanup();
 
+	__connman_plugin_cleanup();
+
 	__connman_log_cleanup();
 
 	g_dbus_cleanup_connection(conn);

commit 923822ad45f7a1f7b9727ed91cac234b1681f34e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 14:14:49 2008 +0200

    Check that the thread pool is available

diff --git a/src/element.c b/src/element.c
index 01cae2d0..fd8570ff 100644
--- a/src/element.c
+++ b/src/element.c
@@ -37,8 +37,8 @@ static GNode *element_root = NULL;
 
 static GSList *driver_list = NULL;
 
-static GThreadPool *thread_register;
-static GThreadPool *thread_unregister;
+static GThreadPool *thread_register = NULL;
+static GThreadPool *thread_unregister = NULL;
 
 static const char *type2string(enum connman_element_type type)
 {
@@ -560,7 +560,8 @@ int connman_element_register(struct connman_element *element,
 
 	connman_element_unlock(element);
 
-	g_thread_pool_push(thread_register, element, NULL);
+	if (thread_register != NULL)
+		g_thread_pool_push(thread_register, element, NULL);
 
 	return 0;
 }
@@ -569,7 +570,8 @@ void connman_element_unregister(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
-	g_thread_pool_push(thread_unregister, element, NULL);
+	if (thread_unregister != NULL)
+		g_thread_pool_push(thread_unregister, element, NULL);
 }
 
 void connman_element_update(struct connman_element *element)
@@ -770,6 +772,7 @@ void __connman_element_cleanup(void)
 	DBG("");
 
 	g_thread_pool_free(thread_register, TRUE, TRUE);
+	thread_register = NULL;
 
 	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
@@ -782,6 +785,7 @@ void __connman_element_cleanup(void)
 	g_static_rw_lock_writer_unlock(&element_lock);
 
 	g_thread_pool_free(thread_unregister, FALSE, TRUE);
+	thread_unregister = NULL;
 
 	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_destroy(element_root);

commit 78238bcd30a5bd0e712bf0b6d19250a6628aa93e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 14:37:38 2008 +0200

    Create element for every network in range

diff --git a/include/element.h b/include/element.h
index c4d97cc2..e000a587 100644
--- a/include/element.h
+++ b/include/element.h
@@ -87,6 +87,10 @@ struct connman_element {
 		gchar *name;
 	} netdev;
 
+	struct {
+		gchar *identifier;
+	} network;
+
 	struct {
 		gchar *address;
 		gchar *netmask;
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 40a5913c..5c275a44 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -29,12 +29,52 @@
 
 #include "supplicant.h"
 
-static void scan_result(struct connman_element *element,
+struct wifi_data {
+	GStaticMutex mutex;
+	GSList *list;
+};
+
+static struct connman_element *find_element(struct wifi_data *data,
+						const char *identifier)
+{
+	GSList *list;
+
+	for (list = data->list; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		if (g_str_equal(identifier, element->network.identifier) == TRUE)
+			return element;
+	}
+
+	return NULL;
+}
+
+static void scan_result(struct connman_element *parent,
 					struct supplicant_network *network)
 {
-	DBG("element %p name %s", element, element->name);
+	struct wifi_data *data = connman_element_get_data(parent);
+	struct connman_element *element;
 
 	DBG("network %p identifier %s", network, network->identifier);
+
+	if (data == NULL)
+		return;
+
+	g_static_mutex_lock(&data->mutex);
+
+	element = find_element(data, network->identifier);
+	if (element == NULL) {
+		element = connman_element_create();
+
+		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
+		element->name = g_strdup(network->identifier);
+
+		data->list = g_slist_append(data->list, element);
+	}
+
+	g_static_mutex_unlock(&data->mutex);
+
+	connman_element_register(element, parent);
 }
 
 static struct supplicant_callback wifi_callback = {
@@ -43,10 +83,19 @@ static struct supplicant_callback wifi_callback = {
 
 static int wifi_probe(struct connman_element *element)
 {
+	struct wifi_data *data;
 	int err;
 
 	DBG("element %p name %s", element, element->name);
 
+	data = g_try_new0(struct wifi_data, 1);
+	if (data == NULL)
+		return -ENOMEM;
+
+	g_static_mutex_init(&data->mutex);
+
+	connman_element_set_data(element, data);
+
 	err = __supplicant_start(element, &wifi_callback);
 	if (err < 0)
 		return err;
@@ -58,9 +107,32 @@ static int wifi_probe(struct connman_element *element)
 
 static void wifi_remove(struct connman_element *element)
 {
+	struct wifi_data *data = connman_element_get_data(element);
+	GSList *list;
+
 	DBG("element %p name %s", element, element->name);
 
 	__supplicant_stop(element);
+
+	connman_element_set_data(element, NULL);
+
+	if (data == NULL)
+		return;
+
+	g_static_mutex_lock(&data->mutex);
+
+	for (list = data->list; list; list = list->next) {
+		struct connman_element *network = list->data;
+
+		connman_element_unregister(network);
+		connman_element_unref(network);
+	}
+
+	g_slist_free(data->list);
+
+	g_static_mutex_unlock(&data->mutex);
+
+	g_free(data);
 }
 
 static struct connman_driver wifi_driver = {
diff --git a/src/element.c b/src/element.c
index fd8570ff..1b49b805 100644
--- a/src/element.c
+++ b/src/element.c
@@ -174,6 +174,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		append_entry(&dict, "Priority",
 				DBUS_TYPE_UINT16, &element->priority);
 
+	if (element->network.identifier != NULL)
+		append_entry(&dict, "Identifier",
+				DBUS_TYPE_STRING, &element->network.identifier);
+
 	if (element->ipv4.address != NULL)
 		append_entry(&dict, "IPv4.Address",
 				DBUS_TYPE_STRING, &element->ipv4.address);
@@ -392,6 +396,7 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.network);
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
+		g_free(element->network.identifier);
 		g_free(element->netdev.name);
 		g_free(element->path);
 		g_free(element->name);

commit f283876a0e996b16606d1e39e9d8212c105db2a5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 15:02:04 2008 +0200

    Add D-Bus disconnect callback

diff --git a/src/main.c b/src/main.c
index f485a41e..d043b317 100644
--- a/src/main.c
+++ b/src/main.c
@@ -43,6 +43,11 @@ static void sig_term(int sig)
 	g_main_loop_quit(main_loop);
 }
 
+static void disconnect_callback(void *user_data)
+{
+	DBG("D-Bus disconnect");
+}
+
 static gchar *option_interface = NULL;
 static gboolean option_detach = TRUE;
 static gboolean option_compat = FALSE;
@@ -118,6 +123,8 @@ int main(int argc, char *argv[])
 		exit(1);
 	}
 
+	g_dbus_set_disconnect_function(conn, disconnect_callback, NULL, NULL);
+
 	if (option_compat == TRUE) {
 		if (g_dbus_request_name(conn, NM_SERVICE, NULL) == FALSE) {
 			fprintf(stderr, "Can't register compat service\n");

commit 638e2551e40bf3fc6988aa9b8125de1ef1b143ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 3 15:02:22 2008 +0200

    Fix network identifier checking

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 5c275a44..30d94f29 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <string.h>
+
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/log.h>
@@ -42,7 +44,11 @@ static struct connman_element *find_element(struct wifi_data *data,
 	for (list = data->list; list; list = list->next) {
 		struct connman_element *element = list->data;
 
-		if (g_str_equal(identifier, element->network.identifier) == TRUE)
+		if (element->network.identifier == NULL)
+			continue;
+
+		if (g_str_equal(element->network.identifier,
+							identifier) == TRUE)
 			return element;
 	}
 
@@ -54,27 +60,40 @@ static void scan_result(struct connman_element *parent,
 {
 	struct wifi_data *data = connman_element_get_data(parent);
 	struct connman_element *element;
+	gchar *temp;
+	int i;
 
 	DBG("network %p identifier %s", network, network->identifier);
 
 	if (data == NULL)
 		return;
 
+	temp = g_strdup(network->identifier);
+
+	for (i = 0; i < strlen(temp); i++) {
+		if (temp[i] == ' ' || temp[i] == '.')
+			temp[i] = '_';
+		temp[i] = g_ascii_tolower(temp[i]);
+	}
+
 	g_static_mutex_lock(&data->mutex);
 
-	element = find_element(data, network->identifier);
+	element = find_element(data, temp);
 	if (element == NULL) {
 		element = connman_element_create();
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
-		element->name = g_strdup(network->identifier);
+		element->name = temp;
+
+		element->network.identifier = g_strdup(temp);
 
 		data->list = g_slist_append(data->list, element);
-	}
 
-	g_static_mutex_unlock(&data->mutex);
+		connman_element_register(element, parent);
+	} else
+		g_free(temp);
 
-	connman_element_register(element, parent);
+	g_static_mutex_unlock(&data->mutex);
 }
 
 static struct supplicant_callback wifi_callback = {

commit 908161662bbe796e2962929ff2131c9bae07f13e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jul 27 22:05:38 2008 +0200

    Fill README with details

diff --git a/README b/README
index e69de29b..f6be6fbf 100644
--- a/README
+++ b/README
@@ -0,0 +1,24 @@
+Connection Manager
+******************
+
+Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+
+
+Compilation and installation
+============================
+
+In order to compile libgdbus you need following software packages:
+	- GCC compiler
+	- GLib library
+	- D-Bus library
+	- GDBus library
+	- HAL library
+	- SQLite3 library
+
+To configure run:
+	./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var
+ 
+Configure automatically searches for all required components and packages. 
+
+To compile and install run:
+	make && make install

commit 8f4ff42f40e48954df28bdea79fcdfdb9e201418
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 29 22:35:31 2008 +0200

    Use configure.ac as it is the preferred name

diff --git a/configure.in b/configure.ac
similarity index 100%
rename from configure.in
rename to configure.ac

commit e7f97e6cfeb8e50356547663b23e1b8bd5097b70
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 29 23:34:45 2008 +0200

    Define CONNMAN_ELEMENT_TYPE_INTERNET

diff --git a/include/element.h b/include/element.h
index e000a587..48216618 100644
--- a/include/element.h
+++ b/include/element.h
@@ -50,7 +50,7 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 8,
 	CONNMAN_ELEMENT_TYPE_RESOLVER   = 9,
 
-	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
+	CONNMAN_ELEMENT_TYPE_INTERNET   = 42,
 };
 
 enum connman_element_subtype {
diff --git a/src/element.c b/src/element.c
index 1b49b805..4fd51a42 100644
--- a/src/element.c
+++ b/src/element.c
@@ -63,8 +63,8 @@ static const char *type2string(enum connman_element_type type)
 		return "zeroconf";
 	case CONNMAN_ELEMENT_TYPE_RESOLVER:
 		return "resolver";
-	case CONNMAN_ELEMENT_TYPE_CONNECTION:
-		return "42";
+	case CONNMAN_ELEMENT_TYPE_INTERNET:
+		return "internet";
 	}
 
 	return NULL;

commit 5fde7cb02abca746e442b18e8b251ccdeba276b9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 06:43:52 2008 +0200

    Remove the wpa_supplicant D-Bus scripts

diff --git a/.gitignore b/.gitignore
index c9a29fbc..c3a0edf1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -29,4 +29,3 @@ src/connman.ver
 src/connman.service
 scripts/connman
 scripts/dhclient-script
-scripts/fi.epitest.hostap.WPASupplicant.service
diff --git a/configure.ac b/configure.ac
index 8abdd137..64196c97 100644
--- a/configure.ac
+++ b/configure.ac
@@ -81,6 +81,5 @@ AC_SUBST(SQLITE_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
 			test/Makefile plugins/Makefile scripts/Makefile
-			scripts/fi.epitest.hostap.WPASupplicant.service
 			scripts/connman src/connman.service connman.pc)
 			
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index b860d5bd..1247398f 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -3,15 +3,7 @@ initdir = $(sysconfdir)/init.d
 
 init_SCRIPTS = connman
 
-dbusdir = $(sysconfdir)/dbus-1/system.d
-
-dbus_DATA = fi.epitest.hostap.WPASupplicant.conf
-
-servicedir = $(datadir)/dbus-1/system-services
-
-service_DATA = fi.epitest.hostap.WPASupplicant.service
-
-DISTCLEANFILES = $(init_SCRIPTS) $(service_DATA)
+DISTCLEANFILES = $(init_SCRIPTS)
 
 scriptdir = $(libdir)/connman/scripts
 
@@ -23,6 +15,6 @@ dhclient_script_LDADD = @DBUS_LIBS@
 
 AM_CFLAGS = @DBUS_CFLAGS@
 
-EXTRA_DIST = $(script_DATA) $(dbus_DATA)
+EXTRA_DIST = $(script_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/scripts/fi.epitest.hostap.WPASupplicant.conf b/scripts/fi.epitest.hostap.WPASupplicant.conf
deleted file mode 100644
index fa7afca0..00000000
--- a/scripts/fi.epitest.hostap.WPASupplicant.conf
+++ /dev/null
@@ -1,10 +0,0 @@
-<!DOCTYPE busconfig PUBLIC
- "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
- "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
-<busconfig>
-	<policy user="root">
-		<allow own="fi.epitest.hostap.WPASupplicant"/>
-		<allow send_destination="fi.epitest.hostap.WPASupplicant"/>
-		<allow send_interface="fi.epitest.hostap.WPASupplicant"/>
-	</policy>
-</busconfig>
diff --git a/scripts/fi.epitest.hostap.WPASupplicant.service.in b/scripts/fi.epitest.hostap.WPASupplicant.service.in
deleted file mode 100644
index cdd2a030..00000000
--- a/scripts/fi.epitest.hostap.WPASupplicant.service.in
+++ /dev/null
@@ -1,4 +0,0 @@
-[D-BUS Service]
-Name=fi.epitest.hostap.WPASupplicant
-Exec=@WPASUPPLICANT@ -u
-User=root

commit 598f0dcc0acd86fe84a693c2e84e7c89b6c3e81e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 07:43:16 2008 +0200

    Print error if interface registration fails

diff --git a/src/element.c b/src/element.c
index 4fd51a42..3a4d40f1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -631,10 +631,11 @@ static void register_element(gpointer data, gpointer user_data)
 
 	__connman_element_store(element);
 
-	g_dbus_register_interface(connection, element->path,
+	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_ELEMENT_INTERFACE,
 					element_methods, NULL, NULL,
-							element, NULL);
+						element, NULL) == FALSE)
+		connman_error("Failed to register %s", element->path);
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementAdded",

commit 6fe69067543ec09b4be1354c7b02a7307dc8fe7f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 07:43:37 2008 +0200

    Ignore broken network identifiers

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 30d94f29..9f93d966 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -68,6 +68,12 @@ static void scan_result(struct connman_element *parent,
 	if (data == NULL)
 		return;
 
+	if (network->identifier == NULL)
+		return;
+
+	if (network->identifier[0] == '\0')
+		return;
+
 	temp = g_strdup(network->identifier);
 
 	for (i = 0; i < strlen(temp); i++) {

commit df6b76be817b02329dd8eaa538fd9849e342d872
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 08:00:41 2008 +0200

    Add test program to list current networks

diff --git a/test/list-networks b/test/list-networks
new file mode 100755
index 00000000..72a9ad18
--- /dev/null
+++ b/test/list-networks
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+elements = manager.ListElements()
+
+for path in elements:
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	properties = element.GetProperties()
+
+	if (properties["Type"] == "device"):
+		print "[ %s ]" % (path)
+
+	if (properties["Type"] == "network"):
+		print "    %s" % (properties["SSID"])

commit d0274f2868275f4cb0dd0214f4972b84bed81884
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 08:01:40 2008 +0200

    Add static property for plain text SSID value

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 9f93d966..275a178e 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <string.h>
+#include <dbus/dbus.h>
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
@@ -95,6 +96,9 @@ static void scan_result(struct connman_element *parent,
 
 		data->list = g_slist_append(data->list, element);
 
+		connman_element_add_static_property(element, "SSID",
+				DBUS_TYPE_STRING, &network->identifier);
+
 		connman_element_register(element, parent);
 	} else
 		g_free(temp);

commit 426271d6f854493529c28632152dec25a6142a1d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 19:41:39 2008 +0200

    Quit when receiving D-Bus disconnect

diff --git a/src/main.c b/src/main.c
index d043b317..1c63f1e8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -46,6 +46,8 @@ static void sig_term(int sig)
 static void disconnect_callback(void *user_data)
 {
 	DBG("D-Bus disconnect");
+
+	g_main_loop_quit(main_loop);
 }
 
 static gchar *option_interface = NULL;

commit 664fc8eb9dae45273e2d34eb80c1b0bad093542e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 20:32:34 2008 +0200

    Bring Ethernet device up and down if needed

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 21ca7fcb..b9089409 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -25,6 +25,7 @@
 
 #include <unistd.h>
 #include <string.h>
+#include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <linux/if.h>
 #include <linux/netlink.h>
@@ -219,6 +220,92 @@ static int rtnl_request(void)
 			(struct sockaddr *) &addr, sizeof(addr));
 }
 
+static int iface_up(struct connman_element *element)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->netdev.index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ifr.ifr_flags & IFF_UP) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags |= IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}
+
+static int iface_down(struct connman_element *element)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->netdev.index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (!(ifr.ifr_flags & IFF_UP)) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags &= ~IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+		err = -errno;
+	else
+		err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}
+
 static int ethernet_probe(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
@@ -227,6 +314,8 @@ static int ethernet_probe(struct connman_element *element)
 	ethernet_list = g_slist_append(ethernet_list, element);
 	g_static_mutex_unlock(&ethernet_mutex);
 
+	iface_up(element);
+
 	rtnl_request();
 
 	return 0;
@@ -236,6 +325,8 @@ static void ethernet_remove(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
+	iface_down(element);
+
 	remove_elements(element);
 
 	g_static_mutex_lock(&ethernet_mutex);

commit 0a208a97b097a0ef33d002abde857feeb13b1b21
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 20:33:08 2008 +0200

    Add default name for Internet elements

diff --git a/src/element.c b/src/element.c
index 3a4d40f1..e24b1e01 100644
--- a/src/element.c
+++ b/src/element.c
@@ -556,6 +556,9 @@ int connman_element_register(struct connman_element *element,
 		case CONNMAN_ELEMENT_TYPE_RESOLVER:
 			element->name = g_strdup("resolver");
 			break;
+		case CONNMAN_ELEMENT_TYPE_INTERNET:
+			element->name = g_strdup("internet");
+			break;
 		default:
 			break;
 		}

commit 18e5d7d3de2d5dabb94f8a7c9f665f02bb5ae324
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 20:33:44 2008 +0200

    Execute resolvconf command and create Internet element

diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 45d15c37..b199646b 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -32,8 +32,9 @@
 static int resolvconf_probe(struct connman_element *element)
 {
 	const char *nameserver = NULL;
+	struct connman_element *internet;
 	gchar *cmd;
-	//int err;
+	int err;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -48,25 +49,42 @@ static int resolvconf_probe(struct connman_element *element)
 
 	DBG("%s", cmd);
 
-	//err = system(cmd);
+	err = system(cmd);
 
 	g_free(cmd);
 
+	internet = connman_element_create();
+
+	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
+
+	connman_element_set_data(element, internet);
+
+	connman_element_register(internet, element);
+
 	return 0;
 }
 
 static void resolvconf_remove(struct connman_element *element)
 {
+	struct connman_element *internet = connman_element_get_data(element);
 	gchar *cmd;
-	//int err;
+	int err;
 
 	DBG("element %p name %s", element, element->name);
 
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_set_data(element, NULL);
+
+	connman_element_unregister(internet);
+
+	connman_element_unref(internet);
+
 	cmd = g_strdup_printf("resolvconf -d %s", element->netdev.name);
 
 	DBG("%s", cmd);
 
-	//err = system(cmd);
+	err = system(cmd);
 
 	g_free(cmd);
 }

commit c2908070308fc8522dff68a4c2006b6e64b95693
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 20:34:25 2008 +0200

    Set IPv4 address and routing information

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 6d2e2a8c..9654c764 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -23,13 +23,160 @@
 #include <config.h>
 #endif
 
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <net/route.h>
+
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/log.h>
 
+enum connman_ipv4_method {
+	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
+	CONNMAN_IPV4_METHOD_OFF     = 1,
+	CONNMAN_IPV4_METHOD_STATIC  = 2,
+	CONNMAN_IPV4_METHOD_DHCP    = 3,
+};
+
+struct connman_ipv4 {
+	enum connman_ipv4_method method;
+	struct in_addr address;
+	struct in_addr netmask;
+	struct in_addr gateway;
+	struct in_addr network;
+	struct in_addr broadcast;
+	struct in_addr nameserver;
+};
+
+static int set_ipv4(struct connman_element *element,
+						struct connman_ipv4 *ipv4)
+{
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	DBG("element %p ipv4 %p", element, ipv4);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->netdev.index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->address;
+
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+
+	if (err < 0)
+		DBG("address setting failed (%s)", strerror(errno));
+
+	addr = (struct sockaddr_in *) &ifr.ifr_netmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->netmask;
+
+	err = ioctl(sk, SIOCSIFNETMASK, &ifr);
+
+	if (err < 0)
+		DBG("netmask setting failed (%s)", strerror(errno));
+
+	addr = (struct sockaddr_in *) &ifr.ifr_broadaddr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->broadcast;
+
+	err = ioctl(sk, SIOCSIFBRDADDR, &ifr);
+
+	if (err < 0)
+		DBG("broadcast setting failed (%s)", strerror(errno));
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr = ipv4->gateway;
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCADDRT, &rt);
+
+	close(sk);
+
+	if (err < 0) {
+		DBG("default route failed (%s)", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int clear_ipv4(struct connman_element *element)
+{
+	struct ifreq ifr;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->netdev.index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	//err = ioctl(sk, SIOCDIFADDR, &ifr);
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0 && errno != EADDRNOTAVAIL) {
+		DBG("address removal failed (%s)", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
 static int ipv4_probe(struct connman_element *element)
 {
 	struct connman_element *resolver;
+	struct connman_ipv4 ipv4;
 	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 
 	DBG("element %p name %s", element, element->name);
@@ -45,6 +192,13 @@ static int ipv4_probe(struct connman_element *element)
 	DBG("netmask %s", netmask);
 	DBG("gateway %s", gateway);
 
+	memset(&ipv4, 0, sizeof(ipv4));
+	ipv4.address.s_addr = inet_addr(address);
+	ipv4.netmask.s_addr = inet_addr(netmask);
+	ipv4.gateway.s_addr = inet_addr(gateway);
+
+	set_ipv4(element, &ipv4);
+
 	resolver = connman_element_create();
 
 	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
@@ -68,6 +222,8 @@ static void ipv4_remove(struct connman_element *element)
 	connman_element_unregister(resolver);
 
 	connman_element_unref(resolver);
+
+	clear_ipv4(element);
 }
 
 static struct connman_driver ipv4_driver = {

commit 03c9df24dec069902c415066c81554e4ff249aa7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 20:35:16 2008 +0200

    Use async D-Bus calls and support state change callback

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index d387c954..3fd3cb9e 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -30,21 +30,12 @@
 
 #include "supplicant.h"
 
+#define TIMEOUT 5000
+
 #define IEEE80211_CAP_ESS       0x0001
 #define IEEE80211_CAP_IBSS      0x0002
 #define IEEE80211_CAP_PRIVACY   0x0010
 
-enum supplicant_state {
-	STATE_INACTIVE,
-	STATE_SCANNING,
-	STATE_ASSOCIATING,
-	STATE_ASSOCIATED,
-	STATE_4WAY_HANDSHAKE,
-	STATE_GROUP_HANDSHAKE,
-	STATE_COMPLETED,
-	STATE_DISCONNECTED,
-};
-
 struct supplicant_task {
 	DBusConnection *conn;
 	int ifindex;
@@ -558,8 +549,8 @@ static int set_network(struct supplicant_task *task, const char *network,
 
 static int initiate_scan(struct supplicant_task *task)
 {
-	DBusMessage *message, *reply;
-	DBusError error;
+	DBusMessage *message;
+	DBusPendingCall *call;
 
 	DBG("task %p", task);
 
@@ -568,24 +559,15 @@ static int initiate_scan(struct supplicant_task *task)
 	if (message == NULL)
 		return -ENOMEM;
 
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to initiate scan");
+	if (dbus_connection_send_with_reply(task->conn, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to initiate scan");
 		dbus_message_unref(message);
 		return -EIO;
 	}
 
 	dbus_message_unref(message);
 
-	dbus_message_unref(reply);
-
 	return 0;
 }
 
@@ -643,17 +625,22 @@ static void extract_capabilites(struct supplicant_network *network,
 		network->has_wep = TRUE;
 }
 
-static int parse_network_properties(struct supplicant_task *task,
-							DBusMessage *message)
+static void properties_reply(DBusPendingCall *call, void *user_data)
 {
-	DBusMessageIter array, dict;
+	struct supplicant_task *task = user_data;
 	struct supplicant_network *network;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("task %p", task);
+
+	reply = dbus_pending_call_steal_reply(call);
 
 	network = g_try_new0(struct supplicant_network, 1);
 	if (network == NULL)
-		return -ENOMEM;
+		goto done;
 
-	dbus_message_iter_init(message, &array);
+	dbus_message_iter_init(reply, &array);
 
 	dbus_message_iter_recurse(&array, &dict);
 
@@ -688,14 +675,15 @@ static int parse_network_properties(struct supplicant_task *task,
 
 	g_free(network);
 
-	return 0;
+done:
+	dbus_message_unref(reply);
 }
 
 static int get_network_properties(struct supplicant_task *task,
 							const char *path)
 {
-	DBusMessage *message, *reply;
-	DBusError error;
+	DBusMessage *message;
+	DBusPendingCall *call;
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, path,
 						SUPPLICANT_INTF ".BSSID",
@@ -703,59 +691,31 @@ static int get_network_properties(struct supplicant_task *task,
 	if (message == NULL)
 		return -ENOMEM;
 
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to get network properties");
+	if (dbus_connection_send_with_reply(task->conn, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get network properties");
 		dbus_message_unref(message);
 		return -EIO;
 	}
 
-	dbus_message_unref(message);
-
-	parse_network_properties(task, reply);
+	dbus_pending_call_set_notify(call, properties_reply, task, NULL);
 
-	dbus_message_unref(reply);
+	dbus_message_unref(message);
 
 	return 0;
 }
 
-static int scan_results_available(struct supplicant_task *task)
+static void scan_results_reply(DBusPendingCall *call, void *user_data)
 {
-	DBusMessage *message, *reply;
+	struct supplicant_task *task = user_data;
+	DBusMessage *reply;
 	DBusError error;
 	char **results;
 	int i, num_results;
 
 	DBG("task %p", task);
 
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
-						SUPPLICANT_INTF ".Interface",
-							"scanResults");
-	if (message == NULL)
-		return -ENOMEM;
-
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to request scan result");
-		dbus_message_unref(message);
-		return -EIO;
-	}
-
-	dbus_message_unref(message);
+	reply = dbus_pending_call_steal_reply(call);
 
 	dbus_error_init(&error);
 
@@ -768,8 +728,7 @@ static int scan_results_available(struct supplicant_task *task)
 			dbus_error_free(&error);
 		} else
 			connman_error("Wrong arguments for scan result");
-		dbus_message_unref(reply);
-		return -EIO;
+		goto done;
 	}
 
 	for (i = 0; i < num_results; i++)
@@ -777,7 +736,33 @@ static int scan_results_available(struct supplicant_task *task)
 
 	g_strfreev(results);
 
+done:
 	dbus_message_unref(reply);
+}
+
+static int scan_results_available(struct supplicant_task *task)
+{
+	DBusMessage *message;
+	DBusPendingCall *call;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
+						SUPPLICANT_INTF ".Interface",
+							"scanResults");
+	if (message == NULL)
+		return -ENOMEM;
+
+	if (dbus_connection_send_with_reply(task->conn, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to request scan result");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_pending_call_set_notify(call, scan_results_reply, task, NULL);
+
+	dbus_message_unref(message);
 
 	return 0;
 }
@@ -819,6 +804,9 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
 		task->state = STATE_DISCONNECTED;
 
+	if (task->callback && task->callback->state_change)
+		task->callback->state_change(task->element, task->state);
+
 	switch (task->state) {
 	case STATE_COMPLETED:
 		/* carrier on */
@@ -1019,7 +1007,7 @@ int __supplicant_scan(struct connman_element *element)
 	return 0;
 }
 
-int __supplicant_connect(struct connman_element *element)
+int __supplicant_connect(struct connman_element *element, const char *ssid)
 {
 	struct supplicant_task *task;
 
@@ -1034,7 +1022,7 @@ int __supplicant_connect(struct connman_element *element)
 	select_network(task);
 	disable_network(task);
 
-	set_network(task, NULL, NULL);
+	set_network(task, ssid, NULL);
 
 	enable_network(task);
 
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 3ba062a5..9b4f6eb4 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -25,6 +25,17 @@
 #define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
 #define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
 
+enum supplicant_state {
+	STATE_INACTIVE,
+	STATE_SCANNING,
+	STATE_ASSOCIATING,
+	STATE_ASSOCIATED,
+	STATE_4WAY_HANDSHAKE,
+	STATE_GROUP_HANDSHAKE,
+	STATE_COMPLETED,
+	STATE_DISCONNECTED,
+};
+
 struct supplicant_network {
 	gchar *identifier;
 	GByteArray *ssid;
@@ -35,6 +46,8 @@ struct supplicant_network {
 };
 
 struct supplicant_callback {
+	void (*state_change) (struct connman_element *element,
+						enum supplicant_state state);
 	void (*scan_result) (struct connman_element *element,
 					struct supplicant_network *network);
 };
@@ -45,5 +58,5 @@ int __supplicant_stop(struct connman_element *element);
 
 int __supplicant_scan(struct connman_element *element);
 
-int __supplicant_connect(struct connman_element *element);
+int __supplicant_connect(struct connman_element *element, const char *ssid);
 int __supplicant_disconnect(struct connman_element *element);

commit 8e0a0c3a63075f0769fd909c574ee264671e1da1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 22:15:54 2008 +0200

    Fix network selection and add network disconnect scripts

diff --git a/test/disable-network b/test/disable-network
new file mode 100755
index 00000000..645fa5d3
--- /dev/null
+++ b/test/disable-network
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+elements = manager.ListElements()
+
+for path in elements:
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	properties = element.GetProperties()
+	if (properties["Type"] != "network"):
+		continue
+
+	if (properties["Connected"] == dbus.Boolean(1)):
+		print "Disconnecting %s" % (path)
+		element.Disconnect()
diff --git a/test/select-network b/test/select-network
index 7de8d65c..2d5b2b1e 100755
--- a/test/select-network
+++ b/test/select-network
@@ -1,32 +1,30 @@
 #!/usr/bin/python
 
+import sys
 import dbus
 
-bus = dbus.SystemBus()
-
-manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
-					'org.moblin.connman.Manager')
+if (len(sys.argv) < 2):
+	print "Usage: %s <network>" % (sys.argv[0])
+	sys.exit(1)
 
-interfaces = manager.ListInterfaces()
+bus = dbus.SystemBus()
 
-for path in interfaces:
-	print "[ %s ]" % (path)
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
 
-	interface = dbus.Interface(bus.get_object('org.moblin.connman', path),
-					'org.moblin.connman.Interface')
+elements = manager.ListElements()
 
-	properties = interface.GetProperties()
+for path in elements:
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
 
-	if (properties["Type"] == "80211"):
-		networks = interface.ListNetworks()
-		for i in networks:
-			network = dbus.Interface(bus.get_object('org.moblin.connman', i),
-						'org.moblin.connman.Network')
+	properties = element.GetProperties()
+	if (properties["Type"] != "network"):
+		continue
 
-			if (network.GetIdentifier() == "ConnMan Testing"):
-				print "   Selecting network %s" % (i)
-				interface.SelectNetwork(i)
-	else:
-		print "   No networks"
+	if (properties["Connected"] == dbus.Boolean(1)):
+		continue
 
-	print
+	if (properties["Identifier"] == sys.argv[1]):
+		print "Connecting %s" % (path)
+		element.Connect()

commit 6d23265f3ef64912639e5d460ef4b74380e14f10
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 22:16:37 2008 +0200

    Add support for connected property

diff --git a/include/element.h b/include/element.h
index 48216618..fb4f70fc 100644
--- a/include/element.h
+++ b/include/element.h
@@ -72,6 +72,7 @@ struct connman_element {
 	enum connman_element_type type;
 	enum connman_element_subtype subtype;
 	enum connman_element_state state;
+	gboolean connected;
 	guint16 priority;
 
 	struct connman_element *parent;
diff --git a/src/element.c b/src/element.c
index e24b1e01..4bdfb845 100644
--- a/src/element.c
+++ b/src/element.c
@@ -102,6 +102,9 @@ static void append_entry(DBusMessageIter *dict,
 	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
 
 	switch (type) {
+	case DBUS_TYPE_BOOLEAN:
+		signature = DBUS_TYPE_BOOLEAN_AS_STRING;
+		break;
 	case DBUS_TYPE_STRING:
 		signature = DBUS_TYPE_STRING_AS_STRING;
 		break;
@@ -170,6 +173,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	if (str != NULL)
 		append_entry(&dict, "Subtype", DBUS_TYPE_STRING, &str);
 
+	append_entry(&dict, "Connected",
+				DBUS_TYPE_BOOLEAN, &element->connected);
+
 	if (element->priority > 0)
 		append_entry(&dict, "Priority",
 				DBUS_TYPE_UINT16, &element->priority);
@@ -199,8 +205,46 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *do_connect(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+
+	DBG("conn %p", conn);
+
+	if (element->driver == NULL)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	if (element->driver->connect) {
+		DBG("Calling connect callback");
+		element->driver->connect(element);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *do_disconnect(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+
+	DBG("conn %p", conn);
+
+	if (element->driver == NULL)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	if (element->driver->disconnect) {
+		DBG("Calling disconnect callback");
+		element->driver->disconnect(element);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static GDBusMethodTable element_methods[] = {
 	{ "GetProperties", "", "a{sv}", get_properties },
+	{ "Connect",       "", "",      do_connect     },
+	{ "Disconnect",    "", "",      do_disconnect  },
 	{ },
 };
 
@@ -357,6 +401,8 @@ struct connman_element *connman_element_create(void)
 	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
 
+	element->connected = FALSE;
+
 	element->netdev.index = -1;
 
 	return element;

commit e3e75cb4135323aee1f2e2bf08e4f4841ec0d1f1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 30 22:54:24 2008 +0200

    Add simple test script to monitor states

diff --git a/test/Makefile.am b/test/Makefile.am
index 9a05de97..08335525 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,6 +1,6 @@
 
-EXTRA_DIST = list-elements monitor-elements \
-		start-scanning select-network simple-agent \
+EXTRA_DIST = list-elements monitor-elements monitor-state \
+		start-scanning select-network disable-network simple-agent \
 		get-state show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/disable-network b/test/disable-network
index 645fa5d3..12da1e83 100755
--- a/test/disable-network
+++ b/test/disable-network
@@ -13,10 +13,13 @@ for path in elements:
 	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Element")
 
-	properties = element.GetProperties()
-	if (properties["Type"] != "network"):
-		continue
+	try:
+		properties = element.GetProperties()
+		if (properties["Type"] != "network"):
+			continue
 
-	if (properties["Connected"] == dbus.Boolean(1)):
-		print "Disconnecting %s" % (path)
-		element.Disconnect()
+		if (properties["Connected"] == dbus.Boolean(1)):
+			print "Disconnecting %s" % (path)
+			element.Disconnect()
+	except:
+		pass
diff --git a/test/monitor-state b/test/monitor-state
new file mode 100755
index 00000000..d17c0e5a
--- /dev/null
+++ b/test/monitor-state
@@ -0,0 +1,57 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+
+internet_path = ""
+
+def get_properties(path):
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	return element.GetProperties()
+
+def element_added(path):
+	global internet_path
+	properties = get_properties(path)
+	if (properties["Type"] == "dhcp"):
+		print "Aquiring IP address"
+	if (properties["Type"] == "ipv4"):
+		print "IP address assigned"
+	if (properties["Type"] == "internet"):
+		internet_path = path
+		print "Succesfully connected"
+
+def element_updated(path):
+	properties = get_properties(path)
+	if (properties["Type"] == "network" and properties["Connected"] == 1):
+		print "Associated with %s" % (properties["SSID"])
+
+def element_removed(path):
+	global internet_path
+	if (path == internet_path):
+		internet_path = ""
+		print "Connection terminated"
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+
+	bus.add_signal_receiver(element_added,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementAdded")
+
+	bus.add_signal_receiver(element_updated,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementUpdated")
+
+	bus.add_signal_receiver(element_removed,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementRemoved")
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()

commit a2e26b701c4017b6ea8acfd21d7c18be365b399d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 31 00:58:57 2008 +0200

    Add support for Update method via D-Bus

diff --git a/src/element.c b/src/element.c
index 4bdfb845..56cba84a 100644
--- a/src/element.c
+++ b/src/element.c
@@ -205,6 +205,24 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *do_update(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+
+	DBG("conn %p", conn);
+
+	if (element->driver == NULL)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	if (element->driver->update) {
+		DBG("Calling update callback");
+		element->driver->update(element);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *do_connect(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -243,6 +261,7 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 
 static GDBusMethodTable element_methods[] = {
 	{ "GetProperties", "", "a{sv}", get_properties },
+	{ "Update",        "", "",      do_update      },
 	{ "Connect",       "", "",      do_connect     },
 	{ "Disconnect",    "", "",      do_disconnect  },
 	{ },

commit 51671d4aa4c0e487e875c960510cea0da2749bf1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 31 01:00:21 2008 +0200

    Fix broken start-scanning test script

diff --git a/test/start-scanning b/test/start-scanning
index b5933231..9b5878b0 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -7,19 +7,22 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
 					'org.moblin.connman.Manager')
 
-interfaces = manager.ListInterfaces()
+elements = manager.ListElements()
 
-for path in interfaces:
-	print "[ %s ]" % (path)
+for path in elements:
+	element = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Element')
+
+	properties = element.GetProperties()
 
-	interface = dbus.Interface(bus.get_object('org.moblin.connman', path),
-					'org.moblin.connman.Interface')
+	if (properties["Type"] != "device"):
+		continue
 
-	properties = interface.GetProperties()
+	print "[ %s ]" % (path)
 
-	if (properties["Type"] == "80211"):
+	if (properties["Subtype"] == "wifi"):
 		print "   Started scanning"
-		interface.Scan()
+		element.Update()
 	else:
 		print "   No scanning"
 

commit 081e214a6fba5282fd9561e52e2edc202b55b964
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 31 17:06:48 2008 +0200

    Add skeleton for setting properties via D-Bus

diff --git a/src/element.c b/src/element.c
index 56cba84a..5537e414 100644
--- a/src/element.c
+++ b/src/element.c
@@ -205,6 +205,12 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *do_update(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -260,10 +266,11 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 }
 
 static GDBusMethodTable element_methods[] = {
-	{ "GetProperties", "", "a{sv}", get_properties },
-	{ "Update",        "", "",      do_update      },
-	{ "Connect",       "", "",      do_connect     },
-	{ "Disconnect",    "", "",      do_disconnect  },
+	{ "GetProperties", "",   "a{sv}", get_properties },
+	{ "SetProperty",   "sv", "",      set_property   },
+	{ "Update",        "",   "",      do_update      },
+	{ "Connect",       "",   "",      do_connect     },
+	{ "Disconnect",    "",   "",      do_disconnect  },
 	{ },
 };
 

commit ed776f9ab57e249da21b3bfd7da5848d2263c5b1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Aug 5 02:38:14 2008 +0200

    Fix selecting network device

diff --git a/src/connman.h b/src/connman.h
index 5f642861..df1aabb7 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -52,7 +52,7 @@ void __connman_plugin_cleanup(void);
 #include <connman/driver.h>
 #include <connman/element.h>
 
-int __connman_element_init(DBusConnection *conn);
+int __connman_element_init(DBusConnection *conn, const char *device);
 void __connman_element_cleanup(void);
 
 void __connman_element_list(enum connman_element_type type,
diff --git a/src/element.c b/src/element.c
index 5537e414..7c892e64 100644
--- a/src/element.c
+++ b/src/element.c
@@ -40,6 +40,8 @@ static GSList *driver_list = NULL;
 static GThreadPool *thread_register = NULL;
 static GThreadPool *thread_unregister = NULL;
 
+static gchar *device_filter = NULL;
+
 static const char *type2string(enum connman_element_type type)
 {
 	switch (type) {
@@ -601,6 +603,11 @@ int connman_element_register(struct connman_element *element,
 {
 	DBG("element %p name %s parent %p", element, element->name, parent);
 
+	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+		if (g_str_equal(device_filter, element->netdev.name) == FALSE)
+			return -EINVAL;
+	}
+
 	if (connman_element_ref(element) == NULL)
 		return -EINVAL;
 
@@ -788,7 +795,7 @@ static void unregister_element(gpointer data, gpointer user_data)
 	connman_element_unref(element);
 }
 
-int __connman_element_init(DBusConnection *conn)
+int __connman_element_init(DBusConnection *conn, const char *device)
 {
 	struct connman_element *element;
 
@@ -798,6 +805,8 @@ int __connman_element_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -EIO;
 
+	device_filter = g_strdup(device);
+
 	g_static_rw_lock_writer_lock(&element_lock);
 
 	element = connman_element_create();
@@ -873,5 +882,7 @@ void __connman_element_cleanup(void)
 	element_root = NULL;
 	g_static_rw_lock_writer_unlock(&element_lock);
 
+	g_free(device_filter);
+
 	dbus_connection_unref(connection);
 }
diff --git a/src/main.c b/src/main.c
index 1c63f1e8..3a5990b5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -50,14 +50,14 @@ static void disconnect_callback(void *user_data)
 	g_main_loop_quit(main_loop);
 }
 
-static gchar *option_interface = NULL;
+static gchar *option_device = NULL;
 static gboolean option_detach = TRUE;
 static gboolean option_compat = FALSE;
 static gboolean option_debug = FALSE;
 
 static GOptionEntry options[] = {
-	{ "interface", 'i', 0, G_OPTION_ARG_STRING, &option_interface,
-				"Specify network interface", "IFACE" },
+	{ "device", 'i', 0, G_OPTION_ARG_STRING, &option_device,
+				"Specify network device/interface", "DEV" },
 	{ "nodaemon", 'n', G_OPTION_FLAG_REVERSE,
 				G_OPTION_ARG_NONE, &option_detach,
 				"Don't fork daemon to background" },
@@ -138,7 +138,7 @@ int main(int argc, char *argv[])
 
 	__connman_storage_init();
 
-	__connman_element_init(conn);
+	__connman_element_init(conn, option_device);
 
 	__connman_agent_init(conn);
 
@@ -146,7 +146,7 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
-	g_free(option_interface);
+	g_free(option_device);
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;

commit 5734f815db47e848c34bb84cd05293134652f635
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 7 04:10:12 2008 +0200

    Show the connected value for each network

diff --git a/test/list-networks b/test/list-networks
index 72a9ad18..d3fa34d9 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -19,4 +19,8 @@ for path in elements:
 		print "[ %s ]" % (path)
 
 	if (properties["Type"] == "network"):
-		print "    %s" % (properties["SSID"])
+		if (properties["Connected"] == 1):
+			state = "*"
+		else:
+			state = " "
+		print "    %s %s" % (state, properties["SSID"])

commit aa549a200ff5b44782935501dc1d0e20de62bd5d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 7 09:21:46 2008 +0200

    Add initial skeleton for profile support

diff --git a/src/Makefile.am b/src/Makefile.am
index a1a7dac8..e4ad9540 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,8 +11,8 @@ DISTCLEANFILES = $(service_DATA)
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h log.c plugin.c element.c \
-					storage.c manager.c agent.c
+connmand_SOURCES = main.c connman.h log.c plugin.c profile.c element.c \
+						storage.c manager.c agent.c
 
 connmand_LDADD = @SQLITE_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
 
diff --git a/src/connman.h b/src/connman.h
index df1aabb7..47d44f93 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -39,6 +39,8 @@ void __connman_agent_cleanup(void);
 int __connman_agent_register(const char *sender, const char *path);
 int __connman_agent_unregister(const char *sender, const char *path);
 
+void __connman_profile_list(DBusMessageIter *iter);
+
 #include <connman/log.h>
 
 int __connman_log_init(gboolean detach, gboolean debug);
diff --git a/src/manager.c b/src/manager.c
index 8ba4f027..c4ea0fb8 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -75,6 +75,30 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *list_profiles(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, iter;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_profile_list(&iter);
+
+	dbus_message_iter_close_container(&array, &iter);
+
+	return reply;
+}
+
 static DBusMessage *list_elements(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -127,6 +151,8 @@ static GDBusMethodTable manager_methods[] = {
 	{ "RegisterAgent",   "o", "", register_agent   },
 	{ "UnregisterAgent", "o", "", unregister_agent },
 
+	{ "ListProfiles", "", "ao", list_profiles },
+
 	{ "ListElements", "", "ao", list_elements },
 	{ "ListDevices",  "", "ao", list_devices  },
 	{ },
diff --git a/src/profile.c b/src/profile.c
new file mode 100644
index 00000000..62d90668
--- /dev/null
+++ b/src/profile.c
@@ -0,0 +1,38 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+#include <gdbus.h>
+
+#include "connman.h"
+
+void __connman_profile_list(DBusMessageIter *iter)
+{
+	const char *path = "/profile/default";
+
+	DBG("");
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
+}

commit efadc037b1fd86443fdff951214eb3b57a14c879
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 7 09:24:22 2008 +0200

    Add support for network scanning and selection

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 275a178e..b4a3b8f0 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -32,6 +32,72 @@
 
 #include "supplicant.h"
 
+static struct connman_element *dhcp_element = NULL;
+
+static int network_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	return 0;
+}
+
+static void network_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static int network_connect(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	if (dhcp_element != NULL) {
+		connman_element_unregister(dhcp_element);
+		dhcp_element = NULL;
+	}
+
+	__supplicant_disconnect(element);
+
+	element->connected = FALSE;
+
+	connman_element_update(element);
+
+	g_free(element->parent->network.identifier);
+	element->parent->network.identifier = element->network.identifier;
+
+	if (__supplicant_connect(element, element->network.identifier) < 0)
+		connman_error("Failed to initiate connect");
+
+	return 0;
+}
+
+static int network_disconnect(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	if (dhcp_element != NULL) {
+		connman_element_unregister(dhcp_element);
+		dhcp_element = NULL;
+	}
+
+	__supplicant_disconnect(element);
+
+	element->connected = FALSE;
+
+	connman_element_update(element);
+
+	return 0;
+}
+
+static struct connman_driver network_driver = {
+	.name		= "wifi-network",
+	.type		= CONNMAN_ELEMENT_TYPE_NETWORK,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_WIFI,
+	.probe		= network_probe,
+	.remove		= network_remove,
+	.connect	= network_connect,
+	.disconnect	= network_disconnect,
+};
+
 struct wifi_data {
 	GStaticMutex mutex;
 	GSList *list;
@@ -56,6 +122,40 @@ static struct connman_element *find_element(struct wifi_data *data,
 	return NULL;
 }
 
+static void state_change(struct connman_element *parent,
+						enum supplicant_state state)
+{
+	struct wifi_data *data = connman_element_get_data(parent);
+	struct connman_element *element;
+
+	DBG("state %d", state);
+
+	if (parent->network.identifier == NULL)
+		return;
+
+	element = find_element(data, parent->network.identifier);
+	if (element == NULL)
+		return;
+
+	if (state == STATE_COMPLETED) {
+		struct connman_element *dhcp;
+
+		dhcp = connman_element_create();
+
+		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
+		dhcp->netdev.index = element->netdev.index;
+		dhcp->netdev.name = g_strdup(element->netdev.name);
+
+		dhcp_element = dhcp;
+
+		element->connected = TRUE;
+
+		connman_element_update(element);
+
+		connman_element_register(dhcp, element);
+	}
+}
+
 static void scan_result(struct connman_element *parent,
 					struct supplicant_network *network)
 {
@@ -78,21 +178,28 @@ static void scan_result(struct connman_element *parent,
 	temp = g_strdup(network->identifier);
 
 	for (i = 0; i < strlen(temp); i++) {
-		if (temp[i] == ' ' || temp[i] == '.')
+		if (temp[i] == ' ' || temp[i] == '.' || temp[i] == '-')
+			temp[i] = '_';
+		if (temp[i] == '(' || temp[i] == ')')
+			temp[i] = '_';
+		if (g_ascii_isprint(temp[i]) == FALSE)
 			temp[i] = '_';
 		temp[i] = g_ascii_tolower(temp[i]);
 	}
 
 	g_static_mutex_lock(&data->mutex);
 
-	element = find_element(data, temp);
+	element = find_element(data, network->identifier);
 	if (element == NULL) {
 		element = connman_element_create();
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
 		element->name = temp;
 
-		element->network.identifier = g_strdup(temp);
+		element->network.identifier = g_strdup(network->identifier);
+
+		element->netdev.index = parent->netdev.index;
+		element->netdev.name = g_strdup(parent->netdev.name);
 
 		data->list = g_slist_append(data->list, element);
 
@@ -107,6 +214,7 @@ static void scan_result(struct connman_element *parent,
 }
 
 static struct supplicant_callback wifi_callback = {
+	.state_change	= state_change,
 	.scan_result	= scan_result,
 };
 
@@ -164,21 +272,44 @@ static void wifi_remove(struct connman_element *element)
 	g_free(data);
 }
 
+static int wifi_update(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	__supplicant_scan(element);
+
+	return 0;
+}
+
 static struct connman_driver wifi_driver = {
-	.name		= "wifi",
+	.name		= "wifi-device",
 	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
 	.subtype	= CONNMAN_ELEMENT_SUBTYPE_WIFI,
 	.probe		= wifi_probe,
 	.remove		= wifi_remove,
+	.update		= wifi_update,
 };
 
 static int wifi_init(void)
 {
-	return connman_driver_register(&wifi_driver);
+	int err;
+
+	err = connman_driver_register(&network_driver);
+	if (err < 0)
+		return err;
+
+	err = connman_driver_register(&wifi_driver);
+	if (err < 0) {
+		connman_driver_unregister(&network_driver);
+		return err;
+	}
+
+	return 0;
 }
 
 static void wifi_exit(void)
 {
+	connman_driver_unregister(&network_driver);
 	connman_driver_unregister(&wifi_driver);
 }
 

commit f3ce64de7eb5cffd32dafe6388b8425a5bec137a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 7 09:40:27 2008 +0200

    Add object path for the default profile

diff --git a/include/dbus.h b/include/dbus.h
index be98a4ef..a76aea24 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -36,6 +36,8 @@ extern "C" {
 
 #define CONNMAN_ELEMENT_INTERFACE  CONNMAN_SERVICE ".Element"
 
+#define CONNMAN_PROFILE_INTERFACE  CONNMAN_SERVICE ".Profile"
+
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 #define CONNMAN_MANAGER_PATH       "/"
 
diff --git a/src/connman.h b/src/connman.h
index 47d44f93..4249f33f 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -39,6 +39,9 @@ void __connman_agent_cleanup(void);
 int __connman_agent_register(const char *sender, const char *path);
 int __connman_agent_unregister(const char *sender, const char *path);
 
+int __connman_profile_init(DBusConnection *conn);
+void __connman_profile_cleanup(void);
+
 void __connman_profile_list(DBusMessageIter *iter);
 
 #include <connman/log.h>
diff --git a/src/main.c b/src/main.c
index 3a5990b5..5f8b4876 100644
--- a/src/main.c
+++ b/src/main.c
@@ -144,6 +144,8 @@ int main(int argc, char *argv[])
 
 	__connman_manager_init(conn, option_compat);
 
+	__connman_profile_init(conn);
+
 	__connman_plugin_init();
 
 	g_free(option_device);
@@ -159,6 +161,8 @@ int main(int argc, char *argv[])
 
 	__connman_element_cleanup();
 
+	__connman_profile_cleanup();
+
 	__connman_manager_cleanup();
 
 	__connman_storage_cleanup();
diff --git a/src/profile.c b/src/profile.c
index 62d90668..223ea434 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -36,3 +36,38 @@ void __connman_profile_list(DBusMessageIter *iter)
 
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
+
+static GDBusMethodTable profile_methods[] = {
+	{ },
+};
+
+static DBusConnection *connection = NULL;
+
+int __connman_profile_init(DBusConnection *conn)
+{
+	DBG("conn %p", conn);
+
+	connection = dbus_connection_ref(conn);
+	if (connection == NULL)
+		return -1;
+
+	g_dbus_register_interface(connection, "/profile/default",
+						CONNMAN_PROFILE_INTERFACE,
+						profile_methods,
+						NULL, NULL, NULL, NULL);
+
+	return 0;
+}
+
+void __connman_profile_cleanup(void)
+{
+	DBG("conn %p", connection);
+
+	g_dbus_unregister_interface(connection, "/profile/default",
+						CONNMAN_PROFILE_INTERFACE);
+
+	if (connection == NULL)
+		return;
+
+	dbus_connection_unref(connection);
+}

commit 992a6e463a381c220b50f9ebfe36a14599c25834
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 7 09:51:00 2008 +0200

    Add resolver plugin for /etc/resolv.conf modifications

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 121e05a5..ea857558 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,7 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = hal.la ethernet.la wifi.la bluetooth.la \
-					dhclient.la ipv4.la resolvconf.la
+			dhclient.la ipv4.la resolvconf.la resolvfile.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
@@ -22,6 +22,8 @@ ipv4_la_SOURCES = ipv4.c
 
 resolvconf_la_SOURCES = resolvconf.c
 
+resolvfile_la_SOURCES = resolvfile.c
+
 AM_LDFLAGS = -no-undefined -module -avoid-version \
 				-export-symbols-regex connman_plugin_desc
 
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index b199646b..1d4927b5 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -72,8 +72,6 @@ static void resolvconf_remove(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	DBG("element %p name %s", element, element->name);
-
 	connman_element_set_data(element, NULL);
 
 	connman_element_unregister(internet);
@@ -92,6 +90,7 @@ static void resolvconf_remove(struct connman_element *element)
 static struct connman_driver resolvconf_driver = {
 	.name		= "resolvconf",
 	.type		= CONNMAN_ELEMENT_TYPE_RESOLVER,
+	.priority	= CONNMAN_DRIVER_PRIORITY_HIGH,
 	.probe		= resolvconf_probe,
 	.remove		= resolvconf_remove,
 };
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
new file mode 100644
index 00000000..d39b2e1d
--- /dev/null
+++ b/plugins/resolvfile.c
@@ -0,0 +1,99 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static int resolvfile_probe(struct connman_element *element)
+{
+	const char *nameserver = NULL;
+	struct connman_element *internet;
+	gchar *cmd;
+	int err;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_get_value(element,
+			CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER, &nameserver);
+
+	if (nameserver == NULL)
+		return -EINVAL;
+
+	cmd = g_strdup_printf("echo \"nameserver %s\" > /etc/resolv.conf",
+								nameserver);
+
+	DBG("%s", cmd);
+
+	err = system(cmd);
+
+	g_free(cmd);
+
+	internet = connman_element_create();
+
+	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
+
+	connman_element_set_data(element, internet);
+
+	connman_element_register(internet, element);
+
+	return 0;
+}
+
+static void resolvfile_remove(struct connman_element *element)
+{
+	struct connman_element *internet = connman_element_get_data(element);
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_set_data(element, NULL);
+
+	connman_element_unregister(internet);
+
+	connman_element_unref(internet);
+}
+
+static struct connman_driver resolvfile_driver = {
+	.name		= "resolvconf",
+	.type		= CONNMAN_ELEMENT_TYPE_RESOLVER,
+	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
+	.probe		= resolvfile_probe,
+	.remove		= resolvfile_remove,
+};
+
+static int resolvfile_init(void)
+{
+	return connman_driver_register(&resolvfile_driver);
+}
+
+static void resolvfile_exit(void)
+{
+	connman_driver_unregister(&resolvfile_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("resolvfile", "Name resolver plugin", VERSION,
+					resolvfile_init, resolvfile_exit)

commit f70d1758c876780c9dabe5b717550a54b194aab3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 7 10:23:16 2008 +0200

    Add properties to the profile interface

diff --git a/src/profile.c b/src/profile.c
index 223ea434..057ece7e 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -37,7 +37,52 @@ void __connman_profile_list(DBusMessageIter *iter)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
+static void append_string(DBusMessageIter *dict, const char *key, void *val)
+{
+	DBusMessageIter entry, value;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_STRING_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	const char *name = "Default";
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_string(&dict, "Name", &name);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
 static GDBusMethodTable profile_methods[] = {
+	{ "GetProperties", "", "a{sv}", get_properties },
 	{ },
 };
 
diff --git a/test/Makefile.am b/test/Makefile.am
index 08335525..9b640ea3 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,5 +1,5 @@
 
-EXTRA_DIST = list-elements monitor-elements monitor-state \
+EXTRA_DIST = list-profiles list-elements monitor-elements monitor-state \
 		start-scanning select-network disable-network simple-agent \
 		get-state show-introspection test-compat test-supplicant
 
diff --git a/test/list-profiles b/test/list-profiles
new file mode 100755
index 00000000..fcf1830c
--- /dev/null
+++ b/test/list-profiles
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+profiles = manager.ListProfiles()
+
+for path in profiles:
+	print "[ %s ]" % (path)
+
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Profile")
+
+	properties = element.GetProperties()
+	for key in properties.keys():
+		print "    %s = %s" % (key, properties[key])
+
+	print

commit 51818dc258152d9578c78219eb6fe32e5e94c84e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 9 04:30:21 2008 +0200

    Add basics for a global RTNL engine

diff --git a/include/Makefile.am b/include/Makefile.am
index 70c39d27..1844d986 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,9 +1,9 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h driver.h element.h property.h dbus.h
+include_HEADERS = log.h plugin.h driver.h element.h property.h rtnl.h dbus.h
 
-noinst_HEADERS = iface.h rtnl.h dhcp.h resolver.h
+noinst_HEADERS = iface.h dhcp.h resolver.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/src/Makefile.am b/src/Makefile.am
index e4ad9540..f959379f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,7 +12,7 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c plugin.c profile.c element.c \
-						storage.c manager.c agent.c
+					storage.c manager.c agent.c rtnl.c
 
 connmand_LDADD = @SQLITE_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
 
diff --git a/src/main.c b/src/main.c
index 5f8b4876..77dff018 100644
--- a/src/main.c
+++ b/src/main.c
@@ -146,6 +146,8 @@ int main(int argc, char *argv[])
 
 	__connman_profile_init(conn);
 
+	__connman_rtnl_init();
+
 	__connman_plugin_init();
 
 	g_free(option_device);
@@ -157,6 +159,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_rtnl_cleanup();
+
 	__connman_agent_cleanup();
 
 	__connman_element_cleanup();
diff --git a/src/rtnl.c b/src/rtnl.c
index f100c213..491f190b 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -36,21 +36,6 @@
 
 #include "connman.h"
 
-struct rtnl_data {
-	unsigned ifi_flags;
-};
-
-static struct rtnl_data *get_rtnl_data(struct connman_iface *iface)
-{
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
-		return NULL;
-
-	if (iface->rtnl_data == NULL)
-		iface->rtnl_data = g_try_new0(struct rtnl_data, 1);
-
-	return iface->rtnl_data;
-}
-
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
 {
 	if (family == AF_INET) {
@@ -85,8 +70,6 @@ static inline void print_attr(struct rtattr *attr, const char *name)
 
 static void rtnl_link(struct nlmsghdr *hdr)
 {
-	struct connman_iface *iface;
-	struct rtnl_data *data;
 	struct ifinfomsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -96,34 +79,6 @@ static void rtnl_link(struct nlmsghdr *hdr)
 
 	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
 
-	iface = __connman_iface_find(msg->ifi_index);
-	if (iface == NULL)
-		return;
-
-	data = get_rtnl_data(iface);
-	if (data == NULL)
-		return;
-
-	if ((data->ifi_flags & IFF_RUNNING) != (msg->ifi_flags & IFF_RUNNING)) {
-		if (!(iface->flags & CONNMAN_IFACE_FLAG_NOCARRIER)) {
-			if (msg->ifi_flags & IFF_RUNNING)
-				connman_iface_indicate_carrier_on(iface);
-			else
-				connman_iface_indicate_carrier_off(iface);
-		}
-	}
-
-	if ((data->ifi_flags & IFF_UP) != (msg->ifi_flags & IFF_UP)) {
-		if (msg->ifi_flags & IFF_UP)
-			connman_iface_indicate_ifup(iface);
-		else
-			connman_iface_indicate_ifdown(iface);
-	}
-
-	data->ifi_flags = msg->ifi_flags;
-
-	return;
-
 	for (attr = IFLA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
@@ -158,9 +113,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 			print_attr(attr, "master");
 			break;
 		case IFLA_WIRELESS:
-			if (iface->driver->rtnl_wireless)
-				iface->driver->rtnl_wireless(iface,
-					RTA_DATA(attr), RTA_PAYLOAD(attr));
+			print_attr(attr, "wireless");
 			break;
 		case IFLA_PROTINFO:
 			print_attr(attr, "protinfo");
@@ -189,8 +142,6 @@ static void rtnl_link(struct nlmsghdr *hdr)
 
 static void rtnl_addr(struct nlmsghdr *hdr)
 {
-	struct connman_iface *iface;
-	struct rtnl_data *data;
 	struct ifaddrmsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -200,14 +151,6 @@ static void rtnl_addr(struct nlmsghdr *hdr)
 
 	DBG("ifa_family %d ifa_index %d", msg->ifa_family, msg->ifa_index);
 
-	iface = __connman_iface_find(msg->ifa_index);
-	if (iface == NULL)
-		return;
-
-	data = get_rtnl_data(iface);
-	if (data == NULL)
-		return;
-
 	for (attr = IFA_RTA(msg); RTA_OK(attr, bytes);
 					attr = RTA_NEXT(attr, bytes)) {
 		switch (attr->rta_type) {
@@ -406,7 +349,7 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK;
+	//addr.nl_groups = RTMGRP_LINK;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 
@@ -418,9 +361,8 @@ int __connman_rtnl_init(void)
 	channel = g_io_channel_unix_new(sk);
 	g_io_channel_set_close_on_unref(channel, TRUE);
 
-	g_io_add_watch(channel,
-			G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
-						netlink_event, NULL);
+	g_io_add_watch(channel, G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+							netlink_event, NULL);
 
 	return 0;
 }

commit 6232321cbe36b7ddaa3f6946a8c562a32d25845e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 9 04:39:52 2008 +0200

    Check if resolvconf is actually installed

diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 1d4927b5..b0650603 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -23,12 +23,15 @@
 #include <config.h>
 #endif
 
+#include <unistd.h>
 #include <stdlib.h>
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/log.h>
 
+#define RESOLVCONF "/sbin/resolvconf"
+
 static int resolvconf_probe(struct connman_element *element)
 {
 	const char *nameserver = NULL;
@@ -38,14 +41,18 @@ static int resolvconf_probe(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	if (access(RESOLVCONF, X_OK) < 0)
+		return -errno;
+
 	connman_element_get_value(element,
 			CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER, &nameserver);
 
 	if (nameserver == NULL)
 		return -EINVAL;
 
-	cmd = g_strdup_printf("echo \"nameserver %s\" | resolvconf -a %s",
-					nameserver, element->netdev.name);
+	cmd = g_strdup_printf("echo \"nameserver %s\" | %s -a %s",
+						RESOLVCONF, nameserver,
+							element->netdev.name);
 
 	DBG("%s", cmd);
 
@@ -78,7 +85,7 @@ static void resolvconf_remove(struct connman_element *element)
 
 	connman_element_unref(internet);
 
-	cmd = g_strdup_printf("resolvconf -d %s", element->netdev.name);
+	cmd = g_strdup_printf("%s -d %s", RESOLVCONF, element->netdev.name);
 
 	DBG("%s", cmd);
 

commit 4658b59abd4e0fc58821a67e6847667c1bab33ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 9 04:59:25 2008 +0200

    Write /etc/resolv.conf file directly

diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index d39b2e1d..bf480818 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -23,7 +23,11 @@
 #include <config.h>
 #endif
 
-#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/stat.h>
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
@@ -34,7 +38,7 @@ static int resolvfile_probe(struct connman_element *element)
 	const char *nameserver = NULL;
 	struct connman_element *internet;
 	gchar *cmd;
-	int err;
+	int fd, len, err;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -44,15 +48,21 @@ static int resolvfile_probe(struct connman_element *element)
 	if (nameserver == NULL)
 		return -EINVAL;
 
-	cmd = g_strdup_printf("echo \"nameserver %s\" > /etc/resolv.conf",
-								nameserver);
+	fd = open("/etc/resolv.conf", O_RDWR | O_CREAT,
+					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+	if (fd < 0)
+		return errno;
 
-	DBG("%s", cmd);
+	err = ftruncate(fd, 0);
 
-	err = system(cmd);
+	cmd = g_strdup_printf("nameserver %s\n", nameserver);
+
+	len = write(fd, cmd, strlen(cmd));
 
 	g_free(cmd);
 
+	close(fd);
+
 	internet = connman_element_create();
 
 	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;

commit a89cdde4c815684b9a39ffac745f093a31df4dea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 9 05:26:46 2008 +0200

    Don't optimize when debug is enabled

diff --git a/configure.ac b/configure.ac
index 64196c97..6508cd44 100644
--- a/configure.ac
+++ b/configure.ac
@@ -28,7 +28,7 @@ AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
 				test "${ac_cv_prog_cc_g}" = "yes"); then
-		CFLAGS="$CFLAGS -g"
+		CFLAGS="$CFLAGS -g -O0"
 	fi
 ])
 

commit 8de5c2bce2ab02078646be19b2f7402760d76394
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 9 05:40:22 2008 +0200

    Add skeleton for RTNL link detection plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index ea857558..780dc1aa 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,13 +1,15 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la ethernet.la wifi.la bluetooth.la \
+plugin_LTLIBRARIES = hal.la rtnllink.la ethernet.la wifi.la bluetooth.la \
 			dhclient.la ipv4.la resolvconf.la resolvfile.la
 
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
 hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
 
+rtnllink_la_SOURCES = rtnllink.c
+
 ethernet_la_SOURCES = ethernet.c
 
 wifi_la_SOURCES = wifi.c supplicant.h supplicant.c
diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
new file mode 100644
index 00000000..07f969ec
--- /dev/null
+++ b/plugins/rtnllink.c
@@ -0,0 +1,40 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/element.h>
+#include <connman/log.h>
+
+static int rtnllink_init(void)
+{
+	return 0;
+}
+
+static void rtnllink_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE("rtnllink", "RTNL link detection plugin", VERSION,
+						rtnllink_init, rtnllink_exit)

commit bcb649ac5e1814b1ef4516229c0be8695adf9055
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 9 05:41:14 2008 +0200

    Plugin names should be all lower-case

diff --git a/plugins/hal.c b/plugins/hal.c
index 3b990c3d..2afe856b 100644
--- a/plugins/hal.c
+++ b/plugins/hal.c
@@ -290,5 +290,5 @@ static void hal_exit(void)
 	dbus_connection_unref(conn);
 }
 
-CONNMAN_PLUGIN_DEFINE("HAL", "Hardware detection plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE("hal", "Hardware detection plugin", VERSION,
 							hal_init, hal_exit)
diff --git a/plugins/wifi.c b/plugins/wifi.c
index b4a3b8f0..640b7085 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -313,5 +313,5 @@ static void wifi_exit(void)
 	connman_driver_unregister(&wifi_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE("WiFi", "WiFi interface plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE("wifi", "WiFi interface plugin", VERSION,
 							wifi_init, wifi_exit)

commit bff52bdff31ac9182a9abcbfac63350cd5ae67de
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 00:26:44 2008 +0200

    Don't match driver for root element

diff --git a/src/element.c b/src/element.c
index 7c892e64..2d4c5fba 100644
--- a/src/element.c
+++ b/src/element.c
@@ -325,6 +325,9 @@ static gint compare_priority(gconstpointer a, gconstpointer b)
 static gboolean match_driver(struct connman_element *element,
 					struct connman_driver *driver)
 {
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return FALSE;
+
 	if (element->type != driver->type &&
 			driver->type != CONNMAN_ELEMENT_TYPE_UNKNOWN)
 		return FALSE;

commit a98f8a0b02a619b6c7eb5d09c56e4930f6a83eee
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 10:08:18 2008 +0200

    Remove all children before removing the parent node

diff --git a/src/element.c b/src/element.c
index 2d4c5fba..365b42ba 100644
--- a/src/element.c
+++ b/src/element.c
@@ -712,10 +712,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_node_append_data(node, element);
 
-	g_static_rw_lock_writer_unlock(&element_lock);
-
-	__connman_element_store(element);
-
 	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_ELEMENT_INTERFACE,
 					element_methods, NULL, NULL,
@@ -727,11 +723,9 @@ static void register_element(gpointer data, gpointer user_data)
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
-		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "DeviceAdded",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
+	g_static_rw_lock_writer_unlock(&element_lock);
+
+	__connman_element_store(element);
 
 	g_static_rw_lock_writer_lock(&element_lock);
 
@@ -754,17 +748,12 @@ static void register_element(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
-static void unregister_element(gpointer data, gpointer user_data)
+static gboolean remove_element(GNode *node, gpointer user_data)
 {
-	struct connman_element *element = data;
-	GNode *node;
+	struct connman_element *element = node->data;
 
 	DBG("element %p name %s", element, element->name);
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
-	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
-
 	if (element->driver) {
 		if (element->driver->remove)
 			element->driver->remove(element);
@@ -779,14 +768,6 @@ static void unregister_element(gpointer data, gpointer user_data)
 		g_node_destroy(node);
 	}
 
-	g_static_rw_lock_writer_unlock(&element_lock);
-
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
-		g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "DeviceRemoved",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementRemoved",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
@@ -796,6 +777,26 @@ static void unregister_element(gpointer data, gpointer user_data)
 						CONNMAN_ELEMENT_INTERFACE);
 
 	connman_element_unref(element);
+
+	return FALSE;
+}
+
+static void unregister_element(gpointer data, gpointer user_data)
+{
+	struct connman_element *element = data;
+	GNode *node;
+
+	DBG("element %p name %s", element, element->name);
+
+	g_static_rw_lock_writer_lock(&element_lock);
+
+	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
+
+	if (node != NULL)
+		g_node_traverse(node, G_POST_ORDER,
+				G_TRAVERSE_ALL, -1, remove_element, NULL);
+
+	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 int __connman_element_init(DBusConnection *conn, const char *device)

commit 2657bbff7f718c5f822bdffd4b10b70ce3b21a33
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 10:23:16 2008 +0200

    The core will remove children in reverse order automatically

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 9654c764..17d6c534 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -204,8 +204,6 @@ static int ipv4_probe(struct connman_element *element)
 	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
 	resolver->netdev.name = g_strdup(element->netdev.name);
 
-	connman_element_set_data(element, resolver);
-
 	connman_element_register(resolver, element);
 
 	return 0;
@@ -213,16 +211,8 @@ static int ipv4_probe(struct connman_element *element)
 
 static void ipv4_remove(struct connman_element *element)
 {
-	struct connman_element *resolver = connman_element_get_data(element);
-
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_set_data(element, NULL);
-
-	connman_element_unregister(resolver);
-
-	connman_element_unref(resolver);
-
 	clear_ipv4(element);
 }
 
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index b0650603..e512f2b7 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -64,8 +64,6 @@ static int resolvconf_probe(struct connman_element *element)
 
 	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
 
-	connman_element_set_data(element, internet);
-
 	connman_element_register(internet, element);
 
 	return 0;
@@ -73,18 +71,11 @@ static int resolvconf_probe(struct connman_element *element)
 
 static void resolvconf_remove(struct connman_element *element)
 {
-	struct connman_element *internet = connman_element_get_data(element);
 	gchar *cmd;
 	int err;
 
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_set_data(element, NULL);
-
-	connman_element_unregister(internet);
-
-	connman_element_unref(internet);
-
 	cmd = g_strdup_printf("%s -d %s", RESOLVCONF, element->netdev.name);
 
 	DBG("%s", cmd);
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index bf480818..5ea3422d 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -67,8 +67,6 @@ static int resolvfile_probe(struct connman_element *element)
 
 	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
 
-	connman_element_set_data(element, internet);
-
 	connman_element_register(internet, element);
 
 	return 0;
@@ -76,15 +74,7 @@ static int resolvfile_probe(struct connman_element *element)
 
 static void resolvfile_remove(struct connman_element *element)
 {
-	struct connman_element *internet = connman_element_get_data(element);
-
 	DBG("element %p name %s", element, element->name);
-
-	connman_element_set_data(element, NULL);
-
-	connman_element_unregister(internet);
-
-	connman_element_unref(internet);
 }
 
 static struct connman_driver resolvfile_driver = {

commit e53e3eb4fae306bfb6bf26bf57c3a9530841487d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 10:26:25 2008 +0200

    Remove deprecated device API

diff --git a/src/manager.c b/src/manager.c
index c4ea0fb8..27f6fc5a 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -123,38 +123,11 @@ static DBusMessage *list_elements(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *list_devices(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	DBusMessage *reply;
-	DBusMessageIter array, iter;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
-
-	dbus_message_iter_close_container(&array, &iter);
-
-	return reply;
-}
-
 static GDBusMethodTable manager_methods[] = {
-	{ "RegisterAgent",   "o", "", register_agent   },
-	{ "UnregisterAgent", "o", "", unregister_agent },
-
-	{ "ListProfiles", "", "ao", list_profiles },
-
-	{ "ListElements", "", "ao", list_elements },
-	{ "ListDevices",  "", "ao", list_devices  },
+	{ "RegisterAgent",   "o", "",   register_agent   },
+	{ "UnregisterAgent", "o", "",   unregister_agent },
+	{ "ListProfiles",    "",  "ao", list_profiles    },
+	{ "ListElements",    "",  "ao", list_elements    },
 	{ },
 };
 
@@ -162,8 +135,6 @@ static GDBusSignalTable manager_signals[] = {
 	{ "ElementAdded",   "o" },
 	{ "ElementUpdated", "o" },
 	{ "ElementRemoved", "o" },
-	{ "DeviceAdded",    "o" },
-	{ "DeviceRemoved",  "o" },
 	{ },
 };
 

commit 004cbb420e7a2b44cb2fde3b9e37f9dc3e60067e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 11:21:45 2008 +0200

    Add PropertyChanged signal declaration

diff --git a/src/element.c b/src/element.c
index 365b42ba..6086b7b1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -276,6 +276,11 @@ static GDBusMethodTable element_methods[] = {
 	{ },
 };
 
+static GDBusSignalTable element_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
 struct append_filter {
 	enum connman_element_type type;
 	DBusMessageIter *iter;
@@ -714,8 +719,8 @@ static void register_element(gpointer data, gpointer user_data)
 
 	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_ELEMENT_INTERFACE,
-					element_methods, NULL, NULL,
-						element, NULL) == FALSE)
+					element_methods, element_signals,
+					NULL, element, NULL) == FALSE)
 		connman_error("Failed to register %s", element->path);
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,

commit 66f359d8eec2c9adde2f3083c791eee101170d2d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 11:23:35 2008 +0200

    Use type2string function if element name is not provided

diff --git a/src/element.c b/src/element.c
index 6086b7b1..ff66bc06 100644
--- a/src/element.c
+++ b/src/element.c
@@ -623,33 +623,8 @@ int connman_element_register(struct connman_element *element,
 
 	__connman_element_load(element);
 
-	if (element->name == NULL) {
-		switch (element->type) {
-		case CONNMAN_ELEMENT_TYPE_IPV4:
-			element->name = g_strdup("ipv4");
-			break;
-		case CONNMAN_ELEMENT_TYPE_IPV6:
-			element->name = g_strdup("ipv6");
-			break;
-		case CONNMAN_ELEMENT_TYPE_DHCP:
-			element->name = g_strdup("dhcp");
-			break;
-		case CONNMAN_ELEMENT_TYPE_BOOTP:
-			element->name = g_strdup("bootp");
-			break;
-		case CONNMAN_ELEMENT_TYPE_ZEROCONF:
-			element->name = g_strdup("zeroconf");
-			break;
-		case CONNMAN_ELEMENT_TYPE_RESOLVER:
-			element->name = g_strdup("resolver");
-			break;
-		case CONNMAN_ELEMENT_TYPE_INTERNET:
-			element->name = g_strdup("internet");
-			break;
-		default:
-			break;
-		}
-	}
+	if (element->name == NULL)
+		element->name = g_strdup(type2string(element->type));
 
 	element->parent = parent;
 

commit a9655c2f60b39c69c2a9c8d38fbfc57084b930aa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 11:25:53 2008 +0200

    Don't allow elements without any name

diff --git a/src/element.c b/src/element.c
index ff66bc06..5e1bea55 100644
--- a/src/element.c
+++ b/src/element.c
@@ -623,8 +623,11 @@ int connman_element_register(struct connman_element *element,
 
 	__connman_element_load(element);
 
-	if (element->name == NULL)
+	if (element->name == NULL) {
 		element->name = g_strdup(type2string(element->type));
+		if (element->name == NULL)
+			return -EINVAL;
+	}
 
 	element->parent = parent;
 

commit c3cdbfae11de2fbc126528955d4330794c590424
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 11:39:57 2008 +0200

    The core takes care of the lifetime for child elements

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 6bffa8f8..ee8a3a52 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -41,7 +41,6 @@ struct dhclient_task {
 	int ifindex;
 	gchar *ifname;
 	struct connman_element *element;
-	struct connman_element *child;
 };
 
 static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
@@ -144,7 +143,6 @@ static int dhclient_probe(struct connman_element *element)
 	task->ifindex = element->netdev.index;
 	task->ifname = g_strdup(element->netdev.name);
 	task->element = element;
-	task->child = NULL;
 
 	if (task->ifname == NULL) {
 		g_free(task);
@@ -204,7 +202,11 @@ static void dhclient_remove(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 
 	g_static_mutex_lock(&task_mutex);
+
 	task = find_task_by_index(element->netdev.index);
+	if (task != NULL)
+		task_list = g_slist_remove(task_list, task);
+
 	g_static_mutex_unlock(&task_mutex);
 
 	if (task == NULL)
@@ -212,16 +214,6 @@ static void dhclient_remove(struct connman_element *element)
 
 	DBG("release %s", task->ifname);
 
-	g_static_mutex_lock(&task_mutex);
-	task_list = g_slist_remove(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
-
-	if (task->child != NULL) {
-		connman_element_unregister(task->child);
-		connman_element_unref(task->child);
-		task->child = NULL;
-	}
-
 	kill_task(task);
 }
 
@@ -308,16 +300,16 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 	if (g_ascii_strcasecmp(text, "PREINIT") == 0) {
 	} else if (g_ascii_strcasecmp(text, "BOUND") == 0 ||
 				g_ascii_strcasecmp(text, "REBOOT") == 0) {
-		task->child = connman_element_create();
-		task->child->type = CONNMAN_ELEMENT_TYPE_IPV4;
-		task->child->netdev.index = task->ifindex;
-		task->child->netdev.name = g_strdup(task->ifname);
+		struct connman_element *element;
+		element = connman_element_create();
+		element->type = CONNMAN_ELEMENT_TYPE_IPV4;
+		element->netdev.index = task->ifindex;
+		element->netdev.name = g_strdup(task->ifname);
 		connman_element_update(task->element);
-		connman_element_register(task->child, task->element);
+		connman_element_register(element, task->element);
 	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
 				g_ascii_strcasecmp(text, "REBIND") == 0) {
 		connman_element_update(task->element);
-		connman_element_update(task->child);
 	} else {
 	}
 
@@ -363,12 +355,6 @@ static void dhclient_exit(void)
 	for (list = task_list; list; list = list->next) {
 		struct dhclient_task *task = list->data;
 
-		if (task->child) {
-			connman_element_unregister(task->child);
-			connman_element_unref(task->child);
-			task->child = NULL;
-		}
-
 		DBG("killing process %d", task->pid);
 
 		kill_task(task);

commit 746e33bd6337b3abb7e2823f3b6afc83bf29b549
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 11:56:25 2008 +0200

    Add function to unregister all children of an element

diff --git a/include/element.h b/include/element.h
index fb4f70fc..c0702acc 100644
--- a/include/element.h
+++ b/include/element.h
@@ -119,6 +119,7 @@ extern int connman_element_get_value(struct connman_element *element,
 extern int connman_element_register(struct connman_element *element,
 					struct connman_element *parent);
 extern void connman_element_unregister(struct connman_element *element);
+extern void connman_element_unregister_children(struct connman_element *element);
 extern void connman_element_update(struct connman_element *element);
 
 static inline void *connman_element_get_data(struct connman_element *element)
diff --git a/src/element.c b/src/element.c
index 5e1bea55..790d6154 100644
--- a/src/element.c
+++ b/src/element.c
@@ -39,6 +39,7 @@ static GSList *driver_list = NULL;
 
 static GThreadPool *thread_register = NULL;
 static GThreadPool *thread_unregister = NULL;
+static GThreadPool *thread_unregister_children = NULL;
 
 static gchar *device_filter = NULL;
 
@@ -647,6 +648,14 @@ void connman_element_unregister(struct connman_element *element)
 		g_thread_pool_push(thread_unregister, element, NULL);
 }
 
+void connman_element_unregister_children(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	if (thread_unregister_children != NULL)
+		g_thread_pool_push(thread_unregister_children, element, NULL);
+}
+
 void connman_element_update(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
@@ -734,9 +743,13 @@ static void register_element(gpointer data, gpointer user_data)
 static gboolean remove_element(GNode *node, gpointer user_data)
 {
 	struct connman_element *element = node->data;
+	struct connman_element *root = user_data;
 
 	DBG("element %p name %s", element, element->name);
 
+	if (element == root)
+		return FALSE;
+
 	if (element->driver) {
 		if (element->driver->remove)
 			element->driver->remove(element);
@@ -782,6 +795,24 @@ static void unregister_element(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
+static void unregister_children(gpointer data, gpointer user_data)
+{
+	struct connman_element *element = data;
+	GNode *node;
+
+	DBG("element %p name %s", element, element->name);
+
+	g_static_rw_lock_writer_lock(&element_lock);
+
+	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
+
+	if (node != NULL)
+		g_node_traverse(node, G_POST_ORDER,
+				G_TRAVERSE_ALL, -1, remove_element, element);
+
+	g_static_rw_lock_writer_unlock(&element_lock);
+}
+
 int __connman_element_init(DBusConnection *conn, const char *device)
 {
 	struct connman_element *element;
@@ -810,6 +841,8 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 							NULL, 1, FALSE, NULL);
 	thread_unregister = g_thread_pool_new(unregister_element,
 							NULL, 1, FALSE, NULL);
+	thread_unregister_children = g_thread_pool_new(unregister_children,
+							NULL, 1, FALSE, NULL);
 
 	return 0;
 }
@@ -864,6 +897,9 @@ void __connman_element_cleanup(void)
 	g_thread_pool_free(thread_unregister, FALSE, TRUE);
 	thread_unregister = NULL;
 
+	g_thread_pool_free(thread_unregister_children, FALSE, TRUE);
+	thread_unregister_children = NULL;
+
 	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_destroy(element_root);
 	element_root = NULL;

commit d3073cdb94002354fe6e37e39557402ddfb30561
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 11:58:32 2008 +0200

    Let the core handle the children unregister task

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index b9089409..0f248bca 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -38,9 +38,6 @@
 static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
 static GSList *ethernet_list = NULL;
 
-static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
-static GSList *element_list = NULL;
-
 static void create_element(struct connman_element *parent,
 					enum connman_element_type type)
 {
@@ -54,42 +51,9 @@ static void create_element(struct connman_element *parent,
 	element->netdev.index = parent->netdev.index;
 	element->netdev.name = g_strdup(parent->netdev.name);
 
-	g_static_mutex_lock(&element_mutex);
-	element_list = g_slist_append(element_list, element);
-	g_static_mutex_unlock(&element_mutex);
-
 	connman_element_register(element, parent);
 }
 
-static void remove_elements(struct connman_element *parent)
-{
-	GSList *list = element_list;
-
-	DBG("parent %p name %s", parent, parent->name);
-
-	g_static_mutex_lock(&element_mutex);
-
-	while (list) {
-		GSList *next = list->next;
-		struct connman_element *element = list->data;
-
-		if (element->netdev.index != parent->netdev.index) {
-			list = next;
-			continue;
-		}
-
-		element_list = g_slist_delete_link(element_list, list);
-
-		connman_element_unregister(element);
-
-		connman_element_unref(element);
-
-		list = next;
-	}
-
-	g_static_mutex_unlock(&element_mutex);
-}
-
 static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 {
 	GSList *list;
@@ -127,7 +91,7 @@ static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 		} else {
 			DBG("carrier off");
 
-			remove_elements(element);
+			connman_element_unregister_children(element);
 		}
 	}
 
@@ -327,8 +291,6 @@ static void ethernet_remove(struct connman_element *element)
 
 	iface_down(element);
 
-	remove_elements(element);
-
 	g_static_mutex_lock(&ethernet_mutex);
 	ethernet_list = g_slist_remove(ethernet_list, element);
 	g_static_mutex_unlock(&ethernet_mutex);

commit d32b5d20f932ab5853d400ea800b2eeaffb37556
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:05:30 2008 +0200

    Update of an element will also trigger update of its children

diff --git a/src/element.c b/src/element.c
index 790d6154..8996f3b5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -656,21 +656,38 @@ void connman_element_unregister_children(struct connman_element *element)
 		g_thread_pool_push(thread_unregister_children, element, NULL);
 }
 
-void connman_element_update(struct connman_element *element)
+static gboolean update_element(GNode *node, gpointer user_data)
 {
-	DBG("element %p name %s", element, element->name);
+	struct connman_element *element = node->data;
 
-	g_static_rw_lock_reader_lock(&element_lock);
+	DBG("element %p name %s", element, element->name);
 
 	if (element->driver && element->driver->update)
 		element->driver->update(element);
 
-	g_static_rw_lock_reader_unlock(&element_lock);
-
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+
+	return FALSE;
+}
+
+void connman_element_update(struct connman_element *element)
+{
+	GNode *node;
+
+	DBG("element %p name %s", element, element->name);
+
+	g_static_rw_lock_reader_lock(&element_lock);
+
+	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
+
+	if (node != NULL)
+		g_node_traverse(node, G_PRE_ORDER,
+				G_TRAVERSE_ALL, -1, update_element, NULL);
+
+	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
 static void register_element(gpointer data, gpointer user_data)

commit 57a065f9bd8db08f2fd4b3b40fbe26198f1358c1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:14:10 2008 +0200

    Fix wrong order of resolvconf arguments

diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index e512f2b7..779c68f3 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -51,7 +51,7 @@ static int resolvconf_probe(struct connman_element *element)
 		return -EINVAL;
 
 	cmd = g_strdup_printf("echo \"nameserver %s\" | %s -a %s",
-						RESOLVCONF, nameserver,
+						nameserver, RESOLVCONF,
 							element->netdev.name);
 
 	DBG("%s", cmd);

commit 8dacf3b5cde294708c06e16a8c03b34834448e48
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:24:19 2008 +0200

    Abort driver matching if probe succeeds

diff --git a/src/element.c b/src/element.c
index 8996f3b5..d954b634 100644
--- a/src/element.c
+++ b/src/element.c
@@ -746,12 +746,12 @@ static void register_element(gpointer data, gpointer user_data)
 
 		DBG("driver %p name %s", driver, driver->name);
 
-		if (driver->probe(element) < 0)
-			continue;
-
-		connman_element_lock(element);
-		element->driver = driver;
-		connman_element_unlock(element);
+		if (driver->probe(element) == 0) {
+			connman_element_lock(element);
+			element->driver = driver;
+			connman_element_unlock(element);
+			break;
+		}
 	}
 
 	g_static_rw_lock_writer_unlock(&element_lock);

commit efcc940369f9f9e14bcd325a4a221eb94eb1f104
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:37:28 2008 +0200

    Remove old resolver implementation

diff --git a/include/resolver.h b/include/resolver.h
deleted file mode 100644
index e3c368e2..00000000
--- a/include/resolver.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifndef __CONNMAN_RESOLVER_H
-#define __CONNMAN_RESOLVER_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <connman/iface.h>
-
-struct connman_resolver_driver {
-	const char *name;
-	int (*append) (struct connman_iface *iface, const char *nameserver);
-	int (*remove) (struct connman_iface *iface);
-};
-
-extern int connman_resolver_register(struct connman_resolver_driver *driver);
-extern void connman_resolver_unregister(struct connman_resolver_driver *driver);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CONNMAN_RESOLVER_H */
diff --git a/src/resolver.c b/src/resolver.c
deleted file mode 100644
index 7c7d2f60..00000000
--- a/src/resolver.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <glib.h>
-
-#include "connman.h"
-
-static GSList *drivers = NULL;
-
-int connman_resolver_register(struct connman_resolver_driver *driver)
-{
-	DBG("driver %p", driver);
-
-	drivers = g_slist_append(drivers, driver);
-
-	return 0;
-}
-
-void connman_resolver_unregister(struct connman_resolver_driver *driver)
-{
-	DBG("driver %p", driver);
-
-	drivers = g_slist_remove(drivers, driver);
-}
-
-int __connman_resolver_append(struct connman_iface *iface,
-						const char *nameserver)
-{
-	struct connman_resolver_driver *driver = g_slist_nth_data(drivers, 0);
-
-	if (driver && driver->append)
-		return driver->append(iface, nameserver);
-
-	return -1;
-}
-
-int __connman_resolver_remove(struct connman_iface *iface)
-{
-	struct connman_resolver_driver *driver = g_slist_nth_data(drivers, 0);
-
-	if (driver && driver->remove)
-		return driver->remove(iface);
-
-	return -1;
-}

commit bbe573030af4dc38bd10e346228ee2eaa76cb7ea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:41:42 2008 +0200

    Remove old DHCP support

diff --git a/include/dhcp.h b/include/dhcp.h
deleted file mode 100644
index 7863af1f..00000000
--- a/include/dhcp.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifndef __CONNMAN_DHCP_H
-#define __CONNMAN_DHCP_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <connman/iface.h>
-
-enum connman_dhcp_state {
-	CONNMAN_DHCP_STATE_UNKNOWN = 0,
-	CONNMAN_DHCP_STATE_INIT    = 1,
-	CONNMAN_DHCP_STATE_BOUND   = 2,
-	CONNMAN_DHCP_STATE_RENEW   = 3,
-	CONNMAN_DHCP_STATE_FAILED  = 4,
-};
-
-struct connman_dhcp_driver {
-	const char *name;
-	int (*request) (struct connman_iface *iface);
-	int (*release) (struct connman_iface *iface);
-};
-
-extern int connman_dhcp_register(struct connman_dhcp_driver *driver);
-extern void connman_dhcp_unregister(struct connman_dhcp_driver *driver);
-
-extern int connman_dhcp_update(struct connman_iface *iface,
-				enum connman_dhcp_state state,
-					struct connman_ipv4 *ipv4);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CONNMAN_DHCP_H */
diff --git a/src/dhcp.c b/src/dhcp.c
deleted file mode 100644
index 1b7bd876..00000000
--- a/src/dhcp.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <arpa/inet.h>
-
-#include <glib.h>
-
-#include "connman.h"
-
-static GSList *drivers = NULL;
-
-int connman_dhcp_register(struct connman_dhcp_driver *driver)
-{
-	DBG("driver %p", driver);
-
-	drivers = g_slist_append(drivers, driver);
-
-	return 0;
-}
-
-void connman_dhcp_unregister(struct connman_dhcp_driver *driver)
-{
-	DBG("driver %p", driver);
-
-	drivers = g_slist_remove(drivers, driver);
-}
-
-int connman_dhcp_update(struct connman_iface *iface,
-				enum connman_dhcp_state state,
-					struct connman_ipv4 *ipv4)
-{
-	DBG("iface %p state %d", iface, state);
-
-	if (state == CONNMAN_DHCP_STATE_BOUND) {
-		DBG("address %s", inet_ntoa(ipv4->address));
-		DBG("netmask %s", inet_ntoa(ipv4->netmask));
-		DBG("gateway %s", inet_ntoa(ipv4->gateway));
-		DBG("network %s", inet_ntoa(ipv4->network));
-		DBG("broadcast %s", inet_ntoa(ipv4->broadcast));
-		DBG("nameserver %s", inet_ntoa(ipv4->nameserver));
-
-		ipv4->method = CONNMAN_IPV4_METHOD_DHCP;
-
-		connman_iface_set_ipv4(iface, ipv4);
-		iface->ipv4 = *ipv4;
-
-		connman_iface_indicate_configured(iface);
-	}
-
-	return 0;
-}
-
-int __connman_dhcp_request(struct connman_iface *iface)
-{
-	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
-
-	if (iface->flags & CONNMAN_IFACE_FLAG_DHCP)
-		return -1;
-
-	if (driver && driver->request) {
-		iface->flags |= CONNMAN_IFACE_FLAG_DHCP;
-		return driver->request(iface);
-	}
-
-	return -1;
-}
-
-int __connman_dhcp_release(struct connman_iface *iface)
-{
-	struct connman_dhcp_driver *driver = g_slist_nth_data(drivers, 0);
-
-	if (!(iface->flags & CONNMAN_IFACE_FLAG_DHCP))
-		return -1;
-
-	if (driver && driver->release) {
-		iface->flags &= ~CONNMAN_IFACE_FLAG_DHCP;
-		return driver->release(iface);
-	}
-
-	return -1;
-}

commit 05710ff07036142552d249788d491f043e59f5a3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:44:07 2008 +0200

    Remove old header files from distribution

diff --git a/include/Makefile.am b/include/Makefile.am
index 1844d986..89c5aa51 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -3,8 +3,6 @@ includedir = @includedir@/connman
 
 include_HEADERS = log.h plugin.h driver.h element.h property.h rtnl.h dbus.h
 
-noinst_HEADERS = iface.h dhcp.h resolver.h
-
 MAINTAINERCLEANFILES = Makefile.in
 
 all-local:

commit a3817be2201b201fcf109d5ea627235e4239f49c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 10 12:45:44 2008 +0200

    Don't include old header files

diff --git a/src/connman.h b/src/connman.h
index 4249f33f..d33d0f31 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -118,14 +118,3 @@ int __connman_rtnl_init(void);
 void __connman_rtnl_cleanup(void);
 
 int __connman_rtnl_send(const void *buf, size_t len);
-
-#include <connman/dhcp.h>
-
-int __connman_dhcp_request(struct connman_iface *iface);
-int __connman_dhcp_release(struct connman_iface *iface);
-
-#include <connman/resolver.h>
-
-int __connman_resolver_append(struct connman_iface *iface,
-						const char *nameserver);
-int __connman_resolver_remove(struct connman_iface *iface);

commit caf82f623d5123506bf12effa4a460e5617a40a8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Aug 11 01:44:57 2008 +0200

    Remove deprecated connman_iface_* API

diff --git a/src/connman.h b/src/connman.h
index d33d0f31..22616f52 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -69,49 +69,6 @@ const char *__connman_element_subtype2string(enum connman_element_subtype type);
 int __connman_element_load(struct connman_element *element);
 int __connman_element_store(struct connman_element *element);
 
-#include <connman/iface.h>
-
-int __connman_iface_init(DBusConnection *conn, const char *interface);
-void __connman_iface_cleanup(void);
-
-struct connman_iface *__connman_iface_find(int index);
-void __connman_iface_list(DBusMessageIter *iter);
-gboolean __connman_iface_is_connected(void);
-
-int __connman_iface_create_identifier(struct connman_iface *iface);
-int __connman_iface_init_via_inet(struct connman_iface *iface);
-int __connman_iface_start(struct connman_iface *iface);
-int __connman_iface_stop(struct connman_iface *iface);
-int __connman_iface_connect(struct connman_iface *iface,
-					struct connman_network *network);
-int __connman_iface_disconnect(struct connman_iface *iface);
-
-char *__connman_iface_find_passphrase(struct connman_iface *iface,
-							const char *network);
-int __connman_iface_load(struct connman_iface *iface);
-int __connman_iface_store(struct connman_iface *iface);
-int __connman_iface_store_current_network(struct connman_iface *iface);
-int __connman_iface_load_networks(struct connman_iface *iface);
-
-void __connman_iface_network_list(struct connman_iface *iface,
-						DBusMessageIter *iter);
-struct connman_network *__connman_iface_find_network(struct connman_iface *iface,
-								const char *path);
-int __connman_iface_remove_network(struct connman_iface *iface, const char *path);
-const char *__connman_iface_add_network(struct connman_iface *iface,
-				const char *identifier, const char *passphrase);
-
-int __connman_network_init(DBusConnection *conn);
-void __connman_network_cleanup(void);
-
-const char *__connman_iface_type2string(enum connman_iface_type type);
-const char *__connman_iface_state2string(enum connman_iface_state state);
-const char *__connman_iface_policy2string(enum connman_iface_policy policy);
-enum connman_iface_policy __connman_iface_string2policy(const char *policy);
-
-const char *__connman_ipv4_method2string(enum connman_ipv4_method method);
-enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
-
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);

commit 9b4c51a543c5dd205bf5134f02f446077c1168f0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Aug 11 06:43:56 2008 +0200

    Use the element listing and filter by device type

diff --git a/test/list-devices b/test/list-devices
index 9b9615bb..3c1b82e9 100755
--- a/test/list-devices
+++ b/test/list-devices
@@ -7,15 +7,18 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-devices = manager.ListDevices()
-
-for path in devices:
-	print "[ %s ]" % (path)
+elements = manager.ListElements()
 
+for path in elements:
 	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Element")
 
 	properties = element.GetProperties()
+	if (properties["Type"] != "device"):
+		continue
+
+	print "[ %s ]" % (path)
+
 	for key in properties.keys():
 		print "    %s = %s" % (key, properties[key])
 

commit bfff79aeb857855ef025efa294028e34f91d91f0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Aug 11 08:20:47 2008 +0200

    Rename connect/disconnect to enable/disable for better semantics

diff --git a/include/driver.h b/include/driver.h
index 3d0ad920..8076a0e0 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -40,8 +40,8 @@ struct connman_driver {
 	int (*probe) (struct connman_element *element);
 	void (*remove) (struct connman_element *element);
 	int (*update) (struct connman_element *element);
-	int (*connect) (struct connman_element *element);
-	int (*disconnect) (struct connman_element *element);
+	int (*enable) (struct connman_element *element);
+	int (*disable) (struct connman_element *element);
 };
 
 extern int connman_driver_register(struct connman_driver *driver);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 640b7085..826b902e 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -46,7 +46,7 @@ static void network_remove(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 }
 
-static int network_connect(struct connman_element *element)
+static int network_enable(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
@@ -70,7 +70,7 @@ static int network_connect(struct connman_element *element)
 	return 0;
 }
 
-static int network_disconnect(struct connman_element *element)
+static int network_disable(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
@@ -94,8 +94,8 @@ static struct connman_driver network_driver = {
 	.subtype	= CONNMAN_ELEMENT_SUBTYPE_WIFI,
 	.probe		= network_probe,
 	.remove		= network_remove,
-	.connect	= network_connect,
-	.disconnect	= network_disconnect,
+	.enable		= network_enable,
+	.disable	= network_disable,
 };
 
 struct wifi_data {
diff --git a/src/element.c b/src/element.c
index d954b634..72290d92 100644
--- a/src/element.c
+++ b/src/element.c
@@ -232,7 +232,7 @@ static DBusMessage *do_update(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static DBusMessage *do_connect(DBusConnection *conn,
+static DBusMessage *do_enable(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
@@ -242,15 +242,15 @@ static DBusMessage *do_connect(DBusConnection *conn,
 	if (element->driver == NULL)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
-	if (element->driver->connect) {
-		DBG("Calling connect callback");
-		element->driver->connect(element);
+	if (element->driver->enable) {
+		DBG("Calling enable callback");
+		element->driver->enable(element);
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static DBusMessage *do_disconnect(DBusConnection *conn,
+static DBusMessage *do_disable(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
@@ -260,9 +260,9 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 	if (element->driver == NULL)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
-	if (element->driver->disconnect) {
-		DBG("Calling disconnect callback");
-		element->driver->disconnect(element);
+	if (element->driver->disable) {
+		DBG("Calling disable callback");
+		element->driver->disable(element);
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
@@ -272,8 +272,8 @@ static GDBusMethodTable element_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_properties },
 	{ "SetProperty",   "sv", "",      set_property   },
 	{ "Update",        "",   "",      do_update      },
-	{ "Connect",       "",   "",      do_connect     },
-	{ "Disconnect",    "",   "",      do_disconnect  },
+	{ "Enable",        "",   "",      do_enable      },
+	{ "Disable",       "",   "",      do_disable     },
 	{ },
 };
 

commit 9e1af1dead7a965277a7e8b0dea90a3de5b47411
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Aug 11 08:35:36 2008 +0200

    Use Enabled property instead of Connected

diff --git a/include/element.h b/include/element.h
index c0702acc..9b8beabc 100644
--- a/include/element.h
+++ b/include/element.h
@@ -72,7 +72,7 @@ struct connman_element {
 	enum connman_element_type type;
 	enum connman_element_subtype subtype;
 	enum connman_element_state state;
-	gboolean connected;
+	gboolean enabled;
 	guint16 priority;
 
 	struct connman_element *parent;
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 826b902e..05611339 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -57,7 +57,7 @@ static int network_enable(struct connman_element *element)
 
 	__supplicant_disconnect(element);
 
-	element->connected = FALSE;
+	element->enabled = FALSE;
 
 	connman_element_update(element);
 
@@ -81,7 +81,7 @@ static int network_disable(struct connman_element *element)
 
 	__supplicant_disconnect(element);
 
-	element->connected = FALSE;
+	element->enabled = FALSE;
 
 	connman_element_update(element);
 
@@ -148,7 +148,7 @@ static void state_change(struct connman_element *parent,
 
 		dhcp_element = dhcp;
 
-		element->connected = TRUE;
+		element->enabled = TRUE;
 
 		connman_element_update(element);
 
diff --git a/src/element.c b/src/element.c
index 72290d92..db7cb4e7 100644
--- a/src/element.c
+++ b/src/element.c
@@ -176,8 +176,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	if (str != NULL)
 		append_entry(&dict, "Subtype", DBUS_TYPE_STRING, &str);
 
-	append_entry(&dict, "Connected",
-				DBUS_TYPE_BOOLEAN, &element->connected);
+	append_entry(&dict, "Enabled", DBUS_TYPE_BOOLEAN, &element->enabled);
 
 	if (element->priority > 0)
 		append_entry(&dict, "Priority",
@@ -438,7 +437,7 @@ struct connman_element *connman_element_create(void)
 	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
 
-	element->connected = FALSE;
+	element->enabled = FALSE;
 
 	element->netdev.index = -1;
 
diff --git a/test/disable-network b/test/disable-network
index 12da1e83..eede449b 100755
--- a/test/disable-network
+++ b/test/disable-network
@@ -18,8 +18,8 @@ for path in elements:
 		if (properties["Type"] != "network"):
 			continue
 
-		if (properties["Connected"] == dbus.Boolean(1)):
-			print "Disconnecting %s" % (path)
-			element.Disconnect()
+		if (properties["Enabled"] == dbus.Boolean(1)):
+			print "Disabling %s" % (path)
+			element.Disable()
 	except:
 		pass
diff --git a/test/list-networks b/test/list-networks
index d3fa34d9..c7998636 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -19,7 +19,7 @@ for path in elements:
 		print "[ %s ]" % (path)
 
 	if (properties["Type"] == "network"):
-		if (properties["Connected"] == 1):
+		if (properties["Enabled"] == 1):
 			state = "*"
 		else:
 			state = " "
diff --git a/test/monitor-state b/test/monitor-state
index d17c0e5a..b4bd1de0 100755
--- a/test/monitor-state
+++ b/test/monitor-state
@@ -27,7 +27,7 @@ def element_added(path):
 
 def element_updated(path):
 	properties = get_properties(path)
-	if (properties["Type"] == "network" and properties["Connected"] == 1):
+	if (properties["Type"] == "network" and properties["Enabled"] == 1):
 		print "Associated with %s" % (properties["SSID"])
 
 def element_removed(path):
diff --git a/test/select-network b/test/select-network
index 2d5b2b1e..afa287c5 100755
--- a/test/select-network
+++ b/test/select-network
@@ -22,9 +22,9 @@ for path in elements:
 	if (properties["Type"] != "network"):
 		continue
 
-	if (properties["Connected"] == dbus.Boolean(1)):
+	if (properties["Enabled"] == dbus.Boolean(1)):
 		continue
 
 	if (properties["Identifier"] == sys.argv[1]):
-		print "Connecting %s" % (path)
-		element.Connect()
+		print "Enabling %s" % (path)
+		element.Enable()

commit 80de79e829a572a49fabffc08988b835840b4cc6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 00:37:49 2008 +0200

    Disable SQLite example code for now

diff --git a/src/storage.c b/src/storage.c
index e093dea3..d67d0d2c 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -23,10 +23,13 @@
 #include <config.h>
 #endif
 
+#if 0
 #include <sqlite3.h>
+#endif
 
 #include "connman.h"
 
+#if 0
 static sqlite3 *db = NULL;
 
 static int create_tables(void)
@@ -51,9 +54,11 @@ static int create_tables(void)
 
 	return 0;
 }
+#endif
 
 int __connman_storage_init(void)
 {
+#if 0
 	int err;
 
 	DBG("");
@@ -73,15 +78,18 @@ int __connman_storage_init(void)
 	}
 
 	create_tables();
+#endif
 
 	return 0;
 }
 
 void __connman_storage_cleanup(void)
 {
+#if 0
 	DBG("");
 
 	sqlite3_close(db);
+#endif
 }
 
 int __connman_element_load(struct connman_element *element)
@@ -91,6 +99,7 @@ int __connman_element_load(struct connman_element *element)
 
 int __connman_element_store(struct connman_element *element)
 {
+#if 0
 	char *sql, *msg;
 
 	DBG("");
@@ -106,6 +115,7 @@ int __connman_element_store(struct connman_element *element)
 			sqlite3_free(msg);
 		}
 	}
+#endif
 
 	return 0;
 }

commit eff47b478f3af6d4501cafcf716b0895c319c9e5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 00:39:33 2008 +0200

    Make HAL requirement optional and check for PolicyKit

diff --git a/configure.ac b/configure.ac
index 6508cd44..c9534a24 100644
--- a/configure.ac
+++ b/configure.ac
@@ -45,7 +45,7 @@ AC_PATH_PROG(DHCLIENT, [dhclient])
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
 
 PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
-                                AC_MSG_ERROR(glib is required))
+				AC_MSG_ERROR(glib is required))
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
@@ -69,17 +69,19 @@ PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 
-PKG_CHECK_MODULES(HAL, hal >= 0.5.8, dummy=yes,
-				AC_MSG_ERROR(libhal is required))
+PKG_CHECK_MODULES(HAL, hal >= 0.5.8, hal_found=yes, hal_found=no)
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
+AM_CONDITIONAL(HAL, test "${hal_found}" = "yes")
 
-PKG_CHECK_MODULES(SQLITE, sqlite3, dummy=yes,
-				AC_MSG_ERROR(sqlite3 is required))
+PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, polkit_found=yes, polkit_found=no)
+AC_SUBST(POLKIT_CFLAGS)
+AC_SUBST(POLKIT_LIBS)
+
+PKG_CHECK_MODULES(SQLITE, sqlite3, sqlite_found=yes, sqlite_found=no)
 AC_SUBST(SQLITE_CFLAGS)
 AC_SUBST(SQLITE_LIBS)
 
 AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
 			test/Makefile plugins/Makefile scripts/Makefile
 			scripts/connman src/connman.service connman.pc)
-			
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 780dc1aa..2358d335 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,12 +1,16 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = hal.la rtnllink.la ethernet.la wifi.la bluetooth.la \
+plugin_LTLIBRARIES = rtnllink.la ethernet.la wifi.la bluetooth.la \
 			dhclient.la ipv4.la resolvconf.la resolvfile.la
 
+if HAL
+plugin_LTLIBRARIES += hal.la
+
 hal_la_SOURCES = hal.c
 hal_la_LIBADD = @HAL_LIBS@
 hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
+endif
 
 rtnllink_la_SOURCES = rtnllink.c
 

commit b7b518712d302a7c372e62582c3b60af4020f13c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 00:49:21 2008 +0200

    Add skeleton for PolicyKit plugin

diff --git a/configure.ac b/configure.ac
index c9534a24..096711ff 100644
--- a/configure.ac
+++ b/configure.ac
@@ -77,6 +77,7 @@ AM_CONDITIONAL(HAL, test "${hal_found}" = "yes")
 PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, polkit_found=yes, polkit_found=no)
 AC_SUBST(POLKIT_CFLAGS)
 AC_SUBST(POLKIT_LIBS)
+AM_CONDITIONAL(POLKIT, test "${polkit_found}" = "yes")
 
 PKG_CHECK_MODULES(SQLITE, sqlite3, sqlite_found=yes, sqlite_found=no)
 AC_SUBST(SQLITE_CFLAGS)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2358d335..96b59b33 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -4,14 +4,6 @@ plugindir = $(libdir)/connman/plugins
 plugin_LTLIBRARIES = rtnllink.la ethernet.la wifi.la bluetooth.la \
 			dhclient.la ipv4.la resolvconf.la resolvfile.la
 
-if HAL
-plugin_LTLIBRARIES += hal.la
-
-hal_la_SOURCES = hal.c
-hal_la_LIBADD = @HAL_LIBS@
-hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
-endif
-
 rtnllink_la_SOURCES = rtnllink.c
 
 ethernet_la_SOURCES = ethernet.c
@@ -30,6 +22,22 @@ resolvconf_la_SOURCES = resolvconf.c
 
 resolvfile_la_SOURCES = resolvfile.c
 
+if HAL
+plugin_LTLIBRARIES += hal.la
+
+hal_la_SOURCES = hal.c
+hal_la_LIBADD = @HAL_LIBS@
+hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
+endif
+
+if POLKIT
+plugin_LTLIBRARIES += polkit.la
+
+polkit_la_SOURCES = polkit.c
+polkit_la_LIBADD = @POLKIT_LIBS@
+polkit_la_CFLAGS = @GLIB_CFLAGS@ @POLKIT_CFLAGS@
+endif
+
 AM_LDFLAGS = -no-undefined -module -avoid-version \
 				-export-symbols-regex connman_plugin_desc
 
diff --git a/plugins/polkit.c b/plugins/polkit.c
new file mode 100644
index 00000000..76e64521
--- /dev/null
+++ b/plugins/polkit.c
@@ -0,0 +1,39 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/log.h>
+
+static int polkit_init(void)
+{
+	return 0;
+}
+
+static void polkit_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE("polkit", "PolicyKit authorization plugin", VERSION,
+						polkit_init, polkit_exit)

commit e3a4699f34f751d47d8fd8e5a488e4b95343732f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 01:13:59 2008 +0200

    Add copy of libgdbus helper for easier adoption

diff --git a/Makefile.am b/Makefile.am
index fe127cd5..66e0a0bc 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = include src doc test plugins scripts
+SUBDIRS = gdbus include src doc test plugins scripts
 
 pkgconfigdir = $(libdir)/pkgconfig
 
diff --git a/configure.ac b/configure.ac
index 096711ff..e5d9f09b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -59,16 +59,14 @@ PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
 AC_SUBST(GMODULE_CFLAGS)
 AC_SUBST(GMODULE_LIBS)
 
-PKG_CHECK_MODULES(GDBUS, gdbus, dummy=yes,
-				AC_MSG_ERROR(libgdbus is required))
-AC_SUBST(GDBUS_CFLAGS)
-AC_SUBST(GDBUS_LIBS)
-
 PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(libdbus is required))
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 
+AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
+AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.a $(DBUS_LIBS)'])
+
 PKG_CHECK_MODULES(HAL, hal >= 0.5.8, hal_found=yes, hal_found=no)
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
@@ -83,6 +81,6 @@ PKG_CHECK_MODULES(SQLITE, sqlite3, sqlite_found=yes, sqlite_found=no)
 AC_SUBST(SQLITE_CFLAGS)
 AC_SUBST(SQLITE_LIBS)
 
-AC_OUTPUT(Makefile include/Makefile src/Makefile doc/Makefile
-			test/Makefile plugins/Makefile scripts/Makefile
-			scripts/connman src/connman.service connman.pc)
+AC_OUTPUT(Makefile gdbus/Makefile include/Makefile src/Makefile doc/Makefile
+				test/Makefile plugins/Makefile scripts/Makefile
+				scripts/connman src/connman.service connman.pc)
diff --git a/gdbus/Makefile.am b/gdbus/Makefile.am
new file mode 100644
index 00000000..756b2fa2
--- /dev/null
+++ b/gdbus/Makefile.am
@@ -0,0 +1,8 @@
+
+noinst_LIBRARIES = libgdbus.a
+
+libgdbus_a_SOURCES = gdbus.h mainloop.c object.c watch.c
+
+AM_CFLAGS = @DBUS_CFLAGS@ @GLIB_CFLAGS@
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/gdbus/gdbus.h b/gdbus/gdbus.h
new file mode 100644
index 00000000..b44bc867
--- /dev/null
+++ b/gdbus/gdbus.h
@@ -0,0 +1,133 @@
+/*
+ *
+ *  D-Bus helper library
+ *
+ *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __GDBUS_H
+#define __GDBUS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <dbus/dbus.h>
+#include <glib.h>
+
+typedef void (* GDBusWatchFunction) (void *user_data);
+
+typedef gboolean (* GDBusSignalFunction) (DBusConnection *connection,
+					DBusMessage *message, void *user_data);
+
+DBusConnection *g_dbus_setup_bus(DBusBusType type, const char *name,
+							DBusError *error);
+
+gboolean g_dbus_request_name(DBusConnection *connection, const char *name,
+							DBusError *error);
+
+gboolean g_dbus_set_disconnect_function(DBusConnection *connection,
+				GDBusWatchFunction function,
+				void *user_data, DBusFreeFunction destroy);
+
+typedef void (* GDBusDestroyFunction) (void *user_data);
+
+typedef DBusMessage * (* GDBusMethodFunction) (DBusConnection *connection,
+					DBusMessage *message, void *user_data);
+
+typedef enum {
+	G_DBUS_METHOD_FLAG_DEPRECATED = (1 << 0),
+	G_DBUS_METHOD_FLAG_NOREPLY    = (1 << 1),
+	G_DBUS_METHOD_FLAG_ASYNC      = (1 << 2),
+} GDBusMethodFlags;
+
+typedef enum {
+	G_DBUS_SIGNAL_FLAG_DEPRECATED = (1 << 0),
+} GDBusSignalFlags;
+
+typedef enum {
+	G_DBUS_PROPERTY_FLAG_DEPRECATED = (1 << 0),
+} GDBusPropertyFlags;
+
+typedef struct {
+	const char *name;
+	const char *signature;
+	const char *reply;
+	GDBusMethodFunction function;
+	GDBusMethodFlags flags;
+} GDBusMethodTable;
+
+typedef struct {
+	const char *name;
+	const char *signature;
+	GDBusSignalFlags flags;
+} GDBusSignalTable;
+
+typedef struct {
+	const char *name;
+	const char *type;
+	GDBusPropertyFlags flags;
+} GDBusPropertyTable;
+
+gboolean g_dbus_register_interface(DBusConnection *connection,
+					const char *path, const char *name,
+					GDBusMethodTable *methods,
+					GDBusSignalTable *signals,
+					GDBusPropertyTable *properties,
+					void *user_data,
+					GDBusDestroyFunction destroy);
+gboolean g_dbus_unregister_interface(DBusConnection *connection,
+					const char *path, const char *name);
+
+DBusMessage *g_dbus_create_error(DBusMessage *message, const char *name,
+						const char *format, ...);
+DBusMessage *g_dbus_create_error_valist(DBusMessage *message, const char *name,
+					const char *format, va_list args);
+DBusMessage *g_dbus_create_reply(DBusMessage *message, int type, ...);
+DBusMessage *g_dbus_create_reply_valist(DBusMessage *message,
+						int type, va_list args);
+
+gboolean g_dbus_send_message(DBusConnection *connection, DBusMessage *message);
+gboolean g_dbus_send_reply(DBusConnection *connection,
+				DBusMessage *message, int type, ...);
+gboolean g_dbus_send_reply_valist(DBusConnection *connection,
+				DBusMessage *message, int type, va_list args);
+
+gboolean g_dbus_emit_signal(DBusConnection *connection,
+				const char *path, const char *interface,
+				const char *name, int type, ...);
+gboolean g_dbus_emit_signal_valist(DBusConnection *connection,
+				const char *path, const char *interface,
+				const char *name, int type, va_list args);
+
+guint g_dbus_add_disconnect_watch(DBusConnection *connection,
+				const char *name,
+				GDBusWatchFunction function,
+				void *user_data, GDBusDestroyFunction destroy);
+guint g_dbus_add_signal_watch(DBusConnection *connection,
+				const char *rule, GDBusSignalFunction function,
+				void *user_data, GDBusDestroyFunction destroy);
+gboolean g_dbus_remove_watch(DBusConnection *connection, guint tag);
+void g_dbus_remove_all_watches(DBusConnection *connection);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GDBUS_H */
diff --git a/gdbus/mainloop.c b/gdbus/mainloop.c
new file mode 100644
index 00000000..b50d83c0
--- /dev/null
+++ b/gdbus/mainloop.c
@@ -0,0 +1,305 @@
+/*
+ *
+ *  D-Bus helper library
+ *
+ *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdint.h>
+
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#ifdef NEED_DBUS_WATCH_GET_UNIX_FD
+#define dbus_watch_get_unix_fd dbus_watch_get_fd
+#endif
+
+#include "gdbus.h"
+
+#define DISPATCH_TIMEOUT  0
+
+#define info(fmt...)
+#define error(fmt...)
+#define debug(fmt...)
+
+typedef struct {
+	uint32_t id;
+	DBusTimeout *timeout;
+} timeout_handler_t;
+
+struct watch_info {
+	guint watch_id;
+	GIOChannel *io;
+	DBusConnection *conn;
+};
+
+struct server_info {
+	guint watch_id;
+	GIOChannel *io;
+	DBusServer *server;
+};
+
+struct disconnect_data {
+	void (*disconnect_cb)(void *);
+	void *user_data;
+};
+
+static DBusHandlerResult disconnect_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
+{
+	struct disconnect_data *dc_data = data;
+
+	if (dbus_message_is_signal(msg,
+			DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE) {
+		error("Got disconnected from the system message bus");
+		dbus_connection_unref(conn);
+		dc_data->disconnect_cb(dc_data->user_data);
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static gboolean message_dispatch_cb(void *data)
+{
+	DBusConnection *connection = data;
+
+	dbus_connection_ref(connection);
+
+	/* Dispatch messages */
+	while (dbus_connection_dispatch(connection) == DBUS_DISPATCH_DATA_REMAINS);
+
+	dbus_connection_unref(connection);
+
+	return FALSE;
+}
+
+static gboolean watch_func(GIOChannel *chan, GIOCondition cond, gpointer data)
+{
+	DBusWatch *watch = data;
+	struct watch_info *info = dbus_watch_get_data(watch);
+	int flags = 0;
+
+	if (cond & G_IO_IN)  flags |= DBUS_WATCH_READABLE;
+	if (cond & G_IO_OUT) flags |= DBUS_WATCH_WRITABLE;
+	if (cond & G_IO_HUP) flags |= DBUS_WATCH_HANGUP;
+	if (cond & G_IO_ERR) flags |= DBUS_WATCH_ERROR;
+
+	dbus_watch_handle(watch, flags);
+
+	if (dbus_connection_get_dispatch_status(info->conn) == DBUS_DISPATCH_DATA_REMAINS)
+		g_timeout_add(DISPATCH_TIMEOUT, message_dispatch_cb, info->conn);
+
+	return TRUE;
+}
+
+static dbus_bool_t add_watch(DBusWatch *watch, void *data)
+{
+	GIOCondition cond = G_IO_HUP | G_IO_ERR;
+	DBusConnection *conn = data;
+	struct watch_info *info;
+	int fd, flags;
+
+	if (!dbus_watch_get_enabled(watch))
+		return TRUE;
+
+	info = g_new(struct watch_info, 1);
+
+	fd = dbus_watch_get_unix_fd(watch);
+	info->io = g_io_channel_unix_new(fd);
+	info->conn = dbus_connection_ref(conn);
+
+	dbus_watch_set_data(watch, info, NULL);
+
+	flags = dbus_watch_get_flags(watch);
+
+	if (flags & DBUS_WATCH_READABLE) cond |= G_IO_IN;
+	if (flags & DBUS_WATCH_WRITABLE) cond |= G_IO_OUT;
+
+	info->watch_id = g_io_add_watch(info->io, cond, watch_func, watch);
+
+	return TRUE;
+}
+
+static void remove_watch(DBusWatch *watch, void *data)
+{
+	struct watch_info *info = dbus_watch_get_data(watch);
+
+	dbus_watch_set_data(watch, NULL, NULL);
+
+	if (info) {
+		g_source_remove(info->watch_id);
+		g_io_channel_unref(info->io);
+		dbus_connection_unref(info->conn);
+		g_free(info);
+	}
+}
+
+static void watch_toggled(DBusWatch *watch, void *data)
+{
+	/* Because we just exit on OOM, enable/disable is
+	 * no different from add/remove */
+	if (dbus_watch_get_enabled(watch))
+		add_watch(watch, data);
+	else
+		remove_watch(watch, data);
+}
+
+static gboolean timeout_handler_dispatch(gpointer data)
+{
+	timeout_handler_t *handler = data;
+
+	/* if not enabled should not be polled by the main loop */
+	if (dbus_timeout_get_enabled(handler->timeout) != TRUE)
+		return FALSE;
+
+	dbus_timeout_handle(handler->timeout);
+
+	return FALSE;
+}
+
+static void timeout_handler_free(void *data)
+{
+	timeout_handler_t *handler = data;
+	if (!handler)
+		return;
+
+	g_source_remove(handler->id);
+	g_free(handler);
+}
+
+static dbus_bool_t add_timeout(DBusTimeout *timeout, void *data)
+{
+	timeout_handler_t *handler;
+
+	if (!dbus_timeout_get_enabled(timeout))
+		return TRUE;
+
+	handler = g_new0(timeout_handler_t, 1);
+
+	handler->timeout = timeout;
+	handler->id = g_timeout_add(dbus_timeout_get_interval(timeout),
+					timeout_handler_dispatch, handler);
+
+	dbus_timeout_set_data(timeout, handler, timeout_handler_free);
+
+	return TRUE;
+}
+
+static void remove_timeout(DBusTimeout *timeout, void *data)
+{
+}
+
+static void timeout_toggled(DBusTimeout *timeout, void *data)
+{
+	if (dbus_timeout_get_enabled(timeout))
+		add_timeout(timeout, data);
+	else
+		remove_timeout(timeout, data);
+}
+
+static void dispatch_status_cb(DBusConnection *conn,
+				DBusDispatchStatus new_status, void *data)
+{
+	if (!dbus_connection_get_is_connected(conn))
+		return;
+
+	if (new_status == DBUS_DISPATCH_DATA_REMAINS)
+		g_timeout_add(DISPATCH_TIMEOUT, message_dispatch_cb, data);
+}
+
+static void setup_dbus_with_main_loop(DBusConnection *conn)
+{
+	dbus_connection_set_watch_functions(conn, add_watch, remove_watch,
+						watch_toggled, conn, NULL);
+
+	dbus_connection_set_timeout_functions(conn, add_timeout, remove_timeout,
+						timeout_toggled, conn, NULL);
+
+	dbus_connection_set_dispatch_status_function(conn, dispatch_status_cb,
+								conn, NULL);
+}
+
+DBusConnection *g_dbus_setup_bus(DBusBusType type, const char *name,
+							DBusError *error)
+{
+	DBusConnection *conn;
+
+	conn = dbus_bus_get(type, error);
+
+	if (error != NULL) {
+		if (dbus_error_is_set(error) == TRUE)
+			return NULL;
+	}
+
+	if (conn == NULL)
+		return NULL;
+
+	if (name != NULL) {
+		if (dbus_bus_request_name(conn, name,
+				DBUS_NAME_FLAG_DO_NOT_QUEUE, error) !=
+				DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER ) {
+			dbus_connection_unref(conn);
+			return NULL;
+		}
+
+		if (error != NULL) {
+			if (dbus_error_is_set(error) == TRUE) {
+				dbus_connection_unref(conn);
+				return NULL;
+			}
+		}
+	}
+
+	setup_dbus_with_main_loop(conn);
+
+	return conn;
+}
+
+gboolean g_dbus_request_name(DBusConnection *connection, const char *name,
+							DBusError *error)
+{
+	return TRUE;
+}
+
+gboolean g_dbus_set_disconnect_function(DBusConnection *connection,
+				GDBusWatchFunction function,
+				void *user_data, DBusFreeFunction destroy)
+{
+	struct disconnect_data *dc_data;
+
+	dc_data = g_new(struct disconnect_data, 1);
+
+	dc_data->disconnect_cb = function;
+	dc_data->user_data = user_data;
+
+	dbus_connection_set_exit_on_disconnect(connection, FALSE);
+
+	if (dbus_connection_add_filter(connection, disconnect_filter,
+						dc_data, g_free) == FALSE) {
+		error("Can't add D-Bus disconnect filter");
+		g_free(dc_data);
+		return FALSE;
+	}
+
+	return TRUE;
+}
diff --git a/gdbus/object.c b/gdbus/object.c
new file mode 100644
index 00000000..a417ab98
--- /dev/null
+++ b/gdbus/object.c
@@ -0,0 +1,641 @@
+/*
+ *
+ *  D-Bus helper library
+ *
+ *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "gdbus.h"
+
+#define info(fmt...)
+#define error(fmt...)
+#define debug(fmt...)
+
+struct generic_data {
+	unsigned int refcount;
+	GSList *interfaces;
+	char *introspect;
+};
+
+struct interface_data {
+	char *name;
+	GDBusMethodTable *methods;
+	GDBusSignalTable *signals;
+	GDBusPropertyTable *properties;
+	void *user_data;
+	GDBusDestroyFunction destroy;
+};
+
+static void print_arguments(GString *gstr, const char *sig,
+						const char *direction)
+{
+	int i;
+
+	for (i = 0; sig[i]; i++) {
+		char type[32];
+		int len, struct_level, dict_level;
+		gboolean complete;
+
+		complete = FALSE;
+		struct_level = dict_level = 0;
+		memset(type, 0, sizeof(type));
+
+		/* Gather enough data to have a single complete type */
+		for (len = 0; len < (sizeof(type) - 1) && sig[i]; len++, i++) {
+			switch (sig[i]){
+			case '(':
+				struct_level++;
+				break;
+			case ')':
+				struct_level--;
+				if (struct_level <= 0 && dict_level <= 0)
+					complete = TRUE;
+				break;
+			case '{':
+				dict_level++;
+				break;
+			case '}':
+				dict_level--;
+				if (struct_level <= 0 && dict_level <= 0)
+					complete = TRUE;
+				break;
+			case 'a':
+				break;
+			default:
+				if (struct_level <= 0 && dict_level <= 0)
+					complete = TRUE;
+				break;
+			}
+
+			type[len] = sig[i];
+
+			if (complete)
+				break;
+		}
+
+
+		if (direction)
+			g_string_append_printf(gstr,
+					"\t\t\t<arg type=\"%s\" direction=\"%s\"/>\n",
+					type, direction);
+		else
+			g_string_append_printf(gstr,
+					"\t\t\t<arg type=\"%s\"/>\n",
+					type);
+	}
+}
+
+static void generate_interface_xml(GString *gstr, struct interface_data *iface)
+{
+	GDBusMethodTable *method;
+	GDBusSignalTable *signal;
+
+	for (method = iface->methods; method && method->name; method++) {
+		if (!strlen(method->signature) && !strlen(method->reply))
+			g_string_append_printf(gstr, "\t\t<method name=\"%s\"/>\n",
+								method->name);
+		else {
+			g_string_append_printf(gstr, "\t\t<method name=\"%s\">\n",
+								method->name);
+			print_arguments(gstr, method->signature, "in");
+			print_arguments(gstr, method->reply, "out");
+			g_string_append_printf(gstr, "\t\t</method>\n");
+		}
+	}
+
+	for (signal = iface->signals; signal && signal->name; signal++) {
+		if (!strlen(signal->signature))
+			g_string_append_printf(gstr, "\t\t<signal name=\"%s\"/>\n",
+								signal->name);
+		else {
+			g_string_append_printf(gstr, "\t\t<signal name=\"%s\">\n",
+								signal->name);
+			print_arguments(gstr, signal->signature, NULL);
+			g_string_append_printf(gstr, "\t\t</signal>\n");
+		}
+	}
+}
+
+static void generate_introspection_xml(DBusConnection *conn,
+				struct generic_data *data, const char *path)
+{
+	GSList *list;
+	GString *gstr;
+	char **children;
+	int i;
+
+	g_free(data->introspect);
+
+	gstr = g_string_new(DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE);
+
+	g_string_append_printf(gstr, "<node name=\"%s\">\n", path);
+
+	for (list = data->interfaces; list; list = list->next) {
+		struct interface_data *iface = list->data;
+
+		g_string_append_printf(gstr, "\t<interface name=\"%s\">\n",
+								iface->name);
+
+		generate_interface_xml(gstr, iface);
+
+		g_string_append_printf(gstr, "\t</interface>\n");
+	}
+
+	if (!dbus_connection_list_registered(conn, path, &children))
+		goto done;
+
+	for (i = 0; children[i]; i++)
+		g_string_append_printf(gstr, "\t<node name=\"%s\"/>\n",
+								children[i]);
+
+	dbus_free_string_array(children);
+
+done:
+	g_string_append_printf(gstr, "</node>\n");
+
+	data->introspect = g_string_free(gstr, FALSE);
+}
+
+static DBusHandlerResult introspect(DBusConnection *connection,
+				DBusMessage *message, struct generic_data *data)
+{
+	DBusMessage *reply;
+
+	if (!dbus_message_has_signature(message, DBUS_TYPE_INVALID_AS_STRING)) {
+		error("Unexpected signature to introspect call");
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+
+	if (!data->introspect)
+		generate_introspection_xml(connection, data,
+						dbus_message_get_path(message));
+
+	reply = dbus_message_new_method_return(message);
+	if (!reply)
+		return DBUS_HANDLER_RESULT_NEED_MEMORY;
+
+	dbus_message_append_args(reply, DBUS_TYPE_STRING, &data->introspect,
+					DBUS_TYPE_INVALID);
+
+	dbus_connection_send(connection, reply, NULL);
+
+	dbus_message_unref(reply);
+
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static void generic_unregister(DBusConnection *connection, void *user_data)
+{
+	struct generic_data *data = user_data;
+
+	g_free(data->introspect);
+	g_free(data);
+}
+
+static struct interface_data *find_interface(GSList *interfaces,
+						const char *name)
+{
+	GSList *list;
+
+	for (list = interfaces; list; list = list->next) {
+		struct interface_data *iface = list->data;
+		if (!strcmp(name, iface->name))
+			return iface;
+	}
+
+	return NULL;
+}
+
+static DBusHandlerResult generic_message(DBusConnection *connection,
+					DBusMessage *message, void *user_data)
+{
+	struct generic_data *data = user_data;
+	struct interface_data *iface;
+	GDBusMethodTable *method;
+	const char *interface;
+
+	if (dbus_message_is_method_call(message,
+					DBUS_INTERFACE_INTROSPECTABLE,
+								"Introspect"))
+		return introspect(connection, message, data);
+
+	interface = dbus_message_get_interface(message);
+
+	iface = find_interface(data->interfaces, interface);
+	if (!iface)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	for (method = iface->methods; method &&
+			method->name && method->function; method++) {
+		DBusMessage *reply;
+
+		if (dbus_message_is_method_call(message, iface->name,
+							method->name) == FALSE)
+			continue;
+
+		if (dbus_message_has_signature(message,
+						method->signature) == FALSE)
+			continue;
+
+		reply = method->function(connection, message, iface->user_data);
+
+		if (method->flags & G_DBUS_METHOD_FLAG_NOREPLY) {
+			if (reply != NULL)
+				dbus_message_unref(reply);
+			return DBUS_HANDLER_RESULT_HANDLED;
+		}
+
+		if (method->flags & G_DBUS_METHOD_FLAG_ASYNC) {
+			if (reply == NULL)
+				return DBUS_HANDLER_RESULT_HANDLED;
+		}
+
+		if (reply == NULL)
+			return DBUS_HANDLER_RESULT_NEED_MEMORY;
+
+		dbus_connection_send(connection, reply, NULL);
+		dbus_message_unref(reply);
+
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static DBusObjectPathVTable generic_table = {
+	.unregister_function	= generic_unregister,
+	.message_function	= generic_message,
+};
+
+static void invalidate_parent_data(DBusConnection *conn, const char *child_path)
+{
+	struct generic_data *data = NULL;
+	char *parent_path, *slash;
+
+	parent_path = g_strdup(child_path);
+	slash = strrchr(parent_path, '/');
+	if (!slash)
+		goto done;
+
+	*slash = '\0';
+	if (!strlen(parent_path))
+		goto done;
+
+	if (!dbus_connection_get_object_path_data(conn, parent_path,
+							(void *) &data))
+		goto done;
+
+	if (!data)
+		goto done;
+
+	g_free(data->introspect);
+	data->introspect = NULL;
+
+done:
+	g_free(parent_path);
+}
+
+static struct generic_data *object_path_ref(DBusConnection *connection,
+							const char *path)
+{
+	struct generic_data *data;
+
+	if (dbus_connection_get_object_path_data(connection, path,
+						(void *) &data) == TRUE) {
+		if (data != NULL) {
+			data->refcount++;
+			return data;
+		}
+	}
+
+	data = g_new0(struct generic_data, 1);
+
+	data->introspect = g_strdup(DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE "<node></node>");
+
+	data->refcount = 1;
+
+	if (!dbus_connection_register_object_path(connection, path,
+						&generic_table, data)) {
+		g_free(data->introspect);
+		g_free(data);
+		return NULL;
+	}
+
+	invalidate_parent_data(connection, path);
+
+	return data;
+}
+
+static void object_path_unref(DBusConnection *connection, const char *path)
+{
+	struct generic_data *data = NULL;
+
+	if (dbus_connection_get_object_path_data(connection, path,
+						(void *) &data) == FALSE)
+		return;
+
+	if (data == NULL)
+		return;
+
+	data->refcount--;
+
+	if (data->refcount > 0)
+		return;
+
+	invalidate_parent_data(connection, path);
+
+	dbus_connection_unregister_object_path(connection, path);
+}
+
+static gboolean check_signal(DBusConnection *conn, const char *path,
+				const char *interface, const char *name,
+				const char **args)
+{
+	struct generic_data *data = NULL;
+	struct interface_data *iface;
+	GDBusSignalTable *signal;
+
+	*args = NULL;
+	if (!dbus_connection_get_object_path_data(conn, path,
+					(void *) &data) || !data) {
+		error("dbus_connection_emit_signal: path %s isn't registered",
+				path);
+		return FALSE;
+	}
+
+	iface = find_interface(data->interfaces, interface);
+
+	if (!iface) {
+		error("dbus_connection_emit_signal: %s does not implement %s",
+				path, interface);
+		return FALSE;
+	}
+
+	for (signal = iface->signals; signal && signal->name; signal++) {
+		if (!strcmp(signal->name, name)) {
+			*args = signal->signature;
+			break;
+		}
+	}
+
+	if (!*args) {
+		error("No signal named %s on interface %s", name, interface);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static dbus_bool_t emit_signal_valist(DBusConnection *conn,
+						const char *path,
+						const char *interface,
+						const char *name,
+						int first,
+						va_list var_args)
+{
+	DBusMessage *signal;
+	dbus_bool_t ret;
+	const char *signature, *args;
+
+	if (!check_signal(conn, path, interface, name, &args))
+		return FALSE;
+
+	signal = dbus_message_new_signal(path, interface, name);
+	if (!signal) {
+		error("Unable to allocate new %s.%s signal", interface,  name);
+		return FALSE;
+	}
+
+	ret = dbus_message_append_args_valist(signal, first, var_args);
+	if (!ret)
+		goto fail;
+
+	signature = dbus_message_get_signature(signal);
+	if (strcmp(args, signature) != 0) {
+		error("%s.%s: expected signature'%s' but got '%s'",
+				interface, name, args, signature);
+		ret = FALSE;
+		goto fail;
+	}
+
+	ret = dbus_connection_send(conn, signal, NULL);
+
+fail:
+	dbus_message_unref(signal);
+
+	return ret;
+}
+
+gboolean g_dbus_register_interface(DBusConnection *connection,
+					const char *path, const char *name,
+					GDBusMethodTable *methods,
+					GDBusSignalTable *signals,
+					GDBusPropertyTable *properties,
+					void *user_data,
+					GDBusDestroyFunction destroy)
+{
+	struct generic_data *data;
+	struct interface_data *iface;
+
+	data = object_path_ref(connection, path);
+	if (data == NULL)
+		return FALSE;
+
+	if (find_interface(data->interfaces, name))
+		return FALSE;
+
+	iface = g_new0(struct interface_data, 1);
+
+	iface->name = g_strdup(name);
+	iface->methods = methods;
+	iface->signals = signals;
+	iface->properties = properties;
+	iface->user_data = user_data;
+	iface->destroy = destroy;
+
+	data->interfaces = g_slist_append(data->interfaces, iface);
+
+	g_free(data->introspect);
+	data->introspect = NULL;
+
+	return TRUE;
+}
+
+gboolean g_dbus_unregister_interface(DBusConnection *connection,
+					const char *path, const char *name)
+{
+	struct generic_data *data = NULL;
+	struct interface_data *iface;
+
+	if (dbus_connection_get_object_path_data(connection, path,
+						(void *) &data) == FALSE)
+		return FALSE;
+
+	if (data == NULL)
+		return FALSE;
+
+	iface = find_interface(data->interfaces, name);
+	if (!iface)
+		return FALSE;
+
+	data->interfaces = g_slist_remove(data->interfaces, iface);
+
+	if (iface->destroy)
+		iface->destroy(iface->user_data);
+
+	g_free(iface->name);
+	g_free(iface);
+
+	g_free(data->introspect);
+	data->introspect = NULL;
+
+	object_path_unref(connection, path);
+
+	return TRUE;
+}
+
+DBusMessage *g_dbus_create_error_valist(DBusMessage *message, const char *name,
+					const char *format, va_list args)
+{
+	return dbus_message_new_error(message, name, format);
+}
+
+DBusMessage *g_dbus_create_error(DBusMessage *message, const char *name,
+						const char *format, ...)
+{
+	va_list args;
+	DBusMessage *reply;
+
+	va_start(args, format);
+
+	reply = g_dbus_create_error_valist(message, name, format, args);
+
+	va_end(args);
+
+	return reply;
+}
+
+DBusMessage *g_dbus_create_reply_valist(DBusMessage *message,
+						int type, va_list args)
+{
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(message);
+	if (reply == NULL)
+		return NULL;
+
+	if (dbus_message_append_args_valist(reply, type, args) == FALSE) {
+		dbus_message_unref(reply);
+		return NULL;
+	}
+
+	return reply;
+}
+
+DBusMessage *g_dbus_create_reply(DBusMessage *message, int type, ...)
+{
+	va_list args;
+	DBusMessage *reply;
+
+	va_start(args, type);
+
+	reply = g_dbus_create_reply_valist(message, type, args);
+
+	va_end(args);
+
+	return reply;
+}
+
+gboolean g_dbus_send_message(DBusConnection *connection, DBusMessage *message)
+{
+	dbus_bool_t result;
+
+	result = dbus_connection_send(connection, message, NULL);
+
+	dbus_message_unref(message);
+
+	return result;
+}
+
+gboolean g_dbus_send_reply_valist(DBusConnection *connection,
+				DBusMessage *message, int type, va_list args)
+{
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(message);
+	if (reply == NULL)
+		return FALSE;
+
+	if (dbus_message_append_args_valist(reply, type, args) == FALSE) {
+		dbus_message_unref(reply);
+		return FALSE;
+	}
+
+	return g_dbus_send_message(connection, reply);
+}
+
+gboolean g_dbus_send_reply(DBusConnection *connection,
+				DBusMessage *message, int type, ...)
+{
+	va_list args;
+	gboolean result;
+
+	va_start(args, type);
+
+	result = g_dbus_send_reply_valist(connection, message, type, args);
+
+	va_end(args);
+
+	return result;
+}
+
+gboolean g_dbus_emit_signal(DBusConnection *connection,
+				const char *path, const char *interface,
+				const char *name, int type, ...)
+{
+        va_list args;
+	gboolean result;
+
+        va_start(args, type);
+
+	result = emit_signal_valist(connection, path, interface,
+							name, type, args);
+
+        va_end(args);
+
+        return result;
+}
+
+gboolean g_dbus_emit_signal_valist(DBusConnection *connection,
+				const char *path, const char *interface,
+				const char *name, int type, va_list args)
+{
+	return emit_signal_valist(connection, path, interface,
+							name, type, args);
+}
diff --git a/gdbus/watch.c b/gdbus/watch.c
new file mode 100644
index 00000000..fb0bef3f
--- /dev/null
+++ b/gdbus/watch.c
@@ -0,0 +1,353 @@
+/*
+ *
+ *  D-Bus helper library
+ *
+ *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "gdbus.h"
+
+#define info(fmt...)
+#define error(fmt...)
+#define debug(fmt...)
+
+static guint listener_id = 0;
+static GSList *name_listeners = NULL;
+
+struct name_callback {
+	GDBusWatchFunction func;
+	void *user_data;
+	guint id;
+};
+
+struct name_data {
+	DBusConnection *connection;
+	char *name;
+	GSList *callbacks;
+};
+
+static struct name_data *name_data_find(DBusConnection *connection,
+							const char *name)
+{
+	GSList *current;
+
+	for (current = name_listeners;
+			current != NULL; current = current->next) {
+		struct name_data *data = current->data;
+
+		if (name == NULL && data->name == NULL) {
+			if (connection == data->connection)
+				return data;
+		} else {
+			if (strcmp(name, data->name) == 0)
+				return data;
+		}
+	}
+
+	return NULL;
+}
+
+static struct name_callback *name_callback_find(GSList *callbacks,
+					GDBusWatchFunction func, void *user_data)
+{
+	GSList *current;
+
+	for (current = callbacks; current != NULL; current = current->next) {
+		struct name_callback *cb = current->data;
+		if (cb->func == func && cb->user_data == user_data)
+			return cb;
+	}
+
+	return NULL;
+}
+
+static void name_data_call_and_free(struct name_data *data)
+{
+	GSList *l;
+
+	for (l = data->callbacks; l != NULL; l = l->next) {
+		struct name_callback *cb = l->data;
+		if (cb->func)
+			cb->func(cb->user_data);
+		g_free(cb);
+	}
+
+	g_slist_free(data->callbacks);
+	g_free(data->name);
+	g_free(data);
+}
+
+static void name_data_free(struct name_data *data)
+{
+	GSList *l;
+
+	for (l = data->callbacks; l != NULL; l = l->next)
+		g_free(l->data);
+
+	g_slist_free(data->callbacks);
+	g_free(data->name);
+	g_free(data);
+}
+
+static int name_data_add(DBusConnection *connection, const char *name,
+				GDBusWatchFunction func, void *user_data, guint id)
+{
+	int first = 1;
+	struct name_data *data = NULL;
+	struct name_callback *cb = NULL;
+
+	cb = g_new(struct name_callback, 1);
+
+	cb->func = func;
+	cb->user_data = user_data;
+	cb->id = id;
+
+	data = name_data_find(connection, name);
+	if (data) {
+		first = 0;
+		goto done;
+	}
+
+	data = g_new0(struct name_data, 1);
+
+	data->connection = connection;
+	data->name = g_strdup(name);
+
+	name_listeners = g_slist_append(name_listeners, data);
+
+done:
+	data->callbacks = g_slist_append(data->callbacks, cb);
+	return first;
+}
+
+static void name_data_remove(DBusConnection *connection,
+			const char *name, GDBusWatchFunction func, void *user_data)
+{
+	struct name_data *data;
+	struct name_callback *cb = NULL;
+
+	data = name_data_find(connection, name);
+	if (!data)
+		return;
+
+	cb = name_callback_find(data->callbacks, func, user_data);
+	if (cb) {
+		data->callbacks = g_slist_remove(data->callbacks, cb);
+		g_free(cb);
+	}
+
+	if (!data->callbacks) {
+		name_listeners = g_slist_remove(name_listeners, data);
+		name_data_free(data);
+	}
+}
+
+static gboolean add_match(DBusConnection *connection, const char *name)
+{
+	DBusError err;
+	char match_string[128];
+
+	snprintf(match_string, sizeof(match_string),
+			"interface=%s,member=NameOwnerChanged,arg0=%s",
+			DBUS_INTERFACE_DBUS, name);
+
+	dbus_error_init(&err);
+
+	dbus_bus_add_match(connection, match_string, &err);
+
+	if (dbus_error_is_set(&err)) {
+		error("Adding match rule \"%s\" failed: %s", match_string,
+				err.message);
+		dbus_error_free(&err);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean remove_match(DBusConnection *connection, const char *name)
+{
+	DBusError err;
+	char match_string[128];
+
+	snprintf(match_string, sizeof(match_string),
+			"interface=%s,member=NameOwnerChanged,arg0=%s",
+			DBUS_INTERFACE_DBUS, name);
+
+	dbus_error_init(&err);
+
+	dbus_bus_remove_match(connection, match_string, &err);
+
+	if (dbus_error_is_set(&err)) {
+		error("Removing owner match rule for %s failed: %s",
+				name, err.message);
+		dbus_error_free(&err);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static DBusHandlerResult name_exit_filter(DBusConnection *connection,
+					DBusMessage *message, void *user_data)
+{
+	GSList *l;
+	struct name_data *data;
+	char *name, *old, *new;
+
+	if (!dbus_message_is_signal(message, DBUS_INTERFACE_DBUS,
+							"NameOwnerChanged"))
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	if (!dbus_message_get_args(message, NULL,
+				DBUS_TYPE_STRING, &name,
+				DBUS_TYPE_STRING, &old,
+				DBUS_TYPE_STRING, &new,
+				DBUS_TYPE_INVALID)) {
+		error("Invalid arguments for NameOwnerChanged signal");
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+
+	/* We are not interested of service creations */
+	if (*new != '\0')
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	data = name_data_find(connection, name);
+	if (!data) {
+		error("Got NameOwnerChanged signal for %s which has no listeners", name);
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+
+	for (l = data->callbacks; l != NULL; l = l->next) {
+		struct name_callback *cb = l->data;
+		cb->func(cb->user_data);
+	}
+
+	name_listeners = g_slist_remove(name_listeners, data);
+	name_data_free(data);
+
+	remove_match(connection, name);
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+guint g_dbus_add_disconnect_watch(DBusConnection *connection,
+				const char *name,
+				GDBusWatchFunction func,
+				void *user_data, GDBusDestroyFunction destroy)
+{
+	int first;
+
+	if (!listener_id) {
+		if (!dbus_connection_add_filter(connection,
+					name_exit_filter, NULL, NULL)) {
+			error("dbus_connection_add_filter() failed");
+			return 0;
+		}
+	}
+
+	listener_id++;
+	first = name_data_add(connection, name, func, user_data, listener_id);
+	/* The filter is already added if this is not the first callback
+	 * registration for the name */
+	if (!first)
+		return listener_id;
+
+	if (name) {
+		debug("name_listener_add(%s)", name);
+
+		if (!add_match(connection, name)) {
+			name_data_remove(connection, name, func, user_data);
+			return 0;
+		}
+	}
+
+	return listener_id;
+}
+
+guint g_dbus_add_signal_watch(DBusConnection *connection,
+				const char *rule, GDBusSignalFunction function,
+				void *user_data, GDBusDestroyFunction destroy)
+{
+	return 0;
+}
+
+gboolean g_dbus_remove_watch(DBusConnection *connection, guint id)
+{
+	struct name_data *data;
+	struct name_callback *cb;
+	GSList *ldata, *lcb;
+
+	if (id == 0)
+		return FALSE;
+
+	for (ldata = name_listeners; ldata; ldata = ldata->next) {
+		data = ldata->data;
+		for (lcb = data->callbacks; lcb; lcb = lcb->next) {
+			cb = lcb->data;
+			if (cb->id == id)
+				goto remove;
+		}
+	}
+
+	return FALSE;
+
+remove:
+	data->callbacks = g_slist_remove(data->callbacks, cb);
+	g_free(cb);
+
+	/* Don't remove the filter if other callbacks exist */
+	if (data->callbacks)
+		return TRUE;
+
+	if (data->name) {
+		if (!remove_match(data->connection, data->name))
+			return FALSE;
+	}
+
+	name_listeners = g_slist_remove(name_listeners, data);
+	name_data_free(data);
+
+	return TRUE;
+}
+
+void g_dbus_remove_all_watches(DBusConnection *connection)
+{
+	struct name_data *data;
+
+	data = name_data_find(connection, NULL);
+	if (!data) {
+		error("name_listener_indicate_disconnect: no listener found");
+		return;
+	}
+
+	debug("name_listener_indicate_disconnect");
+
+	name_data_call_and_free(data);
+}
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 96b59b33..3aee1327 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -13,7 +13,7 @@ wifi_la_SOURCES = wifi.c supplicant.h supplicant.c
 bluetooth_la_SOURCES = bluetooth.c
 
 dhclient_la_SOURCES = dhclient.c
-dhclient_la_CFLAGS = @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
+dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
 ipv4_la_SOURCES = ipv4.c
@@ -49,7 +49,7 @@ else
 scriptdir = $(libdir)/connman/scripts
 endif
 
-AM_CFLAGS = @GDBUS_CFLAGS@
+AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/src/Makefile.am b/src/Makefile.am
index f959379f..9518f28d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -14,7 +14,7 @@ sbin_PROGRAMS = connmand
 connmand_SOURCES = main.c connman.h log.c plugin.c profile.c element.c \
 					storage.c manager.c agent.c rtnl.c
 
-connmand_LDADD = @SQLITE_LIBS@ @GDBUS_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
+connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
 
 connmand_LDFLAGS = -Wl,--version-script=connman.ver
 
@@ -32,7 +32,7 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GDBUS_CFLAGS@ @SQLITE_CFLAGS@ \
+AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
 			-DSTATEDIR=\""$(statedir)"\" \
 			-DSTORAGEDIR=\""$(storagedir)\"" \
 			-DPLUGINDIR=\""$(plugindir)"\"
diff --git a/src/main.c b/src/main.c
index 77dff018..87efa00e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -175,7 +175,7 @@ int main(int argc, char *argv[])
 
 	__connman_log_cleanup();
 
-	g_dbus_cleanup_connection(conn);
+	dbus_connection_unref(conn);
 
 	g_main_loop_unref(main_loop);
 

commit 495ba1eff89bd0a466c07c35c57c65cdb7aee39e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 01:15:49 2008 +0200

    Update requirements

diff --git a/README b/README
index f6be6fbf..246b56aa 100644
--- a/README
+++ b/README
@@ -11,9 +11,9 @@ In order to compile libgdbus you need following software packages:
 	- GCC compiler
 	- GLib library
 	- D-Bus library
-	- GDBus library
-	- HAL library
-	- SQLite3 library
+	- HAL library (optional)
+	- SQLite3 library (optional)
+	- PolicyKit (optional)
 
 To configure run:
 	./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var

commit 6d183c9e8bbce62b4bcb3f26be3176b981615222
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 02:22:38 2008 +0200

    Add security access policy framework

diff --git a/include/Makefile.am b/include/Makefile.am
index 89c5aa51..76057be1 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,8 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h driver.h element.h property.h rtnl.h dbus.h
+include_HEADERS = log.h plugin.h security.h driver.h element.h property.h \
+								rtnl.h dbus.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/security.h b/include/security.h
new file mode 100644
index 00000000..104ca7cf
--- /dev/null
+++ b/include/security.h
@@ -0,0 +1,48 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_SECURITY_H
+#define __CONNMAN_SECURITY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/element.h>
+
+#define CONNMAN_SECURITY_PRIORITY_LOW      -100
+#define CONNMAN_SECURITY_PRIORITY_DEFAULT     0
+#define CONNMAN_SECURITY_PRIORITY_HIGH      100
+
+struct connman_security {
+	const char *name;
+	int priority;
+	int (*authorize_sender) (const char *sender);
+};
+
+extern int connman_security_register(struct connman_security *security);
+extern void connman_security_unregister(struct connman_security *security);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_SECURITY_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 9518f28d..ea4a21d5 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,7 +12,7 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c plugin.c profile.c element.c \
-					storage.c manager.c agent.c rtnl.c
+				security.c storage.c manager.c agent.c rtnl.c
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
 
diff --git a/src/connman.h b/src/connman.h
index 22616f52..fde2bd33 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -54,6 +54,8 @@ void __connman_log_cleanup(void);
 int __connman_plugin_init(void);
 void __connman_plugin_cleanup(void);
 
+#include <connman/security.h>
+
 #include <connman/driver.h>
 #include <connman/element.h>
 
diff --git a/src/security.c b/src/security.c
new file mode 100644
index 00000000..4539ba1f
--- /dev/null
+++ b/src/security.c
@@ -0,0 +1,62 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+static GStaticRWLock security_lock = G_STATIC_RW_LOCK_INIT;
+static GSList *security_list = NULL;
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_security *security1 = a;
+	const struct connman_security *security2 = b;
+
+	return security2->priority - security1->priority;
+}
+
+int connman_security_register(struct connman_security *security)
+{
+	DBG("security %p name %s", security, security->name);
+
+	g_static_rw_lock_writer_lock(&security_lock);
+
+	security_list = g_slist_insert_sorted(security_list, security,
+							compare_priority);
+
+	g_static_rw_lock_writer_unlock(&security_lock);
+
+	return 0;
+}
+
+void connman_security_unregister(struct connman_security *security)
+{
+	DBG("security %p name %s", security, security->name);
+
+	g_static_rw_lock_writer_lock(&security_lock);
+
+	security_list = g_slist_remove(security_list, security);
+
+	g_static_rw_lock_writer_unlock(&security_lock);
+}

commit 531e3460465e6f493eb0b7de2a3b8a7d8959563d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 02:32:56 2008 +0200

    Don't use static library for the included libgdbus

diff --git a/configure.ac b/configure.ac
index e5d9f09b..fdb290b8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -65,7 +65,7 @@ AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
-AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.a $(DBUS_LIBS)'])
+AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 
 PKG_CHECK_MODULES(HAL, hal >= 0.5.8, hal_found=yes, hal_found=no)
 AC_SUBST(HAL_CFLAGS)
diff --git a/gdbus/Makefile.am b/gdbus/Makefile.am
index 756b2fa2..9447555f 100644
--- a/gdbus/Makefile.am
+++ b/gdbus/Makefile.am
@@ -1,7 +1,7 @@
 
-noinst_LIBRARIES = libgdbus.a
+noinst_LTLIBRARIES = libgdbus.la
 
-libgdbus_a_SOURCES = gdbus.h mainloop.c object.c watch.c
+libgdbus_la_SOURCES = gdbus.h mainloop.c object.c watch.c
 
 AM_CFLAGS = @DBUS_CFLAGS@ @GLIB_CFLAGS@
 

commit 81f05550490e222185736eb198d3d760a636722d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 02:34:35 2008 +0200

    Create PolicyKit context and register security callbacks

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 3aee1327..03ac0f3d 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -11,6 +11,7 @@ ethernet_la_SOURCES = ethernet.c
 wifi_la_SOURCES = wifi.c supplicant.h supplicant.c
 
 bluetooth_la_SOURCES = bluetooth.c
+bluetooth_la_LIBADD = @GDBUS_LIBS@
 
 dhclient_la_SOURCES = dhclient.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
@@ -34,7 +35,7 @@ if POLKIT
 plugin_LTLIBRARIES += polkit.la
 
 polkit_la_SOURCES = polkit.c
-polkit_la_LIBADD = @POLKIT_LIBS@
+polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
 polkit_la_CFLAGS = @GLIB_CFLAGS@ @POLKIT_CFLAGS@
 endif
 
diff --git a/plugins/polkit.c b/plugins/polkit.c
index 76e64521..bff357fb 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -23,16 +23,104 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+
+#include <glib.h>
+#include <polkit-dbus/polkit-dbus.h>
+
 #include <connman/plugin.h>
+#include <connman/security.h>
 #include <connman/log.h>
 
+static PolKitContext *polkit_context = NULL;
+
+static int polkit_authorize(const char *sender)
+{
+	DBG("sender %s", sender);
+
+	return -EPERM;
+}
+
+static struct connman_security polkit_security = {
+	.name			= "polkit",
+	.authorize_sender	= polkit_authorize,
+};
+
+static gboolean watch_event(GIOChannel *channel, GIOCondition condition,
+							gpointer user_data)
+{
+	PolKitContext *context = user_data;
+	int fd;
+
+	DBG("context %p", context);
+
+	fd = g_io_channel_unix_get_fd(channel);
+
+	polkit_context_io_func(context, fd);
+
+	return TRUE;
+}
+
+static int add_watch(PolKitContext *context, int fd)
+{
+	GIOChannel *channel;
+	guint id = 0;
+
+	DBG("context %p", context);
+
+	channel = g_io_channel_unix_new(fd);
+	if (channel == NULL)
+		return 0;
+
+	id = g_io_add_watch(channel, G_IO_IN, watch_event, context);
+
+	g_io_channel_unref(channel);
+
+	return id;
+}
+
+static void remove_watch(PolKitContext *context, int id)
+{
+	DBG("context %p", context);
+
+	g_source_remove(id);
+}
+
 static int polkit_init(void)
 {
+	int err;
+
+	polkit_context = polkit_context_new();
+
+	polkit_context_set_io_watch_functions(polkit_context,
+						add_watch, remove_watch);
+
+	if (polkit_context_init(polkit_context, NULL) == FALSE) {
+		connman_error("Can't initialize PolicyKit");
+		polkit_context_unref(polkit_context);
+		polkit_context = NULL;
+		return -EIO;
+	}
+
+	err = connman_security_register(&polkit_security);
+	if (err < 0) {
+		polkit_context_unref(polkit_context);
+		polkit_context = NULL;
+		return err;
+	}
+
 	return 0;
 }
 
 static void polkit_exit(void)
 {
+	connman_security_unregister(&polkit_security);
+
+	if (polkit_context == NULL)
+		return;
+
+	polkit_context_unref(polkit_context);
+	polkit_context = NULL;
 }
 
 CONNMAN_PLUGIN_DEFINE("polkit", "PolicyKit authorization plugin", VERSION,

commit 50553d0bc4e0ad0a882440b816c64dfe6d0fdb71
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 06:45:07 2008 +0200

    Add hook for privileges check

diff --git a/src/connman.h b/src/connman.h
index fde2bd33..19322faf 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -56,6 +56,8 @@ void __connman_plugin_cleanup(void);
 
 #include <connman/security.h>
 
+int __connman_security_check_privileges(DBusMessage *message);
+
 #include <connman/driver.h>
 #include <connman/element.h>
 
diff --git a/src/security.c b/src/security.c
index 4539ba1f..cf4ae7aa 100644
--- a/src/security.c
+++ b/src/security.c
@@ -60,3 +60,32 @@ void connman_security_unregister(struct connman_security *security)
 
 	g_static_rw_lock_writer_unlock(&security_lock);
 }
+
+int __connman_security_check_privileges(DBusMessage *message)
+{
+	GSList *list;
+	const char *sender;
+	int err = -EPERM;
+
+	DBG("message %p", message);
+
+	sender = dbus_message_get_sender(message);
+
+	g_static_rw_lock_reader_lock(&security_lock);
+
+	for (list = security_list; list; list = list->next) {
+		struct connman_security *security = list->data;
+		int err;
+
+		DBG("%s", security->name);
+
+		if (security->authorize_sender) {
+			err = security->authorize_sender(sender);
+			break;
+		}
+	}
+
+	g_static_rw_lock_reader_unlock(&security_lock);
+
+	return err;
+}

commit 3b967d36b32d6bfb156e82ac116c7881f69febd4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 07:18:47 2008 +0200

    Add PolicyKit policy configuration file

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 03ac0f3d..9667d26f 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -37,6 +37,10 @@ plugin_LTLIBRARIES += polkit.la
 polkit_la_SOURCES = polkit.c
 polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
 polkit_la_CFLAGS = @GLIB_CFLAGS@ @POLKIT_CFLAGS@
+
+policydir = $(datadir)/PolicyKit/policy
+
+policy_DATA = connman.policy
 endif
 
 AM_LDFLAGS = -no-undefined -module -avoid-version \
@@ -54,4 +58,6 @@ AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
+EXTRA_DIST = $(policy_DATA)
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/plugins/connman.policy b/plugins/connman.policy
new file mode 100644
index 00000000..2dcc37c7
--- /dev/null
+++ b/plugins/connman.policy
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE policyconfig PUBLIC
+ "-//freedesktop//DTD PolicyKit Policy Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/PolicyKit/1.0/policyconfig.dtd">
+
+<policyconfig>
+
+  <vendor>Connection Manager</vendor>
+  <icon_name>stock_internet</icon_name>
+
+  <action id="org.moblin.connman.modify">
+    <description>Modify configuration</description>
+    <message>Policy prevents modification of settings</message>
+    <defaults>
+      <allow_inactive>no</allow_inactive>
+      <allow_active>auth_admin_keep_always</allow_active>
+    </defaults>
+  </action>
+
+</policyconfig>

commit bea9c6088b3ad1ccc77fbdf7c73ff1e564b277e6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 07:21:09 2008 +0200

    Add authorization callback for privileges check

diff --git a/plugins/polkit.c b/plugins/polkit.c
index bff357fb..7bed0b11 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -32,13 +32,47 @@
 #include <connman/security.h>
 #include <connman/log.h>
 
-static PolKitContext *polkit_context = NULL;
+#define ACTION "org.moblin.connman.modify"
+
+static DBusConnection *connection;
+static PolKitContext *polkit_context;
 
 static int polkit_authorize(const char *sender)
 {
+	DBusError error;
+	PolKitCaller *caller;
+	PolKitAction *action;
+	PolKitResult result;
+
 	DBG("sender %s", sender);
 
-	return -EPERM;
+	dbus_error_init(&error);
+
+	caller = polkit_caller_new_from_dbus_name(connection, sender, &error);
+	if (caller == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Failed to get caller information");
+		return -EIO;
+	}
+
+	action = polkit_action_new();
+	polkit_action_set_action_id(action, ACTION);
+
+	result = polkit_context_is_caller_authorized(polkit_context,
+						action, caller, TRUE, NULL);
+
+	polkit_action_unref(action);
+	polkit_caller_unref(caller);
+
+	DBG("result %s", polkit_result_to_string_representation(result));
+
+	if (result == POLKIT_RESULT_NO)
+		return -EPERM;
+
+	return 0;
 }
 
 static struct connman_security polkit_security = {
@@ -90,6 +124,10 @@ static int polkit_init(void)
 {
 	int err;
 
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (connection == NULL)
+		return -EIO;
+
 	polkit_context = polkit_context_new();
 
 	polkit_context_set_io_watch_functions(polkit_context,
@@ -98,14 +136,14 @@ static int polkit_init(void)
 	if (polkit_context_init(polkit_context, NULL) == FALSE) {
 		connman_error("Can't initialize PolicyKit");
 		polkit_context_unref(polkit_context);
-		polkit_context = NULL;
+		dbus_connection_unref(connection);
 		return -EIO;
 	}
 
 	err = connman_security_register(&polkit_security);
 	if (err < 0) {
 		polkit_context_unref(polkit_context);
-		polkit_context = NULL;
+		dbus_connection_unref(connection);
 		return err;
 	}
 
@@ -116,11 +154,9 @@ static void polkit_exit(void)
 {
 	connman_security_unregister(&polkit_security);
 
-	if (polkit_context == NULL)
-		return;
-
 	polkit_context_unref(polkit_context);
-	polkit_context = NULL;
+
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("polkit", "PolicyKit authorization plugin", VERSION,

commit e25d3bebe018bfbb85cee46376e5e82325c2f4eb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 07:25:25 2008 +0200

    Remove shadow variable messing up the result

diff --git a/src/security.c b/src/security.c
index cf4ae7aa..f81fc465 100644
--- a/src/security.c
+++ b/src/security.c
@@ -75,7 +75,6 @@ int __connman_security_check_privileges(DBusMessage *message)
 
 	for (list = security_list; list; list = list->next) {
 		struct connman_security *security = list->data;
-		int err;
 
 		DBG("%s", security->name);
 

commit 38ac39ac6d5a2407826f8de6442af4a2bc177c0b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 07:34:34 2008 +0200

    Include connman.policy even if PolicyKit is disabled

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 9667d26f..d210f467 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -58,6 +58,6 @@ AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
-EXTRA_DIST = $(policy_DATA)
+EXTRA_DIST = connman.policy
 
 MAINTAINERCLEANFILES = Makefile.in

commit 4f1f10a796d17381a348631bd282828175252250
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 07:47:50 2008 +0200

    Start consolidating D-Bus errors

diff --git a/src/Makefile.am b/src/Makefile.am
index ea4a21d5..9c12a8b6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,8 +11,8 @@ DISTCLEANFILES = $(service_DATA)
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h log.c plugin.c profile.c element.c \
-				security.c storage.c manager.c agent.c rtnl.c
+connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
+		element.c security.c storage.c manager.c agent.c rtnl.c
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
 
diff --git a/src/connman.h b/src/connman.h
index 19322faf..7bde14e4 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -27,6 +27,8 @@
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
 
+DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
+
 int __connman_storage_init(void);
 void __connman_storage_cleanup(void);
 
diff --git a/src/error.c b/src/error.c
new file mode 100644
index 00000000..627cf3d7
--- /dev/null
+++ b/src/error.c
@@ -0,0 +1,34 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gdbus.h>
+
+#include "connman.h"
+
+DBusMessage *__connman_error_permission_denied(DBusMessage *msg)
+{
+	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
+						".PermissionDenied", NULL);
+}

commit 57c5667aad64cb90aa4caf09e4b014deb0ee9805
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 10:25:51 2008 +0200

    Add checks for gtk-doc availability

diff --git a/acinclude.m4 b/acinclude.m4
index 95486c3d..9c51ddfc 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -9,3 +9,37 @@ AC_DEFUN([AC_PROG_CC_PIE], [
 		rm -rf conftest*
 	])
 ])
+
+AC_DEFUN([GTK_DOC_CHECK],
+[
+  AC_BEFORE([AC_PROG_LIBTOOL],[$0])dnl setup libtool first
+  AC_BEFORE([AM_PROG_LIBTOOL],[$0])dnl setup libtool first
+  dnl for overriding the documentation installation directory
+  AC_ARG_WITH([html-dir],
+    AS_HELP_STRING([--with-html-dir=PATH], [path to installed docs]),,
+    [with_html_dir='${datadir}/gtk-doc/html'])
+  HTML_DIR="$with_html_dir"
+  AC_SUBST([HTML_DIR])
+
+  dnl enable/disable documentation building
+  AC_ARG_ENABLE([gtk-doc],
+    AS_HELP_STRING([--enable-gtk-doc],
+                   [use gtk-doc to build documentation [[default=no]]]),,
+    [enable_gtk_doc=no])
+
+  if test x$enable_gtk_doc = xyes; then
+    ifelse([$1],[],
+      [PKG_CHECK_EXISTS([gtk-doc],,
+                        AC_MSG_ERROR([gtk-doc not installed and --enable-gtk-doc requested]))],
+      [PKG_CHECK_EXISTS([gtk-doc >= $1],,
+                        AC_MSG_ERROR([You need to have gtk-doc >= $1 installed to build gtk-doc]))])
+  fi
+
+  AC_MSG_CHECKING([whether to build gtk-doc documentation])
+  AC_MSG_RESULT($enable_gtk_doc)
+
+  AC_PATH_PROGS(GTKDOC_CHECK,gtkdoc-check,)
+
+  AM_CONDITIONAL([ENABLE_GTK_DOC], [test x$enable_gtk_doc = xyes])
+  AM_CONDITIONAL([GTK_DOC_USE_LIBTOOL], [test -n "$LIBTOOL"])
+])
diff --git a/bootstrap-configure b/bootstrap-configure
index 2b8dc78e..ea6d525d 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -4,8 +4,13 @@ if [ -f config.status ]; then
 	make maintainer-clean
 fi
 
+if [ ! -f doc/gtk-doc.make ]; then
+	gtkdocize --copy --docdir doc
+fi
+
 ./bootstrap && \
     ./configure --enable-maintainer-mode \
+		--enable-gtk-doc \
 		--enable-debug \
 		--prefix=/usr \
 		--mandir=/usr/share/man \
diff --git a/configure.ac b/configure.ac
index fdb290b8..fe70d73e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,6 +24,8 @@ m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 
+GTK_DOC_CHECK
+
 AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&

commit d63f95994d10a83acf9ec59a0f7a0d420d2c0a9c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 10:49:58 2008 +0200

    Add doc/version.xml.in file

diff --git a/configure.ac b/configure.ac
index fe70d73e..d500c684 100644
--- a/configure.ac
+++ b/configure.ac
@@ -84,5 +84,5 @@ AC_SUBST(SQLITE_CFLAGS)
 AC_SUBST(SQLITE_LIBS)
 
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile src/Makefile doc/Makefile
-				test/Makefile plugins/Makefile scripts/Makefile
-				scripts/connman src/connman.service connman.pc)
+		test/Makefile plugins/Makefile scripts/Makefile scripts/connman
+				src/connman.service doc/version.xml connman.pc)
diff --git a/doc/version.xml.in b/doc/version.xml.in
new file mode 100644
index 00000000..d78bda93
--- /dev/null
+++ b/doc/version.xml.in
@@ -0,0 +1 @@
+@VERSION@

commit c81df1b2143f018c25b37b8dbedfef6177394c84
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:29:09 2008 +0200

    Remove new page characters

diff --git a/COPYING b/COPYING
index 3912109b..6d45519c 100644
--- a/COPYING
+++ b/COPYING
@@ -55,7 +55,7 @@ patent must be licensed for everyone's free use or not licensed at all.
 
   The precise terms and conditions for copying, distribution and
 modification follow.
-
+
 		    GNU GENERAL PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
@@ -110,7 +110,7 @@ above, provided that you also meet all of these conditions:
     License.  (Exception: if the Program itself is interactive but
     does not normally print such an announcement, your work based on
     the Program is not required to print an announcement.)
-
+
 These requirements apply to the modified work as a whole.  If
 identifiable sections of that work are not derived from the Program,
 and can be reasonably considered independent and separate works in
@@ -168,7 +168,7 @@ access to copy from a designated place, then offering equivalent
 access to copy the source code from the same place counts as
 distribution of the source code, even though third parties are not
 compelled to copy the source along with the object code.
-
+
   4. You may not copy, modify, sublicense, or distribute the Program
 except as expressly provided under this License.  Any attempt
 otherwise to copy, modify, sublicense or distribute the Program is
@@ -225,7 +225,7 @@ impose that choice.
 
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
-
+
   8. If the distribution and/or use of the Program is restricted in
 certain countries either by patents or by copyrighted interfaces, the
 original copyright holder who places the Program under this License
@@ -278,7 +278,7 @@ PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGES.
 
 		     END OF TERMS AND CONDITIONS
-
+
 	    How to Apply These Terms to Your New Programs
 
   If you develop a new program, and you want it to be of the greatest

commit 7697141802ceee91fd9615f4a2bea67cf9aaa281
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:30:36 2008 +0200

    Process documentation directory last

diff --git a/Makefile.am b/Makefile.am
index 66e0a0bc..b956e868 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = gdbus include src doc test plugins scripts
+SUBDIRS = gdbus include src plugins scripts test doc
 
 pkgconfigdir = $(libdir)/pkgconfig
 

commit 76869fdcc39c672cc3b1b04cbfdc20eea91970cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:39:29 2008 +0200

    Add skeleton for documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 62aa9bce..de2b0918 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,4 +1,30 @@
 
-EXTRA_DIST = manager-api.txt element-api.txt agent-api.txt plugin-api.txt
+DOC_MODULE = connman
 
-MAINTAINERCLEANFILES = Makefile.in
+DOC_MAIN_SGML_FILE = $(DOC_MODULE)-docs.xml
+
+DOC_SOURCE_DIR = ../src
+
+MKDB_OPTIONS = --sgml-mode --output-format=xml --tmpl-dir=.
+
+MKTMPL_OPTIONS = --output-dir=.
+
+HFILE_GLOB = $(top_srcdir)/include/*.h
+CFILE_GLOB = $(top_srcdir)/src/*.c
+
+IGNORE_HFILES = config.h connman.h
+
+HTML_IMAGES =
+
+content_files = version.xml connman-introduction.xml
+
+INCLUDES = -I$(top_srcdir) $(GLIB_CFLAGS) $(DBUS_CFLAGS)
+
+GTKDOC_LIBS =
+
+MAINTAINERCLEANFILES = Makefile.in \
+	$(DOC_MODULE).types $(DOC_MODULE)-*.sgml $(DOC_MODULE)-*.txt
+
+include $(top_srcdir)/doc/gtk-doc.make
+
+EXTRA_DIST += manager-api.txt element-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
new file mode 100644
index 00000000..fea3fc0b
--- /dev/null
+++ b/doc/connman-docs.xml
@@ -0,0 +1,79 @@
+<?xml version="1.0"?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
+               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY version SYSTEM "version.xml">
+]>
+<book id="index" xmlns:xi="http://www.w3.org/2003/XInclude">
+  <bookinfo>
+    <title>Connection Manager Reference Manual</title>
+    <releaseinfo>Version &version;</releaseinfo>
+    <authorgroup>
+      <author>
+	<firstname>Marcel</firstname>
+	<surname>Holtmann</surname>
+	<affiliation>
+	  <address>
+	    <email>marcel@holtmann.org</email>
+	  </address>
+	</affiliation>
+      </author>
+    </authorgroup>
+
+    <copyright>
+      <year>2007-2008</year>
+      <holder>Intel Corporation. All rights reserved.</holder>
+    </copyright>
+
+    <legalnotice>
+      <para>
+	Permission is granted to copy, distribute and/or modify this
+	document under the terms of the <citetitle>GNU Free
+	Documentation License</citetitle>, Version 1.1 or any later
+	version published by the Free Software Foundation with no
+	Invariant Sections, no Front-Cover Texts, and no Back-Cover
+	Texts. You may obtain a copy of the <citetitle>GNU Free
+	Documentation License</citetitle> from the Free Software
+	Foundation by visiting <ulink type="http"
+	url="http://www.fsf.org">their Web site</ulink> or by writing
+	to:
+
+	<address>
+	  The Free Software Foundation, Inc.,
+	  <street>59 Temple Place</street> - Suite 330,
+	  <city>Boston</city>, <state>MA</state> <postcode>02111-1307</postcode>,
+	  <country>USA</country>
+	</address>
+      </para>
+    </legalnotice>
+  </bookinfo>
+
+  <reference id="design">
+    <title>Design Overview</title>
+    <partintro>
+      <para>
+	This part presents the design documentation for Connection Manager.
+      </para>
+    </partintro>
+    <xi:include href="connman-introduction.xml" />
+  </reference>
+
+  <reference id="reference">
+    <title>API Reference</title>
+    <partintro>
+      <para>
+	This part presents the function reference for Connection Manager.
+      </para>
+    </partintro>
+  </reference>
+
+  <index>
+    <title>Index</title>
+  </index>
+
+  <appendix id="license">
+    <title>License</title>
+    <para>
+<programlisting><xi:include href="../COPYING" parse="text" /></programlisting>
+    </para>
+  </appendix>
+</book>
diff --git a/doc/connman-introduction.xml b/doc/connman-introduction.xml
new file mode 100644
index 00000000..4672c2c7
--- /dev/null
+++ b/doc/connman-introduction.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0"?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
+               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
+
+<chapter id="introduction">
+  <title>Introduction</title>
+  
+  <sect1 id="intro-about">
+    <title>About</title>
+    
+    <para>
+    </para>
+  </sect1>
+
+</chapter>

commit c2c61d560ec77f5f98b55f51d926bc2b5290d829
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:41:53 2008 +0200

    Provide a copy of gtk-doc.make

diff --git a/doc/gtk-doc.make b/doc/gtk-doc.make
new file mode 100644
index 00000000..354ffb7c
--- /dev/null
+++ b/doc/gtk-doc.make
@@ -0,0 +1,173 @@
+# -*- mode: makefile -*-
+
+####################################
+# Everything below here is generic #
+####################################
+
+if GTK_DOC_USE_LIBTOOL
+GTKDOC_CC = $(LIBTOOL) --mode=compile $(CC) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+GTKDOC_LD = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS)
+else
+GTKDOC_CC = $(CC) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+GTKDOC_LD = $(CC) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS)
+endif
+
+# We set GPATH here; this gives us semantics for GNU make
+# which are more like other make's VPATH, when it comes to
+# whether a source that is a target of one rule is then
+# searched for in VPATH/GPATH.
+#
+GPATH = $(srcdir)
+
+TARGET_DIR=$(HTML_DIR)/$(DOC_MODULE)
+
+EXTRA_DIST = 				\
+	$(content_files)		\
+	$(HTML_IMAGES)			\
+	$(DOC_MAIN_SGML_FILE)		\
+	$(DOC_MODULE)-sections.txt	\
+	$(DOC_MODULE)-overrides.txt
+
+DOC_STAMPS=scan-build.stamp tmpl-build.stamp sgml-build.stamp html-build.stamp \
+	   $(srcdir)/tmpl.stamp $(srcdir)/sgml.stamp $(srcdir)/html.stamp
+
+SCANOBJ_FILES = 		 \
+	$(DOC_MODULE).args 	 \
+	$(DOC_MODULE).hierarchy  \
+	$(DOC_MODULE).interfaces \
+	$(DOC_MODULE).prerequisites \
+	$(DOC_MODULE).signals
+
+REPORT_FILES = \
+	$(DOC_MODULE)-undocumented.txt \
+	$(DOC_MODULE)-undeclared.txt \
+	$(DOC_MODULE)-unused.txt
+
+CLEANFILES = $(SCANOBJ_FILES) $(REPORT_FILES) $(DOC_STAMPS)
+
+if ENABLE_GTK_DOC
+all-local: html-build.stamp
+else
+all-local:
+endif
+
+docs: html-build.stamp
+
+#### scan ####
+
+scan-build.stamp: $(HFILE_GLOB) $(CFILE_GLOB)
+	@echo 'gtk-doc: Scanning header files'
+	@-chmod -R u+w $(srcdir)
+	cd $(srcdir) && \
+	  gtkdoc-scan --module=$(DOC_MODULE) --source-dir=$(DOC_SOURCE_DIR) --ignore-headers="$(IGNORE_HFILES)" $(SCAN_OPTIONS) $(EXTRA_HFILES)
+	if grep -l '^..*$$' $(srcdir)/$(DOC_MODULE).types > /dev/null 2>&1 ; then \
+	    CC="$(GTKDOC_CC)" LD="$(GTKDOC_LD)" CFLAGS="$(GTKDOC_CFLAGS)" LDFLAGS="$(GTKDOC_LIBS)" gtkdoc-scangobj $(SCANGOBJ_OPTIONS) --module=$(DOC_MODULE) --output-dir=$(srcdir) ; \
+	else \
+	    cd $(srcdir) ; \
+	    for i in $(SCANOBJ_FILES) ; do \
+               test -f $$i || touch $$i ; \
+	    done \
+	fi
+	touch scan-build.stamp
+
+$(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt: scan-build.stamp
+	@true
+
+#### templates ####
+
+tmpl-build.stamp: $(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt
+	@echo 'gtk-doc: Rebuilding template files'
+	@-chmod -R u+w $(srcdir)
+	cd $(srcdir) && gtkdoc-mktmpl --module=$(DOC_MODULE) $(MKTMPL_OPTIONS)
+	touch tmpl-build.stamp
+
+tmpl.stamp: tmpl-build.stamp
+	@true
+
+tmpl/*.sgml:
+	@true
+
+
+#### xml ####
+
+sgml-build.stamp: tmpl.stamp $(HFILE_GLOB) $(CFILE_GLOB) $(DOC_MODULE)-sections.txt $(srcdir)/tmpl/*.sgml $(expand_content_files)
+	@echo 'gtk-doc: Building XML'
+	@-chmod -R u+w $(srcdir)
+	cd $(srcdir) && \
+	gtkdoc-mkdb --module=$(DOC_MODULE) --source-dir=$(DOC_SOURCE_DIR) --output-format=xml --expand-content-files="$(expand_content_files)" --main-sgml-file=$(DOC_MAIN_SGML_FILE) $(MKDB_OPTIONS)
+	touch sgml-build.stamp
+
+sgml.stamp: sgml-build.stamp
+	@true
+
+#### html ####
+
+html-build.stamp: sgml.stamp $(DOC_MAIN_SGML_FILE) $(content_files)
+	@echo 'gtk-doc: Building HTML'
+	@-chmod -R u+w $(srcdir)
+	rm -rf $(srcdir)/html
+	mkdir $(srcdir)/html
+	cd $(srcdir)/html && gtkdoc-mkhtml $(DOC_MODULE) ../$(DOC_MAIN_SGML_FILE)
+	test "x$(HTML_IMAGES)" = "x" || ( cd $(srcdir) && cp $(HTML_IMAGES) html )
+	@echo 'gtk-doc: Fixing cross-references'
+	cd $(srcdir) && gtkdoc-fixxref --module-dir=html --html-dir=$(HTML_DIR) $(FIXXREF_OPTIONS)
+	touch html-build.stamp
+
+##############
+
+clean-local:
+	rm -f *~ *.bak
+	rm -rf .libs
+
+distclean-local:
+	cd $(srcdir) && \
+	  rm -rf xml $(REPORT_FILES) \
+	         $(DOC_MODULE)-decl-list.txt $(DOC_MODULE)-decl.txt
+
+maintainer-clean-local: clean
+	cd $(srcdir) && rm -rf xml html
+
+install-data-local:
+	-installfiles=`echo $(srcdir)/html/*`; \
+	if test "$$installfiles" = '$(srcdir)/html/*'; \
+	then echo '-- Nothing to install' ; \
+	else \
+	  $(mkinstalldirs) $(DESTDIR)$(TARGET_DIR); \
+	  for i in $$installfiles; do \
+	    echo '-- Installing '$$i ; \
+	    $(INSTALL_DATA) $$i $(DESTDIR)$(TARGET_DIR); \
+	  done; \
+	  echo '-- Installing $(srcdir)/html/index.sgml' ; \
+	  $(INSTALL_DATA) $(srcdir)/html/index.sgml $(DESTDIR)$(TARGET_DIR) || :; \
+	  which gtkdoc-rebase >/dev/null && \
+	    gtkdoc-rebase --relative --dest-dir=$(DESTDIR) --html-dir=$(DESTDIR)$(TARGET_DIR) ; \
+	fi
+	
+
+uninstall-local:
+	rm -f $(DESTDIR)$(TARGET_DIR)/*
+
+#
+# Require gtk-doc when making dist
+#
+if ENABLE_GTK_DOC
+dist-check-gtkdoc:
+else
+dist-check-gtkdoc:
+	@echo "*** gtk-doc must be installed and enabled in order to make dist"
+	@false
+endif
+
+dist-hook: dist-check-gtkdoc dist-hook-local
+	mkdir $(distdir)/tmpl
+	mkdir $(distdir)/xml
+	mkdir $(distdir)/html
+	-cp $(srcdir)/tmpl/*.sgml $(distdir)/tmpl
+	-cp $(srcdir)/xml/*.xml $(distdir)/xml
+	cp $(srcdir)/html/* $(distdir)/html
+	-cp $(srcdir)/$(DOC_MODULE).types $(distdir)/
+	-cp $(srcdir)/$(DOC_MODULE)-sections.txt $(distdir)/
+	cd $(distdir) && rm -f $(DISTCLEANFILES)
+	-gtkdoc-rebase --online --relative --html-dir=$(distdir)/html
+
+.PHONY : dist-hook-local docs

commit 7e8c003204bc3fd269a96474059c6ee716c0434a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:44:31 2008 +0200

    Disable gtk-doc for distcheck process

diff --git a/Makefile.am b/Makefile.am
index b956e868..0b875b7d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -5,6 +5,8 @@ pkgconfigdir = $(libdir)/pkgconfig
 
 pkgconfig_DATA = connman.pc
 
+DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc
+
 DISTCLEANFILES = $(pkgconfig_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in \

commit 067c3ad4bd5e3ba66675af9439f4d68582bb9d69
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:55:01 2008 +0200

    Make gtk-doc processing fully optional

diff --git a/doc/Makefile.am b/doc/Makefile.am
index de2b0918..c7b59b68 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -16,7 +16,7 @@ IGNORE_HFILES = config.h connman.h
 
 HTML_IMAGES =
 
-content_files = version.xml connman-introduction.xml
+content_files = connman-introduction.xml
 
 INCLUDES = -I$(top_srcdir) $(GLIB_CFLAGS) $(DBUS_CFLAGS)
 
@@ -25,6 +25,10 @@ GTKDOC_LIBS =
 MAINTAINERCLEANFILES = Makefile.in \
 	$(DOC_MODULE).types $(DOC_MODULE)-*.sgml $(DOC_MODULE)-*.txt
 
+if ENABLE_GTK_DOC
 include $(top_srcdir)/doc/gtk-doc.make
+else
+EXTRA_DIST = $(DOC_MAIN_SGML_FILE) $(content_files)
+endif
 
 EXTRA_DIST += manager-api.txt element-api.txt agent-api.txt plugin-api.txt

commit b5fc727db22139bb3f28367d1f31f241ccc1e236
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 13 12:56:45 2008 +0200

    Put the license before the index

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index fea3fc0b..d070a3d6 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -66,14 +66,14 @@
     </partintro>
   </reference>
 
-  <index>
-    <title>Index</title>
-  </index>
-
   <appendix id="license">
     <title>License</title>
     <para>
 <programlisting><xi:include href="../COPYING" parse="text" /></programlisting>
     </para>
   </appendix>
+
+  <index>
+    <title>Index</title>
+  </index>
 </book>

commit a6d8f4bb835dc01344861e26b78867273322cb52
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 14 01:25:48 2008 +0200

    First steps into providing API documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index c7b59b68..a2e92058 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -5,25 +5,32 @@ DOC_MAIN_SGML_FILE = $(DOC_MODULE)-docs.xml
 
 DOC_SOURCE_DIR = ../src
 
-MKDB_OPTIONS = --sgml-mode --output-format=xml --tmpl-dir=.
+SCAN_OPTIONS = --rebuild-sections --source-dir=../include
+
+MKDB_OPTIONS = --sgml-mode --output-format=xml --tmpl-dir=. \
+						--ignore-files=connman \
+						--source-dir=../include \
+						--source-suffixes=c,h
 
 MKTMPL_OPTIONS = --output-dir=.
 
 HFILE_GLOB = $(top_srcdir)/include/*.h
-CFILE_GLOB = $(top_srcdir)/src/*.c
+CFILE_GLOB = $(top_srcdir)/src/*.c $(top_srcdir)/src/*.h
 
-IGNORE_HFILES = config.h connman.h
+IGNORE_HFILES = connman connman.h supplicant.h \
+		iface.h rtnl.h dbus.h element.h property.h driver.h security.h
 
 HTML_IMAGES =
 
 content_files = connman-introduction.xml
 
-INCLUDES = -I$(top_srcdir) $(GLIB_CFLAGS) $(DBUS_CFLAGS)
+INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/gdbus \
+	$(GTHREAD_CFLAGS) $(GMODULE_CFLAGS) $(GLIB_CFLAGS) $(DBUS_CFLAGS)
 
-GTKDOC_LIBS =
+GTKDOC_LIBS = $(DBUS_LIBS) $(GLIB_LIBS) $(GMODULE_LIBS) $(GTHREAD_LIBS)
 
 MAINTAINERCLEANFILES = Makefile.in \
-	$(DOC_MODULE).types $(DOC_MODULE)-*.sgml $(DOC_MODULE)-*.txt
+	$(DOC_MODULE).types $(DOC_MODULE)-*.txt *.sgml
 
 if ENABLE_GTK_DOC
 include $(top_srcdir)/doc/gtk-doc.make
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index d070a3d6..4674a627 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -64,6 +64,8 @@
 	This part presents the function reference for Connection Manager.
       </para>
     </partintro>
+    <xi:include href="xml/log.xml" />
+    <xi:include href="xml/plugin.xml" />
   </reference>
 
   <appendix id="license">
diff --git a/include/log.h b/include/log.h
index 8a0b5a52..81a5bc4f 100644
--- a/include/log.h
+++ b/include/log.h
@@ -26,10 +26,24 @@
 extern "C" {
 #endif
 
+/**
+ * SECTION:log
+ * @title: Logging premitives
+ * @short_description: Functions for logging error and debug information
+ */
+
 extern void connman_info(const char *format, ...);
 extern void connman_error(const char *format, ...);
 extern void connman_debug(const char *format, ...);
 
+/**
+ * DBG:
+ * @fmt: format string
+ * @arg...: list of arguments
+ *
+ * Simple macro around connman_debug() which also include the function
+ * name it is called in.
+ */
 #define DBG(fmt, arg...) connman_debug("%s:%s() " fmt, __FILE__, __FUNCTION__ , ## arg)
 
 #ifdef __cplusplus
diff --git a/include/plugin.h b/include/plugin.h
index 387a48c0..427ceede 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -26,6 +26,12 @@
 extern "C" {
 #endif
 
+/**
+ * SECTION:plugin
+ * @title: Plugin premitives
+ * @short_description: Functions for declaring plugins
+ */
+
 struct connman_plugin_desc {
 	const char *name;
 	const char *description;
@@ -34,7 +40,17 @@ struct connman_plugin_desc {
 	void (*exit) (void);
 };
 
-#define CONNMAN_PLUGIN_DEFINE(name,description,version,init,exit) \
+/**
+ * CONNMAN_PLUGIN_DEFINE:
+ * @name: plugin name
+ * @description: plugin description
+ * @version: plugin version string
+ * @init: init function called on plugin loading
+ * @exit: exit function called on plugin removal
+ *
+ * Macro for defining a plugin descriptor
+ */
+#define CONNMAN_PLUGIN_DEFINE(name, description, version, init, exit) \
 		struct connman_plugin_desc connman_plugin_desc = { \
 			name, description, version, init, exit \
 		};
diff --git a/src/log.c b/src/log.c
index 93026d53..b195df2f 100644
--- a/src/log.c
+++ b/src/log.c
@@ -30,6 +30,13 @@
 
 static volatile gboolean debug_enabled = FALSE;
 
+/**
+ * connman_info:
+ * @format: format string
+ * @Varargs: list of arguments
+ *
+ * Output general information
+ */
 void connman_info(const char *format, ...)
 {
 	va_list ap;
@@ -41,6 +48,13 @@ void connman_info(const char *format, ...)
 	va_end(ap);
 }
 
+/**
+ * connman_error:
+ * @format: format string
+ * @varargs: list of arguments
+ *
+ * Output error messages
+ */
 void connman_error(const char *format, ...)
 {
 	va_list ap;
@@ -52,6 +66,16 @@ void connman_error(const char *format, ...)
 	va_end(ap);
 }
 
+/**
+ * connman_debug:
+ * @format: format string
+ * @varargs: list of arguments
+ *
+ * Output debug message
+ *
+ * The actual output of the debug message is controlled via a command line
+ * switch. If not enabled, these messages will be ignored.
+ */
 void connman_debug(const char *format, ...)
 {
 	va_list ap;
diff --git a/src/plugin.c b/src/plugin.c
index d2ee80f6..244aaebf 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -28,8 +28,6 @@
 #include <glib.h>
 #include <gmodule.h>
 
-#include <connman/plugin.h>
-
 #include "connman.h"
 
 static GSList *plugins = NULL;

commit 466c5e32d5dcbc8fb612cdedcca0caa039f4f769
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 14 01:31:02 2008 +0200

    Update .gitignore with gtk-doc generated files

diff --git a/.gitignore b/.gitignore
index c3a0edf1..f4b0834b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -29,3 +29,11 @@ src/connman.ver
 src/connman.service
 scripts/connman
 scripts/dhclient-script
+doc/*.bak
+doc/*.stamp
+doc/connman.*
+doc/connman-*.txt
+doc/*.sgml
+doc/version.xml
+doc/xml
+doc/html

commit 95957bba963cd329416420e3dedc3d0969c3ee9d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 14 06:57:45 2008 +0200

    Add documentation for the security framework

diff --git a/doc/Makefile.am b/doc/Makefile.am
index a2e92058..213deb54 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -18,7 +18,7 @@ HFILE_GLOB = $(top_srcdir)/include/*.h
 CFILE_GLOB = $(top_srcdir)/src/*.c $(top_srcdir)/src/*.h
 
 IGNORE_HFILES = connman connman.h supplicant.h \
-		iface.h rtnl.h dbus.h element.h property.h driver.h security.h
+		iface.h rtnl.h dbus.h element.h property.h driver.h
 
 HTML_IMAGES =
 
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 4674a627..0460192c 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -66,6 +66,7 @@
     </partintro>
     <xi:include href="xml/log.xml" />
     <xi:include href="xml/plugin.xml" />
+    <xi:include href="xml/security.xml" />
   </reference>
 
   <appendix id="license">
diff --git a/include/security.h b/include/security.h
index 104ca7cf..895464ab 100644
--- a/include/security.h
+++ b/include/security.h
@@ -28,6 +28,12 @@ extern "C" {
 
 #include <connman/element.h>
 
+/**
+ * SECTION:security
+ * @title: Security premitives
+ * @short_description: Functions for registering security modules
+ */
+
 #define CONNMAN_SECURITY_PRIORITY_LOW      -100
 #define CONNMAN_SECURITY_PRIORITY_DEFAULT     0
 #define CONNMAN_SECURITY_PRIORITY_HIGH      100
diff --git a/src/security.c b/src/security.c
index f81fc465..05766509 100644
--- a/src/security.c
+++ b/src/security.c
@@ -36,6 +36,14 @@ static gint compare_priority(gconstpointer a, gconstpointer b)
 	return security2->priority - security1->priority;
 }
 
+/**
+ * connman_security_register:
+ * @security: security module
+ *
+ * Register a new security module
+ *
+ * Returns: %0 on success
+ */
 int connman_security_register(struct connman_security *security)
 {
 	DBG("security %p name %s", security, security->name);
@@ -50,6 +58,12 @@ int connman_security_register(struct connman_security *security)
 	return 0;
 }
 
+/**
+ * connman_security_unregister:
+ * @security: security module
+ *
+ * Remove a previously registered security module
+ */
 void connman_security_unregister(struct connman_security *security)
 {
 	DBG("security %p name %s", security, security->name);

commit 164a8db64e48e0b00730c5830b9a7f8293dcf613
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 14 07:25:31 2008 +0200

    Add documentation for the drivers

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 213deb54..0c237a30 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -18,7 +18,7 @@ HFILE_GLOB = $(top_srcdir)/include/*.h
 CFILE_GLOB = $(top_srcdir)/src/*.c $(top_srcdir)/src/*.h
 
 IGNORE_HFILES = connman connman.h supplicant.h \
-		iface.h rtnl.h dbus.h element.h property.h driver.h
+		iface.h rtnl.h dbus.h element.h property.h
 
 HTML_IMAGES =
 
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 0460192c..d3b69b8f 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -67,6 +67,7 @@
     <xi:include href="xml/log.xml" />
     <xi:include href="xml/plugin.xml" />
     <xi:include href="xml/security.xml" />
+    <xi:include href="xml/driver.xml" />
   </reference>
 
   <appendix id="license">
diff --git a/include/driver.h b/include/driver.h
index 8076a0e0..6d212d8f 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -28,6 +28,12 @@ extern "C" {
 
 #include <connman/element.h>
 
+/**
+ * SECTION:driver
+ * @title: Driver premitives
+ * @short_description: Functions for registering drivers
+ */
+
 #define CONNMAN_DRIVER_PRIORITY_LOW      -100
 #define CONNMAN_DRIVER_PRIORITY_DEFAULT     0
 #define CONNMAN_DRIVER_PRIORITY_HIGH      100
diff --git a/src/element.c b/src/element.c
index db7cb4e7..66c91d0b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -363,6 +363,14 @@ static gboolean probe_driver(GNode *node, gpointer data)
 	return FALSE;
 }
 
+/**
+ * connman_driver_register:
+ * @driver: driver definition
+ *
+ * Register a new driver
+ *
+ * Returns: %0 on success
+ */
 int connman_driver_register(struct connman_driver *driver)
 {
 	DBG("driver %p name %s", driver, driver->name);
@@ -406,6 +414,12 @@ static gboolean remove_driver(GNode *node, gpointer data)
 	return FALSE;
 }
 
+/**
+ * connman_driver_unregister:
+ * @driver: driver definition
+ *
+ * Remove a previously registered driver
+ */
 void connman_driver_unregister(struct connman_driver *driver)
 {
 	DBG("driver %p name %s", driver, driver->name);

commit 550cd253b4bf3197ac4e00f0f213fca391d4622f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Aug 14 07:39:50 2008 +0200

    Add documention for the elements

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 0c237a30..9b5367a7 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -17,8 +17,7 @@ MKTMPL_OPTIONS = --output-dir=.
 HFILE_GLOB = $(top_srcdir)/include/*.h
 CFILE_GLOB = $(top_srcdir)/src/*.c $(top_srcdir)/src/*.h
 
-IGNORE_HFILES = connman connman.h supplicant.h \
-		iface.h rtnl.h dbus.h element.h property.h
+IGNORE_HFILES = connman connman.h rtnl.h dbus.h iface.h
 
 HTML_IMAGES =
 
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index d3b69b8f..29bc8533 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -67,6 +67,7 @@
     <xi:include href="xml/log.xml" />
     <xi:include href="xml/plugin.xml" />
     <xi:include href="xml/security.xml" />
+    <xi:include href="xml/element.xml" />
     <xi:include href="xml/driver.xml" />
   </reference>
 
diff --git a/include/element.h b/include/element.h
index 9b8beabc..e2d7ea8a 100644
--- a/include/element.h
+++ b/include/element.h
@@ -31,6 +31,12 @@ extern "C" {
 
 #include <connman/property.h>
 
+/**
+ * SECTION:element
+ * @title: Element premitives
+ * @short_description: Functions for handling elements
+ */
+
 enum connman_element_state {
 	CONNMAN_ELEMENT_STATE_UNKNOWN   = 0,
 	CONNMAN_ELEMENT_STATE_CONNECT   = 1,
diff --git a/include/property.h b/include/property.h
index 20d525a0..d3439486 100644
--- a/include/property.h
+++ b/include/property.h
@@ -26,6 +26,12 @@
 extern "C" {
 #endif
 
+/**
+ * SECTION:property
+ * @title: Property premitives
+ * @short_description: Functions for handling properties
+ */
+
 enum connman_property_type {
 	CONNMAN_PROPERTY_TYPE_INVALID = 0,
 

commit 4cbf2ccae810df0951ebb13f421c33eb61e000ab
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Aug 15 05:02:46 2008 +0200

    Add the manager and element API documents

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 29bc8533..837d8b05 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -57,6 +57,20 @@
     <xi:include href="connman-introduction.xml" />
   </reference>
 
+  <reference id="manager">
+    <title>Manager interface</title>
+    <para>
+<programlisting><xi:include href="manager-api.txt" parse="text" /></programlisting>
+    </para>
+  </reference>
+
+  <reference id="element">
+    <title>Element interface</title>
+    <para>
+<programlisting><xi:include href="element-api.txt" parse="text" /></programlisting>
+    </para>
+  </reference>
+
   <reference id="reference">
     <title>API Reference</title>
     <partintro>

commit ac9436aff4928050c8ee9f40329fbfda7bec5ff2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Aug 15 20:15:32 2008 +0200

    Use the D-Bus settings if no security module is loaded

diff --git a/src/security.c b/src/security.c
index 05766509..c7c3ccf1 100644
--- a/src/security.c
+++ b/src/security.c
@@ -79,7 +79,7 @@ int __connman_security_check_privileges(DBusMessage *message)
 {
 	GSList *list;
 	const char *sender;
-	int err = -EPERM;
+	int err = 0;
 
 	DBG("message %p", message);
 

commit 175d74c0bc92e3a98b61fda126248b91443a348f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 17 10:11:13 2008 +0200

    Add error definition for invalid arguments

diff --git a/src/connman.h b/src/connman.h
index 7bde14e4..8b1e6fd0 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -27,6 +27,7 @@
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
 
+DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
 
 int __connman_storage_init(void);
diff --git a/src/error.c b/src/error.c
index 627cf3d7..08f94d2e 100644
--- a/src/error.c
+++ b/src/error.c
@@ -27,6 +27,12 @@
 
 #include "connman.h"
 
+DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg)
+{
+	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
+						".InvalidArguments", NULL);
+}
+
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg)
 {
 	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE

commit b4d5dd486e78f3f92dab2d6ef85d5be7fcde226c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 20 09:51:12 2008 +0200

    Add basics for creating D-Bus documentation

diff --git a/configure.ac b/configure.ac
index d500c684..46f5c1f8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,6 +24,8 @@ m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 
+AC_PATH_PROG([XSLTPROC], [xsltproc])
+
 GTK_DOC_CHECK
 
 AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 9b5367a7..ecd6b5e9 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -37,4 +37,6 @@ else
 EXTRA_DIST = $(DOC_MAIN_SGML_FILE) $(content_files)
 endif
 
+EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl
+
 EXTRA_DIST += manager-api.txt element-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/dbus-introspection.dtd b/doc/dbus-introspection.dtd
new file mode 100644
index 00000000..5fe508ef
--- /dev/null
+++ b/doc/dbus-introspection.dtd
@@ -0,0 +1,32 @@
+<!-- DTD for D-Bus Introspection Documentation -->
+
+<!ELEMENT doc (summary?,description?,errors?,permission?,since?,deprecated,seealso?)>
+
+<!ELEMENT summary (#PCDATA|ref)*>
+<!ELEMENT description (#PCDATA|para|example)*>
+<!ELEMENT errors (error)*>
+<!ELEMENT permission (#PCDATA|ref|para)*>
+<!ELEMENT since EMPTY>
+<!ATTLIST since version CDATA #REQUIRED>
+<!ELEMENT deprecated (#PCDATA|ref)>
+<!ATTLIST deprecated version CDATA #REQUIRED>
+<!ATTLIST deprecated instead CDATA #REQUIRED>
+<!ELEMENT seealso (ref+)>
+
+<!ELEMENT error (#PCDATA|para)*>
+<!ATTLIST error name CDATA #REQUIRED>
+<!ELEMENT para (#PCDATA|example|code|list|ref)*>
+<!ELEMENT example (#PCDATA|para|code|ref)*>
+<!ATTLIST language (c|glib|python|shell) #REQUIRED>
+<!ATTLIST title CDATA #IMPLIED>
+<!ELEMENT list (listheader?, item*)>
+<!ATTLIST list type (bullet|number|table) #REQUIRED>
+<!ELEMENT item (term|definition)*>
+<!ELEMENT term (#PCDATA|ref)*>
+<!ELEMENT definition (#PCDATA|para)*>
+
+<!ELEMENT code (#PCDATA)>
+<!ATTLIST code lang CDATA #IMPLIED>
+<!ELEMENT ref CDATA>
+<!ATTLIST ref type (parameter|arg|signal|method|interface) #REQUIRED>
+<!ATTLIST ref to CDATA #REQUIRED>
diff --git a/doc/dbus-introspection.xsl b/doc/dbus-introspection.xsl
new file mode 100644
index 00000000..679b3589
--- /dev/null
+++ b/doc/dbus-introspection.xsl
@@ -0,0 +1,436 @@
+<?xml version='1.0'?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+  xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd"
+  exclude-result-prefixes="doc">
+<!--
+     Convert D-Bus GLib XML into DocBook refentries
+     Copyright (C) 2007 William Jon McCann
+     License: GPL
+-->
+<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
+
+<xsl:template match="/">
+
+<xsl:variable name="interface" select="//interface/@name"/>
+<xsl:variable name="basename">
+  <xsl:call-template name="interface-basename">
+    <xsl:with-param name="str" select="$interface"/>
+  </xsl:call-template>
+</xsl:variable>
+
+<refentry><xsl:attribute name="id"><xsl:value-of select="$basename"/></xsl:attribute>
+  <refmeta>
+    <refentrytitle role="top_of_page"><xsl:value-of select="//interface/@name"/></refentrytitle>
+  </refmeta>
+
+  <refnamediv>
+    <refname><xsl:value-of select="//interface/@name"/></refname>
+    <refpurpose><xsl:value-of select="$basename"/> interface</refpurpose>
+  </refnamediv>
+
+  <refsynopsisdiv role="synopsis">
+    <title role="synopsis.title">Methods</title>
+    <synopsis>
+  <xsl:call-template name="methods-synopsis">
+    <xsl:with-param name="basename" select="$basename"/>
+  </xsl:call-template>
+    </synopsis>
+  </refsynopsisdiv>
+
+  <refsect1 role="signal_proto">
+    <title role="signal_proto.title">Signals</title>
+    <synopsis>
+  <xsl:call-template name="signals-synopsis">
+    <xsl:with-param name="basename" select="$basename"/>
+  </xsl:call-template>
+    </synopsis>
+  </refsect1>
+
+  <refsect1 role="impl_interfaces">
+    <title role="impl_interfaces.title">Implemented Interfaces</title>
+    <para>
+    <xsl:value-of select="$interface"/> implements
+    org.freedesktop.DBus.Introspectable,
+    org.freedesktop.DBus.Properties
+    </para>
+  </refsect1>
+
+  <refsect1 role="properties">
+    <title role="properties.title">Properties</title>
+    <synopsis>
+  <xsl:call-template name="properties-synopsis">
+    <xsl:with-param name="basename" select="$basename"/>
+  </xsl:call-template>
+    </synopsis>
+  </refsect1>
+
+  <refsect1 role="desc">
+    <title role="desc.title">Description</title>
+    <para>
+      <xsl:apply-templates select="//interface/doc:doc"/>
+    </para>
+  </refsect1>
+
+  <refsect1 role="details">
+    <title role="details.title">Details</title>
+    <xsl:call-template name="method-details">
+      <xsl:with-param name="basename" select="$basename"/>
+    </xsl:call-template>
+  </refsect1>
+
+  <refsect1 role="signals">
+    <title role="signals.title">Signal Details</title>
+    <xsl:call-template name="signal-details">
+      <xsl:with-param name="basename" select="$basename"/>
+    </xsl:call-template>
+  </refsect1>
+
+  <refsect1 role="property_details">
+    <title role="property_details.title">Property Details</title>
+    <xsl:call-template name="property-details">
+      <xsl:with-param name="basename" select="$basename"/>
+    </xsl:call-template>
+  </refsect1>
+
+</refentry>
+</xsl:template>
+
+
+<xsl:template name="property-doc">
+  <xsl:apply-templates select="doc:doc/doc:description"/>
+
+  <variablelist role="params">
+    <xsl:for-each select="arg">
+<varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
+<listitem><simpara><xsl:value-of select="doc:doc/doc:summary"/></simpara></listitem>
+</varlistentry>
+    </xsl:for-each>
+  </variablelist>
+
+  <xsl:apply-templates select="doc:doc/doc:since"/>
+  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
+  <xsl:apply-templates select="doc:doc/doc:permission"/>
+  <xsl:apply-templates select="doc:doc/doc:seealso"/>
+</xsl:template>
+
+
+<xsl:template name="property-details">
+  <xsl:param name="basename"/>
+  <xsl:variable name="longest">
+    <xsl:call-template name="find-longest">
+      <xsl:with-param name="set" select="@name"/>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:for-each select="///property">
+  <refsect2>
+    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$basename"/>:<xsl:value-of select="@name"/></xsl:attribute></anchor>The "<xsl:value-of select="@name"/>" property</title>
+<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$basename"/></secondary></indexterm>
+<programlisting>'<xsl:value-of select="@name"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="2"/></xsl:call-template>
+<xsl:call-template name="property-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/></xsl:call-template></programlisting>
+  </refsect2>
+
+  <xsl:call-template name="property-doc"/>
+
+  </xsl:for-each>
+</xsl:template>
+
+<xsl:template name="signal-doc">
+  <xsl:apply-templates select="doc:doc/doc:description"/>
+
+  <variablelist role="params">
+    <xsl:for-each select="arg">
+<varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
+<listitem><simpara><xsl:value-of select="doc:doc/doc:summary"/></simpara></listitem>
+</varlistentry>
+    </xsl:for-each>
+  </variablelist>
+
+  <xsl:apply-templates select="doc:doc/doc:since"/>
+  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
+  <xsl:apply-templates select="doc:doc/doc:permission"/>
+  <xsl:apply-templates select="doc:doc/doc:seealso"/>
+</xsl:template>
+
+<xsl:template name="signal-details">
+  <xsl:param name="basename"/>
+  <xsl:variable name="longest">
+    <xsl:call-template name="find-longest">
+      <xsl:with-param name="set" select="@name"/>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:for-each select="///signal">
+  <refsect2>
+    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$basename"/>::<xsl:value-of select="@name"/></xsl:attribute></anchor>The <xsl:value-of select="@name"/> signal</title>
+<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$basename"/></secondary></indexterm>
+<programlisting><xsl:value-of select="@name"/> (<xsl:call-template name="signal-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/><xsl:with-param name="prefix" select="."/></xsl:call-template>)</programlisting>
+  </refsect2>
+
+  <xsl:call-template name="signal-doc"/>
+
+  </xsl:for-each>
+</xsl:template>
+
+<xsl:template match="doc:code">
+<programlisting>
+<xsl:apply-templates />
+</programlisting>
+</xsl:template>
+
+<xsl:template match="doc:summary">
+<!-- by default don't display -->
+</xsl:template>
+
+<xsl:template match="doc:example">
+<informalexample>
+<xsl:apply-templates />
+</informalexample>
+</xsl:template>
+
+<xsl:template match="doc:para">
+<para>
+<xsl:apply-templates />
+</para>
+</xsl:template>
+
+<xsl:template match="doc:description">
+<xsl:apply-templates />
+</xsl:template>
+
+<xsl:template match="doc:since">
+<para role="since">Since <xsl:value-of select="@version"/>
+</para>
+</xsl:template>
+
+<xsl:template match="doc:deprecated">
+  <xsl:variable name="name" select="../../@name"/>
+  <xsl:variable name="parent">
+    <xsl:call-template name="interface-basename">
+      <xsl:with-param name="str" select="../../../@name"/>/>
+    </xsl:call-template>
+  </xsl:variable>
+
+  <xsl:variable name="type" select="name(../..)"/>
+
+  <para role="deprecated">
+  <warning><para><literal><xsl:value-of select="$name"/></literal> is deprecated since version <xsl:value-of select="@version"/> and should not be used in newly-written code. Use
+
+  <xsl:variable name="to">
+  <xsl:choose>
+    <xsl:when test="contains($type,'property')">
+      <xsl:value-of select="$parent"/>:<xsl:value-of select="@instead"/>
+    </xsl:when>
+    <xsl:when test="contains($type,'signal')">
+      <xsl:value-of select="$parent"/>::<xsl:value-of select="@instead"/>
+    </xsl:when>
+    <xsl:when test="contains($type,'method')">
+      <xsl:value-of select="$parent"/>.<xsl:value-of select="@instead"/>
+    </xsl:when>
+    <xsl:when test="contains($type,'interface')">
+      <xsl:value-of select="@instead"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="@instead"/>
+    </xsl:otherwise>
+  </xsl:choose>
+  </xsl:variable>
+
+  <xsl:call-template name="create-link">
+    <xsl:with-param name="type" select="$type"/>
+    <xsl:with-param name="to" select="$to"/>
+    <xsl:with-param name="val" select="@instead"/>
+  </xsl:call-template>
+instead.</para></warning>
+</para>
+</xsl:template>
+
+<xsl:template match="doc:permission">
+<para role="permission">
+<xsl:apply-templates />
+</para>
+</xsl:template>
+
+<xsl:template match="doc:seealso">
+<para>
+See also:
+<xsl:apply-templates />
+
+</para>
+</xsl:template>
+
+<xsl:template name="create-link">
+  <xsl:param name="type"/>
+  <xsl:param name="to"/>
+  <xsl:param name="val"/>
+
+  <xsl:choose>
+    <xsl:when test="contains($type,'property')">
+      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><literal><xsl:value-of select="$val"/></literal></link>
+    </xsl:when>
+    <xsl:when test="contains($type,'signal')">
+      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><literal><xsl:value-of select="$val"/></literal></link>
+    </xsl:when>
+    <xsl:when test="contains($type,'method')">
+      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><function><xsl:value-of select="$val"/></function></link>
+    </xsl:when>
+    <xsl:when test="contains($type,'interface')">
+      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><xsl:value-of select="$val"/></link>
+    </xsl:when>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template match="doc:ref">
+  <xsl:call-template name="create-link">
+    <xsl:with-param name="type" select="@type"/>
+    <xsl:with-param name="to" select="@to"/>
+    <xsl:with-param name="val" select="."/>
+  </xsl:call-template>
+</xsl:template>
+
+<xsl:template name="method-doc">
+  <xsl:apply-templates select="doc:doc/doc:description"/>
+
+  <variablelist role="params">
+    <xsl:for-each select="arg">
+<varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
+<listitem><simpara><xsl:value-of select="doc:doc/doc:summary"/></simpara></listitem>
+</varlistentry>
+    </xsl:for-each>
+  </variablelist>
+
+  <xsl:apply-templates select="doc:doc/doc:since"/>
+  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
+  <xsl:apply-templates select="doc:doc/doc:permission"/>
+  <xsl:apply-templates select="doc:doc/doc:seealso"/>
+</xsl:template>
+
+<xsl:template name="method-details">
+  <xsl:param name="basename"/>
+  <xsl:variable name="longest">
+    <xsl:call-template name="find-longest">
+      <xsl:with-param name="set" select="@name"/>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:for-each select="///method">
+    <refsect2>
+    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$basename"/>.<xsl:value-of select="@name"/></xsl:attribute></anchor><xsl:value-of select="@name"/> ()</title>
+<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$basename"/></secondary></indexterm>
+<programlisting><xsl:value-of select="@name"/> (<xsl:call-template name="method-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/><xsl:with-param name="prefix" select="."/></xsl:call-template>)</programlisting>
+    </refsect2>
+
+    <xsl:call-template name="method-doc"/>
+
+  </xsl:for-each>
+</xsl:template>
+
+
+<xsl:template name="properties-synopsis">
+  <xsl:param name="basename"/>
+  <xsl:variable name="longest">
+    <xsl:call-template name="find-longest">
+      <xsl:with-param name="set" select="///property/@name"/>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:for-each select="///property">
+<link><xsl:attribute name="linkend"><xsl:value-of select="$basename"/>:<xsl:value-of select="@name"/></xsl:attribute>'<xsl:value-of select="@name"/>'</link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template> <xsl:call-template name="property-args"><xsl:with-param name="indent" select="$longest + 2"/></xsl:call-template>
+</xsl:for-each>
+</xsl:template>
+
+
+<xsl:template name="signals-synopsis">
+  <xsl:param name="basename"/>
+  <xsl:variable name="longest">
+    <xsl:call-template name="find-longest">
+      <xsl:with-param name="set" select="///signal/@name"/>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:for-each select="///signal">
+<link><xsl:attribute name="linkend"><xsl:value-of select="$basename"/>::<xsl:value-of select="@name"/></xsl:attribute><xsl:value-of select="@name"/></link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template>(<xsl:call-template name="signal-args"><xsl:with-param name="indent" select="$longest + 2"/><xsl:with-param name="prefix" select="///signal"/></xsl:call-template>)
+</xsl:for-each>
+</xsl:template>
+
+
+<xsl:template name="methods-synopsis">
+  <xsl:param name="basename"/>
+  <xsl:variable name="longest">
+    <xsl:call-template name="find-longest">
+      <xsl:with-param name="set" select="///method/@name"/>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:for-each select="///method">
+<link><xsl:attribute name="linkend"><xsl:value-of select="$basename"/>.<xsl:value-of select="@name"/></xsl:attribute><xsl:value-of select="@name"/></link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template>(<xsl:call-template name="method-args"><xsl:with-param name="indent" select="$longest + 2"/><xsl:with-param name="prefix" select="///method"/></xsl:call-template>)
+</xsl:for-each>
+</xsl:template>
+
+
+<xsl:template name="method-args"><xsl:param name="indent"/><xsl:param name="prefix"/><xsl:variable name="longest"><xsl:call-template name="find-longest"><xsl:with-param name="set" select="$prefix/arg/@type"/></xsl:call-template></xsl:variable><xsl:for-each select="arg"><xsl:value-of select="@direction"/>
+<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="4 - string-length(@direction)"/></xsl:call-template>'<xsl:value-of select="@type"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@type) + 1"/></xsl:call-template>
+<xsl:value-of select="@name"/><xsl:if test="not(position() = last())">,
+<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$indent"/></xsl:call-template></xsl:if>
+</xsl:for-each>
+</xsl:template>
+
+
+<xsl:template name="signal-args"><xsl:param name="indent"/><xsl:param name="prefix"/><xsl:variable name="longest"><xsl:call-template name="find-longest"><xsl:with-param name="set" select="$prefix/arg/@type"/></xsl:call-template></xsl:variable><xsl:for-each select="arg">'<xsl:value-of select="@type"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@type) + 1"/></xsl:call-template>
+<xsl:value-of select="@name"/><xsl:if test="not(position() = last())">,
+<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$indent"/></xsl:call-template></xsl:if>
+</xsl:for-each>
+</xsl:template>
+
+
+<xsl:template name="property-args"><xsl:param name="indent"/>
+<xsl:value-of select="@access"/><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="9 - string-length(@access) + 1"/></xsl:call-template>'<xsl:value-of select="@type"/>'
+</xsl:template>
+
+
+<xsl:template name="pad-spaces">
+  <xsl:param name="width"/>
+  <xsl:variable name="spaces" xml:space="preserve">                                                                        </xsl:variable>
+  <xsl:value-of select="substring($spaces,1,$width)"/>
+</xsl:template>
+
+
+<xsl:template name="find-longest">
+  <xsl:param name="set"/>
+  <xsl:param name="index" select="1"/>
+  <xsl:param name="longest" select="0"/>
+
+  <xsl:choose>
+    <xsl:when test="$index > count($set)">
+      <!--finished looking-->
+      <xsl:value-of select="$longest"/>
+    </xsl:when>
+    <xsl:when test="string-length($set[$index])>$longest">
+      <!--found new longest-->
+      <xsl:call-template name="find-longest">
+        <xsl:with-param name="set" select="$set"/>
+        <xsl:with-param name="index" select="$index + 1"/>
+        <xsl:with-param name="longest" select="string-length($set[$index])"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:otherwise>
+      <!--this isn't any longer-->
+      <xsl:call-template name="find-longest">
+        <xsl:with-param name="set" select="$set"/>
+        <xsl:with-param name="index" select="$index + 1"/>
+        <xsl:with-param name="longest" select="$longest"/>
+      </xsl:call-template>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+
+<xsl:template name="interface-basename">
+  <xsl:param name="str"/>
+  <xsl:choose>
+    <xsl:when test="contains($str,'.')">
+      <xsl:call-template name="interface-basename">
+	<xsl:with-param name="str" select="substring-after($str,'.')"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="$str"/>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+</xsl:stylesheet>

commit 120501d82b2f136212668d9888b2732d330bbde9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 20 10:09:24 2008 +0200

    Add example for D-Bus documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index ecd6b5e9..0d0381f4 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -33,10 +33,19 @@ MAINTAINERCLEANFILES = Makefile.in \
 
 if ENABLE_GTK_DOC
 include $(top_srcdir)/doc/gtk-doc.make
+
+all-local: xml/dbus-manager.xml
+
+xml/dbus-manager.xml : dbus-manager.xml dbus-introspection.xsl
+	echo "<?xml version=\"1.0\"?>" > $@
+	echo "<!DOCTYPE refentry PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\">" >> $@
+	$(XSLTPROC) dbus-introspection.xsl $< | tail -n +2 >> $@
+
 else
 EXTRA_DIST = $(DOC_MAIN_SGML_FILE) $(content_files)
 endif
 
-EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl
+EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
+		dbus-manager.xml
 
 EXTRA_DIST += manager-api.txt element-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 837d8b05..66d895cf 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -57,6 +57,17 @@
     <xi:include href="connman-introduction.xml" />
   </reference>
 
+  <reference id="dbus">
+    <title>D-Bus API Reference</title>
+    <partintro>
+      <para>
+	This part presents the D-Bus interface used to access Connection
+	Manager.
+      </para>
+    </partintro>
+    <xi:include href="xml/dbus-manager.xml"/>
+  </reference>
+
   <reference id="manager">
     <title>Manager interface</title>
     <para>
@@ -72,7 +83,7 @@
   </reference>
 
   <reference id="reference">
-    <title>API Reference</title>
+    <title>Plugin API Reference</title>
     <partintro>
       <para>
 	This part presents the function reference for Connection Manager.
diff --git a/doc/dbus-manager.xml b/doc/dbus-manager.xml
new file mode 100644
index 00000000..446cd7e9
--- /dev/null
+++ b/doc/dbus-manager.xml
@@ -0,0 +1,30 @@
+<!DOCTYPE node PUBLIC
+	"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+	"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
+
+  <interface name="org.moblin.connman.Manager">
+
+    <method name="ListElements">
+      <arg name="list" direction="out" type="ao">
+        <doc:doc>
+          <doc:summary>
+            <doc:para>
+              List of object paths representing an element.
+            </doc:para>
+          </doc:summary>
+        </doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            List all registered elements in the system.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </method>
+
+  </interface>
+
+</node>

commit 27d6492faf17da616776c141b7852079de51ea60
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Aug 20 10:47:38 2008 +0200

    Build D-Bus documentation in its own directory

diff --git a/configure.ac b/configure.ac
index 46f5c1f8..615045e0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,10 +24,10 @@ m4_ifdef([AC_LIBTOOL_TAGS], [AC_LIBTOOL_TAGS([])])
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 
-AC_PATH_PROG([XSLTPROC], [xsltproc])
-
 GTK_DOC_CHECK
 
+AC_PATH_PROG([XSLTPROC], [xsltproc])
+
 AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 0d0381f4..b9ade0fc 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -21,7 +21,7 @@ IGNORE_HFILES = connman connman.h rtnl.h dbus.h iface.h
 
 HTML_IMAGES =
 
-content_files = connman-introduction.xml
+content_files = connman-introduction.xml dbus/manager.xml
 
 INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/gdbus \
 	$(GTHREAD_CFLAGS) $(GMODULE_CFLAGS) $(GLIB_CFLAGS) $(DBUS_CFLAGS)
@@ -34,15 +34,17 @@ MAINTAINERCLEANFILES = Makefile.in \
 if ENABLE_GTK_DOC
 include $(top_srcdir)/doc/gtk-doc.make
 
-all-local: xml/dbus-manager.xml
-
-xml/dbus-manager.xml : dbus-manager.xml dbus-introspection.xsl
+dbus/manager.xml: dbus-manager.xml dbus-introspection.xsl
+	$(MKDIR_P) -p $(builddir)/dbus
 	echo "<?xml version=\"1.0\"?>" > $@
 	echo "<!DOCTYPE refentry PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\">" >> $@
 	$(XSLTPROC) dbus-introspection.xsl $< | tail -n +2 >> $@
 
+clean-local:
+	rm -rf $(builddir)/dbus
+
 else
-EXTRA_DIST = $(DOC_MAIN_SGML_FILE) $(content_files)
+EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
 EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 66d895cf..f1601c43 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -65,7 +65,7 @@
 	Manager.
       </para>
     </partintro>
-    <xi:include href="xml/dbus-manager.xml"/>
+    <xi:include href="dbus/manager.xml"/>
   </reference>
 
   <reference id="manager">

commit 910534c6b94fa23ade84f402e4aca9a9575e390a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Aug 25 11:14:14 2008 +0200

    Add auto-generated doc/dbus directory

diff --git a/.gitignore b/.gitignore
index f4b0834b..dd020eac 100644
--- a/.gitignore
+++ b/.gitignore
@@ -36,4 +36,5 @@ doc/connman-*.txt
 doc/*.sgml
 doc/version.xml
 doc/xml
+doc/dbus
 doc/html

commit 074d489a01de3dfb1fa2b8e9ad48bf42fff1302b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Aug 25 11:19:06 2008 +0200

    Add more advanced properties implementation

diff --git a/include/element.h b/include/element.h
index e2d7ea8a..57103d31 100644
--- a/include/element.h
+++ b/include/element.h
@@ -73,6 +73,7 @@ struct connman_driver;
 struct connman_element {
 	gint refcount;
 	GStaticMutex mutex;
+	gint index;
 	gchar *name;
 	gchar *path;
 	enum connman_element_type type;
@@ -88,12 +89,6 @@ struct connman_element {
 
 	GSList *properties;
 
-	struct {
-		int index;
-		short flags;
-		gchar *name;
-	} netdev;
-
 	struct {
 		gchar *identifier;
 	} network;
@@ -111,16 +106,19 @@ struct connman_element {
 #define connman_element_lock(element)    g_static_mutex_lock(&(element)->mutex)
 #define connman_element_unlock(element)  g_static_mutex_unlock(&(element)->mutex)
 
-extern struct connman_element *connman_element_create(void);
+extern struct connman_element *connman_element_create(const char *name);
 extern struct connman_element *connman_element_ref(struct connman_element *element);
 extern void connman_element_unref(struct connman_element *element);
 
 extern int connman_element_add_static_property(struct connman_element *element,
 				const char *name, int type, const void *value);
+extern int connman_element_define_properties(struct connman_element *element, ...);
+extern int connman_element_create_property(struct connman_element *element,
+						const char *name, int type);
 extern int connman_element_set_property(struct connman_element *element,
-			enum connman_property_type type, const void *value);
+				enum connman_property_id id, const void *value);
 extern int connman_element_get_value(struct connman_element *element,
-				enum connman_property_type type, void *value);
+				enum connman_property_id id, void *value);
 
 extern int connman_element_register(struct connman_element *element,
 					struct connman_element *parent);
diff --git a/include/property.h b/include/property.h
index d3439486..14198bef 100644
--- a/include/property.h
+++ b/include/property.h
@@ -32,21 +32,29 @@ extern "C" {
  * @short_description: Functions for handling properties
  */
 
-enum connman_property_type {
-	CONNMAN_PROPERTY_TYPE_INVALID = 0,
+enum connman_property_id {
+	CONNMAN_PROPERTY_ID_INVALID = 0,
 
-	CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS,
-	CONNMAN_PROPERTY_TYPE_IPV4_NETMASK,
-	CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY,
-	CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER,
+	CONNMAN_PROPERTY_ID_IPV4_METHOD,
+	CONNMAN_PROPERTY_ID_IPV4_ADDRESS,
+	CONNMAN_PROPERTY_ID_IPV4_NETMASK,
+	CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
+	CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 };
 
+/**
+ * connman_property_flags:
+ * @CONNMAN_PROPERTY_FLAG_STATIC: read-only property
+ * @CONNMAN_PROPERTY_FLAG_REFERENCE: inheritated value (reference only)
+ */
 enum connman_property_flags {
-	CONNMAN_PROPERTY_FLAG_STATIC = (1 << 0),
+	CONNMAN_PROPERTY_FLAG_STATIC     = (1 << 0),
+	CONNMAN_PROPERTY_FLAG_REFERENCE  = (1 << 1),
 };
 
 struct connman_property {
 	enum connman_property_flags flags;
+	enum connman_property_id id;
 	char *name;
 	int type;
 	void *value;
diff --git a/src/element.c b/src/element.c
index 66c91d0b..a9012b2d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <errno.h>
+#include <stdarg.h>
 
 #include <glib.h>
 #include <gdbus.h>
@@ -43,6 +44,49 @@ static GThreadPool *thread_unregister_children = NULL;
 
 static gchar *device_filter = NULL;
 
+static struct {
+	enum connman_property_id id;
+	int type;
+	const char *name;
+	const void *value;
+} propid_table[] = {
+	{ CONNMAN_PROPERTY_ID_IPV4_METHOD,
+		DBUS_TYPE_STRING, "IPv4.Method", "dhcp" },
+	{ CONNMAN_PROPERTY_ID_IPV4_ADDRESS,
+		DBUS_TYPE_STRING, "IPv4.Address" },
+	{ CONNMAN_PROPERTY_ID_IPV4_NETMASK,
+		DBUS_TYPE_STRING, "IPv4.Netmask" },
+	{ CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
+		DBUS_TYPE_STRING, "IPv4.Gateway" },
+	{ CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
+		DBUS_TYPE_STRING, "IPv4.Nameserver" },
+	{ }
+};
+
+static int propid2type(enum connman_property_id id)
+{
+	int i;
+
+	for (i = 0; propid_table[i].name; i++) {
+		if (propid_table[i].id == id)
+			return propid_table[i].type;
+	}
+
+	return DBUS_TYPE_INVALID;
+}
+
+static const char *propid2name(enum connman_property_id id)
+{
+	int i;
+
+	for (i = 0; propid_table[i].name; i++) {
+		if (propid_table[i].id == id)
+			return propid_table[i].name;
+	}
+
+	return NULL;
+}
+
 static const char *type2string(enum connman_element_type type)
 {
 	switch (type) {
@@ -136,11 +180,10 @@ static void append_entry(DBusMessageIter *dict,
 static void append_property(DBusMessageIter *dict,
 				struct connman_property *property)
 {
-	if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC) {
-		append_entry(dict, property->name, property->type,
-							&property->value);
+	if (property->value == NULL)
 		return;
-	}
+
+	append_entry(dict, property->name, property->type, &property->value);
 }
 
 static DBusMessage *get_properties(DBusConnection *conn,
@@ -165,9 +208,11 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	if (element->parent != NULL)
+	if (element->parent != NULL &&
+			element->parent->type != CONNMAN_ELEMENT_TYPE_ROOT) {
 		append_entry(&dict, "Parent",
 				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
+	}
 
 	str = type2string(element->type);
 	if (str != NULL)
@@ -196,12 +241,16 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		append_entry(&dict, "IPv4.Gateway",
 				DBUS_TYPE_STRING, &element->ipv4.gateway);
 
+	connman_element_lock(element);
+
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
 
 		append_property(&dict, property);
 	}
 
+	connman_element_unlock(element);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -210,6 +259,91 @@ static DBusMessage *get_properties(DBusConnection *conn,
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_element *element = data;
+	DBusMessageIter iter;
+	DBusMessageIter value;
+	const char *name;
+	GSList *list;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+		const char *str;
+
+		if (g_str_equal(property->name, name) == FALSE)
+			continue;
+
+		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
+			continue;
+
+		property->flags &= ~CONNMAN_PROPERTY_FLAG_REFERENCE;
+
+		if (property->type == DBUS_TYPE_STRING) {
+			dbus_message_iter_get_basic(&value, &str);
+			g_free(property->value);
+			property->value = g_strdup(str);
+		} else
+			property->value = NULL;
+	}
+
+	connman_element_unlock(element);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *clear_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	const char *name;
+	GSList *list;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &name,
+						DBUS_TYPE_INVALID) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (g_str_equal(property->name, name) == FALSE)
+			continue;
+
+		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
+			continue;
+
+		if (property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)
+			continue;
+
+		property->flags |= CONNMAN_PROPERTY_FLAG_REFERENCE;
+
+		if (property->type == DBUS_TYPE_STRING)
+			g_free(property->value);
+
+		property->value = NULL;
+	}
+
+	connman_element_unlock(element);
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -270,6 +404,7 @@ static DBusMessage *do_disable(DBusConnection *conn,
 static GDBusMethodTable element_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_properties },
 	{ "SetProperty",   "sv", "",      set_property   },
+	{ "ClearProperty", "s",  "",      clear_property },
 	{ "Update",        "",   "",      do_update      },
 	{ "Enable",        "",   "",      do_enable      },
 	{ "Disable",       "",   "",      do_disable     },
@@ -435,11 +570,22 @@ void connman_driver_unregister(struct connman_driver *driver)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
-struct connman_element *connman_element_create(void)
+/**
+ * connman_element_create:
+ * @name: element name
+ *
+ * Allocate a new element and assign the given #name to it. If the name
+ * is #NULL, it will be later on created based on the element type.
+ *
+ * Returns: a newly-allocated #connman_element structure
+ */
+struct connman_element *connman_element_create(const char *name)
 {
 	struct connman_element *element;
 
-	element = g_new0(struct connman_element, 1);
+	element = g_try_new0(struct connman_element, 1);
+	if (element == NULL)
+		return NULL;
 
 	DBG("element %p", element);
 
@@ -447,14 +593,13 @@ struct connman_element *connman_element_create(void)
 
 	g_static_mutex_init(&element->mutex);
 
+	element->name    = g_strdup(name);
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
-
+	element->index   = -1;
 	element->enabled = FALSE;
 
-	element->netdev.index = -1;
-
 	return element;
 }
 
@@ -468,24 +613,39 @@ struct connman_element *connman_element_ref(struct connman_element *element)
 	return element;
 }
 
-void connman_element_unref(struct connman_element *element)
+static void free_properties(struct connman_element *element)
 {
-	DBG("element %p name %s refcount %d", element, element->name,
-				g_atomic_int_get(&element->refcount) - 1);
+	GSList *list;
 
-	if (g_atomic_int_dec_and_test(&element->refcount) == TRUE) {
-		GSList *list;
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_lock(element);
 
-		for (list = element->properties; list; list = list->next) {
-			struct connman_property *property = list->data;
-			if ((property->flags & CONNMAN_PROPERTY_FLAG_STATIC) &&
-					property->type == DBUS_TYPE_STRING)
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)) {
+			if (property->type == DBUS_TYPE_STRING)
 				g_free(property->value);
-			g_free(property);
-			list->data = NULL;
 		}
-		g_slist_free(element->properties);
 
+		g_free(property);
+	}
+
+	g_slist_free(element->properties);
+
+	element->properties = NULL;
+
+	connman_element_unlock(element);
+}
+
+void connman_element_unref(struct connman_element *element)
+{
+	DBG("element %p name %s refcount %d", element, element->name,
+				g_atomic_int_get(&element->refcount) - 1);
+
+	if (g_atomic_int_dec_and_test(&element->refcount) == TRUE) {
+		free_properties(element);
 		g_free(element->ipv4.address);
 		g_free(element->ipv4.netmask);
 		g_free(element->ipv4.gateway);
@@ -493,7 +653,6 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
 		g_free(element->network.identifier);
-		g_free(element->netdev.name);
 		g_free(element->path);
 		g_free(element->name);
 		g_free(element);
@@ -515,9 +674,9 @@ int connman_element_add_static_property(struct connman_element *element,
 		return -ENOMEM;
 
 	property->flags = CONNMAN_PROPERTY_FLAG_STATIC;
-
-	property->name = g_strdup(name);
-	property->type = type;
+	property->id    = CONNMAN_PROPERTY_ID_INVALID;
+	property->name  = g_strdup(name);
+	property->type  = type;
 
 	DBG("name %s type %d value %p", name, type, value);
 
@@ -534,9 +693,166 @@ int connman_element_add_static_property(struct connman_element *element,
 	return 0;
 }
 
+static void *get_reference_value(struct connman_element *element,
+						enum connman_property_id id)
+{
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (property->id != id)
+			continue;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
+			return property->value;
+	}
+
+	if (element->parent == NULL)
+		return NULL;
+
+	return get_reference_value(element->parent, id);
+}
+
+static void set_reference_properties(struct connman_element *element)
+{
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
+			continue;
+
+		property->value = get_reference_value(element->parent,
+								property->id);
+	}
+}
+
+static struct connman_property *create_property(struct connman_element *element,
+						enum connman_property_id id)
+{
+	struct connman_property *property;
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		property = list->data;
+
+		if (property->id == id)
+			goto unlock;
+	}
+
+	property = g_try_new0(struct connman_property, 1);
+	if (property == NULL)
+		goto unlock;
+
+	property->flags = CONNMAN_PROPERTY_FLAG_REFERENCE;
+	property->id    = id;
+	property->name  = g_strdup(propid2name(id));
+	property->type  = propid2type(id);
+
+	if (property->name == NULL) {
+		g_free(property);
+		property = NULL;
+		goto unlock;
+	}
+
+	element->properties = g_slist_append(element->properties, property);
+
+unlock:
+	connman_element_unlock(element);
+
+	return property;
+}
+
+static void create_default_properties(struct connman_element *element)
+{
+	struct connman_property *property;
+	int i;
+
+	DBG("element %p name %s", element, element->name);
+
+	for (i = 0; propid_table[i].name; i++) {
+		DBG("property %s", propid_table[i].name);
+
+		property = create_property(element, propid_table[i].id);
+
+		property->flags &= ~CONNMAN_PROPERTY_FLAG_REFERENCE;
+
+		if (propid_table[i].type != DBUS_TYPE_STRING)
+			continue;
+
+		if (propid_table[i].value)
+			property->value = g_strdup(propid_table[i].value);
+		else
+			property->value = g_strdup("");
+	}
+}
+
+static int define_properties_valist(struct connman_element *element,
+								va_list args)
+{
+	enum connman_property_id id;
+
+	DBG("element %p name %s", element, element->name);
+
+	id = va_arg(args, enum connman_property_id);
+
+	while (id != CONNMAN_PROPERTY_ID_INVALID) {
+
+		DBG("property %d", id);
+
+		create_property(element, id);
+
+		id = va_arg(args, enum connman_property_id);
+	}
+
+	return 0;
+}
+
+/**
+ * connman_element_define_properties:
+ * @element: an element
+ * @varargs: list of property identifiers
+ *
+ * Define the valid properties for an element.
+ *
+ * Returns: %0 on success
+ */
+int connman_element_define_properties(struct connman_element *element, ...)
+{
+	va_list args;
+	int err;
+
+	DBG("element %p name %s", element, element->name);
+
+	va_start(args, element);
+
+	err = define_properties_valist(element, args);
+
+	va_end(args);
+
+	return err;
+}
+
+int connman_element_create_property(struct connman_element *element,
+						const char *name, int type)
+{
+	return -EIO;
+}
+
 int connman_element_set_property(struct connman_element *element,
-			enum connman_property_type type, const void *value)
+				enum connman_property_id id, const void *value)
 {
+#if 0
 	switch (type) {
 	case CONNMAN_PROPERTY_TYPE_INVALID:
 		return -EINVAL;
@@ -565,6 +881,7 @@ int connman_element_set_property(struct connman_element *element,
 		connman_element_unlock(element);
 		break;
 	}
+#endif
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
@@ -575,11 +892,12 @@ int connman_element_set_property(struct connman_element *element,
 }
 
 int connman_element_get_value(struct connman_element *element,
-				enum connman_property_type type, void *value)
+				enum connman_property_id id, void *value)
 {
 	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
 		return -EINVAL;
 
+#if 0
 	switch (type) {
 	case CONNMAN_PROPERTY_TYPE_INVALID:
 		return -EINVAL;
@@ -616,18 +934,29 @@ int connman_element_get_value(struct connman_element *element,
 		connman_element_unlock(element);
 		break;
 	}
+#endif
 
 	return 0;
 }
 
+/**
+ * connman_element_register:
+ * @element: the element to register
+ * @parent: the parent to register the element with
+ *
+ * Register an element with the core. It will be register under the given
+ * parent of if %NULL is provided under the root element.
+ *
+ * Returns: %0 on success
+ */
 int connman_element_register(struct connman_element *element,
 					struct connman_element *parent)
 {
 	DBG("element %p name %s parent %p", element, element->name, parent);
 
 	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
-		if (g_str_equal(device_filter, element->netdev.name) == FALSE)
-			return -EINVAL;
+		if (g_str_equal(device_filter, element->name) == FALSE)
+			return -EPERM;
 	}
 
 	if (connman_element_ref(element) == NULL)
@@ -639,8 +968,10 @@ int connman_element_register(struct connman_element *element,
 
 	if (element->name == NULL) {
 		element->name = g_strdup(type2string(element->type));
-		if (element->name == NULL)
+		if (element->name == NULL) {
+			connman_element_unlock(element);
 			return -EINVAL;
+		}
 	}
 
 	element->parent = parent;
@@ -722,12 +1053,16 @@ static void register_element(gpointer data, gpointer user_data)
 		if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
 			element->subtype = element->parent->subtype;
 	} else {
+		element->parent = element_root->data;
+
 		node = element_root;
 		basepath = "";
 	}
 
 	element->path = g_strdup_printf("%s/%s", basepath, element->name);
 
+	set_reference_properties(element);
+
 	connman_element_unlock(element);
 
 	DBG("element %p path %s", element, element->path);
@@ -857,12 +1192,13 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 
 	g_static_rw_lock_writer_lock(&element_lock);
 
-	element = connman_element_create();
+	element = connman_element_create("root");
 
-	element->name = g_strdup("root");
 	element->path = g_strdup("/");
 	element->type = CONNMAN_ELEMENT_TYPE_ROOT;
 
+	create_default_properties(element);
+
 	element_root = g_node_new(element);
 
 	g_static_rw_lock_writer_unlock(&element_lock);

commit 7f4054b0b2d6c43c59caef670b4330895337d992
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 20:07:39 2008 +0200

    Fixup due to element API changes

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 6d41fb25..2d0d7ad9 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -43,7 +43,7 @@ static void create_element(DBusConnection *conn, const char *path)
 
 	DBG("conn %p path %s", conn, path);
 
-	element = connman_element_create();
+	element = connman_element_create(NULL);
 
 	element->name = g_path_get_basename(path);
 	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 0f248bca..697149bb 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -35,6 +35,11 @@
 #include <connman/driver.h>
 #include <connman/log.h>
 
+struct ethernet_data {
+	int index;
+	short flags;
+};
+
 static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
 static GSList *ethernet_list = NULL;
 
@@ -45,11 +50,12 @@ static void create_element(struct connman_element *parent,
 
 	DBG("parent %p name %s", parent, parent->name);
 
-	element = connman_element_create();
+	element = connman_element_create(NULL);
+	if (element == NULL)
+		return;
 
 	element->type = type;
-	element->netdev.index = parent->netdev.index;
-	element->netdev.name = g_strdup(parent->netdev.name);
+	element->index = parent->index;
 
 	connman_element_register(element, parent);
 }
@@ -70,20 +76,22 @@ static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 
 	for (list = ethernet_list; list; list = list->next) {
 		struct connman_element *element = list->data;
+		struct ethernet_data *ethernet;
 
-		if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE)
+		ethernet = connman_element_get_data(element);
+		if (ethernet == NULL)
 			continue;
 
-		if (element->netdev.index != msg->ifi_index)
+		if (ethernet->index != msg->ifi_index)
 			continue;
 
-		if ((element->netdev.flags & IFF_RUNNING) ==
-						(msg->ifi_flags & IFF_RUNNING))
+		if ((ethernet->flags & IFF_RUNNING) ==
+					(msg->ifi_flags & IFF_RUNNING))
 			continue;
 
-		element->netdev.flags = msg->ifi_flags;
+		ethernet->flags = msg->ifi_flags;
 
-		if (msg->ifi_flags & IFF_RUNNING) {
+		if (ethernet->flags & IFF_RUNNING) {
 			DBG("carrier on");
 
 			create_element(element, CONNMAN_ELEMENT_TYPE_DHCP);
@@ -153,7 +161,7 @@ static gboolean rtnl_event(GIOChannel *chan, GIOCondition cond, gpointer data)
 	return TRUE;
 }
 
-static GIOChannel *channel = NULL;
+static GIOChannel *channel;
 
 static int rtnl_request(void)
 {
@@ -184,19 +192,19 @@ static int rtnl_request(void)
 			(struct sockaddr *) &addr, sizeof(addr));
 }
 
-static int iface_up(struct connman_element *element)
+static int iface_up(struct ethernet_data *ethernet)
 {
 	struct ifreq ifr;
 	int sk, err;
 
-	DBG("element %p", element);
+	DBG("index %d flags %d", ethernet->index, ethernet->flags);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return -errno;
 
 	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = element->netdev.index;
+	ifr.ifr_ifindex = ethernet->index;
 
 	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
 		err = -errno;
@@ -228,19 +236,19 @@ done:
 	return err;
 }
 
-static int iface_down(struct connman_element *element)
+static int iface_down(struct ethernet_data *ethernet)
 {
 	struct ifreq ifr;
 	int sk, err;
 
-	DBG("element %p", element);
+	DBG("index %d flags %d", ethernet->index, ethernet->flags);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sk < 0)
 		return -errno;
 
 	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = element->netdev.index;
+	ifr.ifr_ifindex = ethernet->index;
 
 	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
 		err = -errno;
@@ -272,13 +280,23 @@ done:
 
 static int ethernet_probe(struct connman_element *element)
 {
+	struct ethernet_data *ethernet;
+
 	DBG("element %p name %s", element, element->name);
 
+	ethernet = g_try_new0(struct ethernet_data, 1);
+	if (ethernet == NULL)
+		return -ENOMEM;
+
 	g_static_mutex_lock(&ethernet_mutex);
 	ethernet_list = g_slist_append(ethernet_list, element);
 	g_static_mutex_unlock(&ethernet_mutex);
 
-	iface_up(element);
+	connman_element_set_data(element, ethernet);
+
+	ethernet->index = element->index;
+
+	iface_up(ethernet);
 
 	rtnl_request();
 
@@ -287,13 +305,19 @@ static int ethernet_probe(struct connman_element *element)
 
 static void ethernet_remove(struct connman_element *element)
 {
+	struct ethernet_data *ethernet = connman_element_get_data(element);
+
 	DBG("element %p name %s", element, element->name);
 
-	iface_down(element);
+	connman_element_set_data(element, NULL);
+
+	iface_down(ethernet);
 
 	g_static_mutex_lock(&ethernet_mutex);
 	ethernet_list = g_slist_remove(ethernet_list, element);
 	g_static_mutex_unlock(&ethernet_mutex);
+
+	g_free(ethernet);
 }
 
 static struct connman_driver ethernet_driver = {
@@ -340,8 +364,6 @@ static void rtnl_cleanup(void)
 
 	g_io_channel_shutdown(channel, TRUE, NULL);
 	g_io_channel_unref(channel);
-
-	channel = NULL;
 }
 
 static int ethernet_init(void)
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 05611339..f4c33737 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -140,11 +140,10 @@ static void state_change(struct connman_element *parent,
 	if (state == STATE_COMPLETED) {
 		struct connman_element *dhcp;
 
-		dhcp = connman_element_create();
+		dhcp = connman_element_create(NULL);
 
 		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
-		dhcp->netdev.index = element->netdev.index;
-		dhcp->netdev.name = g_strdup(element->netdev.name);
+		dhcp->index = element->index;
 
 		dhcp_element = dhcp;
 
@@ -191,26 +190,24 @@ static void scan_result(struct connman_element *parent,
 
 	element = find_element(data, network->identifier);
 	if (element == NULL) {
-		element = connman_element_create();
+		element = connman_element_create(temp);
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
-		element->name = temp;
+		element->index = parent->index;
 
 		element->network.identifier = g_strdup(network->identifier);
 
-		element->netdev.index = parent->netdev.index;
-		element->netdev.name = g_strdup(parent->netdev.name);
-
 		data->list = g_slist_append(data->list, element);
 
 		connman_element_add_static_property(element, "SSID",
 				DBUS_TYPE_STRING, &network->identifier);
 
 		connman_element_register(element, parent);
-	} else
-		g_free(temp);
+	}
 
 	g_static_mutex_unlock(&data->mutex);
+
+	g_free(temp);
 }
 
 static struct supplicant_callback wifi_callback = {

commit 29fdbe87a8f2e0f13dcc027ba78eefe85263907d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 20:09:10 2008 +0200

    Use element->index and element->name variables

diff --git a/plugins/hal.c b/plugins/hal.c
index 2afe856b..942faaf6 100644
--- a/plugins/hal.c
+++ b/plugins/hal.c
@@ -85,18 +85,18 @@ static void device_netdev(LibHalContext *ctx, const char *udi,
 {
 	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_ETHERNET ||
 			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI) {
-		element->netdev.index = libhal_device_get_property_int(ctx,
+		element->index = libhal_device_get_property_int(ctx,
 						udi, "net.linux.ifindex", NULL);
 
-		element->netdev.name = libhal_device_get_property_string(ctx,
+		element->name = libhal_device_get_property_string(ctx,
 						udi, "net.interface", NULL);
 	}
 
 	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_MODEM) {
-		element->netdev.index = libhal_device_get_property_int(ctx,
+		element->index = libhal_device_get_property_int(ctx,
 						udi, "serial.port", NULL);
 
-		element->netdev.name = libhal_device_get_property_string(ctx,
+		element->name = libhal_device_get_property_string(ctx,
 						udi, "serial.device", NULL);
 	}
 }
@@ -108,15 +108,22 @@ static void create_element(LibHalContext *ctx, const char *udi,
 
 	DBG("ctx %p udi %s", ctx, udi);
 
-	element = connman_element_create();
+	element = connman_element_create(NULL);
 
-	element->name = g_path_get_basename(udi);
 	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
 	element->subtype = subtype;
 
 	device_info(ctx, udi, element);
 	device_netdev(ctx, udi, element);
 
+	if (element->name == NULL) {
+		element->name = g_path_get_basename(udi);
+		if (element->name == NULL) {
+			connman_element_unref(element);
+			return;
+		}
+	}
+
 	g_static_mutex_lock(&element_mutex);
 
 	connman_element_register(element, NULL);

commit 135f8ccd37f76068bc75e21f23fb68e74be57c0e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 21:11:01 2008 +0200

    Add INET helper functions

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index d210f467..b4e98055 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -8,7 +8,7 @@ rtnllink_la_SOURCES = rtnllink.c
 
 ethernet_la_SOURCES = ethernet.c
 
-wifi_la_SOURCES = wifi.c supplicant.h supplicant.c
+wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 
 bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
@@ -19,7 +19,7 @@ dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 
 ipv4_la_SOURCES = ipv4.c
 
-resolvconf_la_SOURCES = resolvconf.c
+resolvconf_la_SOURCES = resolvconf.c inet.h inet.c
 
 resolvfile_la_SOURCES = resolvfile.c
 
diff --git a/plugins/inet.c b/plugins/inet.c
new file mode 100644
index 00000000..e14d33ef
--- /dev/null
+++ b/plugins/inet.c
@@ -0,0 +1,59 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+
+#include "inet.h"
+
+char *inet_index2name(int index)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	if (index < 0)
+		return NULL;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	return strdup(ifr.ifr_name);
+}
diff --git a/plugins/inet.h b/plugins/inet.h
new file mode 100644
index 00000000..aafd55b3
--- /dev/null
+++ b/plugins/inet.h
@@ -0,0 +1,22 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+char *inet_index2name(int index);

commit 85f79afa2392e6ef108812685b8a1901448c4ebb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 21:11:44 2008 +0200

    Fixup breakage due to new property constants

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 17d6c534..0a66a237 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -71,7 +71,7 @@ static int set_ipv4(struct connman_element *element,
 		return -1;
 
 	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = element->netdev.index;
+	ifr.ifr_ifindex = element->index;
 
 	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
 		close(sk);
@@ -147,7 +147,7 @@ static int clear_ipv4(struct connman_element *element)
 		return -1;
 
 	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = element->netdev.index;
+	ifr.ifr_ifindex = element->index;
 
 	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
 		close(sk);
@@ -182,11 +182,11 @@ static int ipv4_probe(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 
 	connman_element_get_value(element,
-				CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS, &address);
+				CONNMAN_PROPERTY_ID_IPV4_ADDRESS, &address);
 	connman_element_get_value(element,
-				CONNMAN_PROPERTY_TYPE_IPV4_NETMASK, &netmask);
+				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
 	connman_element_get_value(element,
-				CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY, &gateway);
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
 
 	DBG("address %s", address);
 	DBG("netmask %s", netmask);
@@ -199,10 +199,9 @@ static int ipv4_probe(struct connman_element *element)
 
 	set_ipv4(element, &ipv4);
 
-	resolver = connman_element_create();
+	resolver = connman_element_create(NULL);
 
 	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
-	resolver->netdev.name = g_strdup(element->netdev.name);
 
 	connman_element_register(resolver, element);
 

commit 7f30feb2513f6a1609f291e4e9c647a08434d2c2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 21:12:59 2008 +0200

    Fixup resolver plugins to use INET helpers

diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 779c68f3..814bbeb7 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -30,13 +30,15 @@
 #include <connman/driver.h>
 #include <connman/log.h>
 
+#include "inet.h"
+
 #define RESOLVCONF "/sbin/resolvconf"
 
 static int resolvconf_probe(struct connman_element *element)
 {
 	const char *nameserver = NULL;
 	struct connman_element *internet;
-	gchar *cmd;
+	gchar *cmd, *name;
 	int err;
 
 	DBG("element %p name %s", element, element->name);
@@ -45,22 +47,26 @@ static int resolvconf_probe(struct connman_element *element)
 		return -errno;
 
 	connman_element_get_value(element,
-			CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER, &nameserver);
+			CONNMAN_PROPERTY_ID_IPV4_NAMESERVER, &nameserver);
 
 	if (nameserver == NULL)
 		return -EINVAL;
 
+	name = inet_index2name(element->index);
+
 	cmd = g_strdup_printf("echo \"nameserver %s\" | %s -a %s",
-						nameserver, RESOLVCONF,
-							element->netdev.name);
+						nameserver, RESOLVCONF, name);
+
+	g_free(name);
 
 	DBG("%s", cmd);
 
-	err = system(cmd);
+	//err = system(cmd);
+	err = 0;
 
 	g_free(cmd);
 
-	internet = connman_element_create();
+	internet = connman_element_create(NULL);
 
 	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
 
@@ -71,16 +77,21 @@ static int resolvconf_probe(struct connman_element *element)
 
 static void resolvconf_remove(struct connman_element *element)
 {
-	gchar *cmd;
+	gchar *cmd, *name;
 	int err;
 
 	DBG("element %p name %s", element, element->name);
 
-	cmd = g_strdup_printf("%s -d %s", RESOLVCONF, element->netdev.name);
+	name = inet_index2name(element->index);
+
+	cmd = g_strdup_printf("%s -d %s", RESOLVCONF, name);
+
+	g_free(name);
 
 	DBG("%s", cmd);
 
-	err = system(cmd);
+	//err = system(cmd);
+	err = 0;
 
 	g_free(cmd);
 }
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index 5ea3422d..0920441c 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -43,7 +43,7 @@ static int resolvfile_probe(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 
 	connman_element_get_value(element,
-			CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER, &nameserver);
+			CONNMAN_PROPERTY_ID_IPV4_NAMESERVER, &nameserver);
 
 	if (nameserver == NULL)
 		return -EINVAL;
@@ -63,7 +63,7 @@ static int resolvfile_probe(struct connman_element *element)
 
 	close(fd);
 
-	internet = connman_element_create();
+	internet = connman_element_create(NULL);
 
 	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
 

commit a977d2f3861ad3344238326c744974009545c591
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 21:14:09 2008 +0200

    Use INET helpers for setting the interface name

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index ee8a3a52..342e6d7f 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -31,6 +31,8 @@
 #include <connman/dbus.h>
 #include <connman/log.h>
 
+#include "inet.h"
+
 #define DHCLIENT_INTF "org.isc.dhclient"
 #define DHCLIENT_PATH "/org/isc/dhclient"
 
@@ -140,8 +142,8 @@ static int dhclient_probe(struct connman_element *element)
 	if (task == NULL)
 		return -ENOMEM;
 
-	task->ifindex = element->netdev.index;
-	task->ifname = g_strdup(element->netdev.name);
+	task->ifindex = element->index;
+	task->ifname = inet_index2name(element->index);
 	task->element = element;
 
 	if (task->ifname == NULL) {
@@ -203,7 +205,7 @@ static void dhclient_remove(struct connman_element *element)
 
 	g_static_mutex_lock(&task_mutex);
 
-	task = find_task_by_index(element->netdev.index);
+	task = find_task_by_index(element->index);
 	if (task != NULL)
 		task_list = g_slist_remove(task_list, task);
 
@@ -301,10 +303,9 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 	} else if (g_ascii_strcasecmp(text, "BOUND") == 0 ||
 				g_ascii_strcasecmp(text, "REBOOT") == 0) {
 		struct connman_element *element;
-		element = connman_element_create();
+		element = connman_element_create(NULL);
 		element->type = CONNMAN_ELEMENT_TYPE_IPV4;
-		element->netdev.index = task->ifindex;
-		element->netdev.name = g_strdup(task->ifname);
+		element->index = task->ifindex;
 		connman_element_update(task->element);
 		connman_element_register(element, task->element);
 	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 3fd3cb9e..b0d74c6a 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -28,6 +28,7 @@
 
 #include <connman/log.h>
 
+#include "inet.h"
 #include "supplicant.h"
 
 #define TIMEOUT 5000
@@ -909,8 +910,8 @@ int __supplicant_start(struct connman_element *element,
 	if (task == NULL)
 		return -ENOMEM;
 
-	task->ifindex = element->netdev.index;
-	task->ifname = g_strdup(element->netdev.name);
+	task->ifindex = element->index;
+	task->ifname = inet_index2name(element->index);
 	task->element = element;
 	task->callback = callback;
 
@@ -954,7 +955,7 @@ int __supplicant_stop(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	task = find_task_by_index(element->netdev.index);
+	task = find_task_by_index(element->index);
 	if (task == NULL)
 		return -ENODEV;
 
@@ -986,7 +987,7 @@ int __supplicant_scan(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	task = find_task_by_index(element->netdev.index);
+	task = find_task_by_index(element->index);
 	if (task == NULL)
 		return -ENODEV;
 
@@ -1013,7 +1014,7 @@ int __supplicant_connect(struct connman_element *element, const char *ssid)
 
 	DBG("element %p name %s", element, element->name);
 
-	task = find_task_by_index(element->netdev.index);
+	task = find_task_by_index(element->index);
 	if (task == NULL)
 		return -ENODEV;
 
@@ -1035,7 +1036,7 @@ int __supplicant_disconnect(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	task = find_task_by_index(element->netdev.index);
+	task = find_task_by_index(element->index);
 	if (task == NULL)
 		return -ENODEV;
 

commit f5621af4d484694ad91ba9a78e7b89b2f8cf31e6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Sep 1 21:19:13 2008 +0200

    Remove backup files at cleanup stage

diff --git a/doc/Makefile.am b/doc/Makefile.am
index b9ade0fc..92d9540e 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -29,7 +29,7 @@ INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/gdbus \
 GTKDOC_LIBS = $(DBUS_LIBS) $(GLIB_LIBS) $(GMODULE_LIBS) $(GTHREAD_LIBS)
 
 MAINTAINERCLEANFILES = Makefile.in \
-	$(DOC_MODULE).types $(DOC_MODULE)-*.txt *.sgml
+	$(DOC_MODULE).types $(DOC_MODULE)-*.txt *.sgml *.bak
 
 if ENABLE_GTK_DOC
 include $(top_srcdir)/doc/gtk-doc.make

commit 3ffbebd7928775c18ff83c629e266d431d8e489d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 14:39:19 2008 +0200

    Mention the GLib requirement

diff --git a/connman.pc.in b/connman.pc.in
index fd86152c..cb38b922 100644
--- a/connman.pc.in
+++ b/connman.pc.in
@@ -8,6 +8,7 @@ scriptdir=${libdir}/connman/scripts
 
 Name: connman
 Description: Connection Manager
+Requires: glib-2.0
 Version: @VERSION@
 Libs: -module -avoid-version -export-symbols-regex connman_plugin_desc
 Cflags: -I${includedir}

commit ce727c1bf6c7580104d4241b1b1ec0d53b2465f6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 14:44:21 2008 +0200

    Add element subtype for generic network devices

diff --git a/include/element.h b/include/element.h
index 57103d31..a7ddb7d0 100644
--- a/include/element.h
+++ b/include/element.h
@@ -61,11 +61,12 @@ enum connman_element_type {
 
 enum connman_element_subtype {
 	CONNMAN_ELEMENT_SUBTYPE_UNKNOWN   = 0,
-	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 1,
-	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 2,
-	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 3,
-	CONNMAN_ELEMENT_SUBTYPE_MODEM     = 4,
-	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 5,
+	CONNMAN_ELEMENT_SUBTYPE_NETWORK   = 1,
+	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 2,
+	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 3,
+	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 4,
+	CONNMAN_ELEMENT_SUBTYPE_MODEM     = 5,
+	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 6,
 };
 
 struct connman_driver;

commit 8393bbf9b8c2704b68df7db9b326d7230b663476
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 14:53:52 2008 +0200

    Add simple network device plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index b4e98055..e91bf057 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,10 +1,9 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = rtnllink.la ethernet.la wifi.la bluetooth.la \
-			dhclient.la ipv4.la resolvconf.la resolvfile.la
-
-rtnllink_la_SOURCES = rtnllink.c
+plugin_LTLIBRARIES = ethernet.la wifi.la bluetooth.la \
+				netdev.la dhclient.la ipv4.la \
+				resolvconf.la resolvfile.la rtnllink.la
 
 ethernet_la_SOURCES = ethernet.c
 
@@ -13,6 +12,8 @@ wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
+netdev_la_SOURCES = netdev.c
+
 dhclient_la_SOURCES = dhclient.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
@@ -23,6 +24,8 @@ resolvconf_la_SOURCES = resolvconf.c inet.h inet.c
 
 resolvfile_la_SOURCES = resolvfile.c
 
+rtnllink_la_SOURCES = rtnllink.c
+
 if HAL
 plugin_LTLIBRARIES += hal.la
 
diff --git a/plugins/netdev.c b/plugins/netdev.c
new file mode 100644
index 00000000..d8733b76
--- /dev/null
+++ b/plugins/netdev.c
@@ -0,0 +1,81 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static void create_element(struct connman_element *parent,
+					enum connman_element_type type)
+{
+	struct connman_element *element;
+
+	DBG("parent %p name %s", parent, parent->name);
+
+	element = connman_element_create(NULL);
+	if (element == NULL)
+		return;
+
+	element->type = type;
+	element->index = parent->index;
+
+	connman_element_register(element, parent);
+}
+
+static int netdev_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	create_element(element, CONNMAN_ELEMENT_TYPE_DHCP);
+	create_element(element, CONNMAN_ELEMENT_TYPE_ZEROCONF);
+
+	return 0;
+}
+
+static void netdev_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver netdev_driver = {
+	.name		= "netdev",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_NETWORK,
+	.probe		= netdev_probe,
+	.remove		= netdev_remove,
+};
+
+static int netdev_init(void)
+{
+	return connman_driver_register(&netdev_driver);
+}
+
+static void netdev_exit(void)
+{
+	connman_driver_unregister(&netdev_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE("netdev", "Network device plugin", VERSION,
+						netdev_init, netdev_exit)

commit 99b5476272ab042a002ca6e636439e92a06f87e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 15:01:19 2008 +0200

    Add string conversion for network device subtype

diff --git a/src/element.c b/src/element.c
index a9012b2d..3f697ea9 100644
--- a/src/element.c
+++ b/src/element.c
@@ -122,6 +122,8 @@ static const char *subtype2string(enum connman_element_subtype type)
 	switch (type) {
 	case CONNMAN_ELEMENT_SUBTYPE_UNKNOWN:
 		return "unknown";
+	case CONNMAN_ELEMENT_SUBTYPE_NETWORK:
+		return "network";
 	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:
 		return "ethernet";
 	case CONNMAN_ELEMENT_SUBTYPE_WIFI:

commit 5ac584540591580d393ba5a136e949860ae86e75
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 15:03:31 2008 +0200

    Let the Ethernet plugin create network devices

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 697149bb..b05c78bf 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -43,23 +43,6 @@ struct ethernet_data {
 static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
 static GSList *ethernet_list = NULL;
 
-static void create_element(struct connman_element *parent,
-					enum connman_element_type type)
-{
-	struct connman_element *element;
-
-	DBG("parent %p name %s", parent, parent->name);
-
-	element = connman_element_create(NULL);
-	if (element == NULL)
-		return;
-
-	element->type = type;
-	element->index = parent->index;
-
-	connman_element_register(element, parent);
-}
-
 static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 {
 	GSList *list;
@@ -76,6 +59,7 @@ static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 
 	for (list = ethernet_list; list; list = list->next) {
 		struct connman_element *element = list->data;
+		struct connman_element *netdev;
 		struct ethernet_data *ethernet;
 
 		ethernet = connman_element_get_data(element);
@@ -94,8 +78,14 @@ static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 		if (ethernet->flags & IFF_RUNNING) {
 			DBG("carrier on");
 
-			create_element(element, CONNMAN_ELEMENT_TYPE_DHCP);
-			create_element(element, CONNMAN_ELEMENT_TYPE_ZEROCONF);
+			netdev = connman_element_create(NULL);
+			if (netdev != NULL) {
+				netdev->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
+				netdev->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
+				netdev->index   = element->index;
+
+				connman_element_register(netdev, element);
+			}
 		} else {
 			DBG("carrier off");
 

commit ad94c021ad5df8b199f1d74510ed19e61ca2899a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 19:58:14 2008 +0200

    Add debug message when device is ignored

diff --git a/src/element.c b/src/element.c
index 3f697ea9..4238bdf5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -957,8 +957,10 @@ int connman_element_register(struct connman_element *element,
 	DBG("element %p name %s parent %p", element, element->name, parent);
 
 	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
-		if (g_str_equal(device_filter, element->name) == FALSE)
+		if (g_str_equal(device_filter, element->name) == FALSE) {
+			DBG("ignoring %s device", element->name);
 			return -EPERM;
+		}
 	}
 
 	if (connman_element_ref(element) == NULL)

commit 103706c4f4da0c89f8b6f33cccdc3149f4ecc09a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 19:58:41 2008 +0200

    Add support for detecting WiMAX devices properly

diff --git a/plugins/hal.c b/plugins/hal.c
index 942faaf6..bda2f8c1 100644
--- a/plugins/hal.c
+++ b/plugins/hal.c
@@ -23,6 +23,9 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <sys/stat.h>
+
 #include <dbus/dbus.h>
 #include <hal/libhal.h>
 
@@ -36,6 +39,7 @@ static struct {
 } capabilities[] = {
 	{ "net.80203", CONNMAN_ELEMENT_SUBTYPE_ETHERNET },
 	{ "net.80211", CONNMAN_ELEMENT_SUBTYPE_WIFI     },
+	{ "net.wimax", CONNMAN_ELEMENT_SUBTYPE_WIMAX    },
 	{ "modem",     CONNMAN_ELEMENT_SUBTYPE_MODEM    },
 	{ }
 };
@@ -84,7 +88,8 @@ static void device_netdev(LibHalContext *ctx, const char *udi,
 					struct connman_element *element)
 {
 	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_ETHERNET ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI) {
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX) {
 		element->index = libhal_device_get_property_int(ctx,
 						udi, "net.linux.ifindex", NULL);
 
@@ -108,6 +113,21 @@ static void create_element(LibHalContext *ctx, const char *udi,
 
 	DBG("ctx %p udi %s", ctx, udi);
 
+	if (subtype == CONNMAN_ELEMENT_SUBTYPE_ETHERNET) {
+		char *sysfs_path, wimax_path[PATH_MAX];
+		struct stat st;
+
+		sysfs_path = libhal_device_get_property_string(ctx, udi,
+						"linux.sysfs_path", NULL);
+		if (sysfs_path != NULL) {
+			snprintf(wimax_path, PATH_MAX, "%s/wimax", sysfs_path);
+
+			if (stat(wimax_path, &st) == 0 &&
+						(st.st_mode & S_IFDIR))
+				subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
+		}
+	}
+
 	element = connman_element_create(NULL);
 
 	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;

commit 9f87c74fa2360bf63e476577518d2f0e2d5dd71e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 22:33:33 2008 +0200

    Also scan on WiMAX devices

diff --git a/test/start-scanning b/test/start-scanning
index 9b5878b0..104a55b1 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -21,7 +21,10 @@ for path in elements:
 	print "[ %s ]" % (path)
 
 	if (properties["Subtype"] == "wifi"):
-		print "   Started scanning"
+		print "   Started WiFi scanning"
+		element.Update()
+	elif (properties["Subtype"] == "wimax")
+		print "   Started WiMAX scanning"
 		element.Update()
 	else:
 		print "   No scanning"

commit e952851502277cc41cd2a54ef5386cca7a8843dd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 19 01:55:00 2008 +0200

    Fix broken Python statement

diff --git a/test/start-scanning b/test/start-scanning
index 104a55b1..ff0dd07a 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -23,7 +23,7 @@ for path in elements:
 	if (properties["Subtype"] == "wifi"):
 		print "   Started WiFi scanning"
 		element.Update()
-	elif (properties["Subtype"] == "wimax")
+	elif (properties["Subtype"] == "wimax"):
 		print "   Started WiMAX scanning"
 		element.Update()
 	else:

commit 8183cf09ce7b7d623779227aae732de8fc723996
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 26 01:15:55 2008 +0200

    Add /sbin and /usr/sbin to $PATH when detecting for dhclient

diff --git a/configure.ac b/configure.ac
index 615045e0..61e6418c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -45,8 +45,8 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
-AC_PATH_PROG(DHCLIENT, [dhclient])
-AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant])
+AC_PATH_PROG(DHCLIENT, [dhclient], ,$PATH:/sbin:/usr/sbin)
+AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
 
 PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
 				AC_MSG_ERROR(glib is required))

commit 324168d1758b4cf062b703eed36fde1c8c0e642c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 26 01:19:58 2008 +0200

    The properties currently use DBUS_TYPE_* so require dbus-1

diff --git a/connman.pc.in b/connman.pc.in
index cb38b922..2af3c2bb 100644
--- a/connman.pc.in
+++ b/connman.pc.in
@@ -8,7 +8,7 @@ scriptdir=${libdir}/connman/scripts
 
 Name: connman
 Description: Connection Manager
-Requires: glib-2.0
+Requires: glib-2.0 dbus-1
 Version: @VERSION@
 Libs: -module -avoid-version -export-symbols-regex connman_plugin_desc
 Cflags: -I${includedir}

commit 97a8b3658e46f41c930d0d31a1f07099c9859e75
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 26 01:21:46 2008 +0200

    Add INET helpers to dhclient plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index e91bf057..7c12a8ef 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -14,7 +14,7 @@ bluetooth_la_LIBADD = @GDBUS_LIBS@
 
 netdev_la_SOURCES = netdev.c
 
-dhclient_la_SOURCES = dhclient.c
+dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 

commit 794085a8cbcffd8803ced3bcf1bad405db7696d9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 26 01:23:44 2008 +0200

    Print error details when plugin loading fails

diff --git a/src/plugin.c b/src/plugin.c
index 244aaebf..12ed917d 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -75,7 +75,8 @@ static void load_plugins(const gchar *path)
 
 			module = g_module_open(filename, 0);
 			if (module == NULL) {
-				g_warning("Can't load %s", filename);
+				g_warning("Can't load %s: %s", filename,
+							g_module_error());
 				continue;
 			}
 

commit fd8db5dd245a1e6a8a2cdd763f55a461a38bc57e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 26 02:18:23 2008 +0200

    Restore functionality to get property values

diff --git a/src/element.c b/src/element.c
index 4238bdf5..a2a48e87 100644
--- a/src/element.c
+++ b/src/element.c
@@ -899,44 +899,42 @@ int connman_element_get_value(struct connman_element *element,
 	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
 		return -EINVAL;
 
-#if 0
-	switch (type) {
-	case CONNMAN_PROPERTY_TYPE_INVALID:
-		return -EINVAL;
-	case CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS:
+	switch (id) {
+	case CONNMAN_PROPERTY_ID_IPV4_ADDRESS:
 		if (element->ipv4.address == NULL)
 			return connman_element_get_value(element->parent,
-								type, value);
+								id, value);
 		connman_element_lock(element);
 		*((char **) value) = element->ipv4.address;
 		connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_TYPE_IPV4_NETMASK:
+	case CONNMAN_PROPERTY_ID_IPV4_NETMASK:
 		if (element->ipv4.netmask == NULL)
 			return connman_element_get_value(element->parent,
-								type, value);
+								id, value);
 		connman_element_lock(element);
 		*((char **) value) = element->ipv4.netmask;
 		connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY:
+	case CONNMAN_PROPERTY_ID_IPV4_GATEWAY:
 		if (element->ipv4.gateway == NULL)
 			return connman_element_get_value(element->parent,
-								type, value);
+								id, value);
 		connman_element_lock(element);
 		*((char **) value) = element->ipv4.gateway;
 		connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER:
+	case CONNMAN_PROPERTY_ID_IPV4_NAMESERVER:
 		if (element->ipv4.nameserver == NULL)
 			return connman_element_get_value(element->parent,
-								type, value);
+								id, value);
 		connman_element_lock(element);
 		*((char **) value) = element->ipv4.nameserver;
 		connman_element_unlock(element);
 		break;
+	default:
+		return -EINVAL;
 	}
-#endif
 
 	return 0;
 }

commit 83359bfdac24a0bcfd7038050bdaaa2b3d3f9543
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Sep 26 02:20:28 2008 +0200

    Restore setting of IPv4 properties via D-Bus

diff --git a/src/element.c b/src/element.c
index a2a48e87..9260d16e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -854,36 +854,34 @@ int connman_element_create_property(struct connman_element *element,
 int connman_element_set_property(struct connman_element *element,
 				enum connman_property_id id, const void *value)
 {
-#if 0
-	switch (type) {
-	case CONNMAN_PROPERTY_TYPE_INVALID:
-		return -EINVAL;
-	case CONNMAN_PROPERTY_TYPE_IPV4_ADDRESS:
+	switch (id) {
+	case CONNMAN_PROPERTY_ID_IPV4_ADDRESS:
 		connman_element_lock(element);
 		g_free(element->ipv4.address);
 		element->ipv4.address = g_strdup(*((const char **) value));
 		connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_TYPE_IPV4_NETMASK:
+	case CONNMAN_PROPERTY_ID_IPV4_NETMASK:
 		connman_element_lock(element);
 		g_free(element->ipv4.netmask);
 		element->ipv4.netmask = g_strdup(*((const char **) value));
 		connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_TYPE_IPV4_GATEWAY:
+	case CONNMAN_PROPERTY_ID_IPV4_GATEWAY:
 		connman_element_lock(element);
 		g_free(element->ipv4.gateway);
 		element->ipv4.gateway = g_strdup(*((const char **) value));
 		connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_TYPE_IPV4_NAMESERVER:
+	case CONNMAN_PROPERTY_ID_IPV4_NAMESERVER:
 		connman_element_lock(element);
 		g_free(element->ipv4.nameserver);
 		element->ipv4.nameserver = g_strdup(*((const char **) value));
 		connman_element_unlock(element);
 		break;
+	default:
+		return -EINVAL;
 	}
-#endif
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",

commit 18886b7ef037884eff0bac7b9de673aa0a058493
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 14:19:52 2008 +0200

    Use glob pattern matching for interface names

diff --git a/src/element.c b/src/element.c
index 9260d16e..2934eddc 100644
--- a/src/element.c
+++ b/src/element.c
@@ -953,7 +953,8 @@ int connman_element_register(struct connman_element *element,
 	DBG("element %p name %s parent %p", element, element->name, parent);
 
 	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
-		if (g_str_equal(device_filter, element->name) == FALSE) {
+		if (g_pattern_match_simple(device_filter,
+						element->name) == FALSE) {
 			DBG("ignoring %s device", element->name);
 			return -EPERM;
 		}

commit 6fa6bdc6f6a8d239142b32979318245da8941d2b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 14:21:02 2008 +0200

    Fail if address, netmask or gateway are not provided

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 0a66a237..67d1ed10 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -192,6 +192,9 @@ static int ipv4_probe(struct connman_element *element)
 	DBG("netmask %s", netmask);
 	DBG("gateway %s", gateway);
 
+	if (address == NULL || netmask == NULL || gateway == NULL)
+		return -EINVAL;
+
 	memset(&ipv4, 0, sizeof(ipv4));
 	ipv4.address.s_addr = inet_addr(address);
 	ipv4.netmask.s_addr = inet_addr(netmask);

commit 8dd59fd33eed869fcb2597b3962b8d3cba9c5efa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 14:23:28 2008 +0200

    Include fake plugin for testing

diff --git a/bootstrap-configure b/bootstrap-configure
index ea6d525d..cba03dcc 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -15,4 +15,5 @@ fi
 		--prefix=/usr \
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
-		--sysconfdir=/etc
+		--sysconfdir=/etc \
+		--enable-fake $*
diff --git a/configure.ac b/configure.ac
index 61e6418c..5857197a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -85,6 +85,10 @@ PKG_CHECK_MODULES(SQLITE, sqlite3, sqlite_found=yes, sqlite_found=no)
 AC_SUBST(SQLITE_CFLAGS)
 AC_SUBST(SQLITE_LIBS)
 
+AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
+			[enable fake plugin]), [enable_fake=${enableval}])
+AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")
+
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile src/Makefile doc/Makefile
 		test/Makefile plugins/Makefile scripts/Makefile scripts/connman
 				src/connman.service doc/version.xml connman.pc)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 7c12a8ef..a19236cc 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -46,6 +46,12 @@ policydir = $(datadir)/PolicyKit/policy
 policy_DATA = connman.policy
 endif
 
+if FAKE
+plugin_LTLIBRARIES += fake.la
+
+fake_la_SOURCES = fake.c
+endif
+
 AM_LDFLAGS = -no-undefined -module -avoid-version \
 				-export-symbols-regex connman_plugin_desc
 
diff --git a/plugins/fake.c b/plugins/fake.c
new file mode 100644
index 00000000..235751c0
--- /dev/null
+++ b/plugins/fake.c
@@ -0,0 +1,37 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+
+static int fake_init(void)
+{
+	return 0;
+}
+
+static void fake_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE("fake", "Tesing plugin", VERSION, fake_init, fake_exit)

commit 371e8bd67cbeb37695f5b69d964a11bf0cc963b2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 14:28:19 2008 +0200

    Add script for monitoring network changes

diff --git a/test/Makefile.am b/test/Makefile.am
index 9b640ea3..bcc9e5d2 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,6 +1,7 @@
 
 EXTRA_DIST = list-profiles list-elements monitor-elements monitor-state \
-		start-scanning select-network disable-network simple-agent \
-		get-state show-introspection test-compat test-supplicant
+		get-state select-network disable-network monitor-networks \
+		start-scanning simple-agent \
+		show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/monitor-networks b/test/monitor-networks
new file mode 100755
index 00000000..ce817ef9
--- /dev/null
+++ b/test/monitor-networks
@@ -0,0 +1,52 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.service
+import dbus.mainloop.glib
+
+def element_print(action, path):
+	print "%s [ %s ]" % (action, path)
+
+	if (action == "-"):
+		return
+
+	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Element")
+
+	properties = element.GetProperties()
+	if (properties["Type"] != "network"):
+		return
+
+	for key in properties.keys():
+		print "      %s = %s" % (key, properties[key])
+
+def element_added(path):
+	element_print("+", path)
+
+def element_updated(path):
+	element_print("*", path)
+
+def element_removed(path):
+	element_print("-", path)
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+
+	bus.add_signal_receiver(element_added,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementAdded")
+
+	bus.add_signal_receiver(element_updated,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementUpdated")
+
+	bus.add_signal_receiver(element_removed,
+				dbus_interface = "org.moblin.connman.Manager",
+						signal_name = "ElementRemoved")
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()

commit 6ca9fc9115f323d7358b146096994c7f2ba344b5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 14:36:57 2008 +0200

    Add scripts for enabling/disabling devices

diff --git a/test/Makefile.am b/test/Makefile.am
index bcc9e5d2..fe11939d 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,7 +1,7 @@
 
 EXTRA_DIST = list-profiles list-elements monitor-elements monitor-state \
 		get-state select-network disable-network monitor-networks \
-		start-scanning simple-agent \
+		enable-device disable-device start-scanning simple-agent \
 		show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/disable-device b/test/disable-device
new file mode 100755
index 00000000..ac55e77a
--- /dev/null
+++ b/test/disable-device
@@ -0,0 +1,23 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
+
+elements = manager.ListElements()
+
+for path in elements:
+	element = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Element')
+
+	properties = element.GetProperties()
+
+	if (properties["Type"] != "device"):
+		continue
+
+	print "[ %s ]" % (path)
+
+	element.Disable()
diff --git a/test/enable-device b/test/enable-device
new file mode 100755
index 00000000..55bd1f19
--- /dev/null
+++ b/test/enable-device
@@ -0,0 +1,23 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
+
+elements = manager.ListElements()
+
+for path in elements:
+	element = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Element')
+
+	properties = element.GetProperties()
+
+	if (properties["Type"] != "device"):
+		continue
+
+	print "[ %s ]" % (path)
+
+	element.Enable()

commit 866c74f98fae4227d26c651bb6adff43f5275498
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 15:08:48 2008 +0200

    Update status of Enabled property

diff --git a/src/element.c b/src/element.c
index 2934eddc..ff467d54 100644
--- a/src/element.c
+++ b/src/element.c
@@ -359,6 +359,9 @@ static DBusMessage *do_update(DBusConnection *conn,
 	if (element->driver == NULL)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
+	if (element->enabled == FALSE)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
 	if (element->driver->update) {
 		DBG("Calling update callback");
 		element->driver->update(element);
@@ -377,9 +380,19 @@ static DBusMessage *do_enable(DBusConnection *conn,
 	if (element->driver == NULL)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
+	if (element->enabled == TRUE)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
 	if (element->driver->enable) {
 		DBG("Calling enable callback");
-		element->driver->enable(element);
+		if (element->driver->enable(element) == 0) {
+			element->enabled = TRUE;
+
+			g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+		}
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
@@ -395,9 +408,19 @@ static DBusMessage *do_disable(DBusConnection *conn,
 	if (element->driver == NULL)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
+	if (element->enabled == FALSE)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
 	if (element->driver->disable) {
 		DBG("Calling disable callback");
-		element->driver->disable(element);
+		if (element->driver->disable(element) == 0) {
+			element->enabled = FALSE;
+
+			g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+		}
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);

commit 4351a568b74d3ed47ef67582123a70a674126add
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 7 15:11:56 2008 +0200

    Add basic functionality to fake plugin

diff --git a/plugins/fake.c b/plugins/fake.c
index 235751c0..7bd48dfa 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -24,14 +24,98 @@
 #endif
 
 #include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/element.h>
+#include <connman/log.h>
 
-static int fake_init(void)
+static void create_network(struct connman_element *parent, const char *name)
+{
+	struct connman_element *element;
+
+	element = connman_element_create(name);
+	element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
+
+	connman_element_register(element, parent);
+	connman_element_unref(element);
+}
+
+static int fake_device_probe(struct connman_element *element)
+{
+	DBG("");
+
+	return 0;
+}
+
+static void fake_device_remove(struct connman_element *element)
+{
+	DBG("");
+}
+
+static int fake_device_update(struct connman_element *element)
+{
+	DBG("");
+
+	create_network(element, "network_new");
+
+	return 0;
+}
+
+static int fake_device_enable(struct connman_element *element)
 {
+	DBG("");
+
+	create_network(element, "network_one");
+	create_network(element, "network_two");
+
+	return 0;
+}
+
+static int fake_device_disable(struct connman_element *element)
+{
+	DBG("");
+
+	connman_element_unregister_children(element);
+
 	return 0;
 }
 
+static struct connman_driver fake_device_driver = {
+	.name		= "fake-device",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.priority	= CONNMAN_DRIVER_PRIORITY_HIGH,
+	.probe		= fake_device_probe,
+	.remove		= fake_device_remove,
+	.update		= fake_device_update,
+	.enable		= fake_device_enable,
+	.disable	= fake_device_disable,
+};
+
+static void create_device(const char *name)
+{
+	struct connman_element *element;
+
+	element = connman_element_create(name);
+	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+
+	//connman_element_define_properties(element,
+	//				CONNMAN_PROPERTY_ID_IPV4_METHOD,
+	//				CONNMAN_PROPERTY_ID_INVALID);
+
+	connman_element_register(element, NULL);
+	connman_element_unref(element);
+}
+
+static int fake_init(void)
+{
+	create_device("fakeone");
+	create_device("faketwo");
+
+	return connman_driver_register(&fake_device_driver);
+}
+
 static void fake_exit(void)
 {
+	connman_driver_unregister(&fake_device_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE("fake", "Tesing plugin", VERSION, fake_init, fake_exit)

commit 212854d57f92b64726bddec8fb9e321fb023c13c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 8 00:32:59 2008 +0200

    Handle drivers without enable or disable callbacks

diff --git a/src/element.c b/src/element.c
index ff467d54..d2fe4bce 100644
--- a/src/element.c
+++ b/src/element.c
@@ -385,15 +385,15 @@ static DBusMessage *do_enable(DBusConnection *conn,
 
 	if (element->driver->enable) {
 		DBG("Calling enable callback");
-		if (element->driver->enable(element) == 0) {
-			element->enabled = TRUE;
+		element->driver->enable(element);
+	}
+
+	element->enabled = TRUE;
 
-			g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
-		}
-	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -413,15 +413,15 @@ static DBusMessage *do_disable(DBusConnection *conn,
 
 	if (element->driver->disable) {
 		DBG("Calling disable callback");
-		if (element->driver->disable(element) == 0) {
-			element->enabled = FALSE;
+		element->driver->disable(element);
+	}
 
-			g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+	element->enabled = FALSE;
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
-		}
-	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }

commit f4477991e23838c49eb59f94230ce5ac3858dffa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 8 00:38:45 2008 +0200

    Fix checking for existing driver and callbacks

diff --git a/src/element.c b/src/element.c
index d2fe4bce..5b2ecbc7 100644
--- a/src/element.c
+++ b/src/element.c
@@ -356,13 +356,10 @@ static DBusMessage *do_update(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
-	if (element->driver == NULL)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-
 	if (element->enabled == FALSE)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
-	if (element->driver->update) {
+	if (element->driver && element->driver->update) {
 		DBG("Calling update callback");
 		element->driver->update(element);
 	}
@@ -377,13 +374,10 @@ static DBusMessage *do_enable(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
-	if (element->driver == NULL)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-
 	if (element->enabled == TRUE)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
-	if (element->driver->enable) {
+	if (element->driver && element->driver->enable) {
 		DBG("Calling enable callback");
 		element->driver->enable(element);
 	}

commit bfcbd6828d59c9033b0dd33fb781a1d0d8d551c1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 8 00:41:14 2008 +0200

    Fix missing driver handling issue

diff --git a/src/element.c b/src/element.c
index 5b2ecbc7..5025c6db 100644
--- a/src/element.c
+++ b/src/element.c
@@ -399,13 +399,10 @@ static DBusMessage *do_disable(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
-	if (element->driver == NULL)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-
 	if (element->enabled == FALSE)
 		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 
-	if (element->driver->disable) {
+	if (element->driver && element->driver->disable) {
 		DBG("Calling disable callback");
 		element->driver->disable(element);
 	}

commit 110f80fd162fd56542c215b6e0035a4fd92b5d5e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 10 16:08:25 2008 +0200

    Fix copy-and-paste typo

diff --git a/README b/README
index 246b56aa..c5a84833 100644
--- a/README
+++ b/README
@@ -7,7 +7,7 @@ Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
 Compilation and installation
 ============================
 
-In order to compile libgdbus you need following software packages:
+In order to compile Connection Manager you need following software packages:
 	- GCC compiler
 	- GLib library
 	- D-Bus library

commit 74e2a49df7c7c61b91b3cbc6273c5b49d8603f74
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 11 09:24:54 2008 +0200

    Change device removal handling

diff --git a/plugins/hal.c b/plugins/hal.c
index bda2f8c1..12d67ef0 100644
--- a/plugins/hal.c
+++ b/plugins/hal.c
@@ -168,6 +168,7 @@ static void device_added(LibHalContext *ctx, const char *udi)
 
 static void device_removed(LibHalContext *ctx, const char *udi)
 {
+	struct connman_element *removal = NULL;
 	GSList *list;
 	gchar *name;
 
@@ -181,14 +182,18 @@ static void device_removed(LibHalContext *ctx, const char *udi)
 		struct connman_element *element = list->data;
 
 		if (g_str_equal(element->name, name) == TRUE) {
-			element_list = g_slist_remove(element_list, element);
-
-			connman_element_unregister(element);
-			connman_element_unref(element);
+			removal = element;
 			break;
 		}
 	}
 
+	if (removal != NULL) {
+		element_list = g_slist_remove(element_list, removal);
+
+		connman_element_unregister(removal);
+		connman_element_unref(removal);
+	}
+
 	g_static_mutex_unlock(&element_mutex);
 
 	g_free(name);

commit ba204def533bde671766200ddaf09ceba192e23f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 11 12:31:49 2008 +0200

    Add fake subtype for easier testing

diff --git a/include/element.h b/include/element.h
index a7ddb7d0..4669332e 100644
--- a/include/element.h
+++ b/include/element.h
@@ -61,12 +61,13 @@ enum connman_element_type {
 
 enum connman_element_subtype {
 	CONNMAN_ELEMENT_SUBTYPE_UNKNOWN   = 0,
-	CONNMAN_ELEMENT_SUBTYPE_NETWORK   = 1,
-	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 2,
-	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 3,
-	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 4,
-	CONNMAN_ELEMENT_SUBTYPE_MODEM     = 5,
-	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 6,
+	CONNMAN_ELEMENT_SUBTYPE_FAKE      = 1,
+	CONNMAN_ELEMENT_SUBTYPE_NETWORK   = 2,
+	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 3,
+	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 4,
+	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 5,
+	CONNMAN_ELEMENT_SUBTYPE_MODEM     = 6,
+	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 7,
 };
 
 struct connman_driver;

commit 352b0a1ac4ab26a5a0474915339973bf9dddad70
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 11 12:33:53 2008 +0200

    Don't include the Identifier property for now

diff --git a/src/element.c b/src/element.c
index 5025c6db..d3b2cc5c 100644
--- a/src/element.c
+++ b/src/element.c
@@ -229,9 +229,11 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		append_entry(&dict, "Priority",
 				DBUS_TYPE_UINT16, &element->priority);
 
+#if 0
 	if (element->network.identifier != NULL)
 		append_entry(&dict, "Identifier",
 				DBUS_TYPE_STRING, &element->network.identifier);
+#endif
 
 	if (element->ipv4.address != NULL)
 		append_entry(&dict, "IPv4.Address",

commit a2b65153ec2059d23ceb88d206518da687883ebb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 12 20:38:38 2008 +0200

    Make use of fake subtype

diff --git a/plugins/fake.c b/plugins/fake.c
index 7bd48dfa..74b32bcb 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -34,6 +34,7 @@ static void create_network(struct connman_element *parent, const char *name)
 
 	element = connman_element_create(name);
 	element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
+	element->subtype = CONNMAN_ELEMENT_SUBTYPE_FAKE;
 
 	connman_element_register(element, parent);
 	connman_element_unref(element);
@@ -82,7 +83,7 @@ static int fake_device_disable(struct connman_element *element)
 static struct connman_driver fake_device_driver = {
 	.name		= "fake-device",
 	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.priority	= CONNMAN_DRIVER_PRIORITY_HIGH,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_FAKE,
 	.probe		= fake_device_probe,
 	.remove		= fake_device_remove,
 	.update		= fake_device_update,
@@ -96,6 +97,7 @@ static void create_device(const char *name)
 
 	element = connman_element_create(name);
 	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	element->subtype = CONNMAN_ELEMENT_SUBTYPE_FAKE;
 
 	//connman_element_define_properties(element,
 	//				CONNMAN_PROPERTY_ID_IPV4_METHOD,

commit 31d8cfc6648686d832b2df63e3bb68bf23f45762
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 13:44:13 2008 +0200

    Add generic RTNL framework

diff --git a/include/rtnl.h b/include/rtnl.h
index f167a16d..57e8e07c 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -26,6 +26,25 @@
 extern "C" {
 #endif
 
+/**
+ * SECTION:rtnl
+ * @title: RTNL premitives
+ * @short_description: Functions for registering RTNL modules
+ */
+
+#define CONNMAN_RTNL_PRIORITY_LOW      -100
+#define CONNMAN_RTNL_PRIORITY_DEFAULT     0
+#define CONNMAN_RTNL_PRIORITY_HIGH      100
+
+struct connman_rtnl {
+	const char *name;
+	int priority;
+	void (*link_flags) (int index, int flags);
+};
+
+extern int connman_rtnl_register(struct connman_rtnl *rtnl);
+extern void connman_rtnl_unregister(struct connman_rtnl *rtnl);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/rtnl.c b/src/rtnl.c
index 491f190b..53879d6f 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -36,6 +36,74 @@
 
 #include "connman.h"
 
+static GStaticRWLock rtnl_lock = G_STATIC_RW_LOCK_INIT;
+static GSList *rtnl_list = NULL;
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_rtnl *rtnl1 = a;
+	const struct connman_rtnl *rtnl2 = b;
+
+	return rtnl2->priority - rtnl1->priority;
+}
+
+/**
+ * connman_rtnl_register:
+ * @rtnl: RTNL module
+ *
+ * Register a new RTNL module
+ *
+ * Returns: %0 on success
+ */
+int connman_rtnl_register(struct connman_rtnl *rtnl)
+{
+	DBG("rtnl %p name %s", rtnl, rtnl->name);
+
+	g_static_rw_lock_writer_lock(&rtnl_lock);
+
+	rtnl_list = g_slist_insert_sorted(rtnl_list, rtnl,
+							compare_priority);
+
+	g_static_rw_lock_writer_unlock(&rtnl_lock);
+
+	return 0;
+}
+
+/**
+ * connman_rtnl_unregister:
+ * @rtnl: RTNL module
+ *
+ * Remove a previously registered RTNL module
+ */
+void connman_rtnl_unregister(struct connman_rtnl *rtnl)
+{
+	DBG("rtnl %p name %s", rtnl, rtnl->name);
+
+	g_static_rw_lock_writer_lock(&rtnl_lock);
+
+	rtnl_list = g_slist_remove(rtnl_list, rtnl);
+
+	g_static_rw_lock_writer_unlock(&rtnl_lock);
+}
+
+static void process_link_flags(int flags)
+{
+	GSList *list;
+
+	DBG("idex %d", index);
+
+	g_static_rw_lock_reader_lock(&rtnl_lock);
+
+	for (list = rtnl_list; list; list = list->next) {
+		struct connman_rtnl *rtnl = list->data;
+
+		if (rtnl->link_flags)
+			rtnl->link_flags(index, flags);
+	}
+
+	g_static_rw_lock_reader_unlock(&rtnl_lock);
+}
+
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
 {
 	if (family == AF_INET) {
@@ -138,6 +206,8 @@ static void rtnl_link(struct nlmsghdr *hdr)
 			break;
 		}
 	}
+
+	process_link_flags(msg->ifi_flags);
 }
 
 static void rtnl_addr(struct nlmsghdr *hdr)
@@ -349,7 +419,7 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	//addr.nl_groups = RTMGRP_LINK;
+	addr.nl_groups = RTMGRP_LINK;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 

commit d953423c66367ee7d9b2429914257286b48c3b79
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 13:48:57 2008 +0200

    Fix forgotten index parameter

diff --git a/src/rtnl.c b/src/rtnl.c
index 53879d6f..fca9d4fa 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -86,7 +86,7 @@ void connman_rtnl_unregister(struct connman_rtnl *rtnl)
 	g_static_rw_lock_writer_unlock(&rtnl_lock);
 }
 
-static void process_link_flags(int flags)
+static void process_link_flags(int index, int flags)
 {
 	GSList *list;
 
@@ -207,7 +207,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 		}
 	}
 
-	process_link_flags(msg->ifi_flags);
+	process_link_flags(msg->ifi_index, msg->ifi_flags);
 }
 
 static void rtnl_addr(struct nlmsghdr *hdr)

commit 9427977bb5efee031b5001bd943c0efd8aa39276
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 13:56:31 2008 +0200

    The interface flags are from type short

diff --git a/include/rtnl.h b/include/rtnl.h
index 57e8e07c..fac302f2 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -39,7 +39,7 @@ extern "C" {
 struct connman_rtnl {
 	const char *name;
 	int priority;
-	void (*link_flags) (int index, int flags);
+	void (*link_flags) (int index, short flags);
 };
 
 extern int connman_rtnl_register(struct connman_rtnl *rtnl);
diff --git a/src/rtnl.c b/src/rtnl.c
index fca9d4fa..6549488b 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -86,7 +86,7 @@ void connman_rtnl_unregister(struct connman_rtnl *rtnl)
 	g_static_rw_lock_writer_unlock(&rtnl_lock);
 }
 
-static void process_link_flags(int index, int flags)
+static void process_link_flags(int index, short flags)
 {
 	GSList *list;
 

commit b389f8d373c2d8f5c636d40ec020e5e2adf0f01c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 13:57:41 2008 +0200

    Add function for requesting link status

diff --git a/include/rtnl.h b/include/rtnl.h
index fac302f2..42bd79a4 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -45,6 +45,8 @@ struct connman_rtnl {
 extern int connman_rtnl_register(struct connman_rtnl *rtnl);
 extern void connman_rtnl_unregister(struct connman_rtnl *rtnl);
 
+int connman_rtnl_send_getlink(void);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/rtnl.c b/src/rtnl.c
index 6549488b..1cc59b64 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -406,6 +406,26 @@ int __connman_rtnl_send(const void *buf, size_t len)
 			(struct sockaddr *) &addr, sizeof(addr));
 }
 
+int connman_rtnl_send_getlink(void)
+{
+	struct {
+		struct nlmsghdr hdr;
+		struct rtgenmsg msg;
+	} req;
+
+	DBG("");
+
+	memset(&req, 0, sizeof(req));
+	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
+	req.hdr.nlmsg_type = RTM_GETLINK;
+	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
+	req.hdr.nlmsg_pid = 0;
+	req.hdr.nlmsg_seq = 42;
+	req.msg.rtgen_family = AF_INET;
+
+	__connman_rtnl_send(&req, sizeof(req));
+}
+
 int __connman_rtnl_init(void)
 {
 	struct sockaddr_nl addr;

commit b6997d2f97406ca50ad536be16e09bb68dbd1ed4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 13:59:51 2008 +0200

    Make use of the RTNL framework

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index b05c78bf..f171348b 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -43,17 +43,9 @@ struct ethernet_data {
 static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
 static GSList *ethernet_list = NULL;
 
-static void rtnl_link(struct nlmsghdr *hdr, const char *type)
+static void ethernet_link_flags(int index, short flags)
 {
 	GSList *list;
-	struct ifinfomsg *msg;
-	int bytes;
-
-	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
-	bytes = IFLA_PAYLOAD(hdr);
-
-	DBG("%s ifi_index %d ifi_flags 0x%04x",
-				type, msg->ifi_index, msg->ifi_flags);
 
 	g_static_mutex_lock(&ethernet_mutex);
 
@@ -66,14 +58,13 @@ static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 		if (ethernet == NULL)
 			continue;
 
-		if (ethernet->index != msg->ifi_index)
+		if (ethernet->index != index)
 			continue;
 
-		if ((ethernet->flags & IFF_RUNNING) ==
-					(msg->ifi_flags & IFF_RUNNING))
+		if ((ethernet->flags & IFF_RUNNING) == (flags & IFF_RUNNING))
 			continue;
 
-		ethernet->flags = msg->ifi_flags;
+		ethernet->flags = flags;
 
 		if (ethernet->flags & IFF_RUNNING) {
 			DBG("carrier on");
@@ -96,91 +87,10 @@ static void rtnl_link(struct nlmsghdr *hdr, const char *type)
 	g_static_mutex_unlock(&ethernet_mutex);
 }
 
-static gboolean rtnl_event(GIOChannel *chan, GIOCondition cond, gpointer data)
-{
-	unsigned char buf[1024];
-	void *ptr = buf;
-	gsize len;
-	GIOError err;
-
-	if (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
-		return FALSE;
-
-	memset(buf, 0, sizeof(buf));
-
-	err = g_io_channel_read(chan, (gchar *) buf, sizeof(buf), &len);
-	if (err) {
-		if (err == G_IO_ERROR_AGAIN)
-			return TRUE;
-		return FALSE;
-	}
-
-	DBG("buf %p len %zd", buf, len);
-
-	while (len > 0) {
-		struct nlmsghdr *hdr = ptr;
-		struct nlmsgerr *err;
-
-		if (!NLMSG_OK(hdr, len))
-			break;
-
-		DBG("len %d type %d flags 0x%04x seq %d",
-					hdr->nlmsg_len, hdr->nlmsg_type,
-					hdr->nlmsg_flags, hdr->nlmsg_seq);
-
-		switch (hdr->nlmsg_type) {
-		case NLMSG_ERROR:
-			err = NLMSG_DATA(hdr);
-			DBG("ERROR %d (%s)", -err->error,
-						strerror(-err->error));
-			break;
-
-		case RTM_NEWLINK:
-			rtnl_link(hdr, "NEWLINK");
-			break;
-
-		case RTM_DELLINK:
-			rtnl_link(hdr, "DELLINK");
-			break;
-		}
-
-		len -= hdr->nlmsg_len;
-		ptr += hdr->nlmsg_len;
-	}
-
-	return TRUE;
-}
-
-static GIOChannel *channel;
-
-static int rtnl_request(void)
-{
-	struct {
-		struct nlmsghdr hdr;
-		struct rtgenmsg msg;
-	} req;
-
-	struct sockaddr_nl addr;
-	int sk;
-
-	DBG("");
-
-	memset(&req, 0, sizeof(req));
-	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
-	req.hdr.nlmsg_type = RTM_GETLINK;
-	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
-	req.hdr.nlmsg_pid = 0;
-	req.hdr.nlmsg_seq = 42;
-	req.msg.rtgen_family = AF_INET;
-
-	sk = g_io_channel_unix_get_fd(channel);
-
-	memset(&addr, 0, sizeof(addr));
-	addr.nl_family = AF_NETLINK;
-
-	return sendto(sk, &req, sizeof(req), 0,
-			(struct sockaddr *) &addr, sizeof(addr));
-}
+static struct connman_rtnl ethernet_rtnl = {
+	.name		= "ethernet",
+	.link_flags	= ethernet_link_flags,
+};
 
 static int iface_up(struct ethernet_data *ethernet)
 {
@@ -288,7 +198,7 @@ static int ethernet_probe(struct connman_element *element)
 
 	iface_up(ethernet);
 
-	rtnl_request();
+	connman_rtnl_send_getlink();
 
 	return 0;
 }
@@ -318,55 +228,17 @@ static struct connman_driver ethernet_driver = {
 	.remove		= ethernet_remove,
 };
 
-static int rtnl_init(void)
-{
-	struct sockaddr_nl addr;
-	int sk, err;
-
-	DBG("");
-
-	sk = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);
-	if (sk < 0)
-		return -errno;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK;
-
-	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		err = -errno;
-		close(sk);
-		return err;
-	}
-
-	channel = g_io_channel_unix_new(sk);
-	g_io_channel_set_close_on_unref(channel, TRUE);
-
-	g_io_add_watch(channel, G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
-							rtnl_event, NULL);
-
-	return 0;
-}
-
-static void rtnl_cleanup(void)
-{
-	DBG("");
-
-	g_io_channel_shutdown(channel, TRUE, NULL);
-	g_io_channel_unref(channel);
-}
-
 static int ethernet_init(void)
 {
 	int err;
 
-	err = rtnl_init();
+	err = connman_rtnl_register(&ethernet_rtnl);
 	if (err < 0)
 		return err;
 
 	err = connman_driver_register(&ethernet_driver);
 	if (err < 0) {
-		rtnl_cleanup();
+		connman_rtnl_unregister(&ethernet_rtnl):
 		return err;
 	}
 
@@ -377,7 +249,7 @@ static void ethernet_exit(void)
 {
 	connman_driver_unregister(&ethernet_driver);
 
-	rtnl_cleanup();
+	connman_rtnl_unregister(&ethernet_rtnl);
 }
 
 CONNMAN_PLUGIN_DEFINE("ethernet", "Ethernet interface plugin", VERSION,

commit 6d8e8898bd6b68dc07305b0e2b1d3e007fa37dfd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:15:21 2008 +0200

    Add support for newlink and dellink callbacks

diff --git a/include/rtnl.h b/include/rtnl.h
index 42bd79a4..3af63214 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -39,6 +39,10 @@ extern "C" {
 struct connman_rtnl {
 	const char *name;
 	int priority;
+	void (*newlink) (unsigned short type, int index,
+					unsigned flags, unsigned change);
+	void (*dellink) (unsigned short type, int index,
+					unsigned flags, unsigned change);
 	void (*link_flags) (int index, short flags);
 };
 
diff --git a/src/rtnl.c b/src/rtnl.c
index 1cc59b64..35fa54b7 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -86,6 +86,44 @@ void connman_rtnl_unregister(struct connman_rtnl *rtnl)
 	g_static_rw_lock_writer_unlock(&rtnl_lock);
 }
 
+static void process_newlink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	GSList *list;
+
+	DBG("idex %d", index);
+
+	g_static_rw_lock_reader_lock(&rtnl_lock);
+
+	for (list = rtnl_list; list; list = list->next) {
+		struct connman_rtnl *rtnl = list->data;
+
+		if (rtnl->newlink)
+			rtnl->newlink(type, index, flags, change);
+	}
+
+	g_static_rw_lock_reader_unlock(&rtnl_lock);
+}
+
+static void process_dellink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	GSList *list;
+
+	DBG("idex %d", index);
+
+	g_static_rw_lock_reader_lock(&rtnl_lock);
+
+	for (list = rtnl_list; list; list = list->next) {
+		struct connman_rtnl *rtnl = list->data;
+
+		if (rtnl->dellink)
+			rtnl->dellink(type, index, flags, change);
+	}
+
+	g_static_rw_lock_reader_unlock(&rtnl_lock);
+}
+
 static void process_link_flags(int index, short flags)
 {
 	GSList *list;
@@ -210,6 +248,34 @@ static void rtnl_link(struct nlmsghdr *hdr)
 	process_link_flags(msg->ifi_index, msg->ifi_flags);
 }
 
+static void rtnl_newlink(struct nlmsghdr *hdr)
+{
+	struct ifinfomsg *msg;
+
+	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
+
+	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
+
+	process_newlink(msg->ifi_type, msg->ifi_index,
+					msg->ifi_flags, msg->ifi_change);
+
+	rtnl_link(hdr);
+}
+
+static void rtnl_dellink(struct nlmsghdr *hdr)
+{
+	struct ifinfomsg *msg;
+
+	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
+
+	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
+
+	process_dellink(msg->ifi_type, msg->ifi_index,
+					msg->ifi_flags, msg->ifi_change);
+
+	rtnl_link(hdr);
+}
+
 static void rtnl_addr(struct nlmsghdr *hdr)
 {
 	struct ifaddrmsg *msg;
@@ -332,11 +398,11 @@ static void rtnl_message(void *buf, size_t len)
 			return;
 		case RTM_NEWLINK:
 			DBG("NEWLINK");
-			rtnl_link(hdr);
+			rtnl_newlink(hdr);
 			break;
 		case RTM_DELLINK:
 			DBG("DELLINK");
-			rtnl_link(hdr);
+			rtnl_dellink(hdr);
 			break;
 		case RTM_NEWADDR:
 			DBG("NEWADDR");

commit 773ce270c27a7b9b14c93e19b7f261c12e6126ef
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:18:13 2008 +0200

    Use RTNL newlink callback for link changes

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index f171348b..d50f7191 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -33,17 +33,19 @@
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
+#include <connman/rtnl.h>
 #include <connman/log.h>
 
 struct ethernet_data {
 	int index;
-	short flags;
+	unsigned flags;
 };
 
 static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
 static GSList *ethernet_list = NULL;
 
-static void ethernet_link_flags(int index, short flags)
+static void ethernet_newlink(unsigned short type, int index,
+					unsigned flags, unsigned change)
 {
 	GSList *list;
 
@@ -89,7 +91,7 @@ static void ethernet_link_flags(int index, short flags)
 
 static struct connman_rtnl ethernet_rtnl = {
 	.name		= "ethernet",
-	.link_flags	= ethernet_link_flags,
+	.newlink	= ethernet_newlink,
 };
 
 static int iface_up(struct ethernet_data *ethernet)
@@ -238,7 +240,7 @@ static int ethernet_init(void)
 
 	err = connman_driver_register(&ethernet_driver);
 	if (err < 0) {
-		connman_rtnl_unregister(&ethernet_rtnl):
+		connman_rtnl_unregister(&ethernet_rtnl);
 		return err;
 	}
 

commit a69968d931fee36826442a5af7e8286f3287133c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:20:40 2008 +0200

    Add skeleton for RTNL framework callbacks

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index 07f969ec..3d814280 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -25,15 +25,35 @@
 
 #include <connman/plugin.h>
 #include <connman/element.h>
+#include <connman/rtnl.h>
 #include <connman/log.h>
 
+static void rtnllink_newlink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	DBG("index %d", index);
+}
+
+static void rtnllink_dellink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	DBG("index %d", index);
+}
+
+static struct connman_rtnl rtnllink_rtnl = {
+	.name		= "rtnllink",
+	.newlink	= rtnllink_newlink,
+	.dellink	= rtnllink_dellink,
+};
+
 static int rtnllink_init(void)
 {
-	return 0;
+	return connman_rtnl_register(&rtnllink_rtnl);
 }
 
 static void rtnllink_exit(void)
 {
+	connman_rtnl_unregister(&rtnllink_rtnl);
 }
 
 CONNMAN_PLUGIN_DEFINE("rtnllink", "RTNL link detection plugin", VERSION,

commit 629ec10165691a7c5f9a7dfe3859644c280654c9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:26:30 2008 +0200

    Remove link_flags callback

diff --git a/include/rtnl.h b/include/rtnl.h
index 3af63214..395d20bc 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -43,7 +43,6 @@ struct connman_rtnl {
 					unsigned flags, unsigned change);
 	void (*dellink) (unsigned short type, int index,
 					unsigned flags, unsigned change);
-	void (*link_flags) (int index, short flags);
 };
 
 extern int connman_rtnl_register(struct connman_rtnl *rtnl);
diff --git a/src/rtnl.c b/src/rtnl.c
index 35fa54b7..f02c94b5 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -124,24 +124,6 @@ static void process_dellink(unsigned short type, int index,
 	g_static_rw_lock_reader_unlock(&rtnl_lock);
 }
 
-static void process_link_flags(int index, short flags)
-{
-	GSList *list;
-
-	DBG("idex %d", index);
-
-	g_static_rw_lock_reader_lock(&rtnl_lock);
-
-	for (list = rtnl_list; list; list = list->next) {
-		struct connman_rtnl *rtnl = list->data;
-
-		if (rtnl->link_flags)
-			rtnl->link_flags(index, flags);
-	}
-
-	g_static_rw_lock_reader_unlock(&rtnl_lock);
-}
-
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
 {
 	if (family == AF_INET) {
@@ -244,8 +226,6 @@ static void rtnl_link(struct nlmsghdr *hdr)
 			break;
 		}
 	}
-
-	process_link_flags(msg->ifi_index, msg->ifi_flags);
 }
 
 static void rtnl_newlink(struct nlmsghdr *hdr)

commit 804fc546f7da86a88979373802df9653dc6959d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:29:17 2008 +0200

    Fix return value of getlink function

diff --git a/src/rtnl.c b/src/rtnl.c
index f02c94b5..33850176 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -469,7 +469,7 @@ int connman_rtnl_send_getlink(void)
 	req.hdr.nlmsg_seq = 42;
 	req.msg.rtgen_family = AF_INET;
 
-	__connman_rtnl_send(&req, sizeof(req));
+	return __connman_rtnl_send(&req, sizeof(req));
 }
 
 int __connman_rtnl_init(void)

commit 29132f772f4ee73ebb6ae2610a36c83db2824c6b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:32:35 2008 +0200

    Add debug message to RTNL callback

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index d50f7191..fb8afb4c 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -49,6 +49,8 @@ static void ethernet_newlink(unsigned short type, int index,
 {
 	GSList *list;
 
+	DBG("index %d flags %ld change %ld", index, flags, change);
+
 	g_static_mutex_lock(&ethernet_mutex);
 
 	for (list = ethernet_list; list; list = list->next) {

commit 4c171836e1a1001d4ba7f1364c50f3f44622d9c9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:34:00 2008 +0200

    Disable link attribute parsing for now

diff --git a/src/rtnl.c b/src/rtnl.c
index 33850176..5c88cd4f 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -158,6 +158,7 @@ static inline void print_attr(struct rtattr *attr, const char *name)
 
 static void rtnl_link(struct nlmsghdr *hdr)
 {
+#if 0
 	struct ifinfomsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -226,6 +227,7 @@ static void rtnl_link(struct nlmsghdr *hdr)
 			break;
 		}
 	}
+#endif
 }
 
 static void rtnl_newlink(struct nlmsghdr *hdr)

commit 1eea67f44015142e6634e2b89593b0d587df864e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:41:46 2008 +0200

    Add option to enable/disable HAL plugin

diff --git a/configure.ac b/configure.ac
index 5857197a..1d438b17 100644
--- a/configure.ac
+++ b/configure.ac
@@ -74,7 +74,9 @@ AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 PKG_CHECK_MODULES(HAL, hal >= 0.5.8, hal_found=yes, hal_found=no)
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
-AM_CONDITIONAL(HAL, test "${hal_found}" = "yes")
+AC_ARG_ENABLE(hal, AC_HELP_STRING([--enable-hal],
+			[enable HAL plugin]), [enable_hal=${enableval}])
+AM_CONDITIONAL(HAL, test "${enable_hal}" = "yes" && test "${hal_found}" = "yes")
 
 PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, polkit_found=yes, polkit_found=no)
 AC_SUBST(POLKIT_CFLAGS)

commit ad74ad47566ed5565744d91e0f090b3c4d662c90
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:53:50 2008 +0200

    Fix spelling mistake of debug message

diff --git a/src/rtnl.c b/src/rtnl.c
index 5c88cd4f..61205b30 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -91,7 +91,7 @@ static void process_newlink(unsigned short type, int index,
 {
 	GSList *list;
 
-	DBG("idex %d", index);
+	DBG("index %d", index);
 
 	g_static_rw_lock_reader_lock(&rtnl_lock);
 
@@ -110,7 +110,7 @@ static void process_dellink(unsigned short type, int index,
 {
 	GSList *list;
 
-	DBG("idex %d", index);
+	DBG("index %d", index);
 
 	g_static_rw_lock_reader_lock(&rtnl_lock);
 

commit 86629ba675d53064d536f0516b32b09efdef8305
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 14:59:04 2008 +0200

    Increase message buffer size

diff --git a/src/rtnl.c b/src/rtnl.c
index 61205b30..1e66a9af 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -415,7 +415,7 @@ static void rtnl_message(void *buf, size_t len)
 static gboolean netlink_event(GIOChannel *chan,
 				GIOCondition cond, gpointer data)
 {
-	unsigned char buf[256];
+	unsigned char buf[4096];
 	gsize len;
 	GIOError err;
 

commit 61d0b6297c0f8e96a5ce79d03009a2d436e742f4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 15:12:01 2008 +0200

    Add really simple RTNL device detection support

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index 3d814280..abe6811e 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -28,16 +28,92 @@
 #include <connman/rtnl.h>
 #include <connman/log.h>
 
+#include "inet.h"
+
+static GStaticMutex device_mutex = G_STATIC_MUTEX_INIT;
+static GSList *device_list = NULL;
+
 static void rtnllink_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
+	struct connman_element *device;
+	enum connman_element_subtype subtype;
+	GSList *list;
+	gboolean exists = FALSE;
+	gchar *name;
+
 	DBG("index %d", index);
+
+	g_static_mutex_lock(&device_mutex);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		if (device->index == index) {
+			exists = TRUE;
+			break;
+		}
+	}
+
+	g_static_mutex_unlock(&device_mutex);
+
+	if (exists == TRUE)
+		return;
+
+	name = inet_index2name(index);
+
+	if (g_str_has_prefix(name, "eth") == TRUE)
+		subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
+	else if (g_str_has_prefix(name, "wlan") == TRUE)
+		subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+	else if (g_str_has_prefix(name, "wmx") == TRUE)
+		subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
+	else if (g_str_has_prefix(name, "bnep") == TRUE)
+		subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+	else
+		subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+
+	if (subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN) {
+		g_free(name);
+		return;
+	}
+
+	device = connman_element_create(NULL);
+	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	device->subtype = subtype;
+
+	device->index = index;
+	device->name = name;
+
+	g_static_mutex_lock(&device_mutex);
+
+	connman_element_register(device, NULL);
+	device_list = g_slist_append(device_list, device);
+
+	g_static_mutex_unlock(&device_mutex);
 }
 
 static void rtnllink_dellink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
+	GSList *list;
+
 	DBG("index %d", index);
+
+	g_static_mutex_lock(&device_mutex);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		if (device->index == index) {
+			device_list = g_slist_remove(device_list, device);
+			connman_element_unregister(device);
+			connman_element_unref(device);
+			break;
+		}
+	}
+
+	g_static_mutex_unlock(&device_mutex);
 }
 
 static struct connman_rtnl rtnllink_rtnl = {
@@ -48,12 +124,36 @@ static struct connman_rtnl rtnllink_rtnl = {
 
 static int rtnllink_init(void)
 {
-	return connman_rtnl_register(&rtnllink_rtnl);
+	int err;
+
+	err = connman_rtnl_register(&rtnllink_rtnl);
+	if (err < 0)
+		return err;
+
+	connman_rtnl_send_getlink();
+
+	return 0;
 }
 
 static void rtnllink_exit(void)
 {
+	GSList *list;
+
 	connman_rtnl_unregister(&rtnllink_rtnl);
+
+	g_static_mutex_lock(&device_mutex);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		connman_element_unregister(device);
+		connman_element_unref(device);
+	}
+
+	g_slist_free(device_list);
+	device_list = NULL;
+
+	g_static_mutex_unlock(&device_mutex);
 }
 
 CONNMAN_PLUGIN_DEFINE("rtnllink", "RTNL link detection plugin", VERSION,

commit 8a9d87cf8749c8ea0d4d763c9c63a3221be0180e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 16:26:03 2008 +0200

    Use more advanced device type detection

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index abe6811e..5ca96350 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -23,6 +23,15 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+
 #include <connman/plugin.h>
 #include <connman/element.h>
 #include <connman/rtnl.h>
@@ -36,8 +45,8 @@ static GSList *device_list = NULL;
 static void rtnllink_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
+	enum connman_element_subtype subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	struct connman_element *device;
-	enum connman_element_subtype subtype;
 	GSList *list;
 	gboolean exists = FALSE;
 	gchar *name;
@@ -62,16 +71,35 @@ static void rtnllink_newlink(unsigned short type, int index,
 
 	name = inet_index2name(index);
 
-	if (g_str_has_prefix(name, "eth") == TRUE)
-		subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
-	else if (g_str_has_prefix(name, "wlan") == TRUE)
-		subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
-	else if (g_str_has_prefix(name, "wmx") == TRUE)
-		subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
-	else if (g_str_has_prefix(name, "bnep") == TRUE)
-		subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
-	else
-		subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+	if (type == ARPHRD_ETHER) {
+		char bridge_path[PATH_MAX], wimax_path[PATH_MAX];
+		struct stat st;
+		struct iwreq iwr;
+		int sk;
+
+		snprintf(bridge_path, PATH_MAX,
+					"/sys/class/net/%s/bridge", name);
+		snprintf(wimax_path, PATH_MAX,
+					"/sys/class/net/%s/wimax", name);
+
+		memset(&iwr, 0, sizeof(iwr));
+		strncpy(iwr.ifr_ifrn.ifrn_name, name, IFNAMSIZ);
+
+		sk = socket(PF_INET, SOCK_DGRAM, 0);
+
+		if (g_str_has_prefix(name, "bnep") == TRUE)
+			subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
+			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
+			subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
+		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
+			subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+		else
+			subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
+
+		close(sk);
+	}
 
 	if (subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN) {
 		g_free(name);

commit 2be75e86beed6bee061266354854dd5bd5d0204b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 17:13:42 2008 +0200

    Add method and signal for property handling

diff --git a/src/manager.c b/src/manager.c
index 27f6fc5a..d4098dae 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,6 +27,58 @@
 
 #include "connman.h"
 
+static void append_elements(DBusMessageIter *dict)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "Elements";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_UNKNOWN, &iter);
+
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	append_elements(&dict);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
 static DBusMessage *register_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -124,17 +176,19 @@ static DBusMessage *list_elements(DBusConnection *conn,
 }
 
 static GDBusMethodTable manager_methods[] = {
-	{ "RegisterAgent",   "o", "",   register_agent   },
-	{ "UnregisterAgent", "o", "",   unregister_agent },
-	{ "ListProfiles",    "",  "ao", list_profiles    },
-	{ "ListElements",    "",  "ao", list_elements    },
+	{ "GetProperties",   "",  "a{sv}", get_properties   },
+	{ "RegisterAgent",   "o", "",      register_agent   },
+	{ "UnregisterAgent", "o", "",      unregister_agent },
+	{ "ListProfiles",    "",  "ao",    list_profiles    },
+	{ "ListElements",    "",  "ao",    list_elements    },
 	{ },
 };
 
 static GDBusSignalTable manager_signals[] = {
-	{ "ElementAdded",   "o" },
-	{ "ElementUpdated", "o" },
-	{ "ElementRemoved", "o" },
+	{ "PropertyChanged", "sv" },
+	{ "ElementAdded",    "o"  },
+	{ "ElementUpdated",  "o"  },
+	{ "ElementRemoved",  "o"  },
 	{ },
 };
 

commit a8f986749e6ae18eadc1a681fc9d9b534200e559
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 17:39:39 2008 +0200

    Use dynamic linking loader directly

diff --git a/configure.ac b/configure.ac
index 1d438b17..11078965 100644
--- a/configure.ac
+++ b/configure.ac
@@ -48,6 +48,9 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 AC_PATH_PROG(DHCLIENT, [dhclient], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
 
+AC_CHECK_LIB(dl, dlopen, dummy=yes,
+			AC_MSG_ERROR(dynamic linking loader is required))
+
 PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
 				AC_MSG_ERROR(glib is required))
 AC_SUBST(GLIB_CFLAGS)
@@ -58,11 +61,6 @@ PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
 AC_SUBST(GTHREAD_CFLAGS)
 AC_SUBST(GTHREAD_LIBS)
 
-PKG_CHECK_MODULES(GMODULE, gmodule-2.0, dummy=yes,
-				AC_MSG_ERROR(gmodule is required))
-AC_SUBST(GMODULE_CFLAGS)
-AC_SUBST(GMODULE_LIBS)
-
 PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(libdbus is required))
 AC_SUBST(DBUS_CFLAGS)
diff --git a/src/Makefile.am b/src/Makefile.am
index 9c12a8b6..e5772564 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -14,7 +14,7 @@ sbin_PROGRAMS = connmand
 connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
 		element.c security.c storage.c manager.c agent.c rtnl.c
 
-connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GMODULE_LIBS@ @GTHREAD_LIBS@
+connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
 
 connmand_LDFLAGS = -Wl,--version-script=connman.ver
 
@@ -32,7 +32,7 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GTHREAD_CFLAGS@ @GMODULE_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
+AM_CFLAGS = @GTHREAD_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
 			-DSTATEDIR=\""$(statedir)"\" \
 			-DSTORAGEDIR=\""$(storagedir)\"" \
 			-DPLUGINDIR=\""$(plugindir)"\"
diff --git a/src/plugin.c b/src/plugin.c
index 12ed917d..7cbd72b9 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -23,21 +23,20 @@
 #include <config.h>
 #endif
 
-#include <dbus/dbus.h>
+#include <dlfcn.h>
 
 #include <glib.h>
-#include <gmodule.h>
 
 #include "connman.h"
 
 static GSList *plugins = NULL;
 
 struct connman_plugin {
-	GModule *module;
+	void *handle;
 	struct connman_plugin_desc *desc;
 };
 
-static gboolean add_plugin(GModule *module, struct connman_plugin_desc *desc)
+static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 {
 	struct connman_plugin *plugin;
 
@@ -45,7 +44,7 @@ static gboolean add_plugin(GModule *module, struct connman_plugin_desc *desc)
 	if (plugin == NULL)
 		return FALSE;
 
-	plugin->module = module;
+	plugin->handle = handle;
 	plugin->desc = desc;
 
 	plugins = g_slist_append(plugins, plugin);
@@ -55,65 +54,53 @@ static gboolean add_plugin(GModule *module, struct connman_plugin_desc *desc)
 	return TRUE;
 }
 
-static void load_plugins(const gchar *path)
+int __connman_plugin_init(void)
 {
 	GDir *dir;
 	const gchar *file;
 	gchar *filename;
 
-	dir = g_dir_open(path, 0, NULL);
+	DBG("");
+
+	dir = g_dir_open(PLUGINDIR, 0, NULL);
 	if (dir != NULL) {
 		while ((file = g_dir_read_name(dir)) != NULL) {
-			GModule *module;
+			void *handle;
 			struct connman_plugin_desc *desc;
 
 			if (g_str_has_prefix(file, "lib") == TRUE ||
 					g_str_has_suffix(file, ".so") == FALSE)
 				continue;
 
-			filename = g_build_filename(path, file, NULL);
+			filename = g_build_filename(PLUGINDIR, file, NULL);
 
-			module = g_module_open(filename, 0);
-			if (module == NULL) {
+			handle = dlopen(filename, RTLD_LAZY);
+			if (handle == NULL) {
 				g_warning("Can't load %s: %s", filename,
-							g_module_error());
+								dlerror());
 				continue;
 			}
 
 			g_free(filename);
 
-			DBG("%s", g_module_name(module));
-
-			if (g_module_symbol(module, "connman_plugin_desc",
-						(gpointer) &desc) == FALSE) {
+			desc = dlsym(handle, "connman_plugin_desc");
+			if (desc == NULL) {
 				g_warning("Can't load symbol");
-				g_module_close(module);
+				dlclose(handle);
 				continue;
 			}
 
-			if (desc == NULL || desc->init == NULL) {
-				g_module_close(module);
+			if (desc->init == NULL) {
+				dlclose(handle);
 				continue;
 			}
 
-			if (add_plugin(module, desc) == FALSE)
-				g_module_close(module);
+			if (add_plugin(handle, desc) == FALSE)
+				dlclose(handle);
 		}
 
 		g_dir_close(dir);
 	}
-}
-
-int __connman_plugin_init(void)
-{
-	DBG("");
-
-	if (g_module_supported() == FALSE) {
-		g_warning("Modules not supported: %s", g_module_error());
-		return FALSE;
-	}
-
-	load_plugins(PLUGINDIR);
 
 	return 0;
 }
@@ -127,12 +114,10 @@ void __connman_plugin_cleanup(void)
 	for (list = plugins; list; list = list->next) {
 		struct connman_plugin *plugin = list->data;
 
-		DBG("%s", g_module_name(plugin->module));
-
 		if (plugin->desc->exit)
 			plugin->desc->exit();
 
-		g_module_close(plugin->module);
+		dlclose(plugin->handle);
 
 		g_free(plugin);
 	}

commit 2ad81f8d0508e33cbace70a591d5fdd96b21c5e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 17:54:21 2008 +0200

    Add dynamic export linker flag

diff --git a/src/Makefile.am b/src/Makefile.am
index e5772564..52082cd1 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -16,7 +16,7 @@ connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
 
-connmand_LDFLAGS = -Wl,--version-script=connman.ver
+connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
 connmand_DEPENDENCIES = connman.ver
 

commit 0af74f53a3dfd5d4aa93326d5900b8562b019687
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 17:55:52 2008 +0200

    Force symbol resolving and fix memory leak

diff --git a/src/plugin.c b/src/plugin.c
index 7cbd72b9..0d90fd9f 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -74,10 +74,11 @@ int __connman_plugin_init(void)
 
 			filename = g_build_filename(PLUGINDIR, file, NULL);
 
-			handle = dlopen(filename, RTLD_LAZY);
+			handle = dlopen(filename, RTLD_NOW);
 			if (handle == NULL) {
 				g_warning("Can't load %s: %s", filename,
 								dlerror());
+				g_free(filename);
 				continue;
 			}
 
@@ -85,7 +86,7 @@ int __connman_plugin_init(void)
 
 			desc = dlsym(handle, "connman_plugin_desc");
 			if (desc == NULL) {
-				g_warning("Can't load symbol");
+				g_warning("Can't load symbol: %s", dlerror());
 				dlclose(handle);
 				continue;
 			}

commit 4fe64c1ea26c8d0d5c2d51c495a83824613cf2e4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 14 18:05:16 2008 +0200

    Add first step towards providing device abstraction

diff --git a/include/Makefile.am b/include/Makefile.am
index 76057be1..74a8cb78 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -2,7 +2,7 @@
 includedir = @includedir@/connman
 
 include_HEADERS = log.h plugin.h security.h driver.h element.h property.h \
-								rtnl.h dbus.h
+							device.h rtnl.h dbus.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/device.h b/include/device.h
new file mode 100644
index 00000000..09d28561
--- /dev/null
+++ b/include/device.h
@@ -0,0 +1,83 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_DEVICE_H
+#define __CONNMAN_DEVICE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <connman/element.h>
+
+/**
+ * SECTION:driver
+ * @title: Driver premitives
+ * @short_description: Functions for registering drivers
+ */
+
+enum connman_device_type {
+	CONNMAN_DEVICE_TYPE_UNKNOWN   = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN,
+	CONNMAN_DEVICE_TYPE_FAKE      = CONNMAN_ELEMENT_SUBTYPE_FAKE,
+	CONNMAN_DEVICE_TYPE_ETHERNET  = CONNMAN_ELEMENT_SUBTYPE_ETHERNET,
+	CONNMAN_DEVICE_TYPE_WIFI      = CONNMAN_ELEMENT_SUBTYPE_WIFI,
+	CONNMAN_DEVICE_TYPE_WIMAX     = CONNMAN_ELEMENT_SUBTYPE_WIMAX,
+	CONNMAN_DEVICE_TYPE_MODEM     = CONNMAN_ELEMENT_SUBTYPE_MODEM,
+	CONNMAN_DEVICE_TYPE_BLUETOOTH = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
+};
+
+enum connman_device_state {
+	CONNMAN_DEVICE_STATE_UNKNOWN = 0,
+	CONNMAN_DEVICE_STATE_OFF     = 1,
+};
+
+struct connman_device_driver;
+
+struct connman_device {
+	struct connman_element *element;
+	enum connman_device_state state;
+
+	struct connman_device_driver *driver;
+	void *driver_data;
+
+	GSList *networks;
+};
+
+extern int connman_device_set_enabled(struct connman_device *device,
+							gboolean enabled);
+
+struct connman_device_driver {
+	const char *name;
+	enum connman_device_type type;
+	int priority;
+	int (*probe) (struct connman_device *device);
+	void (*remove) (struct connman_device *device);
+	int (*scan) (struct connman_device *device);
+};
+
+extern int connman_device_driver_register(struct connman_device_driver *driver);
+extern void connman_device_driver_unregister(struct connman_device_driver *driver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_DEVICE_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 52082cd1..afa1ce91 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,7 +12,8 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
-		element.c security.c storage.c manager.c agent.c rtnl.c
+				element.c device.c security.c storage.c \
+						manager.c agent.c rtnl.c
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
 
diff --git a/src/device.c b/src/device.c
new file mode 100644
index 00000000..6b73438a
--- /dev/null
+++ b/src/device.c
@@ -0,0 +1,152 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+
+#include "connman.h"
+
+static GSList *driver_list = NULL;
+
+static gboolean match_driver(struct connman_device *device,
+					struct connman_device_driver *driver)
+{
+	if (device->element->subtype == driver->type ||
+			driver->type == CONNMAN_DEVICE_TYPE_UNKNOWN)
+		return TRUE;
+
+	return FALSE;
+}
+
+static int device_probe(struct connman_element *element)
+{
+	struct connman_device *device;
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	device = g_try_new0(struct connman_device, 1);
+	if (device == NULL)
+		return -ENOMEM;
+
+	device->element = element;
+
+	for (list = driver_list; list; list = list->next) {
+		struct connman_device_driver *driver = list->data;
+
+		if (match_driver(device, driver) == FALSE)
+			continue;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		if (driver->probe(device) == 0) {
+			device->driver = driver;
+			connman_element_set_data(element, device);
+			return 0;
+		}
+	}
+
+	g_free(device);
+
+	return -ENODEV;
+}
+
+static int device_remove(struct connman_element *element)
+{
+	struct connman_device *device = connman_element_get_data(element);
+
+	DBG("element %p name %s", element, element->name);
+
+	if (device->driver && device->driver->remove)
+		device->driver->remove(device);
+
+	connman_element_set_data(element, NULL);
+
+	g_free(device);
+
+	return 0;
+}
+
+static struct connman_driver device_driver = {
+	.name		= "device",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
+	.probe		= device_probe,
+	.remove		= device_remove,
+};
+
+int __connman_device_init(void)
+{
+	DBG("");
+
+	return connman_driver_register(&device_driver);
+}
+
+void __connman_device_cleanup(void)
+{
+	DBG("");
+
+	connman_driver_unregister(&device_driver);
+}
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_device_driver *driver1 = a;
+	const struct connman_device_driver *driver2 = b;
+
+	return driver2->priority - driver1->priority;
+}
+
+/**
+ * connman_device_driver_register:
+ * @driver: device driver definition
+ *
+ * Register a new device driver
+ *
+ * Returns: %0 on success
+ */
+int connman_device_driver_register(struct connman_device_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	driver_list = g_slist_insert_sorted(driver_list, driver,
+							compare_priority);
+
+	__connman_driver_rescan(&device_driver);
+
+	return 0;
+}
+
+/**
+ * connman_device_driver_unregister:
+ * @driver: device driver definition
+ *
+ * Remove a previously registered device driver
+ */
+void connman_device_driver_unregister(struct connman_device_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	driver_list = g_slist_remove(driver_list, driver);
+}

commit f99bd377e6e13d163d881b617b5e419658a42f2f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 21:34:40 2008 +0200

    Add string conversion for fake subtype

diff --git a/src/element.c b/src/element.c
index d3b2cc5c..c045c692 100644
--- a/src/element.c
+++ b/src/element.c
@@ -122,6 +122,8 @@ static const char *subtype2string(enum connman_element_subtype type)
 	switch (type) {
 	case CONNMAN_ELEMENT_SUBTYPE_UNKNOWN:
 		return "unknown";
+	case CONNMAN_ELEMENT_SUBTYPE_FAKE:
+		return "fake";
 	case CONNMAN_ELEMENT_SUBTYPE_NETWORK:
 		return "network";
 	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:

commit eae556dcaff92fc0e7c5915d364839c0c3e52a40
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 21:36:00 2008 +0200

    Add init and cleanup calls for device abstraction

diff --git a/src/element.c b/src/element.c
index c045c692..78a550e6 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1229,6 +1229,8 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 	thread_unregister_children = g_thread_pool_new(unregister_children,
 							NULL, 1, FALSE, NULL);
 
+	__connman_device_init();
+
 	return 0;
 }
 
@@ -1266,6 +1268,8 @@ void __connman_element_cleanup(void)
 {
 	DBG("");
 
+	__connman_device_cleanup();
+
 	g_thread_pool_free(thread_register, TRUE, TRUE);
 	thread_register = NULL;
 

commit 9508e2afee0328fcf3a11775555bb0ffe1b1d3e4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 21:42:40 2008 +0200

    Add set_enabled and rescan funtions

diff --git a/include/element.h b/include/element.h
index 4669332e..9054c833 100644
--- a/include/element.h
+++ b/include/element.h
@@ -128,6 +128,9 @@ extern void connman_element_unregister(struct connman_element *element);
 extern void connman_element_unregister_children(struct connman_element *element);
 extern void connman_element_update(struct connman_element *element);
 
+extern int connman_element_set_enabled(struct connman_element *element,
+							gboolean enabled);
+
 static inline void *connman_element_get_data(struct connman_element *element)
 {
 	return element->driver_data;
diff --git a/src/connman.h b/src/connman.h
index 8b1e6fd0..57f97bf4 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -62,6 +62,9 @@ void __connman_plugin_cleanup(void);
 int __connman_security_check_privileges(DBusMessage *message);
 
 #include <connman/driver.h>
+
+void __connman_driver_rescan(struct connman_driver *driver);
+
 #include <connman/element.h>
 
 int __connman_element_init(DBusConnection *conn, const char *device);
@@ -76,6 +79,11 @@ const char *__connman_element_subtype2string(enum connman_element_subtype type);
 int __connman_element_load(struct connman_element *element);
 int __connman_element_store(struct connman_element *element);
 
+#include <connman/device.h>
+
+int __connman_device_init(void);
+void __connman_device_cleanup(void);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/element.c b/src/element.c
index 78a550e6..dd78c698 100644
--- a/src/element.c
+++ b/src/element.c
@@ -518,6 +518,22 @@ static gboolean probe_driver(GNode *node, gpointer data)
 	return FALSE;
 }
 
+void __connman_driver_rescan(struct connman_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	if (!driver->probe)
+		return;
+
+	g_static_rw_lock_writer_lock(&element_lock);
+
+	if (element_root != NULL)
+		g_node_traverse(element_root, G_PRE_ORDER,
+				G_TRAVERSE_ALL, -1, probe_driver, driver);
+
+	g_static_rw_lock_writer_unlock(&element_lock);
+}
+
 /**
  * connman_driver_register:
  * @driver: driver definition
@@ -1053,6 +1069,19 @@ void connman_element_update(struct connman_element *element)
 	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
+int connman_element_set_enabled(struct connman_element *element,
+							gboolean enabled)
+{
+	if (element->enabled == enabled)
+		return 0;
+
+	element->enabled = enabled;
+
+	connman_element_update(element);
+
+	return 0;
+}
+
 static void register_element(gpointer data, gpointer user_data)
 {
 	struct connman_element *element = data;

commit a95cc3309444678d795e2b29d402c6b0d3b1f059
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 21:43:30 2008 +0200

    Fix function declaration

diff --git a/src/device.c b/src/device.c
index 6b73438a..0e2cf59f 100644
--- a/src/device.c
+++ b/src/device.c
@@ -72,7 +72,7 @@ static int device_probe(struct connman_element *element)
 	return -ENODEV;
 }
 
-static int device_remove(struct connman_element *element)
+static void device_remove(struct connman_element *element)
 {
 	struct connman_device *device = connman_element_get_data(element);
 
@@ -84,8 +84,6 @@ static int device_remove(struct connman_element *element)
 	connman_element_set_data(element, NULL);
 
 	g_free(device);
-
-	return 0;
 }
 
 static struct connman_driver device_driver = {

commit a0035fd5cfe3b29d6098a0310642a59457979a63
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 21:45:56 2008 +0200

    Add missing function declaration

diff --git a/include/element.h b/include/element.h
index 9054c833..b731d44d 100644
--- a/include/element.h
+++ b/include/element.h
@@ -128,6 +128,9 @@ extern void connman_element_unregister(struct connman_element *element);
 extern void connman_element_unregister_children(struct connman_element *element);
 extern void connman_element_update(struct connman_element *element);
 
+extern int connman_element_set_enabled(struct connman_element *element,
+							gboolean enabled);
+
 extern int connman_element_set_enabled(struct connman_element *element,
 							gboolean enabled);
 

commit cf0a9a48df4db17ea3801aa15e8be9d4735a01e4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 22:18:27 2008 +0200

    Return when enable or disable callbacks fail

diff --git a/src/element.c b/src/element.c
index dd78c698..fc4b7b72 100644
--- a/src/element.c
+++ b/src/element.c
@@ -383,7 +383,8 @@ static DBusMessage *do_enable(DBusConnection *conn,
 
 	if (element->driver && element->driver->enable) {
 		DBG("Calling enable callback");
-		element->driver->enable(element);
+		if (element->driver->enable(element) < 0)
+			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 	}
 
 	element->enabled = TRUE;
@@ -408,7 +409,8 @@ static DBusMessage *do_disable(DBusConnection *conn,
 
 	if (element->driver && element->driver->disable) {
 		DBG("Calling disable callback");
-		element->driver->disable(element);
+		if (element->driver->disable(element) < 0)
+			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 	}
 
 	element->enabled = FALSE;

commit e22d8671568564ba414799f9cd80ae0781fe4a2d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 15 22:34:10 2008 +0200

    Compile with inet.c and inet.h

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index a19236cc..d5ececbc 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -24,7 +24,7 @@ resolvconf_la_SOURCES = resolvconf.c inet.h inet.c
 
 resolvfile_la_SOURCES = resolvfile.c
 
-rtnllink_la_SOURCES = rtnllink.c
+rtnllink_la_SOURCES = rtnllink.c inet.h inet.c
 
 if HAL
 plugin_LTLIBRARIES += hal.la

commit 950735cef1c48c77a52eabadee8f905388388c87
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 07:29:30 2008 +0200

    Add initial device capabilities defines

diff --git a/include/device.h b/include/device.h
index 09d28561..994d997b 100644
--- a/include/device.h
+++ b/include/device.h
@@ -44,6 +44,10 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
 };
 
+enum connman_device_capabilities {
+	CONNMAN_DEVICE_CAPABILITY_SCANNING = (1 << 0),
+};
+
 enum connman_device_state {
 	CONNMAN_DEVICE_STATE_UNKNOWN = 0,
 	CONNMAN_DEVICE_STATE_OFF     = 1,
@@ -53,6 +57,7 @@ struct connman_device_driver;
 
 struct connman_device {
 	struct connman_element *element;
+	unsigned long capabilities;
 	enum connman_device_state state;
 
 	struct connman_device_driver *driver;

commit 759c9a71c370b0a83d7d61d470a9924a0b16ce73
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 07:37:28 2008 +0200

    Add element type for profiles

diff --git a/include/element.h b/include/element.h
index b731d44d..29f1b3f5 100644
--- a/include/element.h
+++ b/include/element.h
@@ -47,14 +47,15 @@ enum connman_element_state {
 enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_UNKNOWN    = 0,
 	CONNMAN_ELEMENT_TYPE_ROOT       = 1,
-	CONNMAN_ELEMENT_TYPE_DEVICE     = 2,
-	CONNMAN_ELEMENT_TYPE_NETWORK    = 3,
-	CONNMAN_ELEMENT_TYPE_IPV4       = 4,
-	CONNMAN_ELEMENT_TYPE_IPV6       = 5,
-	CONNMAN_ELEMENT_TYPE_DHCP       = 6,
-	CONNMAN_ELEMENT_TYPE_BOOTP      = 7,
-	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 8,
-	CONNMAN_ELEMENT_TYPE_RESOLVER   = 9,
+	CONNMAN_ELEMENT_TYPE_PROFILE    = 2,
+	CONNMAN_ELEMENT_TYPE_DEVICE     = 3,
+	CONNMAN_ELEMENT_TYPE_NETWORK    = 4,
+	CONNMAN_ELEMENT_TYPE_IPV4       = 5,
+	CONNMAN_ELEMENT_TYPE_IPV6       = 6,
+	CONNMAN_ELEMENT_TYPE_DHCP       = 7,
+	CONNMAN_ELEMENT_TYPE_BOOTP      = 8,
+	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 9,
+	CONNMAN_ELEMENT_TYPE_RESOLVER   = 10,
 
 	CONNMAN_ELEMENT_TYPE_INTERNET   = 42,
 };
diff --git a/src/element.c b/src/element.c
index fc4b7b72..428a3e13 100644
--- a/src/element.c
+++ b/src/element.c
@@ -94,6 +94,8 @@ static const char *type2string(enum connman_element_type type)
 		return "unknown";
 	case CONNMAN_ELEMENT_TYPE_ROOT:
 		return "root";
+	case CONNMAN_ELEMENT_TYPE_PROFILE:
+		return "profile";
 	case CONNMAN_ELEMENT_TYPE_DEVICE:
 		return "device";
 	case CONNMAN_ELEMENT_TYPE_NETWORK:

commit 5bca005196d392e3bf1802f359344db5cf76fccc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 07:52:06 2008 +0200

    Assign supplicant filter only once

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b0d74c6a..8944d436 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -38,7 +38,6 @@
 #define IEEE80211_CAP_PRIVACY   0x0010
 
 struct supplicant_task {
-	DBusConnection *conn;
 	int ifindex;
 	gchar *ifname;
 	struct connman_element *element;
@@ -52,6 +51,8 @@ struct supplicant_task {
 static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
 static GSList *task_list = NULL;
 
+static DBusConnection *connection;
+
 static struct supplicant_task *find_task_by_index(int index)
 {
 	GSList *list;
@@ -66,6 +67,20 @@ static struct supplicant_task *find_task_by_index(int index)
 	return NULL;
 }
 
+static struct supplicant_task *find_task_by_path(const char *path)
+{
+	GSList *list;
+
+	for (list = task_list; list; list = list->next) {
+		struct supplicant_task *task = list->data;
+
+		if (g_str_equal(task->path, path) == TRUE)
+			return task;
+	}
+
+	return NULL;
+}
+
 static int get_interface(struct supplicant_task *task)
 {
 	DBusMessage *message, *reply;
@@ -84,7 +99,7 @@ static int get_interface(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -139,7 +154,7 @@ static int add_interface(struct supplicant_task *task)
 	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
 							DBUS_TYPE_INVALID);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -196,7 +211,7 @@ static int remove_interface(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -233,7 +248,7 @@ static int set_ap_scan(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -270,7 +285,7 @@ static int add_network(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -326,7 +341,7 @@ static int remove_network(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -368,7 +383,7 @@ static int select_network(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -404,7 +419,7 @@ static int enable_network(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -440,7 +455,7 @@ static int disable_network(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -529,7 +544,7 @@ static int set_network(struct supplicant_task *task, const char *network,
 
 	dbus_error_init(&error);
 
-	reply = dbus_connection_send_with_reply_and_block(task->conn,
+	reply = dbus_connection_send_with_reply_and_block(connection,
 							message, -1, &error);
 	if (reply == NULL) {
 		if (dbus_error_is_set(&error) == TRUE) {
@@ -560,7 +575,7 @@ static int initiate_scan(struct supplicant_task *task)
 	if (message == NULL)
 		return -ENOMEM;
 
-	if (dbus_connection_send_with_reply(task->conn, message,
+	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to initiate scan");
 		dbus_message_unref(message);
@@ -692,7 +707,7 @@ static int get_network_properties(struct supplicant_task *task,
 	if (message == NULL)
 		return -ENOMEM;
 
-	if (dbus_connection_send_with_reply(task->conn, message,
+	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to get network properties");
 		dbus_message_unref(message);
@@ -754,7 +769,7 @@ static int scan_results_available(struct supplicant_task *task)
 	if (message == NULL)
 		return -ENOMEM;
 
-	if (dbus_connection_send_with_reply(task->conn, message,
+	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to request scan result");
 		dbus_message_unref(message);
@@ -823,8 +838,8 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 static DBusHandlerResult supplicant_filter(DBusConnection *conn,
 						DBusMessage *msg, void *data)
 {
-	struct supplicant_task *task = data;
-	const char *member;
+	struct supplicant_task *task;
+	const char *member, *path;
 
 	if (dbus_message_has_interface(msg,
 				SUPPLICANT_INTF ".Interface") == FALSE)
@@ -834,6 +849,14 @@ static DBusHandlerResult supplicant_filter(DBusConnection *conn,
 	if (member == NULL)
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
+	path = dbus_message_get_path(msg);
+	if (path == NULL)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+	task = find_task_by_path(path);
+	if (task == NULL)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
 	DBG("task %p member %s", task, member);
 
 	if (g_str_equal(member, "ScanResultsAvailable") == TRUE)
@@ -849,10 +872,6 @@ static int add_filter(struct supplicant_task *task)
 	DBusError error;
 	gchar *filter;
 
-	if (dbus_connection_add_filter(task->conn,
-				supplicant_filter, task, NULL) == FALSE)
-		return -EIO;
-
 	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
 						SUPPLICANT_INTF, task->path);
 
@@ -860,7 +879,7 @@ static int add_filter(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	dbus_bus_add_match(task->conn, filter, &error);
+	dbus_bus_add_match(connection, filter, &error);
 
 	g_free(filter);
 
@@ -884,7 +903,7 @@ static int remove_filter(struct supplicant_task *task)
 
 	dbus_error_init(&error);
 
-	dbus_bus_add_match(task->conn, filter, &error);
+	dbus_bus_remove_match(connection, filter, &error);
 
 	g_free(filter);
 
@@ -893,8 +912,6 @@ static int remove_filter(struct supplicant_task *task)
 		dbus_error_free(&error);
 	}
 
-	dbus_connection_remove_filter(task->conn, supplicant_filter, task);
-
 	return 0;
 }
 
@@ -920,12 +937,6 @@ int __supplicant_start(struct connman_element *element,
 		return -ENOMEM;
 	}
 
-	task->conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
-	if (task->conn == NULL) {
-		g_free(task);
-		return -EIO;
-	}
-
 	task->created = FALSE;
 	task->state = STATE_INACTIVE;
 
@@ -971,8 +982,6 @@ int __supplicant_stop(struct connman_element *element)
 
 	remove_interface(task);
 
-	dbus_connection_unref(task->conn);
-
 	g_free(task->ifname);
 	g_free(task->path);
 	g_free(task);
@@ -1011,6 +1020,7 @@ int __supplicant_scan(struct connman_element *element)
 int __supplicant_connect(struct connman_element *element, const char *ssid)
 {
 	struct supplicant_task *task;
+	const char *passphrase = NULL;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -1023,7 +1033,7 @@ int __supplicant_connect(struct connman_element *element, const char *ssid)
 	select_network(task);
 	disable_network(task);
 
-	set_network(task, ssid, NULL);
+	set_network(task, ssid, passphrase);
 
 	enable_network(task);
 
@@ -1046,3 +1056,29 @@ int __supplicant_disconnect(struct connman_element *element)
 
 	return 0;
 }
+
+int __supplicant_init(void)
+{
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (connection == NULL)
+		return -EIO;
+
+	if (dbus_connection_add_filter(connection,
+				supplicant_filter, NULL, NULL) == FALSE) {
+		dbus_connection_unref(connection);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+void __supplicant_exit(void)
+{
+	if (connection == NULL)
+		return;
+
+	dbus_connection_remove_filter(connection, supplicant_filter, NULL);
+
+	dbus_connection_unref(connection);
+	connection = NULL;
+}
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 9b4f6eb4..20552e6a 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -52,6 +52,9 @@ struct supplicant_callback {
 					struct supplicant_network *network);
 };
 
+int __supplicant_init(void);
+void __supplicant_exit(void);
+
 int __supplicant_start(struct connman_element *element,
 					struct supplicant_callback *callback);
 int __supplicant_stop(struct connman_element *element);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index f4c33737..6be82b44 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -291,13 +291,20 @@ static int wifi_init(void)
 {
 	int err;
 
-	err = connman_driver_register(&network_driver);
+	err = __supplicant_init();
 	if (err < 0)
 		return err;
 
+	err = connman_driver_register(&network_driver);
+	if (err < 0) {
+		__supplicant_exit();
+		return err;
+	}
+
 	err = connman_driver_register(&wifi_driver);
 	if (err < 0) {
 		connman_driver_unregister(&network_driver);
+		__supplicant_exit();
 		return err;
 	}
 
@@ -308,6 +315,8 @@ static void wifi_exit(void)
 {
 	connman_driver_unregister(&network_driver);
 	connman_driver_unregister(&wifi_driver);
+
+	__supplicant_exit();
 }
 
 CONNMAN_PLUGIN_DEFINE("wifi", "WiFi interface plugin", VERSION,

commit f2edff0115078824f87fd647e8cb05c0628caaf2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 08:14:31 2008 +0200

    Remove obsolete DHCP element handling

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 6be82b44..1dcd135d 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -32,8 +32,6 @@
 
 #include "supplicant.h"
 
-static struct connman_element *dhcp_element = NULL;
-
 static int network_probe(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
@@ -50,19 +48,14 @@ static int network_enable(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
-	if (dhcp_element != NULL) {
-		connman_element_unregister(dhcp_element);
-		dhcp_element = NULL;
-	}
-
-	__supplicant_disconnect(element);
-
 	element->enabled = FALSE;
-
 	connman_element_update(element);
 
-	g_free(element->parent->network.identifier);
-	element->parent->network.identifier = element->network.identifier;
+	if (element->parent) {
+		g_free(element->parent->network.identifier);
+		element->parent->network.identifier =
+					g_strdup(element->network.identifier);
+	}
 
 	if (__supplicant_connect(element, element->network.identifier) < 0)
 		connman_error("Failed to initiate connect");
@@ -74,15 +67,11 @@ static int network_disable(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
-	if (dhcp_element != NULL) {
-		connman_element_unregister(dhcp_element);
-		dhcp_element = NULL;
-	}
+	connman_element_unregister_children(element);
 
 	__supplicant_disconnect(element);
 
 	element->enabled = FALSE;
-
 	connman_element_update(element);
 
 	return 0;
@@ -145,10 +134,7 @@ static void state_change(struct connman_element *parent,
 		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
 		dhcp->index = element->index;
 
-		dhcp_element = dhcp;
-
 		element->enabled = TRUE;
-
 		connman_element_update(element);
 
 		connman_element_register(dhcp, element);

commit 0dff808200acbee5ce5761b4ed57615a6ae1554d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 18:49:52 2008 +0200

    Add more property helpers

diff --git a/include/element.h b/include/element.h
index 29f1b3f5..d2f13abe 100644
--- a/include/element.h
+++ b/include/element.h
@@ -115,6 +115,8 @@ extern void connman_element_unref(struct connman_element *element);
 
 extern int connman_element_add_static_property(struct connman_element *element,
 				const char *name, int type, const void *value);
+extern int connman_element_add_static_array_property(struct connman_element *element,
+			const char *name, int type, const void *value, int len);
 extern int connman_element_define_properties(struct connman_element *element, ...);
 extern int connman_element_create_property(struct connman_element *element,
 						const char *name, int type);
@@ -122,6 +124,12 @@ extern int connman_element_set_property(struct connman_element *element,
 				enum connman_property_id id, const void *value);
 extern int connman_element_get_value(struct connman_element *element,
 				enum connman_property_id id, void *value);
+extern gboolean connman_element_get_static_property(struct connman_element *element,
+						const char *name, void *value);
+extern gboolean connman_element_get_static_array_property(struct connman_element *element,
+					const char *name, void *value, int *len);
+extern gboolean connman_element_match_static_property(struct connman_element *element,
+					const char *name, const void *value);
 
 extern int connman_element_register(struct connman_element *element,
 					struct connman_element *parent);
diff --git a/include/property.h b/include/property.h
index 14198bef..b8c86c9c 100644
--- a/include/property.h
+++ b/include/property.h
@@ -57,7 +57,9 @@ struct connman_property {
 	enum connman_property_id id;
 	char *name;
 	int type;
+	int subtype;
 	void *value;
+	int size;
 };
 
 #ifdef __cplusplus
diff --git a/src/element.c b/src/element.c
index 428a3e13..83a9e9e3 100644
--- a/src/element.c
+++ b/src/element.c
@@ -25,6 +25,7 @@
 
 #include <errno.h>
 #include <stdarg.h>
+#include <string.h>
 
 #include <glib.h>
 #include <gdbus.h>
@@ -143,6 +144,39 @@ static const char *subtype2string(enum connman_element_subtype type)
 	return NULL;
 }
 
+static void append_array(DBusMessageIter *dict,
+				const char *key, int type, void *val, int len)
+{
+	DBusMessageIter entry, value, array;
+	const char *variant_sig, *array_sig;
+
+	switch (type) {
+	case DBUS_TYPE_BYTE:
+		variant_sig = DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_BYTE_AS_STRING;
+		array_sig = DBUS_TYPE_BYTE_AS_STRING;
+		break;
+	default:
+		return;
+	}
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							variant_sig, &value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+							array_sig, &array);
+	dbus_message_iter_append_fixed_array(&array, type, val, len);
+	dbus_message_iter_close_container(&value, &array);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
 static void append_entry(DBusMessageIter *dict,
 				const char *key, int type, void *val)
 {
@@ -189,7 +223,12 @@ static void append_property(DBusMessageIter *dict,
 	if (property->value == NULL)
 		return;
 
-	append_entry(dict, property->name, property->type, &property->value);
+	if (property->type == DBUS_TYPE_ARRAY)
+		append_array(dict, property->name, property->subtype,
+					&property->value, property->size);
+	else
+		append_entry(dict, property->name, property->type,
+							&property->value);
 }
 
 static DBusMessage *get_properties(DBusConnection *conn,
@@ -233,12 +272,6 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		append_entry(&dict, "Priority",
 				DBUS_TYPE_UINT16, &element->priority);
 
-#if 0
-	if (element->network.identifier != NULL)
-		append_entry(&dict, "Identifier",
-				DBUS_TYPE_STRING, &element->network.identifier);
-#endif
-
 	if (element->ipv4.address != NULL)
 		append_entry(&dict, "IPv4.Address",
 				DBUS_TYPE_STRING, &element->ipv4.address);
@@ -667,6 +700,9 @@ static void free_properties(struct connman_element *element)
 		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)) {
 			if (property->type == DBUS_TYPE_STRING)
 				g_free(property->value);
+			if (property->type == DBUS_TYPE_ARRAY &&
+					property->subtype == DBUS_TYPE_BYTE)
+				g_free(property->value);
 		}
 
 		g_free(property);
@@ -692,7 +728,6 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.network);
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
-		g_free(element->network.identifier);
 		g_free(element->path);
 		g_free(element->name);
 		g_free(element);
@@ -733,6 +768,46 @@ int connman_element_add_static_property(struct connman_element *element,
 	return 0;
 }
 
+int connman_element_add_static_array_property(struct connman_element *element,
+			const char *name, int type, const void *value, int len)
+{
+	struct connman_property *property;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (type != DBUS_TYPE_BYTE)
+		return -EINVAL;
+
+	property = g_try_new0(struct connman_property, 1);
+	if (property == NULL)
+		return -ENOMEM;
+
+	property->flags   = CONNMAN_PROPERTY_FLAG_STATIC;
+	property->id      = CONNMAN_PROPERTY_ID_INVALID;
+	property->name    = g_strdup(name);
+	property->type    = DBUS_TYPE_ARRAY;
+	property->subtype = type;
+
+	DBG("name %s type %d value %p", name, type, value);
+
+	switch (type) {
+	case DBUS_TYPE_BYTE:
+		property->value = g_try_malloc(len);
+		if (property->value != NULL) {
+			memcpy(property->value,
+				*((const unsigned char **) value), len);
+			property->size = len;
+		}
+		break;
+	}
+
+	connman_element_lock(element);
+	element->properties = g_slist_append(element->properties, property);
+	connman_element_unlock(element);
+
+	return 0;
+}
+
 static void *get_reference_value(struct connman_element *element,
 						enum connman_property_id id)
 {
@@ -975,6 +1050,95 @@ int connman_element_get_value(struct connman_element *element,
 	return 0;
 }
 
+gboolean connman_element_get_static_property(struct connman_element *element,
+						const char *name, void *value)
+{
+	GSList *list;
+	gboolean found = FALSE;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
+			continue;
+
+		if (g_str_equal(property->name, name) == TRUE) {
+			*((char **) value) = property->value;
+			found = TRUE;
+			break;
+		}
+	}
+
+	connman_element_unlock(element);
+
+	return found;
+}
+
+gboolean connman_element_get_static_array_property(struct connman_element *element,
+					const char *name, void *value, int *len)
+{
+	GSList *list;
+	gboolean found = FALSE;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
+			continue;
+
+		if (g_str_equal(property->name, name) == TRUE) {
+			*((char **) value) = property->value;
+			*len = property->size;
+			found = TRUE;
+			break;
+		}
+	}
+
+	connman_element_unlock(element);
+
+	return found;
+}
+
+gboolean connman_element_match_static_property(struct connman_element *element,
+					const char *name, const void *value)
+{
+	GSList *list;
+	gboolean result = FALSE;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
+			continue;
+
+		if (g_str_equal(property->name, name) == FALSE)
+			continue;
+
+		if (property->type == DBUS_TYPE_STRING)
+			result = g_str_equal(property->value,
+						*((const char **) value));
+
+		if (result == TRUE)
+			break;
+	}
+
+	connman_element_unlock(element);
+
+	return result;
+}
+
 /**
  * connman_element_register:
  * @element: the element to register

commit 8645704bb007f7431e9837e9c90b7d966b10099b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 18:53:56 2008 +0200

    Fix handling of WiFi SSID values

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 8944d436..d72b8383 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -505,8 +505,35 @@ static void append_entry(DBusMessageIter *dict,
 	dbus_message_iter_close_container(dict, &entry);
 }
 
-static int set_network(struct supplicant_task *task, const char *network,
-						const char *passphrase)
+static void append_array(DBusMessageIter *dict,
+				const char *key, int type, void *val, int len)
+{
+	DBusMessageIter entry, value, array;
+
+	if (type != DBUS_TYPE_BYTE)
+		return;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_BYTE_AS_STRING, &value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+					DBUS_TYPE_BYTE_AS_STRING, &array);
+	dbus_message_iter_append_fixed_array(&array, type, val, len);
+	dbus_message_iter_close_container(&value, &array);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static int set_network(struct supplicant_task *task,
+					const unsigned char *network, int len,
+							const char *passphrase)
 {
 	DBusMessage *message, *reply;
 	DBusMessageIter array, dict;
@@ -529,7 +556,7 @@ static int set_network(struct supplicant_task *task, const char *network,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	append_entry(&dict, "ssid", DBUS_TYPE_STRING, &network);
+	append_array(&dict, "ssid", DBUS_TYPE_BYTE, &network, len);
 
 	if (passphrase && strlen(passphrase) > 0) {
 		const char *key_mgmt = "WPA-PSK";
@@ -597,7 +624,21 @@ static void extract_ssid(struct supplicant_network *network,
 	dbus_message_iter_recurse(value, &array);
 	dbus_message_iter_get_fixed_array(&array, &ssid, &ssid_len);
 
-	network->identifier = g_strdup((char *) ssid);
+	if (ssid_len < 1)
+		return;
+
+	network->ssid = g_try_malloc(ssid_len);
+	if (network->ssid == NULL)
+		return;
+
+	memcpy(network->ssid, ssid, ssid_len);
+	network->ssid_len = ssid_len;
+
+	network->identifier = g_try_malloc0(ssid_len + 1);
+	if (network->identifier == NULL)
+		return;
+
+	memcpy(network->identifier, ssid, ssid_len);
 }
 
 static void extract_wpaie(struct supplicant_network *network,
@@ -689,6 +730,8 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	if (task->callback && task->callback->scan_result)
 		task->callback->scan_result(task->element, network);
 
+	g_free(network->identifier);
+	g_free(network->ssid);
 	g_free(network);
 
 done:
@@ -1017,10 +1060,11 @@ int __supplicant_scan(struct connman_element *element)
 	return 0;
 }
 
-int __supplicant_connect(struct connman_element *element, const char *ssid)
+int __supplicant_connect(struct connman_element *element,
+				const unsigned char *ssid, int ssid_len,
+							const char *passphrase)
 {
 	struct supplicant_task *task;
-	const char *passphrase = NULL;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -1033,7 +1077,7 @@ int __supplicant_connect(struct connman_element *element, const char *ssid)
 	select_network(task);
 	disable_network(task);
 
-	set_network(task, ssid, passphrase);
+	set_network(task, ssid, ssid_len, passphrase);
 
 	enable_network(task);
 
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 20552e6a..538c84f4 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -38,7 +38,8 @@ enum supplicant_state {
 
 struct supplicant_network {
 	gchar *identifier;
-	GByteArray *ssid;
+	guint8 *ssid;
+	guint ssid_len;
 	guint capabilities;
 	gboolean has_wep;
 	gboolean has_wpa;
@@ -61,5 +62,7 @@ int __supplicant_stop(struct connman_element *element);
 
 int __supplicant_scan(struct connman_element *element);
 
-int __supplicant_connect(struct connman_element *element, const char *ssid);
+int __supplicant_connect(struct connman_element *element,
+				const unsigned char *ssid, int ssid_len,
+							const char *passphrase);
 int __supplicant_disconnect(struct connman_element *element);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 1dcd135d..f7280b13 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -32,6 +32,12 @@
 
 #include "supplicant.h"
 
+struct wifi_data {
+	GStaticMutex mutex;
+	GSList *list;
+	gchar *identifier;
+};
+
 static int network_probe(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
@@ -46,18 +52,32 @@ static void network_remove(struct connman_element *element)
 
 static int network_enable(struct connman_element *element)
 {
+	char *identifier, *passphrase = NULL;
+	unsigned char *ssid;
+	int ssid_len;
+
 	DBG("element %p name %s", element, element->name);
 
-	element->enabled = FALSE;
-	connman_element_update(element);
+	if (connman_element_get_static_property(element,
+					"Identifier", &identifier) == FALSE)
+		return -EIO;
+
+	if (connman_element_get_static_array_property(element,
+					"SSID", &ssid, &ssid_len) == FALSE)
+		return -EIO;
+
+	if (element->parent != NULL) {
+		struct wifi_data *data = connman_element_get_data(element->parent);
 
-	if (element->parent) {
-		g_free(element->parent->network.identifier);
-		element->parent->network.identifier =
-					g_strdup(element->network.identifier);
+		if (data != NULL) {
+			g_free(data->identifier);
+			data->identifier = g_strdup(identifier);
+		}
 	}
 
-	if (__supplicant_connect(element, element->network.identifier) < 0)
+	DBG("identifier %s passhprase %s", identifier, passphrase);
+
+	if (__supplicant_connect(element, ssid, ssid_len, passphrase) < 0)
 		connman_error("Failed to initiate connect");
 
 	return 0;
@@ -71,9 +91,6 @@ static int network_disable(struct connman_element *element)
 
 	__supplicant_disconnect(element);
 
-	element->enabled = FALSE;
-	connman_element_update(element);
-
 	return 0;
 }
 
@@ -87,11 +104,6 @@ static struct connman_driver network_driver = {
 	.disable	= network_disable,
 };
 
-struct wifi_data {
-	GStaticMutex mutex;
-	GSList *list;
-};
-
 static struct connman_element *find_element(struct wifi_data *data,
 						const char *identifier)
 {
@@ -100,11 +112,8 @@ static struct connman_element *find_element(struct wifi_data *data,
 	for (list = data->list; list; list = list->next) {
 		struct connman_element *element = list->data;
 
-		if (element->network.identifier == NULL)
-			continue;
-
-		if (g_str_equal(element->network.identifier,
-							identifier) == TRUE)
+		if (connman_element_match_static_property(element,
+					"Identifier", &identifier) == TRUE)
 			return element;
 	}
 
@@ -119,10 +128,10 @@ static void state_change(struct connman_element *parent,
 
 	DBG("state %d", state);
 
-	if (parent->network.identifier == NULL)
+	if (data->identifier == NULL)
 		return;
 
-	element = find_element(data, parent->network.identifier);
+	element = find_element(data, data->identifier);
 	if (element == NULL)
 		return;
 
@@ -134,9 +143,6 @@ static void state_change(struct connman_element *parent,
 		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
 		dhcp->index = element->index;
 
-		element->enabled = TRUE;
-		connman_element_update(element);
-
 		connman_element_register(dhcp, element);
 	}
 }
@@ -181,13 +187,14 @@ static void scan_result(struct connman_element *parent,
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
 		element->index = parent->index;
 
-		element->network.identifier = g_strdup(network->identifier);
-
 		data->list = g_slist_append(data->list, element);
 
-		connman_element_add_static_property(element, "SSID",
+		connman_element_add_static_property(element, "Identifier",
 				DBUS_TYPE_STRING, &network->identifier);
 
+		connman_element_add_static_array_property(element, "SSID",
+			DBUS_TYPE_BYTE, &network->ssid, network->ssid_len);
+
 		connman_element_register(element, parent);
 	}
 
@@ -204,7 +211,6 @@ static struct supplicant_callback wifi_callback = {
 static int wifi_probe(struct connman_element *element)
 {
 	struct wifi_data *data;
-	int err;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -216,6 +222,36 @@ static int wifi_probe(struct connman_element *element)
 
 	connman_element_set_data(element, data);
 
+	return 0;
+}
+
+static void wifi_remove(struct connman_element *element)
+{
+	struct wifi_data *data = connman_element_get_data(element);
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_set_data(element, NULL);
+
+	g_free(data->identifier);
+	g_free(data);
+}
+
+static int wifi_update(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	__supplicant_scan(element);
+
+	return 0;
+}
+
+static int wifi_enable(struct connman_element *element)
+{
+	int err;
+
+	DBG("element %p name %s", element, element->name);
+
 	err = __supplicant_start(element, &wifi_callback);
 	if (err < 0)
 		return err;
@@ -225,41 +261,29 @@ static int wifi_probe(struct connman_element *element)
 	return 0;
 }
 
-static void wifi_remove(struct connman_element *element)
+static int wifi_disable(struct connman_element *element)
 {
 	struct wifi_data *data = connman_element_get_data(element);
 	GSList *list;
 
 	DBG("element %p name %s", element, element->name);
 
-	__supplicant_stop(element);
-
-	connman_element_set_data(element, NULL);
-
-	if (data == NULL)
-		return;
+	__supplicant_disconnect(element);
 
 	g_static_mutex_lock(&data->mutex);
 
 	for (list = data->list; list; list = list->next) {
 		struct connman_element *network = list->data;
 
-		connman_element_unregister(network);
 		connman_element_unref(network);
 	}
 
 	g_slist_free(data->list);
+	data->list = NULL;
 
 	g_static_mutex_unlock(&data->mutex);
 
-	g_free(data);
-}
-
-static int wifi_update(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	__supplicant_scan(element);
+	connman_element_unregister_children(element);
 
 	return 0;
 }
@@ -271,6 +295,8 @@ static struct connman_driver wifi_driver = {
 	.probe		= wifi_probe,
 	.remove		= wifi_remove,
 	.update		= wifi_update,
+	.enable		= wifi_enable,
+	.disable	= wifi_disable,
 };
 
 static int wifi_init(void)

commit 37b8c8db24ea812b0f0e0351895a351260579549
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 16 18:56:12 2008 +0200

    Remove deprecated network structure

diff --git a/include/element.h b/include/element.h
index d2f13abe..fedc4079 100644
--- a/include/element.h
+++ b/include/element.h
@@ -92,10 +92,6 @@ struct connman_element {
 
 	GSList *properties;
 
-	struct {
-		gchar *identifier;
-	} network;
-
 	struct {
 		gchar *address;
 		gchar *netmask;

commit 6b9edbbacdade5e0ccad762d6c848a9bef426114
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 01:35:44 2008 +0200

    Preparation for network abstraction

diff --git a/include/Makefile.am b/include/Makefile.am
index 74a8cb78..70978709 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -2,7 +2,7 @@
 includedir = @includedir@/connman
 
 include_HEADERS = log.h plugin.h security.h driver.h element.h property.h \
-							device.h rtnl.h dbus.h
+					device.h network.h rtnl.h dbus.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/network.h b/include/network.h
new file mode 100644
index 00000000..da7b67f5
--- /dev/null
+++ b/include/network.h
@@ -0,0 +1,33 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_NETWORK_H
+#define __CONNMAN_NETWORK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_NETWORK_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index afa1ce91..120bad25 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,7 +12,7 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
-				element.c device.c security.c storage.c \
+			element.c device.c network.c security.c storage.c \
 						manager.c agent.c rtnl.c
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
diff --git a/src/network.c b/src/network.c
index 1264d2d7..715e8c49 100644
--- a/src/network.c
+++ b/src/network.c
@@ -23,162 +23,4 @@
 #include <config.h>
 #endif
 
-#include <gdbus.h>
-
 #include "connman.h"
-
-static DBusConnection *connection = NULL;
-static unsigned int index = 0;
-
-static GSList *networks = NULL;
-
-void __connman_iface_network_list(struct connman_iface *iface,
-						DBusMessageIter *iter)
-{
-	GSList *list;
-
-	DBG("");
-
-	for (list = networks; list; list = list->next) {
-		struct connman_network *network = list->data;
-
-		if (network->iface != iface)
-			continue;
-
-		dbus_message_iter_append_basic(iter,
-				DBUS_TYPE_OBJECT_PATH, &network->path);
-	}
-}
-
-struct connman_network *__connman_iface_find_network(struct connman_iface *iface,
-								const char *path)
-{
-	GSList *list;
-
-	DBG("");
-
-	for (list = networks; list; list = list->next) {
-		struct connman_network *network = list->data;
-
-		if (network->iface == iface &&
-				g_str_equal(network->path, path) == TRUE)
-			return network;
-	}
-
-	return NULL;
-}
-
-int __connman_iface_remove_network(struct connman_iface *iface, const char *path)
-{
-	g_dbus_unregister_interface(connection, path,
-					CONNMAN_NETWORK_INTERFACE);
-
-	return 0;
-}
-
-static DBusMessage *get_identifier(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_network *network = data;
-	DBusMessage *reply;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_STRING, &network->identifier,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *get_passphrase(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_network *network = data;
-	DBusMessage *reply;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_STRING, &network->passphrase,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static GDBusMethodTable network_methods[] = {
-	{ "GetIdentifier", "", "s", get_identifier },
-	{ "GetPassphrase", "", "s", get_passphrase },
-	{ },
-};
-
-static void network_free(void *data)
-{
-	struct connman_network *network = data;
-
-	DBG("");
-
-	networks = g_slist_remove(networks, network);
-
-	g_free(network->path);
-	g_free(network->identifier);
-	g_free(network->passphrase);
-	g_free(network);
-}
-
-const char *__connman_iface_add_network(struct connman_iface *iface,
-				const char *identifier, const char *passphrase)
-{
-	struct connman_network *network;
-	gchar *path;
-
-	DBG("iface %p", iface);
-
-	network = g_try_new0(struct connman_network, 1);
-	if (network == NULL)
-		return NULL;
-
-	path = g_strdup_printf("%s/net_%d", iface->path, index++);
-	if (path == NULL) {
-		g_free(network);
-		return NULL;
-	}
-
-	network->iface = iface;
-
-	network->path = path;
-	network->identifier = g_strdup(identifier);
-	network->passphrase = g_strdup(passphrase ? passphrase : "");
-
-	networks = g_slist_append(networks, network);
-
-	g_dbus_register_interface(connection, path, CONNMAN_NETWORK_INTERFACE,
-						network_methods, NULL, NULL,
-							network, network_free);
-
-	return path;
-}
-
-int __connman_network_init(DBusConnection *conn)
-{
-	DBG("conn %p", conn);
-
-	connection = dbus_connection_ref(conn);
-	if (connection == NULL)
-		return -1;
-
-	return 0;
-}
-
-void __connman_network_cleanup(void)
-{
-	DBG("conn %p", connection);
-
-	dbus_connection_unref(connection);
-}

commit fbcf1d17374c922631fc60c387210a594a8b0240
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 01:47:32 2008 +0200

    Fix copy-and-paste documentation mistake

diff --git a/include/device.h b/include/device.h
index 994d997b..85f35817 100644
--- a/include/device.h
+++ b/include/device.h
@@ -29,9 +29,9 @@ extern "C" {
 #include <connman/element.h>
 
 /**
- * SECTION:driver
- * @title: Driver premitives
- * @short_description: Functions for registering drivers
+ * SECTION:device
+ * @title: Device driver premitives
+ * @short_description: Functions for registering device drivers
  */
 
 enum connman_device_type {

commit 5a5f2338053e56104bffde1a92a1d903ec934173
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 05:30:10 2008 +0200

    Add generic D-Bus helpers

diff --git a/include/dbus.h b/include/dbus.h
index a76aea24..58b0e835 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -46,6 +46,11 @@ extern "C" {
 
 #define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
 
+extern void connman_dbus_dict_append_array(DBusMessageIter *dict,
+				const char *key, int type, void *val, int len);
+extern void connman_dbus_dict_append_variant(DBusMessageIter *dict,
+					const char *key, int type, void *val);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/Makefile.am b/src/Makefile.am
index 120bad25..f29f37ea 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -13,7 +13,7 @@ sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
 			element.c device.c network.c security.c storage.c \
-						manager.c agent.c rtnl.c
+						manager.c agent.c rtnl.c dbus.c
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
 
diff --git a/src/dbus.c b/src/dbus.c
new file mode 100644
index 00000000..6c0de46d
--- /dev/null
+++ b/src/dbus.c
@@ -0,0 +1,99 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/dbus.h>
+
+void connman_dbus_dict_append_array(DBusMessageIter *dict,
+				const char *key, int type, void *val, int len)
+{
+	DBusMessageIter entry, value, array;
+	const char *variant_sig, *array_sig;
+
+	switch (type) {
+	case DBUS_TYPE_BYTE:
+		variant_sig = DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_BYTE_AS_STRING;
+		array_sig = DBUS_TYPE_BYTE_AS_STRING;
+		break;
+	default:
+		return;
+	}
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							variant_sig, &value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+							array_sig, &array);
+	dbus_message_iter_append_fixed_array(&array, type, val, len);
+	dbus_message_iter_close_container(&value, &array);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+void connman_dbus_dict_append_variant(DBusMessageIter *dict,
+					const char *key, int type, void *val)
+{
+	DBusMessageIter entry, value;
+	const char *signature;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_BOOLEAN:
+		signature = DBUS_TYPE_BOOLEAN_AS_STRING;
+		break;
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT32:
+		signature = DBUS_TYPE_UINT32_AS_STRING;
+		break;
+	case DBUS_TYPE_OBJECT_PATH:
+		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}

commit e12170a1242177b4acd357390b812ecdc32792f3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 05:38:30 2008 +0200

    Make use of generic D-Bus helpers

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index d72b8383..de56f8da 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -27,6 +27,7 @@
 #include <dbus/dbus.h>
 
 #include <connman/log.h>
+#include <connman/dbus.h>
 
 #include "inet.h"
 #include "supplicant.h"
@@ -474,63 +475,6 @@ static int disable_network(struct supplicant_task *task)
 	return 0;
 }
 
-static void append_entry(DBusMessageIter *dict,
-				const char *key, int type, void *val)
-{
-	DBusMessageIter entry, value;
-	const char *signature;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	switch (type) {
-	case DBUS_TYPE_STRING:
-		signature = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT16:
-		signature = DBUS_TYPE_UINT16_AS_STRING;
-		break;
-	default:
-		signature = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							signature, &value);
-	dbus_message_iter_append_basic(&value, type, val);
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
-static void append_array(DBusMessageIter *dict,
-				const char *key, int type, void *val, int len)
-{
-	DBusMessageIter entry, value, array;
-
-	if (type != DBUS_TYPE_BYTE)
-		return;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_BYTE_AS_STRING, &value);
-
-	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-					DBUS_TYPE_BYTE_AS_STRING, &array);
-	dbus_message_iter_append_fixed_array(&array, type, val, len);
-	dbus_message_iter_close_container(&value, &array);
-
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static int set_network(struct supplicant_task *task,
 					const unsigned char *network, int len,
 							const char *passphrase)
@@ -556,15 +500,19 @@ static int set_network(struct supplicant_task *task,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	append_array(&dict, "ssid", DBUS_TYPE_BYTE, &network, len);
+	connman_dbus_dict_append_array(&dict, "ssid",
+					DBUS_TYPE_BYTE, &network, len);
 
 	if (passphrase && strlen(passphrase) > 0) {
 		const char *key_mgmt = "WPA-PSK";
-		append_entry(&dict, "key_mgmt", DBUS_TYPE_STRING, &key_mgmt);
-		append_entry(&dict, "psk", DBUS_TYPE_STRING, &passphrase);
+		connman_dbus_dict_append_variant(&dict, "key_mgmt",
+						DBUS_TYPE_STRING, &key_mgmt);
+		connman_dbus_dict_append_variant(&dict, "psk",
+						DBUS_TYPE_STRING, &passphrase);
 	} else {
 		const char *key_mgmt = "NONE";
-		append_entry(&dict, "key_mgmt", DBUS_TYPE_STRING, &key_mgmt);
+		connman_dbus_dict_append_variant(&dict, "key_mgmt",
+						DBUS_TYPE_STRING, &key_mgmt);
 	}
 
 	dbus_message_iter_close_container(&array, &dict);
diff --git a/src/element.c b/src/element.c
index 83a9e9e3..cb513ecf 100644
--- a/src/element.c
+++ b/src/element.c
@@ -144,79 +144,6 @@ static const char *subtype2string(enum connman_element_subtype type)
 	return NULL;
 }
 
-static void append_array(DBusMessageIter *dict,
-				const char *key, int type, void *val, int len)
-{
-	DBusMessageIter entry, value, array;
-	const char *variant_sig, *array_sig;
-
-	switch (type) {
-	case DBUS_TYPE_BYTE:
-		variant_sig = DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_BYTE_AS_STRING;
-		array_sig = DBUS_TYPE_BYTE_AS_STRING;
-		break;
-	default:
-		return;
-	}
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							variant_sig, &value);
-
-	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-							array_sig, &array);
-	dbus_message_iter_append_fixed_array(&array, type, val, len);
-	dbus_message_iter_close_container(&value, &array);
-
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
-static void append_entry(DBusMessageIter *dict,
-				const char *key, int type, void *val)
-{
-	DBusMessageIter entry, value;
-	const char *signature;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	switch (type) {
-	case DBUS_TYPE_BOOLEAN:
-		signature = DBUS_TYPE_BOOLEAN_AS_STRING;
-		break;
-	case DBUS_TYPE_STRING:
-		signature = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT16:
-		signature = DBUS_TYPE_UINT16_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT32:
-		signature = DBUS_TYPE_UINT32_AS_STRING;
-		break;
-	case DBUS_TYPE_OBJECT_PATH:
-		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
-		break;
-	default:
-		signature = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							signature, &value);
-	dbus_message_iter_append_basic(&value, type, val);
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static void append_property(DBusMessageIter *dict,
 				struct connman_property *property)
 {
@@ -224,11 +151,11 @@ static void append_property(DBusMessageIter *dict,
 		return;
 
 	if (property->type == DBUS_TYPE_ARRAY)
-		append_array(dict, property->name, property->subtype,
-					&property->value, property->size);
+		connman_dbus_dict_append_array(dict, property->name,
+			property->subtype, &property->value, property->size);
 	else
-		append_entry(dict, property->name, property->type,
-							&property->value);
+		connman_dbus_dict_append_variant(dict, property->name,
+					property->type, &property->value);
 }
 
 static DBusMessage *get_properties(DBusConnection *conn,
@@ -255,31 +182,34 @@ static DBusMessage *get_properties(DBusConnection *conn,
 
 	if (element->parent != NULL &&
 			element->parent->type != CONNMAN_ELEMENT_TYPE_ROOT) {
-		append_entry(&dict, "Parent",
+		connman_dbus_dict_append_variant(&dict, "Parent",
 				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
 	}
 
 	str = type2string(element->type);
 	if (str != NULL)
-		append_entry(&dict, "Type", DBUS_TYPE_STRING, &str);
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
 	str = subtype2string(element->subtype);
 	if (str != NULL)
-		append_entry(&dict, "Subtype", DBUS_TYPE_STRING, &str);
+		connman_dbus_dict_append_variant(&dict, "Subtype",
+						DBUS_TYPE_STRING, &str);
 
-	append_entry(&dict, "Enabled", DBUS_TYPE_BOOLEAN, &element->enabled);
+	connman_dbus_dict_append_variant(&dict, "Enabled",
+					DBUS_TYPE_BOOLEAN, &element->enabled);
 
 	if (element->priority > 0)
-		append_entry(&dict, "Priority",
-				DBUS_TYPE_UINT16, &element->priority);
+		connman_dbus_dict_append_variant(&dict, "Priority",
+					DBUS_TYPE_UINT16, &element->priority);
 
 	if (element->ipv4.address != NULL)
-		append_entry(&dict, "IPv4.Address",
+		connman_dbus_dict_append_variant(&dict, "IPv4.Address",
 				DBUS_TYPE_STRING, &element->ipv4.address);
 	if (element->ipv4.netmask != NULL)
-		append_entry(&dict, "IPv4.Netmask",
+		connman_dbus_dict_append_variant(&dict, "IPv4.Netmask",
 				DBUS_TYPE_STRING, &element->ipv4.netmask);
 	if (element->ipv4.gateway != NULL)
-		append_entry(&dict, "IPv4.Gateway",
+		connman_dbus_dict_append_variant(&dict, "IPv4.Gateway",
 				DBUS_TYPE_STRING, &element->ipv4.gateway);
 
 	connman_element_lock(element);

commit 65819b820f763785206ce6b053ae5ad03cfbbdff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 06:51:32 2008 +0200

    Add simple development/hacking introduction

diff --git a/HACKING b/HACKING
new file mode 100644
index 00000000..9e0adec2
--- /dev/null
+++ b/HACKING
@@ -0,0 +1,83 @@
+Hacking on Connection Manager
+*****************************
+
+
+Working with the source code repository
+=======================================
+
+The repository contains two extra scripts that accomplish the bootstrap
+process. One is called "bootstrap" which is the basic scripts that uses the
+autotools scripts to create the needed files for building and installing.
+It makes sure to call the right programs depending on the usage of shared or
+static libraries or translations etc.
+
+The second program is called "bootstrap-configure". This program will make
+sure to properly clean the repository, call the "bootstrap" script and then
+call configure with proper settings for development. It will use the best
+options and pass them over to configure. These options normally include
+the enabling the maintainer mode and the debugging features.
+
+So while in a normal source project the call "./configure ..." is used to
+configure the project with its settings like prefix and extra options. In
+case of bare repositories call "./bootstrap-configure" and it will bootstrap
+the repository and calls configure with all the correct options to make
+development easier.
+
+In case of preparing for a release with "make distcheck", don't use
+bootstrap-configure since it could export development specific settings.
+
+So the normal steps to checkout, build and install such a repository is
+like this:
+
+  Checkout repository
+    # git-clone git://git.moblin.org/projects/connman.git
+    # cd connman
+
+  Configure and build
+    # ./bootstrap-configure
+    # make
+
+  Check installation
+    # make install DESTDIR=$PWD/x
+    # find x
+    # rm -rf x
+
+  Check distribution
+    # make distcheck
+
+  Final installation
+    # sudo make install
+
+  Remove autogenerated files
+    # make maintainer-clean
+
+
+Generating source code documentation
+====================================
+
+The source code is annotated using the gtk-doc style documentation. This
+allows an easy way of generating API documentation. The "bootstrap-configure"
+script will use the "--enable-gtk-doc" configure to enable the generation of
+the documentation.
+
+To make the gtk-doc process work, the gtk-doc tools need to be installed.
+Every distribution should provide a package for this, but the naming of the
+package might be different:
+
+  Ubuntu/Debian
+    # apt-get install gtk-doc-utils
+
+  Fedora
+    # yum install gtk-doc
+
+In case "bootstrap-configure" is not used, the manual steps for generating
+the documentation files are like this:
+
+  Configuring the repository
+    # ./configure --enable-gtk-doc
+
+  Generate the documentation
+    # cd doc && make
+
+  View documentation
+    # firefox doc/html/index.html

commit ae470f3badc8e832f21b946c82eec97e4104fd36
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 18:26:13 2008 +0200

    Change declaration of GDBusWatchFunction

diff --git a/gdbus/gdbus.h b/gdbus/gdbus.h
index b44bc867..42b9061d 100644
--- a/gdbus/gdbus.h
+++ b/gdbus/gdbus.h
@@ -31,7 +31,8 @@ extern "C" {
 #include <dbus/dbus.h>
 #include <glib.h>
 
-typedef void (* GDBusWatchFunction) (void *user_data);
+typedef void (* GDBusWatchFunction) (DBusConnection *connection,
+							void *user_data);
 
 typedef gboolean (* GDBusSignalFunction) (DBusConnection *connection,
 					DBusMessage *message, void *user_data);
diff --git a/gdbus/watch.c b/gdbus/watch.c
index fb0bef3f..63e3a7c3 100644
--- a/gdbus/watch.c
+++ b/gdbus/watch.c
@@ -94,7 +94,7 @@ static void name_data_call_and_free(struct name_data *data)
 	for (l = data->callbacks; l != NULL; l = l->next) {
 		struct name_callback *cb = l->data;
 		if (cb->func)
-			cb->func(cb->user_data);
+			cb->func(data->connection, cb->user_data);
 		g_free(cb);
 	}
 
@@ -246,7 +246,7 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 
 	for (l = data->callbacks; l != NULL; l = l->next) {
 		struct name_callback *cb = l->data;
-		cb->func(cb->user_data);
+		cb->func(connection, cb->user_data);
 	}
 
 	name_listeners = g_slist_remove(name_listeners, data);

commit 0fe3d5e4406c2c086a2fa3f5ae695d187eb03ead
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 18:31:50 2008 +0200

    Fix connection disconnect function

diff --git a/gdbus/mainloop.c b/gdbus/mainloop.c
index b50d83c0..d38bd637 100644
--- a/gdbus/mainloop.c
+++ b/gdbus/mainloop.c
@@ -60,7 +60,7 @@ struct server_info {
 };
 
 struct disconnect_data {
-	void (*disconnect_cb)(void *);
+	GDBusWatchFunction disconnect_cb;
 	void *user_data;
 };
 
@@ -72,8 +72,8 @@ static DBusHandlerResult disconnect_filter(DBusConnection *conn,
 	if (dbus_message_is_signal(msg,
 			DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE) {
 		error("Got disconnected from the system message bus");
+		dc_data->disconnect_cb(conn, dc_data->user_data);
 		dbus_connection_unref(conn);
-		dc_data->disconnect_cb(dc_data->user_data);
 	}
 
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;

commit f9074a6cd08a45628e2c20d14a70aa1698de01b8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 18:34:18 2008 +0200

    Fix agent disconnect callback declaration

diff --git a/src/agent.c b/src/agent.c
index 2d0f3656..fbd8df3c 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -47,7 +47,7 @@ static void agent_free(void)
 	agent_path = NULL;
 }
 
-static void agent_disconnect(void *data)
+static void agent_disconnect(DBusConnection *connection, void *data)
 {
 	DBG("data %p", data);
 

commit 9fed97d6e749e022976d5a56a65f548ea17ce429
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 19:14:25 2008 +0200

    Add g_dbus_add_service_watch() implementation

diff --git a/gdbus/gdbus.h b/gdbus/gdbus.h
index 42b9061d..818a36f7 100644
--- a/gdbus/gdbus.h
+++ b/gdbus/gdbus.h
@@ -117,8 +117,11 @@ gboolean g_dbus_emit_signal_valist(DBusConnection *connection,
 				const char *path, const char *interface,
 				const char *name, int type, va_list args);
 
-guint g_dbus_add_disconnect_watch(DBusConnection *connection,
-				const char *name,
+guint g_dbus_add_service_watch(DBusConnection *connection, const char *name,
+				GDBusWatchFunction connect,
+				GDBusWatchFunction disconnect,
+				void *user_data, GDBusDestroyFunction destroy);
+guint g_dbus_add_disconnect_watch(DBusConnection *connection, const char *name,
 				GDBusWatchFunction function,
 				void *user_data, GDBusDestroyFunction destroy);
 guint g_dbus_add_signal_watch(DBusConnection *connection,
diff --git a/gdbus/watch.c b/gdbus/watch.c
index 63e3a7c3..ec3be640 100644
--- a/gdbus/watch.c
+++ b/gdbus/watch.c
@@ -41,7 +41,8 @@ static guint listener_id = 0;
 static GSList *name_listeners = NULL;
 
 struct name_callback {
-	GDBusWatchFunction func;
+	GDBusWatchFunction conn_func;
+	GDBusWatchFunction disc_func;
 	void *user_data;
 	guint id;
 };
@@ -73,14 +74,13 @@ static struct name_data *name_data_find(DBusConnection *connection,
 	return NULL;
 }
 
-static struct name_callback *name_callback_find(GSList *callbacks,
-					GDBusWatchFunction func, void *user_data)
+static struct name_callback *name_callback_find(GSList *callbacks, guint id)
 {
 	GSList *current;
 
 	for (current = callbacks; current != NULL; current = current->next) {
 		struct name_callback *cb = current->data;
-		if (cb->func == func && cb->user_data == user_data)
+		if (cb->id == id)
 			return cb;
 	}
 
@@ -93,8 +93,8 @@ static void name_data_call_and_free(struct name_data *data)
 
 	for (l = data->callbacks; l != NULL; l = l->next) {
 		struct name_callback *cb = l->data;
-		if (cb->func)
-			cb->func(data->connection, cb->user_data);
+		if (cb->disc_func)
+			cb->disc_func(data->connection, cb->user_data);
 		g_free(cb);
 	}
 
@@ -116,7 +116,9 @@ static void name_data_free(struct name_data *data)
 }
 
 static int name_data_add(DBusConnection *connection, const char *name,
-				GDBusWatchFunction func, void *user_data, guint id)
+						GDBusWatchFunction connect,
+						GDBusWatchFunction disconnect,
+						void *user_data, guint id)
 {
 	int first = 1;
 	struct name_data *data = NULL;
@@ -124,7 +126,8 @@ static int name_data_add(DBusConnection *connection, const char *name,
 
 	cb = g_new(struct name_callback, 1);
 
-	cb->func = func;
+	cb->conn_func = connect;
+	cb->disc_func = disconnect;
 	cb->user_data = user_data;
 	cb->id = id;
 
@@ -147,7 +150,7 @@ done:
 }
 
 static void name_data_remove(DBusConnection *connection,
-			const char *name, GDBusWatchFunction func, void *user_data)
+					const char *name, guint id)
 {
 	struct name_data *data;
 	struct name_callback *cb = NULL;
@@ -156,7 +159,7 @@ static void name_data_remove(DBusConnection *connection,
 	if (!data)
 		return;
 
-	cb = name_callback_find(data->callbacks, func, user_data);
+	cb = name_callback_find(data->callbacks, id);
 	if (cb) {
 		data->callbacks = g_slist_remove(data->callbacks, cb);
 		g_free(cb);
@@ -220,6 +223,7 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 	GSList *l;
 	struct name_data *data;
 	char *name, *old, *new;
+	int keep = 0;
 
 	if (!dbus_message_is_signal(message, DBUS_INTERFACE_DBUS,
 							"NameOwnerChanged"))
@@ -234,10 +238,6 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 	}
 
-	/* We are not interested of service creations */
-	if (*new != '\0')
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
 	data = name_data_find(connection, name);
 	if (!data) {
 		error("Got NameOwnerChanged signal for %s which has no listeners", name);
@@ -246,9 +246,20 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 
 	for (l = data->callbacks; l != NULL; l = l->next) {
 		struct name_callback *cb = l->data;
-		cb->func(connection, cb->user_data);
+		if (*new == '\0') {
+			if (cb->disc_func)
+				cb->disc_func(connection, cb->user_data);
+		} else {
+			if (cb->conn_func)
+				cb->conn_func(connection, cb->user_data);
+		}
+		if (cb->conn_func && cb->disc_func)
+			keep = 1;
 	}
 
+	if (keep)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
 	name_listeners = g_slist_remove(name_listeners, data);
 	name_data_free(data);
 
@@ -257,9 +268,9 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
-guint g_dbus_add_disconnect_watch(DBusConnection *connection,
-				const char *name,
-				GDBusWatchFunction func,
+guint g_dbus_add_service_watch(DBusConnection *connection, const char *name,
+				GDBusWatchFunction connect,
+				GDBusWatchFunction disconnect,
 				void *user_data, GDBusDestroyFunction destroy)
 {
 	int first;
@@ -273,7 +284,8 @@ guint g_dbus_add_disconnect_watch(DBusConnection *connection,
 	}
 
 	listener_id++;
-	first = name_data_add(connection, name, func, user_data, listener_id);
+	first = name_data_add(connection, name, connect, disconnect,
+						user_data, listener_id);
 	/* The filter is already added if this is not the first callback
 	 * registration for the name */
 	if (!first)
@@ -283,7 +295,7 @@ guint g_dbus_add_disconnect_watch(DBusConnection *connection,
 		debug("name_listener_add(%s)", name);
 
 		if (!add_match(connection, name)) {
-			name_data_remove(connection, name, func, user_data);
+			name_data_remove(connection, name, listener_id);
 			return 0;
 		}
 	}
@@ -291,6 +303,14 @@ guint g_dbus_add_disconnect_watch(DBusConnection *connection,
 	return listener_id;
 }
 
+guint g_dbus_add_disconnect_watch(DBusConnection *connection, const char *name,
+				GDBusWatchFunction func,
+				void *user_data, GDBusDestroyFunction destroy)
+{
+	return g_dbus_add_service_watch(connection, name, NULL, func,
+							user_data, destroy);
+}
+
 guint g_dbus_add_signal_watch(DBusConnection *connection,
 				const char *rule, GDBusSignalFunction function,
 				void *user_data, GDBusDestroyFunction destroy)

commit 3a3a82ac1e3f16fe7b8d582bcce968921ecad8c3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 19:29:35 2008 +0200

    Fix disconnect callback declaration

diff --git a/src/main.c b/src/main.c
index 87efa00e..104c5cc5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -43,7 +43,7 @@ static void sig_term(int sig)
 	g_main_loop_quit(main_loop);
 }
 
-static void disconnect_callback(void *user_data)
+static void disconnect_callback(DBusConnection *conn, void *user_data)
 {
 	DBG("D-Bus disconnect");
 

commit 19e56a613e70233a2e07217745dbf93b041c0b53
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 19:34:57 2008 +0200

    Let the Bluetooth plugin listen on service changes

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 2d0d7ad9..d519ac92 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -23,114 +23,47 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+
 #include <gdbus.h>
 
 #include <connman/plugin.h>
-#include <connman/driver.h>
+#include <connman/device.h>
 #include <connman/log.h>
 
 #define BLUEZ_SERVICE "org.bluez"
 
-#define MANAGER_INTERFACE "org.bluez.Manager"
-#define MANAGER_PATH "/"
-
-static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
-static GSList *element_list = NULL;
-
-static void create_element(DBusConnection *conn, const char *path)
+static int bluetooth_probe(struct connman_device *device)
 {
-	struct connman_element *element;
-
-	DBG("conn %p path %s", conn, path);
-
-	element = connman_element_create(NULL);
+	DBG("device %p", device);
 
-	element->name = g_path_get_basename(path);
-	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	element->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
-
-	g_static_mutex_lock(&element_mutex);
-
-	connman_element_register(element, NULL);
-
-	element_list = g_slist_append(element_list, element);
-
-	g_static_mutex_unlock(&element_mutex);
+	return 0;
 }
 
-static gboolean bluetooth_signal(DBusConnection *conn,
-					DBusMessage *msg, void *data)
+static void bluetooth_remove(struct connman_device *device)
 {
-	const char *sender, *interface, *member;
-
-	DBG("conn %p msg %p", conn, msg);
-
-	sender = dbus_message_get_sender(msg);
-	interface = dbus_message_get_interface(msg);
-	member = dbus_message_get_member(msg);
-
-	DBG("sender %s name %s.%s", sender, interface, member);
-
-	return TRUE;
+	DBG("device %p", device);
 }
 
-static void list_adapters(DBusConnection *conn)
-{
-	DBusMessage *msg, *reply;
-	char **paths = NULL;
-	int i, num = 0;
-
-	DBG("conn %p");
-
-	msg = dbus_message_new_method_call(BLUEZ_SERVICE, MANAGER_PATH,
-					MANAGER_INTERFACE, "ListAdapters");
-	if (!msg) {
-		connman_error("ListAdpaters message alloction failed");
-		return;
-	}
-
-	reply = dbus_connection_send_with_reply_and_block(conn, msg, -1, NULL);
-
-	dbus_message_unref(msg);
-
-	if (!reply) {
-		connman_error("ListAdapters method call failed");
-		return;
-	}
-
-	dbus_message_get_args(reply, NULL, DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
-						&paths, &num, DBUS_TYPE_INVALID);
-
-	for (i = 0; i < num; i++)
-		create_element(conn, paths[i]);
-
-	g_strfreev(paths);
-
-	dbus_message_unref(reply);
-}
+static struct connman_device_driver bluetooth_driver = {
+	.name	= "bluetooth",
+	.type	= CONNMAN_DEVICE_TYPE_BLUETOOTH,
+	.probe	= bluetooth_probe,
+	.remove	= bluetooth_remove,
+};
 
-static int bluetooth_probe(struct connman_element *element)
+static void bluetooth_connect(DBusConnection *connection, void *user_data)
 {
-	DBG("element %p name %s", element, element->name);
-
-	return 0;
+	DBG("connection %p", connection);
 }
 
-static void bluetooth_remove(struct connman_element *element)
+static void bluetooth_disconnect(DBusConnection *connection, void *user_data)
 {
-	DBG("element %p name %s", element, element->name);
+	DBG("connection %p", connection);
 }
 
-static struct connman_driver bluetooth_driver = {
-	.name		= "bluetooth",
-	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
-	.probe		= bluetooth_probe,
-	.remove		= bluetooth_remove,
-};
-
 static DBusConnection *connection;
-static guint signal;
+static guint watch;
 
 static int bluetooth_init(void)
 {
@@ -140,25 +73,28 @@ static int bluetooth_init(void)
 	if (connection == NULL)
 		return -EIO;
 
-	signal = g_dbus_add_signal_watch(connection, "sender=org.bluez",
-						bluetooth_signal, NULL, NULL);
-
-	err = connman_driver_register(&bluetooth_driver);
+	err = connman_device_driver_register(&bluetooth_driver);
 	if (err < 0) {
 		dbus_connection_unref(connection);
-		return err;
+		return -EIO;
 	}
 
-	list_adapters(connection);
+	watch = g_dbus_add_service_watch(connection, BLUEZ_SERVICE,
+			bluetooth_connect, bluetooth_disconnect, NULL, NULL);
+	if (watch == 0) {
+		connman_device_driver_unregister(&bluetooth_driver);
+		dbus_connection_unref(connection);
+		return -EIO;
+	}
 
 	return 0;
 }
 
 static void bluetooth_exit(void)
 {
-	connman_driver_unregister(&bluetooth_driver);
+	g_dbus_remove_watch(connection, watch);
 
-	g_dbus_remove_watch(connection, signal);
+	connman_device_driver_unregister(&bluetooth_driver);
 
 	dbus_connection_unref(connection);
 }

commit 176fe9f20467f7c4bd493c437d6e9d5acd2ebb48
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 17 22:10:02 2008 +0200

    Add watch for monitoring wpa_supplicant

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index de56f8da..260d24f9 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1049,11 +1049,9 @@ int __supplicant_disconnect(struct connman_element *element)
 	return 0;
 }
 
-int __supplicant_init(void)
+int __supplicant_init(DBusConnection *conn)
 {
-	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
-	if (connection == NULL)
-		return -EIO;
+	connection = conn;
 
 	if (dbus_connection_add_filter(connection,
 				supplicant_filter, NULL, NULL) == FALSE) {
@@ -1066,11 +1064,5 @@ int __supplicant_init(void)
 
 void __supplicant_exit(void)
 {
-	if (connection == NULL)
-		return;
-
 	dbus_connection_remove_filter(connection, supplicant_filter, NULL);
-
-	dbus_connection_unref(connection);
-	connection = NULL;
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 538c84f4..d62e07d1 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -53,7 +53,7 @@ struct supplicant_callback {
 					struct supplicant_network *network);
 };
 
-int __supplicant_init(void);
+int __supplicant_init(DBusConnection *conn);
 void __supplicant_exit(void);
 
 int __supplicant_start(struct connman_element *element,
diff --git a/plugins/wifi.c b/plugins/wifi.c
index f7280b13..304ebba2 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -24,7 +24,7 @@
 #endif
 
 #include <string.h>
-#include <dbus/dbus.h>
+#include <gdbus.h>
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
@@ -299,17 +299,40 @@ static struct connman_driver wifi_driver = {
 	.disable	= wifi_disable,
 };
 
+static void supplicant_connect(DBusConnection *connection, void *user_data)
+{
+	DBG("connection %p", connection);
+}
+
+static void supplicant_disconnect(DBusConnection *connection, void *user_data)
+{
+	DBG("connection %p", connection);
+}
+
+static DBusConnection *connection;
+static guint watch;
+
 static int wifi_init(void)
 {
 	int err;
 
-	err = __supplicant_init();
-	if (err < 0)
+	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (connection == NULL)
+		return -EIO;
+
+	err = __supplicant_init(connection);
+	if (err < 0) {
+		dbus_connection_unref(connection);
 		return err;
+	}
+
+	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
+			supplicant_connect, supplicant_disconnect, NULL, NULL);
 
 	err = connman_driver_register(&network_driver);
 	if (err < 0) {
 		__supplicant_exit();
+		dbus_connection_unref(connection);
 		return err;
 	}
 
@@ -317,6 +340,7 @@ static int wifi_init(void)
 	if (err < 0) {
 		connman_driver_unregister(&network_driver);
 		__supplicant_exit();
+		dbus_connection_unref(connection);
 		return err;
 	}
 
@@ -328,7 +352,12 @@ static void wifi_exit(void)
 	connman_driver_unregister(&network_driver);
 	connman_driver_unregister(&wifi_driver);
 
+	if (watch > 0)
+		g_dbus_remove_watch(connection, watch);
+
 	__supplicant_exit();
+
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE("wifi", "WiFi interface plugin", VERSION,

commit 0889675fe72fdedfd0f8919084d80a550d6b3472
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 18 18:04:34 2008 +0200

    Handle plugin init errors

diff --git a/src/plugin.c b/src/plugin.c
index 0d90fd9f..cfbd906a 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -47,9 +47,10 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	plugin->handle = handle;
 	plugin->desc = desc;
 
-	plugins = g_slist_append(plugins, plugin);
+	if (desc->init() < 0)
+		return FALSE;
 
-	desc->init();
+	plugins = g_slist_append(plugins, plugin);
 
 	return TRUE;
 }

commit e3e56199f01eda60b6f2d54d4133137ef546314b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 18 18:06:18 2008 +0200

    Fix memory leak when plugin init fails

diff --git a/src/plugin.c b/src/plugin.c
index cfbd906a..153b7be3 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -47,8 +47,10 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	plugin->handle = handle;
 	plugin->desc = desc;
 
-	if (desc->init() < 0)
+	if (desc->init() < 0) {
+		g_free(plugin);
 		return FALSE;
+	}
 
 	plugins = g_slist_append(plugins, plugin);
 

commit 4a7178f181574f47eeea44249358595b2784c3fb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 18 19:06:34 2008 +0200

    Simplify plugin descriptor checking

diff --git a/src/plugin.c b/src/plugin.c
index 153b7be3..c128505d 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -40,6 +40,9 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 {
 	struct connman_plugin *plugin;
 
+	if (desc->init == NULL)
+		return FALSE;
+
 	plugin = g_try_new0(struct connman_plugin, 1);
 	if (plugin == NULL)
 		return FALSE;
@@ -94,11 +97,6 @@ int __connman_plugin_init(void)
 				continue;
 			}
 
-			if (desc->init == NULL) {
-				dlclose(handle);
-				continue;
-			}
-
 			if (add_plugin(handle, desc) == FALSE)
 				dlclose(handle);
 		}

commit 9f5fe30d3ba7b2f1d3965859c822dca2201b2a3f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Oct 20 02:12:38 2008 +0200

    Link wifi plugin with libgdbus

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index d5ececbc..c296aa1c 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -8,6 +8,7 @@ plugin_LTLIBRARIES = ethernet.la wifi.la bluetooth.la \
 ethernet_la_SOURCES = ethernet.c
 
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
+wifi_la_LIBADD = @GDBUS_LIBS@
 
 bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@

commit e204b1b0150df1d5904e509a1fbf5c12a66ed6f8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 07:40:37 2008 +0100

    Add support for resolver modules

diff --git a/include/Makefile.am b/include/Makefile.am
index 70978709..c44bd1b6 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,8 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h security.h driver.h element.h property.h \
+include_HEADERS = log.h plugin.h security.h resolver.h \
+					driver.h element.h property.h \
 					device.h network.h rtnl.h dbus.h
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/include/resolver.h b/include/resolver.h
new file mode 100644
index 00000000..77a95cf0
--- /dev/null
+++ b/include/resolver.h
@@ -0,0 +1,46 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_RESOLVER_H
+#define __CONNMAN_RESOLVER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * SECTION:resolver
+ * @title: Resolver premitives
+ * @short_description: Functions for registering resolver modules
+ */
+
+struct connman_resolver {
+	const char *name;
+};
+
+extern int connman_resolver_register(struct connman_resolver *resolver);
+extern void connman_resolver_unregister(struct connman_resolver *resolver);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_RESOLVER_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index f29f37ea..6c3d6039 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,8 +12,8 @@ DISTCLEANFILES = $(service_DATA)
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
-			element.c device.c network.c security.c storage.c \
-						manager.c agent.c rtnl.c dbus.c
+			element.c device.c network.c security.c resolver.c \
+				storage.c manager.c agent.c rtnl.c dbus.c
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
 
diff --git a/src/connman.h b/src/connman.h
index 57f97bf4..8bacda60 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -61,6 +61,8 @@ void __connman_plugin_cleanup(void);
 
 int __connman_security_check_privileges(DBusMessage *message);
 
+#include <connman/resolver.h>
+
 #include <connman/driver.h>
 
 void __connman_driver_rescan(struct connman_driver *driver);
diff --git a/src/resolver.c b/src/resolver.c
new file mode 100644
index 00000000..404bc3dd
--- /dev/null
+++ b/src/resolver.c
@@ -0,0 +1,67 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+static GStaticRWLock resolver_lock = G_STATIC_RW_LOCK_INIT;
+static GSList *resolver_list = NULL;
+
+/**
+ * connman_resolver_register:
+ * @resolver: resolver module
+ *
+ * Register a new resolver module
+ *
+ * Returns: %0 on success
+ */
+int connman_resolver_register(struct connman_resolver *resolver)
+{
+	DBG("resolver %p name %s", resolver, resolver->name);
+
+	g_static_rw_lock_writer_lock(&resolver_lock);
+
+	resolver_list = g_slist_append(resolver_list, resolver);
+
+	g_static_rw_lock_writer_unlock(&resolver_lock);
+
+	return 0;
+}
+
+/**
+ * connman_resolver_unregister:
+ * @resolver: resolver module
+ *
+ * Remove a previously registered resolver module
+ */
+void connman_resolver_unregister(struct connman_resolver *resolver)
+{
+	DBG("resolver %p name %s", resolver, resolver->name);
+
+	g_static_rw_lock_writer_lock(&resolver_lock);
+
+	resolver_list = g_slist_remove(resolver_list, resolver);
+
+	g_static_rw_lock_writer_unlock(&resolver_lock);
+}

commit bf3f80d905bf9dadc9ad108625b6eb5fa15edd12
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 07:45:25 2008 +0100

    Store element properties in key files

diff --git a/src/storage.c b/src/storage.c
index d67d0d2c..24d0a5c8 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -23,99 +23,95 @@
 #include <config.h>
 #endif
 
-#if 0
-#include <sqlite3.h>
-#endif
-
 #include "connman.h"
 
-#if 0
-static sqlite3 *db = NULL;
-
-static int create_tables(void)
+int __connman_storage_init(void)
 {
-	char *msg;
-	int err;
+	DBG("");
 
+	return 0;
+}
+
+void __connman_storage_cleanup(void)
+{
 	DBG("");
+}
 
-	err = sqlite3_exec(db, "CREATE TABLE properties ("
-					"element TEXT NOT NULL,"
-					"name TEXT NOT NULL,"
-					"value TEXT NOT NULL,"
-					"PRIMARY KEY(element, name))",
-							NULL, NULL, &msg);
-
-	if (err != SQLITE_OK) {
-		connman_error("SQL error: %s", msg);
-		sqlite3_free(msg);
-		return -1;
-	}
+int __connman_element_load(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
 
 	return 0;
 }
-#endif
 
-int __connman_storage_init(void)
+static void do_update(GKeyFile *keyfile, struct connman_element *element)
 {
-#if 0
-	int err;
+	GSList *list;
 
-	DBG("");
+	DBG("element %p name %s", element, element->name);
 
-#if 0
-	if (!sqlite3_threadsafe()) {
-		connman_error("SQLite is missing thread support");
-		return -1;
-	}
-#endif
+	g_key_file_set_string(keyfile, element->path, "Name", element->name);
 
-	err = sqlite3_open(STORAGEDIR "/config.db", &db);
-	if (err != SQLITE_OK) {
-		connman_error("Can't open database: %s", sqlite3_errmsg(db));
-		sqlite3_close(db);
-		return -1;
-	}
+	g_key_file_set_boolean(keyfile, element->path, "Enabled",
+							element->enabled);
 
-	create_tables();
-#endif
+	connman_element_lock(element);
 
-	return 0;
-}
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
 
-void __connman_storage_cleanup(void)
-{
-#if 0
-	DBG("");
+		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
+			continue;
 
-	sqlite3_close(db);
-#endif
-}
+		if (property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)
+			continue;
 
-int __connman_element_load(struct connman_element *element)
-{
-	return 0;
+		if (property->type == DBUS_TYPE_STRING)
+			g_key_file_set_string(keyfile, element->path,
+					property->name, property->value);
+	}
+
+	connman_element_unlock(element);
 }
 
 int __connman_element_store(struct connman_element *element)
 {
-#if 0
-	char *sql, *msg;
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
 
-	DBG("");
+	DBG("element %p name %s", element, element->name);
+
+	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
 
-	if (element->priority > 0) {
-		sql = g_strdup_printf("INSERT INTO properties "
-						"VALUES ('%s','%s','%d')",
-						element->path, "Priority",
-							element->priority);
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
+		goto update;
 
-		if (sqlite3_exec(db, sql, NULL, NULL, &msg) != SQLITE_OK) {
-			connman_error("SQL error: %s", msg);
-			sqlite3_free(msg);
-		}
+	if (length > 0) {
+		if (g_key_file_load_from_data(keyfile, data, length,
+				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+			goto done;
 	}
-#endif
+
+	g_free(data);
+
+update:
+	do_update(keyfile, element);
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents(pathname, data, length, NULL);
+
+done:
+	g_free(data);
+
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
 
 	return 0;
 }

commit e70b5588ad0e2fab7139ea1cddd9ce6074cc7305
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 07:50:02 2008 +0100

    Remove check for SQLite libraries

diff --git a/configure.ac b/configure.ac
index 11078965..9c6259f4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -81,10 +81,6 @@ AC_SUBST(POLKIT_CFLAGS)
 AC_SUBST(POLKIT_LIBS)
 AM_CONDITIONAL(POLKIT, test "${polkit_found}" = "yes")
 
-PKG_CHECK_MODULES(SQLITE, sqlite3, sqlite_found=yes, sqlite_found=no)
-AC_SUBST(SQLITE_CFLAGS)
-AC_SUBST(SQLITE_LIBS)
-
 AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
 			[enable fake plugin]), [enable_fake=${enableval}])
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")

commit f085a666cb8dbaa8aa81d5eeec50cece0009cfa6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 07:54:59 2008 +0100

    Remove HAL device detection support

diff --git a/configure.ac b/configure.ac
index 9c6259f4..c3e4f7f1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -69,13 +69,6 @@ AC_SUBST(DBUS_LIBS)
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
 AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 
-PKG_CHECK_MODULES(HAL, hal >= 0.5.8, hal_found=yes, hal_found=no)
-AC_SUBST(HAL_CFLAGS)
-AC_SUBST(HAL_LIBS)
-AC_ARG_ENABLE(hal, AC_HELP_STRING([--enable-hal],
-			[enable HAL plugin]), [enable_hal=${enableval}])
-AM_CONDITIONAL(HAL, test "${enable_hal}" = "yes" && test "${hal_found}" = "yes")
-
 PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, polkit_found=yes, polkit_found=no)
 AC_SUBST(POLKIT_CFLAGS)
 AC_SUBST(POLKIT_LIBS)
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index c296aa1c..ef5a82dd 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -27,14 +27,6 @@ resolvfile_la_SOURCES = resolvfile.c
 
 rtnllink_la_SOURCES = rtnllink.c inet.h inet.c
 
-if HAL
-plugin_LTLIBRARIES += hal.la
-
-hal_la_SOURCES = hal.c
-hal_la_LIBADD = @HAL_LIBS@
-hal_la_CFLAGS = @GLIB_CFLAGS@ @HAL_CFLAGS@
-endif
-
 if POLKIT
 plugin_LTLIBRARIES += polkit.la
 
diff --git a/plugins/hal.c b/plugins/hal.c
deleted file mode 100644
index 12d67ef0..00000000
--- a/plugins/hal.c
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/stat.h>
-
-#include <dbus/dbus.h>
-#include <hal/libhal.h>
-
-#include <connman/plugin.h>
-#include <connman/element.h>
-#include <connman/log.h>
-
-static struct {
-	const char *name;
-	enum connman_element_subtype subtype;
-} capabilities[] = {
-	{ "net.80203", CONNMAN_ELEMENT_SUBTYPE_ETHERNET },
-	{ "net.80211", CONNMAN_ELEMENT_SUBTYPE_WIFI     },
-	{ "net.wimax", CONNMAN_ELEMENT_SUBTYPE_WIMAX    },
-	{ "modem",     CONNMAN_ELEMENT_SUBTYPE_MODEM    },
-	{ }
-};
-
-static GStaticMutex element_mutex = G_STATIC_MUTEX_INIT;
-static GSList *element_list = NULL;
-
-static void device_info(LibHalContext *ctx, const char *udi,
-					struct connman_element *element)
-{
-	char *parent, *subsys, *value;
-
-	parent = libhal_device_get_property_string(ctx, udi,
-						"info.parent", NULL);
-
-	subsys = libhal_device_get_property_string(ctx, udi,
-						"linux.subsystem", NULL);
-
-	value = libhal_device_get_property_string(ctx, udi,
-						"info.linux.driver", NULL);
-	if (value == NULL) {
-		value = libhal_device_get_property_string(ctx, parent,
-						"info.linux.driver", NULL);
-		if (value != NULL)
-			connman_element_add_static_property(element,
-					"Driver", DBUS_TYPE_STRING, &value);
-	}
-
-	if (g_str_equal(subsys, "net") == TRUE ||
-					g_str_equal(subsys, "tty") == TRUE) {
-		value = libhal_device_get_property_string(ctx, parent,
-							"info.vendor", NULL);
-		if (value != NULL)
-			connman_element_add_static_property(element,
-					"Vendor", DBUS_TYPE_STRING, &value);
-
-		value = libhal_device_get_property_string(ctx, parent,
-							"info.product", NULL);
-		if (value != NULL)
-			connman_element_add_static_property(element,
-					"Product", DBUS_TYPE_STRING, &value);
-	}
-}
-
-static void device_netdev(LibHalContext *ctx, const char *udi,
-					struct connman_element *element)
-{
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_ETHERNET ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX) {
-		element->index = libhal_device_get_property_int(ctx,
-						udi, "net.linux.ifindex", NULL);
-
-		element->name = libhal_device_get_property_string(ctx,
-						udi, "net.interface", NULL);
-	}
-
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_MODEM) {
-		element->index = libhal_device_get_property_int(ctx,
-						udi, "serial.port", NULL);
-
-		element->name = libhal_device_get_property_string(ctx,
-						udi, "serial.device", NULL);
-	}
-}
-
-static void create_element(LibHalContext *ctx, const char *udi,
-					enum connman_element_subtype subtype)
-{
-	struct connman_element *element;
-
-	DBG("ctx %p udi %s", ctx, udi);
-
-	if (subtype == CONNMAN_ELEMENT_SUBTYPE_ETHERNET) {
-		char *sysfs_path, wimax_path[PATH_MAX];
-		struct stat st;
-
-		sysfs_path = libhal_device_get_property_string(ctx, udi,
-						"linux.sysfs_path", NULL);
-		if (sysfs_path != NULL) {
-			snprintf(wimax_path, PATH_MAX, "%s/wimax", sysfs_path);
-
-			if (stat(wimax_path, &st) == 0 &&
-						(st.st_mode & S_IFDIR))
-				subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
-		}
-	}
-
-	element = connman_element_create(NULL);
-
-	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	element->subtype = subtype;
-
-	device_info(ctx, udi, element);
-	device_netdev(ctx, udi, element);
-
-	if (element->name == NULL) {
-		element->name = g_path_get_basename(udi);
-		if (element->name == NULL) {
-			connman_element_unref(element);
-			return;
-		}
-	}
-
-	g_static_mutex_lock(&element_mutex);
-
-	connman_element_register(element, NULL);
-
-	element_list = g_slist_append(element_list, element);
-
-	g_static_mutex_unlock(&element_mutex);
-}
-
-static void device_added(LibHalContext *ctx, const char *udi)
-{
-	int i;
-
-	DBG("ctx %p udi %s", ctx, udi);
-
-	for (i = 0; capabilities[i].name; i++) {
-		if (libhal_device_query_capability(ctx, udi,
-					capabilities[i].name, NULL) == TRUE)
-			create_element(ctx, udi, capabilities[i].subtype);
-	}
-}
-
-static void device_removed(LibHalContext *ctx, const char *udi)
-{
-	struct connman_element *removal = NULL;
-	GSList *list;
-	gchar *name;
-
-	DBG("ctx %p udi %s", ctx, udi);
-
-	name = g_path_get_basename(udi);
-
-	g_static_mutex_lock(&element_mutex);
-
-	for (list = element_list; list; list = list->next) {
-		struct connman_element *element = list->data;
-
-		if (g_str_equal(element->name, name) == TRUE) {
-			removal = element;
-			break;
-		}
-	}
-
-	if (removal != NULL) {
-		element_list = g_slist_remove(element_list, removal);
-
-		connman_element_unregister(removal);
-		connman_element_unref(removal);
-	}
-
-	g_static_mutex_unlock(&element_mutex);
-
-	g_free(name);
-}
-
-static void probe_capability(LibHalContext *ctx, const char *capability,
-					enum connman_element_subtype subtype)
-{
-	char **list;
-	int num;
-
-	DBG("ctx %p capability %s", ctx, capability);
-
-	list = libhal_find_device_by_capability(ctx, capability, &num, NULL);
-	if (list) {
-		char **tmp = list;
-
-		while (*tmp) {
-			create_element(ctx, *tmp, subtype);
-			tmp++;
-		}
-
-		libhal_free_string_array(list);
-	}
-}
-
-static void find_devices(LibHalContext *ctx)
-{
-	int i;
-
-	DBG("ctx %p", ctx);
-
-	for (i = 0; capabilities[i].name; i++)
-		probe_capability(ctx, capabilities[i].name,
-						capabilities[i].subtype);
-}
-
-static LibHalContext *hal_ctx = NULL;
-
-static void libhal_init(void *data)
-{
-	DBusConnection *conn = data;
-
-	DBG("conn %p", conn);
-
-	if (hal_ctx != NULL)
-		return;
-
-	hal_ctx = libhal_ctx_new();
-	if (hal_ctx == NULL)
-		return;
-
-	if (libhal_ctx_set_dbus_connection(hal_ctx, conn) == FALSE) {
-		libhal_ctx_free(hal_ctx);
-		return;
-	}
-
-	if (libhal_ctx_init(hal_ctx, NULL) == FALSE) {
-		libhal_ctx_free(hal_ctx);
-		return ;
-	}
-
-	libhal_ctx_set_device_added(hal_ctx, device_added);
-	libhal_ctx_set_device_removed(hal_ctx, device_removed);
-
-	//libhal_ctx_set_device_new_capability(hal_ctx, new_capability);
-	//libhal_ctx_set_device_lost_capability(hal_ctx, lost_capability);
-
-	find_devices(hal_ctx);
-}
-
-static void libhal_cleanup(void *data)
-{
-	DBusConnection *conn = data;
-	GSList *list;
-
-	DBG("conn %p", conn);
-
-	g_static_mutex_lock(&element_mutex);
-
-	for (list = element_list; list; list = list->next) {
-		struct connman_element *element = list->data;
-
-		connman_element_unregister(element);
-		connman_element_unref(element);
-	}
-
-	g_slist_free(element_list);
-	element_list = NULL;
-
-	g_static_mutex_unlock(&element_mutex);
-
-	if (hal_ctx == NULL)
-		return;
-
-	libhal_ctx_shutdown(hal_ctx, NULL);
-
-	libhal_ctx_free(hal_ctx);
-
-	hal_ctx = NULL;
-}
-
-static int hal_init(void)
-{
-	DBusConnection *conn;
-
-	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
-	if (conn == NULL)
-		return -EIO;
-
-	libhal_init(conn);
-
-	return 0;
-}
-
-static void hal_exit(void)
-{
-	DBusConnection *conn;
-
-	conn = libhal_ctx_get_dbus_connection(hal_ctx);
-	if (conn == NULL)
-		return;
-
-	libhal_cleanup(conn);
-
-	dbus_connection_unref(conn);
-}
-
-CONNMAN_PLUGIN_DEFINE("hal", "Hardware detection plugin", VERSION,
-							hal_init, hal_exit)

commit def315a906d282938698e7cdb938c54e7a344988
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 07:57:22 2008 +0100

    Neither HAL nor SQLite are used anymore

diff --git a/README b/README
index c5a84833..0f473ffa 100644
--- a/README
+++ b/README
@@ -11,8 +11,6 @@ In order to compile Connection Manager you need following software packages:
 	- GCC compiler
 	- GLib library
 	- D-Bus library
-	- HAL library (optional)
-	- SQLite3 library (optional)
 	- PolicyKit (optional)
 
 To configure run:

commit b7580c03be552675c19b9096b4094eecf1076c70
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 09:27:20 2008 +0100

    Update manager interface documentation

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 03b39a5c..ac00c654 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -1,46 +1,55 @@
 Manager hierarchy
-*****************
+=================
 
-Service name	org.moblin.connman
-Interface name	org.moblin.connman.Manager
+Service		org.moblin.connman
+Interface	org.moblin.connman.Manager
 Object path	/
 
-Methods		array{object} ListElements()
+Methods		dict GetProperties()
+
+			Returns all global system properties. See the
+			properties section for available properties.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+		void SetProperty(string name, variant value)
+
+			Changes the value of the specified property. Only
+			properties that are listed as read-write are
+			changeable. On success a PropertyChanged signal
+			will be emitted.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
 		void RegisterAgent(object path)
+
+			Register new agent for handling user requests.
+
+			Possible Errors: [service].Error.InvalidArguments
+
 		void UnregisterAgent(object path)
 
-Signals		ElementAdded(object)
-		ElementRemoved(object)
-
-
-Method: ListElements
-====================
-This method lists all available interfaces. The return value is an array of
-object paths. Every attached network interface (eth0, wlan0 etc.) of the
-system is presented by an object path with additional interfaces on it. The
-main interface is org.freedesktop.connman.Interface.
-
-Method: RegisterAgent
-=====================
-This method allows the user interace to register an agent. There can be only
-one agent registered at a time. The parameter of the method is the object
-path the agent has been registered for the callback method. The agent has
-to implement org.moblin.connman.Agent interface on this object path.
-
-Method: UnregisterAgent
-=======================
-This method unregisters a previously registered agent. In case the agent
-application exits the core will automatically unregister the agent. However
-for a clean agent application it is important to call the unregister method.
-
-Signal: ElementAdded
-====================
-This signal is emitted every time a new element has been added by the
-core and successfully activated. The signal is also emitted on startup
-or at anytime at runtime in case of hotplug devices.
-
-Signal: ElementRemoved
-======================
-This signal is emitted every time an element has been removed. This can
-happen at any time in case of hotplug devices. When the system shuts down,
-this signal is also emitted.
+			Unregister an existing agent.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+Signals		PropertyChanged(string name, variant value)
+
+			This signal indicates a changed value of the given
+			property.
+
+Properties	string State [readonly]
+
+			The global connection state of a system. Possible
+			values are "online" if at least one connection exists
+			and "offline" if no device is connected.
+
+		array{object} Devices [readonly]
+
+			List of device object paths.
+
+		array{object} Connections [readonly]
+
+			List of active connection object paths.

commit 45c42779987d8e03732f571ef2b454c0f4c9abce
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 09:28:06 2008 +0100

    Add device interface documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 92d9540e..6d351164 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -48,6 +48,7 @@ EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
 EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
-		dbus-manager.xml
+						dbus-manager.xml
 
-EXTRA_DIST += manager-api.txt element-api.txt agent-api.txt plugin-api.txt
+EXTRA_DIST += manager-api.txt device-api.txt \
+				element-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/device-api.txt b/doc/device-api.txt
new file mode 100644
index 00000000..a7aa60eb
--- /dev/null
+++ b/doc/device-api.txt
@@ -0,0 +1,52 @@
+Device hierarchy
+================
+
+Service		org.moblin.connman
+Interface	org.moblin.connman.Device
+Object path	[variable prefix]/{device0,device1,...}
+
+Methods		dict GetProperties()
+
+			Returns properties for the device objects. See
+			the properties section for available properties.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+		void SetProperty(string name, variant value)
+
+			Changes the value of the specified property. Only
+			properties that are listed as read-write are
+			changeable. On success a PropertyChanged signal
+			will be emitted.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+Signals		PropertyChanged(string name, variant value)
+
+			This signal indicates a changed value of the given
+			property.
+
+Properties	string Name [readonly]
+
+			The device name (for example eth0, wlan0 etc.)
+
+		boolean Powered [readwrite]
+
+			Switch a device on or off. This will also modify
+			the list of networks in range. All known networks
+			will be still available via the Networks property.
+
+		boolean Scanning [readonly]
+
+			Indicates if a device is scanning. Not all device
+			types might support this. Also some hardware might
+			execute background scanning without notifying the
+			driver about it. Use this property only for visual
+			indication.
+
+		array{object} Networks [readonly]
+
+			List of networks objects paths. Every object path
+			represents a network in range or a known network.

commit 2d5ab53c5c005439464c684ed3402d81598c5aea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 10:15:25 2008 +0100

    Use properties for profiles, devices and connections

diff --git a/src/manager.c b/src/manager.c
index d4098dae..a9a52eab 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,10 +27,10 @@
 
 #include "connman.h"
 
-static void append_elements(DBusMessageIter *dict)
+static void append_devices(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
-	const char *key = "Elements";
+	const char *key = "Devices";
 
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
@@ -44,7 +44,59 @@ static void append_elements(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_UNKNOWN, &iter);
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static void append_connections(DBusMessageIter *dict)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "Connections";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_INTERNET, &iter);
+
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static void append_profiles(DBusMessageIter *dict)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "Profiles";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_profile_list(&iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -72,7 +124,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	append_elements(&dict);
+	append_profiles(&dict);
+
+	append_devices(&dict);
+	append_connections(&dict);
 
 	dbus_message_iter_close_container(&array, &dict);
 
@@ -127,30 +182,6 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *list_profiles(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	DBusMessage *reply;
-	DBusMessageIter array, iter;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
-	__connman_profile_list(&iter);
-
-	dbus_message_iter_close_container(&array, &iter);
-
-	return reply;
-}
-
 static DBusMessage *list_elements(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -179,7 +210,6 @@ static GDBusMethodTable manager_methods[] = {
 	{ "GetProperties",   "",  "a{sv}", get_properties   },
 	{ "RegisterAgent",   "o", "",      register_agent   },
 	{ "UnregisterAgent", "o", "",      unregister_agent },
-	{ "ListProfiles",    "",  "ao",    list_profiles    },
 	{ "ListElements",    "",  "ao",    list_elements    },
 	{ },
 };
diff --git a/test/list-devices b/test/list-devices
index 3c1b82e9..d7b9331d 100755
--- a/test/list-devices
+++ b/test/list-devices
@@ -7,15 +7,13 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
+for path in properties["Devices"]:
 	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Element")
 
 	properties = element.GetProperties()
-	if (properties["Type"] != "device"):
-		continue
 
 	print "[ %s ]" % (path)
 
diff --git a/test/list-profiles b/test/list-profiles
index fcf1830c..025f3cf1 100755
--- a/test/list-profiles
+++ b/test/list-profiles
@@ -7,9 +7,9 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-profiles = manager.ListProfiles()
+properties = manager.GetProperties()
 
-for path in profiles:
+for path in properties["Profiles"]:
 	print "[ %s ]" % (path)
 
 	element = dbus.Interface(bus.get_object("org.moblin.connman", path),

commit 554454d3008035e0df46a20909d796b5f7813ce5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 10:16:33 2008 +0100

    Add entry for profile list property

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index ac00c654..8ef43596 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -46,6 +46,10 @@ Properties	string State [readonly]
 			values are "online" if at least one connection exists
 			and "offline" if no device is connected.
 
+		array{object} Profiles [readonly]
+
+			List of profile object paths.
+
 		array{object} Devices [readonly]
 
 			List of device object paths.

commit a5d0c184434c2d4385aa69a0de703fe0eb06b6e2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 10:21:19 2008 +0100

    Add global state property

diff --git a/src/manager.c b/src/manager.c
index a9a52eab..a4571fbc 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,10 +27,10 @@
 
 #include "connman.h"
 
-static void append_devices(DBusMessageIter *dict)
+static void append_profiles(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
-	const char *key = "Devices";
+	const char *key = "Profiles";
 
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
@@ -44,7 +44,7 @@ static void append_devices(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+	__connman_profile_list(&iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -53,10 +53,10 @@ static void append_devices(DBusMessageIter *dict)
 	dbus_message_iter_close_container(dict, &entry);
 }
 
-static void append_connections(DBusMessageIter *dict)
+static void append_devices(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
-	const char *key = "Connections";
+	const char *key = "Devices";
 
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
@@ -70,7 +70,7 @@ static void append_connections(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_INTERNET, &iter);
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -79,10 +79,10 @@ static void append_connections(DBusMessageIter *dict)
 	dbus_message_iter_close_container(dict, &entry);
 }
 
-static void append_profiles(DBusMessageIter *dict)
+static void append_connections(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
-	const char *key = "Profiles";
+	const char *key = "Connections";
 
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
@@ -96,7 +96,7 @@ static void append_profiles(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_profile_list(&iter);
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_INTERNET, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -105,6 +105,26 @@ static void append_profiles(DBusMessageIter *dict)
 	dbus_message_iter_close_container(dict, &entry);
 }
 
+static void append_state(DBusMessageIter *dict, const char *state)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "State";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_STRING_AS_STRING, &value);
+
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, &state);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -129,6 +149,8 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	append_devices(&dict);
 	append_connections(&dict);
 
+	append_state(&dict, "offline");
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;

commit 80ef1286cda5b5ec2ec48f0572a2909ad80c06b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 19 10:22:05 2008 +0100

    Add script for testing manager interface

diff --git a/test/test-manager b/test/test-manager
new file mode 100755
index 00000000..d06391fc
--- /dev/null
+++ b/test/test-manager
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+def print_list(key, value):
+	text = ""
+	for path in value:
+		text = text + str(path)
+	print "%s = %s" % (key, text)
+
+for key in properties.keys():
+	if (key in ["Profiles", "Devices", "Connections"]):
+		print_list(key, properties[key])
+	else:
+		print "%s = %s" % (key, properties[key])

commit 6578ac5c8229d509af2347a77f806e6818599518
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 11:12:59 2008 +0100

    Don't detect WiFi and Bluetooth devices anymore

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index 5ca96350..14bb3437 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -88,13 +88,13 @@ static void rtnllink_newlink(unsigned short type, int index,
 		sk = socket(PF_INET, SOCK_DGRAM, 0);
 
 		if (g_str_has_prefix(name, "bnep") == TRUE)
-			subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
 		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
-			subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 		else
 			subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
 

commit 27cd15d89ec7755c78bd149d0b026c5b595a19f5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 12:25:22 2008 +0100

    Remove unused variable

diff --git a/src/manager.c b/src/manager.c
index a4571fbc..9de73e0b 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -107,7 +107,7 @@ static void append_connections(DBusMessageIter *dict)
 
 static void append_state(DBusMessageIter *dict, const char *state)
 {
-	DBusMessageIter entry, value, iter;
+	DBusMessageIter entry, value;
 	const char *key = "State";
 
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,

commit 3c5f31a95d29fd46f9b7907d75721eb9b3d820b9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 12:25:46 2008 +0100

    Add function for checking if a service is present

diff --git a/gdbus/gdbus.h b/gdbus/gdbus.h
index 818a36f7..e0d653a5 100644
--- a/gdbus/gdbus.h
+++ b/gdbus/gdbus.h
@@ -43,6 +43,8 @@ DBusConnection *g_dbus_setup_bus(DBusBusType type, const char *name,
 gboolean g_dbus_request_name(DBusConnection *connection, const char *name,
 							DBusError *error);
 
+gboolean g_dbus_check_service(DBusConnection *connection, const char *name);
+
 gboolean g_dbus_set_disconnect_function(DBusConnection *connection,
 				GDBusWatchFunction function,
 				void *user_data, DBusFreeFunction destroy);
diff --git a/gdbus/mainloop.c b/gdbus/mainloop.c
index d38bd637..9e493268 100644
--- a/gdbus/mainloop.c
+++ b/gdbus/mainloop.c
@@ -281,6 +281,49 @@ gboolean g_dbus_request_name(DBusConnection *connection, const char *name,
 	return TRUE;
 }
 
+gboolean g_dbus_check_service(DBusConnection *connection, const char *name)
+{
+	DBusMessage *message, *reply;
+	const char **names;
+	int i, count;
+	gboolean result = FALSE;
+
+	message = dbus_message_new_method_call(DBUS_SERVICE_DBUS,
+			DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "ListNames");
+	if (message == NULL) {
+		error("Can't allocate new message");
+		return FALSE;
+	}
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, NULL);
+
+	dbus_message_unref(message);
+
+	if (reply == NULL) {
+		error("Failed to execute method call");
+		return FALSE;
+	}
+
+	if (dbus_message_get_args(reply, NULL,
+				DBUS_TYPE_ARRAY, DBUS_TYPE_STRING,
+				&names, &count, DBUS_TYPE_INVALID) == FALSE) {
+		error("Failed to read name list");
+		goto done;
+	}
+
+	for (i = 0; i < count; i++)
+		if (g_str_equal(names[i], name) == TRUE) {
+			result = TRUE;
+			break;
+		}
+
+done:
+	dbus_message_unref(reply);
+
+	return result;
+}
+
 gboolean g_dbus_set_disconnect_function(DBusConnection *connection,
 				GDBusWatchFunction function,
 				void *user_data, DBusFreeFunction destroy)

commit bed9f7d567b9a22c3c833f3b40ecd5afdc06d873
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 12:28:29 2008 +0100

    Call connect function if service is present

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index d519ac92..6b0b69a0 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -87,6 +87,9 @@ static int bluetooth_init(void)
 		return -EIO;
 	}
 
+	if (g_dbus_check_service(connection, BLUEZ_SERVICE) == TRUE)
+		bluetooth_connect(connection, NULL);
+
 	return 0;
 }
 

commit 3ff2030313c116a4bf0421b0b0086e7c252e7ea4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:24:50 2008 +0100

    Add support for WiFi Security and Passphrase properties

diff --git a/include/element.h b/include/element.h
index fedc4079..96031db2 100644
--- a/include/element.h
+++ b/include/element.h
@@ -100,6 +100,11 @@ struct connman_element {
 		gchar *broadcast;
 		gchar *nameserver;
 	} ipv4;
+
+	struct {
+		gchar *security;
+		gchar *passphrase;
+	} wifi;
 };
 
 #define connman_element_lock(element)    g_static_mutex_lock(&(element)->mutex)
diff --git a/include/property.h b/include/property.h
index b8c86c9c..4c42f445 100644
--- a/include/property.h
+++ b/include/property.h
@@ -40,6 +40,9 @@ enum connman_property_id {
 	CONNMAN_PROPERTY_ID_IPV4_NETMASK,
 	CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
 	CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
+
+	CONNMAN_PROPERTY_ID_WIFI_SECURITY,
+	CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE,
 };
 
 /**
diff --git a/src/element.c b/src/element.c
index cb513ecf..3e2e0c3e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -61,6 +61,12 @@ static struct {
 		DBUS_TYPE_STRING, "IPv4.Gateway" },
 	{ CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 		DBUS_TYPE_STRING, "IPv4.Nameserver" },
+
+	{ CONNMAN_PROPERTY_ID_WIFI_SECURITY,
+		DBUS_TYPE_STRING, "WiFi.Security" },
+	{ CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE,
+		DBUS_TYPE_STRING, "WiFi.Passphrase" },
+
 	{ }
 };
 
@@ -212,6 +218,13 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "IPv4.Gateway",
 				DBUS_TYPE_STRING, &element->ipv4.gateway);
 
+	if (element->wifi.security != NULL)
+		connman_dbus_dict_append_variant(&dict, "WiFi.Security",
+				DBUS_TYPE_STRING, &element->wifi.security);
+	if (element->wifi.passphrase != NULL)
+		connman_dbus_dict_append_variant(&dict, "WiFi.Passphrase",
+				DBUS_TYPE_STRING, &element->wifi.passphrase);
+
 	connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
@@ -922,6 +935,18 @@ int connman_element_set_property(struct connman_element *element,
 		element->ipv4.nameserver = g_strdup(*((const char **) value));
 		connman_element_unlock(element);
 		break;
+	case CONNMAN_PROPERTY_ID_WIFI_SECURITY:
+		connman_element_lock(element);
+		g_free(element->wifi.security);
+		element->wifi.security = g_strdup(*((const char **) value));
+		connman_element_unlock(element);
+		break;
+	case CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE:
+		connman_element_lock(element);
+		g_free(element->wifi.passphrase);
+		element->wifi.passphrase = g_strdup(*((const char **) value));
+		connman_element_unlock(element);
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -973,6 +998,22 @@ int connman_element_get_value(struct connman_element *element,
 		*((char **) value) = element->ipv4.nameserver;
 		connman_element_unlock(element);
 		break;
+	case CONNMAN_PROPERTY_ID_WIFI_SECURITY:
+		if (element->wifi.security == NULL)
+			return connman_element_get_value(element->parent,
+								id, value);
+		connman_element_lock(element);
+		*((char **) value) = element->wifi.security;
+		connman_element_unlock(element);
+		break;
+	case CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE:
+		if (element->wifi.passphrase == NULL)
+			return connman_element_get_value(element->parent,
+								id, value);
+		connman_element_lock(element);
+		*((char **) value) = element->wifi.passphrase;
+		connman_element_unlock(element);
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1097,8 +1138,6 @@ int connman_element_register(struct connman_element *element,
 
 	connman_element_lock(element);
 
-	__connman_element_load(element);
-
 	if (element->name == NULL) {
 		element->name = g_strdup(type2string(element->type));
 		if (element->name == NULL) {
@@ -1213,6 +1252,8 @@ static void register_element(gpointer data, gpointer user_data)
 
 	DBG("element %p path %s", element, element->path);
 
+	__connman_element_load(element);
+
 	g_node_append_data(node, element);
 
 	if (g_dbus_register_interface(connection, element->path,
diff --git a/src/storage.c b/src/storage.c
index 24d0a5c8..06337c78 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -37,16 +37,67 @@ void __connman_storage_cleanup(void)
 	DBG("");
 }
 
+static int do_load(GKeyFile *keyfile, struct connman_element *element)
+{
+	const gchar *value;
+
+	DBG("element %p name %s", element, element->name);
+
+	value = g_key_file_get_string(keyfile, element->path,
+						"WiFi.Security", NULL);
+	if (value != NULL)
+		connman_element_set_property(element,
+				CONNMAN_PROPERTY_ID_WIFI_SECURITY, &value);
+
+	value = g_key_file_get_string(keyfile, element->path,
+						"WiFi.Passphrase", NULL);
+	if (value != NULL)
+		connman_element_set_property(element,
+				CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &value);
+
+	return 0;
+}
+
 int __connman_element_load(struct connman_element *element)
 {
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+
 	DBG("element %p name %s", element, element->name);
 
+	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE) {
+		g_free(pathname);
+		return -ENOENT;
+	}
+
+	g_free(pathname);
+
+	if (g_key_file_load_from_data(keyfile, data, length,
+							0, NULL) == FALSE) {
+		g_free(data);
+		return -EILSEQ;
+	}
+
+	g_free(data);
+
+	do_load(keyfile, element);
+
+	g_key_file_free(keyfile);
+
 	return 0;
 }
 
 static void do_update(GKeyFile *keyfile, struct connman_element *element)
 {
 	GSList *list;
+	char *value;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -72,6 +123,16 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 	}
 
 	connman_element_unlock(element);
+
+	if (connman_element_get_value(element,
+			CONNMAN_PROPERTY_ID_WIFI_SECURITY, &value) == 0)
+		g_key_file_set_string(keyfile, element->path,
+						"WiFi.Security", value);
+
+	if (connman_element_get_value(element,
+			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &value) == 0)
+		g_key_file_set_string(keyfile, element->path,
+						"WiFi.Passphrase", value);
 }
 
 int __connman_element_store(struct connman_element *element)
@@ -82,6 +143,10 @@ int __connman_element_store(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE &&
+				element->type != CONNMAN_ELEMENT_TYPE_NETWORK)
+		return -EINVAL;
+
 	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);
 	if (pathname == NULL)
 		return -ENOMEM;

commit f1a1f26fd469d0d536026020913d4f301de07f24
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:25:38 2008 +0100

    Detect wpa_supplicant service and WiFi devices

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 304ebba2..f175494e 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -23,13 +23,22 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <unistd.h>
 #include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+
 #include <gdbus.h>
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
+#include <connman/rtnl.h>
 #include <connman/log.h>
 
+#include "inet.h"
 #include "supplicant.h"
 
 struct wifi_data {
@@ -59,11 +68,11 @@ static int network_enable(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 
 	if (connman_element_get_static_property(element,
-					"Identifier", &identifier) == FALSE)
+					"WiFi.Name", &identifier) == FALSE)
 		return -EIO;
 
 	if (connman_element_get_static_array_property(element,
-					"SSID", &ssid, &ssid_len) == FALSE)
+				"WiFi.SSID", &ssid, &ssid_len) == FALSE)
 		return -EIO;
 
 	if (element->parent != NULL) {
@@ -75,6 +84,9 @@ static int network_enable(struct connman_element *element)
 		}
 	}
 
+	connman_element_get_value(element,
+			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &passphrase);
+
 	DBG("identifier %s passhprase %s", identifier, passphrase);
 
 	if (__supplicant_connect(element, ssid, ssid_len, passphrase) < 0)
@@ -113,7 +125,7 @@ static struct connman_element *find_element(struct wifi_data *data,
 		struct connman_element *element = list->data;
 
 		if (connman_element_match_static_property(element,
-					"Identifier", &identifier) == TRUE)
+					"WiFi.Name", &identifier) == TRUE)
 			return element;
 	}
 
@@ -189,10 +201,10 @@ static void scan_result(struct connman_element *parent,
 
 		data->list = g_slist_append(data->list, element);
 
-		connman_element_add_static_property(element, "Identifier",
+		connman_element_add_static_property(element, "WiFi.Name",
 				DBUS_TYPE_STRING, &network->identifier);
 
-		connman_element_add_static_array_property(element, "SSID",
+		connman_element_add_static_array_property(element, "WiFi.SSID",
 			DBUS_TYPE_BYTE, &network->ssid, network->ssid_len);
 
 		connman_element_register(element, parent);
@@ -299,14 +311,136 @@ static struct connman_driver wifi_driver = {
 	.disable	= wifi_disable,
 };
 
+static GStaticMutex device_mutex = G_STATIC_MUTEX_INIT;
+static GSList *device_list = NULL;
+
+static void wifi_newlink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	struct connman_element *device;
+	GSList *list;
+	gboolean exists = FALSE;
+	gchar *name;
+	struct iwreq iwr;
+	int sk;
+
+	DBG("index %d", index);
+
+	if (type != ARPHRD_ETHER)
+		return;
+
+	name = inet_index2name(index);
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_ifrn.ifrn_name, name, IFNAMSIZ);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+
+	if (ioctl(sk, SIOCGIWNAME, &iwr) < 0) {
+		g_free(name);
+		close(sk);
+		return;
+	}
+
+	close(sk);
+
+	g_static_mutex_lock(&device_mutex);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		if (device->index == index) {
+			exists = TRUE;
+			break;
+		}
+	}
+
+	g_static_mutex_unlock(&device_mutex);
+
+	if (exists == TRUE) {
+		g_free(name);
+		return;
+	}
+
+	device = connman_element_create(NULL);
+	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	device->subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+
+	device->index = index;
+	device->name = name;
+
+	g_static_mutex_lock(&device_mutex);
+
+	connman_element_register(device, NULL);
+	device_list = g_slist_append(device_list, device);
+
+	g_static_mutex_unlock(&device_mutex);
+}
+
+static void wifi_dellink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	GSList *list;
+
+	DBG("index %d", index);
+
+	g_static_mutex_lock(&device_mutex);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		if (device->index == index) {
+			device_list = g_slist_remove(device_list, device);
+			connman_element_unregister(device);
+			connman_element_unref(device);
+			break;
+		}
+	}
+
+	g_static_mutex_unlock(&device_mutex);
+}
+
+static struct connman_rtnl wifi_rtnl = {
+	.name		= "wifi",
+	.newlink	= wifi_newlink,
+	.dellink	= wifi_dellink,
+};
+
 static void supplicant_connect(DBusConnection *connection, void *user_data)
 {
 	DBG("connection %p", connection);
+
+	__supplicant_init(connection);
+
+	if (connman_rtnl_register(&wifi_rtnl) < 0)
+		return;
+
+	connman_rtnl_send_getlink();
 }
 
 static void supplicant_disconnect(DBusConnection *connection, void *user_data)
 {
+	GSList *list;
+
 	DBG("connection %p", connection);
+
+	connman_rtnl_unregister(&wifi_rtnl);
+
+	g_static_mutex_lock(&device_mutex);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		connman_element_unregister(device);
+		connman_element_unref(device);
+	}
+
+	g_slist_free(device_list);
+	device_list = NULL;
+
+	g_static_mutex_unlock(&device_mutex);
+
+	__supplicant_exit();
 }
 
 static DBusConnection *connection;
@@ -320,18 +454,8 @@ static int wifi_init(void)
 	if (connection == NULL)
 		return -EIO;
 
-	err = __supplicant_init(connection);
-	if (err < 0) {
-		dbus_connection_unref(connection);
-		return err;
-	}
-
-	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
-			supplicant_connect, supplicant_disconnect, NULL, NULL);
-
 	err = connman_driver_register(&network_driver);
 	if (err < 0) {
-		__supplicant_exit();
 		dbus_connection_unref(connection);
 		return err;
 	}
@@ -339,11 +463,16 @@ static int wifi_init(void)
 	err = connman_driver_register(&wifi_driver);
 	if (err < 0) {
 		connman_driver_unregister(&network_driver);
-		__supplicant_exit();
 		dbus_connection_unref(connection);
 		return err;
 	}
 
+	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
+			supplicant_connect, supplicant_disconnect, NULL, NULL);
+
+	if (g_dbus_check_service(connection, SUPPLICANT_NAME) == TRUE)
+		supplicant_connect(connection, NULL);
+
 	return 0;
 }
 
@@ -355,7 +484,7 @@ static void wifi_exit(void)
 	if (watch > 0)
 		g_dbus_remove_watch(connection, watch);
 
-	__supplicant_exit();
+	supplicant_disconnect(connection, NULL);
 
 	dbus_connection_unref(connection);
 }

commit 0e818d22e9122730882e9ee646b08a909d8f1ff1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:26:51 2008 +0100

    Use WiFi.Name property for network selection

diff --git a/test/select-network b/test/select-network
index afa287c5..76845469 100755
--- a/test/select-network
+++ b/test/select-network
@@ -25,6 +25,6 @@ for path in elements:
 	if (properties["Enabled"] == dbus.Boolean(1)):
 		continue
 
-	if (properties["Identifier"] == sys.argv[1]):
+	if (properties["WiFi.Name"] == sys.argv[1]):
 		print "Enabling %s" % (path)
 		element.Enable()

commit f120fa2ca1ed88f0394eb4bf286e4d2dca7e6863
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:29:33 2008 +0100

    Fix small spelling mistake

diff --git a/doc/device-api.txt b/doc/device-api.txt
index a7aa60eb..d0f850d3 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -7,7 +7,7 @@ Object path	[variable prefix]/{device0,device1,...}
 
 Methods		dict GetProperties()
 
-			Returns properties for the device objects. See
+			Returns properties for the device object. See
 			the properties section for available properties.
 
 			Possible Errors: [service].Error.InvalidArguments

commit b570627cf85d3231a1bdff90c6d7f07c015194d5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:36:22 2008 +0100

    Add API documentation for network interface

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 6d351164..636600fc 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -50,5 +50,5 @@ endif
 EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
 						dbus-manager.xml
 
-EXTRA_DIST += manager-api.txt device-api.txt \
+EXTRA_DIST += manager-api.txt device-api.txt network-api.txt \
 				element-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/network-api.txt b/doc/network-api.txt
new file mode 100644
index 00000000..eb7b40c4
--- /dev/null
+++ b/doc/network-api.txt
@@ -0,0 +1,60 @@
+Network hierarchy
+=================
+
+Service		org.moblin.connman
+Interface	org.moblin.connman.Network
+Object path	[variable prefix]/{network0,network1,...}
+
+Methods		dict GetProperties()
+
+			Returns properties for the network object. See
+			the properties section for available properties.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+		void SetProperty(string name, variant value)
+
+			Changes the value of the specified property. Only
+			properties that are listed as read-write are
+			changeable. On success a PropertyChanged signal
+			will be emitted.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+Signals		PropertyChanged(string name, variant value)
+
+			This signal indicates a changed value of the given
+			property.
+
+Properties	string WiFi.Name [readonly]
+
+			If the network type is WiFi, then this property is
+			present and contains the network name.
+
+		array{byte} WiFi.SSID [readonly]
+
+			If the network type is WiFi, then this property is
+			present and contains the binary SSID value.
+
+		string WiFi.Security [readonly, readwrite]
+
+			If the network type is WiFi, then this property is
+			present and contains the security method or key
+			management setting.
+
+			For scanned networks this value is read only, but in
+			case the network was manually created it is also
+			changeable.
+
+			Possible values are NONE, WPA and WPA2.
+
+		string WiFi.Passphrase [readwrite]
+
+			If the network type is WiFi and a passhrase is
+			requires, then this property is present and contains
+			the passphrase in clear text.
+
+			For system using PolicyKit, the access to this value
+			will be protected by the security policy.

commit 7ad970d62c732ed2e9738c595c7b5ebff15b211f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:44:22 2008 +0100

    Add Device interface to device elements

diff --git a/src/element.c b/src/element.c
index 3e2e0c3e..2ed2361e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -416,6 +416,18 @@ static GDBusSignalTable element_signals[] = {
 	{ },
 };
 
+static GDBusMethodTable device_methods[] = {
+	{ "GetProperties", "",   "a{sv}", get_properties },
+	{ "SetProperty",   "sv", "",      set_property   },
+	{ "ClearProperty", "s",  "",      clear_property },
+	{ },
+};
+
+static GDBusSignalTable device_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
 struct append_filter {
 	enum connman_element_type type;
 	DBusMessageIter *iter;
@@ -1260,7 +1272,16 @@ static void register_element(gpointer data, gpointer user_data)
 					CONNMAN_ELEMENT_INTERFACE,
 					element_methods, element_signals,
 					NULL, element, NULL) == FALSE)
-		connman_error("Failed to register %s", element->path);
+		connman_error("Failed to register %s element", element->path);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+		if (g_dbus_register_interface(connection, element->path,
+					CONNMAN_DEVICE_INTERFACE,
+					device_methods, device_signals,
+					NULL, element, NULL) == FALSE)
+			connman_error("Failed to register %s device",
+								element->path);
+	}
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
@@ -1321,6 +1342,10 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
+		g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_DEVICE_INTERFACE);
+
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_ELEMENT_INTERFACE);
 

commit a89acca04bf0010042806f157cc778ca21889387
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:44:59 2008 +0100

    Use correct interface name for device properties

diff --git a/test/list-devices b/test/list-devices
index d7b9331d..66af8bd3 100755
--- a/test/list-devices
+++ b/test/list-devices
@@ -11,7 +11,7 @@ properties = manager.GetProperties()
 
 for path in properties["Devices"]:
 	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
+						"org.moblin.connman.Device")
 
 	properties = element.GetProperties()
 

commit 0dd05b756d0d86aa90c2edcd6b5dc79e5eba87dd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:45:29 2008 +0100

    Fix D-Bus interface constants

diff --git a/include/dbus.h b/include/dbus.h
index 58b0e835..c1760e09 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -41,9 +41,7 @@ extern "C" {
 #define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
 #define CONNMAN_MANAGER_PATH       "/"
 
-#define CONNMAN_IFACE_INTERFACE    CONNMAN_SERVICE ".Interface"
-#define CONNMAN_IFACE_BASEPATH     "/interface"
-
+#define CONNMAN_DEVICE_INTERFACE   CONNMAN_SERVICE ".Device"
 #define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
 
 extern void connman_dbus_dict_append_array(DBusMessageIter *dict,

commit 48c33ec217373971a7ff411e50e64fcdc27c53a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:50:20 2008 +0100

    Use correct property for network name

diff --git a/test/list-networks b/test/list-networks
index c7998636..11726a82 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -23,4 +23,4 @@ for path in elements:
 			state = "*"
 		else:
 			state = " "
-		print "    %s %s" % (state, properties["SSID"])
+		print "    %s %s" % (state, properties["WiFi.Name"])

commit 987f2dbc1f6bd78a1d86ceddba997506d3786322
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:51:11 2008 +0100

    Show empty passphrase property if security value is present

diff --git a/src/element.c b/src/element.c
index 2ed2361e..d66c81b9 100644
--- a/src/element.c
+++ b/src/element.c
@@ -218,12 +218,18 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "IPv4.Gateway",
 				DBUS_TYPE_STRING, &element->ipv4.gateway);
 
-	if (element->wifi.security != NULL)
+	if (element->wifi.security != NULL) {
+		const char *passphrase = "";
+
 		connman_dbus_dict_append_variant(&dict, "WiFi.Security",
 				DBUS_TYPE_STRING, &element->wifi.security);
-	if (element->wifi.passphrase != NULL)
+
+		if (element->wifi.passphrase != NULL)
+			passphrase = element->wifi.passphrase;
+
 		connman_dbus_dict_append_variant(&dict, "WiFi.Passphrase",
-				DBUS_TYPE_STRING, &element->wifi.passphrase);
+				DBUS_TYPE_STRING, &passphrase);
+	}
 
 	connman_element_lock(element);
 

commit 20bcc97150c2f5e338aed4d442f623e5f07e9867
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 13:54:41 2008 +0100

    Add Network interface to network elements

diff --git a/src/element.c b/src/element.c
index d66c81b9..bfb21b56 100644
--- a/src/element.c
+++ b/src/element.c
@@ -429,8 +429,10 @@ static GDBusMethodTable device_methods[] = {
 	{ },
 };
 
-static GDBusSignalTable device_signals[] = {
-	{ "PropertyChanged", "sv" },
+static GDBusMethodTable network_methods[] = {
+	{ "GetProperties", "",   "a{sv}", get_properties },
+	{ "SetProperty",   "sv", "",      set_property   },
+	{ "ClearProperty", "s",  "",      clear_property },
 	{ },
 };
 
@@ -1283,12 +1285,21 @@ static void register_element(gpointer data, gpointer user_data)
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
 		if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_DEVICE_INTERFACE,
-					device_methods, device_signals,
+					device_methods, element_signals,
 					NULL, element, NULL) == FALSE)
 			connman_error("Failed to register %s device",
 								element->path);
 	}
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
+		if (g_dbus_register_interface(connection, element->path,
+					CONNMAN_NETWORK_INTERFACE,
+					network_methods, element_signals,
+					NULL, element, NULL) == FALSE)
+			connman_error("Failed to register %s network",
+								element->path);
+	}
+
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
@@ -1348,6 +1359,10 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
+		g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_NETWORK_INTERFACE);
+
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_DEVICE_INTERFACE);

commit bcc3aaca389f898bba79c79a0190bf642d6839bd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 14:42:53 2008 +0100

    Add Type property to device interface

diff --git a/doc/device-api.txt b/doc/device-api.txt
index d0f850d3..d50a6c5f 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -32,6 +32,10 @@ Properties	string Name [readonly]
 
 			The device name (for example eth0, wlan0 etc.)
 
+		string Type [readonly]
+
+			The device type (for example ethernet, wifi etc.)
+
 		boolean Powered [readwrite]
 
 			Switch a device on or off. This will also modify

commit 7902a3d3825beb4c2b6d34e305e357173f4442b3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 14:43:53 2008 +0100

    Provide detailed device and network properties

diff --git a/src/element.c b/src/element.c
index bfb21b56..005626d5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -164,11 +164,53 @@ static void append_property(DBusMessageIter *dict,
 					property->type, &property->value);
 }
 
+static void add_common_properties(struct connman_element *element,
+						DBusMessageIter *dict)
+{
+	GSList *list;
+
+	if (element->priority > 0)
+		connman_dbus_dict_append_variant(dict, "Priority",
+					DBUS_TYPE_UINT16, &element->priority);
+
+	if (element->ipv4.address != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Address",
+				DBUS_TYPE_STRING, &element->ipv4.address);
+	if (element->ipv4.netmask != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Netmask",
+				DBUS_TYPE_STRING, &element->ipv4.netmask);
+	if (element->ipv4.gateway != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Gateway",
+				DBUS_TYPE_STRING, &element->ipv4.gateway);
+
+	if (element->wifi.security != NULL) {
+		const char *passphrase = "";
+
+		connman_dbus_dict_append_variant(dict, "WiFi.Security",
+				DBUS_TYPE_STRING, &element->wifi.security);
+
+		if (element->wifi.passphrase != NULL)
+			passphrase = element->wifi.passphrase;
+
+		connman_dbus_dict_append_variant(dict, "WiFi.Passphrase",
+				DBUS_TYPE_STRING, &passphrase);
+	}
+
+	connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		append_property(dict, property);
+	}
+
+	connman_element_unlock(element);
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
-	GSList *list;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
 	const char *str;
@@ -204,42 +246,73 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Enabled",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
-	if (element->priority > 0)
-		connman_dbus_dict_append_variant(&dict, "Priority",
-					DBUS_TYPE_UINT16, &element->priority);
+	add_common_properties(element, &dict);
 
-	if (element->ipv4.address != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Address",
-				DBUS_TYPE_STRING, &element->ipv4.address);
-	if (element->ipv4.netmask != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Netmask",
-				DBUS_TYPE_STRING, &element->ipv4.netmask);
-	if (element->ipv4.gateway != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Gateway",
-				DBUS_TYPE_STRING, &element->ipv4.gateway);
+	dbus_message_iter_close_container(&array, &dict);
 
-	if (element->wifi.security != NULL) {
-		const char *passphrase = "";
+	return reply;
+}
 
-		connman_dbus_dict_append_variant(&dict, "WiFi.Security",
-				DBUS_TYPE_STRING, &element->wifi.security);
+static DBusMessage *get_device_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *str;
 
-		if (element->wifi.passphrase != NULL)
-			passphrase = element->wifi.passphrase;
+	DBG("conn %p", conn);
 
-		connman_dbus_dict_append_variant(&dict, "WiFi.Passphrase",
-				DBUS_TYPE_STRING, &passphrase);
-	}
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
 
-	connman_element_lock(element);
+	dbus_message_iter_init_append(reply, &array);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-		append_property(&dict, property);
-	}
+	str = subtype2string(element->subtype);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
 
-	connman_element_unlock(element);
+	connman_dbus_dict_append_variant(&dict, "Powered",
+					DBUS_TYPE_BOOLEAN, &element->enabled);
+
+	add_common_properties(element, &dict);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static DBusMessage *get_network_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	connman_dbus_dict_append_variant(&dict, "Connected",
+					DBUS_TYPE_BOOLEAN, &element->enabled);
+
+	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);
 
@@ -423,16 +496,12 @@ static GDBusSignalTable element_signals[] = {
 };
 
 static GDBusMethodTable device_methods[] = {
-	{ "GetProperties", "",   "a{sv}", get_properties },
-	{ "SetProperty",   "sv", "",      set_property   },
-	{ "ClearProperty", "s",  "",      clear_property },
+	{ "GetProperties", "",   "a{sv}", get_device_properties },
 	{ },
 };
 
 static GDBusMethodTable network_methods[] = {
-	{ "GetProperties", "",   "a{sv}", get_properties },
-	{ "SetProperty",   "sv", "",      set_property   },
-	{ "ClearProperty", "s",  "",      clear_property },
+	{ "GetProperties", "",   "a{sv}", get_network_properties },
 	{ },
 };
 

commit 7c10a2705ad9b0949c29327922c1fdcddf87dac1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 14:46:37 2008 +0100

    Add constant for Connection interface

diff --git a/include/dbus.h b/include/dbus.h
index c1760e09..031d821b 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -28,21 +28,22 @@ extern "C" {
 
 #include <dbus/dbus.h>
 
-#define CONNMAN_SERVICE  "org.moblin.connman"
+#define CONNMAN_SERVICE			"org.moblin.connman"
 
-#define CONNMAN_ERROR_INTERFACE    CONNMAN_SERVICE ".Error"
+#define CONNMAN_ERROR_INTERFACE		CONNMAN_SERVICE ".Error"
 
-#define CONNMAN_AGENT_INTERFACE    CONNMAN_SERVICE ".Agent"
+#define CONNMAN_AGENT_INTERFACE		CONNMAN_SERVICE ".Agent"
 
-#define CONNMAN_ELEMENT_INTERFACE  CONNMAN_SERVICE ".Element"
+#define CONNMAN_ELEMENT_INTERFACE	CONNMAN_SERVICE ".Element"
 
-#define CONNMAN_PROFILE_INTERFACE  CONNMAN_SERVICE ".Profile"
+#define CONNMAN_PROFILE_INTERFACE	CONNMAN_SERVICE ".Profile"
 
-#define CONNMAN_MANAGER_INTERFACE  CONNMAN_SERVICE ".Manager"
-#define CONNMAN_MANAGER_PATH       "/"
+#define CONNMAN_MANAGER_INTERFACE	CONNMAN_SERVICE ".Manager"
+#define CONNMAN_MANAGER_PATH		"/"
 
-#define CONNMAN_DEVICE_INTERFACE   CONNMAN_SERVICE ".Device"
-#define CONNMAN_NETWORK_INTERFACE  CONNMAN_SERVICE ".Network"
+#define CONNMAN_DEVICE_INTERFACE	CONNMAN_SERVICE ".Device"
+#define CONNMAN_NETWORK_INTERFACE	CONNMAN_SERVICE ".Network"
+#define CONNMAN_CONNECTION_INTERFACE	CONNMAN_SERVICE ".Connection"
 
 extern void connman_dbus_dict_append_array(DBusMessageIter *dict,
 				const char *key, int type, void *val, int len);

commit e1530b2ba9dba6e2231dd5de39d73150266121f6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 14:50:56 2008 +0100

    Provide connection element and its interface

diff --git a/include/element.h b/include/element.h
index 96031db2..55f95937 100644
--- a/include/element.h
+++ b/include/element.h
@@ -57,7 +57,7 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 9,
 	CONNMAN_ELEMENT_TYPE_RESOLVER   = 10,
 
-	CONNMAN_ELEMENT_TYPE_INTERNET   = 42,
+	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
 };
 
 enum connman_element_subtype {
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 814bbeb7..f81d1062 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -68,7 +68,7 @@ static int resolvconf_probe(struct connman_element *element)
 
 	internet = connman_element_create(NULL);
 
-	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
+	internet->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
 
 	connman_element_register(internet, element);
 
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index 0920441c..54ad41b3 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -65,7 +65,7 @@ static int resolvfile_probe(struct connman_element *element)
 
 	internet = connman_element_create(NULL);
 
-	internet->type = CONNMAN_ELEMENT_TYPE_INTERNET;
+	internet->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
 
 	connman_element_register(internet, element);
 
diff --git a/src/element.c b/src/element.c
index 005626d5..d3040cce 100644
--- a/src/element.c
+++ b/src/element.c
@@ -119,8 +119,8 @@ static const char *type2string(enum connman_element_type type)
 		return "zeroconf";
 	case CONNMAN_ELEMENT_TYPE_RESOLVER:
 		return "resolver";
-	case CONNMAN_ELEMENT_TYPE_INTERNET:
-		return "internet";
+	case CONNMAN_ELEMENT_TYPE_CONNECTION:
+		return "connection";
 	}
 
 	return NULL;
@@ -319,6 +319,33 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *get_connection_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	add_common_properties(element, &dict);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -505,6 +532,11 @@ static GDBusMethodTable network_methods[] = {
 	{ },
 };
 
+static GDBusMethodTable connection_methods[] = {
+	{ "GetProperties", "",   "a{sv}", get_connection_properties },
+	{ },
+};
+
 struct append_filter {
 	enum connman_element_type type;
 	DBusMessageIter *iter;
@@ -1369,6 +1401,15 @@ static void register_element(gpointer data, gpointer user_data)
 								element->path);
 	}
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
+		if (g_dbus_register_interface(connection, element->path,
+					CONNMAN_CONNECTION_INTERFACE,
+					connection_methods, element_signals,
+					NULL, element, NULL) == FALSE)
+			connman_error("Failed to register %s connection",
+								element->path);
+	}
+
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
@@ -1428,6 +1469,10 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION)
+		g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_CONNECTION_INTERFACE);
+
 	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);
diff --git a/src/manager.c b/src/manager.c
index 9de73e0b..58f29829 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -96,7 +96,7 @@ static void append_connections(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_INTERNET, &iter);
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 

commit 3b665a3511198458b350528d800c5a8e875e586b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 15:04:32 2008 +0100

    Fix value of global state property

diff --git a/src/connman.h b/src/connman.h
index 8bacda60..7b7cc5e5 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -74,6 +74,7 @@ void __connman_element_cleanup(void);
 
 void __connman_element_list(enum connman_element_type type,
 						DBusMessageIter *iter);
+int __connman_element_count(enum connman_element_type type);
 
 const char *__connman_element_type2string(enum connman_element_type type);
 const char *__connman_element_subtype2string(enum connman_element_subtype type);
diff --git a/src/element.c b/src/element.c
index d3040cce..58b600e1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -542,10 +542,10 @@ struct append_filter {
 	DBusMessageIter *iter;
 };
 
-static gboolean append_path(GNode *node, gpointer data)
+static gboolean append_path(GNode *node, gpointer user_data)
 {
 	struct connman_element *element = node->data;
-	struct append_filter *filter = data;
+	struct append_filter *filter = user_data;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -575,6 +575,44 @@ void __connman_element_list(enum connman_element_type type,
 	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
+struct count_data {
+	enum connman_element_type type;
+	int count;
+};
+
+static gboolean count_element(GNode *node, gpointer user_data)
+{
+	struct connman_element *element = node->data;
+	struct count_data *data = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return FALSE;
+
+	if (data->type != CONNMAN_ELEMENT_TYPE_UNKNOWN &&
+					data->type != element->type)
+		return FALSE;
+
+	data->count++;
+
+	return FALSE;
+}
+
+int __connman_element_count(enum connman_element_type type)
+{
+	struct count_data data = { type, 0 };
+
+	DBG("");
+
+	g_static_rw_lock_reader_lock(&element_lock);
+	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+							count_element, &data);
+	g_static_rw_lock_reader_unlock(&element_lock);
+
+	return data.count;
+}
+
 static gint compare_priority(gconstpointer a, gconstpointer b)
 {
 	const struct connman_driver *driver1 = a;
diff --git a/src/manager.c b/src/manager.c
index 58f29829..ddaf8fcd 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -149,7 +149,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	append_devices(&dict);
 	append_connections(&dict);
 
-	append_state(&dict, "offline");
+	if (__connman_element_count(CONNMAN_ELEMENT_TYPE_CONNECTION) > 0)
+		append_state(&dict, "online");
+	else
+		append_state(&dict, "offline");
 
 	dbus_message_iter_close_container(&array, &dict);
 

commit 1fed4a5ebc54427591c7f7eadee8d5b900c1d8fc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 15:08:37 2008 +0100

    Add test script for showing connection details

diff --git a/test/list-connections b/test/list-connections
new file mode 100755
index 00000000..806490db
--- /dev/null
+++ b/test/list-connections
@@ -0,0 +1,23 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Connections"]:
+	connection = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Connection")
+
+	properties = connection.GetProperties()
+
+	print "[ %s ]" % (path)
+
+	for key in properties.keys():
+		print "    %s = %s" % (key, properties[key])
+
+	print

commit aac1974061446a5e14133713e2d092fb211fd76b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 15:09:08 2008 +0100

    Use correct object name for device element

diff --git a/test/list-devices b/test/list-devices
index 66af8bd3..691a6fbe 100755
--- a/test/list-devices
+++ b/test/list-devices
@@ -10,10 +10,10 @@ manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 properties = manager.GetProperties()
 
 for path in properties["Devices"]:
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Device")
 
-	properties = element.GetProperties()
+	properties = device.GetProperties()
 
 	print "[ %s ]" % (path)
 

commit ca785efaf9500aada346a8155df568c44287a8e5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 15:15:45 2008 +0100

    Add Networks property to device elements

diff --git a/src/element.c b/src/element.c
index 58b600e1..17b43f52 100644
--- a/src/element.c
+++ b/src/element.c
@@ -253,6 +253,32 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static void append_networks(DBusMessageIter *dict)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "Networks";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
+
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
 static DBusMessage *get_device_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -282,6 +308,8 @@ static DBusMessage *get_device_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
+	append_networks(&dict);
+
 	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);

commit 5d5ab87764722fc33b10a331a9462c169a03bb6b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 15:16:21 2008 +0100

    Adapter test script to new network interface

diff --git a/test/list-networks b/test/list-networks
index 11726a82..94e111c4 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -7,20 +7,25 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
 
-	properties = element.GetProperties()
+	properties = device.GetProperties()
 
-	if (properties["Type"] == "device"):
-		print "[ %s ]" % (path)
+	print "[ %s ]" % (path)
 
-	if (properties["Type"] == "network"):
-		if (properties["Enabled"] == 1):
-			state = "*"
-		else:
-			state = " "
-		print "    %s %s" % (state, properties["WiFi.Name"])
+	for path in properties["Networks"]:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		print "    [ %s ]" % (path)
+
+		for key in properties.keys():
+			print "        %s = %s" % (key, properties[key])
+
+	print

commit a8c4558e731ce39e65afaf1e36c2b6fe05c758c4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 19:26:34 2008 +0100

    Add basic signals for changes of manager properties

diff --git a/src/element.c b/src/element.c
index 17b43f52..88f42d69 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1406,6 +1406,120 @@ int connman_element_set_enabled(struct connman_element *element,
 	return 0;
 }
 
+static void append_devices(DBusMessageIter *entry)
+{
+	DBusMessageIter value, iter;
+	const char *key = "Devices";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	//__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
+static void emit_devices_signal(DBusConnection *conn)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	DBG("conn %p", conn);
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_devices(&entry);
+
+	g_dbus_send_message(conn, signal);
+}
+
+static void append_connections(DBusMessageIter *entry)
+{
+	DBusMessageIter value, iter;
+	const char *key = "Connections";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+
+	//__connman_element_list(CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
+
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
+static void emit_connections_signal(DBusConnection *conn)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	DBG("conn %p", conn);
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_connections(&entry);
+
+	g_dbus_send_message(conn, signal);
+}
+
+static void append_state(DBusMessageIter *entry, const char *state)
+{
+	DBusMessageIter value;
+	const char *key = "State";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_STRING_AS_STRING, &value);
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &state);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
+static void emit_state_change(DBusConnection *conn, const char *state)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	DBG("conn %p", conn);
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_state(&entry, state);
+
+	g_dbus_send_message(conn, signal);
+}
+
 static void register_element(gpointer data, gpointer user_data)
 {
 	struct connman_element *element = data;
@@ -1456,6 +1570,8 @@ static void register_element(gpointer data, gpointer user_data)
 					NULL, element, NULL) == FALSE)
 			connman_error("Failed to register %s device",
 								element->path);
+		else
+			emit_devices_signal(connection);
 	}
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
@@ -1474,6 +1590,10 @@ static void register_element(gpointer data, gpointer user_data)
 					NULL, element, NULL) == FALSE)
 			connman_error("Failed to register %s connection",
 								element->path);
+		else {
+			emit_connections_signal(connection);
+			emit_state_change(connection, "online");
+		}
 	}
 
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
@@ -1535,17 +1655,24 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION)
+	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
+		emit_state_change(connection, "offline");
+		emit_connections_signal(connection);
+
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_CONNECTION_INTERFACE);
+	}
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE)
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+		emit_devices_signal(connection);
+
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_DEVICE_INTERFACE);
+	}
 
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_ELEMENT_INTERFACE);

commit cee78c8273f29cd829c630e6ec72abb50fadafec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 19:29:00 2008 +0100

    Remove old storage functions

diff --git a/src/iface-storage.c b/src/iface-storage.c
deleted file mode 100644
index 7aa64619..00000000
--- a/src/iface-storage.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <errno.h>
-#include <arpa/inet.h>
-
-#include <glib.h>
-
-#include "connman.h"
-
-#define GROUP_CONFIG  "Config"
-
-char *__connman_iface_find_passphrase(struct connman_iface *iface,
-							const char *network)
-{
-	GKeyFile *keyfile;
-	gchar *pathname, *result = NULL;
-	gchar **list;
-	gsize list_len;
-	int i;
-
-	if (iface->identifier == NULL)
-		return NULL;
-
-	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
-							iface->identifier);
-	if (pathname == NULL)
-		return NULL;
-
-	keyfile = g_key_file_new();
-
-	g_key_file_set_list_separator(keyfile, ',');
-
-	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
-		goto done;
-
-	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
-		goto done;
-
-	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
-					"KnownNetworks", &list_len, NULL);
-	for (i = 0; i < list_len; i++) {
-		if (g_str_equal(list[i], network) == TRUE) {
-			result = g_key_file_get_string(keyfile, network,
-								"PSK", NULL);
-			if (result == NULL)
-				result = g_strdup("");
-			break;
-		}
-	}
-
-	g_strfreev(list);
-
-done:
-	g_key_file_free(keyfile);
-
-	g_free(pathname);
-
-	return result;
-}
-
-int __connman_iface_load(struct connman_iface *iface)
-{
-	GKeyFile *keyfile;
-	gchar *pathname, *str;
-	gchar **list;
-	gsize list_len;
-
-	DBG("iface %p", iface);
-
-	if (iface->identifier == NULL)
-		return -EIO;
-
-	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
-							iface->identifier);
-	if (pathname == NULL)
-		return -ENOMEM;
-
-	keyfile = g_key_file_new();
-
-	g_key_file_set_list_separator(keyfile, ',');
-
-	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
-		goto done;
-
-	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
-		goto done;
-
-	str = g_key_file_get_string(keyfile, GROUP_CONFIG, "Policy", NULL);
-	if (str != NULL) {
-		iface->policy = __connman_iface_string2policy(str);
-		g_free(str);
-	}
-
-	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
-					"KnownNetworks", &list_len, NULL);
-
-	g_strfreev(list);
-
-	str = g_key_file_get_string(keyfile, GROUP_CONFIG,
-						"LastNetwork", NULL);
-	if (str != NULL) {
-		g_free(iface->network.identifier);
-		iface->network.identifier = str;
-
-		str = g_key_file_get_string(keyfile,
-				iface->network.identifier, "PSK", NULL);
-		if (str != NULL) {
-			g_free(iface->network.passphrase);
-			iface->network.passphrase = str;
-		}
-	}
-
-done:
-	g_key_file_free(keyfile);
-
-	g_free(pathname);
-
-	return 0;
-}
-
-static void do_update(GKeyFile *keyfile, struct connman_iface *iface)
-{
-	const char *str;
-
-	DBG("iface %p", iface);
-
-	str = __connman_iface_policy2string(iface->policy);
-	g_key_file_set_string(keyfile, GROUP_CONFIG, "Policy", str);
-
-	if (iface->network.identifier != NULL) {
-		g_key_file_set_string(keyfile, GROUP_CONFIG,
-				"LastNetwork", iface->network.identifier);
-	} else
-		g_key_file_remove_key(keyfile, GROUP_CONFIG,
-						"LastNetwork", NULL);
-
-	if (iface->network.identifier != NULL)
-		g_key_file_set_string(keyfile, iface->network.identifier,
-					"PSK", iface->network.passphrase);
-}
-
-int __connman_iface_store(struct connman_iface *iface)
-{
-	GKeyFile *keyfile;
-	gchar *pathname, *data = NULL;
-	gsize length;
-
-	DBG("iface %p", iface);
-
-	if (iface->identifier == NULL)
-		return -EIO;
-
-	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
-							iface->identifier);
-	if (pathname == NULL)
-		return -ENOMEM;
-
-	keyfile = g_key_file_new();
-
-	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
-		goto update;
-
-	if (length > 0) {
-		if (g_key_file_load_from_data(keyfile, data, length,
-				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
-			goto done;
-	}
-
-	g_free(data);
-
-update:
-	do_update(keyfile, iface);
-
-	data = g_key_file_to_data(keyfile, &length, NULL);
-
-	g_file_set_contents(pathname, data, length, NULL);
-
-done:
-	g_free(data);
-
-	g_key_file_free(keyfile);
-
-	g_free(pathname);
-
-	return 0;
-}
-
-int __connman_iface_store_current_network(struct connman_iface *iface)
-{
-	GKeyFile *keyfile;
-	gchar *pathname, *data = NULL;
-	gsize length;
-
-	DBG("iface %p", iface);
-
-	if (iface->identifier == NULL)
-		return -EIO;
-
-	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
-							iface->identifier);
-	if (pathname == NULL)
-		return -ENOMEM;
-
-	keyfile = g_key_file_new();
-
-	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
-		goto update;
-
-	if (length > 0) {
-		if (g_key_file_load_from_data(keyfile, data, length,
-				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
-			goto done;
-	}
-
-	g_free(data);
-
-update:
-	g_key_file_set_string(keyfile, GROUP_CONFIG,
-				"LastNetwork", iface->network.identifier);
-
-	data = g_key_file_to_data(keyfile, &length, NULL);
-
-	g_file_set_contents(pathname, data, length, NULL);
-
-done:
-	g_free(data);
-
-	g_key_file_free(keyfile);
-
-	g_free(pathname);
-
-	return 0;
-}
-
-int __connman_iface_load_networks(struct connman_iface *iface)
-{
-	GKeyFile *keyfile;
-	gchar *pathname;
-	gchar **list;
-	gsize list_len;
-	int i;
-
-	if (iface->identifier == NULL)
-		return -1;
-
-	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
-							iface->identifier);
-	if (pathname == NULL)
-		return -1;
-
-	keyfile = g_key_file_new();
-
-	g_key_file_set_list_separator(keyfile, ',');
-
-	if (g_key_file_load_from_file(keyfile, pathname, 0, NULL) == FALSE)
-		goto done;
-
-	if (g_key_file_has_group(keyfile, GROUP_CONFIG) == FALSE)
-		goto done;
-
-	list = g_key_file_get_string_list(keyfile, GROUP_CONFIG,
-					"KnownNetworks", &list_len, NULL);
-	for (i = 0; i < list_len; i++) {
-		gchar *psk;
-
-		DBG("Known network %s", list[i]);
-
-		psk = g_key_file_get_string(keyfile, list[i], "PSK", NULL);
-
-		__connman_iface_add_network(iface, list[i], psk);
-	}
-
-	g_strfreev(list);
-
-done:
-	g_key_file_free(keyfile);
-
-	g_free(pathname);
-
-	return 0;
-}

commit 6957ddea07497760aad62a0c900bad20a514f6b2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 19:31:13 2008 +0100

    Remove obsolete D-Bus element API documentation

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 636600fc..ea75e7f8 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -51,4 +51,4 @@ EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
 						dbus-manager.xml
 
 EXTRA_DIST += manager-api.txt device-api.txt network-api.txt \
-				element-api.txt agent-api.txt plugin-api.txt
+					agent-api.txt plugin-api.txt
diff --git a/doc/element-api.txt b/doc/element-api.txt
deleted file mode 100644
index 423f1a7b..00000000
--- a/doc/element-api.txt
+++ /dev/null
@@ -1,50 +0,0 @@
-Element hierarchy
-*****************
-
-Service name	org.moblin.connman
-Interface name	org.moblin.connman.Element
-Object path	[element object]
-
-Methods		dict GetProperties()
-
-Properties	string Type
-		string Subtype
-		string Driver
-		string Vendor
-		string Product
-
-
-Method: GetProperties
-=====================
-This method allows to retrieve all properties of an element at once. The
-properties are presented in a dictionary.
-
-Property: Type
-==============
-This property represents the main type of an element. It can have the values
-like "device", "network", "ipv4", "ipv6", "dhcp", "bootp" and "zeroconf".
-
-Property: Subtype
-=================
-This property represents the subtype of an element. In the normal case this
-is the hardware type. It can have values like "ethernet", "wifi", "wimax",
-"modem" and "bluetooth".
-
-The element system will inherit the subtype from the parent if not overwritten
-manually and so it should be present in every element.
-
-Property: Driver
-================
-This property represents the driver that is assigned to this element. This
-value will only be present in case of Device elements. On Linux system this
-is the kernel driver name.
-
-Property: Vendor
-================
-This property represent the vendor string for this element. This value is only
-present in case of a Device element. This information are taken from HAL.
-
-Property: Product
-=================
-This property represent the product string for this element. This value is only
-present in case of a Device element. This information are taken from HAL.

commit 0217800d8a31b0b53d14566260639ca7e03946ea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 19:34:18 2008 +0100

    Update API documentation links

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index f1601c43..9c5affc4 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -75,10 +75,17 @@
     </para>
   </reference>
 
-  <reference id="element">
-    <title>Element interface</title>
+  <reference id="device">
+    <title>Device interface</title>
     <para>
-<programlisting><xi:include href="element-api.txt" parse="text" /></programlisting>
+<programlisting><xi:include href="device-api.txt" parse="text" /></programlisting>
+    </para>
+  </reference>
+
+  <reference id="network">
+    <title>Network interface</title>
+    <para>
+<programlisting><xi:include href="network-api.txt" parse="text" /></programlisting>
     </para>
   </reference>
 

commit d184b124aaf605727e9a1ea5075f98351747c990
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 21:02:08 2008 +0100

    Separate elements in device list

diff --git a/test/test-manager b/test/test-manager
index d06391fc..0ae6a40f 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -12,7 +12,7 @@ properties = manager.GetProperties()
 def print_list(key, value):
 	text = ""
 	for path in value:
-		text = text + str(path)
+		text = text + str(path) + " "
 	print "%s = %s" % (key, text)
 
 for key in properties.keys():

commit db05c1daa2ce4b0e44d49ce32d6d7a1073c73c19
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 21:10:05 2008 +0100

    Fix broken global state change signals

diff --git a/src/element.c b/src/element.c
index 88f42d69..99d8103f 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1496,7 +1496,7 @@ static void append_state(DBusMessageIter *entry, const char *state)
 	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
 					DBUS_TYPE_STRING_AS_STRING, &value);
 
-	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &state);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, &state);
 
 	dbus_message_iter_close_container(entry, &value);
 }

commit 0ed841b6a90c2b9ddcd2c42abc7213a64c229fa7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 21:23:48 2008 +0100

    Update object variable to match its type

diff --git a/test/list-profiles b/test/list-profiles
index 025f3cf1..47741141 100755
--- a/test/list-profiles
+++ b/test/list-profiles
@@ -12,10 +12,10 @@ properties = manager.GetProperties()
 for path in properties["Profiles"]:
 	print "[ %s ]" % (path)
 
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
+	profile = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Profile")
 
-	properties = element.GetProperties()
+	properties = profile.GetProperties()
 	for key in properties.keys():
 		print "    %s = %s" % (key, properties[key])
 

commit 501d003fce99e6a9c366d9bbac5c2a293dce9163
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 23 21:27:14 2008 +0100

    Use global state property from manager interface

diff --git a/test/get-state b/test/get-state
index f82b44c5..38c1dc94 100755
--- a/test/get-state
+++ b/test/get-state
@@ -7,6 +7,6 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
 					'org.moblin.connman.Manager')
 
-state = manager.GetState()
+properties = manager.GetProperties()
 
-print "System is %s" % (state)
+print "System is %s" % (properties["State"])

commit b6e6635dca3c929df0240fad174838e7cd17ccf3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 11:27:26 2008 +0100

    Make threading support optional

diff --git a/configure.ac b/configure.ac
index c3e4f7f1..48074201 100644
--- a/configure.ac
+++ b/configure.ac
@@ -56,10 +56,15 @@ PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
-PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
+AC_ARG_ENABLE(threads, AC_HELP_STRING([--enable-threads],
+					[enable threading support]), [
+	AC_DEFINE(NEED_THREADS, 1, [Define if threading support is required])
+
+	PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
 				AC_MSG_ERROR(gthread is required))
-AC_SUBST(GTHREAD_CFLAGS)
-AC_SUBST(GTHREAD_LIBS)
+	GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
+	GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
+])
 
 PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(libdbus is required))
diff --git a/src/Makefile.am b/src/Makefile.am
index 6c3d6039..f49e18e4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -15,7 +15,7 @@ connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
 			element.c device.c network.c security.c resolver.c \
 				storage.c manager.c agent.c rtnl.c dbus.c
 
-connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ -ldl
+connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ -ldl
 
 connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
@@ -33,7 +33,7 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GTHREAD_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
+AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
 			-DSTATEDIR=\""$(statedir)"\" \
 			-DSTORAGEDIR=\""$(storagedir)\"" \
 			-DPLUGINDIR=\""$(plugindir)"\"
diff --git a/src/main.c b/src/main.c
index 104c5cc5..58108135 100644
--- a/src/main.c
+++ b/src/main.c
@@ -76,8 +76,10 @@ int main(int argc, char *argv[])
 	DBusError err;
 	struct sigaction sa;
 
+#ifdef NEED_THREADS
 	if (g_thread_supported() == FALSE)
 		g_thread_init(NULL);
+#endif
 
 	context = g_option_context_new(NULL);
 	g_option_context_add_main_entries(context, options, NULL);
@@ -108,10 +110,12 @@ int main(int argc, char *argv[])
 
 	main_loop = g_main_loop_new(NULL, FALSE);
 
+#ifdef NEED_THREADS
 	if (dbus_threads_init_default() == FALSE) {
 		fprintf(stderr, "Can't init usage of threads\n");
 		exit(1);
 	}
+#endif
 
 	dbus_error_init(&err);
 

commit 84360619c6b6fdeb6cc85ca3e86c5bca8b3ff0a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 15:32:10 2008 +0100

    Remove thread pool for element registration

diff --git a/src/element.c b/src/element.c
index 99d8103f..cbae3333 100644
--- a/src/element.c
+++ b/src/element.c
@@ -39,10 +39,6 @@ static GNode *element_root = NULL;
 
 static GSList *driver_list = NULL;
 
-static GThreadPool *thread_register = NULL;
-static GThreadPool *thread_unregister = NULL;
-static GThreadPool *thread_unregister_children = NULL;
-
 static gchar *device_filter = NULL;
 
 static struct {
@@ -1297,115 +1293,6 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 	return result;
 }
 
-/**
- * connman_element_register:
- * @element: the element to register
- * @parent: the parent to register the element with
- *
- * Register an element with the core. It will be register under the given
- * parent of if %NULL is provided under the root element.
- *
- * Returns: %0 on success
- */
-int connman_element_register(struct connman_element *element,
-					struct connman_element *parent)
-{
-	DBG("element %p name %s parent %p", element, element->name, parent);
-
-	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
-		if (g_pattern_match_simple(device_filter,
-						element->name) == FALSE) {
-			DBG("ignoring %s device", element->name);
-			return -EPERM;
-		}
-	}
-
-	if (connman_element_ref(element) == NULL)
-		return -EINVAL;
-
-	connman_element_lock(element);
-
-	if (element->name == NULL) {
-		element->name = g_strdup(type2string(element->type));
-		if (element->name == NULL) {
-			connman_element_unlock(element);
-			return -EINVAL;
-		}
-	}
-
-	element->parent = parent;
-
-	connman_element_unlock(element);
-
-	if (thread_register != NULL)
-		g_thread_pool_push(thread_register, element, NULL);
-
-	return 0;
-}
-
-void connman_element_unregister(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	if (thread_unregister != NULL)
-		g_thread_pool_push(thread_unregister, element, NULL);
-}
-
-void connman_element_unregister_children(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	if (thread_unregister_children != NULL)
-		g_thread_pool_push(thread_unregister_children, element, NULL);
-}
-
-static gboolean update_element(GNode *node, gpointer user_data)
-{
-	struct connman_element *element = node->data;
-
-	DBG("element %p name %s", element, element->name);
-
-	if (element->driver && element->driver->update)
-		element->driver->update(element);
-
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
-	return FALSE;
-}
-
-void connman_element_update(struct connman_element *element)
-{
-	GNode *node;
-
-	DBG("element %p name %s", element, element->name);
-
-	g_static_rw_lock_reader_lock(&element_lock);
-
-	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
-
-	if (node != NULL)
-		g_node_traverse(node, G_PRE_ORDER,
-				G_TRAVERSE_ALL, -1, update_element, NULL);
-
-	g_static_rw_lock_reader_unlock(&element_lock);
-}
-
-int connman_element_set_enabled(struct connman_element *element,
-							gboolean enabled)
-{
-	if (element->enabled == enabled)
-		return 0;
-
-	element->enabled = enabled;
-
-	connman_element_update(element);
-
-	return 0;
-}
-
 static void append_devices(DBusMessageIter *entry)
 {
 	DBusMessageIter value, iter;
@@ -1626,6 +1513,51 @@ static void register_element(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
+/**
+ * connman_element_register:
+ * @element: the element to register
+ * @parent: the parent to register the element with
+ *
+ * Register an element with the core. It will be register under the given
+ * parent of if %NULL is provided under the root element.
+ *
+ * Returns: %0 on success
+ */
+int connman_element_register(struct connman_element *element,
+					struct connman_element *parent)
+{
+	DBG("element %p name %s parent %p", element, element->name, parent);
+
+	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+		if (g_pattern_match_simple(device_filter,
+						element->name) == FALSE) {
+			DBG("ignoring %s device", element->name);
+			return -EPERM;
+		}
+	}
+
+	if (connman_element_ref(element) == NULL)
+		return -EINVAL;
+
+	connman_element_lock(element);
+
+	if (element->name == NULL) {
+		element->name = g_strdup(type2string(element->type));
+		if (element->name == NULL) {
+			connman_element_unlock(element);
+			return -EINVAL;
+		}
+	}
+
+	element->parent = parent;
+
+	connman_element_unlock(element);
+
+	register_element(element, NULL);
+
+	return 0;
+}
+
 static gboolean remove_element(GNode *node, gpointer user_data)
 {
 	struct connman_element *element = node->data;
@@ -1700,6 +1632,13 @@ static void unregister_element(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
+void connman_element_unregister(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	unregister_element(element, NULL);
+}
+
 static void unregister_children(gpointer data, gpointer user_data)
 {
 	struct connman_element *element = data;
@@ -1718,6 +1657,60 @@ static void unregister_children(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
+void connman_element_unregister_children(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	unregister_children(element, NULL);
+}
+
+static gboolean update_element(GNode *node, gpointer user_data)
+{
+	struct connman_element *element = node->data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->driver && element->driver->update)
+		element->driver->update(element);
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	return FALSE;
+}
+
+void connman_element_update(struct connman_element *element)
+{
+	GNode *node;
+
+	DBG("element %p name %s", element, element->name);
+
+	g_static_rw_lock_reader_lock(&element_lock);
+
+	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
+
+	if (node != NULL)
+		g_node_traverse(node, G_PRE_ORDER,
+				G_TRAVERSE_ALL, -1, update_element, NULL);
+
+	g_static_rw_lock_reader_unlock(&element_lock);
+}
+
+int connman_element_set_enabled(struct connman_element *element,
+							gboolean enabled)
+{
+	if (element->enabled == enabled)
+		return 0;
+
+	element->enabled = enabled;
+
+	connman_element_update(element);
+
+	return 0;
+}
+
 int __connman_element_init(DBusConnection *conn, const char *device)
 {
 	struct connman_element *element;
@@ -1743,13 +1736,6 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 
 	g_static_rw_lock_writer_unlock(&element_lock);
 
-	thread_register = g_thread_pool_new(register_element,
-							NULL, 1, FALSE, NULL);
-	thread_unregister = g_thread_pool_new(unregister_element,
-							NULL, 1, FALSE, NULL);
-	thread_unregister_children = g_thread_pool_new(unregister_children,
-							NULL, 1, FALSE, NULL);
-
 	__connman_device_init();
 
 	return 0;
@@ -1780,7 +1766,7 @@ static gboolean free_node(GNode *node, gpointer data)
 	DBG("element %p name %s", element, element->name);
 
 	if (g_node_depth(node) > 1)
-		g_thread_pool_push(thread_unregister, element, NULL);
+		unregister_element(element, NULL);
 
 	return FALSE;
 }
@@ -1791,9 +1777,6 @@ void __connman_element_cleanup(void)
 
 	__connman_device_cleanup();
 
-	g_thread_pool_free(thread_register, TRUE, TRUE);
-	thread_register = NULL;
-
 	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_driver, NULL);
@@ -1804,12 +1787,6 @@ void __connman_element_cleanup(void)
 							free_node, NULL);
 	g_static_rw_lock_writer_unlock(&element_lock);
 
-	g_thread_pool_free(thread_unregister, FALSE, TRUE);
-	thread_unregister = NULL;
-
-	g_thread_pool_free(thread_unregister_children, FALSE, TRUE);
-	thread_unregister_children = NULL;
-
 	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_destroy(element_root);
 	element_root = NULL;

commit ababfb6aad8dc423fca653cc27d920d466c4311c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 15:34:02 2008 +0100

    Limit Device interface to real devices only

diff --git a/src/element.c b/src/element.c
index cbae3333..0f28b8c4 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1450,7 +1450,8 @@ static void register_element(gpointer data, gpointer user_data)
 					NULL, element, NULL) == FALSE)
 		connman_error("Failed to register %s element", element->path);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
+			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
 		if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_DEVICE_INTERFACE,
 					device_methods, element_signals,
@@ -1599,7 +1600,8 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
+			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
 		emit_devices_signal(connection);
 
 		g_dbus_unregister_interface(connection, element->path,

commit 145e0e77d23d5fa15e7be8dd38aae3cead0d3972
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 15:35:28 2008 +0100

    Fix wrong enum for subtype matching

diff --git a/include/driver.h b/include/driver.h
index 6d212d8f..696c53f2 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -41,7 +41,7 @@ extern "C" {
 struct connman_driver {
 	const char *name;
 	enum connman_element_type type;
-	enum connman_element_type subtype;
+	enum connman_element_subtype subtype;
 	int priority;
 	int (*probe) (struct connman_element *element);
 	void (*remove) (struct connman_element *element);

commit ca702380ea9b34aae28bd69ff7fa0b757092a94b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 15:49:04 2008 +0100

    Add section about testing connmand

diff --git a/HACKING b/HACKING
index 9e0adec2..eb1db38a 100644
--- a/HACKING
+++ b/HACKING
@@ -52,6 +52,28 @@ like this:
     # make maintainer-clean
 
 
+Running from within the source code repository
+==============================================
+
+When using "./configure --enable-maintainer-mode" the automake scripts will
+use the plugins directly from within the repository. This removes the need
+to use "make install" when testing "connmand". The "bootstrap-configure"
+automatically includes this option.
+
+  Run daemon in foreground with debugging
+    # sudo ./src/connmand -n -d
+
+For production installations or distribution packaging it is important that
+the "--enable-maintainer-mode" option is NOT used.
+
+Some times it is important to restrict the available interfaces. For example
+in cases where testing happens over a network connection. The "-i" command
+line switch allows to specify a glob pattern for the interface names.
+
+  Run daemon for wireless interfaces
+    # sudo ./src/connmand -n -i wlan*
+
+
 Generating source code documentation
 ====================================
 
@@ -81,3 +103,4 @@ the documentation files are like this:
 
   View documentation
     # firefox doc/html/index.html
+

commit aeea2a47158da318eeb017d8ae028d5c23024647
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 16:38:39 2008 +0100

    Add policy setting and export it

diff --git a/include/element.h b/include/element.h
index 55f95937..1607f823 100644
--- a/include/element.h
+++ b/include/element.h
@@ -44,6 +44,14 @@ enum connman_element_state {
 	CONNMAN_ELEMENT_STATE_CLOSED    = 3,
 };
 
+enum connman_element_policy {
+	CONNMAN_ELEMENT_POLICY_UNKNOWN = 0,
+	CONNMAN_ELEMENT_POLICY_OFF     = 1,
+	CONNMAN_ELEMENT_POLICY_AUTO    = 2,
+	CONNMAN_ELEMENT_POLICY_IGNORE  = 3,
+	CONNMAN_ELEMENT_POLICY_ASK     = 4,
+};
+
 enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_UNKNOWN    = 0,
 	CONNMAN_ELEMENT_TYPE_ROOT       = 1,
@@ -82,6 +90,7 @@ struct connman_element {
 	enum connman_element_type type;
 	enum connman_element_subtype subtype;
 	enum connman_element_state state;
+	enum connman_element_policy policy;
 	gboolean enabled;
 	guint16 priority;
 
diff --git a/src/element.c b/src/element.c
index 0f28b8c4..eb9c07f1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -146,6 +146,24 @@ static const char *subtype2string(enum connman_element_subtype type)
 	return NULL;
 }
 
+static const char *policy2string(enum connman_element_policy policy)
+{
+	switch (policy) {
+	case CONNMAN_ELEMENT_POLICY_UNKNOWN:
+		return "unknown";
+	case CONNMAN_ELEMENT_POLICY_OFF:
+		return "off";
+	case CONNMAN_ELEMENT_POLICY_AUTO:
+		return "auto";
+	case CONNMAN_ELEMENT_POLICY_IGNORE:
+		return "ignore";
+	case CONNMAN_ELEMENT_POLICY_ASK:
+		return "ask";
+	}
+
+	return NULL;
+}
+
 static void append_property(DBusMessageIter *dict,
 				struct connman_property *property)
 {
@@ -301,6 +319,11 @@ static DBusMessage *get_device_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &str);
 
+	str = policy2string(element->policy);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Policy",
+						DBUS_TYPE_STRING, &str);
+
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
@@ -319,6 +342,7 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -333,6 +357,11 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = policy2string(element->policy);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Policy",
+						DBUS_TYPE_STRING, &str);
+
 	connman_dbus_dict_append_variant(&dict, "Connected",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
@@ -796,6 +825,7 @@ struct connman_element *connman_element_create(const char *name)
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
+	element->policy  = CONNMAN_ELEMENT_POLICY_AUTO;
 	element->index   = -1;
 	element->enabled = FALSE;
 

commit 6c02327fffc01f95d0bed62b36cf2a9c26ea642e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 16:47:33 2008 +0100

    Add check for udev library

diff --git a/configure.ac b/configure.ac
index 48074201..bcb38ea4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -74,6 +74,11 @@ AC_SUBST(DBUS_LIBS)
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
 AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 
+PKG_CHECK_MODULES(UDEV, libudev >= 130, udev_found=yes, udev_found=no)
+AC_SUBST(UDEV_CFLAGS)
+AC_SUBST(UDEV_LIBS)
+AM_CONDITIONAL(UDEV, test "${udev_found}" = "yes")
+
 PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, polkit_found=yes, polkit_found=no)
 AC_SUBST(POLKIT_CFLAGS)
 AC_SUBST(POLKIT_LIBS)

commit 4c94e25ba6544a43f13679616577175f045c332c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 17:11:29 2008 +0100

    Add skeleton for udev support

diff --git a/src/Makefile.am b/src/Makefile.am
index f49e18e4..c3a811c1 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -15,7 +15,11 @@ connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
 			element.c device.c network.c security.c resolver.c \
 				storage.c manager.c agent.c rtnl.c dbus.c
 
-connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ -ldl
+if UDEV
+connmand_SOURCES += udev.c
+endif
+
+connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @UDEV_LIBS@ -ldl
 
 connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
@@ -33,10 +37,10 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
-			-DSTATEDIR=\""$(statedir)"\" \
-			-DSTORAGEDIR=\""$(storagedir)\"" \
-			-DPLUGINDIR=\""$(plugindir)"\"
+AM_CFLAGS = @UDEV_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
+				-DSTATEDIR=\""$(statedir)"\" \
+					-DSTORAGEDIR=\""$(storagedir)\"" \
+						-DPLUGINDIR=\""$(plugindir)"\"
 
 INCLUDES = -I$(top_builddir)/include
 
diff --git a/src/udev.c b/src/udev.c
new file mode 100644
index 00000000..0eba6398
--- /dev/null
+++ b/src/udev.c
@@ -0,0 +1,29 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define LIBUDEV_I_KNOW_THE_API_IS_SUBJECT_TO_CHANGE
+#include <libudev.h>
+
+#include "connman.h"

commit a1c56eba5f011bb441e3884dcaa141d35414773a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 24 18:05:12 2008 +0100

    Mention the optional libudev requirement

diff --git a/README b/README
index 0f473ffa..9b6402ad 100644
--- a/README
+++ b/README
@@ -11,6 +11,7 @@ In order to compile Connection Manager you need following software packages:
 	- GCC compiler
 	- GLib library
 	- D-Bus library
+	- udev library (optional)
 	- PolicyKit (optional)
 
 To configure run:

commit 20b89204d55771f3fa49d771e7a4b3c7c70bbc9a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 26 14:31:59 2008 +0100

    Don't expect reply when sending D-Bus messages

diff --git a/gdbus/object.c b/gdbus/object.c
index a417ab98..50313a26 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -576,6 +576,9 @@ gboolean g_dbus_send_message(DBusConnection *connection, DBusMessage *message)
 {
 	dbus_bool_t result;
 
+	if (dbus_message_get_type(message) == DBUS_MESSAGE_TYPE_METHOD_CALL)
+		dbus_message_set_no_reply(message, TRUE);
+
 	result = dbus_connection_send(connection, message, NULL);
 
 	dbus_message_unref(message);

commit dedfd9fbeb5f437c51d3fa5ba7798f45415173e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 26 19:52:58 2008 +0100

    Add type constant for service elements

diff --git a/include/element.h b/include/element.h
index 1607f823..0a963971 100644
--- a/include/element.h
+++ b/include/element.h
@@ -58,12 +58,13 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_PROFILE    = 2,
 	CONNMAN_ELEMENT_TYPE_DEVICE     = 3,
 	CONNMAN_ELEMENT_TYPE_NETWORK    = 4,
-	CONNMAN_ELEMENT_TYPE_IPV4       = 5,
-	CONNMAN_ELEMENT_TYPE_IPV6       = 6,
-	CONNMAN_ELEMENT_TYPE_DHCP       = 7,
-	CONNMAN_ELEMENT_TYPE_BOOTP      = 8,
-	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 9,
-	CONNMAN_ELEMENT_TYPE_RESOLVER   = 10,
+	CONNMAN_ELEMENT_TYPE_SERVICE    = 5,
+	CONNMAN_ELEMENT_TYPE_IPV4       = 6,
+	CONNMAN_ELEMENT_TYPE_IPV6       = 7,
+	CONNMAN_ELEMENT_TYPE_DHCP       = 8,
+	CONNMAN_ELEMENT_TYPE_BOOTP      = 9,
+	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 10,
+	CONNMAN_ELEMENT_TYPE_RESOLVER   = 11,
 
 	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
 };
diff --git a/src/element.c b/src/element.c
index eb9c07f1..6e14a8c9 100644
--- a/src/element.c
+++ b/src/element.c
@@ -103,6 +103,8 @@ static const char *type2string(enum connman_element_type type)
 		return "device";
 	case CONNMAN_ELEMENT_TYPE_NETWORK:
 		return "network";
+	case CONNMAN_ELEMENT_TYPE_SERVICE:
+		return "service";
 	case CONNMAN_ELEMENT_TYPE_IPV4:
 		return "ipv4";
 	case CONNMAN_ELEMENT_TYPE_IPV6:

commit 9a1f19ccb4b1511e7b59d2c7f90434520bbfa943
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 26 19:59:08 2008 +0100

    Add first draft of Connection interface API

diff --git a/doc/Makefile.am b/doc/Makefile.am
index ea75e7f8..752c5ccf 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -51,4 +51,4 @@ EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
 						dbus-manager.xml
 
 EXTRA_DIST += manager-api.txt device-api.txt network-api.txt \
-					agent-api.txt plugin-api.txt
+			connection-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/connection-api.txt b/doc/connection-api.txt
new file mode 100644
index 00000000..9b6040db
--- /dev/null
+++ b/doc/connection-api.txt
@@ -0,0 +1,30 @@
+Connection hierarchy
+====================
+
+Service		org.moblin.connman
+Interface	org.moblin.connman.Connection
+Object path	[variable prefix]/{connection0,connection1,...}
+
+Methods		dict GetProperties()
+
+			Returns properties for the connection object. See
+			the properties section for available properties.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+Signals		PropertyChanged(string name, variant value)
+
+			This signal indicates a changed value of the given
+			property.
+
+Properties	string IPv4.Method [readonly]
+
+			Indicates the way how the IPv4 settings were
+			configured. Possible values here are "dhcp"
+			and "static".
+
+		string IPv4.Address [readonly]
+
+			Shows the current configured IPv4 address.
+			
\ No newline at end of file

commit 54e282e202a13c398c1ea25171b47e98b5b56cae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 26 20:00:11 2008 +0100

    Fix broken newline entry

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index 9b6040db..f0fba378 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -27,4 +27,3 @@ Properties	string IPv4.Method [readonly]
 		string IPv4.Address [readonly]
 
 			Shows the current configured IPv4 address.
-			
\ No newline at end of file

commit eed198d63d2396eb77f63f01460ecaab3508653e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 2 14:55:28 2008 +0100

    Remove usage of GStaticMutex since it causes compiler problems

diff --git a/include/element.h b/include/element.h
index 0a963971..85b9b069 100644
--- a/include/element.h
+++ b/include/element.h
@@ -84,7 +84,6 @@ struct connman_driver;
 
 struct connman_element {
 	gint refcount;
-	GStaticMutex mutex;
 	gint index;
 	gchar *name;
 	gchar *path;
@@ -117,9 +116,6 @@ struct connman_element {
 	} wifi;
 };
 
-#define connman_element_lock(element)    g_static_mutex_lock(&(element)->mutex)
-#define connman_element_unlock(element)  g_static_mutex_unlock(&(element)->mutex)
-
 extern struct connman_element *connman_element_create(const char *name);
 extern struct connman_element *connman_element_ref(struct connman_element *element);
 extern void connman_element_unref(struct connman_element *element);
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 342e6d7f..7249773d 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -45,7 +45,6 @@ struct dhclient_task {
 	struct connman_element *element;
 };
 
-static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
 static GSList *task_list = NULL;
 
 static struct dhclient_task *find_task_by_pid(GPid pid)
@@ -113,9 +112,7 @@ static void task_died(GPid pid, gint status, gpointer data)
 	g_spawn_close_pid(pid);
 	task->pid = 0;
 
-	g_static_mutex_lock(&task_mutex);
 	task_list = g_slist_remove(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
 
 	unlink_task(task);
 
@@ -186,9 +183,7 @@ static int dhclient_probe(struct connman_element *element)
 		return -1;
 	}
 
-	g_static_mutex_lock(&task_mutex);
 	task_list = g_slist_append(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
 
 	g_child_watch_add(task->pid, task_died, task);
 
@@ -203,14 +198,10 @@ static void dhclient_remove(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	g_static_mutex_lock(&task_mutex);
-
 	task = find_task_by_index(element->index);
 	if (task != NULL)
 		task_list = g_slist_remove(task_list, task);
 
-	g_static_mutex_unlock(&task_mutex);
-
 	if (task == NULL)
 		return;
 
@@ -247,9 +238,7 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 
 	DBG("change %d to %s", pid, text);
 
-	g_static_mutex_lock(&task_mutex);
 	task = find_task_by_pid(pid);
-	g_static_mutex_unlock(&task_mutex);
 
 	if (task == NULL)
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
@@ -351,8 +340,6 @@ static void dhclient_exit(void)
 {
 	GSList *list;
 
-	g_static_mutex_lock(&task_mutex);
-
 	for (list = task_list; list; list = list->next) {
 		struct dhclient_task *task = list->data;
 
@@ -362,8 +349,6 @@ static void dhclient_exit(void)
 		unlink_task(task);
 	}
 
-	g_static_mutex_unlock(&task_mutex);
-
 	g_slist_free(task_list);
 
 	connman_driver_unregister(&dhclient_driver);
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index fb8afb4c..d6861f8d 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -41,7 +41,6 @@ struct ethernet_data {
 	unsigned flags;
 };
 
-static GStaticMutex ethernet_mutex = G_STATIC_MUTEX_INIT;
 static GSList *ethernet_list = NULL;
 
 static void ethernet_newlink(unsigned short type, int index,
@@ -51,8 +50,6 @@ static void ethernet_newlink(unsigned short type, int index,
 
 	DBG("index %d flags %ld change %ld", index, flags, change);
 
-	g_static_mutex_lock(&ethernet_mutex);
-
 	for (list = ethernet_list; list; list = list->next) {
 		struct connman_element *element = list->data;
 		struct connman_element *netdev;
@@ -87,8 +84,6 @@ static void ethernet_newlink(unsigned short type, int index,
 			connman_element_unregister_children(element);
 		}
 	}
-
-	g_static_mutex_unlock(&ethernet_mutex);
 }
 
 static struct connman_rtnl ethernet_rtnl = {
@@ -192,9 +187,7 @@ static int ethernet_probe(struct connman_element *element)
 	if (ethernet == NULL)
 		return -ENOMEM;
 
-	g_static_mutex_lock(&ethernet_mutex);
 	ethernet_list = g_slist_append(ethernet_list, element);
-	g_static_mutex_unlock(&ethernet_mutex);
 
 	connman_element_set_data(element, ethernet);
 
@@ -217,9 +210,7 @@ static void ethernet_remove(struct connman_element *element)
 
 	iface_down(ethernet);
 
-	g_static_mutex_lock(&ethernet_mutex);
 	ethernet_list = g_slist_remove(ethernet_list, element);
-	g_static_mutex_unlock(&ethernet_mutex);
 
 	g_free(ethernet);
 }
diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index 14bb3437..094547d0 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -39,7 +39,6 @@
 
 #include "inet.h"
 
-static GStaticMutex device_mutex = G_STATIC_MUTEX_INIT;
 static GSList *device_list = NULL;
 
 static void rtnllink_newlink(unsigned short type, int index,
@@ -53,8 +52,6 @@ static void rtnllink_newlink(unsigned short type, int index,
 
 	DBG("index %d", index);
 
-	g_static_mutex_lock(&device_mutex);
-
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
@@ -64,8 +61,6 @@ static void rtnllink_newlink(unsigned short type, int index,
 		}
 	}
 
-	g_static_mutex_unlock(&device_mutex);
-
 	if (exists == TRUE)
 		return;
 
@@ -113,12 +108,8 @@ static void rtnllink_newlink(unsigned short type, int index,
 	device->index = index;
 	device->name = name;
 
-	g_static_mutex_lock(&device_mutex);
-
 	connman_element_register(device, NULL);
 	device_list = g_slist_append(device_list, device);
-
-	g_static_mutex_unlock(&device_mutex);
 }
 
 static void rtnllink_dellink(unsigned short type, int index,
@@ -128,8 +119,6 @@ static void rtnllink_dellink(unsigned short type, int index,
 
 	DBG("index %d", index);
 
-	g_static_mutex_lock(&device_mutex);
-
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
@@ -140,8 +129,6 @@ static void rtnllink_dellink(unsigned short type, int index,
 			break;
 		}
 	}
-
-	g_static_mutex_unlock(&device_mutex);
 }
 
 static struct connman_rtnl rtnllink_rtnl = {
@@ -169,8 +156,6 @@ static void rtnllink_exit(void)
 
 	connman_rtnl_unregister(&rtnllink_rtnl);
 
-	g_static_mutex_lock(&device_mutex);
-
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
@@ -180,8 +165,6 @@ static void rtnllink_exit(void)
 
 	g_slist_free(device_list);
 	device_list = NULL;
-
-	g_static_mutex_unlock(&device_mutex);
 }
 
 CONNMAN_PLUGIN_DEFINE("rtnllink", "RTNL link detection plugin", VERSION,
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 260d24f9..243ec1b0 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -49,7 +49,6 @@ struct supplicant_task {
 	enum supplicant_state state;
 };
 
-static GStaticMutex task_mutex = G_STATIC_MUTEX_INIT;
 static GSList *task_list = NULL;
 
 static DBusConnection *connection;
@@ -931,9 +930,7 @@ int __supplicant_start(struct connman_element *element,
 	task->created = FALSE;
 	task->state = STATE_INACTIVE;
 
-	g_static_mutex_lock(&task_mutex);
 	task_list = g_slist_append(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
 
 	err = get_interface(task);
 	if (err < 0) {
@@ -961,9 +958,7 @@ int __supplicant_stop(struct connman_element *element)
 	if (task == NULL)
 		return -ENODEV;
 
-	g_static_mutex_lock(&task_mutex);
 	task_list = g_slist_remove(task_list, task);
-	g_static_mutex_unlock(&task_mutex);
 
 	disable_network(task);
 
diff --git a/plugins/wifi.c b/plugins/wifi.c
index f175494e..c8b7e0a2 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -42,7 +42,6 @@
 #include "supplicant.h"
 
 struct wifi_data {
-	GStaticMutex mutex;
 	GSList *list;
 	gchar *identifier;
 };
@@ -190,8 +189,6 @@ static void scan_result(struct connman_element *parent,
 		temp[i] = g_ascii_tolower(temp[i]);
 	}
 
-	g_static_mutex_lock(&data->mutex);
-
 	element = find_element(data, network->identifier);
 	if (element == NULL) {
 		element = connman_element_create(temp);
@@ -210,8 +207,6 @@ static void scan_result(struct connman_element *parent,
 		connman_element_register(element, parent);
 	}
 
-	g_static_mutex_unlock(&data->mutex);
-
 	g_free(temp);
 }
 
@@ -230,8 +225,6 @@ static int wifi_probe(struct connman_element *element)
 	if (data == NULL)
 		return -ENOMEM;
 
-	g_static_mutex_init(&data->mutex);
-
 	connman_element_set_data(element, data);
 
 	return 0;
@@ -282,8 +275,6 @@ static int wifi_disable(struct connman_element *element)
 
 	__supplicant_disconnect(element);
 
-	g_static_mutex_lock(&data->mutex);
-
 	for (list = data->list; list; list = list->next) {
 		struct connman_element *network = list->data;
 
@@ -293,8 +284,6 @@ static int wifi_disable(struct connman_element *element)
 	g_slist_free(data->list);
 	data->list = NULL;
 
-	g_static_mutex_unlock(&data->mutex);
-
 	connman_element_unregister_children(element);
 
 	return 0;
@@ -311,7 +300,6 @@ static struct connman_driver wifi_driver = {
 	.disable	= wifi_disable,
 };
 
-static GStaticMutex device_mutex = G_STATIC_MUTEX_INIT;
 static GSList *device_list = NULL;
 
 static void wifi_newlink(unsigned short type, int index,
@@ -344,8 +332,6 @@ static void wifi_newlink(unsigned short type, int index,
 
 	close(sk);
 
-	g_static_mutex_lock(&device_mutex);
-
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
@@ -355,8 +341,6 @@ static void wifi_newlink(unsigned short type, int index,
 		}
 	}
 
-	g_static_mutex_unlock(&device_mutex);
-
 	if (exists == TRUE) {
 		g_free(name);
 		return;
@@ -369,12 +353,8 @@ static void wifi_newlink(unsigned short type, int index,
 	device->index = index;
 	device->name = name;
 
-	g_static_mutex_lock(&device_mutex);
-
 	connman_element_register(device, NULL);
 	device_list = g_slist_append(device_list, device);
-
-	g_static_mutex_unlock(&device_mutex);
 }
 
 static void wifi_dellink(unsigned short type, int index,
@@ -384,8 +364,6 @@ static void wifi_dellink(unsigned short type, int index,
 
 	DBG("index %d", index);
 
-	g_static_mutex_lock(&device_mutex);
-
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
@@ -396,8 +374,6 @@ static void wifi_dellink(unsigned short type, int index,
 			break;
 		}
 	}
-
-	g_static_mutex_unlock(&device_mutex);
 }
 
 static struct connman_rtnl wifi_rtnl = {
@@ -426,8 +402,6 @@ static void supplicant_disconnect(DBusConnection *connection, void *user_data)
 
 	connman_rtnl_unregister(&wifi_rtnl);
 
-	g_static_mutex_lock(&device_mutex);
-
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
@@ -438,8 +412,6 @@ static void supplicant_disconnect(DBusConnection *connection, void *user_data)
 	g_slist_free(device_list);
 	device_list = NULL;
 
-	g_static_mutex_unlock(&device_mutex);
-
 	__supplicant_exit();
 }
 
diff --git a/src/connman.h b/src/connman.h
index 7b7cc5e5..d7124d2e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -82,6 +82,14 @@ const char *__connman_element_subtype2string(enum connman_element_subtype type);
 int __connman_element_load(struct connman_element *element);
 int __connman_element_store(struct connman_element *element);
 
+static inline void __connman_element_lock(struct connman_element *element)
+{
+}
+
+static inline void __connman_element_unlock(struct connman_element *element)
+{
+}
+
 #include <connman/device.h>
 
 int __connman_device_init(void);
diff --git a/src/element.c b/src/element.c
index 6e14a8c9..9fd4a018 100644
--- a/src/element.c
+++ b/src/element.c
@@ -212,7 +212,7 @@ static void add_common_properties(struct connman_element *element,
 				DBUS_TYPE_STRING, &passphrase);
 	}
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -220,7 +220,7 @@ static void add_common_properties(struct connman_element *element,
 		append_property(dict, property);
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 }
 
 static DBusMessage *get_properties(DBusConnection *conn,
@@ -422,7 +422,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 	if (__connman_security_check_privileges(msg) < 0)
 		return __connman_error_permission_denied(msg);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -444,7 +444,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 			property->value = NULL;
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -465,7 +465,7 @@ static DBusMessage *clear_property(DBusConnection *conn,
 	if (__connman_security_check_privileges(msg) < 0)
 		return __connman_error_permission_denied(msg);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -487,7 +487,7 @@ static DBusMessage *clear_property(DBusConnection *conn,
 		property->value = NULL;
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -704,9 +704,9 @@ static gboolean probe_driver(GNode *node, gpointer data)
 		if (driver->probe(element) < 0)
 			return FALSE;
 
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		element->driver = driver;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 	}
 
 	return FALSE;
@@ -771,9 +771,9 @@ static gboolean remove_driver(GNode *node, gpointer data)
 		if (driver->remove)
 			driver->remove(element);
 
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		element->driver = NULL;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 	}
 
 	return FALSE;
@@ -821,8 +821,6 @@ struct connman_element *connman_element_create(const char *name)
 
 	element->refcount = 1;
 
-	g_static_mutex_init(&element->mutex);
-
 	element->name    = g_strdup(name);
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
@@ -850,7 +848,7 @@ static void free_properties(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -870,7 +868,7 @@ static void free_properties(struct connman_element *element)
 
 	element->properties = NULL;
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 }
 
 void connman_element_unref(struct connman_element *element)
@@ -919,9 +917,9 @@ int connman_element_add_static_property(struct connman_element *element,
 		break;
 	}
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 	element->properties = g_slist_append(element->properties, property);
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return 0;
 }
@@ -959,9 +957,9 @@ int connman_element_add_static_array_property(struct connman_element *element,
 		break;
 	}
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 	element->properties = g_slist_append(element->properties, property);
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return 0;
 }
@@ -1014,7 +1012,7 @@ static struct connman_property *create_property(struct connman_element *element,
 
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		property = list->data;
@@ -1041,7 +1039,7 @@ static struct connman_property *create_property(struct connman_element *element,
 	element->properties = g_slist_append(element->properties, property);
 
 unlock:
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return property;
 }
@@ -1127,40 +1125,40 @@ int connman_element_set_property(struct connman_element *element,
 {
 	switch (id) {
 	case CONNMAN_PROPERTY_ID_IPV4_ADDRESS:
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		g_free(element->ipv4.address);
 		element->ipv4.address = g_strdup(*((const char **) value));
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_IPV4_NETMASK:
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		g_free(element->ipv4.netmask);
 		element->ipv4.netmask = g_strdup(*((const char **) value));
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_IPV4_GATEWAY:
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		g_free(element->ipv4.gateway);
 		element->ipv4.gateway = g_strdup(*((const char **) value));
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_IPV4_NAMESERVER:
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		g_free(element->ipv4.nameserver);
 		element->ipv4.nameserver = g_strdup(*((const char **) value));
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_WIFI_SECURITY:
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		g_free(element->wifi.security);
 		element->wifi.security = g_strdup(*((const char **) value));
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE:
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		g_free(element->wifi.passphrase);
 		element->wifi.passphrase = g_strdup(*((const char **) value));
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	default:
 		return -EINVAL;
@@ -1185,49 +1183,49 @@ int connman_element_get_value(struct connman_element *element,
 		if (element->ipv4.address == NULL)
 			return connman_element_get_value(element->parent,
 								id, value);
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		*((char **) value) = element->ipv4.address;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_IPV4_NETMASK:
 		if (element->ipv4.netmask == NULL)
 			return connman_element_get_value(element->parent,
 								id, value);
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		*((char **) value) = element->ipv4.netmask;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_IPV4_GATEWAY:
 		if (element->ipv4.gateway == NULL)
 			return connman_element_get_value(element->parent,
 								id, value);
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		*((char **) value) = element->ipv4.gateway;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_IPV4_NAMESERVER:
 		if (element->ipv4.nameserver == NULL)
 			return connman_element_get_value(element->parent,
 								id, value);
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		*((char **) value) = element->ipv4.nameserver;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_WIFI_SECURITY:
 		if (element->wifi.security == NULL)
 			return connman_element_get_value(element->parent,
 								id, value);
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		*((char **) value) = element->wifi.security;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	case CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE:
 		if (element->wifi.passphrase == NULL)
 			return connman_element_get_value(element->parent,
 								id, value);
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		*((char **) value) = element->wifi.passphrase;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 		break;
 	default:
 		return -EINVAL;
@@ -1244,7 +1242,7 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -1259,7 +1257,7 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 		}
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return found;
 }
@@ -1272,7 +1270,7 @@ gboolean connman_element_get_static_array_property(struct connman_element *eleme
 
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -1288,7 +1286,7 @@ gboolean connman_element_get_static_array_property(struct connman_element *eleme
 		}
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return found;
 }
@@ -1301,7 +1299,7 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 
 	DBG("element %p name %s", element, element->name);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -1320,7 +1318,7 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 			break;
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	return result;
 }
@@ -1448,7 +1446,7 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_static_rw_lock_writer_lock(&element_lock);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	if (element->parent) {
 		node = g_node_find(element_root, G_PRE_ORDER,
@@ -1468,7 +1466,7 @@ static void register_element(gpointer data, gpointer user_data)
 
 	set_reference_properties(element);
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	DBG("element %p path %s", element, element->path);
 
@@ -1536,9 +1534,9 @@ static void register_element(gpointer data, gpointer user_data)
 		DBG("driver %p name %s", driver, driver->name);
 
 		if (driver->probe(element) == 0) {
-			connman_element_lock(element);
+			__connman_element_lock(element);
 			element->driver = driver;
-			connman_element_unlock(element);
+			__connman_element_unlock(element);
 			break;
 		}
 	}
@@ -1572,19 +1570,19 @@ int connman_element_register(struct connman_element *element,
 	if (connman_element_ref(element) == NULL)
 		return -EINVAL;
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	if (element->name == NULL) {
 		element->name = g_strdup(type2string(element->type));
 		if (element->name == NULL) {
-			connman_element_unlock(element);
+			__connman_element_unlock(element);
 			return -EINVAL;
 		}
 	}
 
 	element->parent = parent;
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	register_element(element, NULL);
 
@@ -1605,9 +1603,9 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		if (element->driver->remove)
 			element->driver->remove(element);
 
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		element->driver = NULL;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 	}
 
 	if (node != NULL) {
@@ -1785,9 +1783,9 @@ static gboolean free_driver(GNode *node, gpointer data)
 		if (element->driver->remove)
 			element->driver->remove(element);
 
-		connman_element_lock(element);
+		__connman_element_lock(element);
 		element->driver = NULL;
-		connman_element_unlock(element);
+		__connman_element_unlock(element);
 	}
 
 	return FALSE;
diff --git a/src/storage.c b/src/storage.c
index 06337c78..15e0cd66 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -106,7 +106,7 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 	g_key_file_set_boolean(keyfile, element->path, "Enabled",
 							element->enabled);
 
-	connman_element_lock(element);
+	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
@@ -122,7 +122,7 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 					property->name, property->value);
 	}
 
-	connman_element_unlock(element);
+	__connman_element_unlock(element);
 
 	if (connman_element_get_value(element,
 			CONNMAN_PROPERTY_ID_WIFI_SECURITY, &value) == 0)

commit 6193c90589d84e3a8ba09350e6be4479c74c3b38
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 2 18:31:13 2008 +0100

    Make property setting a little bit more generic

diff --git a/src/element.c b/src/element.c
index 9fd4a018..a05f2cf3 100644
--- a/src/element.c
+++ b/src/element.c
@@ -223,6 +223,41 @@ static void add_common_properties(struct connman_element *element,
 	__connman_element_unlock(element);
 }
 
+static void set_common_property(struct connman_element *element,
+				const char *name, DBusMessageIter *value)
+{
+	GSList *list;
+
+	if (g_str_equal(name, "Priority") == TRUE) {
+		dbus_message_iter_get_basic(value, &element->priority);
+		return;
+	}
+
+	__connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+		const char *str;
+
+		if (g_str_equal(property->name, name) == FALSE)
+			continue;
+
+		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
+			continue;
+
+		property->flags &= ~CONNMAN_PROPERTY_FLAG_REFERENCE;
+
+		if (property->type == DBUS_TYPE_STRING) {
+			dbus_message_iter_get_basic(value, &str);
+			g_free(property->value);
+			property->value = g_strdup(str);
+		} else
+			property->value = NULL;
+	}
+
+	__connman_element_unlock(element);
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -374,6 +409,40 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *set_network_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessageIter iter;
+	DBusMessageIter value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
+		const char *str;
+
+		dbus_message_iter_get_basic(&value, &str);
+		g_free(element->wifi.passphrase);
+		element->wifi.passphrase = g_strdup(str);
+	} else
+		set_common_property(element, name, &value);
+
+	__connman_element_store(element);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *get_connection_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -408,7 +477,6 @@ static DBusMessage *set_property(DBusConnection *conn,
 	DBusMessageIter iter;
 	DBusMessageIter value;
 	const char *name;
-	GSList *list;
 
 	DBG("conn %p", conn);
 
@@ -422,29 +490,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 	if (__connman_security_check_privileges(msg) < 0)
 		return __connman_error_permission_denied(msg);
 
-	__connman_element_lock(element);
-
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-		const char *str;
-
-		if (g_str_equal(property->name, name) == FALSE)
-			continue;
-
-		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
-			continue;
-
-		property->flags &= ~CONNMAN_PROPERTY_FLAG_REFERENCE;
-
-		if (property->type == DBUS_TYPE_STRING) {
-			dbus_message_iter_get_basic(&value, &str);
-			g_free(property->value);
-			property->value = g_strdup(str);
-		} else
-			property->value = NULL;
-	}
-
-	__connman_element_unlock(element);
+	set_common_property(element, name, &value);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -584,6 +630,7 @@ static GDBusMethodTable device_methods[] = {
 
 static GDBusMethodTable network_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_network_properties },
+	{ "SetProperty",   "sv", "",      set_network_property   },
 	{ },
 };
 

commit fcbf3efcfb709229ef60c9c4f34bafa55cee74e9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 2 18:41:44 2008 +0100

    Add extra acccess policy for passphrases

diff --git a/plugins/connman.policy b/plugins/connman.policy
index 2dcc37c7..1b34381b 100644
--- a/plugins/connman.policy
+++ b/plugins/connman.policy
@@ -17,4 +17,13 @@
     </defaults>
   </action>
 
+  <action id="org.moblin.connman.passphrase">
+    <description>Passphrase configuration</description>
+    <message>Policy prevents modification of passphrases</message>
+    <defaults>
+      <allow_inactive>no</allow_inactive>
+      <allow_active>auth_admin_keep_always</allow_active>
+    </defaults>
+  </action>
+
 </policyconfig>

commit 296db43fcf95716fbdcb25e65164772a491605f5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 00:22:02 2008 +0100

    Fill WiFi.Security property with details

diff --git a/plugins/wifi.c b/plugins/wifi.c
index c8b7e0a2..87ad8ccc 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -191,6 +191,8 @@ static void scan_result(struct connman_element *parent,
 
 	element = find_element(data, network->identifier);
 	if (element == NULL) {
+		const char *security;
+
 		element = connman_element_create(temp);
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
@@ -204,6 +206,18 @@ static void scan_result(struct connman_element *parent,
 		connman_element_add_static_array_property(element, "WiFi.SSID",
 			DBUS_TYPE_BYTE, &network->ssid, network->ssid_len);
 
+		if (network->has_rsn == TRUE)
+			security = "wpa2";
+		else if (network->has_wpa == TRUE)
+			security = "wpa";
+		else if (network->has_wep == TRUE)
+			security = "wep";
+		else
+			security = "none";
+
+		connman_element_add_static_property(element, "WiFi.Security",
+						DBUS_TYPE_STRING, &security);
+
 		connman_element_register(element, parent);
 	}
 

commit 67c8529a4fe6b9e10569cf02b18dbb83766989b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 00:22:27 2008 +0100

    Optimize SSID character replacement

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 87ad8ccc..494f53bc 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -182,9 +182,9 @@ static void scan_result(struct connman_element *parent,
 	for (i = 0; i < strlen(temp); i++) {
 		if (temp[i] == ' ' || temp[i] == '.' || temp[i] == '-')
 			temp[i] = '_';
-		if (temp[i] == '(' || temp[i] == ')')
+		else if (temp[i] == '(' || temp[i] == ')')
 			temp[i] = '_';
-		if (g_ascii_isprint(temp[i]) == FALSE)
+		else if (g_ascii_isprint(temp[i]) == FALSE)
 			temp[i] = '_';
 		temp[i] = g_ascii_tolower(temp[i]);
 	}

commit 65511e670e72f12cd78549696bb440708f1a7ab6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 00:53:01 2008 +0100

    Extract all properties from scan result

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 243ec1b0..cdaea16b 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -619,13 +619,9 @@ static void extract_rsnie(struct supplicant_network *network,
 static void extract_capabilites(struct supplicant_network *network,
 						DBusMessageIter *value)
 {
-	guint capabilities;
+	dbus_message_iter_get_basic(value, &network->capabilities);
 
-	dbus_message_iter_get_basic(value, &capabilities);
-
-	network->capabilities = capabilities;
-
-	if (capabilities & IEEE80211_CAP_PRIVACY)
+	if (network->capabilities & IEEE80211_CAP_PRIVACY)
 		network->has_wep = TRUE;
 }
 
@@ -662,6 +658,19 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		//type = dbus_message_iter_get_arg_type(&value);
 		//dbus_message_iter_get_basic(&value, &val);
 
+		/* 
+		 * bssid        : a (97)
+		 * ssid         : a (97)
+		 * wpaie        : a (97)
+		 * rsnie        : a (97)
+		 * frequency    : i (105)
+		 * capabilities : q (113)
+		 * quality      : i (105)
+		 * noise        : i (105)
+		 * level        : i (105)
+		 * maxrate      : i (105)
+		 */
+
 		if (g_str_equal(key, "ssid") == TRUE)
 			extract_ssid(network, &value);
 		else if (g_str_equal(key, "wpaie") == TRUE)
@@ -670,6 +679,15 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 			extract_rsnie(network, &value);
 		else if (g_str_equal(key, "capabilities") == TRUE)
 			extract_capabilites(network, &value);
+		else if (g_str_equal(key, "quality") == TRUE)
+			dbus_message_iter_get_basic(&value, &network->quality);
+		else if (g_str_equal(key, "noise") == TRUE)
+			dbus_message_iter_get_basic(&value, &network->noise);
+		else if (g_str_equal(key, "level") == TRUE)
+			dbus_message_iter_get_basic(&value, &network->level);
+		else if (g_str_equal(key, "maxrate") == TRUE)
+			dbus_message_iter_get_basic(&value, &network->maxrate);
+
 
 		dbus_message_iter_next(&dict);
 	}
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index d62e07d1..2e2e4ea1 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -40,10 +40,14 @@ struct supplicant_network {
 	gchar *identifier;
 	guint8 *ssid;
 	guint ssid_len;
-	guint capabilities;
+	guint16 capabilities;
 	gboolean has_wep;
 	gboolean has_wpa;
 	gboolean has_rsn;
+	gint32 quality;
+	gint32 noise;
+	gint32 level;
+	gint32 maxrate;
 };
 
 struct supplicant_callback {

commit 5233b4347cc817a3e6e9e16b2ae6b3b5be25366e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 01:05:01 2008 +0100

    Add byte and signed integer types

diff --git a/src/dbus.c b/src/dbus.c
index 6c0de46d..918fb0e5 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -76,12 +76,21 @@ void connman_dbus_dict_append_variant(DBusMessageIter *dict,
 	case DBUS_TYPE_STRING:
 		signature = DBUS_TYPE_STRING_AS_STRING;
 		break;
+	case DBUS_TYPE_BYTE:
+		signature = DBUS_TYPE_BYTE_AS_STRING;
+		break;
 	case DBUS_TYPE_UINT16:
 		signature = DBUS_TYPE_UINT16_AS_STRING;
 		break;
+	case DBUS_TYPE_INT16:
+		signature = DBUS_TYPE_INT16_AS_STRING;
+		break;
 	case DBUS_TYPE_UINT32:
 		signature = DBUS_TYPE_UINT32_AS_STRING;
 		break;
+	case DBUS_TYPE_INT32:
+		signature = DBUS_TYPE_INT32_AS_STRING;
+		break;
 	case DBUS_TYPE_OBJECT_PATH:
 		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
 		break;

commit 53820bec61c24198f7381a27524519ca24bb699a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 01:12:44 2008 +0100

    Add support for static byte and integer properties

diff --git a/src/element.c b/src/element.c
index a05f2cf3..926302d6 100644
--- a/src/element.c
+++ b/src/element.c
@@ -900,14 +900,10 @@ static void free_properties(struct connman_element *element)
 	for (list = element->properties; list; list = list->next) {
 		struct connman_property *property = list->data;
 
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)) {
-			if (property->type == DBUS_TYPE_STRING)
-				g_free(property->value);
-			if (property->type == DBUS_TYPE_ARRAY &&
-					property->subtype == DBUS_TYPE_BYTE)
-				g_free(property->value);
-		}
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
+			g_free(property->value);
 
+		g_free(property->name);
 		g_free(property);
 	}
 
@@ -944,7 +940,8 @@ int connman_element_add_static_property(struct connman_element *element,
 
 	DBG("element %p name %s", element, element->name);
 
-	if (type != DBUS_TYPE_STRING)
+	if (type != DBUS_TYPE_STRING && type != DBUS_TYPE_BYTE &&
+						type != DBUS_TYPE_INT32)
 		return -EINVAL;
 
 	property = g_try_new0(struct connman_property, 1);
@@ -962,6 +959,16 @@ int connman_element_add_static_property(struct connman_element *element,
 	case DBUS_TYPE_STRING:
 		property->value = g_strdup(*((const char **) value));
 		break;
+	case DBUS_TYPE_BYTE:
+		property->value = g_try_malloc(1);
+		if (property->value != NULL)
+			memcpy(property->value, value, 1);
+		break;
+	case DBUS_TYPE_INT32:
+		property->value = g_try_malloc(sizeof(gint32));
+		if (property->value != NULL)
+			memcpy(property->value, value, sizeof(gint32));
+		break;
 	}
 
 	__connman_element_lock(element);
@@ -1298,7 +1305,17 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 			continue;
 
 		if (g_str_equal(property->name, name) == TRUE) {
-			*((char **) value) = property->value;
+			switch (property->type) {
+			case DBUS_TYPE_STRING:
+				*((char **) value) = property->value;
+				break;
+			case DBUS_TYPE_BYTE:
+				*((guint8 *) value) = *((guint8 *) property->value);
+				break;
+			case DBUS_TYPE_INT32:
+				*((gint32 *) value) = *((gint32 *) property->value);
+				break;
+			}
 			found = TRUE;
 			break;
 		}

commit cfce6f1cea9657772f1846ab230f620ccce84aca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 01:22:10 2008 +0100

    Add signal strength and noise properties

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 494f53bc..0e1526e1 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -192,6 +192,7 @@ static void scan_result(struct connman_element *parent,
 	element = find_element(data, network->identifier);
 	if (element == NULL) {
 		const char *security;
+		guint8 strength;
 
 		element = connman_element_create(temp);
 
@@ -218,6 +219,17 @@ static void scan_result(struct connman_element *parent,
 		connman_element_add_static_property(element, "WiFi.Security",
 						DBUS_TYPE_STRING, &security);
 
+		strength = network->quality;
+
+		connman_element_add_static_property(element, "WiFi.Strength",
+						DBUS_TYPE_BYTE, &strength);
+
+		connman_element_add_static_property(element, "WiFi.Noise",
+					DBUS_TYPE_INT32, &network->noise);
+
+		DBG("%s (%s) strength %d", network->identifier,
+							security, strength);
+
 		connman_element_register(element, parent);
 	}
 

commit b481384506a522d3172e25d71456e0f78a9c0268
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:04:11 2008 +0100

    Propagate WiFi.Security information properly

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index cdaea16b..b7d01cf8 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -475,8 +475,8 @@ static int disable_network(struct supplicant_task *task)
 }
 
 static int set_network(struct supplicant_task *task,
-					const unsigned char *network, int len,
-							const char *passphrase)
+				const unsigned char *network, int len,
+				const char *security, const char *passphrase)
 {
 	DBusMessage *message, *reply;
 	DBusMessageIter array, dict;
@@ -1023,7 +1023,7 @@ int __supplicant_scan(struct connman_element *element)
 
 int __supplicant_connect(struct connman_element *element,
 				const unsigned char *ssid, int ssid_len,
-							const char *passphrase)
+				const char *security, const char *passphrase)
 {
 	struct supplicant_task *task;
 
@@ -1038,7 +1038,7 @@ int __supplicant_connect(struct connman_element *element,
 	select_network(task);
 	disable_network(task);
 
-	set_network(task, ssid, ssid_len, passphrase);
+	set_network(task, ssid, ssid_len, security, passphrase);
 
 	enable_network(task);
 
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 2e2e4ea1..fa10a69d 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -68,5 +68,5 @@ int __supplicant_scan(struct connman_element *element);
 
 int __supplicant_connect(struct connman_element *element,
 				const unsigned char *ssid, int ssid_len,
-							const char *passphrase);
+				const char *security, const char *passphrase);
 int __supplicant_disconnect(struct connman_element *element);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 0e1526e1..294b7716 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -60,7 +60,7 @@ static void network_remove(struct connman_element *element)
 
 static int network_enable(struct connman_element *element)
 {
-	char *identifier, *passphrase = NULL;
+	char *identifier, *security = NULL, *passphrase = NULL;
 	unsigned char *ssid;
 	int ssid_len;
 
@@ -83,12 +83,19 @@ static int network_enable(struct connman_element *element)
 		}
 	}
 
+	if (connman_element_get_static_property(element,
+					"WiFi.Security", &security) == FALSE)
+		connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_WIFI_SECURITY, &security);
+
 	connman_element_get_value(element,
 			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &passphrase);
 
-	DBG("identifier %s passhprase %s", identifier, passphrase);
+	DBG("identifier %s security %s passhprase %s",
+					identifier, security, passphrase);
 
-	if (__supplicant_connect(element, ssid, ssid_len, passphrase) < 0)
+	if (__supplicant_connect(element, ssid, ssid_len,
+						security, passphrase) < 0)
 		connman_error("Failed to initiate connect");
 
 	return 0;

commit 435d94a40c61c6dd73214afe7a7d989c0b61264a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:15:53 2008 +0100

    Set the correct key management for WEP protected networks

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b7d01cf8..39e1624d 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -502,12 +502,26 @@ static int set_network(struct supplicant_task *task,
 	connman_dbus_dict_append_array(&dict, "ssid",
 					DBUS_TYPE_BYTE, &network, len);
 
-	if (passphrase && strlen(passphrase) > 0) {
+	if (g_ascii_strcasecmp(security, "wpa") == 0 ||
+				g_ascii_strcasecmp(security, "wpa2") == 0) {
 		const char *key_mgmt = "WPA-PSK";
 		connman_dbus_dict_append_variant(&dict, "key_mgmt",
 						DBUS_TYPE_STRING, &key_mgmt);
-		connman_dbus_dict_append_variant(&dict, "psk",
+
+		if (passphrase && strlen(passphrase) > 0)
+			connman_dbus_dict_append_variant(&dict, "psk",
+						DBUS_TYPE_STRING, &passphrase);
+	} else if (g_ascii_strcasecmp(security, "wep") == 0) {
+		const char *key_mgmt = "NONE", *index = "0";
+		connman_dbus_dict_append_variant(&dict, "key_mgmt",
+						DBUS_TYPE_STRING, &key_mgmt);
+
+		if (passphrase && strlen(passphrase) > 0) {
+			connman_dbus_dict_append_variant(&dict, "wep_key0",
 						DBUS_TYPE_STRING, &passphrase);
+			connman_dbus_dict_append_variant(&dict, "wep_tx_keyidx",
+						DBUS_TYPE_STRING, &index);
+		}
 	} else {
 		const char *key_mgmt = "NONE";
 		connman_dbus_dict_append_variant(&dict, "key_mgmt",

commit 13006c2850b7017da698a457c48726777db68234
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:25:34 2008 +0100

    Allow setting of Powered property

diff --git a/src/element.c b/src/element.c
index 926302d6..eb91fc9d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -304,6 +304,76 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *do_update(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+
+	DBG("conn %p", conn);
+
+	if (element->enabled == FALSE)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	if (element->driver && element->driver->update) {
+		DBG("Calling update callback");
+		element->driver->update(element);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *do_enable(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+
+	DBG("conn %p", conn);
+
+	if (element->enabled == TRUE)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	if (element->driver && element->driver->enable) {
+		DBG("Calling enable callback");
+		if (element->driver->enable(element) < 0)
+			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+	}
+
+	element->enabled = TRUE;
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *do_disable(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+
+	DBG("conn %p", conn);
+
+	if (element->enabled == FALSE)
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+
+	if (element->driver && element->driver->disable) {
+		DBG("Calling disable callback");
+		if (element->driver->disable(element) < 0)
+			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+	}
+
+	element->enabled = FALSE;
+
+	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
+				DBUS_TYPE_OBJECT_PATH, &element->path,
+							DBUS_TYPE_INVALID);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static void append_networks(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
@@ -373,6 +443,43 @@ static DBusMessage *get_device_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *set_device_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessageIter iter;
+	DBusMessageIter value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	if (g_str_equal(name, "Powered") == TRUE) {
+		dbus_bool_t powered;
+
+		dbus_message_iter_get_basic(&value, &powered);
+
+		if (powered == TRUE)
+			do_enable(conn, msg, data);
+		else
+			do_disable(conn, msg, data);
+	} else
+		set_common_property(element, name, &value);
+
+	__connman_element_store(element);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *get_network_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -538,76 +645,6 @@ static DBusMessage *clear_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static DBusMessage *do_update(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-
-	DBG("conn %p", conn);
-
-	if (element->enabled == FALSE)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-
-	if (element->driver && element->driver->update) {
-		DBG("Calling update callback");
-		element->driver->update(element);
-	}
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *do_enable(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-
-	DBG("conn %p", conn);
-
-	if (element->enabled == TRUE)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-
-	if (element->driver && element->driver->enable) {
-		DBG("Calling enable callback");
-		if (element->driver->enable(element) < 0)
-			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-	}
-
-	element->enabled = TRUE;
-
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *do_disable(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-
-	DBG("conn %p", conn);
-
-	if (element->enabled == FALSE)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-
-	if (element->driver && element->driver->disable) {
-		DBG("Calling disable callback");
-		if (element->driver->disable(element) < 0)
-			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-	}
-
-	element->enabled = FALSE;
-
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
 static GDBusMethodTable element_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_properties },
 	{ "SetProperty",   "sv", "",      set_property   },
@@ -625,6 +662,7 @@ static GDBusSignalTable element_signals[] = {
 
 static GDBusMethodTable device_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_device_properties },
+	{ "SetProperty",   "sv", "",      set_device_property   },
 	{ },
 };
 

commit b9d78ccae06676a1cc82b1555bc14fb6ecfcdae0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:27:51 2008 +0100

    Change test scripts to use Powered property

diff --git a/test/disable-device b/test/disable-device
index ac55e77a..31e9f951 100755
--- a/test/disable-device
+++ b/test/disable-device
@@ -7,17 +7,17 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
 					'org.moblin.connman.Manager')
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
-	element = dbus.Interface(bus.get_object('org.moblin.connman', path),
-						'org.moblin.connman.Element')
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Device')
 
-	properties = element.GetProperties()
+	properties = device.GetProperties()
 
-	if (properties["Type"] != "device"):
+	if (properties["Powered"] == dbus.Boolean(0)):
 		continue
 
 	print "[ %s ]" % (path)
 
-	element.Disable()
+	device.SetProperty("Powered", dbus.Boolean(0));
diff --git a/test/enable-device b/test/enable-device
index 55bd1f19..e79b7361 100755
--- a/test/enable-device
+++ b/test/enable-device
@@ -7,17 +7,17 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
 					'org.moblin.connman.Manager')
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
-	element = dbus.Interface(bus.get_object('org.moblin.connman', path),
-						'org.moblin.connman.Element')
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Device')
 
-	properties = element.GetProperties()
+	properties = device.GetProperties()
 
-	if (properties["Type"] != "device"):
+	if (properties["Powered"] == dbus.Boolean(1)):
 		continue
 
 	print "[ %s ]" % (path)
 
-	element.Enable()
+	device.SetProperty("Powered", dbus.Boolean(1));

commit 16d4d541a41c4829c4e72602327b5157f4bb35cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:34:33 2008 +0100

    Add script for setting a passphrase

diff --git a/test/Makefile.am b/test/Makefile.am
index fe11939d..e0be1bc4 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,7 +1,7 @@
 
 EXTRA_DIST = list-profiles list-elements monitor-elements monitor-state \
-		get-state select-network disable-network monitor-networks \
-		enable-device disable-device start-scanning simple-agent \
-		show-introspection test-compat test-supplicant
+		get-state set-passphrase select-network disable-network \
+		monitor-networks enable-device disable-device start-scanning \
+		simple-agent show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/set-passphrase b/test/set-passphrase
new file mode 100755
index 00000000..db39554f
--- /dev/null
+++ b/test/set-passphrase
@@ -0,0 +1,31 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 3):
+	print "Usage: %s <network> <passphrase>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	for path in properties["Networks"]:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if (properties["WiFi.Name"] == sys.argv[1]):
+			print "Setting passphrase for %s" % (path)
+			network.SetProperty("WiFi.Passphrase", sys.argv[2])

commit 7ec68330d2e0c729ad37b0f724b7d2f93653246b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:50:47 2008 +0100

    Don't overwrite security settings if already set

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 294b7716..1e7df6bd 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -83,10 +83,8 @@ static int network_enable(struct connman_element *element)
 		}
 	}
 
-	if (connman_element_get_static_property(element,
-					"WiFi.Security", &security) == FALSE)
-		connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_WIFI_SECURITY, &security);
+	connman_element_get_value(element,
+			CONNMAN_PROPERTY_ID_WIFI_SECURITY, &security);
 
 	connman_element_get_value(element,
 			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &passphrase);
@@ -198,7 +196,6 @@ static void scan_result(struct connman_element *parent,
 
 	element = find_element(data, network->identifier);
 	if (element == NULL) {
-		const char *security;
 		guint8 strength;
 
 		element = connman_element_create(temp);
@@ -214,17 +211,20 @@ static void scan_result(struct connman_element *parent,
 		connman_element_add_static_array_property(element, "WiFi.SSID",
 			DBUS_TYPE_BYTE, &network->ssid, network->ssid_len);
 
-		if (network->has_rsn == TRUE)
-			security = "wpa2";
-		else if (network->has_wpa == TRUE)
-			security = "wpa";
-		else if (network->has_wep == TRUE)
-			security = "wep";
-		else
-			security = "none";
+		if (element->wifi.security == NULL) {
+			const char *security;
 
-		connman_element_add_static_property(element, "WiFi.Security",
-						DBUS_TYPE_STRING, &security);
+			if (network->has_rsn == TRUE)
+				security = "wpa2";
+			else if (network->has_wpa == TRUE)
+				security = "wpa";
+			else if (network->has_wep == TRUE)
+				security = "wep";
+			else
+				security = "none";
+
+			element->wifi.security = g_strdup(security);
+		}
 
 		strength = network->quality;
 
@@ -235,7 +235,7 @@ static void scan_result(struct connman_element *parent,
 					DBUS_TYPE_INT32, &network->noise);
 
 		DBG("%s (%s) strength %d", network->identifier,
-							security, strength);
+					element->wifi.security, strength);
 
 		connman_element_register(element, parent);
 	}

commit 0389ef2cd3b8836959c67895e3fee5802d8f64ea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 13:51:19 2008 +0100

    Disable strength and noise properties for now

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 1e7df6bd..6793eb47 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -228,11 +228,11 @@ static void scan_result(struct connman_element *parent,
 
 		strength = network->quality;
 
-		connman_element_add_static_property(element, "WiFi.Strength",
-						DBUS_TYPE_BYTE, &strength);
+		//connman_element_add_static_property(element, "WiFi.Strength",
+		//				DBUS_TYPE_BYTE, &strength);
 
-		connman_element_add_static_property(element, "WiFi.Noise",
-					DBUS_TYPE_INT32, &network->noise);
+		//connman_element_add_static_property(element, "WiFi.Noise",
+		//			DBUS_TYPE_INT32, &network->noise);
 
 		DBG("%s (%s) strength %d", network->identifier,
 					element->wifi.security, strength);

commit 27de961c1576ac7588b100e62b9c3fb55019ed5c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 14:59:14 2008 +0100

    Replace more unallowed characters

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 6793eb47..51045869 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -185,7 +185,11 @@ static void scan_result(struct connman_element *parent,
 	temp = g_strdup(network->identifier);
 
 	for (i = 0; i < strlen(temp); i++) {
-		if (temp[i] == ' ' || temp[i] == '.' || temp[i] == '-')
+		if (temp[i] == ' ' || temp[i] == '.')
+			temp[i] = '_';
+		else if (temp[i] == '-' || temp[i] == '+')
+			temp[i] = '_';
+		else if (temp[i] == '!' || temp[i] == '?')
 			temp[i] = '_';
 		else if (temp[i] == '(' || temp[i] == ')')
 			temp[i] = '_';

commit 51b3dc6f611f7a0b1bbf309a4ac766a696828fff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 22:55:10 2008 +0100

    Add network methods for connect and disconnect

diff --git a/src/element.c b/src/element.c
index eb91fc9d..0eda55c3 100644
--- a/src/element.c
+++ b/src/element.c
@@ -669,6 +669,8 @@ static GDBusMethodTable device_methods[] = {
 static GDBusMethodTable network_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_network_properties },
 	{ "SetProperty",   "sv", "",      set_network_property   },
+	{ "Connect",       "",   "",      do_enable              },
+	{ "Disconnect",    "",   "",      do_disable             },
 	{ },
 };
 

commit 1a3b9647cf270105ddc3d62ade586a776dc93592
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 22:55:35 2008 +0100

    Use network interface for connecting and disconnecting

diff --git a/test/disable-network b/test/disable-network
index eede449b..beea2f10 100755
--- a/test/disable-network
+++ b/test/disable-network
@@ -7,19 +7,22 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-elements = manager.ListElements()
-
-for path in elements:
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
-
-	try:
-		properties = element.GetProperties()
-		if (properties["Type"] != "network"):
-			continue
-
-		if (properties["Enabled"] == dbus.Boolean(1)):
-			print "Disabling %s" % (path)
-			element.Disable()
-	except:
-		pass
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	print "[ %s ]" % (path)
+
+	for path in properties["Networks"]:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if (properties["Connected"] == dbus.Boolean(1)):
+			print "Disconnecting %s" % (path)
+			network.Disconnect()
diff --git a/test/select-network b/test/select-network
index 76845469..e7491e8a 100755
--- a/test/select-network
+++ b/test/select-network
@@ -12,19 +12,25 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
 
-	properties = element.GetProperties()
-	if (properties["Type"] != "network"):
-		continue
+	properties = device.GetProperties()
 
-	if (properties["Enabled"] == dbus.Boolean(1)):
-		continue
+	print "[ %s ]" % (path)
 
-	if (properties["WiFi.Name"] == sys.argv[1]):
-		print "Enabling %s" % (path)
-		element.Enable()
+	for path in properties["Networks"]:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if (properties["Connected"] == dbus.Boolean(1)):
+			continue
+
+		if (properties["WiFi.Name"] == sys.argv[1]):
+			print "Connecting %s" % (path)
+			network.Connect()

commit 647a017fc5c757d99dd39e2a65f113abe3ea0a3e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 22:57:52 2008 +0100

    Only introspect devices

diff --git a/test/show-introspection b/test/show-introspection
index 86faca18..bbf93c8b 100755
--- a/test/show-introspection
+++ b/test/show-introspection
@@ -12,9 +12,9 @@ print object.Introspect()
 manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 					"org.moblin.connman.Manager")
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
+for path in properties["Devices"]:
 	object = dbus.Interface(bus.get_object("org.moblin.connman", path),
 					"org.freedesktop.DBus.Introspectable")
 

commit 0b55d59e5c43bb5358fb830691f504ffee8d7e75
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 23:00:14 2008 +0100

    Add method for starting scan via the device interface

diff --git a/src/element.c b/src/element.c
index 0eda55c3..408c46ef 100644
--- a/src/element.c
+++ b/src/element.c
@@ -663,6 +663,7 @@ static GDBusSignalTable element_signals[] = {
 static GDBusMethodTable device_methods[] = {
 	{ "GetProperties", "",   "a{sv}", get_device_properties },
 	{ "SetProperty",   "sv", "",      set_device_property   },
+	{ "Scan",          "",   "",      do_update             },
 	{ },
 };
 

commit 416e8cbe721a7ed8052e599edd3b7ae4249642ba
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 3 23:02:07 2008 +0100

    Use device interface to trigger scanning

diff --git a/test/start-scanning b/test/start-scanning
index ff0dd07a..9d3f4db5 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -7,25 +7,22 @@ bus = dbus.SystemBus()
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
 					'org.moblin.connman.Manager')
 
-elements = manager.ListElements()
+properties = manager.GetProperties()
 
-for path in elements:
-	element = dbus.Interface(bus.get_object('org.moblin.connman', path),
-						'org.moblin.connman.Element')
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Device')
 
-	properties = element.GetProperties()
-
-	if (properties["Type"] != "device"):
-		continue
+	properties = device.GetProperties()
 
 	print "[ %s ]" % (path)
 
-	if (properties["Subtype"] == "wifi"):
+	if (properties["Type"] == "wifi"):
 		print "   Started WiFi scanning"
-		element.Update()
-	elif (properties["Subtype"] == "wimax"):
+		device.Scan()
+	elif (properties["Type"] == "wimax"):
 		print "   Started WiMAX scanning"
-		element.Update()
+		device.Scan()
 	else:
 		print "   No scanning"
 

commit cb90dac4899d26d218e4786f3abd09f37ed55a24
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 10:58:44 2008 +0100

    Use D-Bus API text based documentation

diff --git a/.gitignore b/.gitignore
index dd020eac..c774574a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -35,6 +35,4 @@ doc/connman.*
 doc/connman-*.txt
 doc/*.sgml
 doc/version.xml
-doc/xml
-doc/dbus
 doc/html
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 752c5ccf..7fe30702 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -21,7 +21,7 @@ IGNORE_HFILES = connman connman.h rtnl.h dbus.h iface.h
 
 HTML_IMAGES =
 
-content_files = connman-introduction.xml dbus/manager.xml
+content_files = connman-introduction.xml
 
 INCLUDES = -I$(top_srcdir)/include -I$(top_srcdir)/gdbus \
 	$(GTHREAD_CFLAGS) $(GMODULE_CFLAGS) $(GLIB_CFLAGS) $(DBUS_CFLAGS)
@@ -33,22 +33,9 @@ MAINTAINERCLEANFILES = Makefile.in \
 
 if ENABLE_GTK_DOC
 include $(top_srcdir)/doc/gtk-doc.make
-
-dbus/manager.xml: dbus-manager.xml dbus-introspection.xsl
-	$(MKDIR_P) -p $(builddir)/dbus
-	echo "<?xml version=\"1.0\"?>" > $@
-	echo "<!DOCTYPE refentry PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\">" >> $@
-	$(XSLTPROC) dbus-introspection.xsl $< | tail -n +2 >> $@
-
-clean-local:
-	rm -rf $(builddir)/dbus
-
 else
 EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
-EXTRA_DIST += dbus-introspection.dtd dbus-introspection.xsl \
-						dbus-manager.xml
-
 EXTRA_DIST += manager-api.txt device-api.txt network-api.txt \
 			connection-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 9c5affc4..d709168f 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -57,17 +57,6 @@
     <xi:include href="connman-introduction.xml" />
   </reference>
 
-  <reference id="dbus">
-    <title>D-Bus API Reference</title>
-    <partintro>
-      <para>
-	This part presents the D-Bus interface used to access Connection
-	Manager.
-      </para>
-    </partintro>
-    <xi:include href="dbus/manager.xml"/>
-  </reference>
-
   <reference id="manager">
     <title>Manager interface</title>
     <para>
diff --git a/doc/dbus-introspection.dtd b/doc/dbus-introspection.dtd
deleted file mode 100644
index 5fe508ef..00000000
--- a/doc/dbus-introspection.dtd
+++ /dev/null
@@ -1,32 +0,0 @@
-<!-- DTD for D-Bus Introspection Documentation -->
-
-<!ELEMENT doc (summary?,description?,errors?,permission?,since?,deprecated,seealso?)>
-
-<!ELEMENT summary (#PCDATA|ref)*>
-<!ELEMENT description (#PCDATA|para|example)*>
-<!ELEMENT errors (error)*>
-<!ELEMENT permission (#PCDATA|ref|para)*>
-<!ELEMENT since EMPTY>
-<!ATTLIST since version CDATA #REQUIRED>
-<!ELEMENT deprecated (#PCDATA|ref)>
-<!ATTLIST deprecated version CDATA #REQUIRED>
-<!ATTLIST deprecated instead CDATA #REQUIRED>
-<!ELEMENT seealso (ref+)>
-
-<!ELEMENT error (#PCDATA|para)*>
-<!ATTLIST error name CDATA #REQUIRED>
-<!ELEMENT para (#PCDATA|example|code|list|ref)*>
-<!ELEMENT example (#PCDATA|para|code|ref)*>
-<!ATTLIST language (c|glib|python|shell) #REQUIRED>
-<!ATTLIST title CDATA #IMPLIED>
-<!ELEMENT list (listheader?, item*)>
-<!ATTLIST list type (bullet|number|table) #REQUIRED>
-<!ELEMENT item (term|definition)*>
-<!ELEMENT term (#PCDATA|ref)*>
-<!ELEMENT definition (#PCDATA|para)*>
-
-<!ELEMENT code (#PCDATA)>
-<!ATTLIST code lang CDATA #IMPLIED>
-<!ELEMENT ref CDATA>
-<!ATTLIST ref type (parameter|arg|signal|method|interface) #REQUIRED>
-<!ATTLIST ref to CDATA #REQUIRED>
diff --git a/doc/dbus-introspection.xsl b/doc/dbus-introspection.xsl
deleted file mode 100644
index 679b3589..00000000
--- a/doc/dbus-introspection.xsl
+++ /dev/null
@@ -1,436 +0,0 @@
-<?xml version='1.0'?>
-<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
-  xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd"
-  exclude-result-prefixes="doc">
-<!--
-     Convert D-Bus GLib XML into DocBook refentries
-     Copyright (C) 2007 William Jon McCann
-     License: GPL
--->
-<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
-
-<xsl:template match="/">
-
-<xsl:variable name="interface" select="//interface/@name"/>
-<xsl:variable name="basename">
-  <xsl:call-template name="interface-basename">
-    <xsl:with-param name="str" select="$interface"/>
-  </xsl:call-template>
-</xsl:variable>
-
-<refentry><xsl:attribute name="id"><xsl:value-of select="$basename"/></xsl:attribute>
-  <refmeta>
-    <refentrytitle role="top_of_page"><xsl:value-of select="//interface/@name"/></refentrytitle>
-  </refmeta>
-
-  <refnamediv>
-    <refname><xsl:value-of select="//interface/@name"/></refname>
-    <refpurpose><xsl:value-of select="$basename"/> interface</refpurpose>
-  </refnamediv>
-
-  <refsynopsisdiv role="synopsis">
-    <title role="synopsis.title">Methods</title>
-    <synopsis>
-  <xsl:call-template name="methods-synopsis">
-    <xsl:with-param name="basename" select="$basename"/>
-  </xsl:call-template>
-    </synopsis>
-  </refsynopsisdiv>
-
-  <refsect1 role="signal_proto">
-    <title role="signal_proto.title">Signals</title>
-    <synopsis>
-  <xsl:call-template name="signals-synopsis">
-    <xsl:with-param name="basename" select="$basename"/>
-  </xsl:call-template>
-    </synopsis>
-  </refsect1>
-
-  <refsect1 role="impl_interfaces">
-    <title role="impl_interfaces.title">Implemented Interfaces</title>
-    <para>
-    <xsl:value-of select="$interface"/> implements
-    org.freedesktop.DBus.Introspectable,
-    org.freedesktop.DBus.Properties
-    </para>
-  </refsect1>
-
-  <refsect1 role="properties">
-    <title role="properties.title">Properties</title>
-    <synopsis>
-  <xsl:call-template name="properties-synopsis">
-    <xsl:with-param name="basename" select="$basename"/>
-  </xsl:call-template>
-    </synopsis>
-  </refsect1>
-
-  <refsect1 role="desc">
-    <title role="desc.title">Description</title>
-    <para>
-      <xsl:apply-templates select="//interface/doc:doc"/>
-    </para>
-  </refsect1>
-
-  <refsect1 role="details">
-    <title role="details.title">Details</title>
-    <xsl:call-template name="method-details">
-      <xsl:with-param name="basename" select="$basename"/>
-    </xsl:call-template>
-  </refsect1>
-
-  <refsect1 role="signals">
-    <title role="signals.title">Signal Details</title>
-    <xsl:call-template name="signal-details">
-      <xsl:with-param name="basename" select="$basename"/>
-    </xsl:call-template>
-  </refsect1>
-
-  <refsect1 role="property_details">
-    <title role="property_details.title">Property Details</title>
-    <xsl:call-template name="property-details">
-      <xsl:with-param name="basename" select="$basename"/>
-    </xsl:call-template>
-  </refsect1>
-
-</refentry>
-</xsl:template>
-
-
-<xsl:template name="property-doc">
-  <xsl:apply-templates select="doc:doc/doc:description"/>
-
-  <variablelist role="params">
-    <xsl:for-each select="arg">
-<varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-<listitem><simpara><xsl:value-of select="doc:doc/doc:summary"/></simpara></listitem>
-</varlistentry>
-    </xsl:for-each>
-  </variablelist>
-
-  <xsl:apply-templates select="doc:doc/doc:since"/>
-  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
-  <xsl:apply-templates select="doc:doc/doc:permission"/>
-  <xsl:apply-templates select="doc:doc/doc:seealso"/>
-</xsl:template>
-
-
-<xsl:template name="property-details">
-  <xsl:param name="basename"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///property">
-  <refsect2>
-    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$basename"/>:<xsl:value-of select="@name"/></xsl:attribute></anchor>The "<xsl:value-of select="@name"/>" property</title>
-<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$basename"/></secondary></indexterm>
-<programlisting>'<xsl:value-of select="@name"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="2"/></xsl:call-template>
-<xsl:call-template name="property-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/></xsl:call-template></programlisting>
-  </refsect2>
-
-  <xsl:call-template name="property-doc"/>
-
-  </xsl:for-each>
-</xsl:template>
-
-<xsl:template name="signal-doc">
-  <xsl:apply-templates select="doc:doc/doc:description"/>
-
-  <variablelist role="params">
-    <xsl:for-each select="arg">
-<varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-<listitem><simpara><xsl:value-of select="doc:doc/doc:summary"/></simpara></listitem>
-</varlistentry>
-    </xsl:for-each>
-  </variablelist>
-
-  <xsl:apply-templates select="doc:doc/doc:since"/>
-  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
-  <xsl:apply-templates select="doc:doc/doc:permission"/>
-  <xsl:apply-templates select="doc:doc/doc:seealso"/>
-</xsl:template>
-
-<xsl:template name="signal-details">
-  <xsl:param name="basename"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///signal">
-  <refsect2>
-    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$basename"/>::<xsl:value-of select="@name"/></xsl:attribute></anchor>The <xsl:value-of select="@name"/> signal</title>
-<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$basename"/></secondary></indexterm>
-<programlisting><xsl:value-of select="@name"/> (<xsl:call-template name="signal-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/><xsl:with-param name="prefix" select="."/></xsl:call-template>)</programlisting>
-  </refsect2>
-
-  <xsl:call-template name="signal-doc"/>
-
-  </xsl:for-each>
-</xsl:template>
-
-<xsl:template match="doc:code">
-<programlisting>
-<xsl:apply-templates />
-</programlisting>
-</xsl:template>
-
-<xsl:template match="doc:summary">
-<!-- by default don't display -->
-</xsl:template>
-
-<xsl:template match="doc:example">
-<informalexample>
-<xsl:apply-templates />
-</informalexample>
-</xsl:template>
-
-<xsl:template match="doc:para">
-<para>
-<xsl:apply-templates />
-</para>
-</xsl:template>
-
-<xsl:template match="doc:description">
-<xsl:apply-templates />
-</xsl:template>
-
-<xsl:template match="doc:since">
-<para role="since">Since <xsl:value-of select="@version"/>
-</para>
-</xsl:template>
-
-<xsl:template match="doc:deprecated">
-  <xsl:variable name="name" select="../../@name"/>
-  <xsl:variable name="parent">
-    <xsl:call-template name="interface-basename">
-      <xsl:with-param name="str" select="../../../@name"/>/>
-    </xsl:call-template>
-  </xsl:variable>
-
-  <xsl:variable name="type" select="name(../..)"/>
-
-  <para role="deprecated">
-  <warning><para><literal><xsl:value-of select="$name"/></literal> is deprecated since version <xsl:value-of select="@version"/> and should not be used in newly-written code. Use
-
-  <xsl:variable name="to">
-  <xsl:choose>
-    <xsl:when test="contains($type,'property')">
-      <xsl:value-of select="$parent"/>:<xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:when test="contains($type,'signal')">
-      <xsl:value-of select="$parent"/>::<xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:when test="contains($type,'method')">
-      <xsl:value-of select="$parent"/>.<xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:when test="contains($type,'interface')">
-      <xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:otherwise>
-      <xsl:value-of select="@instead"/>
-    </xsl:otherwise>
-  </xsl:choose>
-  </xsl:variable>
-
-  <xsl:call-template name="create-link">
-    <xsl:with-param name="type" select="$type"/>
-    <xsl:with-param name="to" select="$to"/>
-    <xsl:with-param name="val" select="@instead"/>
-  </xsl:call-template>
-instead.</para></warning>
-</para>
-</xsl:template>
-
-<xsl:template match="doc:permission">
-<para role="permission">
-<xsl:apply-templates />
-</para>
-</xsl:template>
-
-<xsl:template match="doc:seealso">
-<para>
-See also:
-<xsl:apply-templates />
-
-</para>
-</xsl:template>
-
-<xsl:template name="create-link">
-  <xsl:param name="type"/>
-  <xsl:param name="to"/>
-  <xsl:param name="val"/>
-
-  <xsl:choose>
-    <xsl:when test="contains($type,'property')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><literal><xsl:value-of select="$val"/></literal></link>
-    </xsl:when>
-    <xsl:when test="contains($type,'signal')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><literal><xsl:value-of select="$val"/></literal></link>
-    </xsl:when>
-    <xsl:when test="contains($type,'method')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><function><xsl:value-of select="$val"/></function></link>
-    </xsl:when>
-    <xsl:when test="contains($type,'interface')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><xsl:value-of select="$val"/></link>
-    </xsl:when>
-  </xsl:choose>
-</xsl:template>
-
-<xsl:template match="doc:ref">
-  <xsl:call-template name="create-link">
-    <xsl:with-param name="type" select="@type"/>
-    <xsl:with-param name="to" select="@to"/>
-    <xsl:with-param name="val" select="."/>
-  </xsl:call-template>
-</xsl:template>
-
-<xsl:template name="method-doc">
-  <xsl:apply-templates select="doc:doc/doc:description"/>
-
-  <variablelist role="params">
-    <xsl:for-each select="arg">
-<varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-<listitem><simpara><xsl:value-of select="doc:doc/doc:summary"/></simpara></listitem>
-</varlistentry>
-    </xsl:for-each>
-  </variablelist>
-
-  <xsl:apply-templates select="doc:doc/doc:since"/>
-  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
-  <xsl:apply-templates select="doc:doc/doc:permission"/>
-  <xsl:apply-templates select="doc:doc/doc:seealso"/>
-</xsl:template>
-
-<xsl:template name="method-details">
-  <xsl:param name="basename"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///method">
-    <refsect2>
-    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$basename"/>.<xsl:value-of select="@name"/></xsl:attribute></anchor><xsl:value-of select="@name"/> ()</title>
-<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$basename"/></secondary></indexterm>
-<programlisting><xsl:value-of select="@name"/> (<xsl:call-template name="method-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/><xsl:with-param name="prefix" select="."/></xsl:call-template>)</programlisting>
-    </refsect2>
-
-    <xsl:call-template name="method-doc"/>
-
-  </xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="properties-synopsis">
-  <xsl:param name="basename"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="///property/@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///property">
-<link><xsl:attribute name="linkend"><xsl:value-of select="$basename"/>:<xsl:value-of select="@name"/></xsl:attribute>'<xsl:value-of select="@name"/>'</link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template> <xsl:call-template name="property-args"><xsl:with-param name="indent" select="$longest + 2"/></xsl:call-template>
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="signals-synopsis">
-  <xsl:param name="basename"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="///signal/@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///signal">
-<link><xsl:attribute name="linkend"><xsl:value-of select="$basename"/>::<xsl:value-of select="@name"/></xsl:attribute><xsl:value-of select="@name"/></link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template>(<xsl:call-template name="signal-args"><xsl:with-param name="indent" select="$longest + 2"/><xsl:with-param name="prefix" select="///signal"/></xsl:call-template>)
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="methods-synopsis">
-  <xsl:param name="basename"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="///method/@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///method">
-<link><xsl:attribute name="linkend"><xsl:value-of select="$basename"/>.<xsl:value-of select="@name"/></xsl:attribute><xsl:value-of select="@name"/></link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template>(<xsl:call-template name="method-args"><xsl:with-param name="indent" select="$longest + 2"/><xsl:with-param name="prefix" select="///method"/></xsl:call-template>)
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="method-args"><xsl:param name="indent"/><xsl:param name="prefix"/><xsl:variable name="longest"><xsl:call-template name="find-longest"><xsl:with-param name="set" select="$prefix/arg/@type"/></xsl:call-template></xsl:variable><xsl:for-each select="arg"><xsl:value-of select="@direction"/>
-<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="4 - string-length(@direction)"/></xsl:call-template>'<xsl:value-of select="@type"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@type) + 1"/></xsl:call-template>
-<xsl:value-of select="@name"/><xsl:if test="not(position() = last())">,
-<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$indent"/></xsl:call-template></xsl:if>
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="signal-args"><xsl:param name="indent"/><xsl:param name="prefix"/><xsl:variable name="longest"><xsl:call-template name="find-longest"><xsl:with-param name="set" select="$prefix/arg/@type"/></xsl:call-template></xsl:variable><xsl:for-each select="arg">'<xsl:value-of select="@type"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@type) + 1"/></xsl:call-template>
-<xsl:value-of select="@name"/><xsl:if test="not(position() = last())">,
-<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$indent"/></xsl:call-template></xsl:if>
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="property-args"><xsl:param name="indent"/>
-<xsl:value-of select="@access"/><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="9 - string-length(@access) + 1"/></xsl:call-template>'<xsl:value-of select="@type"/>'
-</xsl:template>
-
-
-<xsl:template name="pad-spaces">
-  <xsl:param name="width"/>
-  <xsl:variable name="spaces" xml:space="preserve">                                                                        </xsl:variable>
-  <xsl:value-of select="substring($spaces,1,$width)"/>
-</xsl:template>
-
-
-<xsl:template name="find-longest">
-  <xsl:param name="set"/>
-  <xsl:param name="index" select="1"/>
-  <xsl:param name="longest" select="0"/>
-
-  <xsl:choose>
-    <xsl:when test="$index > count($set)">
-      <!--finished looking-->
-      <xsl:value-of select="$longest"/>
-    </xsl:when>
-    <xsl:when test="string-length($set[$index])>$longest">
-      <!--found new longest-->
-      <xsl:call-template name="find-longest">
-        <xsl:with-param name="set" select="$set"/>
-        <xsl:with-param name="index" select="$index + 1"/>
-        <xsl:with-param name="longest" select="string-length($set[$index])"/>
-      </xsl:call-template>
-    </xsl:when>
-    <xsl:otherwise>
-      <!--this isn't any longer-->
-      <xsl:call-template name="find-longest">
-        <xsl:with-param name="set" select="$set"/>
-        <xsl:with-param name="index" select="$index + 1"/>
-        <xsl:with-param name="longest" select="$longest"/>
-      </xsl:call-template>
-    </xsl:otherwise>
-  </xsl:choose>
-</xsl:template>
-
-
-<xsl:template name="interface-basename">
-  <xsl:param name="str"/>
-  <xsl:choose>
-    <xsl:when test="contains($str,'.')">
-      <xsl:call-template name="interface-basename">
-	<xsl:with-param name="str" select="substring-after($str,'.')"/>
-      </xsl:call-template>
-    </xsl:when>
-    <xsl:otherwise>
-      <xsl:value-of select="$str"/>
-    </xsl:otherwise>
-  </xsl:choose>
-</xsl:template>
-
-</xsl:stylesheet>
diff --git a/doc/dbus-manager.xml b/doc/dbus-manager.xml
deleted file mode 100644
index 446cd7e9..00000000
--- a/doc/dbus-manager.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<!DOCTYPE node PUBLIC
-	"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
-	"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-
-  <interface name="org.moblin.connman.Manager">
-
-    <method name="ListElements">
-      <arg name="list" direction="out" type="ao">
-        <doc:doc>
-          <doc:summary>
-            <doc:para>
-              List of object paths representing an element.
-            </doc:para>
-          </doc:summary>
-        </doc:doc>
-      </arg>
-
-      <doc:doc>
-        <doc:description>
-          <doc:para>
-            List all registered elements in the system.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-  </interface>
-
-</node>

commit 76a376b0671b6e791ee3b5aa859e3f2dabd7bcd1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 11:07:03 2008 +0100

    Mention the automake version 1.10 requirement

diff --git a/HACKING b/HACKING
index eb1db38a..221bfed2 100644
--- a/HACKING
+++ b/HACKING
@@ -2,6 +2,22 @@ Hacking on Connection Manager
 *****************************
 
 
+Build tools requirements
+========================
+
+When building and testing directly from the repository it is important to
+have at least automake version 1.10 or later installed. All modern
+distributions should default to the latest version, but it seems that
+Debian's default is still an earlier version:
+
+  Check version
+    # dpkg -l '*automake*'
+
+  Install new version
+    # apt-get install automake1.10
+    # update-alternatives --config automake
+
+
 Working with the source code repository
 =======================================
 

commit 8bda03b4654dd6dd4875c70dcdb7e1befe77421a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 11:13:35 2008 +0100

    Add API skeleton for service interface

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 7fe30702..4a52ec27 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -37,5 +37,5 @@ else
 EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
-EXTRA_DIST += manager-api.txt device-api.txt network-api.txt \
-			connection-api.txt agent-api.txt plugin-api.txt
+EXTRA_DIST += manager-api.txt device-api.txt network-api.txt service-api.txt \
+				connection-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index d709168f..542c4e18 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -78,6 +78,20 @@
     </para>
   </reference>
 
+  <reference id="service">
+    <title>Service interface</title>
+    <para>
+<programlisting><xi:include href="service-api.txt" parse="text" /></programlisting>
+    </para>
+  </reference>
+
+  <reference id="connection">
+    <title>Connection interface</title>
+    <para>
+<programlisting><xi:include href="connection-api.txt" parse="text" /></programlisting>
+    </para>
+  </reference>
+
   <reference id="reference">
     <title>Plugin API Reference</title>
     <partintro>
diff --git a/doc/service-api.txt b/doc/service-api.txt
new file mode 100644
index 00000000..0e5b13e6
--- /dev/null
+++ b/doc/service-api.txt
@@ -0,0 +1,23 @@
+Service hierarchy
+=================
+
+Service		org.moblin.connman
+Interface	org.moblin.connman.Service
+Object path	[variable prefix]/{service0,service1,...}
+
+Methods		dict GetProperties()
+
+			Returns properties for the service object. See
+			the properties section for available properties.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
+Signals		PropertyChanged(string name, variant value)
+
+			This signal indicates a changed value of the given
+			property.
+
+Properties	string Identifier [readonly]
+
+			Unique identifier for this service.

commit a1e81534eef5bae1b27c2839bc0762feb53d2c22
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 11:14:12 2008 +0100

    Add doc/xml/ directory to ignore list

diff --git a/.gitignore b/.gitignore
index c774574a..f4b0834b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -35,4 +35,5 @@ doc/connman.*
 doc/connman-*.txt
 doc/*.sgml
 doc/version.xml
+doc/xml
 doc/html

commit fb4cdf2283756b5fe31526420d151d7b740f419a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 11:22:06 2008 +0100

    Disable element D-Bus API for now

diff --git a/src/element.c b/src/element.c
index 408c46ef..56965de5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -258,52 +258,6 @@ static void set_common_property(struct connman_element *element,
 	__connman_element_unlock(element);
 }
 
-static DBusMessage *get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	const char *str;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	if (element->parent != NULL &&
-			element->parent->type != CONNMAN_ELEMENT_TYPE_ROOT) {
-		connman_dbus_dict_append_variant(&dict, "Parent",
-				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
-	}
-
-	str = type2string(element->type);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Type",
-						DBUS_TYPE_STRING, &str);
-	str = subtype2string(element->subtype);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Subtype",
-						DBUS_TYPE_STRING, &str);
-
-	connman_dbus_dict_append_variant(&dict, "Enabled",
-					DBUS_TYPE_BOOLEAN, &element->enabled);
-
-	add_common_properties(element, &dict);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
 static DBusMessage *do_update(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -577,6 +531,53 @@ static DBusMessage *get_connection_properties(DBusConnection *conn,
 	return reply;
 }
 
+#if 0
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *str;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	if (element->parent != NULL &&
+			element->parent->type != CONNMAN_ELEMENT_TYPE_ROOT) {
+		connman_dbus_dict_append_variant(&dict, "Parent",
+				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
+	}
+
+	str = type2string(element->type);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
+	str = subtype2string(element->subtype);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Subtype",
+						DBUS_TYPE_STRING, &str);
+
+	connman_dbus_dict_append_variant(&dict, "Enabled",
+					DBUS_TYPE_BOOLEAN, &element->enabled);
+
+	add_common_properties(element, &dict);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -654,6 +655,7 @@ static GDBusMethodTable element_methods[] = {
 	{ "Disable",       "",   "",      do_disable     },
 	{ },
 };
+#endif
 
 static GDBusSignalTable element_signals[] = {
 	{ "PropertyChanged", "sv" },
@@ -1579,11 +1581,13 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_node_append_data(node, element);
 
+#if 0
 	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_ELEMENT_INTERFACE,
 					element_methods, element_signals,
 					NULL, element, NULL) == FALSE)
 		connman_error("Failed to register %s element", element->path);
+#endif
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
 			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
@@ -1743,8 +1747,10 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 						CONNMAN_DEVICE_INTERFACE);
 	}
 
+#if 0
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_ELEMENT_INTERFACE);
+#endif
 
 	connman_element_unref(element);
 

commit 206a2cad3435d785ddb76980c9af7540c9a3c3d5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 12:04:30 2008 +0100

    Remove outdated test scripts

diff --git a/test/Makefile.am b/test/Makefile.am
index e0be1bc4..5d61b645 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,7 +1,7 @@
 
-EXTRA_DIST = list-profiles list-elements monitor-elements monitor-state \
-		get-state set-passphrase select-network disable-network \
-		monitor-networks enable-device disable-device start-scanning \
+EXTRA_DIST = get-state list-profiles list-connections \
+		list-devices enable-device disable-device start-scanning \
+		list-networks select-network disable-network set-passphrase \
 		simple-agent show-introspection test-compat test-supplicant
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/list-elements b/test/list-elements
deleted file mode 100755
index 3def8819..00000000
--- a/test/list-elements
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/usr/bin/python
-
-import dbus
-
-bus = dbus.SystemBus()
-
-manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
-					"org.moblin.connman.Manager")
-
-elements = manager.ListElements()
-
-for path in elements:
-	print "[ %s ]" % (path)
-
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
-
-	properties = element.GetProperties()
-	for key in properties.keys():
-		print "    %s = %s" % (key, properties[key])
-
-	print
diff --git a/test/monitor-elements b/test/monitor-elements
deleted file mode 100755
index 81803952..00000000
--- a/test/monitor-elements
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/usr/bin/python
-
-import gobject
-
-import dbus
-import dbus.service
-import dbus.mainloop.glib
-
-def element_print(action, path):
-	print "%s [ %s ]" % (action, path)
-
-	if (action == "-"):
-		return
-
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
-
-	properties = element.GetProperties()
-	for key in properties.keys():
-		print "      %s = %s" % (key, properties[key])
-
-def element_added(path):
-	element_print("+", path)
-
-def element_updated(path):
-	element_print("*", path)
-
-def element_removed(path):
-	element_print("-", path)
-
-if __name__ == '__main__':
-	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
-
-	bus = dbus.SystemBus()
-
-	bus.add_signal_receiver(element_added,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementAdded")
-
-	bus.add_signal_receiver(element_updated,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementUpdated")
-
-	bus.add_signal_receiver(element_removed,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementRemoved")
-
-	mainloop = gobject.MainLoop()
-	mainloop.run()
diff --git a/test/monitor-networks b/test/monitor-networks
deleted file mode 100755
index ce817ef9..00000000
--- a/test/monitor-networks
+++ /dev/null
@@ -1,52 +0,0 @@
-#!/usr/bin/python
-
-import gobject
-
-import dbus
-import dbus.service
-import dbus.mainloop.glib
-
-def element_print(action, path):
-	print "%s [ %s ]" % (action, path)
-
-	if (action == "-"):
-		return
-
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
-
-	properties = element.GetProperties()
-	if (properties["Type"] != "network"):
-		return
-
-	for key in properties.keys():
-		print "      %s = %s" % (key, properties[key])
-
-def element_added(path):
-	element_print("+", path)
-
-def element_updated(path):
-	element_print("*", path)
-
-def element_removed(path):
-	element_print("-", path)
-
-if __name__ == '__main__':
-	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
-
-	bus = dbus.SystemBus()
-
-	bus.add_signal_receiver(element_added,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementAdded")
-
-	bus.add_signal_receiver(element_updated,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementUpdated")
-
-	bus.add_signal_receiver(element_removed,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementRemoved")
-
-	mainloop = gobject.MainLoop()
-	mainloop.run()
diff --git a/test/monitor-state b/test/monitor-state
deleted file mode 100755
index b4bd1de0..00000000
--- a/test/monitor-state
+++ /dev/null
@@ -1,57 +0,0 @@
-#!/usr/bin/python
-
-import gobject
-
-import dbus
-import dbus.service
-import dbus.mainloop.glib
-
-internet_path = ""
-
-def get_properties(path):
-	element = dbus.Interface(bus.get_object("org.moblin.connman", path),
-						"org.moblin.connman.Element")
-
-	return element.GetProperties()
-
-def element_added(path):
-	global internet_path
-	properties = get_properties(path)
-	if (properties["Type"] == "dhcp"):
-		print "Aquiring IP address"
-	if (properties["Type"] == "ipv4"):
-		print "IP address assigned"
-	if (properties["Type"] == "internet"):
-		internet_path = path
-		print "Succesfully connected"
-
-def element_updated(path):
-	properties = get_properties(path)
-	if (properties["Type"] == "network" and properties["Enabled"] == 1):
-		print "Associated with %s" % (properties["SSID"])
-
-def element_removed(path):
-	global internet_path
-	if (path == internet_path):
-		internet_path = ""
-		print "Connection terminated"
-
-if __name__ == '__main__':
-	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
-
-	bus = dbus.SystemBus()
-
-	bus.add_signal_receiver(element_added,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementAdded")
-
-	bus.add_signal_receiver(element_updated,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementUpdated")
-
-	bus.add_signal_receiver(element_removed,
-				dbus_interface = "org.moblin.connman.Manager",
-						signal_name = "ElementRemoved")
-
-	mainloop = gobject.MainLoop()
-	mainloop.run()

commit e3d4af6fd0a5437f07e88ac06e5fb95ead8366d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 21:19:30 2008 +0100

    Fix missing device index for resolver elements

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 67d1ed10..0e386120 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -205,6 +205,7 @@ static int ipv4_probe(struct connman_element *element)
 	resolver = connman_element_create(NULL);
 
 	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
+	resolver->index = element->index;
 
 	connman_element_register(resolver, element);
 

commit bb755b910cedc6f8d396a6b237dc6e10531d66f5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 21:39:39 2008 +0100

    Disable element signals for now

diff --git a/src/element.c b/src/element.c
index 56965de5..53f4cb98 100644
--- a/src/element.c
+++ b/src/element.c
@@ -294,10 +294,12 @@ static DBusMessage *do_enable(DBusConnection *conn,
 
 	element->enabled = TRUE;
 
+#if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+#endif
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -320,10 +322,12 @@ static DBusMessage *do_disable(DBusConnection *conn,
 
 	element->enabled = FALSE;
 
+#if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+#endif
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -1261,10 +1265,12 @@ int connman_element_set_property(struct connman_element *element,
 		return -EINVAL;
 	}
 
+#if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+#endif
 
 	return 0;
 }
@@ -1623,10 +1629,12 @@ static void register_element(gpointer data, gpointer user_data)
 		}
 	}
 
+#if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+#endif
 
 	g_static_rw_lock_writer_unlock(&element_lock);
 
@@ -1722,10 +1730,12 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		g_node_destroy(node);
 	}
 
+#if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementRemoved",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+#endif
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
 		emit_state_change(connection, "offline");
@@ -1816,10 +1826,12 @@ static gboolean update_element(GNode *node, gpointer user_data)
 	if (element->driver && element->driver->update)
 		element->driver->update(element);
 
+#if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
 				DBUS_TYPE_OBJECT_PATH, &element->path,
 							DBUS_TYPE_INVALID);
+#endif
 
 	return FALSE;
 }
diff --git a/src/manager.c b/src/manager.c
index ddaf8fcd..341e4623 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -207,6 +207,7 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 	return reply;
 }
 
+#if 0
 static DBusMessage *list_elements(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -230,20 +231,25 @@ static DBusMessage *list_elements(DBusConnection *conn,
 
 	return reply;
 }
+#endif
 
 static GDBusMethodTable manager_methods[] = {
 	{ "GetProperties",   "",  "a{sv}", get_properties   },
 	{ "RegisterAgent",   "o", "",      register_agent   },
 	{ "UnregisterAgent", "o", "",      unregister_agent },
+#if 0
 	{ "ListElements",    "",  "ao",    list_elements    },
+#endif
 	{ },
 };
 
 static GDBusSignalTable manager_signals[] = {
 	{ "PropertyChanged", "sv" },
+#if 0
 	{ "ElementAdded",    "o"  },
 	{ "ElementUpdated",  "o"  },
 	{ "ElementRemoved",  "o"  },
+#endif
 	{ },
 };
 

commit 0f7286042151b6fa69570a0990dc5400ac8ca70c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 4 22:09:25 2008 +0100

    Add proper IPv4 attributes

diff --git a/src/element.c b/src/element.c
index 53f4cb98..72b0467e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -183,21 +183,29 @@ static void append_property(DBusMessageIter *dict,
 static void add_common_properties(struct connman_element *element,
 						DBusMessageIter *dict)
 {
+	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 	GSList *list;
 
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_ADDRESS, &address);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
 	if (element->priority > 0)
 		connman_dbus_dict_append_variant(dict, "Priority",
 					DBUS_TYPE_UINT16, &element->priority);
 
-	if (element->ipv4.address != NULL)
+	if (address != NULL)
 		connman_dbus_dict_append_variant(dict, "IPv4.Address",
-				DBUS_TYPE_STRING, &element->ipv4.address);
-	if (element->ipv4.netmask != NULL)
+						DBUS_TYPE_STRING, &address);
+	if (netmask != NULL)
 		connman_dbus_dict_append_variant(dict, "IPv4.Netmask",
-				DBUS_TYPE_STRING, &element->ipv4.netmask);
-	if (element->ipv4.gateway != NULL)
+						DBUS_TYPE_STRING, &netmask);
+	if (gateway != NULL)
 		connman_dbus_dict_append_variant(dict, "IPv4.Gateway",
-				DBUS_TYPE_STRING, &element->ipv4.gateway);
+						DBUS_TYPE_STRING, &gateway);
 
 	if (element->wifi.security != NULL) {
 		const char *passphrase = "";

commit cf87ef5c131af32de16b51d47ecd55f26d2b991c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 13:59:25 2008 +0100

    Fix detection of Bluetooth devices

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 6b0b69a0..978f2577 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -33,6 +33,8 @@
 
 #define BLUEZ_SERVICE "org.bluez"
 
+#define TIMEOUT 5000
+
 static int bluetooth_probe(struct connman_device *device)
 {
 	DBG("device %p", device);
@@ -52,14 +54,91 @@ static struct connman_device_driver bluetooth_driver = {
 	.remove	= bluetooth_remove,
 };
 
+static GSList *device_list = NULL;
+
+static void adapters_reply(DBusPendingCall *call, void *user_data)
+{
+	DBusMessage *reply;
+	DBusError error;
+	char **adapters;
+	int i, num_adapters;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error,
+				DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+						&adapters, &num_adapters,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for adapter list");
+		goto done;
+	}
+
+	for (i = 0; i < num_adapters; i++) {
+		struct connman_element *device;
+
+		device = connman_element_create(NULL);
+		device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+		device->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+
+		device->name = g_path_get_basename(adapters[i]);
+
+		connman_element_register(device, NULL);
+		device_list = g_slist_append(device_list, device);
+	}
+
+	g_strfreev(adapters);
+
+done:
+	dbus_message_unref(reply);
+}
+
 static void bluetooth_connect(DBusConnection *connection, void *user_data)
 {
+	DBusMessage *message;
+	DBusPendingCall *call;
+
 	DBG("connection %p", connection);
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, "/",
+					"org.bluez.Manager", "ListAdapters");
+	if (message == NULL)
+		return;
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get Bluetooth adapters");
+		dbus_message_unref(message);
+		return;
+	}
+
+	dbus_pending_call_set_notify(call, adapters_reply, NULL, NULL);
+
+	dbus_message_unref(message);
 }
 
 static void bluetooth_disconnect(DBusConnection *connection, void *user_data)
 {
+	GSList *list;
+
 	DBG("connection %p", connection);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		connman_element_unregister(device);
+		connman_element_unref(device);
+	}
+
+	g_slist_free(device_list);
+	device_list = NULL;
 }
 
 static DBusConnection *connection;

commit 54bdbc71afb639449aa3d64f1fd61a057c79189c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 20:14:47 2008 +0100

    Send signal for changed device and connection lists

diff --git a/src/element.c b/src/element.c
index 72b0467e..8abfd0d7 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1458,7 +1458,7 @@ static void append_devices(DBusMessageIter *entry)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	//__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -1498,7 +1498,7 @@ static void append_connections(DBusMessageIter *entry)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	//__connman_element_list(CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
+	__connman_element_list(CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 

commit c4f2302710ca4e779555759418bac3babc2d953e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 20:21:08 2008 +0100

    Fix cleanup and unregistration procedures

diff --git a/src/element.c b/src/element.c
index 8abfd0d7..370713a6 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1775,9 +1775,8 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 	return FALSE;
 }
 
-static void unregister_element(gpointer data, gpointer user_data)
+void connman_element_unregister(struct connman_element *element)
 {
-	struct connman_element *element = data;
 	GNode *node;
 
 	DBG("element %p name %s", element, element->name);
@@ -1793,16 +1792,8 @@ static void unregister_element(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
-void connman_element_unregister(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	unregister_element(element, NULL);
-}
-
-static void unregister_children(gpointer data, gpointer user_data)
+void connman_element_unregister_children(struct connman_element *element)
 {
-	struct connman_element *element = data;
 	GNode *node;
 
 	DBG("element %p name %s", element, element->name);
@@ -1818,13 +1809,6 @@ static void unregister_children(gpointer data, gpointer user_data)
 	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
-void connman_element_unregister_children(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	unregister_children(element, NULL);
-}
-
 static gboolean update_element(GNode *node, gpointer user_data)
 {
 	struct connman_element *element = node->data;
@@ -1929,7 +1913,7 @@ static gboolean free_node(GNode *node, gpointer data)
 	DBG("element %p name %s", element, element->name);
 
 	if (g_node_depth(node) > 1)
-		unregister_element(element, NULL);
+		connman_element_unregister(element);
 
 	return FALSE;
 }
diff --git a/src/main.c b/src/main.c
index 58108135..000847d6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -163,19 +163,19 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
-	__connman_rtnl_cleanup();
-
-	__connman_agent_cleanup();
+	__connman_plugin_cleanup();
 
-	__connman_element_cleanup();
+	__connman_rtnl_cleanup();
 
 	__connman_profile_cleanup();
 
 	__connman_manager_cleanup();
 
-	__connman_storage_cleanup();
+	__connman_agent_cleanup();
 
-	__connman_plugin_cleanup();
+	__connman_element_cleanup();
+
+	__connman_storage_cleanup();
 
 	__connman_log_cleanup();
 

commit e7f9a5e40c71f267015af90cacb009eea3ee323a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 21:03:59 2008 +0100

    Add deny policy to D-Bus access configuration

diff --git a/src/connman.conf b/src/connman.conf
index f9da1512..b8846a52 100644
--- a/src/connman.conf
+++ b/src/connman.conf
@@ -10,4 +10,8 @@
         <allow send_destination="org.moblin.connman"/>
         <allow send_interface="org.moblin.connman"/>
     </policy>
+    <policy context="default">
+        <deny send_destination="org.moblin.connman"/>
+        <deny send_interface="org.moblin.connman"/>
+    </policy>
 </busconfig>

commit 7bb1bc293ccdb0d8fb95ae8ef25080ab13656769
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 21:39:16 2008 +0100

    Do policy based enabling/disabling of devices

diff --git a/src/element.c b/src/element.c
index 370713a6..c9fd08a9 100644
--- a/src/element.c
+++ b/src/element.c
@@ -795,6 +795,20 @@ static gboolean match_driver(struct connman_element *element,
 	return FALSE;
 }
 
+static void enable_element(struct connman_element *element)
+{
+	if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE)
+		return;
+
+	if (element->policy != CONNMAN_ELEMENT_POLICY_AUTO)
+		return;
+
+	if (element->driver && element->driver->enable) {
+		if (element->driver->enable(element) == 0)
+			element->enabled = TRUE;
+	}
+}
+
 static gboolean probe_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
@@ -809,6 +823,8 @@ static gboolean probe_driver(GNode *node, gpointer data)
 		__connman_element_lock(element);
 		element->driver = driver;
 		__connman_element_unlock(element);
+
+		enable_element(element);
 	}
 
 	return FALSE;
@@ -862,6 +878,20 @@ int connman_driver_register(struct connman_driver *driver)
 	return 0;
 }
 
+static void disable_element(struct connman_element *element)
+{
+	if (element->policy != CONNMAN_ELEMENT_POLICY_AUTO)
+		return;
+
+	if (element->enabled == FALSE)
+		return;
+
+	if (element->driver && element->driver->disable) {
+		if (element->driver->disable(element) == 0)
+			element->enabled = FALSE;
+	}
+}
+
 static gboolean remove_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
@@ -870,6 +900,8 @@ static gboolean remove_driver(GNode *node, gpointer data)
 	DBG("element %p name %s", element, element->name);
 
 	if (element->driver == driver) {
+		disable_element(element);
+
 		if (driver->remove)
 			driver->remove(element);
 
@@ -1662,6 +1694,8 @@ static void register_element(gpointer data, gpointer user_data)
 			__connman_element_lock(element);
 			element->driver = driver;
 			__connman_element_unlock(element);
+
+			enable_element(element);
 			break;
 		}
 	}

commit f7afbae29f9cb5a933890e12c16771de5bfd642f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 21:42:10 2008 +0100

    Don't store fake or network device elements

diff --git a/src/storage.c b/src/storage.c
index 15e0cd66..5e390415 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -147,6 +147,10 @@ int __connman_element_store(struct connman_element *element)
 				element->type != CONNMAN_ELEMENT_TYPE_NETWORK)
 		return -EINVAL;
 
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_FAKE ||
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_NETWORK)
+		return -EINVAL;
+
 	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);
 	if (pathname == NULL)
 		return -ENOMEM;

commit fca9b70ed3be7b479c5949bf001d0a071802fca2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 21:47:21 2008 +0100

    Store the policy setting

diff --git a/src/connman.h b/src/connman.h
index d7124d2e..82916f15 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -79,6 +79,8 @@ int __connman_element_count(enum connman_element_type type);
 const char *__connman_element_type2string(enum connman_element_type type);
 const char *__connman_element_subtype2string(enum connman_element_subtype type);
 
+const char *__connman_element_policy2string(enum connman_element_policy policy);
+
 int __connman_element_load(struct connman_element *element);
 int __connman_element_store(struct connman_element *element);
 
diff --git a/src/element.c b/src/element.c
index c9fd08a9..0fd230be 100644
--- a/src/element.c
+++ b/src/element.c
@@ -148,7 +148,7 @@ static const char *subtype2string(enum connman_element_subtype type)
 	return NULL;
 }
 
-static const char *policy2string(enum connman_element_policy policy)
+const char *__connman_element_policy2string(enum connman_element_policy policy)
 {
 	switch (policy) {
 	case CONNMAN_ELEMENT_POLICY_UNKNOWN:
@@ -392,7 +392,7 @@ static DBusMessage *get_device_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &str);
 
-	str = policy2string(element->policy);
+	str = __connman_element_policy2string(element->policy);
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "Policy",
 						DBUS_TYPE_STRING, &str);
@@ -467,7 +467,7 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	str = policy2string(element->policy);
+	str = __connman_element_policy2string(element->policy);
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "Policy",
 						DBUS_TYPE_STRING, &str);
diff --git a/src/storage.c b/src/storage.c
index 5e390415..1aeda881 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -103,6 +103,10 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 
 	g_key_file_set_string(keyfile, element->path, "Name", element->name);
 
+	value = __connman_element_policy2string(element->policy);
+	if (value != NULL)
+		g_key_file_set_string(keyfile, element->path, "Policy", value);
+
 	g_key_file_set_boolean(keyfile, element->path, "Enabled",
 							element->enabled);
 

commit d58d6a1fc8aea4ac47f815d3217e3f6a19be378a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 21:52:06 2008 +0100

    Load policy configuration from storage

diff --git a/src/connman.h b/src/connman.h
index 82916f15..c42859fe 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -80,6 +80,7 @@ const char *__connman_element_type2string(enum connman_element_type type);
 const char *__connman_element_subtype2string(enum connman_element_subtype type);
 
 const char *__connman_element_policy2string(enum connman_element_policy policy);
+enum connman_element_policy __connman_element_string2policy(const char *policy);
 
 int __connman_element_load(struct connman_element *element);
 int __connman_element_store(struct connman_element *element);
diff --git a/src/element.c b/src/element.c
index 0fd230be..36f40900 100644
--- a/src/element.c
+++ b/src/element.c
@@ -166,6 +166,20 @@ const char *__connman_element_policy2string(enum connman_element_policy policy)
 	return NULL;
 }
 
+enum connman_element_policy __connman_element_string2policy(const char *policy)
+{
+	if (strcasecmp(policy, "off") == 0)
+		return CONNMAN_ELEMENT_POLICY_OFF;
+	else if (strcasecmp(policy, "ignore") == 0)
+		return CONNMAN_ELEMENT_POLICY_IGNORE;
+	else if (strcasecmp(policy, "auto") == 0)
+		return CONNMAN_ELEMENT_POLICY_AUTO;
+	else if (strcasecmp(policy, "ask") == 0)
+		return CONNMAN_ELEMENT_POLICY_ASK;
+	else
+		return CONNMAN_ELEMENT_POLICY_UNKNOWN;
+}
+
 static void append_property(DBusMessageIter *dict,
 				struct connman_property *property)
 {
diff --git a/src/storage.c b/src/storage.c
index 1aeda881..d8c32f4e 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -43,6 +43,11 @@ static int do_load(GKeyFile *keyfile, struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	value = g_key_file_get_string(keyfile, element->path,
+						"Policy", NULL);
+	if (value != NULL)
+		element->policy = __connman_element_string2policy(value);
+
 	value = g_key_file_get_string(keyfile, element->path,
 						"WiFi.Security", NULL);
 	if (value != NULL)
@@ -98,14 +103,15 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 {
 	GSList *list;
 	char *value;
+	const char *str;
 
 	DBG("element %p name %s", element, element->name);
 
 	g_key_file_set_string(keyfile, element->path, "Name", element->name);
 
-	value = __connman_element_policy2string(element->policy);
-	if (value != NULL)
-		g_key_file_set_string(keyfile, element->path, "Policy", value);
+	str = __connman_element_policy2string(element->policy);
+	if (str != NULL)
+		g_key_file_set_string(keyfile, element->path, "Policy", str);
 
 	g_key_file_set_boolean(keyfile, element->path, "Enabled",
 							element->enabled);

commit 9a190718628f120e6a3469a7d128795c70fc1ad0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 21:53:42 2008 +0100

    Don't store the enable status of an element

diff --git a/src/storage.c b/src/storage.c
index d8c32f4e..bbd9417c 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -113,8 +113,8 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 	if (str != NULL)
 		g_key_file_set_string(keyfile, element->path, "Policy", str);
 
-	g_key_file_set_boolean(keyfile, element->path, "Enabled",
-							element->enabled);
+	//g_key_file_set_boolean(keyfile, element->path, "Enabled",
+	//						element->enabled);
 
 	__connman_element_lock(element);
 

commit afc80b971146277e4befc173ef61cfcb375a3b0f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 22:07:26 2008 +0100

    Track global connection state

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 51045869..0ae20f59 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -44,6 +44,7 @@
 struct wifi_data {
 	GSList *list;
 	gchar *identifier;
+	gboolean connected;
 };
 
 static int network_probe(struct connman_element *element)
@@ -77,6 +78,9 @@ static int network_enable(struct connman_element *element)
 	if (element->parent != NULL) {
 		struct wifi_data *data = connman_element_get_data(element->parent);
 
+		if (data->connected == TRUE)
+			return -EBUSY;
+
 		if (data != NULL) {
 			g_free(data->identifier);
 			data->identifier = g_strdup(identifier);
@@ -154,13 +158,16 @@ static void state_change(struct connman_element *parent,
 	if (state == STATE_COMPLETED) {
 		struct connman_element *dhcp;
 
+		data->connected = TRUE;
+
 		dhcp = connman_element_create(NULL);
 
 		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
 		dhcp->index = element->index;
 
 		connman_element_register(dhcp, element);
-	}
+	} else if (state == STATE_DISCONNECTED || state == STATE_INACTIVE)
+		data->connected = FALSE;
 }
 
 static void scan_result(struct connman_element *parent,
@@ -262,6 +269,8 @@ static int wifi_probe(struct connman_element *element)
 	if (data == NULL)
 		return -ENOMEM;
 
+	data->connected = FALSE;
+
 	connman_element_set_data(element, data);
 
 	return 0;

commit 9703f77e6f49cf5bcf318c1f2d315a6250ae773d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 22:11:51 2008 +0100

    Add generic failure reply

diff --git a/src/connman.h b/src/connman.h
index c42859fe..9f7c4c1f 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -27,6 +27,7 @@
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
 
+DBusMessage *__connman_error_failed(DBusMessage *msg);
 DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
 
diff --git a/src/element.c b/src/element.c
index 36f40900..0f7ceccb 100644
--- a/src/element.c
+++ b/src/element.c
@@ -288,11 +288,13 @@ static DBusMessage *do_update(DBusConnection *conn,
 	DBG("conn %p", conn);
 
 	if (element->enabled == FALSE)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+		return __connman_error_failed(msg);
 
 	if (element->driver && element->driver->update) {
 		DBG("Calling update callback");
-		element->driver->update(element);
+		if (element->driver->update(element) < 0)
+			return __connman_error_failed(msg);
+
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
@@ -306,12 +308,12 @@ static DBusMessage *do_enable(DBusConnection *conn,
 	DBG("conn %p", conn);
 
 	if (element->enabled == TRUE)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+		return __connman_error_failed(msg);
 
 	if (element->driver && element->driver->enable) {
 		DBG("Calling enable callback");
 		if (element->driver->enable(element) < 0)
-			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+			return __connman_error_failed(msg);
 	}
 
 	element->enabled = TRUE;
@@ -334,12 +336,12 @@ static DBusMessage *do_disable(DBusConnection *conn,
 	DBG("conn %p", conn);
 
 	if (element->enabled == FALSE)
-		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+		return __connman_error_failed(msg);
 
 	if (element->driver && element->driver->disable) {
 		DBG("Calling disable callback");
 		if (element->driver->disable(element) < 0)
-			return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+			return __connman_error_failed(msg);
 	}
 
 	element->enabled = FALSE;
diff --git a/src/error.c b/src/error.c
index 08f94d2e..21606cbc 100644
--- a/src/error.c
+++ b/src/error.c
@@ -27,6 +27,12 @@
 
 #include "connman.h"
 
+DBusMessage *__connman_error_failed(DBusMessage *msg)
+{
+	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
+							".Failed", NULL);
+}
+
 DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg)
 {
 	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE

commit 00762852ce32ff3c639241cb247290a1a5c76007
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 22:41:48 2008 +0100

    Use separate enable/disable callbacks

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index d6861f8d..bd2ddc29 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -193,8 +193,6 @@ static int ethernet_probe(struct connman_element *element)
 
 	ethernet->index = element->index;
 
-	iface_up(ethernet);
-
 	connman_rtnl_send_getlink();
 
 	return 0;
@@ -208,19 +206,41 @@ static void ethernet_remove(struct connman_element *element)
 
 	connman_element_set_data(element, NULL);
 
-	iface_down(ethernet);
-
 	ethernet_list = g_slist_remove(ethernet_list, element);
 
 	g_free(ethernet);
 }
 
+static int ethernet_enable(struct connman_element *element)
+{
+	struct ethernet_data *ethernet = connman_element_get_data(element);
+
+	DBG("element %p name %s", element, element->name);
+
+	iface_up(ethernet);
+
+	return 0;
+}
+
+static int ethernet_disable(struct connman_element *element)
+{
+	struct ethernet_data *ethernet = connman_element_get_data(element);
+
+	DBG("element %p name %s", element, element->name);
+
+	iface_down(ethernet);
+
+	return 0;
+}
+
 static struct connman_driver ethernet_driver = {
 	.name		= "ethernet",
 	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
 	.subtype	= CONNMAN_ELEMENT_SUBTYPE_ETHERNET,
 	.probe		= ethernet_probe,
 	.remove		= ethernet_remove,
+	.enable		= ethernet_enable,
+	.disable	= ethernet_disable,
 };
 
 static int ethernet_init(void)

commit 193dcee5019657796339e4c4132e6d5425318871
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 22:55:15 2008 +0100

    Support selected listing and counting of elements

diff --git a/src/connman.h b/src/connman.h
index 9f7c4c1f..965a2839 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -73,9 +73,11 @@ void __connman_driver_rescan(struct connman_driver *driver);
 int __connman_element_init(DBusConnection *conn, const char *device);
 void __connman_element_cleanup(void);
 
-void __connman_element_list(enum connman_element_type type,
-						DBusMessageIter *iter);
-int __connman_element_count(enum connman_element_type type);
+void __connman_element_list(struct connman_element *element,
+					enum connman_element_type type,
+							DBusMessageIter *iter);
+int __connman_element_count(struct connman_element *element,
+					enum connman_element_type type);
 
 const char *__connman_element_type2string(enum connman_element_type type);
 const char *__connman_element_subtype2string(enum connman_element_subtype type);
diff --git a/src/element.c b/src/element.c
index 0f7ceccb..0aef003b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -356,7 +356,8 @@ static DBusMessage *do_disable(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static void append_networks(DBusMessageIter *dict)
+static void append_networks(struct connman_element *element,
+						DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
 	const char *key = "Networks";
@@ -373,7 +374,7 @@ static void append_networks(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
+	__connman_element_list(element, CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -416,7 +417,7 @@ static DBusMessage *get_device_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
-	append_networks(&dict);
+	append_networks(element, &dict);
 
 	add_common_properties(element, &dict);
 
@@ -735,16 +736,26 @@ static gboolean append_path(GNode *node, gpointer user_data)
 	return FALSE;
 }
 
-void __connman_element_list(enum connman_element_type type,
-						DBusMessageIter *iter)
+void __connman_element_list(struct connman_element *element,
+					enum connman_element_type type,
+							DBusMessageIter *iter)
 {
 	struct append_filter filter = { type, iter };
+	GNode *node;
 
 	DBG("");
 
+	if (element != NULL) {
+		node = g_node_find(element_root, G_PRE_ORDER,
+						G_TRAVERSE_ALL, element);
+		if (node == NULL)
+			return;
+	} else
+		node = element_root;
+
 	g_static_rw_lock_reader_lock(&element_lock);
-	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
-							append_path, &filter);
+	g_node_traverse(node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+						append_path, &filter);
 	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
@@ -772,15 +783,25 @@ static gboolean count_element(GNode *node, gpointer user_data)
 	return FALSE;
 }
 
-int __connman_element_count(enum connman_element_type type)
+int __connman_element_count(struct connman_element *element,
+					enum connman_element_type type)
 {
 	struct count_data data = { type, 0 };
+	GNode *node;
 
 	DBG("");
 
+	if (element != NULL) {
+		node = g_node_find(element_root, G_PRE_ORDER,
+						G_TRAVERSE_ALL, element);
+		if (node == NULL)
+			return 0;
+	} else
+		node = element_root;
+
 	g_static_rw_lock_reader_lock(&element_lock);
-	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
-							count_element, &data);
+	g_node_traverse(node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+						count_element, &data);
 	g_static_rw_lock_reader_unlock(&element_lock);
 
 	return data.count;
@@ -1506,7 +1527,7 @@ static void append_devices(DBusMessageIter *entry)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -1546,7 +1567,7 @@ static void append_connections(DBusMessageIter *entry)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
+	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
diff --git a/src/manager.c b/src/manager.c
index 341e4623..3c22339c 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -70,7 +70,7 @@ static void append_devices(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -96,7 +96,7 @@ static void append_connections(DBusMessageIter *dict)
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
 
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
+	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
 
 	dbus_message_iter_close_container(&value, &iter);
 
@@ -149,7 +149,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	append_devices(&dict);
 	append_connections(&dict);
 
-	if (__connman_element_count(CONNMAN_ELEMENT_TYPE_CONNECTION) > 0)
+	if (__connman_element_count(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION) > 0)
 		append_state(&dict, "online");
 	else
 		append_state(&dict, "offline");

commit e4192ffa8649754ebbab769495bb3ab40a7c146c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 23:01:17 2008 +0100

    Disable generic device driver for now

diff --git a/src/device.c b/src/device.c
index 0e2cf59f..3ad61ffb 100644
--- a/src/device.c
+++ b/src/device.c
@@ -29,6 +29,7 @@
 
 static GSList *driver_list = NULL;
 
+#if 0
 static gboolean match_driver(struct connman_device *device,
 					struct connman_device_driver *driver)
 {
@@ -93,19 +94,21 @@ static struct connman_driver device_driver = {
 	.probe		= device_probe,
 	.remove		= device_remove,
 };
+#endif
 
 int __connman_device_init(void)
 {
 	DBG("");
 
-	return connman_driver_register(&device_driver);
+	//return connman_driver_register(&device_driver);
+	return 0;
 }
 
 void __connman_device_cleanup(void)
 {
 	DBG("");
 
-	connman_driver_unregister(&device_driver);
+	//connman_driver_unregister(&device_driver);
 }
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -131,7 +134,7 @@ int connman_device_driver_register(struct connman_device_driver *driver)
 	driver_list = g_slist_insert_sorted(driver_list, driver,
 							compare_priority);
 
-	__connman_driver_rescan(&device_driver);
+	//__connman_driver_rescan(&device_driver);
 
 	return 0;
 }

commit d7a989cc7e5ae1f7ba1791fab7aecc1e06dcde63
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 00:36:41 2008 +0100

    Convert hex WEP key string into binary

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 39e1624d..0a23039e 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#include <stdlib.h>
 #include <string.h>
 #include <dbus/dbus.h>
 
@@ -516,9 +517,28 @@ static int set_network(struct supplicant_task *task,
 		connman_dbus_dict_append_variant(&dict, "key_mgmt",
 						DBUS_TYPE_STRING, &key_mgmt);
 
-		if (passphrase && strlen(passphrase) > 0) {
-			connman_dbus_dict_append_variant(&dict, "wep_key0",
-						DBUS_TYPE_STRING, &passphrase);
+		if (passphrase) {
+			int size = strlen(passphrase);
+			if (size == 10 || size == 26) {
+				unsigned char *key = malloc(13);
+				char tmp[3];
+				int i;
+				memset(tmp, 0, sizeof(tmp));
+				if (key == NULL)
+					size = 0;
+				for (i = 0; i < size / 2; i++) {
+					memcpy(tmp, passphrase + (i * 2), 2);
+					key[i] = (unsigned char) strtol(tmp,
+								NULL, 16);
+				}
+			        connman_dbus_dict_append_array(&dict,
+						"wep_key0", DBUS_TYPE_BYTE,
+							&key, size / 2);
+				free(key);
+			} else
+				connman_dbus_dict_append_variant(&dict,
+						"wep_key0", DBUS_TYPE_STRING,
+								&passphrase);
 			connman_dbus_dict_append_variant(&dict, "wep_tx_keyidx",
 						DBUS_TYPE_STRING, &index);
 		}

commit aa7b81c7494f844bb4f08647868ae3bd0ce038b4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 23:54:26 2008 +0100

    Show Networks property only for wireless devices

diff --git a/src/element.c b/src/element.c
index 0aef003b..00da43a3 100644
--- a/src/element.c
+++ b/src/element.c
@@ -362,6 +362,10 @@ static void append_networks(struct connman_element *element,
 	DBusMessageIter entry, value, iter;
 	const char *key = "Networks";
 
+	if (element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIFI &&
+			element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIMAX)
+		return;
+
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
 

commit dc904e17f98346d1d233dc090c3195c33ff5f71d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 00:00:11 2008 +0100

    Don't check non wireless devices

diff --git a/test/disable-network b/test/disable-network
index beea2f10..0f261549 100755
--- a/test/disable-network
+++ b/test/disable-network
@@ -15,6 +15,9 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
+	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
+		continue;
+
 	print "[ %s ]" % (path)
 
 	for path in properties["Networks"]:
diff --git a/test/list-networks b/test/list-networks
index 94e111c4..3b29a8e4 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -15,6 +15,9 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
+	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
+		continue;
+
 	print "[ %s ]" % (path)
 
 	for path in properties["Networks"]:
diff --git a/test/select-network b/test/select-network
index e7491e8a..b5a0259f 100755
--- a/test/select-network
+++ b/test/select-network
@@ -20,6 +20,9 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
+	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
+		continue;
+
 	print "[ %s ]" % (path)
 
 	for path in properties["Networks"]:
diff --git a/test/set-passphrase b/test/set-passphrase
index db39554f..1c0d0f18 100755
--- a/test/set-passphrase
+++ b/test/set-passphrase
@@ -20,6 +20,9 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
+	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
+		continue;
+
 	for path in properties["Networks"]:
 		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Network")

commit 555b6e45c2746818d2c2a8816b4069c7b4a967f9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 00:08:47 2008 +0100

    Add skeleton for loopback setup plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index ef5a82dd..b9011f9e 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,10 +1,12 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = ethernet.la wifi.la bluetooth.la \
+plugin_LTLIBRARIES = loopback.la ethernet.la wifi.la bluetooth.la \
 				netdev.la dhclient.la ipv4.la \
 				resolvconf.la resolvfile.la rtnllink.la
 
+loopback_la_SOURCES = loopback.c
+
 ethernet_la_SOURCES = ethernet.c
 
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
diff --git a/plugins/loopback.c b/plugins/loopback.c
new file mode 100644
index 00000000..255d2bf4
--- /dev/null
+++ b/plugins/loopback.c
@@ -0,0 +1,38 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+
+static int loopback_init(void)
+{
+	return 0;
+}
+
+static void loopback_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE("loopback", "Loopback device plugin", VERSION,
+						loopback_init, loopback_exit)

commit 6751366d75406726fb533f842fd59b69feb95292
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 00:27:49 2008 +0100

    Set loopback interface parameters during setup

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 255d2bf4..184ea739 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -23,11 +23,81 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+
 #include <connman/plugin.h>
+#include <connman/log.h>
 
 static int loopback_init(void)
 {
-	return 0;
+	struct ifreq ifr;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	strcpy(ifr.ifr_name, "lo");
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ifr.ifr_flags & IFF_UP) {
+		err = -EALREADY;
+		connman_info("The loopback interface is already up");
+		goto done;
+	}
+
+	addr = (struct sockaddr_in *) &ifr.ifr_addr;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = inet_addr("127.0.0.0");
+
+	err = ioctl(sk, SIOCSIFADDR, &ifr);
+	if (err < 0) {
+		err = -errno;
+		connman_error("Setting address failed (%s)", strerror(-err));
+		goto done;
+	}
+
+	addr = (struct sockaddr_in *) &ifr.ifr_netmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = inet_addr("255.0.0.0");
+
+	err = ioctl(sk, SIOCSIFNETMASK, &ifr);
+	if (err < 0) {
+		err = -errno;
+		connman_error("Setting netmask failed (%s)", strerror(-err));
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	ifr.ifr_flags |= IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		connman_error("Activating loopback interface failed (%s)",
+							strerror(-err));
+		goto done;
+	}
+
+done:
+	close(sk);
+
+	return err;
 }
 
 static void loopback_exit(void)

commit 60645ef70a1cdc95ec9f4156c84e4e2aeac1c35c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 03:25:29 2008 +0100

    Require at minimum udev-127

diff --git a/configure.ac b/configure.ac
index bcb38ea4..e5df8916 100644
--- a/configure.ac
+++ b/configure.ac
@@ -74,7 +74,7 @@ AC_SUBST(DBUS_LIBS)
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
 AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 
-PKG_CHECK_MODULES(UDEV, libudev >= 130, udev_found=yes, udev_found=no)
+PKG_CHECK_MODULES(UDEV, libudev >= 127, udev_found=yes, udev_found=no)
 AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
 AM_CONDITIONAL(UDEV, test "${udev_found}" = "yes")

commit 0e79d2bd2c57ae9731488110af9e2960549e9aa7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 03:36:08 2008 +0100

    Include stdarg.h to workaround libudev bug

diff --git a/src/udev.c b/src/udev.c
index 0eba6398..1f80728c 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <stdarg.h>
+
 #define LIBUDEV_I_KNOW_THE_API_IS_SUBJECT_TO_CHANGE
 #include <libudev.h>
 

commit 00052435b7d3ea4139684c7f3b39911fdff5ac91
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 03:43:48 2008 +0100

    Update Agent interface description

diff --git a/doc/agent-api.txt b/doc/agent-api.txt
index ff7aa53b..f39c9664 100644
--- a/doc/agent-api.txt
+++ b/doc/agent-api.txt
@@ -1,17 +1,14 @@
 Agent hierarchy
-***************
+===============
 
-Service name	[unique name]
-Interface name	org.moblin.connman.Agent
-Object path	[random object]
+Service		unique name
+Interface	org.moblin.connman.Agent
+Object path	freely definable
 
 Methods		void Release()
 
-
-Method: Release
-===============
-This method will be called when the core releases the agent. This normally
-happens when the core shuts down.
-
-To get notified when the core exits, an agent should also watch out for the
-NameOwnerChanged from org.moblin.connman service.
+			This method gets called when the service daemon
+			unregisters the agent. An agent can use it to do
+			cleanup tasks. There is no need to unregister the
+			agent, because when this method gets called it has
+			already been unregistered.

commit f03cdb8c277deca62626a1798365d3b34bafedc5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 03:49:23 2008 +0100

    Add an extra empty line

diff --git a/doc/plugin-api.txt b/doc/plugin-api.txt
index f8dded07..baaea307 100644
--- a/doc/plugin-api.txt
+++ b/doc/plugin-api.txt
@@ -1,6 +1,7 @@
 Plugin programming interface
 ****************************
 
+
 Plugin basics
 =============
 The Connection Manager supports plugins for various actions. The basic plugin

commit 77c6ac36d6d89c85988917acb8dcaef000db988b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 03:49:31 2008 +0100

    Don't install device.h at the moment

diff --git a/include/Makefile.am b/include/Makefile.am
index c44bd1b6..704ac561 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,9 +1,10 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h security.h resolver.h \
-					driver.h element.h property.h \
-					device.h network.h rtnl.h dbus.h
+include_HEADERS = log.h plugin.h security.h resolver.h driver.h \
+				element.h property.h network.h rtnl.h dbus.h
+
+noinst_HEADERS = device.h
 
 MAINTAINERCLEANFILES = Makefile.in
 

commit 87b4dec95bf09a19eef90a93487a1c32d36be6ae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 03:52:45 2008 +0100

    Include test-manager and leave test-supplicant out

diff --git a/test/Makefile.am b/test/Makefile.am
index 5d61b645..9bf9ecf3 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -2,6 +2,6 @@
 EXTRA_DIST = get-state list-profiles list-connections \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network set-passphrase \
-		simple-agent show-introspection test-compat test-supplicant
+		simple-agent show-introspection test-manager test-compat
 
 MAINTAINERCLEANFILES = Makefile.in

commit d4ab407c06a5113a655252478c98a988bc030c58
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 04:04:49 2008 +0100

    Release 0.1

diff --git a/ChangeLog b/ChangeLog
index e69de29b..ba270525 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -0,0 +1,2 @@
+ver 0.1:
+	Initial public release.
diff --git a/configure.ac b/configure.ac
index e5df8916..c95bdb33 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.0)
+AM_INIT_AUTOMAKE(connman, 0.1)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 9e4b0435da1726aa58e39e350d3497097db2634f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 15:41:32 2008 +0100

    Fix error message creation

diff --git a/gdbus/object.c b/gdbus/object.c
index 50313a26..e3e96ce0 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -523,7 +523,11 @@ gboolean g_dbus_unregister_interface(DBusConnection *connection,
 DBusMessage *g_dbus_create_error_valist(DBusMessage *message, const char *name,
 					const char *format, va_list args)
 {
-	return dbus_message_new_error(message, name, format);
+	char str[1024];
+
+	vsnprintf(str, sizeof(str), format, args);
+
+	return dbus_message_new_error(message, name, str);
 }
 
 DBusMessage *g_dbus_create_error(DBusMessage *message, const char *name,

commit 61a7962866886dff93f29bee45007dbdac26199a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 6 18:13:04 2008 +0100

    Allow pre-processor pasting of plugin name

diff --git a/doc/plugin-api.txt b/doc/plugin-api.txt
index baaea307..e329ced7 100644
--- a/doc/plugin-api.txt
+++ b/doc/plugin-api.txt
@@ -4,6 +4,7 @@ Plugin programming interface
 
 Plugin basics
 =============
+
 The Connection Manager supports plugins for various actions. The basic plugin
 contains of plugin description via CONNMAN_PLUGIN_DEFINE and also init/exit
 callbacks definied through that description.
@@ -19,5 +20,5 @@ static void example_exit(void)
 {
 }
 
-CONNMAN_PLUGIN_DEFINE("example", "Example plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(example, "Example plugin", VERSION,
 						example_init, example_exit)
diff --git a/include/plugin.h b/include/plugin.h
index 427ceede..587e9d76 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -52,7 +52,7 @@ struct connman_plugin_desc {
  */
 #define CONNMAN_PLUGIN_DEFINE(name, description, version, init, exit) \
 		struct connman_plugin_desc connman_plugin_desc = { \
-			name, description, version, init, exit \
+			#name, description, version, init, exit \
 		};
 
 #ifdef __cplusplus
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 978f2577..c09e4a5e 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -181,5 +181,5 @@ static void bluetooth_exit(void)
 	dbus_connection_unref(connection);
 }
 
-CONNMAN_PLUGIN_DEFINE("bluetooth", "Bluetooth technology plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(bluetooth, "Bluetooth technology plugin", VERSION,
 						bluetooth_init, bluetooth_exit)
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 7249773d..3d6f189b 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -356,5 +356,5 @@ static void dhclient_exit(void)
 	dbus_connection_unref(connection);
 }
 
-CONNMAN_PLUGIN_DEFINE("dhclient", "ISC DHCP client plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(dhclient, "ISC DHCP client plugin", VERSION,
 						dhclient_init, dhclient_exit)
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index bd2ddc29..28c1742d 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -267,5 +267,5 @@ static void ethernet_exit(void)
 	connman_rtnl_unregister(&ethernet_rtnl);
 }
 
-CONNMAN_PLUGIN_DEFINE("ethernet", "Ethernet interface plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(ethernet, "Ethernet interface plugin", VERSION,
 						ethernet_init, ethernet_exit)
diff --git a/plugins/fake.c b/plugins/fake.c
index 74b32bcb..33165dab 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -120,4 +120,4 @@ static void fake_exit(void)
 	connman_driver_unregister(&fake_device_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE("fake", "Tesing plugin", VERSION, fake_init, fake_exit)
+CONNMAN_PLUGIN_DEFINE(fake, "Tesing plugin", VERSION, fake_init, fake_exit)
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 0e386120..173c691b 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -236,5 +236,5 @@ static void ipv4_exit(void)
 	connman_driver_unregister(&ipv4_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE("ipv4", "IPv4 configuration plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(ipv4, "IPv4 configuration plugin", VERSION,
 							ipv4_init, ipv4_exit)
diff --git a/plugins/loopback.c b/plugins/loopback.c
index 184ea739..29e6547e 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -104,5 +104,5 @@ static void loopback_exit(void)
 {
 }
 
-CONNMAN_PLUGIN_DEFINE("loopback", "Loopback device plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(loopback, "Loopback device plugin", VERSION,
 						loopback_init, loopback_exit)
diff --git a/plugins/netdev.c b/plugins/netdev.c
index d8733b76..226d633e 100644
--- a/plugins/netdev.c
+++ b/plugins/netdev.c
@@ -77,5 +77,5 @@ static void netdev_exit(void)
 	connman_driver_unregister(&netdev_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE("netdev", "Network device plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(netdev, "Network device plugin", VERSION,
 						netdev_init, netdev_exit)
diff --git a/plugins/polkit.c b/plugins/polkit.c
index 7bed0b11..a2e15a99 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -159,5 +159,5 @@ static void polkit_exit(void)
 	dbus_connection_unref(connection);
 }
 
-CONNMAN_PLUGIN_DEFINE("polkit", "PolicyKit authorization plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(polkit, "PolicyKit authorization plugin", VERSION,
 						polkit_init, polkit_exit)
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index f81d1062..e1d53379 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -114,5 +114,5 @@ static void resolvconf_exit(void)
 	connman_driver_unregister(&resolvconf_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE("resolvconf", "Name resolver plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(resolvconf, "Name resolver plugin", VERSION,
 					resolvconf_init, resolvconf_exit)
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index 54ad41b3..deb39c94 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -95,5 +95,5 @@ static void resolvfile_exit(void)
 	connman_driver_unregister(&resolvfile_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE("resolvfile", "Name resolver plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(resolvfile, "Name resolver plugin", VERSION,
 					resolvfile_init, resolvfile_exit)
diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index 094547d0..da5a5887 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -167,5 +167,5 @@ static void rtnllink_exit(void)
 	device_list = NULL;
 }
 
-CONNMAN_PLUGIN_DEFINE("rtnllink", "RTNL link detection plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(rtnllink, "RTNL link detection plugin", VERSION,
 						rtnllink_init, rtnllink_exit)
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 0ae20f59..7d17ae21 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -507,5 +507,5 @@ static void wifi_exit(void)
 	dbus_connection_unref(connection);
 }
 
-CONNMAN_PLUGIN_DEFINE("wifi", "WiFi interface plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(wifi, "WiFi interface plugin", VERSION,
 							wifi_init, wifi_exit)

commit 1442498be8fef36f3ecc9641bc449941de0790cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 8 18:18:59 2008 +0100

    Remove send_interface statements

diff --git a/src/connman.conf b/src/connman.conf
index b8846a52..8d73de91 100644
--- a/src/connman.conf
+++ b/src/connman.conf
@@ -4,14 +4,11 @@
     <policy user="root">
         <allow own="org.moblin.connman"/>
         <allow send_destination="org.moblin.connman"/>
-        <allow send_interface="org.isc.dhclient"/>
     </policy>
     <policy at_console="true">
         <allow send_destination="org.moblin.connman"/>
-        <allow send_interface="org.moblin.connman"/>
     </policy>
     <policy context="default">
         <deny send_destination="org.moblin.connman"/>
-        <deny send_interface="org.moblin.connman"/>
     </policy>
 </busconfig>

commit 70f5d6b292a3b1e32aa2cfc6900506c35267b31b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 01:54:55 2008 +0100

    Fix handling of properties with byte values

diff --git a/src/element.c b/src/element.c
index 00da43a3..407afc73 100644
--- a/src/element.c
+++ b/src/element.c
@@ -186,12 +186,20 @@ static void append_property(DBusMessageIter *dict,
 	if (property->value == NULL)
 		return;
 
-	if (property->type == DBUS_TYPE_ARRAY)
+	switch (property->type) {
+	case DBUS_TYPE_ARRAY:
 		connman_dbus_dict_append_array(dict, property->name,
 			property->subtype, &property->value, property->size);
-	else
+		break;
+	case DBUS_TYPE_STRING:
 		connman_dbus_dict_append_variant(dict, property->name,
 					property->type, &property->value);
+		break;
+	default:
+		connman_dbus_dict_append_variant(dict, property->name,
+					property->type, property->value);
+		break;
+	}
 }
 
 static void add_common_properties(struct connman_element *element,
@@ -1068,8 +1076,7 @@ int connman_element_add_static_property(struct connman_element *element,
 
 	DBG("element %p name %s", element, element->name);
 
-	if (type != DBUS_TYPE_STRING && type != DBUS_TYPE_BYTE &&
-						type != DBUS_TYPE_INT32)
+	if (type != DBUS_TYPE_STRING && type != DBUS_TYPE_BYTE)
 		return -EINVAL;
 
 	property = g_try_new0(struct connman_property, 1);
@@ -1092,11 +1099,6 @@ int connman_element_add_static_property(struct connman_element *element,
 		if (property->value != NULL)
 			memcpy(property->value, value, 1);
 		break;
-	case DBUS_TYPE_INT32:
-		property->value = g_try_malloc(sizeof(gint32));
-		if (property->value != NULL)
-			memcpy(property->value, value, sizeof(gint32));
-		break;
 	}
 
 	__connman_element_lock(element);
@@ -1438,15 +1440,9 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 			switch (property->type) {
 			case DBUS_TYPE_STRING:
 				*((char **) value) = property->value;
-				break;
-			case DBUS_TYPE_BYTE:
-				*((guint8 *) value) = *((guint8 *) property->value);
-				break;
-			case DBUS_TYPE_INT32:
-				*((gint32 *) value) = *((gint32 *) property->value);
+				found = TRUE;
 				break;
 			}
-			found = TRUE;
 			break;
 		}
 	}

commit cd762b0091f6fda81e2a49b2e339abd1a446bc00
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 01:55:26 2008 +0100

    Include signal strength property

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 7d17ae21..5462bf28 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -239,8 +239,8 @@ static void scan_result(struct connman_element *parent,
 
 		strength = network->quality;
 
-		//connman_element_add_static_property(element, "WiFi.Strength",
-		//				DBUS_TYPE_BYTE, &strength);
+		connman_element_add_static_property(element, "WiFi.Strength",
+						DBUS_TYPE_BYTE, &strength);
 
 		//connman_element_add_static_property(element, "WiFi.Noise",
 		//			DBUS_TYPE_INT32, &network->noise);

commit 32cf3a028ebabc6c43bfa348b1513ebb407a7460
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 02:16:33 2008 +0100

    Show signal strength correctly and parse SSID value

diff --git a/test/list-networks b/test/list-networks
index 3b29a8e4..8f7e01bb 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -1,6 +1,7 @@
 #!/usr/bin/python
 
 import dbus
+import string
 
 bus = dbus.SystemBus()
 
@@ -9,6 +10,15 @@ manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 
 properties = manager.GetProperties()
 
+def convert_ssid(ssid_list):
+	ssid = ""
+	for byte in ssid_list:
+		if (str(byte) in string.printable):
+			ssid = ssid + str(byte)
+		else:
+			ssid = ssid + "."
+	return ssid
+
 for path in properties["Devices"]:
 	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Device")
@@ -29,6 +39,12 @@ for path in properties["Devices"]:
 		print "    [ %s ]" % (path)
 
 		for key in properties.keys():
-			print "        %s = %s" % (key, properties[key])
+			if (key == "WiFi.SSID"):
+				ssid = convert_ssid(properties[key])
+				print "        %s = [ %s ]" % (key, ssid)
+			elif (key == "WiFi.Strength"):
+				print "        %s = %d" % (key, properties[key])
+			else:
+				print "        %s = %s" % (key, properties[key])
 
 	print

commit b498d94a4409887a695af78a5af20bc7fc305c80
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 10:04:48 2008 +0100

    Don't enumerate network pseudo devices

diff --git a/src/element.c b/src/element.c
index 407afc73..9dd3039f 100644
--- a/src/element.c
+++ b/src/element.c
@@ -742,6 +742,10 @@ static gboolean append_path(GNode *node, gpointer user_data)
 					filter->type != element->type)
 		return FALSE;
 
+	if (filter->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_NETWORK)
+		return FALSE;
+
 	dbus_message_iter_append_basic(filter->iter,
 				DBUS_TYPE_OBJECT_PATH, &element->path);
 

commit 88bebe2a27bfcc790b5ca2d6bf8a395c0efbb4ad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:08:37 2008 +0100

    Document CreateNetwork and RemoveNetwork methods

diff --git a/doc/device-api.txt b/doc/device-api.txt
index d50a6c5f..ad462a6b 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -23,6 +23,22 @@ Methods		dict GetProperties()
 			Possible Errors: [service].Error.InvalidArguments
 					 [service].Error.DoesNotExist
 
+		object CreateNetwork(dict network)
+
+			Creates a network object from the specified
+			properties. Valid properties are WiFi.SSID,
+			WiFi.Security and WiFi.Passphrase. Check the
+			network interface description for details.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+		void RemoveNetwork(object network)
+
+			Removes a previously created network object.
+
+			Possible Errors: [service].Error.InvalidArguments
+					 [service].Error.DoesNotExist
+
 Signals		PropertyChanged(string name, variant value)
 
 			This signal indicates a changed value of the given

commit 2ace7fcefb7b636cea2d91e7c4c102b4b7037373
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:10:15 2008 +0100

    Remove invalid error messages

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index f0fba378..7f3d940e 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -11,7 +11,6 @@ Methods		dict GetProperties()
 			the properties section for available properties.
 
 			Possible Errors: [service].Error.InvalidArguments
-					 [service].Error.DoesNotExist
 
 Signals		PropertyChanged(string name, variant value)
 
diff --git a/doc/device-api.txt b/doc/device-api.txt
index ad462a6b..847b6f48 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -11,7 +11,6 @@ Methods		dict GetProperties()
 			the properties section for available properties.
 
 			Possible Errors: [service].Error.InvalidArguments
-					 [service].Error.DoesNotExist
 
 		void SetProperty(string name, variant value)
 
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 8ef43596..9365e66f 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -11,7 +11,6 @@ Methods		dict GetProperties()
 			properties section for available properties.
 
 			Possible Errors: [service].Error.InvalidArguments
-					 [service].Error.DoesNotExist
 
 		void SetProperty(string name, variant value)
 
diff --git a/doc/network-api.txt b/doc/network-api.txt
index eb7b40c4..be0cf39f 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -11,7 +11,6 @@ Methods		dict GetProperties()
 			the properties section for available properties.
 
 			Possible Errors: [service].Error.InvalidArguments
-					 [service].Error.DoesNotExist
 
 		void SetProperty(string name, variant value)
 
diff --git a/doc/service-api.txt b/doc/service-api.txt
index 0e5b13e6..ec29c95b 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -11,7 +11,6 @@ Methods		dict GetProperties()
 			the properties section for available properties.
 
 			Possible Errors: [service].Error.InvalidArguments
-					 [service].Error.DoesNotExist
 
 Signals		PropertyChanged(string name, variant value)
 

commit 1cfc371f117c273f8b633dd9e5b74dd95be7ecf1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:16:11 2008 +0100

    Document generic Name, Available and Remember properties

diff --git a/doc/network-api.txt b/doc/network-api.txt
index be0cf39f..9bcdf122 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -27,10 +27,25 @@ Signals		PropertyChanged(string name, variant value)
 			This signal indicates a changed value of the given
 			property.
 
-Properties	string WiFi.Name [readonly]
+Properties	string Name [readonly]
 
-			If the network type is WiFi, then this property is
-			present and contains the network name.
+			The pretty/long version of the network name. For
+			example in case of WiFi this should be the UTF-8
+			valid version of the SSID.
+
+		boolean Available [readonly]
+
+			Indicates that this network is in range and
+			ready to be used.
+
+			The scanning process can change this property.
+
+		boolean Remember [readwrite]
+
+			Indicates that this network will be remembered.
+
+			For manually created networks this is set by
+			default.
 
 		array{byte} WiFi.SSID [readonly]
 

commit b7f59753507e5ee0076a5cf4687d06b3da2ca0d3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:20:04 2008 +0100

    Use generic Name property instead of WiFi.Name

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 5462bf28..39f288d7 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -61,14 +61,14 @@ static void network_remove(struct connman_element *element)
 
 static int network_enable(struct connman_element *element)
 {
-	char *identifier, *security = NULL, *passphrase = NULL;
+	char *name, *security = NULL, *passphrase = NULL;
 	unsigned char *ssid;
 	int ssid_len;
 
 	DBG("element %p name %s", element, element->name);
 
 	if (connman_element_get_static_property(element,
-					"WiFi.Name", &identifier) == FALSE)
+						"Name", &name) == FALSE)
 		return -EIO;
 
 	if (connman_element_get_static_array_property(element,
@@ -83,7 +83,7 @@ static int network_enable(struct connman_element *element)
 
 		if (data != NULL) {
 			g_free(data->identifier);
-			data->identifier = g_strdup(identifier);
+			data->identifier = g_strdup(name);
 		}
 	}
 
@@ -93,8 +93,8 @@ static int network_enable(struct connman_element *element)
 	connman_element_get_value(element,
 			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &passphrase);
 
-	DBG("identifier %s security %s passhprase %s",
-					identifier, security, passphrase);
+	DBG("name %s security %s passhprase %s",
+					name, security, passphrase);
 
 	if (__supplicant_connect(element, ssid, ssid_len,
 						security, passphrase) < 0)
@@ -133,7 +133,7 @@ static struct connman_element *find_element(struct wifi_data *data,
 		struct connman_element *element = list->data;
 
 		if (connman_element_match_static_property(element,
-					"WiFi.Name", &identifier) == TRUE)
+					"Name", &identifier) == TRUE)
 			return element;
 	}
 
@@ -216,7 +216,7 @@ static void scan_result(struct connman_element *parent,
 
 		data->list = g_slist_append(data->list, element);
 
-		connman_element_add_static_property(element, "WiFi.Name",
+		connman_element_add_static_property(element, "Name",
 				DBUS_TYPE_STRING, &network->identifier);
 
 		connman_element_add_static_array_property(element, "WiFi.SSID",

commit 45d2f588889b385b8a7a209e3e6fe2559cd5b950
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:22:04 2008 +0100

    Add skeleton for manual network creation API

diff --git a/src/element.c b/src/element.c
index 9dd3039f..70da7425 100644
--- a/src/element.c
+++ b/src/element.c
@@ -395,7 +395,7 @@ static void append_networks(struct connman_element *element,
 	dbus_message_iter_close_container(dict, &entry);
 }
 
-static DBusMessage *get_device_properties(DBusConnection *conn,
+static DBusMessage *device_get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
@@ -438,7 +438,7 @@ static DBusMessage *get_device_properties(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *set_device_property(DBusConnection *conn,
+static DBusMessage *device_set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
@@ -475,6 +475,18 @@ static DBusMessage *set_device_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static DBusMessage *device_create_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return __connman_error_invalid_arguments(msg);
+}
+
+static DBusMessage *device_remove_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *get_network_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -704,9 +716,11 @@ static GDBusSignalTable element_signals[] = {
 };
 
 static GDBusMethodTable device_methods[] = {
-	{ "GetProperties", "",   "a{sv}", get_device_properties },
-	{ "SetProperty",   "sv", "",      set_device_property   },
-	{ "Scan",          "",   "",      do_update             },
+	{ "GetProperties", "",      "a{sv}", device_get_properties },
+	{ "SetProperty",   "sv",    "",      device_set_property   },
+	{ "CreateNetwork", "a{sv}", "o",     device_create_network },
+	{ "RemoveNetwork", "o",     "",      device_remove_network },
+	{ "ProposeScan",   "",      "",      do_update             },
 	{ },
 };
 

commit 518c863bcaab4bd138d655dbb280fbd9153cda49
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:22:47 2008 +0100

    Use ProposeScan method

diff --git a/test/start-scanning b/test/start-scanning
index 9d3f4db5..aaa3e58a 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -19,10 +19,10 @@ for path in properties["Devices"]:
 
 	if (properties["Type"] == "wifi"):
 		print "   Started WiFi scanning"
-		device.Scan()
+		device.ProposeScan()
 	elif (properties["Type"] == "wimax"):
 		print "   Started WiMAX scanning"
-		device.Scan()
+		device.ProposeScan()
 	else:
 		print "   No scanning"
 

commit 4b9a69f1d6b579679be9a8190f60eb28fceaf547
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:44:30 2008 +0100

    Add first draft of implemention for CreateNetwork

diff --git a/src/element.c b/src/element.c
index 70da7425..6ad75b1b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -442,8 +442,7 @@ static DBusMessage *device_set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
-	DBusMessageIter iter;
-	DBusMessageIter value;
+	DBusMessageIter iter, value;
 	const char *name;
 
 	DBG("conn %p", conn);
@@ -475,10 +474,74 @@ static DBusMessage *device_set_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static int parse_network_dict(DBusMessageIter *iter, const char **ssid,
+				const char **security, const char **passphrase)
+{
+	while (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+
+		dbus_message_iter_recurse(iter, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+		dbus_message_iter_recurse(&entry, &value);
+
+		switch (dbus_message_iter_get_arg_type(&value)) {
+		case DBUS_TYPE_STRING:
+			if (g_str_equal(key, "WiFi.SSID") == TRUE)
+				dbus_message_iter_get_basic(&value, ssid);
+			else if (g_str_equal(key, "WiFi.Security") == TRUE)
+				dbus_message_iter_get_basic(&value, security);
+			else if (g_str_equal(key, "WiFi.Passphrase") == TRUE)
+				dbus_message_iter_get_basic(&value, passphrase);
+			break;
+		}
+
+		dbus_message_iter_next(iter);
+	}
+
+	return 0;
+}
+
 static DBusMessage *device_create_network(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
-	return __connman_error_invalid_arguments(msg);
+	struct connman_element *element = data;
+	struct connman_element *network;
+	DBusMessageIter iter, array;
+	const char *ssid = NULL, *security = NULL, *passphrase = NULL;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_recurse(&iter, &array);
+	parse_network_dict(&array, &ssid, &security, &passphrase);
+	if (ssid == NULL)
+		return __connman_error_invalid_arguments(msg);
+
+	DBG("ssid %s security %s passphrase %s", ssid, security, passphrase);
+
+	network = connman_element_create(ssid);
+
+	network->type = CONNMAN_ELEMENT_TYPE_NETWORK;
+	network->index = element->index;
+
+	connman_element_add_static_property(network, "Name",
+						DBUS_TYPE_STRING, &ssid);
+
+	connman_element_add_static_array_property(element, "WiFi.SSID",
+					DBUS_TYPE_BYTE, &ssid, strlen(ssid));
+
+	network->wifi.security = g_strdup(security);
+	network->wifi.passphrase = g_strdup(passphrase);
+
+	connman_element_register(network, element);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_OBJECT_PATH, &network->path,
+							DBUS_TYPE_INVALID);
 }
 
 static DBusMessage *device_remove_network(DBusConnection *conn,

commit 03556de2e4798fd592f6f35c8845eb72c9ead693
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 9 18:45:52 2008 +0100

    Add test script for network creation

diff --git a/test/Makefile.am b/test/Makefile.am
index 9bf9ecf3..1e38effb 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,7 +1,8 @@
 
 EXTRA_DIST = get-state list-profiles list-connections \
 		list-devices enable-device disable-device start-scanning \
-		list-networks select-network disable-network set-passphrase \
-		simple-agent show-introspection test-manager test-compat
+		list-networks select-network disable-network create-network \
+		set-passphrase simple-agent show-introspection \
+		test-manager test-compat
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/create-network b/test/create-network
new file mode 100755
index 00000000..32c8ab30
--- /dev/null
+++ b/test/create-network
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 2):
+	print "Usage: %s <network>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
+		continue;
+
+	path = device.CreateNetwork({ "WiFi.SSID": sys.argv[1] });

commit ab6d36ab9ea43a39daf3d68f1ae2486cfb92457b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 10 23:40:29 2008 +0100

    Don't built fake plugin anymore

diff --git a/bootstrap-configure b/bootstrap-configure
index cba03dcc..0714169e 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -16,4 +16,4 @@ fi
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
 		--sysconfdir=/etc \
-		--enable-fake $*
+		--disable-fake $*

commit d6558ac5058ca81e2bb25ea1ee5f20a7186e4dcf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 00:26:40 2008 +0100

    Mention Connected property

diff --git a/doc/network-api.txt b/doc/network-api.txt
index 9bcdf122..8480fcdf 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -40,6 +40,10 @@ Properties	string Name [readonly]
 
 			The scanning process can change this property.
 
+		boolean Connected [readonly]
+
+			Indicates that this network is currently connected.
+
 		boolean Remember [readwrite]
 
 			Indicates that this network will be remembered.

commit 0dbb44988061fa97f85bb56e5b745df9fe888cba
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 00:29:28 2008 +0100

    Add Available and Remember properties for networks

diff --git a/include/element.h b/include/element.h
index 85b9b069..aaf389dc 100644
--- a/include/element.h
+++ b/include/element.h
@@ -92,6 +92,8 @@ struct connman_element {
 	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
+	gboolean available;
+	gboolean remember;
 	guint16 priority;
 
 	struct connman_element *parent;
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 39f288d7..b0ee4aef 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -251,6 +251,8 @@ static void scan_result(struct connman_element *parent,
 		connman_element_register(element, parent);
 	}
 
+	element->available = TRUE;
+
 	g_free(temp);
 }
 
diff --git a/src/element.c b/src/element.c
index 6ad75b1b..a8eee215 100644
--- a/src/element.c
+++ b/src/element.c
@@ -529,6 +529,8 @@ static DBusMessage *device_create_network(DBusConnection *conn,
 	network->type = CONNMAN_ELEMENT_TYPE_NETWORK;
 	network->index = element->index;
 
+	network->remember = TRUE;
+
 	connman_element_add_static_property(network, "Name",
 						DBUS_TYPE_STRING, &ssid);
 
@@ -550,7 +552,7 @@ static DBusMessage *device_remove_network(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static DBusMessage *get_network_properties(DBusConnection *conn,
+static DBusMessage *network_get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
@@ -576,9 +578,15 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Policy",
 						DBUS_TYPE_STRING, &str);
 
+	connman_dbus_dict_append_variant(&dict, "Available",
+					DBUS_TYPE_BOOLEAN, &element->available);
+
 	connman_dbus_dict_append_variant(&dict, "Connected",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
+	connman_dbus_dict_append_variant(&dict, "Remember",
+					DBUS_TYPE_BOOLEAN, &element->remember);
+
 	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);
@@ -586,7 +594,7 @@ static DBusMessage *get_network_properties(DBusConnection *conn,
 	return reply;
 }
 
-static DBusMessage *set_network_property(DBusConnection *conn,
+static DBusMessage *network_set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
@@ -606,7 +614,9 @@ static DBusMessage *set_network_property(DBusConnection *conn,
 	if (__connman_security_check_privileges(msg) < 0)
 		return __connman_error_permission_denied(msg);
 
-	if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
+	if (g_str_equal(name, "Remember") == TRUE) {
+		dbus_message_iter_get_basic(&value, &element->remember);
+	} else if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
 		const char *str;
 
 		dbus_message_iter_get_basic(&value, &str);
@@ -788,8 +798,8 @@ static GDBusMethodTable device_methods[] = {
 };
 
 static GDBusMethodTable network_methods[] = {
-	{ "GetProperties", "",   "a{sv}", get_network_properties },
-	{ "SetProperty",   "sv", "",      set_network_property   },
+	{ "GetProperties", "",   "a{sv}", network_get_properties },
+	{ "SetProperty",   "sv", "",      network_set_property   },
 	{ "Connect",       "",   "",      do_enable              },
 	{ "Disconnect",    "",   "",      do_disable             },
 	{ },
diff --git a/src/storage.c b/src/storage.c
index bbd9417c..e0e3dc55 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -48,6 +48,10 @@ static int do_load(GKeyFile *keyfile, struct connman_element *element)
 	if (value != NULL)
 		element->policy = __connman_element_string2policy(value);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
+		element->remember = g_key_file_get_boolean(keyfile,
+					element->path, "Remember", NULL);
+
 	value = g_key_file_get_string(keyfile, element->path,
 						"WiFi.Security", NULL);
 	if (value != NULL)
@@ -116,6 +120,10 @@ static void do_update(GKeyFile *keyfile, struct connman_element *element)
 	//g_key_file_set_boolean(keyfile, element->path, "Enabled",
 	//						element->enabled);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
+		g_key_file_set_boolean(keyfile, element->path, "Remember",
+							element->remember);
+
 	__connman_element_lock(element);
 
 	for (list = element->properties; list; list = list->next) {
@@ -172,7 +180,7 @@ int __connman_element_store(struct connman_element *element)
 
 	if (length > 0) {
 		if (g_key_file_load_from_data(keyfile, data, length,
-				G_KEY_FILE_KEEP_COMMENTS, NULL) == FALSE)
+							0, NULL) == FALSE)
 			goto done;
 	}
 

commit da8e11efb0472f8d21cd4afff152036701e531a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 16:56:43 2008 +0100

    Add devname attribute for device filtering

diff --git a/include/element.h b/include/element.h
index aaf389dc..e56f669f 100644
--- a/include/element.h
+++ b/include/element.h
@@ -95,6 +95,7 @@ struct connman_element {
 	gboolean available;
 	gboolean remember;
 	guint16 priority;
+	gchar *devname;
 
 	struct connman_element *parent;
 
diff --git a/src/element.c b/src/element.c
index a8eee215..7361eb24 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1154,6 +1154,7 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.network);
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
+		g_free(element->devname);
 		g_free(element->path);
 		g_free(element->name);
 		g_free(element);
@@ -1846,10 +1847,14 @@ int connman_element_register(struct connman_element *element,
 {
 	DBG("element %p name %s parent %p", element, element->name, parent);
 
+	if (element->devname == NULL)
+		element->devname = g_strdup(element->name);
+
 	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
 		if (g_pattern_match_simple(device_filter,
-						element->name) == FALSE) {
-			DBG("ignoring %s device", element->name);
+						element->devname) == FALSE) {
+			DBG("ignoring %s [%s] device", element->name,
+							element->devname);
 			return -EPERM;
 		}
 	}

commit 6fc878f74ce6d37260f29c782cd65a47483083e4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 16:57:12 2008 +0100

    Add common index to ident conversion helper

diff --git a/plugins/inet.c b/plugins/inet.c
index e14d33ef..ab0fcdcd 100644
--- a/plugins/inet.c
+++ b/plugins/inet.c
@@ -26,10 +26,12 @@
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <net/if.h>
+#include <net/ethernet.h>
 
 #include "inet.h"
 
@@ -57,3 +59,49 @@ char *inet_index2name(int index)
 
 	return strdup(ifr.ifr_name);
 }
+
+char *inet_index2ident(int index, const char *prefix)
+{
+	struct ifreq ifr;
+	struct ether_addr *eth;
+	char *str;
+	int sk, err, len;
+
+	if (index < 0)
+		return NULL;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	len = prefix ? strlen(prefix) + 18 : 18;
+
+	str = malloc(len);
+	if (!str)
+		return NULL;
+
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	snprintf(str, len, "%s%02X_%02X_%02X_%02X_%02X_%02X",
+						prefix ? prefix : "",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
+	return str;
+}
diff --git a/plugins/inet.h b/plugins/inet.h
index aafd55b3..afa80253 100644
--- a/plugins/inet.h
+++ b/plugins/inet.h
@@ -20,3 +20,4 @@
  */
 
 char *inet_index2name(int index);
+char *inet_index2ident(int index, const char *prefix);

commit 63c934f2f9daeb743416c0f7a440adf72690a3fc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 16:57:42 2008 +0100

    Create unique device name and object path

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index da5a5887..3fbcedbd 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -48,7 +48,7 @@ static void rtnllink_newlink(unsigned short type, int index,
 	struct connman_element *device;
 	GSList *list;
 	gboolean exists = FALSE;
-	gchar *name;
+	gchar *name, *devname;
 
 	DBG("index %d", index);
 
@@ -64,7 +64,8 @@ static void rtnllink_newlink(unsigned short type, int index,
 	if (exists == TRUE)
 		return;
 
-	name = inet_index2name(index);
+	name = inet_index2ident(index, "dev_");
+	devname = inet_index2name(index);
 
 	if (type == ARPHRD_ETHER) {
 		char bridge_path[PATH_MAX], wimax_path[PATH_MAX];
@@ -78,7 +79,7 @@ static void rtnllink_newlink(unsigned short type, int index,
 					"/sys/class/net/%s/wimax", name);
 
 		memset(&iwr, 0, sizeof(iwr));
-		strncpy(iwr.ifr_ifrn.ifrn_name, name, IFNAMSIZ);
+		strncpy(iwr.ifr_ifrn.ifrn_name, devname, IFNAMSIZ);
 
 		sk = socket(PF_INET, SOCK_DGRAM, 0);
 
@@ -107,6 +108,7 @@ static void rtnllink_newlink(unsigned short type, int index,
 
 	device->index = index;
 	device->name = name;
+	device->devname = devname;
 
 	connman_element_register(device, NULL);
 	device_list = g_slist_append(device_list, device);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index b0ee4aef..93312caa 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -356,7 +356,7 @@ static void wifi_newlink(unsigned short type, int index,
 	struct connman_element *device;
 	GSList *list;
 	gboolean exists = FALSE;
-	gchar *name;
+	gchar *name, *devname;
 	struct iwreq iwr;
 	int sk;
 
@@ -365,10 +365,11 @@ static void wifi_newlink(unsigned short type, int index,
 	if (type != ARPHRD_ETHER)
 		return;
 
-	name = inet_index2name(index);
+	name = inet_index2ident(index, "dev_");
+	devname = inet_index2name(index);
 
 	memset(&iwr, 0, sizeof(iwr));
-	strncpy(iwr.ifr_ifrn.ifrn_name, name, IFNAMSIZ);
+	strncpy(iwr.ifr_ifrn.ifrn_name, devname, IFNAMSIZ);
 
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 
@@ -400,6 +401,7 @@ static void wifi_newlink(unsigned short type, int index,
 
 	device->index = index;
 	device->name = name;
+	device->devname = devname;
 
 	connman_element_register(device, NULL);
 	device_list = g_slist_append(device_list, device);

commit 05534b145e751387994ae35dc9f344a306540122
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 16:58:46 2008 +0100

    Remove deprecated INET helper functions

diff --git a/src/iface-inet.c b/src/iface-inet.c
deleted file mode 100644
index cd21c137..00000000
--- a/src/iface-inet.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <net/if.h>
-#include <net/ethernet.h>
-
-#include "connman.h"
-
-int __connman_iface_create_identifier(struct connman_iface *iface)
-{
-	struct ifreq ifr;
-	struct ether_addr *eth;
-	int sk, err;
-
-	DBG("iface %p", iface);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	if (err == 0)
-		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return -EIO;
-
-	iface->identifier = malloc(18);
-	if (iface->identifier == NULL)
-		return -ENOMEM;
-
-	eth = (void *) &ifr.ifr_hwaddr.sa_data;
-	sprintf(iface->identifier, "%02X-%02X-%02X-%02X-%02X-%02X",
-						eth->ether_addr_octet[0],
-						eth->ether_addr_octet[1],
-						eth->ether_addr_octet[2],
-						eth->ether_addr_octet[3],
-						eth->ether_addr_octet[4],
-						eth->ether_addr_octet[5]);
-
-	return 0;
-}
-
-int __connman_iface_init_via_inet(struct connman_iface *iface)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	DBG("iface %p", iface);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -EIO;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	err = ioctl(sk, SIOCGIFNAME, &ifr);
-
-	if (err == 0)
-		err = ioctl(sk, SIOCGIFFLAGS, &ifr);
-
-	close(sk);
-
-	if (err < 0)
-		return -EIO;
-
-	if (ifr.ifr_flags & IFF_UP)
-		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-	else
-		iface->state = CONNMAN_IFACE_STATE_OFF;
-
-	if (ifr.ifr_flags & IFF_RUNNING) {
-		if (!(iface->flags & CONNMAN_IFACE_FLAG_NOCARRIER))
-			iface->state = CONNMAN_IFACE_STATE_CARRIER;
-	}
-
-	return 0;
-}
-
-static int __connman_iface_up(struct connman_iface *iface)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	DBG("iface %p", iface);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -errno;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (ifr.ifr_flags & IFF_UP) {
-		err = -EALREADY;
-		goto done;
-	}
-
-	ifr.ifr_flags |= IFF_UP;
-
-	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	err = 0;
-
-done:
-	close(sk);
-
-	return err;
-}
-
-static int __connman_iface_down(struct connman_iface *iface)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	DBG("iface %p", iface);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -errno;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (!(ifr.ifr_flags & IFF_UP)) {
-		err = -EALREADY;
-		goto done;
-	}
-
-	ifr.ifr_flags &= ~IFF_UP;
-
-	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
-		err = -errno;
-	else
-		err = 0;
-
-done:
-	close(sk);
-
-	return err;
-}
-
-int __connman_iface_start(struct connman_iface *iface)
-{
-	int err;
-
-	DBG("iface %p", iface);
-
-	if (iface->flags & CONNMAN_IFACE_FLAG_STARTED)
-		return -EALREADY;
-
-	err = __connman_iface_up(iface);
-
-	if (iface->driver->start) {
-		err = iface->driver->start(iface);
-		if (err < 0)
-			return err;
-	}
-
-	iface->flags |= CONNMAN_IFACE_FLAG_STARTED;
-
-	return 0;
-}
-
-int __connman_iface_stop(struct connman_iface *iface)
-{
-	int err;
-
-	DBG("iface %p", iface);
-
-	__connman_dhcp_release(iface);
-
-	connman_iface_clear_ipv4(iface);
-
-	if (iface->flags & CONNMAN_IFACE_FLAG_RUNNING) {
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
-		iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
-	}
-
-	if (!(iface->flags & CONNMAN_IFACE_FLAG_STARTED))
-		return -EINVAL;
-
-	if (iface->driver->stop) {
-		err = iface->driver->stop(iface);
-		if (err < 0)
-			return err;
-	}
-
-	iface->flags &= ~CONNMAN_IFACE_FLAG_STARTED;
-
-	err = __connman_iface_down(iface);
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-int __connman_iface_connect(struct connman_iface *iface,
-					struct connman_network *network)
-{
-	DBG("iface %p name %s passphrase %s", iface,
-				network->identifier, network->passphrase);
-
-	if (iface->flags & CONNMAN_IFACE_FLAG_RUNNING) {
-		__connman_dhcp_release(iface);
-
-		connman_iface_clear_ipv4(iface);
-
-		if (iface->driver->disconnect)
-			iface->driver->disconnect(iface);
-
-		iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
-	}
-
-	if (iface->driver->connect)
-		iface->driver->connect(iface, network);
-
-	iface->flags |= CONNMAN_IFACE_FLAG_RUNNING;
-
-	return 0;
-}
-
-int __connman_iface_disconnect(struct connman_iface *iface)
-{
-	DBG("iface %p", iface);
-
-	__connman_dhcp_release(iface);
-
-	connman_iface_clear_ipv4(iface);
-
-	if (!(iface->flags & CONNMAN_IFACE_FLAG_RUNNING))
-		return -EINVAL;
-
-	if (iface->driver->disconnect)
-		iface->driver->disconnect(iface);
-
-	iface->flags &= ~CONNMAN_IFACE_FLAG_RUNNING;
-
-	return 0;
-}

commit 68cb90edd4b5b27813f937cca498c298305095cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 17:12:27 2008 +0100

    Add definitions for IPv4 methods

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 542c4e18..a0e12e23 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -104,6 +104,7 @@
     <xi:include href="xml/security.xml" />
     <xi:include href="xml/element.xml" />
     <xi:include href="xml/driver.xml" />
+    <xi:include href="xml/ipv4.xml" />
   </reference>
 
   <appendix id="license">
diff --git a/include/Makefile.am b/include/Makefile.am
index 704ac561..8c6617e6 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -2,7 +2,7 @@
 includedir = @includedir@/connman
 
 include_HEADERS = log.h plugin.h security.h resolver.h driver.h \
-				element.h property.h network.h rtnl.h dbus.h
+			element.h property.h network.h ipv4.h rtnl.h dbus.h
 
 noinst_HEADERS = device.h
 
diff --git a/include/ipv4.h b/include/ipv4.h
new file mode 100644
index 00000000..3cbf85b2
--- /dev/null
+++ b/include/ipv4.h
@@ -0,0 +1,46 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_IPV4_H
+#define __CONNMAN_IPV4_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * SECTION:ipv4
+ * @title: IPv4 premitives
+ * @short_description: Functions for handling IPv4
+ */
+
+enum connman_ipv4_method {
+	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
+	CONNMAN_IPV4_METHOD_OFF     = 1,
+	CONNMAN_IPV4_METHOD_STATIC  = 2,
+	CONNMAN_IPV4_METHOD_DHCP    = 3,
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_IPV4_H */
diff --git a/src/connman.h b/src/connman.h
index 965a2839..44a56ef2 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -62,6 +62,7 @@ void __connman_plugin_cleanup(void);
 
 int __connman_security_check_privileges(DBusMessage *message);
 
+#include <connman/ipv4.h>
 #include <connman/resolver.h>
 
 #include <connman/driver.h>

commit 516bd979f71d8d1de1fb34e95345bcc3edd882fe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 17:14:34 2008 +0100

    Don't include ipv4.xml for now

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index a0e12e23..542c4e18 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -104,7 +104,6 @@
     <xi:include href="xml/security.xml" />
     <xi:include href="xml/element.xml" />
     <xi:include href="xml/driver.xml" />
-    <xi:include href="xml/ipv4.xml" />
   </reference>
 
   <appendix id="license">

commit bc9ec6ee5880b7301be327740fe693edaadeb229
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 17:15:57 2008 +0100

    Add functions for IPv4 method conversion

diff --git a/src/connman.h b/src/connman.h
index 44a56ef2..0275febd 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -63,6 +63,10 @@ void __connman_plugin_cleanup(void);
 int __connman_security_check_privileges(DBusMessage *message);
 
 #include <connman/ipv4.h>
+
+const char *__connman_ipv4_method2string(enum connman_ipv4_method method);
+enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
+
 #include <connman/resolver.h>
 
 #include <connman/driver.h>
diff --git a/src/element.c b/src/element.c
index 7361eb24..16a7d277 100644
--- a/src/element.c
+++ b/src/element.c
@@ -180,6 +180,34 @@ enum connman_element_policy __connman_element_string2policy(const char *policy)
 		return CONNMAN_ELEMENT_POLICY_UNKNOWN;
 }
 
+const char *__connman_ipv4_method2string(enum connman_ipv4_method method)
+{
+	switch (method) {
+	case CONNMAN_IPV4_METHOD_UNKNOWN:
+		return "unknown";
+	case CONNMAN_IPV4_METHOD_OFF:
+		return "off";
+	case CONNMAN_IPV4_METHOD_STATIC:
+		return "static";
+	case CONNMAN_IPV4_METHOD_DHCP:
+		return "dhcp";
+	}
+
+	return "unknown";
+}
+
+enum connman_ipv4_method __connman_ipv4_string2method(const char *method)
+{
+	if (strcasecmp(method, "off") == 0)
+		return CONNMAN_IPV4_METHOD_OFF;
+	else if (strcasecmp(method, "static") == 0)
+		return CONNMAN_IPV4_METHOD_STATIC;
+	else if (strcasecmp(method, "dhcp") == 0)
+		return CONNMAN_IPV4_METHOD_DHCP;
+	else
+		return CONNMAN_IPV4_METHOD_UNKNOWN;
+}
+
 static void append_property(DBusMessageIter *dict,
 				struct connman_property *property)
 {

commit 6a1f084d9ba7673c39cc901106d128840c27f942
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 17:16:19 2008 +0100

    Remove deprecated interface helpers

diff --git a/src/iface-helper.c b/src/iface-helper.c
deleted file mode 100644
index 23c26051..00000000
--- a/src/iface-helper.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string.h>
-
-#include "connman.h"
-
-const char *__connman_iface_type2string(enum connman_iface_type type)
-{
-	switch (type) {
-	case CONNMAN_IFACE_TYPE_UNKNOWN:
-		return "unknown";
-	case CONNMAN_IFACE_TYPE_80203:
-		return "80203";
-	case CONNMAN_IFACE_TYPE_80211:
-		return "80211";
-	case CONNMAN_IFACE_TYPE_WIMAX:
-		return "wimax";
-	case CONNMAN_IFACE_TYPE_MODEM:
-		return "modem";
-	case CONNMAN_IFACE_TYPE_BLUETOOTH:
-		return "bluetooth";
-	}
-
-	return "unknown";
-}
-
-const char *__connman_iface_state2string(enum connman_iface_state state)
-{
-	switch (state) {
-	case CONNMAN_IFACE_STATE_UNKNOWN:
-		return "unknown";
-	case CONNMAN_IFACE_STATE_OFF:
-		return "off";
-	case CONNMAN_IFACE_STATE_ENABLED:
-		return "enabled";
-	case CONNMAN_IFACE_STATE_SCANNING:
-		return "scanning";
-	case CONNMAN_IFACE_STATE_CONNECT:
-		return "connect";
-	case CONNMAN_IFACE_STATE_CONNECTED:
-		return "connected";
-	case CONNMAN_IFACE_STATE_CARRIER:
-		return "carrier";
-	case CONNMAN_IFACE_STATE_CONFIGURE:
-		return "configure";
-	case CONNMAN_IFACE_STATE_READY:
-		return "ready";
-	case CONNMAN_IFACE_STATE_SHUTDOWN:
-		return "shutdown";
-	}
-
-	return "unknown";
-}
-
-const char *__connman_iface_policy2string(enum connman_iface_policy policy)
-{
-	switch (policy) {
-	case CONNMAN_IFACE_POLICY_UNKNOWN:
-		return "unknown";
-	case CONNMAN_IFACE_POLICY_OFF:
-		return "off";
-	case CONNMAN_IFACE_POLICY_IGNORE:
-		return "ignore";
-	case CONNMAN_IFACE_POLICY_AUTO:
-		return "auto";
-	case CONNMAN_IFACE_POLICY_ASK:
-		return "ask";
-	}
-
-	return "unknown";
-}
-
-enum connman_iface_policy __connman_iface_string2policy(const char *policy)
-{
-	if (strcasecmp(policy, "off") == 0)
-		return CONNMAN_IFACE_POLICY_OFF;
-	else if (strcasecmp(policy, "ignore") == 0)
-		return CONNMAN_IFACE_POLICY_IGNORE;
-	else if (strcasecmp(policy, "auto") == 0)
-		return CONNMAN_IFACE_POLICY_AUTO;
-	else if (strcasecmp(policy, "ask") == 0)
-		return CONNMAN_IFACE_POLICY_ASK;
-	else
-		return CONNMAN_IFACE_POLICY_UNKNOWN;
-}
-
-const char *__connman_ipv4_method2string(enum connman_ipv4_method method)
-{
-	switch (method) {
-	case CONNMAN_IPV4_METHOD_UNKNOWN:
-		return "unknown";
-	case CONNMAN_IPV4_METHOD_OFF:
-		return "off";
-	case CONNMAN_IPV4_METHOD_STATIC:
-		return "static";
-	case CONNMAN_IPV4_METHOD_DHCP:
-		return "dhcp";
-	}
-
-	return "unknown";
-}
-
-enum connman_ipv4_method __connman_ipv4_string2method(const char *method)
-{
-	if (strcasecmp(method, "off") == 0)
-		return CONNMAN_IPV4_METHOD_OFF;
-	else if (strcasecmp(method, "static") == 0)
-		return CONNMAN_IPV4_METHOD_STATIC;
-	else if (strcasecmp(method, "dhcp") == 0)
-		return CONNMAN_IPV4_METHOD_DHCP;
-	else
-		return CONNMAN_IPV4_METHOD_UNKNOWN;
-}

commit 373b7a179f8a5b861ed7f376d89e756d71a6a84c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 17:16:48 2008 +0100

    Remove deprecated interface declarations

diff --git a/include/iface.h b/include/iface.h
deleted file mode 100644
index 3530f23b..00000000
--- a/include/iface.h
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifndef __CONNMAN_IFACE_H
-#define __CONNMAN_IFACE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <netinet/in.h>
-
-enum connman_iface_type {
-	CONNMAN_IFACE_TYPE_UNKNOWN   = 0,
-	CONNMAN_IFACE_TYPE_80203     = 1,
-	CONNMAN_IFACE_TYPE_80211     = 2,
-	CONNMAN_IFACE_TYPE_WIMAX     = 3,
-	CONNMAN_IFACE_TYPE_MODEM     = 4,
-	CONNMAN_IFACE_TYPE_BLUETOOTH = 5,
-};
-
-enum connman_iface_flags {
-	CONNMAN_IFACE_FLAG_RTNL      = (1 << 0),
-	CONNMAN_IFACE_FLAG_IPV4      = (1 << 1),
-	CONNMAN_IFACE_FLAG_IPV6      = (1 << 2),
-	CONNMAN_IFACE_FLAG_SCANNING  = (1 << 3),
-	CONNMAN_IFACE_FLAG_NOCARRIER = (1 << 4),
-
-	CONNMAN_IFACE_FLAG_STARTED   = (1 << 16),
-	CONNMAN_IFACE_FLAG_RUNNING   = (1 << 17),
-	CONNMAN_IFACE_FLAG_DHCP      = (1 << 18),
-};
-
-enum connman_iface_state {
-	CONNMAN_IFACE_STATE_UNKNOWN   = 0,
-	CONNMAN_IFACE_STATE_OFF       = 1,
-	CONNMAN_IFACE_STATE_ENABLED   = 2,
-	CONNMAN_IFACE_STATE_SCANNING  = 3,
-	CONNMAN_IFACE_STATE_CONNECT   = 4,
-	CONNMAN_IFACE_STATE_CONNECTED = 5,
-	CONNMAN_IFACE_STATE_CARRIER   = 6,
-	CONNMAN_IFACE_STATE_CONFIGURE = 7,
-	CONNMAN_IFACE_STATE_READY     = 8,
-	CONNMAN_IFACE_STATE_SHUTDOWN  = 9,
-};
-
-enum connman_iface_policy {
-	CONNMAN_IFACE_POLICY_UNKNOWN = 0,
-	CONNMAN_IFACE_POLICY_OFF     = 1,
-	CONNMAN_IFACE_POLICY_IGNORE  = 2,
-	CONNMAN_IFACE_POLICY_AUTO    = 3,
-	CONNMAN_IFACE_POLICY_ASK     = 4,
-};
-
-enum connman_ipv4_method {
-	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
-	CONNMAN_IPV4_METHOD_OFF     = 1,
-	CONNMAN_IPV4_METHOD_STATIC  = 2,
-	CONNMAN_IPV4_METHOD_DHCP    = 3,
-};
-
-struct connman_ipv4 {
-	enum connman_ipv4_method method;
-	struct in_addr address;
-	struct in_addr netmask;
-	struct in_addr gateway;
-	struct in_addr network;
-	struct in_addr broadcast;
-	struct in_addr nameserver;
-};
-
-struct connman_network {
-	struct connman_iface *iface;
-	char *path;
-	char *identifier;
-	char *passphrase;
-};
-
-struct connman_iface {
-	char *path;
-	char *udi;
-	char *sysfs;
-	char *identifier;
-	int index;
-	enum connman_iface_type type;
-	unsigned long flags;
-	enum connman_iface_state state;
-	enum connman_iface_policy policy;
-	struct connman_network network;
-	struct connman_ipv4 ipv4;
-
-	struct connman_iface_driver *driver;
-	void *driver_data;
-
-	void *rtnl_data;
-
-	struct {
-		char *driver;
-		char *vendor;
-		char *product;
-	} device;
-};
-
-struct connman_iface_driver {
-	const char *name;
-	const char *capability;
-
-	int (*probe) (struct connman_iface *iface);
-	void (*remove) (struct connman_iface *iface);
-
-	int (*start) (struct connman_iface *iface);
-	int (*stop) (struct connman_iface *iface);
-
-	int (*scan) (struct connman_iface *iface);
-	int (*connect) (struct connman_iface *iface,
-					struct connman_network *network);
-	int (*disconnect) (struct connman_iface *iface);
-
-	void (*rtnl_carrier) (struct connman_iface *iface, int carrier);
-	void (*rtnl_wireless) (struct connman_iface *iface,
-					void *data, unsigned short len);
-};
-
-extern int connman_iface_register(struct connman_iface_driver *driver);
-extern void connman_iface_unregister(struct connman_iface_driver *driver);
-
-static inline void *connman_iface_get_data(struct connman_iface *iface)
-{
-	return iface->driver_data;
-}
-
-static inline void connman_iface_set_data(struct connman_iface *iface,
-								void *data)
-{
-	iface->driver_data = data;
-}
-
-extern void connman_iface_indicate_ifup(struct connman_iface *iface);
-extern void connman_iface_indicate_ifdown(struct connman_iface *iface);
-extern void connman_iface_indicate_connected(struct connman_iface *iface);
-extern void connman_iface_indicate_carrier_on(struct connman_iface *iface);
-extern void connman_iface_indicate_carrier_off(struct connman_iface *iface);
-extern void connman_iface_indicate_configured(struct connman_iface *iface);
-
-extern void connman_iface_indicate_station(struct connman_iface *iface,
-				const char *name, int strength, int security);
-
-extern int connman_iface_get_ipv4(struct connman_iface *iface,
-						struct connman_ipv4 *ipv4);
-extern int connman_iface_set_ipv4(struct connman_iface *iface,
-						struct connman_ipv4 *ipv4);
-extern int connman_iface_clear_ipv4(struct connman_iface *iface);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CONNMAN_IFACE_H */

commit b149b69096a0efd9889ade2faef3c6ad83d73814
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 11 17:17:37 2008 +0100

    Remove deprecated interface implementation

diff --git a/src/iface.c b/src/iface.c
deleted file mode 100644
index e5b88fa7..00000000
--- a/src/iface.c
+++ /dev/null
@@ -1,1522 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <net/if.h>
-#include <net/route.h>
-
-#include <linux/netlink.h>
-#include <linux/rtnetlink.h>
-
-#include <glib.h>
-#include <gdbus.h>
-
-#include <hal/libhal.h>
-
-#include "connman.h"
-
-static DBusConnection *connection = NULL;
-
-static gchar *ifname_filter = NULL;
-
-static GSList *drivers = NULL;
-
-int connman_iface_register(struct connman_iface_driver *driver)
-{
-	DBG("driver %p", driver);
-
-	drivers = g_slist_append(drivers, driver);
-
-	return 0;
-}
-
-void connman_iface_unregister(struct connman_iface_driver *driver)
-{
-	DBG("driver %p", driver);
-
-	drivers = g_slist_remove(drivers, driver);
-}
-
-static GSList *interfaces = NULL;
-
-struct connman_iface *__connman_iface_find(int index)
-{
-	GSList *list;
-
-	for (list = interfaces; list; list = list->next) {
-		struct connman_iface *iface = list->data;
-
-		if (iface->index == index)
-			return iface;
-	}
-
-	return NULL;
-}
-
-void __connman_iface_list(DBusMessageIter *iter)
-{
-	GSList *list;
-
-	DBG("");
-
-	for (list = interfaces; list; list = list->next) {
-		struct connman_iface *iface = list->data;
-
-		dbus_message_iter_append_basic(iter,
-				DBUS_TYPE_OBJECT_PATH, &iface->path);
-	}
-}
-
-gboolean __connman_iface_is_connected(void)
-{
-	GSList *list;
-	gboolean connected = FALSE;
-
-	DBG("");
-
-	for (list = interfaces; list; list = list->next) {
-		struct connman_iface *iface = list->data;
-
-		if (iface->state == CONNMAN_IFACE_STATE_READY) {
-			connected = TRUE;
-			break;
-		}
-	}
-
-	return connected;
-}
-
-static void append_entry(DBusMessageIter *dict,
-				const char *key, int type, void *val)
-{
-	DBusMessageIter entry, value;
-	const char *signature;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	switch (type) {
-	case DBUS_TYPE_STRING:
-		signature = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT16:
-		signature = DBUS_TYPE_UINT16_AS_STRING;
-		break;
-	default:
-		signature = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							signature, &value);
-	dbus_message_iter_append_basic(&value, type, val);
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
-static gboolean scan_timeout(gpointer user_data)
-{
-	struct connman_iface *iface = user_data;
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_SCANNING:
-		if (iface->driver->scan)
-			iface->driver->scan(iface);
-		return TRUE;
-	default:
-		break;
-	}
-
-	return FALSE;
-}
-
-static void state_changed(struct connman_iface *iface)
-{
-	const char *str = __connman_iface_state2string(iface->state);
-	enum connman_iface_state state = iface->state;
-
-	DBG("iface %p state %s", iface, str);
-
-	g_dbus_emit_signal(connection, iface->path,
-				CONNMAN_IFACE_INTERFACE, "StateChanged",
-				DBUS_TYPE_STRING, &str, DBUS_TYPE_INVALID);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_OFF:
-		__connman_iface_stop(iface);
-		break;
-
-	case CONNMAN_IFACE_STATE_ENABLED:
-		__connman_iface_start(iface);
-		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
-			state = CONNMAN_IFACE_STATE_SCANNING;
-		break;
-
-	case CONNMAN_IFACE_STATE_SCANNING:
-		if (iface->driver->scan)
-			iface->driver->scan(iface);
-		g_timeout_add(8000, scan_timeout, iface);
-		break;
-
-	case CONNMAN_IFACE_STATE_CARRIER:
-		if (iface->policy == CONNMAN_IFACE_POLICY_AUTO)
-			state = CONNMAN_IFACE_STATE_CONFIGURE;
-		break;
-
-	case CONNMAN_IFACE_STATE_CONFIGURE:
-		__connman_dhcp_request(iface);
-		break;
-
-	case CONNMAN_IFACE_STATE_SHUTDOWN:
-		__connman_iface_stop(iface);
-		if (iface->policy != CONNMAN_IFACE_POLICY_AUTO)
-			state = CONNMAN_IFACE_STATE_OFF;
-		break;
-
-	case CONNMAN_IFACE_STATE_READY:
-		break;
-
-	default:
-		break;
-	}
-
-	if (iface->state != state) {
-		iface->state = state;
-		state_changed(iface);
-	}
-}
-
-static void switch_policy(struct connman_iface *iface)
-{
-	DBG("iface %p policy %d", iface, iface->policy);
-
-	switch (iface->policy) {
-	case CONNMAN_IFACE_POLICY_OFF:
-		__connman_iface_stop(iface);
-		break;
-
-	case CONNMAN_IFACE_POLICY_IGNORE:
-		break;
-
-	case CONNMAN_IFACE_POLICY_AUTO:
-	case CONNMAN_IFACE_POLICY_ASK:
-		__connman_iface_start(iface);
-		break;
-
-	default:
-		break;
-	}
-}
-
-void connman_iface_indicate_ifup(struct connman_iface *iface)
-{
-	DBG("iface %p state %d", iface, iface->state);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_OFF:
-		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-		state_changed(iface);
-		break;
-	default:
-		break;
-	}
-}
-
-void connman_iface_indicate_ifdown(struct connman_iface *iface)
-{
-	DBG("iface %p state %d", iface, iface->state);
-
-	if (iface->policy == CONNMAN_IFACE_POLICY_AUTO)
-		iface->state = CONNMAN_IFACE_STATE_ENABLED;
-	else
-		iface->state = CONNMAN_IFACE_STATE_SHUTDOWN;
-
-	state_changed(iface);
-}
-
-void connman_iface_indicate_connected(struct connman_iface *iface)
-{
-	DBG("iface %p state %d", iface, iface->state);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_CONNECT:
-		iface->state = CONNMAN_IFACE_STATE_CONNECTED;
-		state_changed(iface);
-		break;
-	default:
-		break;
-	}
-}
-
-void connman_iface_indicate_carrier_on(struct connman_iface *iface)
-{
-	DBG("iface %p state %d", iface, iface->state);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_ENABLED:
-	case CONNMAN_IFACE_STATE_CONNECT:
-	case CONNMAN_IFACE_STATE_CONNECTED:
-		iface->state = CONNMAN_IFACE_STATE_CARRIER;
-		state_changed(iface);
-		break;
-	default:
-		break;
-	}
-}
-
-void connman_iface_indicate_carrier_off(struct connman_iface *iface)
-{
-	DBG("iface %p state %d", iface, iface->state);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_CARRIER:
-	case CONNMAN_IFACE_STATE_CONFIGURE:
-	case CONNMAN_IFACE_STATE_READY:
-		__connman_iface_disconnect(iface);
-		if (iface->flags & CONNMAN_IFACE_FLAG_SCANNING)
-			iface->state = CONNMAN_IFACE_STATE_SCANNING;
-		else
-			iface->state = CONNMAN_IFACE_STATE_ENABLED;
-		state_changed(iface);
-		break;
-	default:
-		break;
-	}
-}
-
-void connman_iface_indicate_configured(struct connman_iface *iface)
-{
-	DBG("iface %p state %d", iface, iface->state);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_CONFIGURE:
-		iface->state = CONNMAN_IFACE_STATE_READY;
-		state_changed(iface);
-		__connman_iface_store_current_network(iface);
-		break;
-	default:
-		break;
-	}
-}
-
-static void append_station(DBusMessage *reply, const char *name,
-						int signal, int security)
-{
-	DBusMessageIter array, dict;
-	const char *wpa = "WPA";
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	append_entry(&dict, "ESSID", DBUS_TYPE_STRING, &name);
-	append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
-
-	if (security > 0)
-		append_entry(&dict, "Security", DBUS_TYPE_STRING, &wpa);
-
-	dbus_message_iter_close_container(&array, &dict);
-}
-
-void connman_iface_indicate_station(struct connman_iface *iface,
-				const char *name, int strength, int security)
-{
-	DBusMessage *signal;
-	char *ssid, *passphrase;
-	int len;
-
-	DBG("iface %p security %d name %s", iface, security, name);
-
-	if (name == NULL || strlen(name) == 0)
-		return;
-
-	signal = dbus_message_new_signal(iface->path,
-				CONNMAN_IFACE_INTERFACE, "NetworkFound");
-	if (signal == NULL)
-		return;
-
-	append_station(signal, name, strength, security);
-
-	dbus_connection_send(connection, signal, NULL);
-	dbus_message_unref(signal);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_CONNECT:
-	case CONNMAN_IFACE_STATE_CONNECTED:
-	case CONNMAN_IFACE_STATE_CARRIER:
-	case CONNMAN_IFACE_STATE_CONFIGURE:
-	case CONNMAN_IFACE_STATE_READY:
-		return;
-	default:
-		break;
-	}
-
-	len = strlen(name);
-	ssid = strdup(name);
-	if (ssid == NULL)
-		return;
-
-	/* The D-Link access points return a 0x05 at the end of the SSID */
-	if (ssid[len - 1] == '\05')
-		ssid[len - 1] = '\0';
-
-	passphrase = __connman_iface_find_passphrase(iface, ssid);
-	if (passphrase != NULL) {
-		DBG("network %s passphrase %s", ssid, passphrase);
-
-		g_free(iface->network.identifier);
-		iface->network.identifier = g_strdup(ssid);
-		g_free(iface->network.passphrase);
-		iface->network.passphrase = passphrase;
-
-		__connman_iface_connect(iface, &iface->network);
-
-		iface->state = CONNMAN_IFACE_STATE_CONNECT;
-		state_changed(iface);
-	}
-
-	free(ssid);
-}
-
-int connman_iface_get_ipv4(struct connman_iface *iface,
-						struct connman_ipv4 *ipv4)
-{
-#if 0
-	struct {
-		struct nlmsghdr hdr;
-		struct rtgenmsg msg;
-	} req;
-
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
-		return -1;
-
-	DBG("iface %p ipv4 %p", iface, ipv4);
-
-	memset(&req, 0, sizeof(req));
-	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
-	req.hdr.nlmsg_type = RTM_GETADDR;
-	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
-	req.hdr.nlmsg_pid = 0;
-	req.hdr.nlmsg_seq = 4711;
-	req.msg.rtgen_family = AF_INET;
-
-	__connman_rtnl_send(&req, sizeof(req));
-#endif
-
-	return 0;
-}
-
-int connman_iface_set_ipv4(struct connman_iface *iface,
-						struct connman_ipv4 *ipv4)
-{
-	struct ifreq ifr;
-	struct rtentry rt;
-	struct sockaddr_in *addr;
-	int sk, err;
-
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
-		return -1;
-
-	DBG("iface %p ipv4 %p", iface, ipv4);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		close(sk);
-		return -1;
-	}
-
-	DBG("ifname %s", ifr.ifr_name);
-
-	addr = (struct sockaddr_in *) &ifr.ifr_addr;
-	addr->sin_family = AF_INET;
-	addr->sin_addr = ipv4->address;
-
-	err = ioctl(sk, SIOCSIFADDR, &ifr);
-
-	if (err < 0)
-		DBG("address setting failed (%s)", strerror(errno));
-
-	addr = (struct sockaddr_in *) &ifr.ifr_netmask;
-	addr->sin_family = AF_INET;
-	addr->sin_addr = ipv4->netmask;
-
-	err = ioctl(sk, SIOCSIFNETMASK, &ifr);
-
-	if (err < 0)
-		DBG("netmask setting failed (%s)", strerror(errno));
-
-	addr = (struct sockaddr_in *) &ifr.ifr_broadaddr;
-	addr->sin_family = AF_INET;
-	addr->sin_addr = ipv4->broadcast;
-
-	err = ioctl(sk, SIOCSIFBRDADDR, &ifr);
-
-	if (err < 0)
-		DBG("broadcast setting failed (%s)", strerror(errno));
-
-	memset(&rt, 0, sizeof(rt));
-	rt.rt_flags = RTF_UP | RTF_GATEWAY;
-
-	addr = (struct sockaddr_in *) &rt.rt_dst;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	addr = (struct sockaddr_in *) &rt.rt_gateway;
-	addr->sin_family = AF_INET;
-	addr->sin_addr = ipv4->gateway;
-
-	addr = (struct sockaddr_in *) &rt.rt_genmask;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	err = ioctl(sk, SIOCADDRT, &rt);
-
-	close(sk);
-
-	if (err < 0) {
-		DBG("default route failed (%s)", strerror(errno));
-		return -1;
-	}
-
-	__connman_resolver_append(iface, inet_ntoa(ipv4->nameserver));
-
-	return 0;
-}
-
-int connman_iface_clear_ipv4(struct connman_iface *iface)
-{
-	struct ifreq ifr;
-	struct sockaddr_in *addr;
-	int sk, err;
-
-	if ((iface->flags & CONNMAN_IFACE_FLAG_RTNL) == 0)
-		return -1;
-
-	DBG("iface %p", iface);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = iface->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		close(sk);
-		return -1;
-	}
-
-	DBG("ifname %s", ifr.ifr_name);
-
-	addr = (struct sockaddr_in *) &ifr.ifr_addr;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	//err = ioctl(sk, SIOCDIFADDR, &ifr);
-	err = ioctl(sk, SIOCSIFADDR, &ifr);
-
-	close(sk);
-
-	if (err < 0 && errno != EADDRNOTAVAIL) {
-		DBG("address removal failed (%s)", strerror(errno));
-		return -1;
-	}
-
-	__connman_resolver_remove(iface);
-
-	return 0;
-}
-
-static DBusMessage *scan_iface(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	struct connman_iface_driver *driver = iface->driver;
-	DBusMessage *reply;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	switch (iface->state) {
-	case CONNMAN_IFACE_STATE_CONNECT:
-	case CONNMAN_IFACE_STATE_CONFIGURE:
-			return reply;
-	default:
-		break;
-	}
-
-	if (driver->scan)
-		driver->scan(iface);
-
-	return reply;
-}
-
-static DBusMessage *get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	const char *str;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	str = __connman_iface_type2string(iface->type);
-	append_entry(&dict, "Type", DBUS_TYPE_STRING, &str);
-
-	str = __connman_iface_state2string(iface->state);
-	append_entry(&dict, "State", DBUS_TYPE_STRING, &str);
-
-	if (iface->type == CONNMAN_IFACE_TYPE_80211) {
-		dbus_uint16_t signal = 75;
-		append_entry(&dict, "Signal", DBUS_TYPE_UINT16, &signal);
-	}
-
-	str = __connman_iface_policy2string(iface->policy);
-	append_entry(&dict, "Policy", DBUS_TYPE_STRING, &str);
-
-	if (iface->device.driver != NULL)
-		append_entry(&dict, "Driver",
-				DBUS_TYPE_STRING, &iface->device.driver);
-
-	if (iface->device.vendor != NULL)
-		append_entry(&dict, "Vendor",
-				DBUS_TYPE_STRING, &iface->device.vendor);
-
-	if (iface->device.product != NULL)
-		append_entry(&dict, "Product",
-				DBUS_TYPE_STRING, &iface->device.product);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
-static DBusMessage *get_state(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	const char *state;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	state = __connman_iface_state2string(iface->state);
-
-	dbus_message_append_args(reply, DBUS_TYPE_STRING, &state,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *get_signal(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	dbus_uint16_t signal;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	if (iface->type == CONNMAN_IFACE_TYPE_80211)
-		signal = 75;
-	else
-		signal = 0;
-
-	dbus_message_append_args(reply, DBUS_TYPE_UINT16, &signal,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *get_policy(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	const char *policy;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	policy = __connman_iface_policy2string(iface->policy);
-
-	dbus_message_append_args(reply, DBUS_TYPE_STRING, &policy,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *set_policy(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	enum connman_iface_policy new_policy;
-	const char *policy;
-
-	DBG("conn %p", conn);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &policy,
-							DBUS_TYPE_INVALID);
-
-	new_policy = __connman_iface_string2policy(policy);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	if (iface->policy != new_policy) {
-		iface->policy = new_policy;
-		__connman_iface_store(iface);
-
-		switch_policy(iface);
-		policy = __connman_iface_policy2string(new_policy);
-
-		g_dbus_emit_signal(conn, iface->path, CONNMAN_IFACE_INTERFACE,
-				"PolicyChanged", DBUS_TYPE_STRING, &policy,
-							DBUS_TYPE_INVALID);
-	}
-
-	return reply;
-}
-
-static void append_network(DBusMessage *reply,
-				struct connman_iface *iface, gboolean secrets)
-{
-	DBusMessageIter array, dict;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	switch (iface->type) {
-	case CONNMAN_IFACE_TYPE_80211:
-		if (iface->network.identifier != NULL)
-			append_entry(&dict, "ESSID",
-				DBUS_TYPE_STRING, &iface->network.identifier);
-		if (secrets == TRUE && iface->network.passphrase != NULL)
-			append_entry(&dict, "PSK",
-				DBUS_TYPE_STRING, &iface->network.passphrase);
-		break;
-	default:
-		break;
-	}
-
-	dbus_message_iter_close_container(&array, &dict);
-}
-
-static DBusMessage *get_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	append_network(reply, iface, TRUE);
-
-	return reply;
-}
-
-static DBusMessage *set_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply, *signal;
-	DBusMessageIter array, dict;
-	gboolean changed = FALSE;
-
-	DBG("conn %p", conn);
-
-	dbus_message_iter_init(msg, &array);
-
-	dbus_message_iter_recurse(&array, &dict);
-
-	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key, *val;
-
-		dbus_message_iter_recurse(&dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-
-		dbus_message_iter_recurse(&entry, &value);
-
-		//type = dbus_message_iter_get_arg_type(&value);
-		dbus_message_iter_get_basic(&value, &val);
-
-		if (g_strcasecmp(key, "ESSID") == 0) {
-			g_free(iface->network.identifier);
-			iface->network.identifier = g_strdup(val);
-			changed = TRUE;
-		}
-
-		if (g_strcasecmp(key, "PSK") == 0) {
-			g_free(iface->network.passphrase);
-			iface->network.passphrase = g_strdup(val);
-			changed = TRUE;
-		}
-
-		dbus_message_iter_next(&dict);
-	}
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	if (changed == TRUE) {
-		__connman_iface_store(iface);
-
-		signal = dbus_message_new_signal(iface->path,
-				CONNMAN_IFACE_INTERFACE, "NetworkChanged");
-		if (signal != NULL) {
-			append_network(signal, iface, FALSE);
-			dbus_connection_send(conn, signal, NULL);
-			dbus_message_unref(signal);
-		}
-
-		__connman_iface_connect(iface, &iface->network);
-	}
-
-	return reply;
-}
-
-static DBusMessage *list_networks(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	DBusMessageIter array, iter;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
-	__connman_iface_network_list(iface, &iter);
-
-	dbus_message_iter_close_container(&array, &iter);
-
-	return reply;
-}
-
-static DBusMessage *create_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	const char *path, *identifier = NULL, *passphrase = NULL;
-
-	DBG("conn %p", conn);
-
-	dbus_message_iter_init(msg, &array);
-
-	dbus_message_iter_recurse(&array, &dict);
-
-	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key, *val;
-
-		dbus_message_iter_recurse(&dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-
-		dbus_message_iter_recurse(&entry, &value);
-
-		//type = dbus_message_iter_get_arg_type(&value);
-		dbus_message_iter_get_basic(&value, &val);
-
-		if (g_strcasecmp(key, "Identifier") == 0)
-			identifier = val;
-
-		if (g_strcasecmp(key, "Passphrase") == 0)
-			passphrase = val;
-
-		dbus_message_iter_next(&dict);
-	}
-
-	DBG("identifier %s passphrase %s", identifier, passphrase);
-
-	path = __connman_iface_add_network(iface, identifier, passphrase);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_OBJECT_PATH, &path,
-							DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *remove_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-	const char *path;
-
-	DBG("conn %p", conn);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
-							DBUS_TYPE_INVALID);
-
-	__connman_iface_remove_network(iface, path);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static DBusMessage *select_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	struct connman_network *network;
-	DBusMessage *reply;
-	const char *path;
-
-	DBG("conn %p", conn);
-
-	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
-							DBUS_TYPE_INVALID);
-
-	network = __connman_iface_find_network(iface, path);
-	if (network == NULL)
-		goto done;
-
-	g_free(iface->network.identifier);
-	iface->network.identifier = g_strdup(network->identifier);
-	g_free(iface->network.passphrase);
-	iface->network.passphrase = g_strdup(network->passphrase);
-
-	__connman_iface_connect(iface, &iface->network);
-
-done:
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	return reply;
-}
-
-static void append_ipv4(DBusMessage *reply, struct connman_iface *iface)
-{
-	DBusMessageIter array, dict;
-	const char *str;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	str = __connman_ipv4_method2string(CONNMAN_IPV4_METHOD_DHCP);
-	append_entry(&dict, "Method", DBUS_TYPE_STRING, &str);
-
-	if (iface->ipv4.address.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.address);
-		append_entry(&dict, "Address", DBUS_TYPE_STRING, &str);
-	}
-
-	if (iface->ipv4.netmask.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.netmask);
-		append_entry(&dict, "Netmask", DBUS_TYPE_STRING, &str);
-	}
-
-	if (iface->ipv4.gateway.s_addr != INADDR_ANY) {
-		str = inet_ntoa(iface->ipv4.gateway);
-		append_entry(&dict, "Gateway", DBUS_TYPE_STRING, &str);
-	}
-
-	dbus_message_iter_close_container(&array, &dict);
-}
-
-static DBusMessage *get_ipv4(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply;
-
-	DBG("conn %p", conn);
-
-	switch (iface->policy) {
-	case CONNMAN_IFACE_POLICY_OFF:
-	case CONNMAN_IFACE_POLICY_IGNORE:
-		return dbus_message_new_error(msg, CONNMAN_ERROR_INTERFACE
-						".NotAvailable", "");
-	default:
-		break;
-	}
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	append_ipv4(reply, iface);
-
-	return reply;
-}
-
-static DBusMessage *set_ipv4(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_iface *iface = data;
-	DBusMessage *reply, *signal;
-	DBusMessageIter array, dict;
-	gboolean changed = FALSE;
-
-	DBG("conn %p", conn);
-
-	return dbus_message_new_error(msg, CONNMAN_ERROR_INTERFACE
-						".NotImplemented", "");
-
-	dbus_message_iter_init(msg, &array);
-
-	dbus_message_iter_recurse(&array, &dict);
-
-	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key, *val;
-		enum connman_ipv4_method method;
-		in_addr_t addr;
-
-		dbus_message_iter_recurse(&dict, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-
-		dbus_message_iter_recurse(&entry, &value);
-
-		//type = dbus_message_iter_get_arg_type(&value);
-		dbus_message_iter_get_basic(&value, &val);
-
-		if (g_strcasecmp(key, "Method") == 0) {
-			method = __connman_ipv4_string2method(val);
-			if (iface->ipv4.method != method) {
-				iface->ipv4.method = method;
-				changed = TRUE;
-			}
-		}
-
-		if (g_strcasecmp(key, "Address") == 0) {
-			addr = inet_addr(val);
-			if (iface->ipv4.address.s_addr != addr) {
-				iface->ipv4.address.s_addr = addr;
-				changed = TRUE;
-			}
-		}
-
-		if (g_strcasecmp(key, "Netmask") == 0) {
-			addr = inet_addr(val);
-			if (iface->ipv4.netmask.s_addr != addr) {
-				iface->ipv4.netmask.s_addr = addr;
-				changed = TRUE;
-			}
-		}
-
-		if (g_strcasecmp(key, "Gateway") == 0) {
-			addr = inet_addr(val);
-			if (iface->ipv4.gateway.s_addr != addr) {
-				iface->ipv4.gateway.s_addr = addr;
-				changed = TRUE;
-			}
-		}
-
-		dbus_message_iter_next(&dict);
-	}
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_append_args(reply, DBUS_TYPE_INVALID);
-
-	if (changed == TRUE) {
-		__connman_iface_store(iface);
-
-		signal = dbus_message_new_signal(iface->path,
-				CONNMAN_IFACE_INTERFACE, "IPv4Changed");
-		if (signal != NULL) {
-			append_ipv4(signal, iface);
-			dbus_connection_send(conn, signal, NULL);
-			dbus_message_unref(signal);
-		}
-	}
-
-	return reply;
-}
-
-static GDBusMethodTable iface_methods[] = {
-	{ "Scan",          "",      "",      scan_iface     },
-	{ "GetProperties", "",      "a{sv}", get_properties },
-	{ "GetState",      "",      "s",     get_state      },
-	{ "GetSignal",     "",      "q",     get_signal     },
-	{ "GetPolicy",     "",      "s",     get_policy     },
-	{ "SetPolicy",     "s",     "",      set_policy     },
-	{ "GetNetwork",    "",      "a{sv}", get_network    },
-	{ "SetNetwork",    "a{sv}", "",      set_network    },
-	{ "ListNetworks",  "",      "ao",    list_networks  },
-	{ "CreateNetwork", "a{av}", "o",     create_network },
-	{ "RemoveNetwork", "o",     "",      remove_network },
-	{ "SelectNetwork", "o",     "",      select_network },
-	{ "GetIPv4",       "",      "a{sv}", get_ipv4       },
-	{ "SetIPv4",       "a{sv}", "",      set_ipv4       },
-	{ },
-};
-
-static GDBusSignalTable iface_signals[] = {
-	{ "StateChanged",   "s"     },
-	{ "SignalChanged",  "q"     },
-	{ "PolicyChanged",  "s"     },
-	{ "NetworkFound",   "a{sv}" },
-	{ "NetworkChanged", "a{sv}" },
-	{ "IPv4Changed",    "a{sv}" },
-	{ },
-};
-
-static void device_free(void *data)
-{
-	struct connman_iface *iface = data;
-
-	DBG("iface %p", iface);
-
-	connman_iface_clear_ipv4(iface);
-
-	if (iface->driver && iface->driver->remove)
-		iface->driver->remove(iface);
-
-	g_free(iface->path);
-	g_free(iface->udi);
-	g_free(iface->sysfs);
-	g_free(iface->identifier);
-	g_free(iface->network.identifier);
-	g_free(iface->network.passphrase);
-	g_free(iface->device.driver);
-	g_free(iface->device.vendor);
-	g_free(iface->device.product);
-	g_free(iface);
-}
-
-static void detect_device_info(LibHalContext *ctx, struct connman_iface *iface)
-{
-	char *parent, *subsys, *value;
-
-	parent = libhal_device_get_property_string(ctx, iface->udi,
-						"info.parent", NULL);
-
-	subsys = libhal_device_get_property_string(ctx, iface->udi,
-						"linux.subsystem", NULL);
-
-	value = libhal_device_get_property_string(ctx, iface->udi,
-						"info.linux.driver", NULL);
-	if (value == NULL) {
-		value = libhal_device_get_property_string(ctx, parent,
-						"info.linux.driver", NULL);
-		if (value != NULL)
-			iface->device.driver = g_strdup(value);
-	}
-
-	if (strcmp(subsys, "net") == 0) {
-		value = libhal_device_get_property_string(ctx, parent,
-							"info.vendor", NULL);
-		if (value != NULL)
-			iface->device.vendor = g_strdup(value);
-
-		value = libhal_device_get_property_string(ctx, parent,
-							"info.product", NULL);
-		if (value != NULL)
-			iface->device.product = g_strdup(value);
-	}
-}
-
-static int probe_device(LibHalContext *ctx,
-			struct connman_iface_driver *driver, const char *udi)
-{
-	DBusConnection *conn;
-	struct connman_iface *iface;
-	char *temp, *sysfs, *ifname;
-	int err;
-
-	DBG("ctx %p driver %p udi %s", ctx, driver, udi);
-
-	if (!driver->probe)
-		return -1;
-
-	iface = g_try_new0(struct connman_iface, 1);
-	if (iface == NULL)
-		return -1;
-
-	temp = g_path_get_basename(udi);
-	iface->path = g_strdup_printf("%s/%s", CONNMAN_IFACE_BASEPATH, temp);
-	g_free(temp);
-
-	iface->udi = g_strdup(udi);
-
-	DBG("iface %p path %s", iface, iface->path);
-
-	sysfs = libhal_device_get_property_string(ctx, udi,
-						"linux.sysfs_path", NULL);
-	if (sysfs != NULL)
-		iface->sysfs = g_strdup(sysfs);
-
-	detect_device_info(ctx, iface);
-
-	iface->index = -1;
-
-	if (g_str_has_prefix(driver->capability, "net") == TRUE) {
-		iface->index = libhal_device_get_property_int(ctx, udi,
-						"net.linux.ifindex", NULL);
-
-		ifname = libhal_device_get_property_string(ctx, udi,
-						"net.interface", NULL);
-		if (ifname != NULL && ifname_filter != NULL &&
-				g_str_equal(ifname, ifname_filter) == FALSE) {
-			device_free(iface);
-			return -1;
-		}
-	}
-
-	iface->type = CONNMAN_IFACE_TYPE_UNKNOWN;
-	iface->flags = 0;
-	iface->state = CONNMAN_IFACE_STATE_UNKNOWN;
-	iface->policy = CONNMAN_IFACE_POLICY_UNKNOWN;
-
-	err = driver->probe(iface);
-	if (err < 0) {
-		device_free(iface);
-		return -1;
-	}
-
-	__connman_iface_create_identifier(iface);
-
-	__connman_iface_init_via_inet(iface);
-
-	iface->driver = driver;
-
-	iface->policy = CONNMAN_IFACE_POLICY_AUTO;
-
-	__connman_iface_load(iface);
-
-	DBG("iface %p network %s secret %s", iface,
-					iface->network.identifier,
-					iface->network.passphrase);
-
-	conn = libhal_ctx_get_dbus_connection(ctx);
-
-	interfaces = g_slist_append(interfaces, iface);
-
-	if (iface->flags & CONNMAN_IFACE_FLAG_IPV4) {
-		connman_iface_get_ipv4(iface, &iface->ipv4);
-
-		DBG("address %s", inet_ntoa(iface->ipv4.address));
-	}
-
-	g_dbus_register_interface(conn, iface->path,
-					CONNMAN_IFACE_INTERFACE,
-					iface_methods, iface_signals, NULL,
-							iface, device_free);
-
-	DBG("iface %p identifier %s", iface, iface->identifier);
-
-	g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
-					CONNMAN_MANAGER_INTERFACE,
-					"InterfaceAdded",
-					DBUS_TYPE_OBJECT_PATH, &iface->path,
-					DBUS_TYPE_INVALID);
-
-	__connman_iface_load_networks(iface);
-
-	switch_policy(iface);
-
-	state_changed(iface);
-
-	return 0;
-}
-
-static void device_added(LibHalContext *ctx, const char *udi)
-{
-	GSList *list;
-
-	DBG("ctx %p udi %s", ctx, udi);
-
-	for (list = drivers; list; list = list->next) {
-		struct connman_iface_driver *driver = list->data;
-
-		if (driver->capability == NULL)
-			continue;
-
-		if (libhal_device_query_capability(ctx, udi,
-					driver->capability, NULL) == TRUE) {
-			if (probe_device(ctx, driver, udi) == 0)
-				break;
-		}
-	}
-}
-
-static void device_removed(LibHalContext *ctx, const char *udi)
-{
-	DBusConnection *conn;
-	GSList *list;
-
-	DBG("ctx %p udi %s", ctx, udi);
-
-	conn = libhal_ctx_get_dbus_connection(ctx);
-
-	for (list = interfaces; list; list = list->next) {
-		struct connman_iface *iface = list->data;
-
-		if (strcmp(udi, iface->udi) == 0) {
-			g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
-					CONNMAN_MANAGER_INTERFACE,
-					"InterfaceRemoved",
-					DBUS_TYPE_OBJECT_PATH, &iface->path,
-					DBUS_TYPE_INVALID);
-			interfaces = g_slist_remove(interfaces, iface);
-			g_dbus_unregister_interface(conn, iface->path,
-						CONNMAN_IFACE_INTERFACE);
-			break;
-		}
-	}
-}
-
-static void probe_driver(LibHalContext *ctx,
-				struct connman_iface_driver *driver)
-{
-	char **list;
-	int num;
-
-	DBG("ctx %p driver %p", ctx, driver);
-
-	list = libhal_find_device_by_capability(ctx,
-					driver->capability, &num, NULL);
-	if (list) {
-		char **tmp = list;
-
-		while (*tmp) {
-			probe_device(ctx, driver, *tmp);
-			tmp++;
-		}
-
-		libhal_free_string_array(list);
-	}
-}
-
-static void find_devices(LibHalContext *ctx)
-{
-	GSList *list;
-
-	DBG("ctx %p", ctx);
-
-	for (list = drivers; list; list = list->next) {
-		struct connman_iface_driver *driver = list->data;
-
-		DBG("driver %p", driver);
-
-		if (driver->capability == NULL)
-			continue;
-
-		probe_driver(ctx, driver);
-	}
-}
-
-static LibHalContext *hal_ctx = NULL;
-
-static void hal_init(void *data)
-{
-	DBusConnection *conn = data;
-
-	DBG("conn %p", conn);
-
-	if (hal_ctx != NULL)
-		return;
-
-	hal_ctx = libhal_ctx_new();
-	if (hal_ctx == NULL)
-		return;
-
-	if (libhal_ctx_set_dbus_connection(hal_ctx, conn) == FALSE) {
-		libhal_ctx_free(hal_ctx);
-		return;
-	}
-
-	if (libhal_ctx_init(hal_ctx, NULL) == FALSE) {
-		libhal_ctx_free(hal_ctx);
-		return ;
-	}
-
-	libhal_ctx_set_device_added(hal_ctx, device_added);
-	libhal_ctx_set_device_removed(hal_ctx, device_removed);
-
-	//libhal_ctx_set_device_new_capability(hal_ctx, new_capability);
-	//libhal_ctx_set_device_lost_capability(hal_ctx, lost_capability);
-
-	find_devices(hal_ctx);
-}
-
-static void hal_cleanup(void *data)
-{
-	DBusConnection *conn = data;
-	GSList *list;
-
-	DBG("conn %p", conn);
-
-	if (hal_ctx == NULL)
-		return;
-
-	for (list = interfaces; list; list = list->next) {
-		struct connman_iface *iface = list->data;
-
-		DBG("path %s", iface->path);
-
-		g_dbus_emit_signal(conn, CONNMAN_MANAGER_PATH,
-					CONNMAN_MANAGER_INTERFACE,
-					"InterfaceRemoved",
-					DBUS_TYPE_OBJECT_PATH, &iface->path,
-					DBUS_TYPE_INVALID);
-
-		g_dbus_unregister_interface(conn, iface->path,
-						CONNMAN_IFACE_INTERFACE);
-	}
-
-	g_slist_free(interfaces);
-
-	interfaces = NULL;
-
-	libhal_ctx_shutdown(hal_ctx, NULL);
-
-	libhal_ctx_free(hal_ctx);
-
-	hal_ctx = NULL;
-}
-
-static guint hal_watch = 0;
-
-int __connman_iface_init(DBusConnection *conn, const char *interface)
-{
-	DBG("conn %p", conn);
-
-	connection = dbus_connection_ref(conn);
-	if (connection == NULL)
-		return -1;
-
-	if (interface != NULL)
-		ifname_filter = g_strdup(interface);
-
-	hal_init(connection);
-
-	hal_watch = g_dbus_add_service_watch(connection, "org.freedesktop.Hal",
-				hal_init, hal_cleanup, connection, NULL);
-
-	return 0;
-}
-
-void __connman_iface_cleanup(void)
-{
-	DBG("conn %p", connection);
-
-	g_dbus_remove_watch(connection, hal_watch);
-
-	hal_cleanup(connection);
-
-	g_free(ifname_filter);
-
-	dbus_connection_unref(connection);
-}

commit cd320803ef8b6850e097adcd4c074ef416be190a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 00:45:36 2008 +0100

    Remove usage of reader/write lock

diff --git a/src/element.c b/src/element.c
index 16a7d277..93c31df2 100644
--- a/src/element.c
+++ b/src/element.c
@@ -34,11 +34,8 @@
 
 static DBusConnection *connection;
 
-static GStaticRWLock element_lock = G_STATIC_RW_LOCK_INIT;
 static GNode *element_root = NULL;
-
 static GSList *driver_list = NULL;
-
 static gchar *device_filter = NULL;
 
 static struct {
@@ -884,10 +881,8 @@ void __connman_element_list(struct connman_element *element,
 	} else
 		node = element_root;
 
-	g_static_rw_lock_reader_lock(&element_lock);
 	g_node_traverse(node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
 						append_path, &filter);
-	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
 struct count_data {
@@ -930,10 +925,8 @@ int __connman_element_count(struct connman_element *element,
 	} else
 		node = element_root;
 
-	g_static_rw_lock_reader_lock(&element_lock);
 	g_node_traverse(node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
 						count_element, &data);
-	g_static_rw_lock_reader_unlock(&element_lock);
 
 	return data.count;
 }
@@ -1005,13 +998,9 @@ void __connman_driver_rescan(struct connman_driver *driver)
 	if (!driver->probe)
 		return;
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	if (element_root != NULL)
 		g_node_traverse(element_root, G_PRE_ORDER,
 				G_TRAVERSE_ALL, -1, probe_driver, driver);
-
-	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 /**
@@ -1032,8 +1021,6 @@ int connman_driver_register(struct connman_driver *driver)
 	if (!driver->probe)
 		return -EINVAL;
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	driver_list = g_slist_insert_sorted(driver_list, driver,
 							compare_priority);
 
@@ -1041,8 +1028,6 @@ int connman_driver_register(struct connman_driver *driver)
 		g_node_traverse(element_root, G_PRE_ORDER,
 				G_TRAVERSE_ALL, -1, probe_driver, driver);
 
-	g_static_rw_lock_writer_unlock(&element_lock);
-
 	return 0;
 }
 
@@ -1091,15 +1076,11 @@ void connman_driver_unregister(struct connman_driver *driver)
 {
 	DBG("driver %p name %s", driver, driver->name);
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	driver_list = g_slist_remove(driver_list, driver);
 
 	if (element_root != NULL)
 		g_node_traverse(element_root, G_POST_ORDER,
 				G_TRAVERSE_ALL, -1, remove_driver, driver);
-
-	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 /**
@@ -1754,8 +1735,6 @@ static void register_element(gpointer data, gpointer user_data)
 	GSList *list;
 	GNode *node;
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	__connman_element_lock(element);
 
 	if (element->parent) {
@@ -1833,12 +1812,8 @@ static void register_element(gpointer data, gpointer user_data)
 							DBUS_TYPE_INVALID);
 #endif
 
-	g_static_rw_lock_writer_unlock(&element_lock);
-
 	__connman_element_store(element);
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	for (list = driver_list; list; list = list->next) {
 		struct connman_driver *driver = list->data;
 
@@ -1856,8 +1831,6 @@ static void register_element(gpointer data, gpointer user_data)
 			break;
 		}
 	}
-
-	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 /**
@@ -1976,15 +1949,11 @@ void connman_element_unregister(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
 
 	if (node != NULL)
 		g_node_traverse(node, G_POST_ORDER,
 				G_TRAVERSE_ALL, -1, remove_element, NULL);
-
-	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 void connman_element_unregister_children(struct connman_element *element)
@@ -1993,15 +1962,11 @@ void connman_element_unregister_children(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
 
 	if (node != NULL)
 		g_node_traverse(node, G_POST_ORDER,
 				G_TRAVERSE_ALL, -1, remove_element, element);
-
-	g_static_rw_lock_writer_unlock(&element_lock);
 }
 
 static gboolean update_element(GNode *node, gpointer user_data)
@@ -2029,15 +1994,11 @@ void connman_element_update(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	g_static_rw_lock_reader_lock(&element_lock);
-
 	node = g_node_find(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, element);
 
 	if (node != NULL)
 		g_node_traverse(node, G_PRE_ORDER,
 				G_TRAVERSE_ALL, -1, update_element, NULL);
-
-	g_static_rw_lock_reader_unlock(&element_lock);
 }
 
 int connman_element_set_enabled(struct connman_element *element,
@@ -2065,8 +2026,6 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 
 	device_filter = g_strdup(device);
 
-	g_static_rw_lock_writer_lock(&element_lock);
-
 	element = connman_element_create("root");
 
 	element->path = g_strdup("/");
@@ -2076,8 +2035,6 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 
 	element_root = g_node_new(element);
 
-	g_static_rw_lock_writer_unlock(&element_lock);
-
 	__connman_device_init();
 
 	return 0;
@@ -2119,20 +2076,14 @@ void __connman_element_cleanup(void)
 
 	__connman_device_cleanup();
 
-	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_driver, NULL);
-	g_static_rw_lock_writer_unlock(&element_lock);
 
-	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_node, NULL);
-	g_static_rw_lock_writer_unlock(&element_lock);
 
-	g_static_rw_lock_writer_lock(&element_lock);
 	g_node_destroy(element_root);
 	element_root = NULL;
-	g_static_rw_lock_writer_unlock(&element_lock);
 
 	g_free(device_filter);
 
diff --git a/src/resolver.c b/src/resolver.c
index 404bc3dd..929fd2e5 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -25,7 +25,6 @@
 
 #include "connman.h"
 
-static GStaticRWLock resolver_lock = G_STATIC_RW_LOCK_INIT;
 static GSList *resolver_list = NULL;
 
 /**
@@ -40,12 +39,8 @@ int connman_resolver_register(struct connman_resolver *resolver)
 {
 	DBG("resolver %p name %s", resolver, resolver->name);
 
-	g_static_rw_lock_writer_lock(&resolver_lock);
-
 	resolver_list = g_slist_append(resolver_list, resolver);
 
-	g_static_rw_lock_writer_unlock(&resolver_lock);
-
 	return 0;
 }
 
@@ -59,9 +54,5 @@ void connman_resolver_unregister(struct connman_resolver *resolver)
 {
 	DBG("resolver %p name %s", resolver, resolver->name);
 
-	g_static_rw_lock_writer_lock(&resolver_lock);
-
 	resolver_list = g_slist_remove(resolver_list, resolver);
-
-	g_static_rw_lock_writer_unlock(&resolver_lock);
 }
diff --git a/src/rtnl.c b/src/rtnl.c
index 1e66a9af..ece4f165 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -36,7 +36,6 @@
 
 #include "connman.h"
 
-static GStaticRWLock rtnl_lock = G_STATIC_RW_LOCK_INIT;
 static GSList *rtnl_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -59,13 +58,9 @@ int connman_rtnl_register(struct connman_rtnl *rtnl)
 {
 	DBG("rtnl %p name %s", rtnl, rtnl->name);
 
-	g_static_rw_lock_writer_lock(&rtnl_lock);
-
 	rtnl_list = g_slist_insert_sorted(rtnl_list, rtnl,
 							compare_priority);
 
-	g_static_rw_lock_writer_unlock(&rtnl_lock);
-
 	return 0;
 }
 
@@ -79,11 +74,7 @@ void connman_rtnl_unregister(struct connman_rtnl *rtnl)
 {
 	DBG("rtnl %p name %s", rtnl, rtnl->name);
 
-	g_static_rw_lock_writer_lock(&rtnl_lock);
-
 	rtnl_list = g_slist_remove(rtnl_list, rtnl);
-
-	g_static_rw_lock_writer_unlock(&rtnl_lock);
 }
 
 static void process_newlink(unsigned short type, int index,
@@ -93,16 +84,12 @@ static void process_newlink(unsigned short type, int index,
 
 	DBG("index %d", index);
 
-	g_static_rw_lock_reader_lock(&rtnl_lock);
-
 	for (list = rtnl_list; list; list = list->next) {
 		struct connman_rtnl *rtnl = list->data;
 
 		if (rtnl->newlink)
 			rtnl->newlink(type, index, flags, change);
 	}
-
-	g_static_rw_lock_reader_unlock(&rtnl_lock);
 }
 
 static void process_dellink(unsigned short type, int index,
@@ -112,16 +99,12 @@ static void process_dellink(unsigned short type, int index,
 
 	DBG("index %d", index);
 
-	g_static_rw_lock_reader_lock(&rtnl_lock);
-
 	for (list = rtnl_list; list; list = list->next) {
 		struct connman_rtnl *rtnl = list->data;
 
 		if (rtnl->dellink)
 			rtnl->dellink(type, index, flags, change);
 	}
-
-	g_static_rw_lock_reader_unlock(&rtnl_lock);
 }
 
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
diff --git a/src/security.c b/src/security.c
index c7c3ccf1..41d45e40 100644
--- a/src/security.c
+++ b/src/security.c
@@ -25,7 +25,6 @@
 
 #include "connman.h"
 
-static GStaticRWLock security_lock = G_STATIC_RW_LOCK_INIT;
 static GSList *security_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -48,13 +47,9 @@ int connman_security_register(struct connman_security *security)
 {
 	DBG("security %p name %s", security, security->name);
 
-	g_static_rw_lock_writer_lock(&security_lock);
-
 	security_list = g_slist_insert_sorted(security_list, security,
 							compare_priority);
 
-	g_static_rw_lock_writer_unlock(&security_lock);
-
 	return 0;
 }
 
@@ -68,11 +63,7 @@ void connman_security_unregister(struct connman_security *security)
 {
 	DBG("security %p name %s", security, security->name);
 
-	g_static_rw_lock_writer_lock(&security_lock);
-
 	security_list = g_slist_remove(security_list, security);
-
-	g_static_rw_lock_writer_unlock(&security_lock);
 }
 
 int __connman_security_check_privileges(DBusMessage *message)
@@ -85,8 +76,6 @@ int __connman_security_check_privileges(DBusMessage *message)
 
 	sender = dbus_message_get_sender(message);
 
-	g_static_rw_lock_reader_lock(&security_lock);
-
 	for (list = security_list; list; list = list->next) {
 		struct connman_security *security = list->data;
 
@@ -98,7 +87,5 @@ int __connman_security_check_privileges(DBusMessage *message)
 		}
 	}
 
-	g_static_rw_lock_reader_unlock(&security_lock);
-
 	return err;
 }

commit 56483301b45ba75e91e3f67775cef8a2a74d56b2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 01:17:33 2008 +0100

    Call disable callback before remove callback

diff --git a/src/element.c b/src/element.c
index 93c31df2..2d8168d1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1893,6 +1893,8 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		return FALSE;
 
 	if (element->driver) {
+		disable_element(element);
+
 		if (element->driver->remove)
 			element->driver->remove(element);
 
@@ -2047,6 +2049,8 @@ static gboolean free_driver(GNode *node, gpointer data)
 	DBG("element %p name %s", element, element->name);
 
 	if (element->driver) {
+		disable_element(element);
+
 		if (element->driver->remove)
 			element->driver->remove(element);
 

commit 2ab74c251611b6e77a575677d466997d3031a37e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 01:18:04 2008 +0100

    Fix issue with wpa_supplicant disconnecting

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 93312caa..660ea9f4 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -148,6 +148,9 @@ static void state_change(struct connman_element *parent,
 
 	DBG("state %d", state);
 
+	if (data == NULL)
+		return;
+
 	if (data->identifier == NULL)
 		return;
 
@@ -334,6 +337,8 @@ static int wifi_disable(struct connman_element *element)
 
 	connman_element_unregister_children(element);
 
+	__supplicant_stop(element);
+
 	return 0;
 }
 

commit c43d569914a284c3348deeed9b9092e186545d03
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 23:00:52 2008 +0100

    Add missing signal for network changes

diff --git a/src/element.c b/src/element.c
index 2d8168d1..31c4560b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -390,21 +390,18 @@ static DBusMessage *do_disable(DBusConnection *conn,
 }
 
 static void append_networks(struct connman_element *element,
-						DBusMessageIter *dict)
+						DBusMessageIter *entry)
 {
-	DBusMessageIter entry, value, iter;
+	DBusMessageIter value, iter;
 	const char *key = "Networks";
 
 	if (element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIFI &&
 			element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIMAX)
 		return;
 
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
 
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
 		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
 								&value);
 
@@ -415,9 +412,7 @@ static void append_networks(struct connman_element *element,
 
 	dbus_message_iter_close_container(&value, &iter);
 
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
+	dbus_message_iter_close_container(entry, &value);
 }
 
 static DBusMessage *device_get_properties(DBusConnection *conn,
@@ -425,7 +420,7 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 {
 	struct connman_element *element = data;
 	DBusMessage *reply;
-	DBusMessageIter array, dict;
+	DBusMessageIter array, dict, entry;
 	const char *str;
 
 	DBG("conn %p", conn);
@@ -454,8 +449,13 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
+	dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
 	append_networks(element, &dict);
 
+	dbus_message_iter_close_container(&dict, &entry);
+
 	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);
@@ -1654,6 +1654,29 @@ static void emit_devices_signal(DBusConnection *conn)
 	g_dbus_send_message(conn, signal);
 }
 
+static void emit_networks_signal(DBusConnection *conn,
+					struct connman_element *device)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	DBG("conn %p", conn);
+
+	if (device == NULL)
+		return;
+
+	signal = dbus_message_new_signal(device->path,
+				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_networks(device, &entry);
+
+	g_dbus_send_message(conn, signal);
+}
+
 static void append_connections(DBusMessageIter *entry)
 {
 	DBusMessageIter value, iter;
@@ -1790,6 +1813,8 @@ static void register_element(gpointer data, gpointer user_data)
 					NULL, element, NULL) == FALSE)
 			connman_error("Failed to register %s network",
 								element->path);
+		else
+			emit_networks_signal(connection, element->parent);
 	}
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {

commit b44bcd75905003183c1d5d352315b8a0f3f10e34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 23:03:55 2008 +0100

    Send signal when network got removed

diff --git a/src/element.c b/src/element.c
index 31c4560b..1dd9c614 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1948,9 +1948,12 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 						CONNMAN_CONNECTION_INTERFACE);
 	}
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
+	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
+		emit_networks_signal(connection, element->parent);
+
 		g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);
+	}
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
 			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {

commit a1953b25126c327c1bbfeb351b8649c1c1f82c0a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 23:06:02 2008 +0100

    Add script to monitor property changes

diff --git a/test/Makefile.am b/test/Makefile.am
index 1e38effb..e4ea64f7 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -3,6 +3,6 @@ EXTRA_DIST = get-state list-profiles list-connections \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
 		set-passphrase simple-agent show-introspection \
-		test-manager test-compat
+		test-manager test-compat monitor-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/monitor-connman b/test/monitor-connman
new file mode 100755
index 00000000..86c7d42d
--- /dev/null
+++ b/test/monitor-connman
@@ -0,0 +1,23 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.mainloop.glib
+
+def property_changed(name, value, path):
+	print "[%s] %s = %s" % (path, name, str(value))
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+	manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+						"org.moblin.connman.Manager")
+
+	bus.add_signal_receiver(property_changed,
+					signal_name = "PropertyChanged",
+							path_keyword="path")
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()

commit 58a1be7d56108ec65f95f522fbd7c4ee6bff7f86
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 23:12:23 2008 +0100

    Print more detailed information about the signal

diff --git a/test/monitor-connman b/test/monitor-connman
index 86c7d42d..2c4b9bdd 100755
--- a/test/monitor-connman
+++ b/test/monitor-connman
@@ -5,19 +5,20 @@ import gobject
 import dbus
 import dbus.mainloop.glib
 
-def property_changed(name, value, path):
-	print "[%s] %s = %s" % (path, name, str(value))
+def property_changed(name, value, path, interface):
+	iface = interface[interface.rfind(".") + 1:]
+	print "{%s} [%s] %s = %s" % (iface, path, name, str(value))
 
 if __name__ == '__main__':
 	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
 
 	bus = dbus.SystemBus()
-	manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
-						"org.moblin.connman.Manager")
 
 	bus.add_signal_receiver(property_changed,
+					bus_name="org.moblin.connman",
 					signal_name = "PropertyChanged",
-							path_keyword="path")
+						path_keyword="path",
+						interface_keyword="interface")
 
 	mainloop = gobject.MainLoop()
 	mainloop.run()

commit bf25d0317646a4f4a4b0fbd76ff4d0ee00d2378a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 23:30:18 2008 +0100

    Send signals for Powered and Connected changes

diff --git a/src/element.c b/src/element.c
index 1dd9c614..f088b599 100644
--- a/src/element.c
+++ b/src/element.c
@@ -313,6 +313,51 @@ static void set_common_property(struct connman_element *element,
 	__connman_element_unlock(element);
 }
 
+static void emit_enabled_signal(DBusConnection *conn,
+					struct connman_element *element)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *iface, *key;
+
+	DBG("conn %p", conn);
+
+	if (element == NULL)
+		return;
+
+	switch (element->type) {
+	case CONNMAN_ELEMENT_TYPE_DEVICE:
+		iface = CONNMAN_DEVICE_INTERFACE;
+		key = "Powered";
+		break;
+	case CONNMAN_ELEMENT_TYPE_NETWORK:
+		iface = CONNMAN_NETWORK_INTERFACE;
+		key = "Connected";
+		break;
+	default:
+		return;
+	}
+
+	signal = dbus_message_new_signal(element->path,
+						iface, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN,
+							&element->enabled);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(conn, signal);
+}
+
 static DBusMessage *do_update(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -351,6 +396,8 @@ static DBusMessage *do_enable(DBusConnection *conn,
 
 	element->enabled = TRUE;
 
+	emit_enabled_signal(connection, element);
+
 #if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
@@ -379,6 +426,8 @@ static DBusMessage *do_disable(DBusConnection *conn,
 
 	element->enabled = FALSE;
 
+	emit_enabled_signal(connection, element);
+
 #if 0
 	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
 				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
@@ -965,8 +1014,10 @@ static void enable_element(struct connman_element *element)
 		return;
 
 	if (element->driver && element->driver->enable) {
-		if (element->driver->enable(element) == 0)
+		if (element->driver->enable(element) == 0) {
 			element->enabled = TRUE;
+			emit_enabled_signal(connection, element);
+		}
 	}
 }
 
@@ -1040,8 +1091,10 @@ static void disable_element(struct connman_element *element)
 		return;
 
 	if (element->driver && element->driver->disable) {
-		if (element->driver->disable(element) == 0)
+		if (element->driver->disable(element) == 0) {
 			element->enabled = FALSE;
+			emit_enabled_signal(connection, element);
+		}
 	}
 }
 

commit 67a2843d9cdf1c961c98151fcb2224b2fbe3d03f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 12 23:32:21 2008 +0100

    Fix retrieving network list

diff --git a/src/element.c b/src/element.c
index f088b599..2a6caf9e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -501,7 +501,7 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 	dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
 
-	append_networks(element, &dict);
+	append_networks(element, &entry);
 
 	dbus_message_iter_close_container(&dict, &entry);
 

commit 2660c3971164ad79b5c758159cab3d3ab46bbdaf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 00:44:24 2008 +0100

    Add callback to invalidate old results

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 0a23039e..da274a03 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -789,6 +789,9 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 		goto done;
 	}
 
+	if (task->callback && task->callback->clear_results)
+			task->callback->clear_results(task->element);
+
 	for (i = 0; i < num_results; i++)
 		get_network_properties(task, results[i]);
 
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index fa10a69d..48cf89b1 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -53,6 +53,7 @@ struct supplicant_network {
 struct supplicant_callback {
 	void (*state_change) (struct connman_element *element,
 						enum supplicant_state state);
+	void (*clear_results) (struct connman_element *element);
 	void (*scan_result) (struct connman_element *element,
 					struct supplicant_network *network);
 };

commit d6253a89c45aee2e7d6928d3f1ab6ea5d96e6774
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 01:29:52 2008 +0100

    Add detection of no longer available networks

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 660ea9f4..8b83c342 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -41,8 +41,12 @@
 #include "inet.h"
 #include "supplicant.h"
 
+#define CLEANUP_PENDING_TIMEOUT  8	/* in seconds */
+
 struct wifi_data {
-	GSList *list;
+	GSList *current;
+	GSList *pending;
+	guint timer;
 	gchar *identifier;
 	gboolean connected;
 };
@@ -124,12 +128,28 @@ static struct connman_driver network_driver = {
 	.disable	= network_disable,
 };
 
-static struct connman_element *find_element(struct wifi_data *data,
-						const char *identifier)
+static struct connman_element *find_current_element(struct wifi_data *data,
+							const char *identifier)
+{
+	GSList *list;
+
+	for (list = data->current; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		if (connman_element_match_static_property(element,
+					"Name", &identifier) == TRUE)
+			return element;
+	}
+
+	return NULL;
+}
+
+static struct connman_element *find_pending_element(struct wifi_data *data,
+							const char *identifier)
 {
 	GSList *list;
 
-	for (list = data->list; list; list = list->next) {
+	for (list = data->pending; list; list = list->next) {
 		struct connman_element *element = list->data;
 
 		if (connman_element_match_static_property(element,
@@ -154,7 +174,7 @@ static void state_change(struct connman_element *parent,
 	if (data->identifier == NULL)
 		return;
 
-	element = find_element(data, data->identifier);
+	element = find_current_element(data, data->identifier);
 	if (element == NULL)
 		return;
 
@@ -173,6 +193,46 @@ static void state_change(struct connman_element *parent,
 		data->connected = FALSE;
 }
 
+static gboolean cleanup_pending(gpointer user_data)
+{
+	struct wifi_data *data = user_data;
+	GSList *list;
+
+	DBG("");
+
+	for (list = data->pending; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		DBG("element %p name %s", element, element->name);
+
+		connman_element_unregister(element);
+		connman_element_unref(element);
+	}
+
+	g_slist_free(data->pending);
+	data->pending = NULL;
+
+	data->timer = 0;
+
+	return FALSE;
+}
+
+static void clear_results(struct connman_element *parent)
+{
+	struct wifi_data *data = connman_element_get_data(parent);
+	GSList *list;
+
+	DBG("pending %d", g_slist_length(data->pending));
+	DBG("current %d", g_slist_length(data->current));
+
+	data->pending = data->current;
+	data->current = NULL;
+
+	if (data->timer == 0)
+		data->timer = g_timeout_add_seconds(CLEANUP_PENDING_TIMEOUT,
+							cleanup_pending, data);
+}
+
 static void scan_result(struct connman_element *parent,
 					struct supplicant_network *network)
 {
@@ -208,7 +268,7 @@ static void scan_result(struct connman_element *parent,
 		temp[i] = g_ascii_tolower(temp[i]);
 	}
 
-	element = find_element(data, network->identifier);
+	element = find_pending_element(data, network->identifier);
 	if (element == NULL) {
 		guint8 strength;
 
@@ -217,8 +277,6 @@ static void scan_result(struct connman_element *parent,
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
 		element->index = parent->index;
 
-		data->list = g_slist_append(data->list, element);
-
 		connman_element_add_static_property(element, "Name",
 				DBUS_TYPE_STRING, &network->identifier);
 
@@ -252,7 +310,10 @@ static void scan_result(struct connman_element *parent,
 					element->wifi.security, strength);
 
 		connman_element_register(element, parent);
-	}
+	} else
+		data->pending = g_slist_remove(data->pending, element);
+
+	data->current = g_slist_append(data->current, element);
 
 	element->available = TRUE;
 
@@ -261,6 +322,7 @@ static void scan_result(struct connman_element *parent,
 
 static struct supplicant_callback wifi_callback = {
 	.state_change	= state_change,
+	.clear_results	= clear_results,
 	.scan_result	= scan_result,
 };
 
@@ -324,16 +386,30 @@ static int wifi_disable(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	if (data->timer > 0) {
+		g_source_remove(data->timer);
+		data->timer = 0;
+	}
+
 	__supplicant_disconnect(element);
 
-	for (list = data->list; list; list = list->next) {
+	for (list = data->pending; list; list = list->next) {
+		struct connman_element *network = list->data;
+
+		connman_element_unref(network);
+	}
+
+	g_slist_free(data->pending);
+	data->pending = NULL;
+
+	for (list = data->current; list; list = list->next) {
 		struct connman_element *network = list->data;
 
 		connman_element_unref(network);
 	}
 
-	g_slist_free(data->list);
-	data->list = NULL;
+	g_slist_free(data->current);
+	data->current = NULL;
 
 	connman_element_unregister_children(element);
 

commit 69b169f3532ff2502accfbcb840d56ce518f51f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 01:41:47 2008 +0100

    Add some details about the monitor-connman script

diff --git a/HACKING b/HACKING
index 221bfed2..baf7ccd5 100644
--- a/HACKING
+++ b/HACKING
@@ -90,6 +90,30 @@ line switch allows to specify a glob pattern for the interface names.
     # sudo ./src/connmand -n -i wlan*
 
 
+Debugging the D-Bus interface during runtime
+============================================
+
+Running the daemon with debugging information in the foreground is quite
+verbose and sometimes not really helpful. The "monitor-connman" script
+allows to monitor "PropertyChanged" D-Bus signals from various interfaces.
+
+  During start of daemon
+    {Manager} [/] Devices = dbus.Array([dbus.ObjectPath('/dev_00_90_CC ...
+    {Device} [/dev_00_90_CC_xx_xx_xx] Powered = 1
+    {Device} [/dev_00_90_CC_xx_xx_xx] Networks = dbus.Array( ...
+
+  During shutdown of daemon
+    {Device} [/dev_00_90_CC_xx_xx_xx] Networks = dbus.Array( ...
+    {Device} [/dev_00_90_CC_xx_xx_xx] Powered = 0
+    {Manager} [/] Devices = dbus.Array([], ...
+
+Every "PropertyChanged" signal will generate a line of output. Some of them
+can get very complex. The first detail inside "{ ... }" is the interface
+name (without its service name prefix). The second detail inside "[ ... ]"
+is the object path. And after that it is followed by a key and value of
+the property that changed.
+
+
 Generating source code documentation
 ====================================
 

commit 64ed4af748907c3c077d4c5b0755434ec7ac248c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 01:49:40 2008 +0100

    Remove unused variable

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 8b83c342..e463589e 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -220,7 +220,6 @@ static gboolean cleanup_pending(gpointer user_data)
 static void clear_results(struct connman_element *parent)
 {
 	struct wifi_data *data = connman_element_get_data(parent);
-	GSList *list;
 
 	DBG("pending %d", g_slist_length(data->pending));
 	DBG("current %d", g_slist_length(data->current));

commit 78def9a9658469d9b666c53b901a70b3fd3c209e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 01:58:07 2008 +0100

    Fix broken invalid character replacement code

diff --git a/plugins/wifi.c b/plugins/wifi.c
index e463589e..533b035c 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -254,17 +254,10 @@ static void scan_result(struct connman_element *parent,
 	temp = g_strdup(network->identifier);
 
 	for (i = 0; i < strlen(temp); i++) {
-		if (temp[i] == ' ' || temp[i] == '.')
-			temp[i] = '_';
-		else if (temp[i] == '-' || temp[i] == '+')
-			temp[i] = '_';
-		else if (temp[i] == '!' || temp[i] == '?')
-			temp[i] = '_';
-		else if (temp[i] == '(' || temp[i] == ')')
-			temp[i] = '_';
-		else if (g_ascii_isprint(temp[i]) == FALSE)
+		gchar tmp = g_ascii_tolower(temp[i]);
+
+		if (tmp < 'a' || tmp > 'z')
 			temp[i] = '_';
-		temp[i] = g_ascii_tolower(temp[i]);
 	}
 
 	element = find_pending_element(data, network->identifier);

commit ac83f1cd2872ecc88b4276eeda02fce2ebec553c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 02:00:57 2008 +0100

    Fix usage of wrong network name property

diff --git a/test/select-network b/test/select-network
index b5a0259f..e7d1a635 100755
--- a/test/select-network
+++ b/test/select-network
@@ -34,6 +34,6 @@ for path in properties["Devices"]:
 		if (properties["Connected"] == dbus.Boolean(1)):
 			continue
 
-		if (properties["WiFi.Name"] == sys.argv[1]):
+		if (properties["Name"] == sys.argv[1]):
 			print "Connecting %s" % (path)
 			network.Connect()
diff --git a/test/set-passphrase b/test/set-passphrase
index 1c0d0f18..f80d7545 100755
--- a/test/set-passphrase
+++ b/test/set-passphrase
@@ -29,6 +29,6 @@ for path in properties["Devices"]:
 
 		properties = network.GetProperties()
 
-		if (properties["WiFi.Name"] == sys.argv[1]):
+		if (properties["Name"] == sys.argv[1]):
 			print "Setting passphrase for %s" % (path)
 			network.SetProperty("WiFi.Passphrase", sys.argv[2])

commit 4c85f61ab0e0e4a7a641576b8013e720dd7c64a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 02:24:18 2008 +0100

    Remove disabled code fragments of old element interface

diff --git a/include/dbus.h b/include/dbus.h
index 031d821b..9c8a8933 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -31,16 +31,12 @@ extern "C" {
 #define CONNMAN_SERVICE			"org.moblin.connman"
 
 #define CONNMAN_ERROR_INTERFACE		CONNMAN_SERVICE ".Error"
-
 #define CONNMAN_AGENT_INTERFACE		CONNMAN_SERVICE ".Agent"
 
-#define CONNMAN_ELEMENT_INTERFACE	CONNMAN_SERVICE ".Element"
-
-#define CONNMAN_PROFILE_INTERFACE	CONNMAN_SERVICE ".Profile"
-
 #define CONNMAN_MANAGER_INTERFACE	CONNMAN_SERVICE ".Manager"
 #define CONNMAN_MANAGER_PATH		"/"
 
+#define CONNMAN_PROFILE_INTERFACE	CONNMAN_SERVICE ".Profile"
 #define CONNMAN_DEVICE_INTERFACE	CONNMAN_SERVICE ".Device"
 #define CONNMAN_NETWORK_INTERFACE	CONNMAN_SERVICE ".Network"
 #define CONNMAN_CONNECTION_INTERFACE	CONNMAN_SERVICE ".Connection"
diff --git a/src/element.c b/src/element.c
index 2a6caf9e..895ec920 100644
--- a/src/element.c
+++ b/src/element.c
@@ -398,13 +398,6 @@ static DBusMessage *do_enable(DBusConnection *conn,
 
 	emit_enabled_signal(connection, element);
 
-#if 0
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-#endif
-
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -428,13 +421,6 @@ static DBusMessage *do_disable(DBusConnection *conn,
 
 	emit_enabled_signal(connection, element);
 
-#if 0
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-#endif
-
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -731,137 +717,6 @@ static DBusMessage *get_connection_properties(DBusConnection *conn,
 	return reply;
 }
 
-#if 0
-static DBusMessage *get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	const char *str;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	if (element->parent != NULL &&
-			element->parent->type != CONNMAN_ELEMENT_TYPE_ROOT) {
-		connman_dbus_dict_append_variant(&dict, "Parent",
-				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
-	}
-
-	str = type2string(element->type);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Type",
-						DBUS_TYPE_STRING, &str);
-	str = subtype2string(element->subtype);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Subtype",
-						DBUS_TYPE_STRING, &str);
-
-	connman_dbus_dict_append_variant(&dict, "Enabled",
-					DBUS_TYPE_BOOLEAN, &element->enabled);
-
-	add_common_properties(element, &dict);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
-static DBusMessage *set_property(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessageIter iter;
-	DBusMessageIter value;
-	const char *name;
-
-	DBG("conn %p", conn);
-
-	if (dbus_message_iter_init(msg, &iter) == FALSE)
-		return __connman_error_invalid_arguments(msg);
-
-	dbus_message_iter_get_basic(&iter, &name);
-	dbus_message_iter_next(&iter);
-	dbus_message_iter_recurse(&iter, &value);
-
-	if (__connman_security_check_privileges(msg) < 0)
-		return __connman_error_permission_denied(msg);
-
-	set_common_property(element, name, &value);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *clear_property(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	const char *name;
-	GSList *list;
-
-	DBG("conn %p", conn);
-
-	if (dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &name,
-						DBUS_TYPE_INVALID) == FALSE)
-		return __connman_error_invalid_arguments(msg);
-
-	if (__connman_security_check_privileges(msg) < 0)
-		return __connman_error_permission_denied(msg);
-
-	__connman_element_lock(element);
-
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (g_str_equal(property->name, name) == FALSE)
-			continue;
-
-		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
-			continue;
-
-		if (property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)
-			continue;
-
-		property->flags |= CONNMAN_PROPERTY_FLAG_REFERENCE;
-
-		if (property->type == DBUS_TYPE_STRING)
-			g_free(property->value);
-
-		property->value = NULL;
-	}
-
-	__connman_element_unlock(element);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static GDBusMethodTable element_methods[] = {
-	{ "GetProperties", "",   "a{sv}", get_properties },
-	{ "SetProperty",   "sv", "",      set_property   },
-	{ "ClearProperty", "s",  "",      clear_property },
-	{ "Update",        "",   "",      do_update      },
-	{ "Enable",        "",   "",      do_enable      },
-	{ "Disable",       "",   "",      do_disable     },
-	{ },
-};
-#endif
-
-static GDBusSignalTable element_signals[] = {
-	{ "PropertyChanged", "sv" },
-	{ },
-};
-
 static GDBusMethodTable device_methods[] = {
 	{ "GetProperties", "",      "a{sv}", device_get_properties },
 	{ "SetProperty",   "sv",    "",      device_set_property   },
@@ -884,6 +739,11 @@ static GDBusMethodTable connection_methods[] = {
 	{ },
 };
 
+static GDBusSignalTable element_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
 struct append_filter {
 	enum connman_element_type type;
 	DBusMessageIter *iter;
@@ -1502,13 +1362,6 @@ int connman_element_set_property(struct connman_element *element,
 		return -EINVAL;
 	}
 
-#if 0
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-#endif
-
 	return 0;
 }
 
@@ -1839,14 +1692,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_node_append_data(node, element);
 
-#if 0
-	if (g_dbus_register_interface(connection, element->path,
-					CONNMAN_ELEMENT_INTERFACE,
-					element_methods, element_signals,
-					NULL, element, NULL) == FALSE)
-		connman_error("Failed to register %s element", element->path);
-#endif
-
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
 			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
 		if (g_dbus_register_interface(connection, element->path,
@@ -1883,13 +1728,6 @@ static void register_element(gpointer data, gpointer user_data)
 		}
 	}
 
-#if 0
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementAdded",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-#endif
-
 	__connman_element_store(element);
 
 	for (list = driver_list; list; list = list->next) {
@@ -1986,13 +1824,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		g_node_destroy(node);
 	}
 
-#if 0
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementRemoved",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-#endif
-
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
 		emit_state_change(connection, "offline");
 		emit_connections_signal(connection);
@@ -2016,11 +1847,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 						CONNMAN_DEVICE_INTERFACE);
 	}
 
-#if 0
-	g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_ELEMENT_INTERFACE);
-#endif
-
 	connman_element_unref(element);
 
 	return FALSE;
@@ -2061,13 +1887,6 @@ static gboolean update_element(GNode *node, gpointer user_data)
 	if (element->driver && element->driver->update)
 		element->driver->update(element);
 
-#if 0
-	g_dbus_emit_signal(connection, CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "ElementUpdated",
-				DBUS_TYPE_OBJECT_PATH, &element->path,
-							DBUS_TYPE_INVALID);
-#endif
-
 	return FALSE;
 }
 
diff --git a/src/manager.c b/src/manager.c
index 3c22339c..df53feff 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -207,49 +207,15 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 	return reply;
 }
 
-#if 0
-static DBusMessage *list_elements(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	DBusMessage *reply;
-	DBusMessageIter array, iter;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
-	__connman_element_list(CONNMAN_ELEMENT_TYPE_UNKNOWN, &iter);
-
-	dbus_message_iter_close_container(&array, &iter);
-
-	return reply;
-}
-#endif
-
 static GDBusMethodTable manager_methods[] = {
 	{ "GetProperties",   "",  "a{sv}", get_properties   },
 	{ "RegisterAgent",   "o", "",      register_agent   },
 	{ "UnregisterAgent", "o", "",      unregister_agent },
-#if 0
-	{ "ListElements",    "",  "ao",    list_elements    },
-#endif
 	{ },
 };
 
 static GDBusSignalTable manager_signals[] = {
 	{ "PropertyChanged", "sv" },
-#if 0
-	{ "ElementAdded",    "o"  },
-	{ "ElementUpdated",  "o"  },
-	{ "ElementRemoved",  "o"  },
-#endif
 	{ },
 };
 

commit 18a4d325b70492cc696b377321062585de8294f3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 02:29:01 2008 +0100

    Update D-Bus access policy configuration

diff --git a/src/connman.conf b/src/connman.conf
index 8d73de91..55f76d6a 100644
--- a/src/connman.conf
+++ b/src/connman.conf
@@ -4,11 +4,13 @@
     <policy user="root">
         <allow own="org.moblin.connman"/>
         <allow send_destination="org.moblin.connman"/>
+        <allow send_interface="org.moblin.connman.Agent"/>
     </policy>
     <policy at_console="true">
         <allow send_destination="org.moblin.connman"/>
     </policy>
     <policy context="default">
+        <!-- use "allow" with enabled PolicyKit support -->
         <deny send_destination="org.moblin.connman"/>
     </policy>
 </busconfig>

commit b7c6f712f25d665be9d6da257aa676fa2eb35d90
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 03:03:39 2008 +0100

    Release 0.2

diff --git a/ChangeLog b/ChangeLog
index ba270525..38f7d5c3 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,2 +1,11 @@
+ver 0.2:
+	Add support for indicating network changes.
+	Add support for signal strength property.
+	Add support for unique device names.
+	Fix broken device enumeration.
+	Fix issue with device removal callback.
+	Fix issue with wpa_supplicant disconnecting.
+	Fix D-Bus access policy configuration.
+
 ver 0.1:
 	Initial public release.
diff --git a/configure.ac b/configure.ac
index c95bdb33..ffe01fee 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.1)
+AM_INIT_AUTOMAKE(connman, 0.2)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 06c0b8a9158bd5b0aad93dd9100ec0606ea894ac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 15:50:25 2008 +0100

    Add support for inactive and cleanup timers

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 533b035c..3fbed238 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -41,12 +41,14 @@
 #include "inet.h"
 #include "supplicant.h"
 
-#define CLEANUP_PENDING_TIMEOUT  8	/* in seconds */
+#define CLEANUP_TIMEOUT   8	/* in seconds */
+#define INACTIVE_TIMEOUT  12	/* in seconds */
 
 struct wifi_data {
 	GSList *current;
 	GSList *pending;
-	guint timer;
+	guint cleanup_timer;
+	guint inactive_timer;
 	gchar *identifier;
 	gboolean connected;
 };
@@ -160,6 +162,25 @@ static struct connman_element *find_pending_element(struct wifi_data *data,
 	return NULL;
 }
 
+static gboolean inactive_scan(gpointer user_data)
+{
+	struct connman_element *device = user_data;
+	struct wifi_data *data = connman_element_get_data(device);
+
+	DBG("");
+
+	if (data->cleanup_timer > 0) {
+		g_source_remove(data->cleanup_timer);
+		data->cleanup_timer = 0;
+	}
+
+	__supplicant_scan(device);
+
+	data->inactive_timer = 0;
+
+	return FALSE;
+}
+
 static void state_change(struct connman_element *parent,
 						enum supplicant_state state)
 {
@@ -168,6 +189,10 @@ static void state_change(struct connman_element *parent,
 
 	DBG("state %d", state);
 
+	if (state == STATE_INACTIVE && data->inactive_timer == 0)
+		data->inactive_timer = g_timeout_add_seconds(INACTIVE_TIMEOUT,
+							inactive_scan, parent);
+
 	if (data == NULL)
 		return;
 
@@ -212,7 +237,7 @@ static gboolean cleanup_pending(gpointer user_data)
 	g_slist_free(data->pending);
 	data->pending = NULL;
 
-	data->timer = 0;
+	data->cleanup_timer = 0;
 
 	return FALSE;
 }
@@ -227,8 +252,10 @@ static void clear_results(struct connman_element *parent)
 	data->pending = data->current;
 	data->current = NULL;
 
-	if (data->timer == 0)
-		data->timer = g_timeout_add_seconds(CLEANUP_PENDING_TIMEOUT,
+	if (data->cleanup_timer > 0)
+		return;
+
+	data->cleanup_timer = g_timeout_add_seconds(CLEANUP_TIMEOUT,
 							cleanup_pending, data);
 }
 
@@ -378,9 +405,14 @@ static int wifi_disable(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	if (data->timer > 0) {
-		g_source_remove(data->timer);
-		data->timer = 0;
+	if (data->cleanup_timer > 0) {
+		g_source_remove(data->cleanup_timer);
+		data->cleanup_timer = 0;
+	}
+
+	if (data->inactive_timer > 0) {
+		g_source_remove(data->inactive_timer);
+		data->inactive_timer = 0;
 	}
 
 	__supplicant_disconnect(element);

commit 16d4c499a52e8e8116015be66c86e15bb82f96be
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 15:53:37 2008 +0100

    Remove misuse of parent element parameter name

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 3fbed238..ed3a68e1 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -67,6 +67,7 @@ static void network_remove(struct connman_element *element)
 
 static int network_enable(struct connman_element *element)
 {
+	struct connman_element *device = element->parent;
 	char *name, *security = NULL, *passphrase = NULL;
 	unsigned char *ssid;
 	int ssid_len;
@@ -81,13 +82,13 @@ static int network_enable(struct connman_element *element)
 				"WiFi.SSID", &ssid, &ssid_len) == FALSE)
 		return -EIO;
 
-	if (element->parent != NULL) {
-		struct wifi_data *data = connman_element_get_data(element->parent);
-
-		if (data->connected == TRUE)
-			return -EBUSY;
+	if (device != NULL) {
+		struct wifi_data *data = connman_element_get_data(device);
 
 		if (data != NULL) {
+			if (data->connected == TRUE)
+				return -EBUSY;
+
 			g_free(data->identifier);
 			data->identifier = g_strdup(name);
 		}
@@ -181,17 +182,17 @@ static gboolean inactive_scan(gpointer user_data)
 	return FALSE;
 }
 
-static void state_change(struct connman_element *parent,
+static void state_change(struct connman_element *device,
 						enum supplicant_state state)
 {
-	struct wifi_data *data = connman_element_get_data(parent);
+	struct wifi_data *data = connman_element_get_data(device);
 	struct connman_element *element;
 
 	DBG("state %d", state);
 
 	if (state == STATE_INACTIVE && data->inactive_timer == 0)
 		data->inactive_timer = g_timeout_add_seconds(INACTIVE_TIMEOUT,
-							inactive_scan, parent);
+							inactive_scan, device);
 
 	if (data == NULL)
 		return;
@@ -242,9 +243,9 @@ static gboolean cleanup_pending(gpointer user_data)
 	return FALSE;
 }
 
-static void clear_results(struct connman_element *parent)
+static void clear_results(struct connman_element *device)
 {
-	struct wifi_data *data = connman_element_get_data(parent);
+	struct wifi_data *data = connman_element_get_data(device);
 
 	DBG("pending %d", g_slist_length(data->pending));
 	DBG("current %d", g_slist_length(data->current));
@@ -259,10 +260,10 @@ static void clear_results(struct connman_element *parent)
 							cleanup_pending, data);
 }
 
-static void scan_result(struct connman_element *parent,
+static void scan_result(struct connman_element *device,
 					struct supplicant_network *network)
 {
-	struct wifi_data *data = connman_element_get_data(parent);
+	struct wifi_data *data = connman_element_get_data(device);
 	struct connman_element *element;
 	gchar *temp;
 	int i;
@@ -294,7 +295,7 @@ static void scan_result(struct connman_element *parent,
 		element = connman_element_create(temp);
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
-		element->index = parent->index;
+		element->index = device->index;
 
 		connman_element_add_static_property(element, "Name",
 				DBUS_TYPE_STRING, &network->identifier);
@@ -328,7 +329,7 @@ static void scan_result(struct connman_element *parent,
 		DBG("%s (%s) strength %d", network->identifier,
 					element->wifi.security, strength);
 
-		connman_element_register(element, parent);
+		connman_element_register(element, device);
 	} else
 		data->pending = g_slist_remove(data->pending, element);
 

commit 2f09e0d729845dd47373c9c7e70b8aad566ebf14
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 16:01:18 2008 +0100

    Add support for sorting resolvers by priority

diff --git a/include/resolver.h b/include/resolver.h
index 77a95cf0..5c023758 100644
--- a/include/resolver.h
+++ b/include/resolver.h
@@ -32,8 +32,13 @@ extern "C" {
  * @short_description: Functions for registering resolver modules
  */
 
+#define CONNMAN_RESOLVER_PRIORITY_LOW      -100
+#define CONNMAN_RESOLVER_PRIORITY_DEFAULT     0
+#define CONNMAN_RESOLVER_PRIORITY_HIGH      100
+
 struct connman_resolver {
 	const char *name;
+	int priority;
 };
 
 extern int connman_resolver_register(struct connman_resolver *resolver);
diff --git a/src/resolver.c b/src/resolver.c
index 929fd2e5..a8132361 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -27,6 +27,14 @@
 
 static GSList *resolver_list = NULL;
 
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_resolver *resolver1 = a;
+	const struct connman_resolver *resolver2 = b;
+
+	return resolver2->priority - resolver1->priority;
+}
+
 /**
  * connman_resolver_register:
  * @resolver: resolver module
@@ -39,7 +47,8 @@ int connman_resolver_register(struct connman_resolver *resolver)
 {
 	DBG("resolver %p name %s", resolver, resolver->name);
 
-	resolver_list = g_slist_append(resolver_list, resolver);
+	resolver_list = g_slist_insert_sorted(resolver_list, resolver,
+							compare_priority);
 
 	return 0;
 }

commit 1854341db894fd9efc8aa5eabe32b3a101ec605c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:15:04 2008 +0100

    Add small self testing framework

diff --git a/src/Makefile.am b/src/Makefile.am
index c3a811c1..c2553b0b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -11,9 +11,9 @@ DISTCLEANFILES = $(service_DATA)
 
 sbin_PROGRAMS = connmand
 
-connmand_SOURCES = main.c connman.h log.c error.c plugin.c profile.c \
-			element.c device.c network.c security.c resolver.c \
-				storage.c manager.c agent.c rtnl.c dbus.c
+connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
+			profile.c element.c device.c network.c security.c \
+			resolver.c storage.c manager.c agent.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/connman.h b/src/connman.h
index 0275febd..9fbe9ec8 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -31,6 +31,8 @@ DBusMessage *__connman_error_failed(DBusMessage *msg);
 DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
 
+int __connman_selftest(void);
+
 int __connman_storage_init(void);
 void __connman_storage_cleanup(void);
 
diff --git a/src/main.c b/src/main.c
index 000847d6..929d31a8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -52,6 +52,7 @@ static void disconnect_callback(DBusConnection *conn, void *user_data)
 
 static gchar *option_device = NULL;
 static gboolean option_detach = TRUE;
+static gboolean option_selftest = FALSE;
 static gboolean option_compat = FALSE;
 static gboolean option_debug = FALSE;
 
@@ -61,6 +62,8 @@ static GOptionEntry options[] = {
 	{ "nodaemon", 'n', G_OPTION_FLAG_REVERSE,
 				G_OPTION_ARG_NONE, &option_detach,
 				"Don't fork daemon to background" },
+	{ "selftest", 't', 0, G_OPTION_ARG_NONE, &option_selftest,
+				"Run self testing routines" },
 	{ "compat", 'c', 0, G_OPTION_ARG_NONE, &option_compat,
 				"Enable Network Manager compatibility" },
 	{ "debug", 'd', 0, G_OPTION_ARG_NONE, &option_debug,
@@ -140,6 +143,13 @@ int main(int argc, char *argv[])
 
 	__connman_log_init(option_detach, option_debug);
 
+	if (option_selftest == TRUE) {
+		if (__connman_selftest() < 0) {
+			connman_error("Self testing routines failed");
+			goto selftest;
+		}
+	}
+
 	__connman_storage_init();
 
 	__connman_element_init(conn, option_device);
@@ -177,6 +187,7 @@ int main(int argc, char *argv[])
 
 	__connman_storage_cleanup();
 
+selftest:
 	__connman_log_cleanup();
 
 	dbus_connection_unref(conn);
diff --git a/src/selftest.c b/src/selftest.c
new file mode 100644
index 00000000..b3e0c238
--- /dev/null
+++ b/src/selftest.c
@@ -0,0 +1,39 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+int __connman_selftest(void)
+{
+	int err;
+
+	connman_info("Start self testing");
+
+	err = 0;
+
+	connman_info("Finished self testing");
+
+	return err;
+}

commit aad2c32df36c15ccafaadd5c0f7f71aff4c21995
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:25:04 2008 +0100

    Add improved resolver framework

diff --git a/include/resolver.h b/include/resolver.h
index 5c023758..d849e08a 100644
--- a/include/resolver.h
+++ b/include/resolver.h
@@ -39,11 +39,19 @@ extern "C" {
 struct connman_resolver {
 	const char *name;
 	int priority;
+	int (*append) (const char *interface, const char *domain,
+							const char *server);
+	int (*remove) (const char *interface, const char *domain,
+							const char *server);
 };
 
 extern int connman_resolver_register(struct connman_resolver *resolver);
 extern void connman_resolver_unregister(struct connman_resolver *resolver);
 
+extern int connman_resolver_append(const char *interface, const char *domain,
+							const char *server);
+extern int connman_resolver_remove_all(const char *interface);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/connman.h b/src/connman.h
index 9fbe9ec8..4fca0507 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -71,6 +71,8 @@ enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
 
 #include <connman/resolver.h>
 
+int __connman_resolver_selftest(void);
+
 #include <connman/driver.h>
 
 void __connman_driver_rescan(struct connman_driver *driver);
diff --git a/src/resolver.c b/src/resolver.c
index a8132361..d77ebc2a 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -25,8 +25,39 @@
 
 #include "connman.h"
 
+struct entry_data {
+	struct connman_resolver *resolver;
+	char *interface;
+	char *domain;
+	char *server;
+};
+
+static GSList *entry_list = NULL;
 static GSList *resolver_list = NULL;
 
+static void remove_entries(GSList *entries)
+{
+	GSList *list;
+
+	for (list = entries; list; list = list->next) {
+		struct entry_data *entry = list->data;
+		struct connman_resolver *resolver = entry->resolver;
+
+		entry_list = g_slist_remove(entry_list, entry);
+
+		if (resolver->remove)
+			resolver->remove(entry->interface, entry->domain,
+								entry->server);
+
+		g_free(entry->server);
+		g_free(entry->domain);
+		g_free(entry->interface);
+		g_free(entry);
+	}
+
+	g_slist_free(entries);
+}
+
 static gint compare_priority(gconstpointer a, gconstpointer b)
 {
 	const struct connman_resolver *resolver1 = a;
@@ -45,11 +76,27 @@ static gint compare_priority(gconstpointer a, gconstpointer b)
  */
 int connman_resolver_register(struct connman_resolver *resolver)
 {
+	GSList *list;
+
 	DBG("resolver %p name %s", resolver, resolver->name);
 
 	resolver_list = g_slist_insert_sorted(resolver_list, resolver,
 							compare_priority);
 
+	if (resolver->append == NULL)
+		return 0;
+
+	for (list = entry_list; list; list = list->next) {
+		struct entry_data *entry = list->data;
+
+		if (entry->resolver)
+			continue;
+
+		if (resolver->append(entry->interface, entry->domain,
+							entry->server) == 0)
+			entry->resolver = resolver;
+	}
+
 	return 0;
 }
 
@@ -61,7 +108,127 @@ int connman_resolver_register(struct connman_resolver *resolver)
  */
 void connman_resolver_unregister(struct connman_resolver *resolver)
 {
+	GSList *list, *matches = NULL;
+
 	DBG("resolver %p name %s", resolver, resolver->name);
 
 	resolver_list = g_slist_remove(resolver_list, resolver);
+
+	for (list = entry_list; list; list = list->next) {
+		struct entry_data *entry = list->data;
+
+		if (entry->resolver != resolver)
+			continue;
+
+		matches = g_slist_append(matches, entry);
+	}
+
+	remove_entries(matches);
+}
+
+/**
+ * connman_resolver_append:
+ * @interface: network interface
+ * @domain: domain limitation
+ * @server: server address
+ *
+ * Append resolver server address to current list
+ */
+int connman_resolver_append(const char *interface, const char *domain,
+							const char *server)
+{
+	struct entry_data *entry;
+	GSList *list;
+
+	DBG("interface %s domain %s server %s", interface, domain, server);
+
+	entry = g_try_new0(struct entry_data, 1);
+	if (entry == NULL)
+		return -ENOMEM;
+
+	entry->interface = g_strdup(interface);
+	entry->domain = g_strdup(domain);
+	entry->server = g_strdup(server);
+
+	entry_list = g_slist_append(entry_list, entry);
+
+	for (list = resolver_list; list; list = list->next) {
+		struct connman_resolver *resolver = list->data;
+
+		if (resolver->append == NULL)
+			continue;
+
+		if (resolver->append(interface, domain, server) == 0) {
+			entry->resolver = resolver;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * connman_resolver_remove_all:
+ * @interface: network interface
+ *
+ * Remove all resolver server address for the specified interface
+ */
+int connman_resolver_remove_all(const char *interface)
+{
+	GSList *list, *matches = NULL;
+
+	DBG("interface %s", interface);
+
+	for (list = entry_list; list; list = list->next) {
+		struct entry_data *entry = list->data;
+		struct connman_resolver *resolver;
+
+		if (g_str_equal(entry->interface, interface) == FALSE)
+			continue;
+
+		matches = g_slist_append(matches, entry);
+	}
+
+	remove_entries(matches);
+
+	return 0;
+}
+
+static int selftest_append(const char *interface, const char *domain,
+							const char *server)
+{
+	DBG("server %s", server);
+
+	return 0;
+}
+
+static int selftest_remove(const char *interface, const char *domain,
+							const char *server)
+{
+	DBG("server %s", server);
+
+	return 0;
+}
+
+static struct connman_resolver selftest = {
+	.name     = "selftest",
+	.priority = CONNMAN_RESOLVER_PRIORITY_HIGH + 42,
+	.append   = selftest_append,
+	.remove   = selftest_remove,
+};
+
+int __connman_resolver_selftest(void)
+{
+	connman_resolver_append("wlan0", "lwn.net", "192.168.0.1");
+
+	connman_resolver_register(&selftest);
+
+	connman_resolver_append("eth0", "moblin.org", "192.168.42.1");
+	connman_resolver_append("wlan0", "lwn.net", "192.168.0.2");
+
+	connman_resolver_remove_all("wlan0");
+
+	connman_resolver_unregister(&selftest);
+
+	return 0;
 }
diff --git a/src/selftest.c b/src/selftest.c
index b3e0c238..17f77587 100644
--- a/src/selftest.c
+++ b/src/selftest.c
@@ -31,8 +31,12 @@ int __connman_selftest(void)
 
 	connman_info("Start self testing");
 
-	err = 0;
+	connman_info("Testing resolver unit");
+	err = __connman_resolver_selftest();
+	if (err < 0)
+		goto done;
 
+done:
 	connman_info("Finished self testing");
 
 	return err;

commit 4cc7b22fe12f12d2ded7aaa78c9887f53a5133fe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:33:05 2008 +0100

    Remove unused variable and fix another variable name

diff --git a/src/resolver.c b/src/resolver.c
index d77ebc2a..01e8cf9c 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -181,7 +181,6 @@ int connman_resolver_remove_all(const char *interface)
 
 	for (list = entry_list; list; list = list->next) {
 		struct entry_data *entry = list->data;
-		struct connman_resolver *resolver;
 
 		if (g_str_equal(entry->interface, interface) == FALSE)
 			continue;
@@ -210,7 +209,7 @@ static int selftest_remove(const char *interface, const char *domain,
 	return 0;
 }
 
-static struct connman_resolver selftest = {
+static struct connman_resolver selftest_resolver = {
 	.name     = "selftest",
 	.priority = CONNMAN_RESOLVER_PRIORITY_HIGH + 42,
 	.append   = selftest_append,
@@ -221,14 +220,14 @@ int __connman_resolver_selftest(void)
 {
 	connman_resolver_append("wlan0", "lwn.net", "192.168.0.1");
 
-	connman_resolver_register(&selftest);
+	connman_resolver_register(&selftest_resolver);
 
 	connman_resolver_append("eth0", "moblin.org", "192.168.42.1");
 	connman_resolver_append("wlan0", "lwn.net", "192.168.0.2");
 
 	connman_resolver_remove_all("wlan0");
 
-	connman_resolver_unregister(&selftest);
+	connman_resolver_unregister(&selftest_resolver);
 
 	return 0;
 }

commit 212ac19139a303448076d3699428c375c5439e19
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:50:01 2008 +0100

    Convert IPv4 setting to use new resolver framework

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index b9011f9e..c4af117c 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -21,9 +21,9 @@ dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
-ipv4_la_SOURCES = ipv4.c
+ipv4_la_SOURCES = ipv4.c inet.h inet.c
 
-resolvconf_la_SOURCES = resolvconf.c inet.h inet.c
+resolvconf_la_SOURCES = resolvconf.c
 
 resolvfile_la_SOURCES = resolvfile.c
 
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 173c691b..ddff1533 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -37,8 +37,11 @@
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
+#include <connman/resolver.h>
 #include <connman/log.h>
 
+#include "inet.h"
+
 enum connman_ipv4_method {
 	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
 	CONNMAN_IPV4_METHOD_OFF     = 1,
@@ -57,7 +60,7 @@ struct connman_ipv4 {
 };
 
 static int set_ipv4(struct connman_element *element,
-						struct connman_ipv4 *ipv4)
+			struct connman_ipv4 *ipv4, const char *nameserver)
 {
 	struct ifreq ifr;
 	struct rtentry rt;
@@ -131,6 +134,8 @@ static int set_ipv4(struct connman_element *element,
 		return -1;
 	}
 
+	connman_resolver_append(ifr.ifr_name, NULL, nameserver);
+
 	return 0;
 }
 
@@ -156,6 +161,8 @@ static int clear_ipv4(struct connman_element *element)
 
 	DBG("ifname %s", ifr.ifr_name);
 
+	connman_resolver_remove_all(ifr.ifr_name);
+
 	addr = (struct sockaddr_in *) &ifr.ifr_addr;
 	addr->sin_family = AF_INET;
 	addr->sin_addr.s_addr = INADDR_ANY;
@@ -175,9 +182,10 @@ static int clear_ipv4(struct connman_element *element)
 
 static int ipv4_probe(struct connman_element *element)
 {
-	struct connman_element *resolver;
+	struct connman_element *connection;
 	struct connman_ipv4 ipv4;
 	const char *address = NULL, *netmask = NULL, *gateway = NULL;
+	const char *nameserver = NULL;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -188,6 +196,9 @@ static int ipv4_probe(struct connman_element *element)
 	connman_element_get_value(element,
 				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
 
+	connman_element_get_value(element,
+			CONNMAN_PROPERTY_ID_IPV4_NAMESERVER, &nameserver);
+
 	DBG("address %s", address);
 	DBG("netmask %s", netmask);
 	DBG("gateway %s", gateway);
@@ -200,14 +211,14 @@ static int ipv4_probe(struct connman_element *element)
 	ipv4.netmask.s_addr = inet_addr(netmask);
 	ipv4.gateway.s_addr = inet_addr(gateway);
 
-	set_ipv4(element, &ipv4);
+	set_ipv4(element, &ipv4, nameserver);
 
-	resolver = connman_element_create(NULL);
+	connection = connman_element_create(NULL);
 
-	resolver->type = CONNMAN_ELEMENT_TYPE_RESOLVER;
-	resolver->index = element->index;
+	connection->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
+	connection->index = element->index;
 
-	connman_element_register(resolver, element);
+	connman_element_register(connection, element);
 
 	return 0;
 }
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index e1d53379..41f649cc 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -23,41 +23,31 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
 #include <unistd.h>
 #include <stdlib.h>
 
 #include <connman/plugin.h>
-#include <connman/driver.h>
+#include <connman/resolver.h>
 #include <connman/log.h>
 
-#include "inet.h"
+#include <glib.h>
 
 #define RESOLVCONF "/sbin/resolvconf"
 
-static int resolvconf_probe(struct connman_element *element)
+static int resolvconf_append(const char *interface, const char *domain,
+							const char *server)
 {
-	const char *nameserver = NULL;
-	struct connman_element *internet;
-	gchar *cmd, *name;
+	char *cmd;
 	int err;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("interface %s server %s", interface, server);
 
 	if (access(RESOLVCONF, X_OK) < 0)
 		return -errno;
 
-	connman_element_get_value(element,
-			CONNMAN_PROPERTY_ID_IPV4_NAMESERVER, &nameserver);
-
-	if (nameserver == NULL)
-		return -EINVAL;
-
-	name = inet_index2name(element->index);
-
 	cmd = g_strdup_printf("echo \"nameserver %s\" | %s -a %s",
-						nameserver, RESOLVCONF, name);
-
-	g_free(name);
+						server, RESOLVCONF, interface);
 
 	DBG("%s", cmd);
 
@@ -66,27 +56,18 @@ static int resolvconf_probe(struct connman_element *element)
 
 	g_free(cmd);
 
-	internet = connman_element_create(NULL);
-
-	internet->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
-
-	connman_element_register(internet, element);
-
-	return 0;
+	return err;
 }
 
-static void resolvconf_remove(struct connman_element *element)
+static int resolvconf_remove(const char *interface, const char *domain,
+							const char *server)
 {
-	gchar *cmd, *name;
+	char *cmd;
 	int err;
 
-	DBG("element %p name %s", element, element->name);
-
-	name = inet_index2name(element->index);
+	DBG("interface %s server %s", interface, server);
 
-	cmd = g_strdup_printf("%s -d %s", RESOLVCONF, name);
-
-	g_free(name);
+	cmd = g_strdup_printf("%s -d %s", RESOLVCONF, interface);
 
 	DBG("%s", cmd);
 
@@ -94,24 +75,25 @@ static void resolvconf_remove(struct connman_element *element)
 	err = 0;
 
 	g_free(cmd);
+
+	return err;
 }
 
-static struct connman_driver resolvconf_driver = {
+static struct connman_resolver resolvconf_resolver = {
 	.name		= "resolvconf",
-	.type		= CONNMAN_ELEMENT_TYPE_RESOLVER,
-	.priority	= CONNMAN_DRIVER_PRIORITY_HIGH,
-	.probe		= resolvconf_probe,
+	.priority	= CONNMAN_RESOLVER_PRIORITY_DEFAULT,
+	.append		= resolvconf_append,
 	.remove		= resolvconf_remove,
 };
 
 static int resolvconf_init(void)
 {
-	return connman_driver_register(&resolvconf_driver);
+	return connman_resolver_register(&resolvconf_resolver);
 }
 
 static void resolvconf_exit(void)
 {
-	connman_driver_unregister(&resolvconf_driver);
+	connman_resolver_unregister(&resolvconf_resolver);
 }
 
 CONNMAN_PLUGIN_DEFINE(resolvconf, "Name resolver plugin", VERSION,
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index deb39c94..440656af 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -24,29 +24,25 @@
 #endif
 
 #include <stdio.h>
+#include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/stat.h>
 
 #include <connman/plugin.h>
-#include <connman/driver.h>
+#include <connman/resolver.h>
 #include <connman/log.h>
 
-static int resolvfile_probe(struct connman_element *element)
+#include <glib.h>
+
+static int resolvfile_append(const char *interface, const char *domain,
+							const char *server)
 {
-	const char *nameserver = NULL;
-	struct connman_element *internet;
-	gchar *cmd;
+	char *cmd;
 	int fd, len, err;
 
-	DBG("element %p name %s", element, element->name);
-
-	connman_element_get_value(element,
-			CONNMAN_PROPERTY_ID_IPV4_NAMESERVER, &nameserver);
-
-	if (nameserver == NULL)
-		return -EINVAL;
+	DBG("server %s", server);
 
 	fd = open("/etc/resolv.conf", O_RDWR | O_CREAT,
 					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
@@ -55,7 +51,7 @@ static int resolvfile_probe(struct connman_element *element)
 
 	err = ftruncate(fd, 0);
 
-	cmd = g_strdup_printf("nameserver %s\n", nameserver);
+	cmd = g_strdup_printf("nameserver %s\n", server);
 
 	len = write(fd, cmd, strlen(cmd));
 
@@ -63,36 +59,32 @@ static int resolvfile_probe(struct connman_element *element)
 
 	close(fd);
 
-	internet = connman_element_create(NULL);
-
-	internet->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
-
-	connman_element_register(internet, element);
-
 	return 0;
 }
 
-static void resolvfile_remove(struct connman_element *element)
+static int resolvfile_remove(const char *interface, const char *domain,
+							const char *server)
 {
-	DBG("element %p name %s", element, element->name);
+	DBG("server %s", server);
+
+	return 0;
 }
 
-static struct connman_driver resolvfile_driver = {
-	.name		= "resolvconf",
-	.type		= CONNMAN_ELEMENT_TYPE_RESOLVER,
-	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
-	.probe		= resolvfile_probe,
+static struct connman_resolver resolvfile_resolver = {
+	.name		= "resolvfile",
+	.priority	= CONNMAN_RESOLVER_PRIORITY_LOW,
+	.append		= resolvfile_append,
 	.remove		= resolvfile_remove,
 };
 
 static int resolvfile_init(void)
 {
-	return connman_driver_register(&resolvfile_driver);
+	return connman_resolver_register(&resolvfile_resolver);
 }
 
 static void resolvfile_exit(void)
 {
-	connman_driver_unregister(&resolvfile_driver);
+	connman_resolver_unregister(&resolvfile_resolver);
 }
 
 CONNMAN_PLUGIN_DEFINE(resolvfile, "Name resolver plugin", VERSION,

commit 947c603d03e65b8343fb83a06b81fd52702081e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:50:53 2008 +0100

    Remove linkage of unused functions

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index c4af117c..88a2d782 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -21,7 +21,7 @@ dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
-ipv4_la_SOURCES = ipv4.c inet.h inet.c
+ipv4_la_SOURCES = ipv4.c
 
 resolvconf_la_SOURCES = resolvconf.c
 

commit 67e4d9d3cc18b494eb07639eb33e29342100ca7b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:52:10 2008 +0100

    Remove deprecated resolver element type

diff --git a/include/element.h b/include/element.h
index e56f669f..466f46b3 100644
--- a/include/element.h
+++ b/include/element.h
@@ -64,7 +64,6 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_DHCP       = 8,
 	CONNMAN_ELEMENT_TYPE_BOOTP      = 9,
 	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 10,
-	CONNMAN_ELEMENT_TYPE_RESOLVER   = 11,
 
 	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
 };
diff --git a/src/element.c b/src/element.c
index 895ec920..dbed9ca5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -112,8 +112,6 @@ static const char *type2string(enum connman_element_type type)
 		return "bootp";
 	case CONNMAN_ELEMENT_TYPE_ZEROCONF:
 		return "zeroconf";
-	case CONNMAN_ELEMENT_TYPE_RESOLVER:
-		return "resolver";
 	case CONNMAN_ELEMENT_TYPE_CONNECTION:
 		return "connection";
 	}

commit c45047df7b35f3d4802cedf8fe21e2a2f8610935
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 19:56:05 2008 +0100

    Restart scanning after disconnecting

diff --git a/plugins/wifi.c b/plugins/wifi.c
index ed3a68e1..67ac993c 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -190,7 +190,8 @@ static void state_change(struct connman_element *device,
 
 	DBG("state %d", state);
 
-	if (state == STATE_INACTIVE && data->inactive_timer == 0)
+	if ((state == STATE_INACTIVE || state == STATE_DISCONNECTED) &&
+						data->inactive_timer == 0)
 		data->inactive_timer = g_timeout_add_seconds(INACTIVE_TIMEOUT,
 							inactive_scan, device);
 

commit 2f74c0693e5f374778e5f5d329e742c390e84d37
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 20:04:06 2008 +0100

    Add skeleton for DNS proxy resolver plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 88a2d782..41f20bd2 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,8 +2,8 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = loopback.la ethernet.la wifi.la bluetooth.la \
-				netdev.la dhclient.la ipv4.la \
-				resolvconf.la resolvfile.la rtnllink.la
+				netdev.la dhclient.la ipv4.la rtnllink.la \
+				dnsproxy.la resolvconf.la resolvfile.la
 
 loopback_la_SOURCES = loopback.c
 
@@ -23,12 +23,14 @@ dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 
 ipv4_la_SOURCES = ipv4.c
 
+rtnllink_la_SOURCES = rtnllink.c inet.h inet.c
+
+dnsproxy_la_SOURCES = dnsproxy.c
+
 resolvconf_la_SOURCES = resolvconf.c
 
 resolvfile_la_SOURCES = resolvfile.c
 
-rtnllink_la_SOURCES = rtnllink.c inet.h inet.c
-
 if POLKIT
 plugin_LTLIBRARIES += polkit.la
 
diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
new file mode 100644
index 00000000..419d33dc
--- /dev/null
+++ b/plugins/dnsproxy.c
@@ -0,0 +1,64 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/resolver.h>
+#include <connman/log.h>
+
+static int dnsproxy_append(const char *interface, const char *domain,
+							const char *server)
+{
+	DBG("server %s", server);
+
+	return -1;
+}
+
+static int dnsproxy_remove(const char *interface, const char *domain,
+							const char *server)
+{
+	DBG("server %s", server);
+
+	return 0;
+}
+
+static struct connman_resolver dnsproxy_resolver = {
+	.name		= "dnsproxy",
+	.priority	= CONNMAN_RESOLVER_PRIORITY_HIGH,
+	.append		= dnsproxy_append,
+	.remove		= dnsproxy_remove,
+};
+
+static int dnsproxy_init(void)
+{
+	return connman_resolver_register(&dnsproxy_resolver);
+}
+
+static void dnsproxy_exit(void)
+{
+	connman_resolver_unregister(&dnsproxy_resolver);
+}
+
+CONNMAN_PLUGIN_DEFINE(dnsproxy, "DNS proxy resolver plugin", VERSION,
+					dnsproxy_init, dnsproxy_exit)

commit 7b19cffd7e92e8efdc6a26cb566abc73a009934c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 20:34:56 2008 +0100

    Emit signal when element gets enabled or disabled

diff --git a/src/element.c b/src/element.c
index dbed9ca5..ea49ec99 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1909,7 +1909,7 @@ int connman_element_set_enabled(struct connman_element *element,
 
 	element->enabled = enabled;
 
-	connman_element_update(element);
+	emit_enabled_signal(connection, element);
 
 	return 0;
 }

commit 1e826f42422e54cc92935119d6a6a9abf060d961
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 20:36:07 2008 +0100

    Add support for automatically connecting known networks

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 67ac993c..75990631 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -182,6 +182,32 @@ static gboolean inactive_scan(gpointer user_data)
 	return FALSE;
 }
 
+static void connect_known_networks(struct connman_element *device)
+{
+	struct wifi_data *data = connman_element_get_data(device);
+	GSList *list;
+
+	DBG("");
+
+	if (data->inactive_timer > 0) {
+		g_source_remove(data->inactive_timer);
+		data->inactive_timer = 0;
+	}
+
+	for (list = data->current; list; list = list->next) {
+		struct connman_element *element = list->data;
+
+		if (element->policy == CONNMAN_ELEMENT_POLICY_AUTO &&
+						element->remember == TRUE) {
+			if (network_enable(element) == 0)
+				return;
+		}
+	}
+
+	data->inactive_timer = g_timeout_add_seconds(INACTIVE_TIMEOUT,
+							inactive_scan, device);
+}
+
 static void state_change(struct connman_element *device,
 						enum supplicant_state state)
 {
@@ -190,25 +216,21 @@ static void state_change(struct connman_element *device,
 
 	DBG("state %d", state);
 
-	if ((state == STATE_INACTIVE || state == STATE_DISCONNECTED) &&
-						data->inactive_timer == 0)
-		data->inactive_timer = g_timeout_add_seconds(INACTIVE_TIMEOUT,
-							inactive_scan, device);
-
 	if (data == NULL)
 		return;
 
 	if (data->identifier == NULL)
-		return;
+		goto reconnect;
 
 	element = find_current_element(data, data->identifier);
 	if (element == NULL)
-		return;
+		goto reconnect;
 
 	if (state == STATE_COMPLETED) {
 		struct connman_element *dhcp;
 
 		data->connected = TRUE;
+		connman_element_set_enabled(element, TRUE);
 
 		dhcp = connman_element_create(NULL);
 
@@ -216,8 +238,18 @@ static void state_change(struct connman_element *device,
 		dhcp->index = element->index;
 
 		connman_element_register(dhcp, element);
-	} else if (state == STATE_DISCONNECTED || state == STATE_INACTIVE)
+	} else if (state == STATE_INACTIVE || state == STATE_DISCONNECTED) {
 		data->connected = FALSE;
+		connman_element_set_enabled(element, FALSE);
+
+		connman_element_unregister_children(element);
+	}
+
+reconnect:
+	if (state == STATE_INACTIVE || state == STATE_DISCONNECTED) {
+		data->connected = FALSE;
+		connect_known_networks(device);
+	}
 }
 
 static gboolean cleanup_pending(gpointer user_data)

commit c4cca8087b85ee569b450a9b4ea91eb7f0b8a3d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 20:44:36 2008 +0100

    Only try to connect to available networks

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 75990631..6dafad47 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -198,7 +198,8 @@ static void connect_known_networks(struct connman_element *device)
 		struct connman_element *element = list->data;
 
 		if (element->policy == CONNMAN_ELEMENT_POLICY_AUTO &&
-						element->remember == TRUE) {
+						element->remember == TRUE &&
+						element->available == TRUE) {
 			if (network_enable(element) == 0)
 				return;
 		}

commit 0bf62525dd76931ef9a8e20ec87bf02840a686ef
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 21:17:53 2008 +0100

    Remove the off policy option

diff --git a/include/element.h b/include/element.h
index 466f46b3..aede0d9c 100644
--- a/include/element.h
+++ b/include/element.h
@@ -46,10 +46,9 @@ enum connman_element_state {
 
 enum connman_element_policy {
 	CONNMAN_ELEMENT_POLICY_UNKNOWN = 0,
-	CONNMAN_ELEMENT_POLICY_OFF     = 1,
+	CONNMAN_ELEMENT_POLICY_IGNORE  = 1,
 	CONNMAN_ELEMENT_POLICY_AUTO    = 2,
-	CONNMAN_ELEMENT_POLICY_IGNORE  = 3,
-	CONNMAN_ELEMENT_POLICY_ASK     = 4,
+	CONNMAN_ELEMENT_POLICY_ASK     = 3,
 };
 
 enum connman_element_type {
diff --git a/src/element.c b/src/element.c
index ea49ec99..3c329b86 100644
--- a/src/element.c
+++ b/src/element.c
@@ -148,12 +148,10 @@ const char *__connman_element_policy2string(enum connman_element_policy policy)
 	switch (policy) {
 	case CONNMAN_ELEMENT_POLICY_UNKNOWN:
 		return "unknown";
-	case CONNMAN_ELEMENT_POLICY_OFF:
-		return "off";
-	case CONNMAN_ELEMENT_POLICY_AUTO:
-		return "auto";
 	case CONNMAN_ELEMENT_POLICY_IGNORE:
 		return "ignore";
+	case CONNMAN_ELEMENT_POLICY_AUTO:
+		return "auto";
 	case CONNMAN_ELEMENT_POLICY_ASK:
 		return "ask";
 	}
@@ -163,9 +161,7 @@ const char *__connman_element_policy2string(enum connman_element_policy policy)
 
 enum connman_element_policy __connman_element_string2policy(const char *policy)
 {
-	if (strcasecmp(policy, "off") == 0)
-		return CONNMAN_ELEMENT_POLICY_OFF;
-	else if (strcasecmp(policy, "ignore") == 0)
+	if (strcasecmp(policy, "ignore") == 0)
 		return CONNMAN_ELEMENT_POLICY_IGNORE;
 	else if (strcasecmp(policy, "auto") == 0)
 		return CONNMAN_ELEMENT_POLICY_AUTO;

commit b70e5ae739c0944c683b6daa34448a69a5a84dc9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 13 21:25:16 2008 +0100

    Don't install D-Bus system activation service

diff --git a/src/Makefile.am b/src/Makefile.am
index c2553b0b..170e40a4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -3,12 +3,6 @@ dbusdir = $(sysconfdir)/dbus-1/system.d
 
 dbus_DATA = connman.conf
 
-servicedir = $(datarootdir)/dbus-1/system-services
-
-service_DATA = connman.service
-
-DISTCLEANFILES = $(service_DATA)
-
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \

commit 1dcb48fa42e97ec8addb292976887a80ac42e450
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 00:29:30 2008 +0100

    Add support for changing static properties

diff --git a/include/element.h b/include/element.h
index aede0d9c..bc03011a 100644
--- a/include/element.h
+++ b/include/element.h
@@ -123,6 +123,8 @@ extern void connman_element_unref(struct connman_element *element);
 
 extern int connman_element_add_static_property(struct connman_element *element,
 				const char *name, int type, const void *value);
+extern int connman_element_set_static_property(struct connman_element *element,
+				const char *name, int type, const void *value);
 extern int connman_element_add_static_array_property(struct connman_element *element,
 			const char *name, int type, const void *value, int len);
 extern int connman_element_define_properties(struct connman_element *element, ...);
diff --git a/src/element.c b/src/element.c
index 3c329b86..375b8714 100644
--- a/src/element.c
+++ b/src/element.c
@@ -343,10 +343,8 @@ static void emit_enabled_signal(DBusConnection *conn,
 
 	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
 					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
-
 	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN,
 							&element->enabled);
-
 	dbus_message_iter_close_container(&entry, &value);
 
 	g_dbus_send_message(conn, signal);
@@ -1116,6 +1114,99 @@ int connman_element_add_static_property(struct connman_element *element,
 	return 0;
 }
 
+static void emit_property_changed(DBusConnection *conn,
+				struct connman_element *element,
+				const char *name, int type, const void *data)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *iface, *sig;
+
+	DBG("conn %p", conn);
+
+	switch (element->type) {
+	case CONNMAN_ELEMENT_TYPE_DEVICE:
+		iface = CONNMAN_DEVICE_INTERFACE;
+		break;
+	case CONNMAN_ELEMENT_TYPE_NETWORK:
+		iface = CONNMAN_NETWORK_INTERFACE;
+		break;
+	default:
+		return;
+	}
+
+	signal = dbus_message_new_signal(element->path,
+						iface, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &name);
+
+	switch (type) {
+	case DBUS_TYPE_STRING:
+		sig = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_BYTE:
+		sig = DBUS_TYPE_BYTE_AS_STRING;
+		break;
+	default:
+		sig = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+							sig, &value);
+	dbus_message_iter_append_basic(&value, type, data);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(conn, signal);
+}
+
+int connman_element_set_static_property(struct connman_element *element,
+				const char *name, int type, const void *value)
+{
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (type != DBUS_TYPE_STRING && type != DBUS_TYPE_BYTE)
+		return -EINVAL;
+
+	__connman_element_lock(element);
+
+	for (list = element->properties; list; list = list->next) {
+		struct connman_property *property = list->data;
+
+		if (g_str_equal(property->name, name) == FALSE)
+			continue;
+
+		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
+			continue;
+
+		property->type = type;
+		g_free(property->value);
+
+		switch (type) {
+		case DBUS_TYPE_STRING:
+			property->value = g_strdup(*((const char **) value));
+			break;
+		case DBUS_TYPE_BYTE:
+			property->value = g_try_malloc(1);
+			if (property->value != NULL)
+				memcpy(property->value, value, 1);
+			break;
+		}
+	}
+
+	__connman_element_unlock(element);
+
+	emit_property_changed(connection, element, name, type, value);
+
+	return 0;
+}
+
 int connman_element_add_static_array_property(struct connman_element *element,
 			const char *name, int type, const void *value, int len)
 {
@@ -1527,9 +1618,7 @@ static void append_devices(DBusMessageIter *entry)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
 	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
-
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(entry, &value);
@@ -1590,9 +1679,7 @@ static void append_connections(DBusMessageIter *entry)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
 	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
-
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(entry, &value);
@@ -1626,9 +1713,7 @@ static void append_state(DBusMessageIter *entry, const char *state)
 
 	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
 					DBUS_TYPE_STRING_AS_STRING, &value);
-
 	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, &state);
-
 	dbus_message_iter_close_container(entry, &value);
 }
 

commit 9c4dd9603160c08f38109571d7c6eebfdfc86d83
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 00:30:08 2008 +0100

    Indicate changes to the signal strength

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 6dafad47..77d83702 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -299,6 +299,7 @@ static void scan_result(struct connman_element *device,
 {
 	struct wifi_data *data = connman_element_get_data(device);
 	struct connman_element *element;
+	guint8 strength = network->quality;
 	gchar *temp;
 	int i;
 
@@ -324,8 +325,6 @@ static void scan_result(struct connman_element *device,
 
 	element = find_pending_element(data, network->identifier);
 	if (element == NULL) {
-		guint8 strength;
-
 		element = connman_element_create(temp);
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
@@ -352,21 +351,20 @@ static void scan_result(struct connman_element *device,
 			element->wifi.security = g_strdup(security);
 		}
 
-		strength = network->quality;
-
 		connman_element_add_static_property(element, "WiFi.Strength",
 						DBUS_TYPE_BYTE, &strength);
 
-		//connman_element_add_static_property(element, "WiFi.Noise",
-		//			DBUS_TYPE_INT32, &network->noise);
-
 		DBG("%s (%s) strength %d", network->identifier,
 					element->wifi.security, strength);
 
 		connman_element_register(element, device);
-	} else
+	} else {
 		data->pending = g_slist_remove(data->pending, element);
 
+		connman_element_set_static_property(element, "WiFi.Strength",
+						DBUS_TYPE_BYTE, &strength);
+	}
+
 	data->current = g_slist_append(data->current, element);
 
 	element->available = TRUE;

commit 99515f9c0d4818aa99eb227657954a2d9f1d3ae3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 00:37:10 2008 +0100

    Print signal strength as integer

diff --git a/test/monitor-connman b/test/monitor-connman
index 2c4b9bdd..0c4a2efc 100755
--- a/test/monitor-connman
+++ b/test/monitor-connman
@@ -7,7 +7,11 @@ import dbus.mainloop.glib
 
 def property_changed(name, value, path, interface):
 	iface = interface[interface.rfind(".") + 1:]
-	print "{%s} [%s] %s = %s" % (iface, path, name, str(value))
+	if (name == "WiFi.Strength"):
+		val = int(value)
+	else:
+		val = str(value)
+	print "{%s} [%s] %s = %s" % (iface, path, name, val)
 
 if __name__ == '__main__':
 	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

commit c634b10c2613e71f2824171b9a42c1728f801c71
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 02:12:40 2008 +0100

    Add generic signal strength property

diff --git a/doc/network-api.txt b/doc/network-api.txt
index 8480fcdf..b38e1223 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -51,6 +51,10 @@ Properties	string Name [readonly]
 			For manually created networks this is set by
 			default.
 
+		uint8 Strength [readonly]
+
+			Indicates the signal strength of the network.
+
 		array{byte} WiFi.SSID [readonly]
 
 			If the network type is WiFi, then this property is
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 77d83702..70e19e9d 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -351,7 +351,7 @@ static void scan_result(struct connman_element *device,
 			element->wifi.security = g_strdup(security);
 		}
 
-		connman_element_add_static_property(element, "WiFi.Strength",
+		connman_element_add_static_property(element, "Strength",
 						DBUS_TYPE_BYTE, &strength);
 
 		DBG("%s (%s) strength %d", network->identifier,
@@ -361,7 +361,7 @@ static void scan_result(struct connman_element *device,
 	} else {
 		data->pending = g_slist_remove(data->pending, element);
 
-		connman_element_set_static_property(element, "WiFi.Strength",
+		connman_element_set_static_property(element, "Strength",
 						DBUS_TYPE_BYTE, &strength);
 	}
 
diff --git a/test/list-networks b/test/list-networks
index 8f7e01bb..b4462103 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -42,7 +42,7 @@ for path in properties["Devices"]:
 			if (key == "WiFi.SSID"):
 				ssid = convert_ssid(properties[key])
 				print "        %s = [ %s ]" % (key, ssid)
-			elif (key == "WiFi.Strength"):
+			elif (key == "Strength"):
 				print "        %s = %d" % (key, properties[key])
 			else:
 				print "        %s = %s" % (key, properties[key])
diff --git a/test/monitor-connman b/test/monitor-connman
index 0c4a2efc..97d3a6b5 100755
--- a/test/monitor-connman
+++ b/test/monitor-connman
@@ -7,7 +7,7 @@ import dbus.mainloop.glib
 
 def property_changed(name, value, path, interface):
 	iface = interface[interface.rfind(".") + 1:]
-	if (name == "WiFi.Strength"):
+	if (name == "Strength"):
 		val = int(value)
 	else:
 		val = str(value)

commit cc737fc9212cd4af3f903cb49a9a271c83e767d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 03:38:13 2008 +0100

    Don't apply filter to network devices

diff --git a/src/element.c b/src/element.c
index 375b8714..e0822295 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1846,7 +1846,8 @@ int connman_element_register(struct connman_element *element,
 	if (element->devname == NULL)
 		element->devname = g_strdup(element->name);
 
-	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
+	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
+			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
 		if (g_pattern_match_simple(device_filter,
 						element->devname) == FALSE) {
 			DBG("ignoring %s [%s] device", element->name,

commit 3cbd718323c5fe44459db0cf1df3441e51b9de23
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 03:45:00 2008 +0100

    Don't include network list for Ethernet devices

diff --git a/src/element.c b/src/element.c
index e0822295..5081ff3e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -422,10 +422,6 @@ static void append_networks(struct connman_element *element,
 	DBusMessageIter value, iter;
 	const char *key = "Networks";
 
-	if (element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIFI &&
-			element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIMAX)
-		return;
-
 	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
 
 	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
@@ -476,12 +472,13 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
-	dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX) {
+		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
-
-	append_networks(element, &entry);
-
-	dbus_message_iter_close_container(&dict, &entry);
+		append_networks(element, &entry);
+		dbus_message_iter_close_container(&dict, &entry);
+	}
 
 	add_common_properties(element, &dict);
 

commit 568fd534af91a91367870e306ce52735964ea877
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 03:48:33 2008 +0100

    Fix bridge and WiMAX device detection

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index 3fbcedbd..b0ed247f 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -74,9 +74,9 @@ static void rtnllink_newlink(unsigned short type, int index,
 		int sk;
 
 		snprintf(bridge_path, PATH_MAX,
-					"/sys/class/net/%s/bridge", name);
+					"/sys/class/net/%s/bridge", devname);
 		snprintf(wimax_path, PATH_MAX,
-					"/sys/class/net/%s/wimax", name);
+					"/sys/class/net/%s/wimax", devname);
 
 		memset(&iwr, 0, sizeof(iwr));
 		strncpy(iwr.ifr_ifrn.ifrn_name, devname, IFNAMSIZ);

commit 2904ecea7aa4403602f01e634d81e312cd6eebdd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 04:48:56 2008 +0100

    Release 0.3

diff --git a/ChangeLog b/ChangeLog
index 38f7d5c3..f9dcf501 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,10 @@
+ver 0.3:
+	Add support for automatically connecting known networks.
+	Add improved framework for handling resolver details.
+	Add generic signal strength property.
+	Fix bridge and WiMAX device detection.
+	Fix network listing for Ethernet devices.
+
 ver 0.2:
 	Add support for indicating network changes.
 	Add support for signal strength property.
diff --git a/configure.ac b/configure.ac
index ffe01fee..0a10c57b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.2)
+AM_INIT_AUTOMAKE(connman, 0.3)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit e0abb552e9b2759f0ec7324d1d040a83a1249f47
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 23:53:44 2008 +0100

    Add DNS proxy/multiplexer implementation

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index 419d33dc..bc61d519 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -23,22 +23,206 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+
 #include <connman/plugin.h>
 #include <connman/resolver.h>
 #include <connman/log.h>
 
+#include <glib.h>
+
+struct server_data {
+	char *interface;
+	char *server;
+	GIOChannel *channel;
+	guint watch;
+};
+
+struct request_data {
+	struct sockaddr_in sin;
+	socklen_t len;
+	guint16 id;
+};
+
+static GSList *server_list = NULL;
+static GSList *request_list = NULL;
+
+static GIOChannel *listener_channel = NULL;
+static guint listener_watch = 0;
+
+static struct request_data *find_request(guint16 id)
+{
+	GSList *list;
+
+	for (list = request_list; list; list = list->next) {
+		struct request_data *data = list->data;
+
+		if (data->id == id)
+			return data;
+	}
+
+	return NULL;
+}
+
+static struct server_data *find_server(const char *interface,
+							const char *server)
+{
+	GSList *list;
+
+	DBG("interface %s server %s", interface, server);
+
+	for (list = server_list; list; list = list->next) {
+		struct server_data *data = list->data;
+
+		if (data->interface == NULL || data->server == NULL)
+			continue;
+
+		if (g_str_equal(data->interface, interface) == TRUE &&
+				g_str_equal(data->server, server) == TRUE)
+			return data;
+	}
+
+	return NULL;
+}
+
+static gboolean server_event(GIOChannel *channel, GIOCondition condition,
+							gpointer user_data)
+{
+	struct request_data *req;
+	unsigned char buf[768];
+	int sk, err, len;
+
+	sk = g_io_channel_unix_get_fd(channel);
+
+	len = recv(sk, buf, sizeof(buf), 0);
+	if (len < 2)
+		return TRUE;
+
+	DBG("Received %d bytes (id 0x%04x)", len, buf[0] | buf[1] << 8);
+
+	req = find_request(buf[0] | buf[1] << 8);
+	if (req == NULL)
+		return TRUE;
+
+	request_list = g_slist_remove(request_list, req);
+
+	sk = g_io_channel_unix_get_fd(listener_channel);
+
+	err = sendto(sk, buf, len, 0, (struct sockaddr *) &req->sin, req->len);
+
+	g_free(req);
+
+	return TRUE;
+}
+
+static struct server_data *create_server(const char *interface,
+							const char *server)
+{
+	struct server_data *data;
+	struct sockaddr_in sin;
+	int sk;
+
+	DBG("interface %s server %s", interface, server);
+
+	sk = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+	if (sk < 0) {
+		connman_error("Failed to create server %s socket", server);
+		return NULL;
+	}
+
+	if (setsockopt(sk, SOL_SOCKET, SO_BINDTODEVICE,
+				interface, strlen(interface) + 1) < 0) {
+		connman_error("Failed to bind server %s to interface %s",
+							server, interface);
+		close(sk);
+		return NULL;
+	}
+
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_port = htons(53);
+	sin.sin_addr.s_addr = inet_addr(server);
+
+	if (connect(sk, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
+		connman_error("Failed to connect server %s", server);
+		close(sk);
+		return NULL;
+	}
+
+	data = g_try_new0(struct server_data, 1);
+	if (data == NULL) {
+		connman_error("Failed to allocate server %s data", server);
+		close(sk);
+		return NULL;
+	}
+
+	data->channel = g_io_channel_unix_new(sk);
+	if (data->channel == NULL) {
+		connman_error("Failed to create server %s channel", server);
+		close(sk);
+		g_free(data);
+		return NULL;
+	}
+
+	g_io_channel_set_close_on_unref(data->channel, TRUE);
+
+	data->watch = g_io_add_watch(data->channel, G_IO_IN,
+							server_event, data);
+
+	data->interface = g_strdup(interface);
+	data->server = g_strdup(server);
+
+	return data;
+}
+
+static void destroy_server(struct server_data *data)
+{
+	DBG("interface %s server %s", data->interface, data->server);
+
+	if (data->watch > 0)
+		g_source_remove(data->watch);
+
+	g_io_channel_unref(data->channel);
+
+	g_free(data->interface);
+	g_free(data->server);
+	g_free(data);
+}
+
 static int dnsproxy_append(const char *interface, const char *domain,
 							const char *server)
 {
-	DBG("server %s", server);
+	struct server_data *data;
+
+	DBG("interface %s server %s", interface, server);
+
+	data = create_server(interface, server);
+	if (data == NULL)
+		return -EIO;
 
-	return -1;
+	server_list = g_slist_append(server_list, data);
+
+	return 0;
 }
 
 static int dnsproxy_remove(const char *interface, const char *domain,
 							const char *server)
 {
-	DBG("server %s", server);
+	struct server_data *data;
+
+	DBG("interface %s server %s", interface, server);
+
+	data = find_server(interface, server);
+	if (data == NULL)
+		return 0;
+
+	server_list = g_slist_remove(server_list, data);
+
+	destroy_server(data);
 
 	return 0;
 }
@@ -50,15 +234,154 @@ static struct connman_resolver dnsproxy_resolver = {
 	.remove		= dnsproxy_remove,
 };
 
+static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
+							gpointer user_data)
+{
+	GSList *list;
+	unsigned char buf[768];
+	struct request_data *req;
+	struct sockaddr_in sin;
+	socklen_t size = sizeof(sin);
+	int sk, err, len;
+
+	sk = g_io_channel_unix_get_fd(channel);
+
+	memset(&sin, 0, sizeof(sin));
+	len = recvfrom(sk, buf, sizeof(buf), 0,
+					(struct sockaddr *) &sin, &size);
+	if (len < 2)
+		return TRUE;
+
+	DBG("Received %d bytes (id 0x%04x)", len, buf[0] | buf[1] << 8);
+
+	if (g_slist_length(server_list) == 0)
+		return TRUE;
+
+	req = find_request(buf[0] | (buf[1] << 8));
+	if (req == NULL) {
+		req = g_try_new0(struct request_data, 1);
+		if (req == NULL)
+			return TRUE;
+
+		memcpy(&req->sin, &sin, sizeof(sin));
+		req->len = size;
+		req->id = buf[0] | (buf[1] << 8);
+
+		request_list = g_slist_append(request_list, req);
+	} else {
+		memcpy(&req->sin, &sin, sizeof(sin));
+		req->len = size;
+	}
+
+	for (list = server_list; list; list = list->next) {
+		struct server_data *data = list->data;
+
+		sk = g_io_channel_unix_get_fd(data->channel);
+
+		err = send(sk, buf, len, 0);
+	}
+
+	return TRUE;
+}
+
+static int create_listener(void)
+{
+	const char *ifname = "lo";
+	struct sockaddr_in sin;
+	int sk;
+
+	DBG("");
+
+	sk = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+	if (sk < 0) {
+		connman_error("Failed to create listener socket");
+		return -EIO;
+	}
+
+	//setsockopt(sk, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
+	//setsockopt(sk, SOL_IP, IP_PKTINFO, &opt, sizeof(opt));
+
+	if (setsockopt(sk, SOL_SOCKET, SO_BINDTODEVICE,
+					ifname, strlen(ifname) + 1) < 0) {
+		connman_error("Failed to bind listener interface");
+		close(sk);
+		return -EIO;
+	}
+
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_port = htons(53);
+	sin.sin_addr.s_addr = inet_addr("127.0.0.1");
+	//sin.sin_addr.s_addr = INADDR_ANY;
+
+	if (bind(sk, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
+		connman_error("Failed to bind listener socket");
+		close(sk);
+		return -EIO;
+	}
+
+	listener_channel = g_io_channel_unix_new(sk);
+	if (listener_channel == NULL) {
+		connman_error("Failed to create listener channel");
+		close(sk);
+		return -EIO;
+	}
+
+	g_io_channel_set_close_on_unref(listener_channel, TRUE);
+
+	listener_watch = g_io_add_watch(listener_channel, G_IO_IN,
+							listener_event, NULL);
+
+	return 0;
+}
+
+static void destroy_listener(void)
+{
+	GSList *list;
+
+	DBG("");
+
+	if (listener_watch > 0)
+		g_source_remove(listener_watch);
+
+	for (list = request_list; list; list = list->next) {
+		struct request_data *data = list->data;
+
+		DBG("Dropping request (id 0x%04x)", data->id);
+
+		g_free(data);
+		list->data = NULL;
+	}
+
+	g_slist_free(request_list);
+	request_list = NULL;
+
+	g_io_channel_unref(listener_channel);
+}
+
 static int dnsproxy_init(void)
 {
-	return connman_resolver_register(&dnsproxy_resolver);
+	int err;
+
+	err = create_listener();
+	if (err < 0)
+		return err;
+
+	err = connman_resolver_register(&dnsproxy_resolver);
+	if (err < 0) {
+		destroy_listener();
+		return err;
+	}
+
+	return 0;
 }
 
 static void dnsproxy_exit(void)
 {
+	destroy_listener();
+
 	connman_resolver_unregister(&dnsproxy_resolver);
 }
 
 CONNMAN_PLUGIN_DEFINE(dnsproxy, "DNS proxy resolver plugin", VERSION,
-					dnsproxy_init, dnsproxy_exit)
+						dnsproxy_init, dnsproxy_exit)

commit 388bdb1cc0e7384a1d97d51e581776291cde5738
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 14 23:56:18 2008 +0100

    Add copy of RFC 1035 (DNS system)

diff --git a/doc/rfc1035.txt b/doc/rfc1035.txt
new file mode 100644
index 00000000..b1a9bf5a
--- /dev/null
+++ b/doc/rfc1035.txt
@@ -0,0 +1,3077 @@
+Network Working Group                                     P. Mockapetris
+Request for Comments: 1035                                           ISI
+                                                           November 1987
+Obsoletes: RFCs 882, 883, 973
+
+            DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION
+
+
+1. STATUS OF THIS MEMO
+
+This RFC describes the details of the domain system and protocol, and
+assumes that the reader is familiar with the concepts discussed in a
+companion RFC, "Domain Names - Concepts and Facilities" [RFC-1034].
+
+The domain system is a mixture of functions and data types which are an
+official protocol and functions and data types which are still
+experimental.  Since the domain system is intentionally extensible, new
+data types and experimental behavior should always be expected in parts
+of the system beyond the official protocol.  The official protocol parts
+include standard queries, responses and the Internet class RR data
+formats (e.g., host addresses).  Since the previous RFC set, several
+definitions have changed, so some previous definitions are obsolete.
+
+Experimental or obsolete features are clearly marked in these RFCs, and
+such information should be used with caution.
+
+The reader is especially cautioned not to depend on the values which
+appear in examples to be current or complete, since their purpose is
+primarily pedagogical.  Distribution of this memo is unlimited.
+
+                           Table of Contents
+
+  1. STATUS OF THIS MEMO                                              1
+  2. INTRODUCTION                                                     3
+      2.1. Overview                                                   3
+      2.2. Common configurations                                      4
+      2.3. Conventions                                                7
+          2.3.1. Preferred name syntax                                7
+          2.3.2. Data Transmission Order                              8
+          2.3.3. Character Case                                       9
+          2.3.4. Size limits                                         10
+  3. DOMAIN NAME SPACE AND RR DEFINITIONS                            10
+      3.1. Name space definitions                                    10
+      3.2. RR definitions                                            11
+          3.2.1. Format                                              11
+          3.2.2. TYPE values                                         12
+          3.2.3. QTYPE values                                        12
+          3.2.4. CLASS values                                        13
+
+
+
+Mockapetris                                                     [Page 1]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+          3.2.5. QCLASS values                                       13
+      3.3. Standard RRs                                              13
+          3.3.1. CNAME RDATA format                                  14
+          3.3.2. HINFO RDATA format                                  14
+          3.3.3. MB RDATA format (EXPERIMENTAL)                      14
+          3.3.4. MD RDATA format (Obsolete)                          15
+          3.3.5. MF RDATA format (Obsolete)                          15
+          3.3.6. MG RDATA format (EXPERIMENTAL)                      16
+          3.3.7. MINFO RDATA format (EXPERIMENTAL)                   16
+          3.3.8. MR RDATA format (EXPERIMENTAL)                      17
+          3.3.9. MX RDATA format                                     17
+          3.3.10. NULL RDATA format (EXPERIMENTAL)                   17
+          3.3.11. NS RDATA format                                    18
+          3.3.12. PTR RDATA format                                   18
+          3.3.13. SOA RDATA format                                   19
+          3.3.14. TXT RDATA format                                   20
+      3.4. ARPA Internet specific RRs                                20
+          3.4.1. A RDATA format                                      20
+          3.4.2. WKS RDATA format                                    21
+      3.5. IN-ADDR.ARPA domain                                       22
+      3.6. Defining new types, classes, and special namespaces       24
+  4. MESSAGES                                                        25
+      4.1. Format                                                    25
+          4.1.1. Header section format                               26
+          4.1.2. Question section format                             28
+          4.1.3. Resource record format                              29
+          4.1.4. Message compression                                 30
+      4.2. Transport                                                 32
+          4.2.1. UDP usage                                           32
+          4.2.2. TCP usage                                           32
+  5. MASTER FILES                                                    33
+      5.1. Format                                                    33
+      5.2. Use of master files to define zones                       35
+      5.3. Master file example                                       36
+  6. NAME SERVER IMPLEMENTATION                                      37
+      6.1. Architecture                                              37
+          6.1.1. Control                                             37
+          6.1.2. Database                                            37
+          6.1.3. Time                                                39
+      6.2. Standard query processing                                 39
+      6.3. Zone refresh and reload processing                        39
+      6.4. Inverse queries (Optional)                                40
+          6.4.1. The contents of inverse queries and responses       40
+          6.4.2. Inverse query and response example                  41
+          6.4.3. Inverse query processing                            42
+
+
+
+
+
+
+Mockapetris                                                     [Page 2]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+      6.5. Completion queries and responses                          42
+  7. RESOLVER IMPLEMENTATION                                         43
+      7.1. Transforming a user request into a query                  43
+      7.2. Sending the queries                                       44
+      7.3. Processing responses                                      46
+      7.4. Using the cache                                           47
+  8. MAIL SUPPORT                                                    47
+      8.1. Mail exchange binding                                     48
+      8.2. Mailbox binding (Experimental)                            48
+  9. REFERENCES and BIBLIOGRAPHY                                     50
+  Index                                                              54
+
+2. INTRODUCTION
+
+2.1. Overview
+
+The goal of domain names is to provide a mechanism for naming resources
+in such a way that the names are usable in different hosts, networks,
+protocol families, internets, and administrative organizations.
+
+From the user's point of view, domain names are useful as arguments to a
+local agent, called a resolver, which retrieves information associated
+with the domain name.  Thus a user might ask for the host address or
+mail information associated with a particular domain name.  To enable
+the user to request a particular type of information, an appropriate
+query type is passed to the resolver with the domain name.  To the user,
+the domain tree is a single information space; the resolver is
+responsible for hiding the distribution of data among name servers from
+the user.
+
+From the resolver's point of view, the database that makes up the domain
+space is distributed among various name servers.  Different parts of the
+domain space are stored in different name servers, although a particular
+data item will be stored redundantly in two or more name servers.  The
+resolver starts with knowledge of at least one name server.  When the
+resolver processes a user query it asks a known name server for the
+information; in return, the resolver either receives the desired
+information or a referral to another name server.  Using these
+referrals, resolvers learn the identities and contents of other name
+servers.  Resolvers are responsible for dealing with the distribution of
+the domain space and dealing with the effects of name server failure by
+consulting redundant databases in other servers.
+
+Name servers manage two kinds of data.  The first kind of data held in
+sets called zones; each zone is the complete database for a particular
+"pruned" subtree of the domain space.  This data is called
+authoritative.  A name server periodically checks to make sure that its
+zones are up to date, and if not, obtains a new copy of updated zones
+
+
+
+Mockapetris                                                     [Page 3]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+from master files stored locally or in another name server.  The second
+kind of data is cached data which was acquired by a local resolver.
+This data may be incomplete, but improves the performance of the
+retrieval process when non-local data is repeatedly accessed.  Cached
+data is eventually discarded by a timeout mechanism.
+
+This functional structure isolates the problems of user interface,
+failure recovery, and distribution in the resolvers and isolates the
+database update and refresh problems in the name servers.
+
+2.2. Common configurations
+
+A host can participate in the domain name system in a number of ways,
+depending on whether the host runs programs that retrieve information
+from the domain system, name servers that answer queries from other
+hosts, or various combinations of both functions.  The simplest, and
+perhaps most typical, configuration is shown below:
+
+                 Local Host                        |  Foreign
+                                                   |
+    +---------+               +----------+         |  +--------+
+    |         | user queries  |          |queries  |  |        |
+    |  User   |-------------->|          |---------|->|Foreign |
+    | Program |               | Resolver |         |  |  Name  |
+    |         |<--------------|          |<--------|--| Server |
+    |         | user responses|          |responses|  |        |
+    +---------+               +----------+         |  +--------+
+                                |     A            |
+                cache additions |     | references |
+                                V     |            |
+                              +----------+         |
+                              |  cache   |         |
+                              +----------+         |
+
+User programs interact with the domain name space through resolvers; the
+format of user queries and user responses is specific to the host and
+its operating system.  User queries will typically be operating system
+calls, and the resolver and its cache will be part of the host operating
+system.  Less capable hosts may choose to implement the resolver as a
+subroutine to be linked in with every program that needs its services.
+Resolvers answer user queries with information they acquire via queries
+to foreign name servers and the local cache.
+
+Note that the resolver may have to make several queries to several
+different foreign name servers to answer a particular user query, and
+hence the resolution of a user query may involve several network
+accesses and an arbitrary amount of time.  The queries to foreign name
+servers and the corresponding responses have a standard format described
+
+
+
+Mockapetris                                                     [Page 4]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+in this memo, and may be datagrams.
+
+Depending on its capabilities, a name server could be a stand alone
+program on a dedicated machine or a process or processes on a large
+timeshared host.  A simple configuration might be:
+
+                 Local Host                        |  Foreign
+                                                   |
+      +---------+                                  |
+     /         /|                                  |
+    +---------+ |             +----------+         |  +--------+
+    |         | |             |          |responses|  |        |
+    |         | |             |   Name   |---------|->|Foreign |
+    |  Master |-------------->|  Server  |         |  |Resolver|
+    |  files  | |             |          |<--------|--|        |
+    |         |/              |          | queries |  +--------+
+    +---------+               +----------+         |
+
+Here a primary name server acquires information about one or more zones
+by reading master files from its local file system, and answers queries
+about those zones that arrive from foreign resolvers.
+
+The DNS requires that all zones be redundantly supported by more than
+one name server.  Designated secondary servers can acquire zones and
+check for updates from the primary server using the zone transfer
+protocol of the DNS.  This configuration is shown below:
+
+                 Local Host                        |  Foreign
+                                                   |
+      +---------+                                  |
+     /         /|                                  |
+    +---------+ |             +----------+         |  +--------+
+    |         | |             |          |responses|  |        |
+    |         | |             |   Name   |---------|->|Foreign |
+    |  Master |-------------->|  Server  |         |  |Resolver|
+    |  files  | |             |          |<--------|--|        |
+    |         |/              |          | queries |  +--------+
+    +---------+               +----------+         |
+                                A     |maintenance |  +--------+
+                                |     +------------|->|        |
+                                |      queries     |  |Foreign |
+                                |                  |  |  Name  |
+                                +------------------|--| Server |
+                             maintenance responses |  +--------+
+
+In this configuration, the name server periodically establishes a
+virtual circuit to a foreign name server to acquire a copy of a zone or
+to check that an existing copy has not changed.  The messages sent for
+
+
+
+Mockapetris                                                     [Page 5]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+these maintenance activities follow the same form as queries and
+responses, but the message sequences are somewhat different.
+
+The information flow in a host that supports all aspects of the domain
+name system is shown below:
+
+                 Local Host                        |  Foreign
+                                                   |
+    +---------+               +----------+         |  +--------+
+    |         | user queries  |          |queries  |  |        |
+    |  User   |-------------->|          |---------|->|Foreign |
+    | Program |               | Resolver |         |  |  Name  |
+    |         |<--------------|          |<--------|--| Server |
+    |         | user responses|          |responses|  |        |
+    +---------+               +----------+         |  +--------+
+                                |     A            |
+                cache additions |     | references |
+                                V     |            |
+                              +----------+         |
+                              |  Shared  |         |
+                              | database |         |
+                              +----------+         |
+                                A     |            |
+      +---------+     refreshes |     | references |
+     /         /|               |     V            |
+    +---------+ |             +----------+         |  +--------+
+    |         | |             |          |responses|  |        |
+    |         | |             |   Name   |---------|->|Foreign |
+    |  Master |-------------->|  Server  |         |  |Resolver|
+    |  files  | |             |          |<--------|--|        |
+    |         |/              |          | queries |  +--------+
+    +---------+               +----------+         |
+                                A     |maintenance |  +--------+
+                                |     +------------|->|        |
+                                |      queries     |  |Foreign |
+                                |                  |  |  Name  |
+                                +------------------|--| Server |
+                             maintenance responses |  +--------+
+
+The shared database holds domain space data for the local name server
+and resolver.  The contents of the shared database will typically be a
+mixture of authoritative data maintained by the periodic refresh
+operations of the name server and cached data from previous resolver
+requests.  The structure of the domain data and the necessity for
+synchronization between name servers and resolvers imply the general
+characteristics of this database, but the actual format is up to the
+local implementor.
+
+
+
+
+Mockapetris                                                     [Page 6]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+Information flow can also be tailored so that a group of hosts act
+together to optimize activities.  Sometimes this is done to offload less
+capable hosts so that they do not have to implement a full resolver.
+This can be appropriate for PCs or hosts which want to minimize the
+amount of new network code which is required.  This scheme can also
+allow a group of hosts can share a small number of caches rather than
+maintaining a large number of separate caches, on the premise that the
+centralized caches will have a higher hit ratio.  In either case,
+resolvers are replaced with stub resolvers which act as front ends to
+resolvers located in a recursive server in one or more name servers
+known to perform that service:
+
+                   Local Hosts                     |  Foreign
+                                                   |
+    +---------+                                    |
+    |         | responses                          |
+    | Stub    |<--------------------+              |
+    | Resolver|                     |              |
+    |         |----------------+    |              |
+    +---------+ recursive      |    |              |
+                queries        |    |              |
+                               V    |              |
+    +---------+ recursive     +----------+         |  +--------+
+    |         | queries       |          |queries  |  |        |
+    | Stub    |-------------->| Recursive|---------|->|Foreign |
+    | Resolver|               | Server   |         |  |  Name  |
+    |         |<--------------|          |<--------|--| Server |
+    +---------+ responses     |          |responses|  |        |
+                              +----------+         |  +--------+
+                              |  Central |         |
+                              |   cache  |         |
+                              +----------+         |
+
+In any case, note that domain components are always replicated for
+reliability whenever possible.
+
+2.3. Conventions
+
+The domain system has several conventions dealing with low-level, but
+fundamental, issues.  While the implementor is free to violate these
+conventions WITHIN HIS OWN SYSTEM, he must observe these conventions in
+ALL behavior observed from other hosts.
+
+2.3.1. Preferred name syntax
+
+The DNS specifications attempt to be as general as possible in the rules
+for constructing domain names.  The idea is that the name of any
+existing object can be expressed as a domain name with minimal changes.
+
+
+
+Mockapetris                                                     [Page 7]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+However, when assigning a domain name for an object, the prudent user
+will select a name which satisfies both the rules of the domain system
+and any existing rules for the object, whether these rules are published
+or implied by existing programs.
+
+For example, when naming a mail domain, the user should satisfy both the
+rules of this memo and those in RFC-822.  When creating a new host name,
+the old rules for HOSTS.TXT should be followed.  This avoids problems
+when old software is converted to use domain names.
+
+The following syntax will result in fewer problems with many
+
+applications that use domain names (e.g., mail, TELNET).
+
+<domain> ::= <subdomain> | " "
+
+<subdomain> ::= <label> | <subdomain> "." <label>
+
+<label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
+
+<ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
+
+<let-dig-hyp> ::= <let-dig> | "-"
+
+<let-dig> ::= <letter> | <digit>
+
+<letter> ::= any one of the 52 alphabetic characters A through Z in
+upper case and a through z in lower case
+
+<digit> ::= any one of the ten digits 0 through 9
+
+Note that while upper and lower case letters are allowed in domain
+names, no significance is attached to the case.  That is, two names with
+the same spelling but different case are to be treated as if identical.
+
+The labels must follow the rules for ARPANET host names.  They must
+start with a letter, end with a letter or digit, and have as interior
+characters only letters, digits, and hyphen.  There are also some
+restrictions on the length.  Labels must be 63 characters or less.
+
+For example, the following strings identify hosts in the Internet:
+
+A.ISI.EDU XX.LCS.MIT.EDU SRI-NIC.ARPA
+
+2.3.2. Data Transmission Order
+
+The order of transmission of the header and data described in this
+document is resolved to the octet level.  Whenever a diagram shows a
+
+
+
+Mockapetris                                                     [Page 8]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+group of octets, the order of transmission of those octets is the normal
+order in which they are read in English.  For example, in the following
+diagram, the octets are transmitted in the order they are numbered.
+
+     0                   1
+     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       1       |       2       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       3       |       4       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       5       |       6       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+Whenever an octet represents a numeric quantity, the left most bit in
+the diagram is the high order or most significant bit.  That is, the bit
+labeled 0 is the most significant bit.  For example, the following
+diagram represents the value 170 (decimal).
+
+     0 1 2 3 4 5 6 7
+    +-+-+-+-+-+-+-+-+
+    |1 0 1 0 1 0 1 0|
+    +-+-+-+-+-+-+-+-+
+
+Similarly, whenever a multi-octet field represents a numeric quantity
+the left most bit of the whole field is the most significant bit.  When
+a multi-octet quantity is transmitted the most significant octet is
+transmitted first.
+
+2.3.3. Character Case
+
+For all parts of the DNS that are part of the official protocol, all
+comparisons between character strings (e.g., labels, domain names, etc.)
+are done in a case-insensitive manner.  At present, this rule is in
+force throughout the domain system without exception.  However, future
+additions beyond current usage may need to use the full binary octet
+capabilities in names, so attempts to store domain names in 7-bit ASCII
+or use of special bytes to terminate labels, etc., should be avoided.
+
+When data enters the domain system, its original case should be
+preserved whenever possible.  In certain circumstances this cannot be
+done.  For example, if two RRs are stored in a database, one at x.y and
+one at X.Y, they are actually stored at the same place in the database,
+and hence only one casing would be preserved.  The basic rule is that
+case can be discarded only when data is used to define structure in a
+database, and two names are identical when compared in a case
+insensitive manner.
+
+
+
+
+Mockapetris                                                     [Page 9]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+Loss of case sensitive data must be minimized.  Thus while data for x.y
+and X.Y may both be stored under a single location x.y or X.Y, data for
+a.x and B.X would never be stored under A.x, A.X, b.x, or b.X.  In
+general, this preserves the case of the first label of a domain name,
+but forces standardization of interior node labels.
+
+Systems administrators who enter data into the domain database should
+take care to represent the data they supply to the domain system in a
+case-consistent manner if their system is case-sensitive.  The data
+distribution system in the domain system will ensure that consistent
+representations are preserved.
+
+2.3.4. Size limits
+
+Various objects and parameters in the DNS have size limits.  They are
+listed below.  Some could be easily changed, others are more
+fundamental.
+
+labels          63 octets or less
+
+names           255 octets or less
+
+TTL             positive values of a signed 32 bit number.
+
+UDP messages    512 octets or less
+
+3. DOMAIN NAME SPACE AND RR DEFINITIONS
+
+3.1. Name space definitions
+
+Domain names in messages are expressed in terms of a sequence of labels.
+Each label is represented as a one octet length field followed by that
+number of octets.  Since every domain name ends with the null label of
+the root, a domain name is terminated by a length byte of zero.  The
+high order two bits of every length octet must be zero, and the
+remaining six bits of the length field limit the label to 63 octets or
+less.
+
+To simplify implementations, the total length of a domain name (i.e.,
+label octets and label length octets) is restricted to 255 octets or
+less.
+
+Although labels can contain any 8 bit values in octets that make up a
+label, it is strongly recommended that labels follow the preferred
+syntax described elsewhere in this memo, which is compatible with
+existing host naming conventions.  Name servers and resolvers must
+compare labels in a case-insensitive manner (i.e., A=a), assuming ASCII
+with zero parity.  Non-alphabetic codes must match exactly.
+
+
+
+Mockapetris                                                    [Page 10]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.2. RR definitions
+
+3.2.1. Format
+
+All RRs have the same top level format shown below:
+
+                                    1  1  1  1  1  1
+      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                                               |
+    /                                               /
+    /                      NAME                     /
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                      TYPE                     |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                     CLASS                     |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                      TTL                      |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                   RDLENGTH                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
+    /                     RDATA                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+
+where:
+
+NAME            an owner name, i.e., the name of the node to which this
+                resource record pertains.
+
+TYPE            two octets containing one of the RR TYPE codes.
+
+CLASS           two octets containing one of the RR CLASS codes.
+
+TTL             a 32 bit signed integer that specifies the time interval
+                that the resource record may be cached before the source
+                of the information should again be consulted.  Zero
+                values are interpreted to mean that the RR can only be
+                used for the transaction in progress, and should not be
+                cached.  For example, SOA records are always distributed
+                with a zero TTL to prohibit caching.  Zero values can
+                also be used for extremely volatile data.
+
+RDLENGTH        an unsigned 16 bit integer that specifies the length in
+                octets of the RDATA field.
+
+
+
+Mockapetris                                                    [Page 11]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+RDATA           a variable length string of octets that describes the
+                resource.  The format of this information varies
+                according to the TYPE and CLASS of the resource record.
+
+3.2.2. TYPE values
+
+TYPE fields are used in resource records.  Note that these types are a
+subset of QTYPEs.
+
+TYPE            value and meaning
+
+A               1 a host address
+
+NS              2 an authoritative name server
+
+MD              3 a mail destination (Obsolete - use MX)
+
+MF              4 a mail forwarder (Obsolete - use MX)
+
+CNAME           5 the canonical name for an alias
+
+SOA             6 marks the start of a zone of authority
+
+MB              7 a mailbox domain name (EXPERIMENTAL)
+
+MG              8 a mail group member (EXPERIMENTAL)
+
+MR              9 a mail rename domain name (EXPERIMENTAL)
+
+NULL            10 a null RR (EXPERIMENTAL)
+
+WKS             11 a well known service description
+
+PTR             12 a domain name pointer
+
+HINFO           13 host information
+
+MINFO           14 mailbox or mail list information
+
+MX              15 mail exchange
+
+TXT             16 text strings
+
+3.2.3. QTYPE values
+
+QTYPE fields appear in the question part of a query.  QTYPES are a
+superset of TYPEs, hence all TYPEs are valid QTYPEs.  In addition, the
+following QTYPEs are defined:
+
+
+
+Mockapetris                                                    [Page 12]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+AXFR            252 A request for a transfer of an entire zone
+
+MAILB           253 A request for mailbox-related records (MB, MG or MR)
+
+MAILA           254 A request for mail agent RRs (Obsolete - see MX)
+
+*               255 A request for all records
+
+3.2.4. CLASS values
+
+CLASS fields appear in resource records.  The following CLASS mnemonics
+and values are defined:
+
+IN              1 the Internet
+
+CS              2 the CSNET class (Obsolete - used only for examples in
+                some obsolete RFCs)
+
+CH              3 the CHAOS class
+
+HS              4 Hesiod [Dyer 87]
+
+3.2.5. QCLASS values
+
+QCLASS fields appear in the question section of a query.  QCLASS values
+are a superset of CLASS values; every CLASS is a valid QCLASS.  In
+addition to CLASS values, the following QCLASSes are defined:
+
+*               255 any class
+
+3.3. Standard RRs
+
+The following RR definitions are expected to occur, at least
+potentially, in all classes.  In particular, NS, SOA, CNAME, and PTR
+will be used in all classes, and have the same format in all classes.
+Because their RDATA format is known, all domain names in the RDATA
+section of these RRs may be compressed.
+
+<domain-name> is a domain name represented as a series of labels, and
+terminated by a label with zero length.  <character-string> is a single
+length octet followed by that number of characters.  <character-string>
+is treated as binary information, and can be up to 256 characters in
+length (including the length octet).
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 13]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.3.1. CNAME RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                     CNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+CNAME           A <domain-name> which specifies the canonical or primary
+                name for the owner.  The owner name is an alias.
+
+CNAME RRs cause no additional section processing, but name servers may
+choose to restart the query at the canonical name in certain cases.  See
+the description of name server logic in [RFC-1034] for details.
+
+3.3.2. HINFO RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                      CPU                      /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                       OS                      /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+CPU             A <character-string> which specifies the CPU type.
+
+OS              A <character-string> which specifies the operating
+                system type.
+
+Standard values for CPU and OS can be found in [RFC-1010].
+
+HINFO records are used to acquire general information about a host.  The
+main use is for protocols such as FTP that can use special procedures
+when talking between machines or operating systems of the same type.
+
+3.3.3. MB RDATA format (EXPERIMENTAL)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   MADNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+MADNAME         A <domain-name> which specifies a host which has the
+                specified mailbox.
+
+
+
+Mockapetris                                                    [Page 14]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+MB records cause additional section processing which looks up an A type
+RRs corresponding to MADNAME.
+
+3.3.4. MD RDATA format (Obsolete)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   MADNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+MADNAME         A <domain-name> which specifies a host which has a mail
+                agent for the domain which should be able to deliver
+                mail for the domain.
+
+MD records cause additional section processing which looks up an A type
+record corresponding to MADNAME.
+
+MD is obsolete.  See the definition of MX and [RFC-974] for details of
+the new scheme.  The recommended policy for dealing with MD RRs found in
+a master file is to reject them, or to convert them to MX RRs with a
+preference of 0.
+
+3.3.5. MF RDATA format (Obsolete)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   MADNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+MADNAME         A <domain-name> which specifies a host which has a mail
+                agent for the domain which will accept mail for
+                forwarding to the domain.
+
+MF records cause additional section processing which looks up an A type
+record corresponding to MADNAME.
+
+MF is obsolete.  See the definition of MX and [RFC-974] for details ofw
+the new scheme.  The recommended policy for dealing with MD RRs found in
+a master file is to reject them, or to convert them to MX RRs with a
+preference of 10.
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 15]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.3.6. MG RDATA format (EXPERIMENTAL)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   MGMNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+MGMNAME         A <domain-name> which specifies a mailbox which is a
+                member of the mail group specified by the domain name.
+
+MG records cause no additional section processing.
+
+3.3.7. MINFO RDATA format (EXPERIMENTAL)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                    RMAILBX                    /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                    EMAILBX                    /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+RMAILBX         A <domain-name> which specifies a mailbox which is
+                responsible for the mailing list or mailbox.  If this
+                domain name names the root, the owner of the MINFO RR is
+                responsible for itself.  Note that many existing mailing
+                lists use a mailbox X-request for the RMAILBX field of
+                mailing list X, e.g., Msgroup-request for Msgroup.  This
+                field provides a more general mechanism.
+
+
+EMAILBX         A <domain-name> which specifies a mailbox which is to
+                receive error messages related to the mailing list or
+                mailbox specified by the owner of the MINFO RR (similar
+                to the ERRORS-TO: field which has been proposed).  If
+                this domain name names the root, errors should be
+                returned to the sender of the message.
+
+MINFO records cause no additional section processing.  Although these
+records can be associated with a simple mailbox, they are usually used
+with a mailing list.
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 16]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.3.8. MR RDATA format (EXPERIMENTAL)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   NEWNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+NEWNAME         A <domain-name> which specifies a mailbox which is the
+                proper rename of the specified mailbox.
+
+MR records cause no additional section processing.  The main use for MR
+is as a forwarding entry for a user who has moved to a different
+mailbox.
+
+3.3.9. MX RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                  PREFERENCE                   |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   EXCHANGE                    /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+PREFERENCE      A 16 bit integer which specifies the preference given to
+                this RR among others at the same owner.  Lower values
+                are preferred.
+
+EXCHANGE        A <domain-name> which specifies a host willing to act as
+                a mail exchange for the owner name.
+
+MX records cause type A additional section processing for the host
+specified by EXCHANGE.  The use of MX RRs is explained in detail in
+[RFC-974].
+
+3.3.10. NULL RDATA format (EXPERIMENTAL)
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                  <anything>                   /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+Anything at all may be in the RDATA field so long as it is 65535 octets
+or less.
+
+
+
+
+Mockapetris                                                    [Page 17]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+NULL records cause no additional section processing.  NULL RRs are not
+allowed in master files.  NULLs are used as placeholders in some
+experimental extensions of the DNS.
+
+3.3.11. NS RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   NSDNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+NSDNAME         A <domain-name> which specifies a host which should be
+                authoritative for the specified class and domain.
+
+NS records cause both the usual additional section processing to locate
+a type A record, and, when used in a referral, a special search of the
+zone in which they reside for glue information.
+
+The NS RR states that the named host should be expected to have a zone
+starting at owner name of the specified class.  Note that the class may
+not indicate the protocol family which should be used to communicate
+with the host, although it is typically a strong hint.  For example,
+hosts which are name servers for either Internet (IN) or Hesiod (HS)
+class information are normally queried using IN class protocols.
+
+3.3.12. PTR RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   PTRDNAME                    /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+PTRDNAME        A <domain-name> which points to some location in the
+                domain name space.
+
+PTR records cause no additional section processing.  These RRs are used
+in special domains to point to some other location in the domain space.
+These records are simple data, and don't imply any special processing
+similar to that performed by CNAME, which identifies aliases.  See the
+description of the IN-ADDR.ARPA domain for an example.
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 18]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.3.13. SOA RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                     MNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                     RNAME                     /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    SERIAL                     |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    REFRESH                    |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                     RETRY                     |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    EXPIRE                     |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    MINIMUM                    |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+MNAME           The <domain-name> of the name server that was the
+                original or primary source of data for this zone.
+
+RNAME           A <domain-name> which specifies the mailbox of the
+                person responsible for this zone.
+
+SERIAL          The unsigned 32 bit version number of the original copy
+                of the zone.  Zone transfers preserve this value.  This
+                value wraps and should be compared using sequence space
+                arithmetic.
+
+REFRESH         A 32 bit time interval before the zone should be
+                refreshed.
+
+RETRY           A 32 bit time interval that should elapse before a
+                failed refresh should be retried.
+
+EXPIRE          A 32 bit time value that specifies the upper limit on
+                the time interval that can elapse before the zone is no
+                longer authoritative.
+
+
+
+
+
+Mockapetris                                                    [Page 19]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+MINIMUM         The unsigned 32 bit minimum TTL field that should be
+                exported with any RR from this zone.
+
+SOA records cause no additional section processing.
+
+All times are in units of seconds.
+
+Most of these fields are pertinent only for name server maintenance
+operations.  However, MINIMUM is used in all query operations that
+retrieve RRs from a zone.  Whenever a RR is sent in a response to a
+query, the TTL field is set to the maximum of the TTL field from the RR
+and the MINIMUM field in the appropriate SOA.  Thus MINIMUM is a lower
+bound on the TTL field for all RRs in a zone.  Note that this use of
+MINIMUM should occur when the RRs are copied into the response and not
+when the zone is loaded from a master file or via a zone transfer.  The
+reason for this provison is to allow future dynamic update facilities to
+change the SOA RR with known semantics.
+
+
+3.3.14. TXT RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                   TXT-DATA                    /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+TXT-DATA        One or more <character-string>s.
+
+TXT RRs are used to hold descriptive text.  The semantics of the text
+depends on the domain where it is found.
+
+3.4. Internet specific RRs
+
+3.4.1. A RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    ADDRESS                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+ADDRESS         A 32 bit Internet address.
+
+Hosts that have multiple Internet addresses will have multiple A
+records.
+
+
+
+
+
+Mockapetris                                                    [Page 20]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+A records cause no additional section processing.  The RDATA section of
+an A line in a master file is an Internet address expressed as four
+decimal numbers separated by dots without any imbedded spaces (e.g.,
+"10.2.0.52" or "192.0.5.6").
+
+3.4.2. WKS RDATA format
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    ADDRESS                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |       PROTOCOL        |                       |
+    +--+--+--+--+--+--+--+--+                       |
+    |                                               |
+    /                   <BIT MAP>                   /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+ADDRESS         An 32 bit Internet address
+
+PROTOCOL        An 8 bit IP protocol number
+
+<BIT MAP>       A variable length bit map.  The bit map must be a
+                multiple of 8 bits long.
+
+The WKS record is used to describe the well known services supported by
+a particular protocol on a particular internet address.  The PROTOCOL
+field specifies an IP protocol number, and the bit map has one bit per
+port of the specified protocol.  The first bit corresponds to port 0,
+the second to port 1, etc.  If the bit map does not include a bit for a
+protocol of interest, that bit is assumed zero.  The appropriate values
+and mnemonics for ports and protocols are specified in [RFC-1010].
+
+For example, if PROTOCOL=TCP (6), the 26th bit corresponds to TCP port
+25 (SMTP).  If this bit is set, a SMTP server should be listening on TCP
+port 25; if zero, SMTP service is not supported on the specified
+address.
+
+The purpose of WKS RRs is to provide availability information for
+servers for TCP and UDP.  If a server supports both TCP and UDP, or has
+multiple Internet addresses, then multiple WKS RRs are used.
+
+WKS RRs cause no additional section processing.
+
+In master files, both ports and protocols are expressed using mnemonics
+or decimal numbers.
+
+
+
+
+Mockapetris                                                    [Page 21]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.5. IN-ADDR.ARPA domain
+
+The Internet uses a special domain to support gateway location and
+Internet address to host mapping.  Other classes may employ a similar
+strategy in other domains.  The intent of this domain is to provide a
+guaranteed method to perform host address to host name mapping, and to
+facilitate queries to locate all gateways on a particular network in the
+Internet.
+
+Note that both of these services are similar to functions that could be
+performed by inverse queries; the difference is that this part of the
+domain name space is structured according to address, and hence can
+guarantee that the appropriate data can be located without an exhaustive
+search of the domain space.
+
+The domain begins at IN-ADDR.ARPA and has a substructure which follows
+the Internet addressing structure.
+
+Domain names in the IN-ADDR.ARPA domain are defined to have up to four
+labels in addition to the IN-ADDR.ARPA suffix.  Each label represents
+one octet of an Internet address, and is expressed as a character string
+for a decimal value in the range 0-255 (with leading zeros omitted
+except in the case of a zero octet which is represented by a single
+zero).
+
+Host addresses are represented by domain names that have all four labels
+specified.  Thus data for Internet address 10.2.0.52 is located at
+domain name 52.0.2.10.IN-ADDR.ARPA.  The reversal, though awkward to
+read, allows zones to be delegated which are exactly one network of
+address space.  For example, 10.IN-ADDR.ARPA can be a zone containing
+data for the ARPANET, while 26.IN-ADDR.ARPA can be a separate zone for
+MILNET.  Address nodes are used to hold pointers to primary host names
+in the normal domain space.
+
+Network numbers correspond to some non-terminal nodes at various depths
+in the IN-ADDR.ARPA domain, since Internet network numbers are either 1,
+2, or 3 octets.  Network nodes are used to hold pointers to the primary
+host names of gateways attached to that network.  Since a gateway is, by
+definition, on more than one network, it will typically have two or more
+network nodes which point at it.  Gateways will also have host level
+pointers at their fully qualified addresses.
+
+Both the gateway pointers at network nodes and the normal host pointers
+at full address nodes use the PTR RR to point back to the primary domain
+names of the corresponding hosts.
+
+For example, the IN-ADDR.ARPA domain will contain information about the
+ISI gateway between net 10 and 26, an MIT gateway from net 10 to MIT's
+
+
+
+Mockapetris                                                    [Page 22]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+net 18, and hosts A.ISI.EDU and MULTICS.MIT.EDU.  Assuming that ISI
+gateway has addresses 10.2.0.22 and 26.0.0.103, and a name MILNET-
+GW.ISI.EDU, and the MIT gateway has addresses 10.0.0.77 and 18.10.0.4
+and a name GW.LCS.MIT.EDU, the domain database would contain:
+
+    10.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.
+    10.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.
+    18.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.
+    26.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.
+    22.0.2.10.IN-ADDR.ARPA.    PTR MILNET-GW.ISI.EDU.
+    103.0.0.26.IN-ADDR.ARPA.   PTR MILNET-GW.ISI.EDU.
+    77.0.0.10.IN-ADDR.ARPA.    PTR GW.LCS.MIT.EDU.
+    4.0.10.18.IN-ADDR.ARPA.    PTR GW.LCS.MIT.EDU.
+    103.0.3.26.IN-ADDR.ARPA.   PTR A.ISI.EDU.
+    6.0.0.10.IN-ADDR.ARPA.     PTR MULTICS.MIT.EDU.
+
+Thus a program which wanted to locate gateways on net 10 would originate
+a query of the form QTYPE=PTR, QCLASS=IN, QNAME=10.IN-ADDR.ARPA.  It
+would receive two RRs in response:
+
+    10.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.
+    10.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.
+
+The program could then originate QTYPE=A, QCLASS=IN queries for MILNET-
+GW.ISI.EDU. and GW.LCS.MIT.EDU. to discover the Internet addresses of
+these gateways.
+
+A resolver which wanted to find the host name corresponding to Internet
+host address 10.0.0.6 would pursue a query of the form QTYPE=PTR,
+QCLASS=IN, QNAME=6.0.0.10.IN-ADDR.ARPA, and would receive:
+
+    6.0.0.10.IN-ADDR.ARPA.     PTR MULTICS.MIT.EDU.
+
+Several cautions apply to the use of these services:
+   - Since the IN-ADDR.ARPA special domain and the normal domain
+     for a particular host or gateway will be in different zones,
+     the possibility exists that that the data may be inconsistent.
+
+   - Gateways will often have two names in separate domains, only
+     one of which can be primary.
+
+   - Systems that use the domain database to initialize their
+     routing tables must start with enough gateway information to
+     guarantee that they can access the appropriate name server.
+
+   - The gateway data only reflects the existence of a gateway in a
+     manner equivalent to the current HOSTS.TXT file.  It doesn't
+     replace the dynamic availability information from GGP or EGP.
+
+
+
+Mockapetris                                                    [Page 23]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+3.6. Defining new types, classes, and special namespaces
+
+The previously defined types and classes are the ones in use as of the
+date of this memo.  New definitions should be expected.  This section
+makes some recommendations to designers considering additions to the
+existing facilities.  The mailing list NAMEDROPPERS@SRI-NIC.ARPA is the
+forum where general discussion of design issues takes place.
+
+In general, a new type is appropriate when new information is to be
+added to the database about an existing object, or we need new data
+formats for some totally new object.  Designers should attempt to define
+types and their RDATA formats that are generally applicable to all
+classes, and which avoid duplication of information.  New classes are
+appropriate when the DNS is to be used for a new protocol, etc which
+requires new class-specific data formats, or when a copy of the existing
+name space is desired, but a separate management domain is necessary.
+
+New types and classes need mnemonics for master files; the format of the
+master files requires that the mnemonics for type and class be disjoint.
+
+TYPE and CLASS values must be a proper subset of QTYPEs and QCLASSes
+respectively.
+
+The present system uses multiple RRs to represent multiple values of a
+type rather than storing multiple values in the RDATA section of a
+single RR.  This is less efficient for most applications, but does keep
+RRs shorter.  The multiple RRs assumption is incorporated in some
+experimental work on dynamic update methods.
+
+The present system attempts to minimize the duplication of data in the
+database in order to insure consistency.  Thus, in order to find the
+address of the host for a mail exchange, you map the mail domain name to
+a host name, then the host name to addresses, rather than a direct
+mapping to host address.  This approach is preferred because it avoids
+the opportunity for inconsistency.
+
+In defining a new type of data, multiple RR types should not be used to
+create an ordering between entries or express different formats for
+equivalent bindings, instead this information should be carried in the
+body of the RR and a single type used.  This policy avoids problems with
+caching multiple types and defining QTYPEs to match multiple types.
+
+For example, the original form of mail exchange binding used two RR
+types one to represent a "closer" exchange (MD) and one to represent a
+"less close" exchange (MF).  The difficulty is that the presence of one
+RR type in a cache doesn't convey any information about the other
+because the query which acquired the cached information might have used
+a QTYPE of MF, MD, or MAILA (which matched both).  The redesigned
+
+
+
+Mockapetris                                                    [Page 24]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+service used a single type (MX) with a "preference" value in the RDATA
+section which can order different RRs.  However, if any MX RRs are found
+in the cache, then all should be there.
+
+4. MESSAGES
+
+4.1. Format
+
+All communications inside of the domain protocol are carried in a single
+format called a message.  The top level format of message is divided
+into 5 sections (some of which are empty in certain cases) shown below:
+
+    +---------------------+
+    |        Header       |
+    +---------------------+
+    |       Question      | the question for the name server
+    +---------------------+
+    |        Answer       | RRs answering the question
+    +---------------------+
+    |      Authority      | RRs pointing toward an authority
+    +---------------------+
+    |      Additional     | RRs holding additional information
+    +---------------------+
+
+The header section is always present.  The header includes fields that
+specify which of the remaining sections are present, and also specify
+whether the message is a query or a response, a standard query or some
+other opcode, etc.
+
+The names of the sections after the header are derived from their use in
+standard queries.  The question section contains fields that describe a
+question to a name server.  These fields are a query type (QTYPE), a
+query class (QCLASS), and a query domain name (QNAME).  The last three
+sections have the same format: a possibly empty list of concatenated
+resource records (RRs).  The answer section contains RRs that answer the
+question; the authority section contains RRs that point toward an
+authoritative name server; the additional records section contains RRs
+which relate to the query, but are not strictly answers for the
+question.
+
+
+
+
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 25]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+4.1.1. Header section format
+
+The header contains the following fields:
+
+                                    1  1  1  1  1  1
+      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                      ID                       |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    QDCOUNT                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    ANCOUNT                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    NSCOUNT                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                    ARCOUNT                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+ID              A 16 bit identifier assigned by the program that
+                generates any kind of query.  This identifier is copied
+                the corresponding reply and can be used by the requester
+                to match up replies to outstanding queries.
+
+QR              A one bit field that specifies whether this message is a
+                query (0), or a response (1).
+
+OPCODE          A four bit field that specifies kind of query in this
+                message.  This value is set by the originator of a query
+                and copied into the response.  The values are:
+
+                0               a standard query (QUERY)
+
+                1               an inverse query (IQUERY)
+
+                2               a server status request (STATUS)
+
+                3-15            reserved for future use
+
+AA              Authoritative Answer - this bit is valid in responses,
+                and specifies that the responding name server is an
+                authority for the domain name in question section.
+
+                Note that the contents of the answer section may have
+                multiple owner names because of aliases.  The AA bit
+
+
+
+Mockapetris                                                    [Page 26]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+                corresponds to the name which matches the query name, or
+                the first owner name in the answer section.
+
+TC              TrunCation - specifies that this message was truncated
+                due to length greater than that permitted on the
+                transmission channel.
+
+RD              Recursion Desired - this bit may be set in a query and
+                is copied into the response.  If RD is set, it directs
+                the name server to pursue the query recursively.
+                Recursive query support is optional.
+
+RA              Recursion Available - this be is set or cleared in a
+                response, and denotes whether recursive query support is
+                available in the name server.
+
+Z               Reserved for future use.  Must be zero in all queries
+                and responses.
+
+RCODE           Response code - this 4 bit field is set as part of
+                responses.  The values have the following
+                interpretation:
+
+                0               No error condition
+
+                1               Format error - The name server was
+                                unable to interpret the query.
+
+                2               Server failure - The name server was
+                                unable to process this query due to a
+                                problem with the name server.
+
+                3               Name Error - Meaningful only for
+                                responses from an authoritative name
+                                server, this code signifies that the
+                                domain name referenced in the query does
+                                not exist.
+
+                4               Not Implemented - The name server does
+                                not support the requested kind of query.
+
+                5               Refused - The name server refuses to
+                                perform the specified operation for
+                                policy reasons.  For example, a name
+                                server may not wish to provide the
+                                information to the particular requester,
+                                or a name server may not wish to perform
+                                a particular operation (e.g., zone
+
+
+
+Mockapetris                                                    [Page 27]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+                                transfer) for particular data.
+
+                6-15            Reserved for future use.
+
+QDCOUNT         an unsigned 16 bit integer specifying the number of
+                entries in the question section.
+
+ANCOUNT         an unsigned 16 bit integer specifying the number of
+                resource records in the answer section.
+
+NSCOUNT         an unsigned 16 bit integer specifying the number of name
+                server resource records in the authority records
+                section.
+
+ARCOUNT         an unsigned 16 bit integer specifying the number of
+                resource records in the additional records section.
+
+4.1.2. Question section format
+
+The question section is used to carry the "question" in most queries,
+i.e., the parameters that define what is being asked.  The section
+contains QDCOUNT (usually 1) entries, each of the following format:
+
+                                    1  1  1  1  1  1
+      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                                               |
+    /                     QNAME                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                     QTYPE                     |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                     QCLASS                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+QNAME           a domain name represented as a sequence of labels, where
+                each label consists of a length octet followed by that
+                number of octets.  The domain name terminates with the
+                zero length octet for the null label of the root.  Note
+                that this field may be an odd number of octets; no
+                padding is used.
+
+QTYPE           a two octet code which specifies the type of the query.
+                The values for this field include all codes valid for a
+                TYPE field, together with some more general codes which
+                can match more than one type of RR.
+
+
+
+Mockapetris                                                    [Page 28]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+QCLASS          a two octet code that specifies the class of the query.
+                For example, the QCLASS field is IN for the Internet.
+
+4.1.3. Resource record format
+
+The answer, authority, and additional sections all share the same
+format: a variable number of resource records, where the number of
+records is specified in the corresponding count field in the header.
+Each resource record has the following format:
+                                    1  1  1  1  1  1
+      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                                               |
+    /                                               /
+    /                      NAME                     /
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                      TYPE                     |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                     CLASS                     |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                      TTL                      |
+    |                                               |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                   RDLENGTH                    |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
+    /                     RDATA                     /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+NAME            a domain name to which this resource record pertains.
+
+TYPE            two octets containing one of the RR type codes.  This
+                field specifies the meaning of the data in the RDATA
+                field.
+
+CLASS           two octets which specify the class of the data in the
+                RDATA field.
+
+TTL             a 32 bit unsigned integer that specifies the time
+                interval (in seconds) that the resource record may be
+                cached before it should be discarded.  Zero values are
+                interpreted to mean that the RR can only be used for the
+                transaction in progress, and should not be cached.
+
+
+
+
+
+Mockapetris                                                    [Page 29]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+RDLENGTH        an unsigned 16 bit integer that specifies the length in
+                octets of the RDATA field.
+
+RDATA           a variable length string of octets that describes the
+                resource.  The format of this information varies
+                according to the TYPE and CLASS of the resource record.
+                For example, the if the TYPE is A and the CLASS is IN,
+                the RDATA field is a 4 octet ARPA Internet address.
+
+4.1.4. Message compression
+
+In order to reduce the size of messages, the domain system utilizes a
+compression scheme which eliminates the repetition of domain names in a
+message.  In this scheme, an entire domain name or a list of labels at
+the end of a domain name is replaced with a pointer to a prior occurance
+of the same name.
+
+The pointer takes the form of a two octet sequence:
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    | 1  1|                OFFSET                   |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+The first two bits are ones.  This allows a pointer to be distinguished
+from a label, since the label must begin with two zero bits because
+labels are restricted to 63 octets or less.  (The 10 and 01 combinations
+are reserved for future use.)  The OFFSET field specifies an offset from
+the start of the message (i.e., the first octet of the ID field in the
+domain header).  A zero offset specifies the first byte of the ID field,
+etc.
+
+The compression scheme allows a domain name in a message to be
+represented as either:
+
+   - a sequence of labels ending in a zero octet
+
+   - a pointer
+
+   - a sequence of labels ending with a pointer
+
+Pointers can only be used for occurances of a domain name where the
+format is not class specific.  If this were not the case, a name server
+or resolver would be required to know the format of all RRs it handled.
+As yet, there are no such cases, but they may occur in future RDATA
+formats.
+
+If a domain name is contained in a part of the message subject to a
+length field (such as the RDATA section of an RR), and compression is
+
+
+
+Mockapetris                                                    [Page 30]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+used, the length of the compressed name is used in the length
+calculation, rather than the length of the expanded name.
+
+Programs are free to avoid using pointers in messages they generate,
+although this will reduce datagram capacity, and may cause truncation.
+However all programs are required to understand arriving messages that
+contain pointers.
+
+For example, a datagram might need to use the domain names F.ISI.ARPA,
+FOO.F.ISI.ARPA, ARPA, and the root.  Ignoring the other fields of the
+message, these domain names might be represented as:
+
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    20 |           1           |           F           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    22 |           3           |           I           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    24 |           S           |           I           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    26 |           4           |           A           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    28 |           R           |           P           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    30 |           A           |           0           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    40 |           3           |           F           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    42 |           O           |           O           |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    44 | 1  1|                20                       |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    64 | 1  1|                26                       |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    92 |           0           |                       |
+       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+The domain name for F.ISI.ARPA is shown at offset 20.  The domain name
+FOO.F.ISI.ARPA is shown at offset 40; this definition uses a pointer to
+concatenate a label for FOO to the previously defined F.ISI.ARPA.  The
+domain name ARPA is defined at offset 64 using a pointer to the ARPA
+component of the name F.ISI.ARPA at 20; note that this pointer relies on
+ARPA being the last label in the string at 20.  The root domain name is
+
+
+
+Mockapetris                                                    [Page 31]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+defined by a single octet of zeros at 92; the root domain name has no
+labels.
+
+4.2. Transport
+
+The DNS assumes that messages will be transmitted as datagrams or in a
+byte stream carried by a virtual circuit.  While virtual circuits can be
+used for any DNS activity, datagrams are preferred for queries due to
+their lower overhead and better performance.  Zone refresh activities
+must use virtual circuits because of the need for reliable transfer.
+
+The Internet supports name server access using TCP [RFC-793] on server
+port 53 (decimal) as well as datagram access using UDP [RFC-768] on UDP
+port 53 (decimal).
+
+4.2.1. UDP usage
+
+Messages sent using UDP user server port 53 (decimal).
+
+Messages carried by UDP are restricted to 512 bytes (not counting the IP
+or UDP headers).  Longer messages are truncated and the TC bit is set in
+the header.
+
+UDP is not acceptable for zone transfers, but is the recommended method
+for standard queries in the Internet.  Queries sent using UDP may be
+lost, and hence a retransmission strategy is required.  Queries or their
+responses may be reordered by the network, or by processing in name
+servers, so resolvers should not depend on them being returned in order.
+
+The optimal UDP retransmission policy will vary with performance of the
+Internet and the needs of the client, but the following are recommended:
+
+   - The client should try other servers and server addresses
+     before repeating a query to a specific address of a server.
+
+   - The retransmission interval should be based on prior
+     statistics if possible.  Too aggressive retransmission can
+     easily slow responses for the community at large.  Depending
+     on how well connected the client is to its expected servers,
+     the minimum retransmission interval should be 2-5 seconds.
+
+More suggestions on server selection and retransmission policy can be
+found in the resolver section of this memo.
+
+4.2.2. TCP usage
+
+Messages sent over TCP connections use server port 53 (decimal).  The
+message is prefixed with a two byte length field which gives the message
+
+
+
+Mockapetris                                                    [Page 32]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+length, excluding the two byte length field.  This length field allows
+the low-level processing to assemble a complete message before beginning
+to parse it.
+
+Several connection management policies are recommended:
+
+   - The server should not block other activities waiting for TCP
+     data.
+
+   - The server should support multiple connections.
+
+   - The server should assume that the client will initiate
+     connection closing, and should delay closing its end of the
+     connection until all outstanding client requests have been
+     satisfied.
+
+   - If the server needs to close a dormant connection to reclaim
+     resources, it should wait until the connection has been idle
+     for a period on the order of two minutes.  In particular, the
+     server should allow the SOA and AXFR request sequence (which
+     begins a refresh operation) to be made on a single connection.
+     Since the server would be unable to answer queries anyway, a
+     unilateral close or reset may be used instead of a graceful
+     close.
+
+5. MASTER FILES
+
+Master files are text files that contain RRs in text form.  Since the
+contents of a zone can be expressed in the form of a list of RRs a
+master file is most often used to define a zone, though it can be used
+to list a cache's contents.  Hence, this section first discusses the
+format of RRs in a master file, and then the special considerations when
+a master file is used to create a zone in some name server.
+
+5.1. Format
+
+The format of these files is a sequence of entries.  Entries are
+predominantly line-oriented, though parentheses can be used to continue
+a list of items across a line boundary, and text literals can contain
+CRLF within the text.  Any combination of tabs and spaces act as a
+delimiter between the separate items that make up an entry.  The end of
+any line in the master file can end with a comment.  The comment starts
+with a ";" (semicolon).
+
+The following entries are defined:
+
+    <blank>[<comment>]
+
+
+
+
+Mockapetris                                                    [Page 33]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+    $ORIGIN <domain-name> [<comment>]
+
+    $INCLUDE <file-name> [<domain-name>] [<comment>]
+
+    <domain-name><rr> [<comment>]
+
+    <blank><rr> [<comment>]
+
+Blank lines, with or without comments, are allowed anywhere in the file.
+
+Two control entries are defined: $ORIGIN and $INCLUDE.  $ORIGIN is
+followed by a domain name, and resets the current origin for relative
+domain names to the stated name.  $INCLUDE inserts the named file into
+the current file, and may optionally specify a domain name that sets the
+relative domain name origin for the included file.  $INCLUDE may also
+have a comment.  Note that a $INCLUDE entry never changes the relative
+origin of the parent file, regardless of changes to the relative origin
+made within the included file.
+
+The last two forms represent RRs.  If an entry for an RR begins with a
+blank, then the RR is assumed to be owned by the last stated owner.  If
+an RR entry begins with a <domain-name>, then the owner name is reset.
+
+<rr> contents take one of the following forms:
+
+    [<TTL>] [<class>] <type> <RDATA>
+
+    [<class>] [<TTL>] <type> <RDATA>
+
+The RR begins with optional TTL and class fields, followed by a type and
+RDATA field appropriate to the type and class.  Class and type use the
+standard mnemonics, TTL is a decimal integer.  Omitted class and TTL
+values are default to the last explicitly stated values.  Since type and
+class mnemonics are disjoint, the parse is unique.  (Note that this
+order is different from the order used in examples and the order used in
+the actual RRs; the given order allows easier parsing and defaulting.)
+
+<domain-name>s make up a large share of the data in the master file.
+The labels in the domain name are expressed as character strings and
+separated by dots.  Quoting conventions allow arbitrary characters to be
+stored in domain names.  Domain names that end in a dot are called
+absolute, and are taken as complete.  Domain names which do not end in a
+dot are called relative; the actual domain name is the concatenation of
+the relative part with an origin specified in a $ORIGIN, $INCLUDE, or as
+an argument to the master file loading routine.  A relative name is an
+error when no origin is available.
+
+
+
+
+
+Mockapetris                                                    [Page 34]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+<character-string> is expressed in one or two ways: as a contiguous set
+of characters without interior spaces, or as a string beginning with a "
+and ending with a ".  Inside a " delimited string any character can
+occur, except for a " itself, which must be quoted using \ (back slash).
+
+Because these files are text files several special encodings are
+necessary to allow arbitrary data to be loaded.  In particular:
+
+                of the root.
+
+@               A free standing @ is used to denote the current origin.
+
+\X              where X is any character other than a digit (0-9), is
+                used to quote that character so that its special meaning
+                does not apply.  For example, "\." can be used to place
+                a dot character in a label.
+
+\DDD            where each D is a digit is the octet corresponding to
+                the decimal number described by DDD.  The resulting
+                octet is assumed to be text and is not checked for
+                special meaning.
+
+( )             Parentheses are used to group data that crosses a line
+                boundary.  In effect, line terminations are not
+                recognized within parentheses.
+
+;               Semicolon is used to start a comment; the remainder of
+                the line is ignored.
+
+5.2. Use of master files to define zones
+
+When a master file is used to load a zone, the operation should be
+suppressed if any errors are encountered in the master file.  The
+rationale for this is that a single error can have widespread
+consequences.  For example, suppose that the RRs defining a delegation
+have syntax errors; then the server will return authoritative name
+errors for all names in the subzone (except in the case where the
+subzone is also present on the server).
+
+Several other validity checks that should be performed in addition to
+insuring that the file is syntactically correct:
+
+   1. All RRs in the file should have the same class.
+
+   2. Exactly one SOA RR should be present at the top of the zone.
+
+   3. If delegations are present and glue information is required,
+      it should be present.
+
+
+
+Mockapetris                                                    [Page 35]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+   4. Information present outside of the authoritative nodes in the
+      zone should be glue information, rather than the result of an
+      origin or similar error.
+
+5.3. Master file example
+
+The following is an example file which might be used to define the
+ISI.EDU zone.and is loaded with an origin of ISI.EDU:
+
+@   IN  SOA     VENERA      Action\.domains (
+                                 20     ; SERIAL
+                                 7200   ; REFRESH
+                                 600    ; RETRY
+                                 3600000; EXPIRE
+                                 60)    ; MINIMUM
+
+        NS      A.ISI.EDU.
+        NS      VENERA
+        NS      VAXA
+        MX      10      VENERA
+        MX      20      VAXA
+
+A       A       26.3.0.103
+
+VENERA  A       10.1.0.52
+        A       128.9.0.32
+
+VAXA    A       10.2.0.27
+        A       128.9.0.33
+
+
+$INCLUDE <SUBSYS>ISI-MAILBOXES.TXT
+
+Where the file <SUBSYS>ISI-MAILBOXES.TXT is:
+
+    MOE     MB      A.ISI.EDU.
+    LARRY   MB      A.ISI.EDU.
+    CURLEY  MB      A.ISI.EDU.
+    STOOGES MG      MOE
+            MG      LARRY
+            MG      CURLEY
+
+Note the use of the \ character in the SOA RR to specify the responsible
+person mailbox "Action.domains@E.ISI.EDU".
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 36]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+6. NAME SERVER IMPLEMENTATION
+
+6.1. Architecture
+
+The optimal structure for the name server will depend on the host
+operating system and whether the name server is integrated with resolver
+operations, either by supporting recursive service, or by sharing its
+database with a resolver.  This section discusses implementation
+considerations for a name server which shares a database with a
+resolver, but most of these concerns are present in any name server.
+
+6.1.1. Control
+
+A name server must employ multiple concurrent activities, whether they
+are implemented as separate tasks in the host's OS or multiplexing
+inside a single name server program.  It is simply not acceptable for a
+name server to block the service of UDP requests while it waits for TCP
+data for refreshing or query activities.  Similarly, a name server
+should not attempt to provide recursive service without processing such
+requests in parallel, though it may choose to serialize requests from a
+single client, or to regard identical requests from the same client as
+duplicates.  A name server should not substantially delay requests while
+it reloads a zone from master files or while it incorporates a newly
+refreshed zone into its database.
+
+6.1.2. Database
+
+While name server implementations are free to use any internal data
+structures they choose, the suggested structure consists of three major
+parts:
+
+   - A "catalog" data structure which lists the zones available to
+     this server, and a "pointer" to the zone data structure.  The
+     main purpose of this structure is to find the nearest ancestor
+     zone, if any, for arriving standard queries.
+
+   - Separate data structures for each of the zones held by the
+     name server.
+
+   - A data structure for cached data. (or perhaps separate caches
+     for different classes)
+
+All of these data structures can be implemented an identical tree
+structure format, with different data chained off the nodes in different
+parts: in the catalog the data is pointers to zones, while in the zone
+and cache data structures, the data will be RRs.  In designing the tree
+framework the designer should recognize that query processing will need
+to traverse the tree using case-insensitive label comparisons; and that
+
+
+
+Mockapetris                                                    [Page 37]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+in real data, a few nodes have a very high branching factor (100-1000 or
+more), but the vast majority have a very low branching factor (0-1).
+
+One way to solve the case problem is to store the labels for each node
+in two pieces: a standardized-case representation of the label where all
+ASCII characters are in a single case, together with a bit mask that
+denotes which characters are actually of a different case.  The
+branching factor diversity can be handled using a simple linked list for
+a node until the branching factor exceeds some threshold, and
+transitioning to a hash structure after the threshold is exceeded.  In
+any case, hash structures used to store tree sections must insure that
+hash functions and procedures preserve the casing conventions of the
+DNS.
+
+The use of separate structures for the different parts of the database
+is motivated by several factors:
+
+   - The catalog structure can be an almost static structure that
+     need change only when the system administrator changes the
+     zones supported by the server.  This structure can also be
+     used to store parameters used to control refreshing
+     activities.
+
+   - The individual data structures for zones allow a zone to be
+     replaced simply by changing a pointer in the catalog.  Zone
+     refresh operations can build a new structure and, when
+     complete, splice it into the database via a simple pointer
+     replacement.  It is very important that when a zone is
+     refreshed, queries should not use old and new data
+     simultaneously.
+
+   - With the proper search procedures, authoritative data in zones
+     will always "hide", and hence take precedence over, cached
+     data.
+
+   - Errors in zone definitions that cause overlapping zones, etc.,
+     may cause erroneous responses to queries, but problem
+     determination is simplified, and the contents of one "bad"
+     zone can't corrupt another.
+
+   - Since the cache is most frequently updated, it is most
+     vulnerable to corruption during system restarts.  It can also
+     become full of expired RR data.  In either case, it can easily
+     be discarded without disturbing zone data.
+
+A major aspect of database design is selecting a structure which allows
+the name server to deal with crashes of the name server's host.  State
+information which a name server should save across system crashes
+
+
+
+Mockapetris                                                    [Page 38]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+includes the catalog structure (including the state of refreshing for
+each zone) and the zone data itself.
+
+6.1.3. Time
+
+Both the TTL data for RRs and the timing data for refreshing activities
+depends on 32 bit timers in units of seconds.  Inside the database,
+refresh timers and TTLs for cached data conceptually "count down", while
+data in the zone stays with constant TTLs.
+
+A recommended implementation strategy is to store time in two ways:  as
+a relative increment and as an absolute time.  One way to do this is to
+use positive 32 bit numbers for one type and negative numbers for the
+other.  The RRs in zones use relative times; the refresh timers and
+cache data use absolute times.  Absolute numbers are taken with respect
+to some known origin and converted to relative values when placed in the
+response to a query.  When an absolute TTL is negative after conversion
+to relative, then the data is expired and should be ignored.
+
+6.2. Standard query processing
+
+The major algorithm for standard query processing is presented in
+[RFC-1034].
+
+When processing queries with QCLASS=*, or some other QCLASS which
+matches multiple classes, the response should never be authoritative
+unless the server can guarantee that the response covers all classes.
+
+When composing a response, RRs which are to be inserted in the
+additional section, but duplicate RRs in the answer or authority
+sections, may be omitted from the additional section.
+
+When a response is so long that truncation is required, the truncation
+should start at the end of the response and work forward in the
+datagram.  Thus if there is any data for the authority section, the
+answer section is guaranteed to be unique.
+
+The MINIMUM value in the SOA should be used to set a floor on the TTL of
+data distributed from a zone.  This floor function should be done when
+the data is copied into a response.  This will allow future dynamic
+update protocols to change the SOA MINIMUM field without ambiguous
+semantics.
+
+6.3. Zone refresh and reload processing
+
+In spite of a server's best efforts, it may be unable to load zone data
+from a master file due to syntax errors, etc., or be unable to refresh a
+zone within the its expiration parameter.  In this case, the name server
+
+
+
+Mockapetris                                                    [Page 39]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+should answer queries as if it were not supposed to possess the zone.
+
+If a master is sending a zone out via AXFR, and a new version is created
+during the transfer, the master should continue to send the old version
+if possible.  In any case, it should never send part of one version and
+part of another.  If completion is not possible, the master should reset
+the connection on which the zone transfer is taking place.
+
+6.4. Inverse queries (Optional)
+
+Inverse queries are an optional part of the DNS.  Name servers are not
+required to support any form of inverse queries.  If a name server
+receives an inverse query that it does not support, it returns an error
+response with the "Not Implemented" error set in the header.  While
+inverse query support is optional, all name servers must be at least
+able to return the error response.
+
+6.4.1. The contents of inverse queries and responses          Inverse
+queries reverse the mappings performed by standard query operations;
+while a standard query maps a domain name to a resource, an inverse
+query maps a resource to a domain name.  For example, a standard query
+might bind a domain name to a host address; the corresponding inverse
+query binds the host address to a domain name.
+
+Inverse queries take the form of a single RR in the answer section of
+the message, with an empty question section.  The owner name of the
+query RR and its TTL are not significant.  The response carries
+questions in the question section which identify all names possessing
+the query RR WHICH THE NAME SERVER KNOWS.  Since no name server knows
+about all of the domain name space, the response can never be assumed to
+be complete.  Thus inverse queries are primarily useful for database
+management and debugging activities.  Inverse queries are NOT an
+acceptable method of mapping host addresses to host names; use the IN-
+ADDR.ARPA domain instead.
+
+Where possible, name servers should provide case-insensitive comparisons
+for inverse queries.  Thus an inverse query asking for an MX RR of
+"Venera.isi.edu" should get the same response as a query for
+"VENERA.ISI.EDU"; an inverse query for HINFO RR "IBM-PC UNIX" should
+produce the same result as an inverse query for "IBM-pc unix".  However,
+this cannot be guaranteed because name servers may possess RRs that
+contain character strings but the name server does not know that the
+data is character.
+
+When a name server processes an inverse query, it either returns:
+
+   1. zero, one, or multiple domain names for the specified
+      resource as QNAMEs in the question section
+
+
+
+Mockapetris                                                    [Page 40]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+   2. an error code indicating that the name server doesn't support
+      inverse mapping of the specified resource type.
+
+When the response to an inverse query contains one or more QNAMEs, the
+owner name and TTL of the RR in the answer section which defines the
+inverse query is modified to exactly match an RR found at the first
+QNAME.
+
+RRs returned in the inverse queries cannot be cached using the same
+mechanism as is used for the replies to standard queries.  One reason
+for this is that a name might have multiple RRs of the same type, and
+only one would appear.  For example, an inverse query for a single
+address of a multiply homed host might create the impression that only
+one address existed.
+
+6.4.2. Inverse query and response example          The overall structure
+of an inverse query for retrieving the domain name that corresponds to
+Internet address 10.1.0.52 is shown below:
+
+                         +-----------------------------------------+
+           Header        |          OPCODE=IQUERY, ID=997          |
+                         +-----------------------------------------+
+          Question       |                 <empty>                 |
+                         +-----------------------------------------+
+           Answer        |        <anyname> A IN 10.1.0.52         |
+                         +-----------------------------------------+
+          Authority      |                 <empty>                 |
+                         +-----------------------------------------+
+         Additional      |                 <empty>                 |
+                         +-----------------------------------------+
+
+This query asks for a question whose answer is the Internet style
+address 10.1.0.52.  Since the owner name is not known, any domain name
+can be used as a placeholder (and is ignored).  A single octet of zero,
+signifying the root, is usually used because it minimizes the length of
+the message.  The TTL of the RR is not significant.  The response to
+this query might be:
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 41]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+                         +-----------------------------------------+
+           Header        |         OPCODE=RESPONSE, ID=997         |
+                         +-----------------------------------------+
+          Question       |QTYPE=A, QCLASS=IN, QNAME=VENERA.ISI.EDU |
+                         +-----------------------------------------+
+           Answer        |  VENERA.ISI.EDU  A IN 10.1.0.52         |
+                         +-----------------------------------------+
+          Authority      |                 <empty>                 |
+                         +-----------------------------------------+
+         Additional      |                 <empty>                 |
+                         +-----------------------------------------+
+
+Note that the QTYPE in a response to an inverse query is the same as the
+TYPE field in the answer section of the inverse query.  Responses to
+inverse queries may contain multiple questions when the inverse is not
+unique.  If the question section in the response is not empty, then the
+RR in the answer section is modified to correspond to be an exact copy
+of an RR at the first QNAME.
+
+6.4.3. Inverse query processing
+
+Name servers that support inverse queries can support these operations
+through exhaustive searches of their databases, but this becomes
+impractical as the size of the database increases.  An alternative
+approach is to invert the database according to the search key.
+
+For name servers that support multiple zones and a large amount of data,
+the recommended approach is separate inversions for each zone.  When a
+particular zone is changed during a refresh, only its inversions need to
+be redone.
+
+Support for transfer of this type of inversion may be included in future
+versions of the domain system, but is not supported in this version.
+
+6.5. Completion queries and responses
+
+The optional completion services described in RFC-882 and RFC-883 have
+been deleted.  Redesigned services may become available in the future.
+
+
+
+
+
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 42]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+7. RESOLVER IMPLEMENTATION
+
+The top levels of the recommended resolver algorithm are discussed in
+[RFC-1034].  This section discusses implementation details assuming the
+database structure suggested in the name server implementation section
+of this memo.
+
+7.1. Transforming a user request into a query
+
+The first step a resolver takes is to transform the client's request,
+stated in a format suitable to the local OS, into a search specification
+for RRs at a specific name which match a specific QTYPE and QCLASS.
+Where possible, the QTYPE and QCLASS should correspond to a single type
+and a single class, because this makes the use of cached data much
+simpler.  The reason for this is that the presence of data of one type
+in a cache doesn't confirm the existence or non-existence of data of
+other types, hence the only way to be sure is to consult an
+authoritative source.  If QCLASS=* is used, then authoritative answers
+won't be available.
+
+Since a resolver must be able to multiplex multiple requests if it is to
+perform its function efficiently, each pending request is usually
+represented in some block of state information.  This state block will
+typically contain:
+
+   - A timestamp indicating the time the request began.
+     The timestamp is used to decide whether RRs in the database
+     can be used or are out of date.  This timestamp uses the
+     absolute time format previously discussed for RR storage in
+     zones and caches.  Note that when an RRs TTL indicates a
+     relative time, the RR must be timely, since it is part of a
+     zone.  When the RR has an absolute time, it is part of a
+     cache, and the TTL of the RR is compared against the timestamp
+     for the start of the request.
+
+     Note that using the timestamp is superior to using a current
+     time, since it allows RRs with TTLs of zero to be entered in
+     the cache in the usual manner, but still used by the current
+     request, even after intervals of many seconds due to system
+     load, query retransmission timeouts, etc.
+
+   - Some sort of parameters to limit the amount of work which will
+     be performed for this request.
+
+     The amount of work which a resolver will do in response to a
+     client request must be limited to guard against errors in the
+     database, such as circular CNAME references, and operational
+     problems, such as network partition which prevents the
+
+
+
+Mockapetris                                                    [Page 43]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+     resolver from accessing the name servers it needs.  While
+     local limits on the number of times a resolver will retransmit
+     a particular query to a particular name server address are
+     essential, the resolver should have a global per-request
+     counter to limit work on a single request.  The counter should
+     be set to some initial value and decremented whenever the
+     resolver performs any action (retransmission timeout,
+     retransmission, etc.)  If the counter passes zero, the request
+     is terminated with a temporary error.
+
+     Note that if the resolver structure allows one request to
+     start others in parallel, such as when the need to access a
+     name server for one request causes a parallel resolve for the
+     name server's addresses, the spawned request should be started
+     with a lower counter.  This prevents circular references in
+     the database from starting a chain reaction of resolver
+     activity.
+
+   - The SLIST data structure discussed in [RFC-1034].
+
+     This structure keeps track of the state of a request if it
+     must wait for answers from foreign name servers.
+
+7.2. Sending the queries
+
+As described in [RFC-1034], the basic task of the resolver is to
+formulate a query which will answer the client's request and direct that
+query to name servers which can provide the information.  The resolver
+will usually only have very strong hints about which servers to ask, in
+the form of NS RRs, and may have to revise the query, in response to
+CNAMEs, or revise the set of name servers the resolver is asking, in
+response to delegation responses which point the resolver to name
+servers closer to the desired information.  In addition to the
+information requested by the client, the resolver may have to call upon
+its own services to determine the address of name servers it wishes to
+contact.
+
+In any case, the model used in this memo assumes that the resolver is
+multiplexing attention between multiple requests, some from the client,
+and some internally generated.  Each request is represented by some
+state information, and the desired behavior is that the resolver
+transmit queries to name servers in a way that maximizes the probability
+that the request is answered, minimizes the time that the request takes,
+and avoids excessive transmissions.  The key algorithm uses the state
+information of the request to select the next name server address to
+query, and also computes a timeout which will cause the next action
+should a response not arrive.  The next action will usually be a
+transmission to some other server, but may be a temporary error to the
+
+
+
+Mockapetris                                                    [Page 44]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+client.
+
+The resolver always starts with a list of server names to query (SLIST).
+This list will be all NS RRs which correspond to the nearest ancestor
+zone that the resolver knows about.  To avoid startup problems, the
+resolver should have a set of default servers which it will ask should
+it have no current NS RRs which are appropriate.  The resolver then adds
+to SLIST all of the known addresses for the name servers, and may start
+parallel requests to acquire the addresses of the servers when the
+resolver has the name, but no addresses, for the name servers.
+
+To complete initialization of SLIST, the resolver attaches whatever
+history information it has to the each address in SLIST.  This will
+usually consist of some sort of weighted averages for the response time
+of the address, and the batting average of the address (i.e., how often
+the address responded at all to the request).  Note that this
+information should be kept on a per address basis, rather than on a per
+name server basis, because the response time and batting average of a
+particular server may vary considerably from address to address.  Note
+also that this information is actually specific to a resolver address /
+server address pair, so a resolver with multiple addresses may wish to
+keep separate histories for each of its addresses.  Part of this step
+must deal with addresses which have no such history; in this case an
+expected round trip time of 5-10 seconds should be the worst case, with
+lower estimates for the same local network, etc.
+
+Note that whenever a delegation is followed, the resolver algorithm
+reinitializes SLIST.
+
+The information establishes a partial ranking of the available name
+server addresses.  Each time an address is chosen and the state should
+be altered to prevent its selection again until all other addresses have
+been tried.  The timeout for each transmission should be 50-100% greater
+than the average predicted value to allow for variance in response.
+
+Some fine points:
+
+   - The resolver may encounter a situation where no addresses are
+     available for any of the name servers named in SLIST, and
+     where the servers in the list are precisely those which would
+     normally be used to look up their own addresses.  This
+     situation typically occurs when the glue address RRs have a
+     smaller TTL than the NS RRs marking delegation, or when the
+     resolver caches the result of a NS search.  The resolver
+     should detect this condition and restart the search at the
+     next ancestor zone, or alternatively at the root.
+
+
+
+
+
+Mockapetris                                                    [Page 45]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+   - If a resolver gets a server error or other bizarre response
+     from a name server, it should remove it from SLIST, and may
+     wish to schedule an immediate transmission to the next
+     candidate server address.
+
+7.3. Processing responses
+
+The first step in processing arriving response datagrams is to parse the
+response.  This procedure should include:
+
+   - Check the header for reasonableness.  Discard datagrams which
+     are queries when responses are expected.
+
+   - Parse the sections of the message, and insure that all RRs are
+     correctly formatted.
+
+   - As an optional step, check the TTLs of arriving data looking
+     for RRs with excessively long TTLs.  If a RR has an
+     excessively long TTL, say greater than 1 week, either discard
+     the whole response, or limit all TTLs in the response to 1
+     week.
+
+The next step is to match the response to a current resolver request.
+The recommended strategy is to do a preliminary matching using the ID
+field in the domain header, and then to verify that the question section
+corresponds to the information currently desired.  This requires that
+the transmission algorithm devote several bits of the domain ID field to
+a request identifier of some sort.  This step has several fine points:
+
+   - Some name servers send their responses from different
+     addresses than the one used to receive the query.  That is, a
+     resolver cannot rely that a response will come from the same
+     address which it sent the corresponding query to.  This name
+     server bug is typically encountered in UNIX systems.
+
+   - If the resolver retransmits a particular request to a name
+     server it should be able to use a response from any of the
+     transmissions.  However, if it is using the response to sample
+     the round trip time to access the name server, it must be able
+     to determine which transmission matches the response (and keep
+     transmission times for each outgoing message), or only
+     calculate round trip times based on initial transmissions.
+
+   - A name server will occasionally not have a current copy of a
+     zone which it should have according to some NS RRs.  The
+     resolver should simply remove the name server from the current
+     SLIST, and continue.
+
+
+
+
+Mockapetris                                                    [Page 46]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+7.4. Using the cache
+
+In general, we expect a resolver to cache all data which it receives in
+responses since it may be useful in answering future client requests.
+However, there are several types of data which should not be cached:
+
+   - When several RRs of the same type are available for a
+     particular owner name, the resolver should either cache them
+     all or none at all.  When a response is truncated, and a
+     resolver doesn't know whether it has a complete set, it should
+     not cache a possibly partial set of RRs.
+
+   - Cached data should never be used in preference to
+     authoritative data, so if caching would cause this to happen
+     the data should not be cached.
+
+   - The results of an inverse query should not be cached.
+
+   - The results of standard queries where the QNAME contains "*"
+     labels if the data might be used to construct wildcards.  The
+     reason is that the cache does not necessarily contain existing
+     RRs or zone boundary information which is necessary to
+     restrict the application of the wildcard RRs.
+
+   - RR data in responses of dubious reliability.  When a resolver
+     receives unsolicited responses or RR data other than that
+     requested, it should discard it without caching it.  The basic
+     implication is that all sanity checks on a packet should be
+     performed before any of it is cached.
+
+In a similar vein, when a resolver has a set of RRs for some name in a
+response, and wants to cache the RRs, it should check its cache for
+already existing RRs.  Depending on the circumstances, either the data
+in the response or the cache is preferred, but the two should never be
+combined.  If the data in the response is from authoritative data in the
+answer section, it is always preferred.
+
+8. MAIL SUPPORT
+
+The domain system defines a standard for mapping mailboxes into domain
+names, and two methods for using the mailbox information to derive mail
+routing information.  The first method is called mail exchange binding
+and the other method is mailbox binding.  The mailbox encoding standard
+and mail exchange binding are part of the DNS official protocol, and are
+the recommended method for mail routing in the Internet.  Mailbox
+binding is an experimental feature which is still under development and
+subject to change.
+
+
+
+
+Mockapetris                                                    [Page 47]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+The mailbox encoding standard assumes a mailbox name of the form
+"<local-part>@<mail-domain>".  While the syntax allowed in each of these
+sections varies substantially between the various mail internets, the
+preferred syntax for the ARPA Internet is given in [RFC-822].
+
+The DNS encodes the <local-part> as a single label, and encodes the
+<mail-domain> as a domain name.  The single label from the <local-part>
+is prefaced to the domain name from <mail-domain> to form the domain
+name corresponding to the mailbox.  Thus the mailbox HOSTMASTER@SRI-
+NIC.ARPA is mapped into the domain name HOSTMASTER.SRI-NIC.ARPA.  If the
+<local-part> contains dots or other special characters, its
+representation in a master file will require the use of backslash
+quoting to ensure that the domain name is properly encoded.  For
+example, the mailbox Action.domains@ISI.EDU would be represented as
+Action\.domains.ISI.EDU.
+
+8.1. Mail exchange binding
+
+Mail exchange binding uses the <mail-domain> part of a mailbox
+specification to determine where mail should be sent.  The <local-part>
+is not even consulted.  [RFC-974] specifies this method in detail, and
+should be consulted before attempting to use mail exchange support.
+
+One of the advantages of this method is that it decouples mail
+destination naming from the hosts used to support mail service, at the
+cost of another layer of indirection in the lookup function.  However,
+the addition layer should eliminate the need for complicated "%", "!",
+etc encodings in <local-part>.
+
+The essence of the method is that the <mail-domain> is used as a domain
+name to locate type MX RRs which list hosts willing to accept mail for
+<mail-domain>, together with preference values which rank the hosts
+according to an order specified by the administrators for <mail-domain>.
+
+In this memo, the <mail-domain> ISI.EDU is used in examples, together
+with the hosts VENERA.ISI.EDU and VAXA.ISI.EDU as mail exchanges for
+ISI.EDU.  If a mailer had a message for Mockapetris@ISI.EDU, it would
+route it by looking up MX RRs for ISI.EDU.  The MX RRs at ISI.EDU name
+VENERA.ISI.EDU and VAXA.ISI.EDU, and type A queries can find the host
+addresses.
+
+8.2. Mailbox binding (Experimental)
+
+In mailbox binding, the mailer uses the entire mail destination
+specification to construct a domain name.  The encoded domain name for
+the mailbox is used as the QNAME field in a QTYPE=MAILB query.
+
+Several outcomes are possible for this query:
+
+
+
+Mockapetris                                                    [Page 48]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+   1. The query can return a name error indicating that the mailbox
+      does not exist as a domain name.
+
+      In the long term, this would indicate that the specified
+      mailbox doesn't exist.  However, until the use of mailbox
+      binding is universal, this error condition should be
+      interpreted to mean that the organization identified by the
+      global part does not support mailbox binding.  The
+      appropriate procedure is to revert to exchange binding at
+      this point.
+
+   2. The query can return a Mail Rename (MR) RR.
+
+      The MR RR carries new mailbox specification in its RDATA
+      field.  The mailer should replace the old mailbox with the
+      new one and retry the operation.
+
+   3. The query can return a MB RR.
+
+      The MB RR carries a domain name for a host in its RDATA
+      field.  The mailer should deliver the message to that host
+      via whatever protocol is applicable, e.g., b,SMTP.
+
+   4. The query can return one or more Mail Group (MG) RRs.
+
+      This condition means that the mailbox was actually a mailing
+      list or mail group, rather than a single mailbox.  Each MG RR
+      has a RDATA field that identifies a mailbox that is a member
+      of the group.  The mailer should deliver a copy of the
+      message to each member.
+
+   5. The query can return a MB RR as well as one or more MG RRs.
+
+      This condition means the the mailbox was actually a mailing
+      list.  The mailer can either deliver the message to the host
+      specified by the MB RR, which will in turn do the delivery to
+      all members, or the mailer can use the MG RRs to do the
+      expansion itself.
+
+In any of these cases, the response may include a Mail Information
+(MINFO) RR.  This RR is usually associated with a mail group, but is
+legal with a MB.  The MINFO RR identifies two mailboxes.  One of these
+identifies a responsible person for the original mailbox name.  This
+mailbox should be used for requests to be added to a mail group, etc.
+The second mailbox name in the MINFO RR identifies a mailbox that should
+receive error messages for mail failures.  This is particularly
+appropriate for mailing lists when errors in member names should be
+reported to a person other than the one who sends a message to the list.
+
+
+
+Mockapetris                                                    [Page 49]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+New fields may be added to this RR in the future.
+
+
+9. REFERENCES and BIBLIOGRAPHY
+
+[Dyer 87]       S. Dyer, F. Hsu, "Hesiod", Project Athena
+                Technical Plan - Name Service, April 1987, version 1.9.
+
+                Describes the fundamentals of the Hesiod name service.
+
+[IEN-116]       J. Postel, "Internet Name Server", IEN-116,
+                USC/Information Sciences Institute, August 1979.
+
+                A name service obsoleted by the Domain Name System, but
+                still in use.
+
+[Quarterman 86] J. Quarterman, and J. Hoskins, "Notable Computer Networks",
+                Communications of the ACM, October 1986, volume 29, number
+                10.
+
+[RFC-742]       K. Harrenstien, "NAME/FINGER", RFC-742, Network
+                Information Center, SRI International, December 1977.
+
+[RFC-768]       J. Postel, "User Datagram Protocol", RFC-768,
+                USC/Information Sciences Institute, August 1980.
+
+[RFC-793]       J. Postel, "Transmission Control Protocol", RFC-793,
+                USC/Information Sciences Institute, September 1981.
+
+[RFC-799]       D. Mills, "Internet Name Domains", RFC-799, COMSAT,
+                September 1981.
+
+                Suggests introduction of a hierarchy in place of a flat
+                name space for the Internet.
+
+[RFC-805]       J. Postel, "Computer Mail Meeting Notes", RFC-805,
+                USC/Information Sciences Institute, February 1982.
+
+[RFC-810]       E. Feinler, K. Harrenstien, Z. Su, and V. White, "DOD
+                Internet Host Table Specification", RFC-810, Network
+                Information Center, SRI International, March 1982.
+
+                Obsolete.  See RFC-952.
+
+[RFC-811]       K. Harrenstien, V. White, and E. Feinler, "Hostnames
+                Server", RFC-811, Network Information Center, SRI
+                International, March 1982.
+
+
+
+
+Mockapetris                                                    [Page 50]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+                Obsolete.  See RFC-953.
+
+[RFC-812]       K. Harrenstien, and V. White, "NICNAME/WHOIS", RFC-812,
+                Network Information Center, SRI International, March
+                1982.
+
+[RFC-819]       Z. Su, and J. Postel, "The Domain Naming Convention for
+                Internet User Applications", RFC-819, Network
+                Information Center, SRI International, August 1982.
+
+                Early thoughts on the design of the domain system.
+                Current implementation is completely different.
+
+[RFC-821]       J. Postel, "Simple Mail Transfer Protocol", RFC-821,
+                USC/Information Sciences Institute, August 1980.
+
+[RFC-830]       Z. Su, "A Distributed System for Internet Name Service",
+                RFC-830, Network Information Center, SRI International,
+                October 1982.
+
+                Early thoughts on the design of the domain system.
+                Current implementation is completely different.
+
+[RFC-882]       P. Mockapetris, "Domain names - Concepts and
+                Facilities," RFC-882, USC/Information Sciences
+                Institute, November 1983.
+
+                Superceeded by this memo.
+
+[RFC-883]       P. Mockapetris, "Domain names - Implementation and
+                Specification," RFC-883, USC/Information Sciences
+                Institute, November 1983.
+
+                Superceeded by this memo.
+
+[RFC-920]       J. Postel and J. Reynolds, "Domain Requirements",
+                RFC-920, USC/Information Sciences Institute,
+                October 1984.
+
+                Explains the naming scheme for top level domains.
+
+[RFC-952]       K. Harrenstien, M. Stahl, E. Feinler, "DoD Internet Host
+                Table Specification", RFC-952, SRI, October 1985.
+
+                Specifies the format of HOSTS.TXT, the host/address
+                table replaced by the DNS.
+
+
+
+
+
+Mockapetris                                                    [Page 51]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+[RFC-953]       K. Harrenstien, M. Stahl, E. Feinler, "HOSTNAME Server",
+                RFC-953, SRI, October 1985.
+
+                This RFC contains the official specification of the
+                hostname server protocol, which is obsoleted by the DNS.
+                This TCP based protocol accesses information stored in
+                the RFC-952 format, and is used to obtain copies of the
+                host table.
+
+[RFC-973]       P. Mockapetris, "Domain System Changes and
+                Observations", RFC-973, USC/Information Sciences
+                Institute, January 1986.
+
+                Describes changes to RFC-882 and RFC-883 and reasons for
+                them.
+
+[RFC-974]       C. Partridge, "Mail routing and the domain system",
+                RFC-974, CSNET CIC BBN Labs, January 1986.
+
+                Describes the transition from HOSTS.TXT based mail
+                addressing to the more powerful MX system used with the
+                domain system.
+
+[RFC-1001]      NetBIOS Working Group, "Protocol standard for a NetBIOS
+                service on a TCP/UDP transport: Concepts and Methods",
+                RFC-1001, March 1987.
+
+                This RFC and RFC-1002 are a preliminary design for
+                NETBIOS on top of TCP/IP which proposes to base NetBIOS
+                name service on top of the DNS.
+
+[RFC-1002]      NetBIOS Working Group, "Protocol standard for a NetBIOS
+                service on a TCP/UDP transport: Detailed
+                Specifications", RFC-1002, March 1987.
+
+[RFC-1010]      J. Reynolds, and J. Postel, "Assigned Numbers", RFC-1010,
+                USC/Information Sciences Institute, May 1987.
+
+                Contains socket numbers and mnemonics for host names,
+                operating systems, etc.
+
+[RFC-1031]      W. Lazear, "MILNET Name Domain Transition", RFC-1031,
+                November 1987.
+
+                Describes a plan for converting the MILNET to the DNS.
+
+[RFC-1032]      M. Stahl, "Establishing a Domain - Guidelines for
+                Administrators", RFC-1032, November 1987.
+
+
+
+Mockapetris                                                    [Page 52]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+                Describes the registration policies used by the NIC to
+                administer the top level domains and delegate subzones.
+
+[RFC-1033]      M. Lottor, "Domain Administrators Operations Guide",
+                RFC-1033, November 1987.
+
+                A cookbook for domain administrators.
+
+[Solomon 82]    M. Solomon, L. Landweber, and D. Neuhengen, "The CSNET
+                Name Server", Computer Networks, vol 6, nr 3, July 1982.
+
+                Describes a name service for CSNET which is independent
+                from the DNS and DNS use in the CSNET.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 53]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+Index
+
+          *   13
+
+          ;   33, 35
+
+          <character-string>   35
+          <domain-name>   34
+
+          @   35
+
+          \   35
+
+          A   12
+
+          Byte order   8
+
+          CH   13
+          Character case   9
+          CLASS   11
+          CNAME   12
+          Completion   42
+          CS   13
+
+          Hesiod   13
+          HINFO   12
+          HS   13
+
+          IN   13
+          IN-ADDR.ARPA domain   22
+          Inverse queries   40
+
+          Mailbox names   47
+          MB   12
+          MD   12
+          MF   12
+          MG   12
+          MINFO   12
+          MINIMUM   20
+          MR   12
+          MX   12
+
+          NS   12
+          NULL   12
+
+          Port numbers   32
+          Primary server   5
+          PTR   12, 18
+
+
+
+Mockapetris                                                    [Page 54]
+
+RFC 1035        Domain Implementation and Specification    November 1987
+
+
+          QCLASS   13
+          QTYPE   12
+
+          RDATA   12
+          RDLENGTH  11
+
+          Secondary server   5
+          SOA   12
+          Stub resolvers   7
+
+          TCP   32
+          TXT   12
+          TYPE   11
+
+          UDP   32
+
+          WKS   12
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Mockapetris                                                    [Page 55]
+

commit 5bb2816373b31c080a944dc957f3f38c1282aedf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 00:44:17 2008 +0100

    Add property for connection type

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index 7f3d940e..e2cf4746 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -17,7 +17,11 @@ Signals		PropertyChanged(string name, variant value)
 			This signal indicates a changed value of the given
 			property.
 
-Properties	string IPv4.Method [readonly]
+Properties	string Type [readonly]
+
+			The connection type (for example wifi etc.)
+
+		string IPv4.Method [readonly]
 
 			Indicates the way how the IPv4 settings were
 			configured. Possible values here are "dhcp"
diff --git a/src/element.c b/src/element.c
index 5081ff3e..d1e6de3e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -679,12 +679,13 @@ static DBusMessage *network_set_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static DBusMessage *get_connection_properties(DBusConnection *conn,
+static DBusMessage *connection_get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -699,6 +700,11 @@ static DBusMessage *get_connection_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = subtype2string(element->subtype);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
+
 	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);
@@ -724,7 +730,7 @@ static GDBusMethodTable network_methods[] = {
 };
 
 static GDBusMethodTable connection_methods[] = {
-	{ "GetProperties", "",   "a{sv}", get_connection_properties },
+	{ "GetProperties", "",   "a{sv}", connection_get_properties },
 	{ },
 };
 

commit ab0ef99eace3bff348b56cef74c62a1b1cfdaf72
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 00:55:10 2008 +0100

    Fix wrong subtype assignment within network devices

diff --git a/plugins/netdev.c b/plugins/netdev.c
index 226d633e..3e085346 100644
--- a/plugins/netdev.c
+++ b/plugins/netdev.c
@@ -41,6 +41,11 @@ static void create_element(struct connman_element *parent,
 	element->type = type;
 	element->index = parent->index;
 
+	if (parent->parent)
+		element->subtype = parent->parent->subtype;
+	else
+		element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+
 	connman_element_register(element, parent);
 }
 

commit b7ccda2018ca17b559d079503c49b330ea9d12f2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 01:18:09 2008 +0100

    Print more manager details

diff --git a/test/test-manager b/test/test-manager
index 0ae6a40f..5ed672aa 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -9,14 +9,30 @@ manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 
 properties = manager.GetProperties()
 
-def print_list(key, value):
-	text = ""
+def print_properties(key, value):
+	if (key == "Profiles"):
+		interface = "org.moblin.connman.Profile"
+	elif (key == "Devices"):
+		interface = "org.moblin.connman.Device"
+	elif (key == "Connections"):
+		interface = "org.moblin.connman.Connection"
+	else:
+		return
+
+	print "%s" % (key)
 	for path in value:
-		text = text + str(path) + " "
-	print "%s = %s" % (key, text)
+		print "    %s" % (path)
+		obj = dbus.Interface(bus.get_object("org.moblin.connman", path),
+								interface)
+
+		properties = obj.GetProperties()
+
+		for key in properties.keys():
+			print "        %s = %s" % (key, properties[key])
 
 for key in properties.keys():
 	if (key in ["Profiles", "Devices", "Connections"]):
-		print_list(key, properties[key])
+		print_properties(key, properties[key])
 	else:
-		print "%s = %s" % (key, properties[key])
+		print "%s" % (key)
+		print "    %s" % (properties[key])

commit 800c08ed4d45aa21f6540b49e34a8a36d44f2542
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 01:30:13 2008 +0100

    Print networks more prettier and easier to read

diff --git a/test/test-manager b/test/test-manager
index 5ed672aa..afeb110f 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -28,10 +28,19 @@ def print_properties(key, value):
 		properties = obj.GetProperties()
 
 		for key in properties.keys():
+			if (key == "Networks"):
+				continue
 			print "        %s = %s" % (key, properties[key])
 
+		if "Networks" in properties.keys():
+			list = ""
+			for path in properties["Networks"]:
+				val = str(path)
+				list = list + val[val.rfind("/") + 1:] + " "
+			print "        Networks = [ %s]" % (list)
+
 for key in properties.keys():
-	if (key in ["Profiles", "Devices", "Connections"]):
+	if key in ["Profiles", "Devices", "Connections"]:
 		print_properties(key, properties[key])
 	else:
 		print "%s" % (key)

commit 5f9427b70d3e710e02179f11d39e9407be049632
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 02:55:35 2008 +0100

    Handle signal strength property

diff --git a/test/test-manager b/test/test-manager
index afeb110f..c99b54ba 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -30,7 +30,13 @@ def print_properties(key, value):
 		for key in properties.keys():
 			if (key == "Networks"):
 				continue
-			print "        %s = %s" % (key, properties[key])
+
+			if (key == "Strength"):
+				val = int(properties[key])
+			else:
+				val = str(properties[key])
+
+			print "        %s = %s" % (key, val)
 
 		if "Networks" in properties.keys():
 			list = ""

commit 5ba07041179215daa35b2ea208ef5969ad8cf25f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 02:57:43 2008 +0100

    Add signal strength to connection objects

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index e2cf4746..7356b348 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -21,6 +21,12 @@ Properties	string Type [readonly]
 
 			The connection type (for example wifi etc.)
 
+		uint8 Strength [readonly]
+
+			Indicates the signal strength of the connection.
+
+			This property is optional and not always present.
+
 		string IPv4.Method [readonly]
 
 			Indicates the way how the IPv4 settings were
diff --git a/include/element.h b/include/element.h
index bc03011a..48e46f20 100644
--- a/include/element.h
+++ b/include/element.h
@@ -93,6 +93,7 @@ struct connman_element {
 	gboolean available;
 	gboolean remember;
 	guint16 priority;
+	guint8 strength;
 	gchar *devname;
 
 	struct connman_element *parent;
diff --git a/src/element.c b/src/element.c
index d1e6de3e..a78a2bed 100644
--- a/src/element.c
+++ b/src/element.c
@@ -705,6 +705,11 @@ static DBusMessage *connection_get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &str);
 
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX)
+		connman_dbus_dict_append_variant(&dict, "Strength",
+					DBUS_TYPE_BYTE, &element->strength);
+
 	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);
@@ -1739,6 +1744,20 @@ static void emit_state_change(DBusConnection *conn, const char *state)
 	g_dbus_send_message(conn, signal);
 }
 
+static void set_signal_strength(struct connman_element *connection)
+{
+	struct connman_element *element = connection;
+
+	while (element != NULL) {
+		if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
+			connection->strength = element->strength;
+			break;
+		}
+
+		element = element->parent;
+	}
+}
+
 static void register_element(gpointer data, gpointer user_data)
 {
 	struct connman_element *element = data;
@@ -1805,6 +1824,7 @@ static void register_element(gpointer data, gpointer user_data)
 			connman_error("Failed to register %s connection",
 								element->path);
 		else {
+			set_signal_strength(element);
 			emit_connections_signal(connection);
 			emit_state_change(connection, "online");
 		}

commit 1020d4fff525b3618d19b9ad178fcca0da3ebc55
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 02:58:16 2008 +0100

    Make signal strength value available

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 70e19e9d..1a057a9b 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -299,7 +299,6 @@ static void scan_result(struct connman_element *device,
 {
 	struct wifi_data *data = connman_element_get_data(device);
 	struct connman_element *element;
-	guint8 strength = network->quality;
 	gchar *temp;
 	int i;
 
@@ -351,18 +350,22 @@ static void scan_result(struct connman_element *device,
 			element->wifi.security = g_strdup(security);
 		}
 
+		element->strength = network->quality;
+
 		connman_element_add_static_property(element, "Strength",
-						DBUS_TYPE_BYTE, &strength);
+					DBUS_TYPE_BYTE, &element->strength);
 
 		DBG("%s (%s) strength %d", network->identifier,
-					element->wifi.security, strength);
+				element->wifi.security, element->strength);
 
 		connman_element_register(element, device);
 	} else {
 		data->pending = g_slist_remove(data->pending, element);
 
+		element->strength = network->quality;
+
 		connman_element_set_static_property(element, "Strength",
-						DBUS_TYPE_BYTE, &strength);
+					DBUS_TYPE_BYTE, &element->strength);
 	}
 
 	data->current = g_slist_append(data->current, element);

commit 305e8edb2cb751597b8bbafd40acf10c57b32454
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 03:17:31 2008 +0100

    Trigger update process after scan results

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 1a057a9b..4459a27c 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -366,6 +366,8 @@ static void scan_result(struct connman_element *device,
 
 		connman_element_set_static_property(element, "Strength",
 					DBUS_TYPE_BYTE, &element->strength);
+
+		connman_element_update(element);
 	}
 
 	data->current = g_slist_append(data->current, element);

commit 9d1ab587994ff1cab91c4cace94ed76114059a50
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 03:18:38 2008 +0100

    Indicate when signal strength of connection changes

diff --git a/src/element.c b/src/element.c
index a78a2bed..72f4026a 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1139,6 +1139,9 @@ static void emit_property_changed(DBusConnection *conn,
 	case CONNMAN_ELEMENT_TYPE_NETWORK:
 		iface = CONNMAN_NETWORK_INTERFACE;
 		break;
+	case CONNMAN_ELEMENT_TYPE_CONNECTION:
+		iface = CONNMAN_CONNECTION_INTERFACE;
+		break;
 	default:
 		return;
 	}
@@ -1984,12 +1987,22 @@ void connman_element_unregister_children(struct connman_element *element)
 static gboolean update_element(GNode *node, gpointer user_data)
 {
 	struct connman_element *element = node->data;
+	struct connman_element *root = user_data;
 
 	DBG("element %p name %s", element, element->name);
 
 	if (element->driver && element->driver->update)
 		element->driver->update(element);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION &&
+				root->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
+		if (element->strength != root->strength) {
+			element->strength = root->strength;
+			emit_property_changed(connection, element, "Strength",
+					DBUS_TYPE_BYTE, &element->strength);
+		}
+	}
+
 	return FALSE;
 }
 
@@ -2003,7 +2016,7 @@ void connman_element_update(struct connman_element *element)
 
 	if (node != NULL)
 		g_node_traverse(node, G_PRE_ORDER,
-				G_TRAVERSE_ALL, -1, update_element, NULL);
+				G_TRAVERSE_ALL, -1, update_element, element);
 }
 
 int connman_element_set_enabled(struct connman_element *element,

commit 91b02d3430e53b5bf7d974e37cd60102a93f92ad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 03:24:03 2008 +0100

    Only update signal strength when it changes

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 4459a27c..b7eea7b1 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -362,12 +362,14 @@ static void scan_result(struct connman_element *device,
 	} else {
 		data->pending = g_slist_remove(data->pending, element);
 
-		element->strength = network->quality;
+		if (element->strength != network->quality) {
+			element->strength = network->quality;
 
-		connman_element_set_static_property(element, "Strength",
+			connman_element_set_static_property(element, "Strength",
 					DBUS_TYPE_BYTE, &element->strength);
 
-		connman_element_update(element);
+			connman_element_update(element);
+		}
 	}
 
 	data->current = g_slist_append(data->current, element);

commit 8a714e90ed686264d17e4eddd343c91075d10f27
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 03:41:03 2008 +0100

    Only connect known networks when in inactive state

diff --git a/plugins/wifi.c b/plugins/wifi.c
index b7eea7b1..9cddb61d 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -247,7 +247,7 @@ static void state_change(struct connman_element *device,
 	}
 
 reconnect:
-	if (state == STATE_INACTIVE || state == STATE_DISCONNECTED) {
+	if (state == STATE_INACTIVE) {
 		data->connected = FALSE;
 		connect_known_networks(device);
 	}

commit 273799ecfabe3d3a696dda38d8a400fac08d12d0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 04:05:18 2008 +0100

    Add directory for client application

diff --git a/Makefile.am b/Makefile.am
index 0b875b7d..78c98b87 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = gdbus include src plugins scripts test doc
+SUBDIRS = gdbus include src plugins client scripts test doc
 
 pkgconfigdir = $(libdir)/pkgconfig
 
diff --git a/client/Makefile.am b/client/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/client/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in
diff --git a/configure.ac b/configure.ac
index 0a10c57b..c5a7a1de 100644
--- a/configure.ac
+++ b/configure.ac
@@ -89,5 +89,5 @@ AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")
 
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile src/Makefile doc/Makefile
-		test/Makefile plugins/Makefile scripts/Makefile scripts/connman
-				src/connman.service doc/version.xml connman.pc)
+		test/Makefile plugins/Makefile client/Makefile scripts/Makefile
+		scripts/connman src/connman.service doc/version.xml connman.pc)

commit 09959bf44d59941446f11980dcaf3aa1061edc13
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 04:09:20 2008 +0100

    Fix error handling of init routine

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index bc61d519..39eefec8 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -368,12 +368,10 @@ static int dnsproxy_init(void)
 		return err;
 
 	err = connman_resolver_register(&dnsproxy_resolver);
-	if (err < 0) {
+	if (err < 0)
 		destroy_listener();
-		return err;
-	}
 
-	return 0;
+	return err;
 }
 
 static void dnsproxy_exit(void)

commit 0323435d73aeaf0dea25e40e7b41bf6d1a4534f3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 04:59:36 2008 +0100

    Add support for IPv4.Broadcast property

diff --git a/include/property.h b/include/property.h
index 4c42f445..fe734c26 100644
--- a/include/property.h
+++ b/include/property.h
@@ -39,6 +39,7 @@ enum connman_property_id {
 	CONNMAN_PROPERTY_ID_IPV4_ADDRESS,
 	CONNMAN_PROPERTY_ID_IPV4_NETMASK,
 	CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
+	CONNMAN_PROPERTY_ID_IPV4_BROADCAST,
 	CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 
 	CONNMAN_PROPERTY_ID_WIFI_SECURITY,
diff --git a/src/element.c b/src/element.c
index 72f4026a..9f59de03 100644
--- a/src/element.c
+++ b/src/element.c
@@ -52,6 +52,8 @@ static struct {
 		DBUS_TYPE_STRING, "IPv4.Netmask" },
 	{ CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
 		DBUS_TYPE_STRING, "IPv4.Gateway" },
+	{ CONNMAN_PROPERTY_ID_IPV4_BROADCAST,
+		DBUS_TYPE_STRING, "IPv4.Broadcast" },
 	{ CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 		DBUS_TYPE_STRING, "IPv4.Nameserver" },
 
@@ -1436,6 +1438,12 @@ int connman_element_set_property(struct connman_element *element,
 		element->ipv4.gateway = g_strdup(*((const char **) value));
 		__connman_element_unlock(element);
 		break;
+	case CONNMAN_PROPERTY_ID_IPV4_BROADCAST:
+		__connman_element_lock(element);
+		g_free(element->ipv4.broadcast);
+		element->ipv4.broadcast = g_strdup(*((const char **) value));
+		__connman_element_unlock(element);
+		break;
 	case CONNMAN_PROPERTY_ID_IPV4_NAMESERVER:
 		__connman_element_lock(element);
 		g_free(element->ipv4.nameserver);
@@ -1492,6 +1500,14 @@ int connman_element_get_value(struct connman_element *element,
 		*((char **) value) = element->ipv4.gateway;
 		__connman_element_unlock(element);
 		break;
+	case CONNMAN_PROPERTY_ID_IPV4_BROADCAST:
+		if (element->ipv4.broadcast == NULL)
+			return connman_element_get_value(element->parent,
+								id, value);
+		__connman_element_lock(element);
+		*((char **) value) = element->ipv4.broadcast;
+		__connman_element_unlock(element);
+		break;
 	case CONNMAN_PROPERTY_ID_IPV4_NAMESERVER:
 		if (element->ipv4.nameserver == NULL)
 			return connman_element_get_value(element->parent,

commit 97fc312c6036c72eb392dcefe080e30404673f18
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 07:49:43 2008 +0100

    Add support RTNL gateway change notifications

diff --git a/include/rtnl.h b/include/rtnl.h
index 395d20bc..5637fb9d 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -43,12 +43,15 @@ struct connman_rtnl {
 					unsigned flags, unsigned change);
 	void (*dellink) (unsigned short type, int index,
 					unsigned flags, unsigned change);
+	void (*newgateway) (int index, const char *gateway);
+	void (*delgateway) (int index, const char *gateway);
 };
 
 extern int connman_rtnl_register(struct connman_rtnl *rtnl);
 extern void connman_rtnl_unregister(struct connman_rtnl *rtnl);
 
 int connman_rtnl_send_getlink(void);
+int connman_rtnl_send_getroute(void);
 
 #ifdef __cplusplus
 }
diff --git a/src/rtnl.c b/src/rtnl.c
index ece4f165..e3584065 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -82,8 +82,6 @@ static void process_newlink(unsigned short type, int index,
 {
 	GSList *list;
 
-	DBG("index %d", index);
-
 	for (list = rtnl_list; list; list = list->next) {
 		struct connman_rtnl *rtnl = list->data;
 
@@ -97,8 +95,6 @@ static void process_dellink(unsigned short type, int index,
 {
 	GSList *list;
 
-	DBG("index %d", index);
-
 	for (list = rtnl_list; list; list = list->next) {
 		struct connman_rtnl *rtnl = list->data;
 
@@ -107,6 +103,69 @@ static void process_dellink(unsigned short type, int index,
 	}
 }
 
+static char *extract_gateway(struct rtmsg *msg, int bytes, int *index)
+{
+	char *gateway = NULL;
+	struct in_addr addr;
+	struct rtattr *attr;
+
+	for (attr = RTM_RTA(msg); RTA_OK(attr, bytes);
+					attr = RTA_NEXT(attr, bytes)) {
+		switch (attr->rta_type) {
+		case RTA_GATEWAY:
+			addr = *((struct in_addr *) RTA_DATA(attr));
+			g_free(gateway);
+			gateway = g_strdup(inet_ntoa(addr));
+			break;
+		case RTA_OIF:
+			*index = *((int *) RTA_DATA(attr));
+			break;
+		}
+	}
+
+	return gateway;
+}
+
+static void process_newgateway(struct rtmsg *msg, int bytes)
+{
+	int index = -1;
+	char *gateway;
+	GSList *list;
+
+	gateway = extract_gateway(msg, bytes, &index);
+	if (gateway == NULL || index < 0)
+		return;
+
+	for (list = rtnl_list; list; list = list->next) {
+		struct connman_rtnl *rtnl = list->data;
+
+		if (rtnl->newgateway)
+			rtnl->newgateway(index, gateway);
+	}
+
+	g_free(gateway);
+}
+
+static void process_delgateway(struct rtmsg *msg, int bytes)
+{
+	int index = -1;
+	char *gateway;
+	GSList *list;
+
+	gateway = extract_gateway(msg, bytes, &index);
+	if (gateway == NULL || index < 0)
+		return;
+
+	for (list = rtnl_list; list; list = list->next) {
+		struct connman_rtnl *rtnl = list->data;
+
+		if (rtnl->delgateway)
+			rtnl->delgateway(index, gateway);
+	}
+
+	g_free(gateway);
+}
+
 static inline void print_inet(struct rtattr *attr, const char *name, int family)
 {
 	if (family == AF_INET) {
@@ -219,7 +278,9 @@ static void rtnl_newlink(struct nlmsghdr *hdr)
 
 	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
 
-	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
+	DBG("ifi_type %d ifi_index %d ifi_flags 0x%04x ifi_change 0x%04x",
+					msg->ifi_type, msg->ifi_index,
+					msg->ifi_flags, msg->ifi_change);
 
 	process_newlink(msg->ifi_type, msg->ifi_index,
 					msg->ifi_flags, msg->ifi_change);
@@ -233,7 +294,9 @@ static void rtnl_dellink(struct nlmsghdr *hdr)
 
 	msg = (struct ifinfomsg *) NLMSG_DATA(hdr);
 
-	DBG("ifi_index %d ifi_flags 0x%04x", msg->ifi_index, msg->ifi_flags);
+	DBG("ifi_type %d ifi_index %d ifi_flags 0x%04x ifi_change 0x%04x",
+					msg->ifi_type, msg->ifi_index,
+					msg->ifi_flags, msg->ifi_change);
 
 	process_dellink(msg->ifi_type, msg->ifi_index,
 					msg->ifi_flags, msg->ifi_change);
@@ -285,6 +348,7 @@ static void rtnl_addr(struct nlmsghdr *hdr)
 
 static void rtnl_route(struct nlmsghdr *hdr)
 {
+#if 0
 	struct rtmsg *msg;
 	struct rtattr *attr;
 	int bytes;
@@ -329,6 +393,146 @@ static void rtnl_route(struct nlmsghdr *hdr)
 			break;
 		}
 	}
+#endif
+}
+
+static void rtnl_newroute(struct nlmsghdr *hdr)
+{
+	struct rtmsg *msg;
+
+	msg = (struct rtmsg *) NLMSG_DATA(hdr);
+
+	if (msg->rtm_type == RTN_UNICAST && msg->rtm_table == RT_TABLE_MAIN &&
+					msg->rtm_scope == RT_SCOPE_UNIVERSE) {
+		DBG("rtm_table %d rtm_scope %d rtm_type %d rtm_flags 0x%04x",
+					msg->rtm_table, msg->rtm_scope,
+					msg->rtm_type, msg->rtm_flags);
+		process_newgateway(msg, RTM_PAYLOAD(hdr));
+	}
+
+	rtnl_route(hdr);
+}
+
+static void rtnl_delroute(struct nlmsghdr *hdr)
+{
+	struct rtmsg *msg;
+
+	msg = (struct rtmsg *) NLMSG_DATA(hdr);
+
+	if (msg->rtm_type == RTN_UNICAST && msg->rtm_table == RT_TABLE_MAIN &&
+					msg->rtm_scope == RT_SCOPE_UNIVERSE) {
+		DBG("rtm_table %d rtm_scope %d rtm_type %d rtm_flags 0x%04x",
+					msg->rtm_table, msg->rtm_scope,
+					msg->rtm_type, msg->rtm_flags);
+		process_delgateway(msg, RTM_PAYLOAD(hdr));
+	}
+
+	rtnl_route(hdr);
+}
+
+static const char *type2string(uint16_t type)
+{
+	switch (type) {
+	case NLMSG_NOOP:
+		return "NOOP";
+	case NLMSG_ERROR:
+		return "ERROR";
+	case NLMSG_DONE:
+		return "DONE";
+	case NLMSG_OVERRUN:
+		return "OVERRUN";
+	case RTM_GETLINK:
+		return "GETLINK";
+	case RTM_NEWLINK:
+		return "NEWLINK";
+	case RTM_DELLINK:
+		return "DELLINK";
+	case RTM_NEWADDR:
+		return "NEWADDR";
+	case RTM_DELADDR:
+		return "DELADDR";
+	case RTM_GETROUTE:
+		return "GETROUTE";
+	case RTM_NEWROUTE:
+		return "NEWROUTE";
+	case RTM_DELROUTE:
+		return "DELROUTE";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+static GIOChannel *channel = NULL;
+
+struct rtnl_request {
+	struct nlmsghdr hdr;
+	struct rtgenmsg msg;
+};
+#define RTNL_REQUEST_SIZE  (sizeof(struct nlmsghdr) + sizeof(struct rtgenmsg))
+
+static GSList *request_list = NULL;
+static guint32 request_seq = 0;
+
+static struct rtnl_request *find_request(guint32 seq)
+{
+	GSList *list;
+
+	for (list = request_list; list; list = list->next) {
+		struct rtnl_request *req = list->data;
+
+		if (req->hdr.nlmsg_seq == seq)
+			return req;
+	}
+
+	return NULL;
+}
+
+static int send_request(struct rtnl_request *req)
+{
+	struct sockaddr_nl addr;
+	int sk;
+
+	DBG("%s len %d type %d flags 0x%04x seq %d",
+				type2string(req->hdr.nlmsg_type),
+				req->hdr.nlmsg_len, req->hdr.nlmsg_type,
+				req->hdr.nlmsg_flags, req->hdr.nlmsg_seq);
+
+	sk = g_io_channel_unix_get_fd(channel);
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+
+	return sendto(sk, req, req->hdr.nlmsg_len, 0,
+				(struct sockaddr *) &addr, sizeof(addr));
+}
+
+static int queue_request(struct rtnl_request *req)
+{
+	request_list = g_slist_append(request_list, req);
+
+	if (g_slist_length(request_list) > 1)
+		return 0;
+
+	return send_request(req);
+}
+
+static int process_response(guint32 seq)
+{
+	struct rtnl_request *req;
+
+	DBG("seq %d", seq);
+
+	req = find_request(seq);
+	if (req != NULL) {
+		request_list = g_slist_remove(request_list, req);
+		g_free(req);
+	}
+
+	req = g_slist_nth_data(request_list, 0);
+	if (req == NULL)
+		return 0;
+
+	return send_request(req);
 }
 
 static void rtnl_message(void *buf, size_t len)
@@ -342,51 +546,38 @@ static void rtnl_message(void *buf, size_t len)
 		if (!NLMSG_OK(hdr, len))
 			break;
 
-		DBG("len %d type %d flags 0x%04x seq %d",
+		DBG("%s len %d type %d flags 0x%04x seq %d",
+					type2string(hdr->nlmsg_type),
 					hdr->nlmsg_len, hdr->nlmsg_type,
 					hdr->nlmsg_flags, hdr->nlmsg_seq);
 
 		switch (hdr->nlmsg_type) {
 		case NLMSG_NOOP:
-			DBG("NOOP");
+		case NLMSG_OVERRUN:
+			return;
+		case NLMSG_DONE:
+			process_response(hdr->nlmsg_seq);
 			return;
 		case NLMSG_ERROR:
 			err = NLMSG_DATA(hdr);
-			DBG("ERROR %d (%s)", -err->error,
+			DBG("error %d (%s)", -err->error,
 						strerror(-err->error));
 			return;
-		case NLMSG_DONE:
-			DBG("DONE");
-			return;
-		case NLMSG_OVERRUN:
-			DBG("OVERRUN");
-			return;
 		case RTM_NEWLINK:
-			DBG("NEWLINK");
 			rtnl_newlink(hdr);
 			break;
 		case RTM_DELLINK:
-			DBG("DELLINK");
 			rtnl_dellink(hdr);
 			break;
 		case RTM_NEWADDR:
-			DBG("NEWADDR");
-			rtnl_addr(hdr);
-			break;
 		case RTM_DELADDR:
-			DBG("DELADDR");
 			rtnl_addr(hdr);
 			break;
 		case RTM_NEWROUTE:
-			DBG("NEWROUTE");
-			rtnl_route(hdr);
+			rtnl_newroute(hdr);
 			break;
 		case RTM_DELROUTE:
-			DBG("DELROUTE");
-			rtnl_route(hdr);
-			break;
-		default:
-			DBG("type %d", hdr->nlmsg_type);
+			rtnl_delroute(hdr);
 			break;
 		}
 
@@ -419,42 +610,44 @@ static gboolean netlink_event(GIOChannel *chan,
 	return TRUE;
 }
 
-static GIOChannel *channel = NULL;
-
-int __connman_rtnl_send(const void *buf, size_t len)
+int connman_rtnl_send_getlink(void)
 {
-	struct sockaddr_nl addr;
-	int sk;
+	struct rtnl_request *req;
 
-	DBG("buf %p len %zd", buf, len);
+	DBG("");
 
-	sk = g_io_channel_unix_get_fd(channel);
+	req = g_try_malloc0(RTNL_REQUEST_SIZE);
+	if (req == NULL)
+		return -ENOMEM;
 
-	memset(&addr, 0, sizeof(addr));
-	addr.nl_family = AF_NETLINK;
+	req->hdr.nlmsg_len = RTNL_REQUEST_SIZE;
+	req->hdr.nlmsg_type = RTM_GETLINK;
+	req->hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
+	req->hdr.nlmsg_pid = 0;
+	req->hdr.nlmsg_seq = request_seq++;
+	req->msg.rtgen_family = AF_INET;
 
-	return sendto(sk, buf, len, 0,
-			(struct sockaddr *) &addr, sizeof(addr));
+	return queue_request(req);
 }
 
-int connman_rtnl_send_getlink(void)
+int connman_rtnl_send_getroute(void)
 {
-	struct {
-		struct nlmsghdr hdr;
-		struct rtgenmsg msg;
-	} req;
+	struct rtnl_request *req;
 
 	DBG("");
 
-	memset(&req, 0, sizeof(req));
-	req.hdr.nlmsg_len = sizeof(req.hdr) + sizeof(req.msg);
-	req.hdr.nlmsg_type = RTM_GETLINK;
-	req.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
-	req.hdr.nlmsg_pid = 0;
-	req.hdr.nlmsg_seq = 42;
-	req.msg.rtgen_family = AF_INET;
+	req = g_try_malloc0(RTNL_REQUEST_SIZE);
+	if (req == NULL)
+		return -ENOMEM;
 
-	return __connman_rtnl_send(&req, sizeof(req));
+	req->hdr.nlmsg_len = RTNL_REQUEST_SIZE;
+	req->hdr.nlmsg_type = RTM_GETROUTE;
+	req->hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
+	req->hdr.nlmsg_pid = 0;
+	req->hdr.nlmsg_seq = request_seq++;
+	req->msg.rtgen_family = AF_INET;
+
+	return queue_request(req);
 }
 
 int __connman_rtnl_init(void)
@@ -470,7 +663,7 @@ int __connman_rtnl_init(void)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.nl_family = AF_NETLINK;
-	addr.nl_groups = RTMGRP_LINK;
+	addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_ROUTE;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
 	//addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;
 
@@ -490,8 +683,25 @@ int __connman_rtnl_init(void)
 
 void __connman_rtnl_cleanup(void)
 {
+	GSList *list;
+
 	DBG("");
 
+	for (list = request_list; list; list = list->next) {
+		struct rtnl_request *req = list->data;
+
+		DBG("%s len %d type %d flags 0x%04x seq %d",
+				type2string(req->hdr.nlmsg_type),
+				req->hdr.nlmsg_len, req->hdr.nlmsg_type,
+				req->hdr.nlmsg_flags, req->hdr.nlmsg_seq);
+
+		g_free(req);
+		list->data = NULL;
+	}
+
+	g_slist_free(request_list);
+	request_list = NULL;
+
 	g_io_channel_shutdown(channel, TRUE, NULL);
 	g_io_channel_unref(channel);
 

commit 3bbee5b2cc7b77a044ea32f46a4469d0b5cdddf2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 08:09:03 2008 +0100

    Add property to indicate default connections

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index 7356b348..c39c6d29 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -27,6 +27,11 @@ Properties	string Type [readonly]
 
 			This property is optional and not always present.
 
+		boolean Default [readonly]
+
+			Indicates if it is a default connection. It is
+			possible to have multiple default connections.
+
 		string IPv4.Method [readonly]
 
 			Indicates the way how the IPv4 settings were
diff --git a/src/element.c b/src/element.c
index 9f59de03..1b1e61dc 100644
--- a/src/element.c
+++ b/src/element.c
@@ -330,6 +330,10 @@ static void emit_enabled_signal(DBusConnection *conn,
 		iface = CONNMAN_NETWORK_INTERFACE;
 		key = "Connected";
 		break;
+	case CONNMAN_ELEMENT_TYPE_CONNECTION:
+		iface = CONNMAN_CONNECTION_INTERFACE;
+		key = "Default";
+		break;
 	default:
 		return;
 	}
@@ -712,6 +716,9 @@ static DBusMessage *connection_get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Strength",
 					DBUS_TYPE_BYTE, &element->strength);
 
+	connman_dbus_dict_append_variant(&dict, "Default",
+					DBUS_TYPE_BOOLEAN, &element->enabled);
+
 	add_common_properties(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);

commit 6d80d487757835256edbeb32beddde8fb93ac99d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 08:18:54 2008 +0100

    Track gateway changes and don't overwrite default gateway

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index ddff1533..86ab9e1a 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -38,6 +38,7 @@
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/resolver.h>
+#include <connman/rtnl.h>
 #include <connman/log.h>
 
 #include "inet.h"
@@ -53,17 +54,41 @@ struct connman_ipv4 {
 	enum connman_ipv4_method method;
 	struct in_addr address;
 	struct in_addr netmask;
-	struct in_addr gateway;
-	struct in_addr network;
 	struct in_addr broadcast;
-	struct in_addr nameserver;
 };
 
+struct gateway_data {
+	int index;
+	char *gateway;
+};
+
+static GSList *gateway_list = NULL;
+
+static struct gateway_data *find_gateway(int index, const char *gateway)
+{
+	GSList *list;
+
+	if (gateway == NULL)
+		return NULL;
+
+	for (list = gateway_list; list; list = list->next) {
+		struct gateway_data *data = list->data;
+
+		if (data->gateway == NULL)
+			continue;
+
+		if (data->index == index &&
+				g_str_equal(data->gateway, gateway) == TRUE)
+			return data;
+	}
+
+	return NULL;
+}
+
 static int set_ipv4(struct connman_element *element,
 			struct connman_ipv4 *ipv4, const char *nameserver)
 {
 	struct ifreq ifr;
-	struct rtentry rt;
 	struct sockaddr_in *addr;
 	int sk, err;
 
@@ -110,30 +135,8 @@ static int set_ipv4(struct connman_element *element,
 	if (err < 0)
 		DBG("broadcast setting failed (%s)", strerror(errno));
 
-	memset(&rt, 0, sizeof(rt));
-	rt.rt_flags = RTF_UP | RTF_GATEWAY;
-
-	addr = (struct sockaddr_in *) &rt.rt_dst;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	addr = (struct sockaddr_in *) &rt.rt_gateway;
-	addr->sin_family = AF_INET;
-	addr->sin_addr = ipv4->gateway;
-
-	addr = (struct sockaddr_in *) &rt.rt_genmask;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	err = ioctl(sk, SIOCADDRT, &rt);
-
 	close(sk);
 
-	if (err < 0) {
-		DBG("default route failed (%s)", strerror(errno));
-		return -1;
-	}
-
 	connman_resolver_append(ifr.ifr_name, NULL, nameserver);
 
 	return 0;
@@ -180,11 +183,102 @@ static int clear_ipv4(struct connman_element *element)
 	return 0;
 }
 
+static int set_route(struct connman_element *element, const char *gateway)
+{
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = inet_addr(gateway);
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCADDRT, &rt);
+	if (err < 0)
+		DBG("default route failed (%s)", strerror(errno));
+
+	close(sk);
+
+	return err;
+}
+
+static int conn_probe(struct connman_element *element)
+{
+	const char *gateway = NULL;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->parent == NULL)
+		return -ENODEV;
+
+	if (element->parent->type != CONNMAN_ELEMENT_TYPE_IPV4)
+		return -ENODEV;
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	DBG("gateway %s", gateway);
+
+	if (gateway == NULL)
+		return -EINVAL;
+
+	if (g_slist_length(gateway_list) > 0) {
+		DBG("default already present");
+		return -EALREADY;
+	}
+
+	set_route(element, gateway);
+
+	connman_element_set_enabled(element, TRUE);
+
+	return 0;
+}
+
+static void conn_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver conn_driver = {
+	.name		= "ipv4-connection",
+	.type		= CONNMAN_ELEMENT_TYPE_CONNECTION,
+	.probe		= conn_probe,
+	.remove		= conn_remove,
+};
+
 static int ipv4_probe(struct connman_element *element)
 {
 	struct connman_element *connection;
 	struct connman_ipv4 ipv4;
-	const char *address = NULL, *netmask = NULL, *gateway = NULL;
+	const char *address = NULL, *netmask = NULL, *broadcast = NULL;
 	const char *nameserver = NULL;
 
 	DBG("element %p name %s", element, element->name);
@@ -194,22 +288,22 @@ static int ipv4_probe(struct connman_element *element)
 	connman_element_get_value(element,
 				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
 	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+				CONNMAN_PROPERTY_ID_IPV4_BROADCAST, &broadcast);
 
 	connman_element_get_value(element,
 			CONNMAN_PROPERTY_ID_IPV4_NAMESERVER, &nameserver);
 
 	DBG("address %s", address);
 	DBG("netmask %s", netmask);
-	DBG("gateway %s", gateway);
+	DBG("broadcast %s", broadcast);
 
-	if (address == NULL || netmask == NULL || gateway == NULL)
+	if (address == NULL || netmask == NULL)
 		return -EINVAL;
 
 	memset(&ipv4, 0, sizeof(ipv4));
 	ipv4.address.s_addr = inet_addr(address);
 	ipv4.netmask.s_addr = inet_addr(netmask);
-	ipv4.gateway.s_addr = inet_addr(gateway);
+	ipv4.broadcast.s_addr = inet_addr(broadcast);
 
 	set_ipv4(element, &ipv4, nameserver);
 
@@ -231,20 +325,100 @@ static void ipv4_remove(struct connman_element *element)
 }
 
 static struct connman_driver ipv4_driver = {
-	.name		= "ipv4",
+	.name		= "ipv4-address",
 	.type		= CONNMAN_ELEMENT_TYPE_IPV4,
 	.probe		= ipv4_probe,
 	.remove		= ipv4_remove,
 };
 
+static void ipv4_newgateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	DBG("index %d gateway %s", index, gateway);
+
+	data = find_gateway(index, gateway);
+	if (data != NULL)
+		return;
+
+	data = g_try_new0(struct gateway_data, 1);
+	if (data == NULL)
+		return;
+
+	data->index = index;
+	data->gateway = g_strdup(gateway);
+
+	gateway_list = g_slist_append(gateway_list, data);
+}
+
+static void ipv4_delgateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	DBG("index %d gateway %s", index, gateway);
+
+	data = find_gateway(index, gateway);
+	if (data == NULL)
+		return;
+
+	gateway_list = g_slist_remove(gateway_list, data);
+
+	g_free(data->gateway);
+	g_free(data);
+}
+
+static struct connman_rtnl ipv4_rtnl = {
+	.name		= "ipv4-rtnl",
+	.newgateway	= ipv4_newgateway,
+	.delgateway	= ipv4_delgateway,
+};
+
 static int ipv4_init(void)
 {
-	return connman_driver_register(&ipv4_driver);
+	int err;
+
+	err = connman_rtnl_register(&ipv4_rtnl);
+	if (err < 0)
+		return err;
+
+	connman_rtnl_send_getroute();
+
+	err = connman_driver_register(&conn_driver);
+	if (err < 0) {
+		connman_rtnl_unregister(&ipv4_rtnl);
+		return err;
+	}
+
+	err = connman_driver_register(&ipv4_driver);
+	if (err < 0) {
+		connman_driver_unregister(&conn_driver);
+		connman_rtnl_unregister(&ipv4_rtnl);
+	}
+
+	return err;
 }
 
 static void ipv4_exit(void)
 {
+	GSList *list;
+
+	connman_driver_unregister(&conn_driver);
 	connman_driver_unregister(&ipv4_driver);
+
+	connman_rtnl_unregister(&ipv4_rtnl);
+
+	for (list = gateway_list; list; list = list->next) {
+		struct gateway_data *data = list->data;
+
+		DBG("index %d gateway %s", data->index, data->gateway);
+
+		g_free(data->gateway);
+		g_free(data);
+		list->data = NULL;
+	}
+
+	g_slist_free(gateway_list);
+	gateway_list = NULL;
 }
 
 CONNMAN_PLUGIN_DEFINE(ipv4, "IPv4 configuration plugin", VERSION,

commit 0be58a73c3f1def6e578424380b15370a9a6440c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 08:45:41 2008 +0100

    Add support for enabling/disabling gateway setting

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 86ab9e1a..b1c26d4b 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -223,7 +223,54 @@ static int set_route(struct connman_element *element, const char *gateway)
 
 	err = ioctl(sk, SIOCADDRT, &rt);
 	if (err < 0)
-		DBG("default route failed (%s)", strerror(errno));
+		DBG("default route setting failed (%s)", strerror(errno));
+
+	close(sk);
+
+	return err;
+}
+
+static int del_route(struct connman_element *element, const char *gateway)
+{
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = inet_addr(gateway);
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCDELRT, &rt);
+	if (err < 0)
+		DBG("default route removal failed (%s)", strerror(errno));
 
 	close(sk);
 
@@ -248,11 +295,11 @@ static int conn_probe(struct connman_element *element)
 	DBG("gateway %s", gateway);
 
 	if (gateway == NULL)
-		return -EINVAL;
+		return 0;
 
 	if (g_slist_length(gateway_list) > 0) {
 		DBG("default already present");
-		return -EALREADY;
+		return 0;
 	}
 
 	set_route(element, gateway);
@@ -267,11 +314,51 @@ static void conn_remove(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 }
 
+static int conn_enable(struct connman_element *element)
+{
+	const char *gateway = NULL;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	DBG("gateway %s", gateway);
+
+	if (gateway == NULL)
+		return -EINVAL;
+
+	set_route(element, gateway);
+
+	return 0;
+}
+
+static int conn_disable(struct connman_element *element)
+{
+	const char *gateway = NULL;
+
+	DBG("element %p name %s", element, element->name);
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	DBG("gateway %s", gateway);
+
+	if (gateway == NULL)
+		return -EINVAL;
+
+	del_route(element, gateway);
+
+	return 0;
+}
+
 static struct connman_driver conn_driver = {
 	.name		= "ipv4-connection",
 	.type		= CONNMAN_ELEMENT_TYPE_CONNECTION,
 	.probe		= conn_probe,
 	.remove		= conn_remove,
+	.enable		= conn_enable,
+	.disable	= conn_disable,
 };
 
 static int ipv4_probe(struct connman_element *element)

commit 93ee679d1e82bbc875130e077f8558230b8d4b29
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 08:46:10 2008 +0100

    Add support for changing default connections

diff --git a/src/element.c b/src/element.c
index 1b1e61dc..098bbae1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -518,9 +518,9 @@ static DBusMessage *device_set_property(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &powered);
 
 		if (powered == TRUE)
-			do_enable(conn, msg, data);
+			do_enable(conn, msg, element);
 		else
-			do_disable(conn, msg, data);
+			do_disable(conn, msg, element);
 	} else
 		set_common_property(element, name, &value);
 
@@ -726,6 +726,39 @@ static DBusMessage *connection_get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *connection_set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessageIter iter, value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	if (g_str_equal(name, "Default") == TRUE) {
+		dbus_bool_t enabled;
+
+		dbus_message_iter_get_basic(&value, &enabled);
+
+		if (enabled == TRUE)
+			return do_enable(conn, msg, element);
+		else
+			return do_disable(conn, msg, element);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static GDBusMethodTable device_methods[] = {
 	{ "GetProperties", "",      "a{sv}", device_get_properties },
 	{ "SetProperty",   "sv",    "",      device_set_property   },
@@ -745,6 +778,7 @@ static GDBusMethodTable network_methods[] = {
 
 static GDBusMethodTable connection_methods[] = {
 	{ "GetProperties", "",   "a{sv}", connection_get_properties },
+	{ "SetProperty",   "sv", "",      connection_set_property   },
 	{ },
 };
 

commit f457515a077ff1946ec5ab00635c47a2a40bab8a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 08:50:11 2008 +0100

    Add script for selecting connections

diff --git a/test/Makefile.am b/test/Makefile.am
index e4ea64f7..2087e881 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,5 +1,5 @@
 
-EXTRA_DIST = get-state list-profiles list-connections \
+EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
 		set-passphrase simple-agent show-introspection \
diff --git a/test/select-connection b/test/select-connection
new file mode 100755
index 00000000..34d1f93c
--- /dev/null
+++ b/test/select-connection
@@ -0,0 +1,23 @@
+#!/usr/bin/python
+
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Connections"]:
+	connection = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Connection")
+
+	properties = connection.GetProperties()
+
+	if (properties["Default"] == dbus.Boolean(1)):
+		continue
+
+	print "[ %s ]" % (path)
+
+	connection.SetProperty("Default", dbus.Boolean(1))

commit 212b3e0a7b14bebbf9886ac16eaf8a8b33a985be
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 08:54:31 2008 +0100

    Print boolean properties as true or false

diff --git a/test/test-manager b/test/test-manager
index c99b54ba..c0ad77d4 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -10,11 +10,11 @@ manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 properties = manager.GetProperties()
 
 def print_properties(key, value):
-	if (key == "Profiles"):
+	if key == "Profiles":
 		interface = "org.moblin.connman.Profile"
-	elif (key == "Devices"):
+	elif key == "Devices":
 		interface = "org.moblin.connman.Device"
-	elif (key == "Connections"):
+	elif key == "Connections":
 		interface = "org.moblin.connman.Connection"
 	else:
 		return
@@ -28,10 +28,16 @@ def print_properties(key, value):
 		properties = obj.GetProperties()
 
 		for key in properties.keys():
-			if (key == "Networks"):
+			if key == "Networks":
 				continue
 
-			if (key == "Strength"):
+			if key in ["Powered", "Connected", "Available",
+							"Remember", "Default"]:
+				if properties[key] == dbus.Boolean(1):
+					val = "true"
+				else:
+					val = "false"
+			elif key == "Strength":
 				val = int(properties[key])
 			else:
 				val = str(properties[key])

commit 6fc25870e4cb00374c96ce31f012fe188475f4aa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 09:11:05 2008 +0100

    Fix offline state signal emission

diff --git a/src/element.c b/src/element.c
index 098bbae1..9b91ab07 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1988,7 +1988,9 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 	}
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
-		emit_state_change(connection, "offline");
+		if (__connman_element_count(NULL,
+					CONNMAN_ELEMENT_TYPE_CONNECTION) == 0)
+			emit_state_change(connection, "offline");
 		emit_connections_signal(connection);
 
 		g_dbus_unregister_interface(connection, element->path,

commit 3dd560cb2721d764f21de74f208209c64e855c55
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 09:20:04 2008 +0100

    Use IFF_LOWER_UP instead of IFF_RUNNING for link detection

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 28c1742d..832d636f 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -62,12 +62,12 @@ static void ethernet_newlink(unsigned short type, int index,
 		if (ethernet->index != index)
 			continue;
 
-		if ((ethernet->flags & IFF_RUNNING) == (flags & IFF_RUNNING))
+		if ((ethernet->flags & IFF_LOWER_UP) == (flags & IFF_LOWER_UP))
 			continue;
 
 		ethernet->flags = flags;
 
-		if (ethernet->flags & IFF_RUNNING) {
+		if (ethernet->flags & IFF_LOWER_UP) {
 			DBG("carrier on");
 
 			netdev = connman_element_create(NULL);

commit 548a9238633420375bc6aa847279cd9ad2c8dd6f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 09:41:20 2008 +0100

    Execute resolvconf commands

diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 41f649cc..0a1c0360 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -51,8 +51,7 @@ static int resolvconf_append(const char *interface, const char *domain,
 
 	DBG("%s", cmd);
 
-	//err = system(cmd);
-	err = 0;
+	err = system(cmd);
 
 	g_free(cmd);
 
@@ -71,8 +70,7 @@ static int resolvconf_remove(const char *interface, const char *domain,
 
 	DBG("%s", cmd);
 
-	//err = system(cmd);
-	err = 0;
+	err = system(cmd);
 
 	g_free(cmd);
 

commit f6da5ddaa4bb61d63d9c585b1b7821d682ff59bb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 09:49:43 2008 +0100

    Release 0.4

diff --git a/ChangeLog b/ChangeLog
index f9dcf501..3b92407e 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+ver 0.4:
+	Add DNS proxy resolver plugin.
+	Add support for default connections.
+	Add support for gateway change notifications.
+	Add signal strength property for connections.
+	Add property for connection type.
+	Fix issue with carrier detection.
+	Fix broken resolvconf plugin.
+
 ver 0.3:
 	Add support for automatically connecting known networks.
 	Add improved framework for handling resolver details.
diff --git a/configure.ac b/configure.ac
index c5a7a1de..8bf52546 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.3)
+AM_INIT_AUTOMAKE(connman, 0.4)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit e9fdbe094a5edda6f85d2b532ccc51c260234da6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 15 16:53:24 2008 +0100

    Allow numbers in path for network objects

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 9cddb61d..be2358c4 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -316,9 +316,9 @@ static void scan_result(struct connman_element *device,
 	temp = g_strdup(network->identifier);
 
 	for (i = 0; i < strlen(temp); i++) {
-		gchar tmp = g_ascii_tolower(temp[i]);
-
-		if (tmp < 'a' || tmp > 'z')
+		char tmp = temp[i];
+		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
+						(tmp < 'a' || tmp > 'z'))
 			temp[i] = '_';
 	}
 

commit eef3cadcb3bce384b8fb2b0531386c982021dc39
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 16 04:50:48 2008 +0100

    Fix Name property of device objects

diff --git a/doc/device-api.txt b/doc/device-api.txt
index 847b6f48..7df37919 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -45,7 +45,10 @@ Signals		PropertyChanged(string name, variant value)
 
 Properties	string Name [readonly]
 
-			The device name (for example eth0, wlan0 etc.)
+			The device name (for example "Wireless" etc.)
+
+			This name can be used for directly displaying it in
+			the application. It has pure informational purpose.
 
 		string Type [readonly]
 
diff --git a/src/element.c b/src/element.c
index 9b91ab07..9a756416 100644
--- a/src/element.c
+++ b/src/element.c
@@ -145,6 +145,28 @@ static const char *subtype2string(enum connman_element_subtype type)
 	return NULL;
 }
 
+static const char *subtype2description(enum connman_element_subtype type)
+{
+	switch (type) {
+	case CONNMAN_ELEMENT_SUBTYPE_UNKNOWN:
+	case CONNMAN_ELEMENT_SUBTYPE_FAKE:
+	case CONNMAN_ELEMENT_SUBTYPE_NETWORK:
+		return NULL;
+	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:
+		return "Ethernet";
+	case CONNMAN_ELEMENT_SUBTYPE_WIFI:
+		return "Wireless";
+	case CONNMAN_ELEMENT_SUBTYPE_WIMAX:
+		return "WiMAX";
+	case CONNMAN_ELEMENT_SUBTYPE_MODEM:
+		return "Modem";
+	case CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH:
+		return "Bluetooth";
+	}
+
+	return NULL;
+}
+
 const char *__connman_element_policy2string(enum connman_element_policy policy)
 {
 	switch (policy) {
@@ -465,6 +487,15 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = subtype2description(element->subtype);
+	if (str != NULL && element->devname != NULL) {
+		char *name = g_strdup_printf("%s (%s)", str, element->devname);
+		if (name != NULL)
+			connman_dbus_dict_append_variant(&dict, "Name",
+						DBUS_TYPE_STRING, &name);
+		g_free(name);
+	}
+
 	str = subtype2string(element->subtype);
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "Type",

commit 8b0d086c892b72cfdef0ee799e515b60e43c9766
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 16 04:54:15 2008 +0100

    Add Scanning property to device objects

diff --git a/src/element.c b/src/element.c
index 9a756416..a39cc096 100644
--- a/src/element.c
+++ b/src/element.c
@@ -511,6 +511,11 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 
 	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
 			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX) {
+		dbus_bool_t scanning = FALSE;
+
+		connman_dbus_dict_append_variant(&dict, "Scanning",
+						DBUS_TYPE_BOOLEAN, &scanning);
+
 		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
 		append_networks(element, &entry);
diff --git a/test/test-manager b/test/test-manager
index c0ad77d4..09c6e19e 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -31,8 +31,8 @@ def print_properties(key, value):
 			if key == "Networks":
 				continue
 
-			if key in ["Powered", "Connected", "Available",
-							"Remember", "Default"]:
+			if key in ["Powered", "Scanning", "Connected",
+					"Available", "Remember", "Default"]:
 				if properties[key] == dbus.Boolean(1):
 					val = "true"
 				else:

commit 1ea9542c44ec6bcf2ab21bc9ecbe584b50bac847
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 16 14:12:09 2008 +0100

    Include sys/types.h to make it build with uClibc

diff --git a/src/udev.c b/src/udev.c
index 1f80728c..40ec8242 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <stdarg.h>
+#include <sys/types.h>
 
 #define LIBUDEV_I_KNOW_THE_API_IS_SUBJECT_TO_CHANGE
 #include <libudev.h>

commit 2f057e927fa44d7e61db2cde08a5cbaacc1cea51
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 02:23:57 2008 +0100

    Add support dynamic Bluetooth adapter detection

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index c09e4a5e..778dd357 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -31,7 +31,13 @@
 #include <connman/device.h>
 #include <connman/log.h>
 
-#define BLUEZ_SERVICE "org.bluez"
+#define BLUEZ_SERVICE			"org.bluez"
+#define BLUEZ_MANAGER_INTERFACE		BLUEZ_SERVICE ".Manager"
+#define BLUEZ_ADAPTER_INTERFACE		BLUEZ_SERVICE ".Adapter"
+
+#define ADAPTER_ADDED			"AdapterAdded"
+#define ADAPTER_REMOVED			"AdapterRemoved"
+#define PROPERTY_CHANGED		"PropertyChanged"
 
 #define TIMEOUT 5000
 
@@ -56,6 +62,64 @@ static struct connman_device_driver bluetooth_driver = {
 
 static GSList *device_list = NULL;
 
+static void property_changed(DBusMessage *msg)
+{
+	DBG("");
+}
+
+static struct connman_element *find_adapter(const char *path)
+{
+	const char *devname = g_basename(path);
+	GSList *list;
+
+	DBG("path %s", path);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_element *device = list->data;
+
+		if (g_str_equal(device->devname, devname) == TRUE)
+			return device;
+	}
+
+	return NULL;
+}
+
+static void add_adapter(const char *path)
+{
+	struct connman_element *device;
+
+	DBG("path %s", path);
+
+	device = find_adapter(path);
+	if (device != NULL)
+		return;
+
+	device = connman_element_create(NULL);
+	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	device->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+
+	device->name = g_path_get_basename(path);
+
+	connman_element_register(device, NULL);
+	device_list = g_slist_append(device_list, device);
+}
+
+static void remove_adapter(const char *path)
+{
+	struct connman_element *device;
+
+	DBG("path %s", path);
+
+	device = find_adapter(path);
+	if (device == NULL)
+		return;
+
+	device_list = g_slist_remove(device_list, device);
+
+	connman_element_unregister(device);
+	connman_element_unref(device);
+}
+
 static void adapters_reply(DBusPendingCall *call, void *user_data)
 {
 	DBusMessage *reply;
@@ -81,18 +145,8 @@ static void adapters_reply(DBusPendingCall *call, void *user_data)
 		goto done;
 	}
 
-	for (i = 0; i < num_adapters; i++) {
-		struct connman_element *device;
-
-		device = connman_element_create(NULL);
-		device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-		device->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
-
-		device->name = g_path_get_basename(adapters[i]);
-
-		connman_element_register(device, NULL);
-		device_list = g_slist_append(device_list, device);
-	}
+	for (i = 0; i < num_adapters; i++)
+		add_adapter(adapters[i]);
 
 	g_strfreev(adapters);
 
@@ -108,7 +162,7 @@ static void bluetooth_connect(DBusConnection *connection, void *user_data)
 	DBG("connection %p", connection);
 
 	message = dbus_message_new_method_call(BLUEZ_SERVICE, "/",
-					"org.bluez.Manager", "ListAdapters");
+				BLUEZ_MANAGER_INTERFACE, "ListAdapters");
 	if (message == NULL)
 		return;
 
@@ -141,43 +195,100 @@ static void bluetooth_disconnect(DBusConnection *connection, void *user_data)
 	device_list = NULL;
 }
 
+static DBusHandlerResult bluetooth_signal(DBusConnection *conn,
+						DBusMessage *msg, void *data)
+{
+	DBG("connection %p", conn);
+
+	if (dbus_message_is_signal(msg, BLUEZ_ADAPTER_INTERFACE,
+						PROPERTY_CHANGED) == TRUE) {
+		property_changed(msg);
+	} else if (dbus_message_is_signal(msg, BLUEZ_MANAGER_INTERFACE,
+						ADAPTER_ADDED) == TRUE) {
+		const char *path;
+		dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+		add_adapter(path);
+	} else if (dbus_message_is_signal(msg, BLUEZ_MANAGER_INTERFACE,
+						ADAPTER_REMOVED) == TRUE) {
+		const char *path;
+		dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+		remove_adapter(path);
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
 static DBusConnection *connection;
 static guint watch;
 
+static const char *added_rule = "type=signal,member=" ADAPTER_ADDED
+					",interface=" BLUEZ_MANAGER_INTERFACE;
+static const char *removed_rule = "type=signal,member=" ADAPTER_REMOVED
+					",interface=" BLUEZ_MANAGER_INTERFACE;
+
+static const char *adapter_rule = "type=signal,member=" PROPERTY_CHANGED
+					",interface=" BLUEZ_ADAPTER_INTERFACE;
+
 static int bluetooth_init(void)
 {
-	int err;
+	int err = -EIO;
 
 	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 	if (connection == NULL)
 		return -EIO;
 
+	if (dbus_connection_add_filter(connection, bluetooth_signal,
+							NULL, NULL) == FALSE)
+		goto unref;
+
 	err = connman_device_driver_register(&bluetooth_driver);
-	if (err < 0) {
-		dbus_connection_unref(connection);
-		return -EIO;
-	}
+	if (err < 0)
+		goto remove;
 
 	watch = g_dbus_add_service_watch(connection, BLUEZ_SERVICE,
 			bluetooth_connect, bluetooth_disconnect, NULL, NULL);
 	if (watch == 0) {
 		connman_device_driver_unregister(&bluetooth_driver);
-		dbus_connection_unref(connection);
-		return -EIO;
+		err = -EIO;
+		goto remove;
 	}
 
 	if (g_dbus_check_service(connection, BLUEZ_SERVICE) == TRUE)
 		bluetooth_connect(connection, NULL);
 
+	dbus_bus_add_match(connection, added_rule, NULL);
+	dbus_bus_add_match(connection, removed_rule, NULL);
+	dbus_bus_add_match(connection, adapter_rule, NULL);
+	dbus_connection_flush(connection);
+
 	return 0;
+
+remove:
+	dbus_connection_remove_filter(connection, bluetooth_signal, NULL);
+
+unref:
+	dbus_connection_unref(connection);
+
+	return err;
 }
 
 static void bluetooth_exit(void)
 {
+	dbus_bus_remove_match(connection, adapter_rule, NULL);
+	dbus_bus_remove_match(connection, removed_rule, NULL);
+	dbus_bus_remove_match(connection, added_rule, NULL);
+	dbus_connection_flush(connection);
+
 	g_dbus_remove_watch(connection, watch);
 
+	bluetooth_disconnect(connection, NULL);
+
 	connman_device_driver_unregister(&bluetooth_driver);
 
+	dbus_connection_remove_filter(connection, bluetooth_signal, NULL);
+
 	dbus_connection_unref(connection);
 }
 

commit 7eb3da555c0c700598fa941bda6d48339377124f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 04:14:43 2008 +0100

    Track mode changes of Bluetooth devices

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 778dd357..95b48318 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -28,7 +28,7 @@
 #include <gdbus.h>
 
 #include <connman/plugin.h>
-#include <connman/device.h>
+#include <connman/driver.h>
 #include <connman/log.h>
 
 #define BLUEZ_SERVICE			"org.bluez"
@@ -41,32 +41,44 @@
 
 #define TIMEOUT 5000
 
-static int bluetooth_probe(struct connman_device *device)
+static int bluetooth_probe(struct connman_element *device)
 {
-	DBG("device %p", device);
+	DBG("device %p name %s", device, device->name);
 
 	return 0;
 }
 
-static void bluetooth_remove(struct connman_device *device)
+static void bluetooth_remove(struct connman_element *device)
 {
-	DBG("device %p", device);
+	DBG("device %p name %s", device, device->name);
 }
 
-static struct connman_device_driver bluetooth_driver = {
-	.name	= "bluetooth",
-	.type	= CONNMAN_DEVICE_TYPE_BLUETOOTH,
-	.probe	= bluetooth_probe,
-	.remove	= bluetooth_remove,
-};
+static int bluetooth_enable(struct connman_element *device)
+{
+	DBG("device %p name %s", device, device->name);
 
-static GSList *device_list = NULL;
+	return -EINVAL;
+}
 
-static void property_changed(DBusMessage *msg)
+static int bluetooth_disable(struct connman_element *device)
 {
-	DBG("");
+	DBG("device %p name %s", device, device->name);
+
+	return 0;
 }
 
+static struct connman_driver bluetooth_driver = {
+	.name		= "bluetooth",
+	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
+	.subtype	= CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
+	.probe		= bluetooth_probe,
+	.remove		= bluetooth_remove,
+	.enable		= bluetooth_enable,
+	.disable	= bluetooth_disable,
+};
+
+static GSList *device_list = NULL;
+
 static struct connman_element *find_adapter(const char *path)
 {
 	const char *devname = g_basename(path);
@@ -84,9 +96,90 @@ static struct connman_element *find_adapter(const char *path)
 	return NULL;
 }
 
-static void add_adapter(const char *path)
+static void property_changed(DBusConnection *connection, DBusMessage *message)
+{
+	const char *path = dbus_message_get_path(message);
+	struct connman_element *device;
+	DBusMessageIter iter, value;
+	const char *key;
+
+	DBG("path %s", path);
+
+	device = find_adapter(path);
+	if (device == NULL)
+		return;
+
+	if (dbus_message_iter_init(message, &iter) == FALSE)
+		return;
+
+	dbus_message_iter_get_basic(&iter, &key);
+
+	if (g_str_equal(key, "Powered") == TRUE) {
+		gboolean val;
+
+		dbus_message_iter_next(&iter);
+		dbus_message_iter_recurse(&iter, &value);
+
+		dbus_message_iter_get_basic(&value, &val);
+		connman_element_set_enabled(device, val);
+	}
+}
+
+static void properties_reply(DBusPendingCall *call, void *user_data)
 {
+	DBusMessage *message = user_data;
+	const char *path = dbus_message_get_path(message);
 	struct connman_element *device;
+	DBusMessageIter array, dict;
+	DBusMessage *reply;
+
+	DBG("path %s", path);
+
+	device = find_adapter(path);
+
+	dbus_message_unref(message);
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	if (device == NULL)
+		goto done;
+
+	if (dbus_message_iter_init(reply, &array) == FALSE)
+		goto done;
+
+	if (dbus_message_iter_get_arg_type(&array) != DBUS_TYPE_ARRAY)
+		goto done;
+
+	dbus_message_iter_recurse(&array, &dict);
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		if (g_str_equal(key, "Powered") == TRUE) {
+			gboolean val;
+
+			dbus_message_iter_next(&entry);
+			dbus_message_iter_recurse(&entry, &value);
+
+			dbus_message_iter_get_basic(&value, &val);
+			connman_element_set_enabled(device, val);
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+done:
+	dbus_message_unref(reply);
+}
+
+static void add_adapter(DBusConnection *connection, const char *path)
+{
+	struct connman_element *device;
+	DBusMessage *message;
+	DBusPendingCall *call;
 
 	DBG("path %s", path);
 
@@ -102,9 +195,23 @@ static void add_adapter(const char *path)
 
 	connman_element_register(device, NULL);
 	device_list = g_slist_append(device_list, device);
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
+				BLUEZ_ADAPTER_INTERFACE, "GetProperties");
+	if (message == NULL)
+		return;
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get adapter properties");
+		dbus_message_unref(message);
+		return;
+	}
+
+	dbus_pending_call_set_notify(call, properties_reply, message, NULL);
 }
 
-static void remove_adapter(const char *path)
+static void remove_adapter(DBusConnection *connection, const char *path)
 {
 	struct connman_element *device;
 
@@ -122,6 +229,7 @@ static void remove_adapter(const char *path)
 
 static void adapters_reply(DBusPendingCall *call, void *user_data)
 {
+	DBusConnection *connection = user_data;
 	DBusMessage *reply;
 	DBusError error;
 	char **adapters;
@@ -146,7 +254,7 @@ static void adapters_reply(DBusPendingCall *call, void *user_data)
 	}
 
 	for (i = 0; i < num_adapters; i++)
-		add_adapter(adapters[i]);
+		add_adapter(connection, adapters[i]);
 
 	g_strfreev(adapters);
 
@@ -173,7 +281,7 @@ static void bluetooth_connect(DBusConnection *connection, void *user_data)
 		return;
 	}
 
-	dbus_pending_call_set_notify(call, adapters_reply, NULL, NULL);
+	dbus_pending_call_set_notify(call, adapters_reply, connection, NULL);
 
 	dbus_message_unref(message);
 }
@@ -195,26 +303,28 @@ static void bluetooth_disconnect(DBusConnection *connection, void *user_data)
 	device_list = NULL;
 }
 
-static DBusHandlerResult bluetooth_signal(DBusConnection *conn,
-						DBusMessage *msg, void *data)
+static DBusHandlerResult bluetooth_signal(DBusConnection *connection,
+					DBusMessage *message, void *user_data)
 {
-	DBG("connection %p", conn);
+	DBG("connection %p", connection);
 
-	if (dbus_message_is_signal(msg, BLUEZ_ADAPTER_INTERFACE,
+	if (dbus_message_is_signal(message, BLUEZ_ADAPTER_INTERFACE,
 						PROPERTY_CHANGED) == TRUE) {
-		property_changed(msg);
-	} else if (dbus_message_is_signal(msg, BLUEZ_MANAGER_INTERFACE,
+		property_changed(connection, message);
+	} else if (dbus_message_is_signal(message, BLUEZ_MANAGER_INTERFACE,
 						ADAPTER_ADDED) == TRUE) {
 		const char *path;
-		dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+		dbus_message_get_args(message, NULL,
+					DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
-		add_adapter(path);
-	} else if (dbus_message_is_signal(msg, BLUEZ_MANAGER_INTERFACE,
+		add_adapter(connection, path);
+	} else if (dbus_message_is_signal(message, BLUEZ_MANAGER_INTERFACE,
 						ADAPTER_REMOVED) == TRUE) {
 		const char *path;
-		dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+		dbus_message_get_args(message, NULL,
+					DBUS_TYPE_OBJECT_PATH, &path,
 							DBUS_TYPE_INVALID);
-		remove_adapter(path);
+		remove_adapter(connection, path);
 	}
 
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
@@ -243,14 +353,14 @@ static int bluetooth_init(void)
 							NULL, NULL) == FALSE)
 		goto unref;
 
-	err = connman_device_driver_register(&bluetooth_driver);
+	err = connman_driver_register(&bluetooth_driver);
 	if (err < 0)
 		goto remove;
 
 	watch = g_dbus_add_service_watch(connection, BLUEZ_SERVICE,
 			bluetooth_connect, bluetooth_disconnect, NULL, NULL);
 	if (watch == 0) {
-		connman_device_driver_unregister(&bluetooth_driver);
+		connman_driver_unregister(&bluetooth_driver);
 		err = -EIO;
 		goto remove;
 	}
@@ -285,7 +395,7 @@ static void bluetooth_exit(void)
 
 	bluetooth_disconnect(connection, NULL);
 
-	connman_device_driver_unregister(&bluetooth_driver);
+	connman_driver_unregister(&bluetooth_driver);
 
 	dbus_connection_remove_filter(connection, bluetooth_signal, NULL);
 

commit 19adbb63c30ca07cc9999d54503fad03072617b6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 04:46:50 2008 +0100

    Use ignore policy as default for Bluetooth

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 95b48318..94c8649c 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -190,6 +190,7 @@ static void add_adapter(DBusConnection *connection, const char *path)
 	device = connman_element_create(NULL);
 	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
 	device->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+	device->policy = CONNMAN_ELEMENT_POLICY_IGNORE;
 
 	device->name = g_path_get_basename(path);
 

commit 9328a63c330a64982d2a9bc060d8985c2228d3e5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 04:54:01 2008 +0100

    Retrieve list of Bluetooth devices

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 94c8649c..2b33c3ae 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -175,6 +175,45 @@ done:
 	dbus_message_unref(reply);
 }
 
+static void devices_reply(DBusPendingCall *call, void *user_data)
+{
+	DBusMessage *message = user_data;
+	const char *path = dbus_message_get_path(message);
+	DBusMessage *reply;
+	DBusError error;
+	char **devices;
+	int i, num_devices;
+
+	DBG("path %s", path);
+
+	dbus_message_unref(message);
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error,
+				DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+						&devices, &num_devices,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for device list");
+		goto done;
+	}
+
+	for (i = 0; i < num_devices; i++) {
+		DBG("device %s", devices[i]);
+	}
+
+	g_strfreev(devices);
+
+done:
+	dbus_message_unref(reply);
+}
+
 static void add_adapter(DBusConnection *connection, const char *path)
 {
 	struct connman_element *device;
@@ -210,6 +249,20 @@ static void add_adapter(DBusConnection *connection, const char *path)
 	}
 
 	dbus_pending_call_set_notify(call, properties_reply, message, NULL);
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
+				BLUEZ_ADAPTER_INTERFACE, "ListDevices");
+	if (message == NULL)
+		return;
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get Bluetooth devices");
+		dbus_message_unref(message);
+		return;
+	}
+
+	dbus_pending_call_set_notify(call, devices_reply, message, NULL);
 }
 
 static void remove_adapter(DBusConnection *connection, const char *path)

commit 366dc1fdece8aa53344d054d34fa8e698f405770
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 15:35:17 2008 +0100

    Remove duplicate function prototype

diff --git a/include/element.h b/include/element.h
index 48e46f20..f5d2d56f 100644
--- a/include/element.h
+++ b/include/element.h
@@ -148,9 +148,6 @@ extern void connman_element_unregister(struct connman_element *element);
 extern void connman_element_unregister_children(struct connman_element *element);
 extern void connman_element_update(struct connman_element *element);
 
-extern int connman_element_set_enabled(struct connman_element *element,
-							gboolean enabled);
-
 extern int connman_element_set_enabled(struct connman_element *element,
 							gboolean enabled);
 

commit ca6b2ec5e5c48563968775f5de05a8c2251fde76
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 15:43:15 2008 +0100

    Add support for changing scanning state

diff --git a/include/element.h b/include/element.h
index f5d2d56f..327b8df0 100644
--- a/include/element.h
+++ b/include/element.h
@@ -90,6 +90,7 @@ struct connman_element {
 	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
+	gboolean scanning;
 	gboolean available;
 	gboolean remember;
 	guint16 priority;
@@ -150,6 +151,8 @@ extern void connman_element_update(struct connman_element *element);
 
 extern int connman_element_set_enabled(struct connman_element *element,
 							gboolean enabled);
+extern int connman_element_set_scanning(struct connman_element *element,
+							gboolean scanning);
 
 static inline void *connman_element_get_data(struct connman_element *element)
 {
diff --git a/src/element.c b/src/element.c
index a39cc096..c2cf05f7 100644
--- a/src/element.c
+++ b/src/element.c
@@ -378,6 +378,39 @@ static void emit_enabled_signal(DBusConnection *conn,
 	g_dbus_send_message(conn, signal);
 }
 
+static void emit_scanning_signal(DBusConnection *conn,
+					struct connman_element *element)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Scanning";
+
+	DBG("conn %p", conn);
+
+	if (element == NULL)
+		return;
+
+	if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE)
+		return;
+
+	signal = dbus_message_new_signal(element->path,
+				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN,
+							&element->scanning);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(conn, signal);
+}
+
 static DBusMessage *do_update(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -510,11 +543,10 @@ static DBusMessage *device_get_properties(DBusConnection *conn,
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
 	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX) {
-		dbus_bool_t scanning = FALSE;
-
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX ||
+			element->subtype == CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH) {
 		connman_dbus_dict_append_variant(&dict, "Scanning",
-						DBUS_TYPE_BOOLEAN, &scanning);
+					DBUS_TYPE_BOOLEAN, &element->scanning);
 
 		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
@@ -2127,6 +2159,19 @@ int connman_element_set_enabled(struct connman_element *element,
 	return 0;
 }
 
+int connman_element_set_scanning(struct connman_element *element,
+							gboolean scanning)
+{
+	if (element->scanning == scanning)
+		return 0;
+
+	element->scanning = scanning;
+
+	emit_scanning_signal(connection, element);
+
+	return 0;
+}
+
 int __connman_element_init(DBusConnection *conn, const char *device)
 {
 	struct connman_element *element;

commit daf3903e0695e63a68bdbf15f0079f40e7deaf99
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 15:44:14 2008 +0100

    Track scanning state changes of Bluetooth devices

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 2b33c3ae..8c83a988 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -114,14 +114,19 @@ static void property_changed(DBusConnection *connection, DBusMessage *message)
 
 	dbus_message_iter_get_basic(&iter, &key);
 
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
 	if (g_str_equal(key, "Powered") == TRUE) {
 		gboolean val;
 
-		dbus_message_iter_next(&iter);
-		dbus_message_iter_recurse(&iter, &value);
-
 		dbus_message_iter_get_basic(&value, &val);
 		connman_element_set_enabled(device, val);
+	} else if (g_str_equal(key, "Discovering") == TRUE) {
+		gboolean val;
+
+		dbus_message_iter_get_basic(&value, &val);
+		connman_element_set_scanning(device, val);
 	}
 }
 
@@ -158,14 +163,19 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		dbus_message_iter_recurse(&dict, &entry);
 		dbus_message_iter_get_basic(&entry, &key);
 
+		dbus_message_iter_next(&entry);
+		dbus_message_iter_recurse(&entry, &value);
+
 		if (g_str_equal(key, "Powered") == TRUE) {
 			gboolean val;
 
-			dbus_message_iter_next(&entry);
-			dbus_message_iter_recurse(&entry, &value);
-
 			dbus_message_iter_get_basic(&value, &val);
 			connman_element_set_enabled(device, val);
+		} else if (g_str_equal(key, "Discovering") == TRUE) {
+			gboolean val;
+
+			dbus_message_iter_get_basic(&value, &val);
+			connman_element_set_scanning(device, val);
 		}
 
 		dbus_message_iter_next(&dict);

commit fb650756bce388463c83a0cfb5ef2b955537c38f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 15:58:59 2008 +0100

    Indicate scanning state while not associated

diff --git a/plugins/wifi.c b/plugins/wifi.c
index be2358c4..aa6021da 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -217,6 +217,11 @@ static void state_change(struct connman_element *device,
 
 	DBG("state %d", state);
 
+	if (state == STATE_SCANNING)
+		connman_element_set_scanning(device, TRUE);
+	else
+		connman_element_set_scanning(device, FALSE);
+
 	if (data == NULL)
 		return;
 

commit 8a903a3696cc93c7828bea9f098896ca9c410418
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 16:01:42 2008 +0100

    Handle failure of device registration

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 8c83a988..6b0f05c4 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -243,7 +243,11 @@ static void add_adapter(DBusConnection *connection, const char *path)
 
 	device->name = g_path_get_basename(path);
 
-	connman_element_register(device, NULL);
+	if (connman_element_register(device, NULL) < 0) {
+		connman_element_unref(device);
+		return;
+	}
+
 	device_list = g_slist_append(device_list, device);
 
 	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,

commit 6e8f721b4b86da751efcdbfdec4ccf526f1cba34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 17 21:53:04 2008 +0100

    Add Device property to network objects

diff --git a/doc/network-api.txt b/doc/network-api.txt
index b38e1223..ce487dd1 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -55,6 +55,11 @@ Properties	string Name [readonly]
 
 			Indicates the signal strength of the network.
 
+		object Device [readonly]
+
+			The object path of the device this networks
+			belongs to.
+
 		array{byte} WiFi.SSID [readonly]
 
 			If the network type is WiFi, then this property is
diff --git a/src/element.c b/src/element.c
index c2cf05f7..6c07046f 100644
--- a/src/element.c
+++ b/src/element.c
@@ -696,6 +696,10 @@ static DBusMessage *network_get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	if (element->parent)
+		connman_dbus_dict_append_variant(&dict, "Device",
+				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
+
 	str = __connman_element_policy2string(element->policy);
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "Policy",

commit 0f461fae5f251b9598b4b470f52ca9af575c0cc2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 18 00:11:05 2008 +0100

    Handle element registration failures

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 3d6f189b..06083b65 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -296,7 +296,8 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 		element->type = CONNMAN_ELEMENT_TYPE_IPV4;
 		element->index = task->ifindex;
 		connman_element_update(task->element);
-		connman_element_register(element, task->element);
+		if (connman_element_register(element, task->element) < 0)
+			connman_element_unref(element);
 	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
 				g_ascii_strcasecmp(text, "REBIND") == 0) {
 		connman_element_update(task->element);
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 832d636f..9cfa76bd 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -76,7 +76,8 @@ static void ethernet_newlink(unsigned short type, int index,
 				netdev->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
 				netdev->index   = element->index;
 
-				connman_element_register(netdev, element);
+				if (connman_element_register(netdev, element) < 0)
+					connman_element_unref(netdev);
 			}
 		} else {
 			DBG("carrier off");
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index b1c26d4b..b7d79be8 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -399,7 +399,8 @@ static int ipv4_probe(struct connman_element *element)
 	connection->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
 	connection->index = element->index;
 
-	connman_element_register(connection, element);
+	if (connman_element_register(connection, element) < 0)
+		connman_element_unref(connection);
 
 	return 0;
 }
diff --git a/plugins/netdev.c b/plugins/netdev.c
index 3e085346..b32c12f0 100644
--- a/plugins/netdev.c
+++ b/plugins/netdev.c
@@ -46,7 +46,8 @@ static void create_element(struct connman_element *parent,
 	else
 		element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 
-	connman_element_register(element, parent);
+	if (connman_element_register(element, parent) < 0)
+		connman_element_unref(element);
 }
 
 static int netdev_probe(struct connman_element *element)
diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index b0ed247f..e7acc5ff 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -110,7 +110,11 @@ static void rtnllink_newlink(unsigned short type, int index,
 	device->name = name;
 	device->devname = devname;
 
-	connman_element_register(device, NULL);
+	if (connman_element_register(device, NULL) < 0) {
+		connman_element_unref(device);
+		return;
+	}
+
 	device_list = g_slist_append(device_list, device);
 }
 
diff --git a/plugins/wifi.c b/plugins/wifi.c
index aa6021da..23fbb892 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -243,7 +243,8 @@ static void state_change(struct connman_element *device,
 		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
 		dhcp->index = element->index;
 
-		connman_element_register(dhcp, element);
+		if (connman_element_register(dhcp, element) < 0)
+			connman_element_unref(dhcp);
 	} else if (state == STATE_INACTIVE || state == STATE_DISCONNECTED) {
 		data->connected = FALSE;
 		connman_element_set_enabled(element, FALSE);
@@ -363,7 +364,10 @@ static void scan_result(struct connman_element *device,
 		DBG("%s (%s) strength %d", network->identifier,
 				element->wifi.security, element->strength);
 
-		connman_element_register(element, device);
+		if (connman_element_register(element, device) < 0) {
+			connman_element_unref(element);
+			goto done;
+		}
 	} else {
 		data->pending = g_slist_remove(data->pending, element);
 
@@ -381,6 +385,7 @@ static void scan_result(struct connman_element *device,
 
 	element->available = TRUE;
 
+done:
 	g_free(temp);
 }
 
@@ -553,7 +558,11 @@ static void wifi_newlink(unsigned short type, int index,
 	device->name = name;
 	device->devname = devname;
 
-	connman_element_register(device, NULL);
+	if (connman_element_register(device, NULL) < 0) {
+		connman_element_unregister(device);
+		return;
+	}
+
 	device_list = g_slist_append(device_list, device);
 }
 

commit f883452f576d8f9e51d2b474f5a5d4d33ab093f9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 18 02:08:29 2008 +0100

    Activate wpa_supplicant if needed

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index da274a03..bca325de 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1099,8 +1099,28 @@ int __supplicant_disconnect(struct connman_element *element)
 	return 0;
 }
 
+void __supplicant_activate(DBusConnection *conn)
+{
+	DBusMessage *message;
+
+	DBG("conn %p", conn);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, "/",
+				DBUS_INTERFACE_INTROSPECTABLE, "Introspect");
+        if (message == NULL)
+		return;
+
+	dbus_message_set_no_reply(message, TRUE);
+
+	dbus_connection_send(conn, message, NULL);
+
+	dbus_message_unref(message);
+}
+
 int __supplicant_init(DBusConnection *conn)
 {
+	DBG("conn %p", conn);
+
 	connection = conn;
 
 	if (dbus_connection_add_filter(connection,
@@ -1114,5 +1134,7 @@ int __supplicant_init(DBusConnection *conn)
 
 void __supplicant_exit(void)
 {
+	DBG("conn %p", connection);
+
 	dbus_connection_remove_filter(connection, supplicant_filter, NULL);
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 48cf89b1..4a746a64 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -58,6 +58,8 @@ struct supplicant_callback {
 					struct supplicant_network *network);
 };
 
+void __supplicant_activate(DBusConnection *conn);
+
 int __supplicant_init(DBusConnection *conn);
 void __supplicant_exit(void);
 
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 23fbb892..e38f2bba 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -653,6 +653,8 @@ static int wifi_init(void)
 
 	if (g_dbus_check_service(connection, SUPPLICANT_NAME) == TRUE)
 		supplicant_connect(connection, NULL);
+	else
+		__supplicant_activate(connection);
 
 	return 0;
 }

commit 71187176982da82f48deb8504fc033fb72c78f74
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 18 02:21:42 2008 +0100

    Fix duplicate wireless scan results

diff --git a/plugins/wifi.c b/plugins/wifi.c
index e38f2bba..f2153527 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -140,7 +140,7 @@ static struct connman_element *find_current_element(struct wifi_data *data,
 		struct connman_element *element = list->data;
 
 		if (connman_element_match_static_property(element,
-					"Name", &identifier) == TRUE)
+						"Name", &identifier) == TRUE)
 			return element;
 	}
 
@@ -156,7 +156,7 @@ static struct connman_element *find_pending_element(struct wifi_data *data,
 		struct connman_element *element = list->data;
 
 		if (connman_element_match_static_property(element,
-					"Name", &identifier) == TRUE)
+						"Name", &identifier) == TRUE)
 			return element;
 	}
 
@@ -170,11 +170,6 @@ static gboolean inactive_scan(gpointer user_data)
 
 	DBG("");
 
-	if (data->cleanup_timer > 0) {
-		g_source_remove(data->cleanup_timer);
-		data->cleanup_timer = 0;
-	}
-
 	__supplicant_scan(device);
 
 	data->inactive_timer = 0;
@@ -290,12 +285,14 @@ static void clear_results(struct connman_element *device)
 	DBG("pending %d", g_slist_length(data->pending));
 	DBG("current %d", g_slist_length(data->current));
 
+	if (data->cleanup_timer > 0) {
+		g_source_remove(data->cleanup_timer);
+		cleanup_pending(data);
+	}
+
 	data->pending = data->current;
 	data->current = NULL;
 
-	if (data->cleanup_timer > 0)
-		return;
-
 	data->cleanup_timer = g_timeout_add_seconds(CLEANUP_TIMEOUT,
 							cleanup_pending, data);
 }
@@ -457,7 +454,7 @@ static int wifi_disable(struct connman_element *element)
 
 	if (data->cleanup_timer > 0) {
 		g_source_remove(data->cleanup_timer);
-		data->cleanup_timer = 0;
+		cleanup_pending(data);
 	}
 
 	if (data->inactive_timer > 0) {
@@ -467,15 +464,6 @@ static int wifi_disable(struct connman_element *element)
 
 	__supplicant_disconnect(element);
 
-	for (list = data->pending; list; list = list->next) {
-		struct connman_element *network = list->data;
-
-		connman_element_unref(network);
-	}
-
-	g_slist_free(data->pending);
-	data->pending = NULL;
-
 	for (list = data->current; list; list = list->next) {
 		struct connman_element *network = list->data;
 

commit 76fc6c0e0c2ad9890a5cfde7b503b11276f64a95
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 18 04:26:09 2008 +0100

    Only allow WiFi devices to create networks for now

diff --git a/src/element.c b/src/element.c
index 6c07046f..11450539 100644
--- a/src/element.c
+++ b/src/element.c
@@ -637,6 +637,9 @@ static DBusMessage *device_create_network(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIFI)
+		return __connman_error_invalid_arguments(msg);
+
 	if (dbus_message_iter_init(msg, &iter) == FALSE)
 		return __connman_error_invalid_arguments(msg);
 

commit b8c73db85609c1d97cc9965d5ff2dc310ffb5d1a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 18 18:15:30 2008 +0100

    Release 0.5

diff --git a/ChangeLog b/ChangeLog
index 3b92407e..8955af96 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,14 @@
+ver 0.5:
+	Add support for handling Bluetooth adapters.
+	Add support for activating wpa_supplicant on demand.
+	Add Device property to network objects.
+	Add Scanning property to device objects.
+	Fix Name property of device objects.
+	Fix WiFi SSID to object path conversion.
+	Fix duplicate wireless scan results.
+	Fix built issue with libudev and uClibc.
+	Fix issues with element registration failures.
+
 ver 0.4:
 	Add DNS proxy resolver plugin.
 	Add support for default connections.
diff --git a/configure.ac b/configure.ac
index 8bf52546..0f81dde7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.50)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.4)
+AM_INIT_AUTOMAKE(connman, 0.5)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 8373959e1f96ad8ec6e0ceffff4dd3e5062ee180
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 19 11:55:48 2008 +0100

    Add skeleton for uDHCP plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 41f20bd2..25ec3565 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,12 +1,14 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = loopback.la ethernet.la wifi.la bluetooth.la \
-				netdev.la dhclient.la ipv4.la rtnllink.la \
+plugin_LTLIBRARIES = loopback.la netdev.la ethernet.la wifi.la bluetooth.la \
+				udhcp.la dhclient.la ipv4.la rtnllink.la \
 				dnsproxy.la resolvconf.la resolvfile.la
 
 loopback_la_SOURCES = loopback.c
 
+netdev_la_SOURCES = netdev.c
+
 ethernet_la_SOURCES = ethernet.c
 
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
@@ -15,7 +17,7 @@ wifi_la_LIBADD = @GDBUS_LIBS@
 bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
-netdev_la_SOURCES = netdev.c
+udhcp_la_SOURCES = udhcp.c
 
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
diff --git a/plugins/udhcp.c b/plugins/udhcp.c
new file mode 100644
index 00000000..ccd2f58b
--- /dev/null
+++ b/plugins/udhcp.c
@@ -0,0 +1,61 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static int udhcp_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	return 0;
+}
+
+static void udhcp_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver udhcp_driver = {
+	.name		= "udhcp",
+	.type		= CONNMAN_ELEMENT_TYPE_DHCP,
+	.priority	= CONNMAN_DRIVER_PRIORITY_HIGH,
+	.probe		= udhcp_probe,
+	.remove		= udhcp_remove,
+};
+
+static int udhcp_init(void)
+{
+	return connman_driver_register(&udhcp_driver);
+}
+
+static void udhcp_exit(void)
+{
+	connman_driver_unregister(&udhcp_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE(dhclient, "uDHCP client plugin", VERSION,
+						udhcp_init, udhcp_exit)

commit ae537ca940011f9c9e2e753f9ca74e3efc3db8ac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 19 19:04:21 2008 +0100

    Check for dhclient binary availability

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 06083b65..61dafe42 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#include <unistd.h>
 #include <sys/wait.h>
 #include <glib/gstdio.h>
 
@@ -135,6 +136,9 @@ static int dhclient_probe(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	if (access(DHCLIENT, X_OK) < 0)
+		return -errno;
+
 	task = g_try_new0(struct dhclient_task, 1);
 	if (task == NULL)
 		return -ENOMEM;

commit 7d5ec9de1cc7c0c50b8b54affc09b69f6a51b931
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 07:26:07 2008 +0100

    Return failure when disabling Bluetooth

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 6b0f05c4..6988693e 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -64,7 +64,7 @@ static int bluetooth_disable(struct connman_element *device)
 {
 	DBG("device %p name %s", device, device->name);
 
-	return 0;
+	return -EINVAL;
 }
 
 static struct connman_driver bluetooth_driver = {

commit 0548e30af62395997767f51ac5c0804f8d7545cc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 08:24:41 2008 +0100

    Add D-Bus helper for appending properties

diff --git a/include/dbus.h b/include/dbus.h
index 9c8a8933..97a58ba5 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -41,6 +41,9 @@ extern "C" {
 #define CONNMAN_NETWORK_INTERFACE	CONNMAN_SERVICE ".Network"
 #define CONNMAN_CONNECTION_INTERFACE	CONNMAN_SERVICE ".Connection"
 
+extern void connman_dbus_property_append_variant(DBusMessageIter *property,
+					const char *key, int type, void *val);
+
 extern void connman_dbus_dict_append_array(DBusMessageIter *dict,
 				const char *key, int type, void *val, int len);
 extern void connman_dbus_dict_append_variant(DBusMessageIter *dict,
diff --git a/src/dbus.c b/src/dbus.c
index 918fb0e5..333b4cf8 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -25,6 +25,50 @@
 
 #include <connman/dbus.h>
 
+void connman_dbus_property_append_variant(DBusMessageIter *iter,
+					const char *key, int type, void *val)
+{
+	DBusMessageIter value;
+	const char *signature;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &key);
+
+	switch (type) {
+	case DBUS_TYPE_BOOLEAN:
+		signature = DBUS_TYPE_BOOLEAN_AS_STRING;
+		break;
+	case DBUS_TYPE_STRING:
+		signature = DBUS_TYPE_STRING_AS_STRING;
+		break;
+	case DBUS_TYPE_BYTE:
+		signature = DBUS_TYPE_BYTE_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT16:
+		signature = DBUS_TYPE_UINT16_AS_STRING;
+		break;
+	case DBUS_TYPE_INT16:
+		signature = DBUS_TYPE_INT16_AS_STRING;
+		break;
+	case DBUS_TYPE_UINT32:
+		signature = DBUS_TYPE_UINT32_AS_STRING;
+		break;
+	case DBUS_TYPE_INT32:
+		signature = DBUS_TYPE_INT32_AS_STRING;
+		break;
+	case DBUS_TYPE_OBJECT_PATH:
+		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
+		break;
+	default:
+		signature = DBUS_TYPE_VARIANT_AS_STRING;
+		break;
+	}
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,
+							signature, &value);
+	dbus_message_iter_append_basic(&value, type, val);
+	dbus_message_iter_close_container(iter, &value);
+}
+
 void connman_dbus_dict_append_array(DBusMessageIter *dict,
 				const char *key, int type, void *val, int len)
 {
@@ -61,48 +105,12 @@ void connman_dbus_dict_append_array(DBusMessageIter *dict,
 void connman_dbus_dict_append_variant(DBusMessageIter *dict,
 					const char *key, int type, void *val)
 {
-	DBusMessageIter entry, value;
-	const char *signature;
+	DBusMessageIter entry;
 
 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
 
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	switch (type) {
-	case DBUS_TYPE_BOOLEAN:
-		signature = DBUS_TYPE_BOOLEAN_AS_STRING;
-		break;
-	case DBUS_TYPE_STRING:
-		signature = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_BYTE:
-		signature = DBUS_TYPE_BYTE_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT16:
-		signature = DBUS_TYPE_UINT16_AS_STRING;
-		break;
-	case DBUS_TYPE_INT16:
-		signature = DBUS_TYPE_INT16_AS_STRING;
-		break;
-	case DBUS_TYPE_UINT32:
-		signature = DBUS_TYPE_UINT32_AS_STRING;
-		break;
-	case DBUS_TYPE_INT32:
-		signature = DBUS_TYPE_INT32_AS_STRING;
-		break;
-	case DBUS_TYPE_OBJECT_PATH:
-		signature = DBUS_TYPE_OBJECT_PATH_AS_STRING;
-		break;
-	default:
-		signature = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							signature, &value);
-	dbus_message_iter_append_basic(&value, type, val);
-	dbus_message_iter_close_container(&entry, &value);
+	connman_dbus_property_append_variant(&entry, key, type, val);
 
 	dbus_message_iter_close_container(dict, &entry);
 }

commit f45eb6d3bac2de0cd890183583656411f0366f16
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 08:25:15 2008 +0100

    Add variable to hold a possible object path

diff --git a/include/element.h b/include/element.h
index 327b8df0..083533da 100644
--- a/include/element.h
+++ b/include/element.h
@@ -95,6 +95,7 @@ struct connman_element {
 	gboolean remember;
 	guint16 priority;
 	guint8 strength;
+	gchar *devpath;
 	gchar *devname;
 
 	struct connman_element *parent;
diff --git a/src/element.c b/src/element.c
index 11450539..0352646b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1195,6 +1195,7 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
 		g_free(element->devname);
+		g_free(element->devpath);
 		g_free(element->path);
 		g_free(element->name);
 		g_free(element);

commit c586908e887ba0f25efb682e0f835755d36077b8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 08:26:04 2008 +0100

    Add support for switching Bluetooth devices on and off

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 6988693e..d7ae2867 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -29,15 +29,19 @@
 
 #include <connman/plugin.h>
 #include <connman/driver.h>
+#include <connman/dbus.h>
 #include <connman/log.h>
 
 #define BLUEZ_SERVICE			"org.bluez"
 #define BLUEZ_MANAGER_INTERFACE		BLUEZ_SERVICE ".Manager"
 #define BLUEZ_ADAPTER_INTERFACE		BLUEZ_SERVICE ".Adapter"
 
+#define LIST_ADAPTERS			"ListAdapters"
 #define ADAPTER_ADDED			"AdapterAdded"
 #define ADAPTER_REMOVED			"AdapterRemoved"
+
 #define PROPERTY_CHANGED		"PropertyChanged"
+#define SET_PROPERTY			"SetProperty"
 
 #define TIMEOUT 5000
 
@@ -53,18 +57,65 @@ static void bluetooth_remove(struct connman_element *device)
 	DBG("device %p name %s", device, device->name);
 }
 
+static void powered_reply(DBusPendingCall *call, void *user_data)
+{
+	DBusMessage *reply;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	dbus_message_unref(reply);
+}
+
+static int change_powered(DBusConnection *connection, const char *path,
+							dbus_bool_t powered)
+{
+	DBusMessage *message;
+	DBusMessageIter iter;
+	DBusPendingCall *call;
+
+	DBG("");
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
+					BLUEZ_ADAPTER_INTERFACE, SET_PROPERTY);
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_iter_init_append(message, &iter);
+	connman_dbus_property_append_variant(&iter, "Powered",
+						DBUS_TYPE_BOOLEAN, &powered);
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to change Powered property");
+		dbus_message_unref(message);
+		return -EINVAL;
+	}
+
+	dbus_pending_call_set_notify(call, powered_reply, NULL, NULL);
+
+	dbus_message_unref(message);
+
+	return -EINPROGRESS;
+}
+
 static int bluetooth_enable(struct connman_element *device)
 {
+	DBusConnection *connection = connman_element_get_data(device);
+
 	DBG("device %p name %s", device, device->name);
 
-	return -EINVAL;
+	return change_powered(connection, device->devpath, TRUE);
 }
 
 static int bluetooth_disable(struct connman_element *device)
 {
+	DBusConnection *connection = connman_element_get_data(device);
+
 	DBG("device %p name %s", device, device->name);
 
-	return -EINVAL;
+	return change_powered(connection, device->devpath, FALSE);
 }
 
 static struct connman_driver bluetooth_driver = {
@@ -81,7 +132,6 @@ static GSList *device_list = NULL;
 
 static struct connman_element *find_adapter(const char *path)
 {
-	const char *devname = g_basename(path);
 	GSList *list;
 
 	DBG("path %s", path);
@@ -89,7 +139,7 @@ static struct connman_element *find_adapter(const char *path)
 	for (list = device_list; list; list = list->next) {
 		struct connman_element *device = list->data;
 
-		if (g_str_equal(device->devname, devname) == TRUE)
+		if (g_str_equal(device->devpath, path) == TRUE)
 			return device;
 	}
 
@@ -242,6 +292,9 @@ static void add_adapter(DBusConnection *connection, const char *path)
 	device->policy = CONNMAN_ELEMENT_POLICY_IGNORE;
 
 	device->name = g_path_get_basename(path);
+	device->devpath = g_strdup(path);
+
+	connman_element_set_data(device, connection);
 
 	if (connman_element_register(device, NULL) < 0) {
 		connman_element_unref(device);
@@ -338,7 +391,7 @@ static void bluetooth_connect(DBusConnection *connection, void *user_data)
 	DBG("connection %p", connection);
 
 	message = dbus_message_new_method_call(BLUEZ_SERVICE, "/",
-				BLUEZ_MANAGER_INTERFACE, "ListAdapters");
+				BLUEZ_MANAGER_INTERFACE, LIST_ADAPTERS);
 	if (message == NULL)
 		return;
 

commit 72c28aa582fccf616092b3baed5a0964a98a09d7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 08:42:13 2008 +0100

    Add generic reference to the global D-Bus connection

diff --git a/include/dbus.h b/include/dbus.h
index 97a58ba5..a0fe3fdc 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -41,6 +41,8 @@ extern "C" {
 #define CONNMAN_NETWORK_INTERFACE	CONNMAN_SERVICE ".Network"
 #define CONNMAN_CONNECTION_INTERFACE	CONNMAN_SERVICE ".Connection"
 
+extern DBusConnection *connman_dbus_get_connection(void);
+
 extern void connman_dbus_property_append_variant(DBusMessageIter *property,
 					const char *key, int type, void *val);
 
diff --git a/src/connman.h b/src/connman.h
index 4fca0507..70fcac1d 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -27,6 +27,9 @@
 #define NM_PATH       "/org/freedesktop/NetworkManager"
 #define NM_INTERFACE  NM_SERVICE
 
+int __connman_dbus_init(DBusConnection *conn);
+void __connman_dbus_cleanup(void);
+
 DBusMessage *__connman_error_failed(DBusMessage *msg);
 DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
diff --git a/src/dbus.c b/src/dbus.c
index 333b4cf8..6960a40f 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -114,3 +114,25 @@ void connman_dbus_dict_append_variant(DBusMessageIter *dict,
 
 	dbus_message_iter_close_container(dict, &entry);
 }
+
+static DBusConnection *connection = NULL;
+
+DBusConnection *connman_dbus_get_connection(void)
+{
+	if (connection == NULL)
+		return NULL;
+
+	return dbus_connection_ref(connection);
+}
+
+int __connman_dbus_init(DBusConnection *conn)
+{
+	connection = conn;
+
+	return 0;
+}
+
+void __connman_dbus_cleanup(void)
+{
+	connection = NULL;
+}
diff --git a/src/main.c b/src/main.c
index 929d31a8..638ad0bc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -150,6 +150,8 @@ int main(int argc, char *argv[])
 		}
 	}
 
+	__connman_dbus_init(conn);
+
 	__connman_storage_init();
 
 	__connman_element_init(conn, option_device);
@@ -187,6 +189,8 @@ int main(int argc, char *argv[])
 
 	__connman_storage_cleanup();
 
+	__connman_dbus_cleanup();
+
 selftest:
 	__connman_log_cleanup();
 

commit 60fe07bb4f740459d0ee42fd207085634354b9d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 08:46:36 2008 +0100

    Let plugins use connman_dbus_get_connection() function

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index d7ae2867..9a26a94b 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -466,7 +466,7 @@ static int bluetooth_init(void)
 {
 	int err = -EIO;
 
-	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	connection = connman_dbus_get_connection();
 	if (connection == NULL)
 		return -EIO;
 
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 61dafe42..2cb4930a 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -318,7 +318,7 @@ static int dhclient_init(void)
 	gchar *filter;
 	int err;
 
-	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	connection = connman_dbus_get_connection();
 
 	busname = dbus_bus_get_unique_name(connection);
 	busname = CONNMAN_SERVICE;
diff --git a/plugins/polkit.c b/plugins/polkit.c
index a2e15a99..1bf3f900 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -30,6 +30,7 @@
 
 #include <connman/plugin.h>
 #include <connman/security.h>
+#include <connman/dbus.h>
 #include <connman/log.h>
 
 #define ACTION "org.moblin.connman.modify"
@@ -124,7 +125,7 @@ static int polkit_init(void)
 {
 	int err;
 
-	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	connection = connman_dbus_get_connection();
 	if (connection == NULL)
 		return -EIO;
 
diff --git a/plugins/wifi.c b/plugins/wifi.c
index f2153527..dd769b57 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -36,6 +36,7 @@
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/rtnl.h>
+#include <connman/dbus.h>
 #include <connman/log.h>
 
 #include "inet.h"
@@ -619,7 +620,7 @@ static int wifi_init(void)
 {
 	int err;
 
-	connection = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	connection = connman_dbus_get_connection();
 	if (connection == NULL)
 		return -EIO;
 

commit 95fdd0345e76d6670787dad454265d3affdb52b9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 08:57:15 2008 +0100

    Use connman_dbus_dict_append_variant() instead of self-coded version

diff --git a/src/profile.c b/src/profile.c
index 057ece7e..86907701 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -37,23 +37,6 @@ void __connman_profile_list(DBusMessageIter *iter)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
-static void append_string(DBusMessageIter *dict, const char *key, void *val)
-{
-	DBusMessageIter entry, value;
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-					DBUS_TYPE_STRING_AS_STRING, &value);
-	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, val);
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -74,7 +57,8 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	append_string(&dict, "Name", &name);
+	connman_dbus_dict_append_variant(&dict, "Name",
+						DBUS_TYPE_STRING, &name);
 
 	dbus_message_iter_close_container(&array, &dict);
 

commit c40b50857d39ce1ba3110dea0abaa8c838c8b7c4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 09:07:13 2008 +0100

    Use private adapter data structure

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 9a26a94b..aec26d1e 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -45,16 +45,42 @@
 
 #define TIMEOUT 5000
 
-static int bluetooth_probe(struct connman_element *device)
+struct adapter_data {
+	DBusConnection *connection;
+};
+
+static int bluetooth_probe(struct connman_element *adapter)
 {
-	DBG("device %p name %s", device, device->name);
+	struct adapter_data *data;
+
+	DBG("adapter %p name %s", adapter, adapter->name);
+
+	data = g_try_new0(struct adapter_data, 1);
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->connection = connman_dbus_get_connection();
+	if (data->connection == NULL) {
+		g_free(data);
+		return -EIO;
+	}
+
+	connman_element_set_data(adapter, data);
 
 	return 0;
 }
 
-static void bluetooth_remove(struct connman_element *device)
+static void bluetooth_remove(struct connman_element *adapter)
 {
-	DBG("device %p name %s", device, device->name);
+	struct adapter_data *data = connman_element_get_data(adapter);
+
+	DBG("adapter %p name %s", adapter, adapter->name);
+
+	connman_element_set_data(adapter, NULL);
+
+	dbus_connection_unref(data->connection);
+
+	g_free(data);
 }
 
 static void powered_reply(DBusPendingCall *call, void *user_data)
@@ -100,22 +126,22 @@ static int change_powered(DBusConnection *connection, const char *path,
 	return -EINPROGRESS;
 }
 
-static int bluetooth_enable(struct connman_element *device)
+static int bluetooth_enable(struct connman_element *adapter)
 {
-	DBusConnection *connection = connman_element_get_data(device);
+	struct adapter_data *data = connman_element_get_data(adapter);
 
-	DBG("device %p name %s", device, device->name);
+	DBG("adapter %p name %s", adapter, adapter->name);
 
-	return change_powered(connection, device->devpath, TRUE);
+	return change_powered(data->connection, adapter->devpath, TRUE);
 }
 
-static int bluetooth_disable(struct connman_element *device)
+static int bluetooth_disable(struct connman_element *adapter)
 {
-	DBusConnection *connection = connman_element_get_data(device);
+	struct adapter_data *data = connman_element_get_data(adapter);
 
-	DBG("device %p name %s", device, device->name);
+	DBG("adapter %p name %s", adapter, adapter->name);
 
-	return change_powered(connection, device->devpath, FALSE);
+	return change_powered(data->connection, adapter->devpath, FALSE);
 }
 
 static struct connman_driver bluetooth_driver = {
@@ -294,8 +320,6 @@ static void add_adapter(DBusConnection *connection, const char *path)
 	device->name = g_path_get_basename(path);
 	device->devpath = g_strdup(path);
 
-	connman_element_set_data(device, connection);
-
 	if (connman_element_register(device, NULL) < 0) {
 		connman_element_unref(device);
 		return;

commit 3740318614518a1af92f22b297eb4603c6ca20e8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 09:38:46 2008 +0100

    Iterate over the Bluetooth Devices property

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index aec26d1e..9bb29d46 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -41,6 +41,7 @@
 #define ADAPTER_REMOVED			"AdapterRemoved"
 
 #define PROPERTY_CHANGED		"PropertyChanged"
+#define GET_PROPERTIES			"GetProperties"
 #define SET_PROPERTY			"SetProperty"
 
 #define TIMEOUT 5000
@@ -172,6 +173,29 @@ static struct connman_element *find_adapter(const char *path)
 	return NULL;
 }
 
+static void check_devices(struct connman_element *adapter,
+						DBusMessageIter *array)
+{
+	DBusMessageIter value;
+
+	DBG("adapter %p name %s", adapter, adapter->name);
+
+	if (dbus_message_iter_get_arg_type(array) != DBUS_TYPE_ARRAY)
+		return;
+
+	dbus_message_iter_recurse(array, &value);
+
+	while (dbus_message_iter_get_arg_type(&value) == DBUS_TYPE_OBJECT_PATH) {
+		const char *path;
+
+		dbus_message_iter_get_basic(&value, &path);
+
+		DBG("device %s", path);
+
+		dbus_message_iter_next(&value);
+	}
+}
+
 static void property_changed(DBusConnection *connection, DBusMessage *message)
 {
 	const char *path = dbus_message_get_path(message);
@@ -252,6 +276,8 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 			dbus_message_iter_get_basic(&value, &val);
 			connman_element_set_scanning(device, val);
+		} else if (g_str_equal(key, "Devices") == TRUE) {
+			check_devices(device, &value);
 		}
 
 		dbus_message_iter_next(&dict);
@@ -261,45 +287,6 @@ done:
 	dbus_message_unref(reply);
 }
 
-static void devices_reply(DBusPendingCall *call, void *user_data)
-{
-	DBusMessage *message = user_data;
-	const char *path = dbus_message_get_path(message);
-	DBusMessage *reply;
-	DBusError error;
-	char **devices;
-	int i, num_devices;
-
-	DBG("path %s", path);
-
-	dbus_message_unref(message);
-
-	reply = dbus_pending_call_steal_reply(call);
-
-	dbus_error_init(&error);
-
-	if (dbus_message_get_args(reply, &error,
-				DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
-						&devices, &num_devices,
-						DBUS_TYPE_INVALID) == FALSE) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Wrong arguments for device list");
-		goto done;
-	}
-
-	for (i = 0; i < num_devices; i++) {
-		DBG("device %s", devices[i]);
-	}
-
-	g_strfreev(devices);
-
-done:
-	dbus_message_unref(reply);
-}
-
 static void add_adapter(DBusConnection *connection, const char *path)
 {
 	struct connman_element *device;
@@ -328,7 +315,7 @@ static void add_adapter(DBusConnection *connection, const char *path)
 	device_list = g_slist_append(device_list, device);
 
 	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
-				BLUEZ_ADAPTER_INTERFACE, "GetProperties");
+				BLUEZ_ADAPTER_INTERFACE, GET_PROPERTIES);
 	if (message == NULL)
 		return;
 
@@ -340,20 +327,6 @@ static void add_adapter(DBusConnection *connection, const char *path)
 	}
 
 	dbus_pending_call_set_notify(call, properties_reply, message, NULL);
-
-	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
-				BLUEZ_ADAPTER_INTERFACE, "ListDevices");
-	if (message == NULL)
-		return;
-
-	if (dbus_connection_send_with_reply(connection, message,
-						&call, TIMEOUT) == FALSE) {
-		connman_error("Failed to get Bluetooth devices");
-		dbus_message_unref(message);
-		return;
-	}
-
-	dbus_pending_call_set_notify(call, devices_reply, message, NULL);
 }
 
 static void remove_adapter(DBusConnection *connection, const char *path)

commit 735cd2d81e0cc0696b868743030ac1fc4457e1e3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 21:53:04 2008 +0100

    Use tabs for indentation

diff --git a/gdbus/object.c b/gdbus/object.c
index e3e96ce0..4375ec5e 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -626,17 +626,17 @@ gboolean g_dbus_emit_signal(DBusConnection *connection,
 				const char *path, const char *interface,
 				const char *name, int type, ...)
 {
-        va_list args;
+	va_list args;
 	gboolean result;
 
-        va_start(args, type);
+	va_start(args, type);
 
 	result = emit_signal_valist(connection, path, interface,
 							name, type, args);
 
-        va_end(args);
+	va_end(args);
 
-        return result;
+	return result;
 }
 
 gboolean g_dbus_emit_signal_valist(DBusConnection *connection,

commit 7eb0cf5c259469ab07a6ec79cc316afe532cf5ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 16:18:05 2008 +0100

    Update property documentation

diff --git a/doc/device-api.txt b/doc/device-api.txt
index 7df37919..45c72155 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -52,7 +52,25 @@ Properties	string Name [readonly]
 
 		string Type [readonly]
 
-			The device type (for example ethernet, wifi etc.)
+			The device type (for example "ethernet", "wifi" etc.)
+
+		string Policy [readwrite]
+
+			Setting of the device power policy. Possible values
+			are "off", "ignore" and "auto".
+
+			The policy defines on how the device is initialized
+			when brought up. The actual device power state can
+			be changed independently to this value.
+
+			If a device is switched off and the policy is changed
+			to "auto", the device will be switched. For a current
+			active device changing the policy to "off" results
+			in powering down the device.
+
+			The "ignore" policy can be set for devices that are
+			detected, but managed by a different entity on the
+			system. For example complex network setups.
 
 		boolean Powered [readwrite]
 
@@ -60,6 +78,14 @@ Properties	string Name [readonly]
 			the list of networks in range. All known networks
 			will be still available via the Networks property.
 
+			Changing this value doesn't change the value of the
+			Policy property.
+
+			The value of this property can be changed by other
+			parts of the system (including the kernel). An
+			example would be modifications via the "ifconfig"
+			command line utility.
+
 		boolean Scanning [readonly]
 
 			Indicates if a device is scanning. Not all device
diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 9365e66f..7ebfa89b 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -45,6 +45,19 @@ Properties	string State [readonly]
 			values are "online" if at least one connection exists
 			and "offline" if no device is connected.
 
+		boolean FlightMode [readwrite]
+
+			The flight mode indicates the global setting for
+			switching all radios on or off. Changing flight mode
+			to true results in powering down all devices. When
+			leaving flight mode the individual policy of each
+			device decides to switch the radio back on or not.
+
+			During flight mode, it is still possible to switch
+			certain technologies manually back on. For example
+			the limited usage of WiFi or Bluetooth devices might
+			be allowed in some situations.
+
 		array{object} Profiles [readonly]
 
 			List of profile object paths.
diff --git a/doc/network-api.txt b/doc/network-api.txt
index ce487dd1..66ad6fbd 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -53,7 +53,8 @@ Properties	string Name [readonly]
 
 		uint8 Strength [readonly]
 
-			Indicates the signal strength of the network.
+			Indicates the signal strength of the network. This
+			is a normalized value between 0 and 100.
 
 		object Device [readonly]
 
@@ -65,6 +66,16 @@ Properties	string Name [readonly]
 			If the network type is WiFi, then this property is
 			present and contains the binary SSID value.
 
+		string WiFi.Mode [readonly, readwrite]
+
+			If the network type is WiFi, then this property is
+			present and contains the mode of the network. The
+			possible values are "managed" or "adhoc".
+
+			For scanned networks this value is read only, but in
+			case the network was manually created it is also
+			changeable.
+
 		string WiFi.Security [readonly, readwrite]
 
 			If the network type is WiFi, then this property is
@@ -75,7 +86,7 @@ Properties	string Name [readonly]
 			case the network was manually created it is also
 			changeable.
 
-			Possible values are NONE, WPA and WPA2.
+			Possible values are "none", "wep", "wpa" and "wpa2".
 
 		string WiFi.Passphrase [readwrite]
 
@@ -83,5 +94,5 @@ Properties	string Name [readonly]
 			requires, then this property is present and contains
 			the passphrase in clear text.
 
-			For system using PolicyKit, the access to this value
+			For systems using PolicyKit, the access to this value
 			will be protected by the security policy.

commit c1f1b9736e2deb99a0849dad70ed069797b12a2a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 16:39:34 2008 +0100

    Require at minimum autoconf 2.60

diff --git a/configure.ac b/configure.ac
index 0f81dde7..3dcc2df6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,4 +1,4 @@
-AC_PREREQ(2.50)
+AC_PREREQ(2.60)
 AC_INIT()
 
 AM_INIT_AUTOMAKE(connman, 0.5)

commit 32e29cbf5000a7750f3b3e2fc52f3c6828e778f9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 20:42:38 2008 +0100

    Turn warnings into errors when debugging is enabled

diff --git a/configure.ac b/configure.ac
index 3dcc2df6..72cf4467 100644
--- a/configure.ac
+++ b/configure.ac
@@ -32,7 +32,7 @@ AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
 				test "${ac_cv_prog_cc_g}" = "yes"); then
-		CFLAGS="$CFLAGS -g -O0"
+		CFLAGS="$CFLAGS -g -O0 -Werror"
 	fi
 ])
 

commit b93f19856e9a31a7615496d90133c4f2effdb4fa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 21:07:56 2008 +0100

    Create exported symbols list after all objects are built

diff --git a/src/Makefile.am b/src/Makefile.am
index 170e40a4..018fb15f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -42,7 +42,7 @@ EXTRA_DIST = $(dbus_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in
 
-connman.exp:
+connman.exp: $(connmand_OBJECTS)
 	nm -B *.o | awk '{ print $$3 }' | sort -u | grep -E -e '^connman_' > $@
 
 connman.ver: connman.exp

commit cbec83f07c92c4e5102a17902380719ac6d6f359
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 21:23:47 2008 +0100

    Add support for exporting the WiFi network mode

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index bca325de..0b84903e 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -655,6 +655,11 @@ static void extract_capabilites(struct supplicant_network *network,
 {
 	dbus_message_iter_get_basic(value, &network->capabilities);
 
+	if (network->capabilities & IEEE80211_CAP_ESS)
+		network->adhoc = FALSE;
+	else if (network->capabilities & IEEE80211_CAP_IBSS)
+		network->adhoc = TRUE;
+
 	if (network->capabilities & IEEE80211_CAP_PRIVACY)
 		network->has_wep = TRUE;
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 4a746a64..2afd003b 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -41,6 +41,7 @@ struct supplicant_network {
 	guint8 *ssid;
 	guint ssid_len;
 	guint16 capabilities;
+	gboolean adhoc;
 	gboolean has_wep;
 	gboolean has_wpa;
 	gboolean has_rsn;
diff --git a/plugins/wifi.c b/plugins/wifi.c
index dd769b57..f72cdb8e 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -328,6 +328,8 @@ static void scan_result(struct connman_element *device,
 
 	element = find_pending_element(data, network->identifier);
 	if (element == NULL) {
+		const char *mode;
+
 		element = connman_element_create(temp);
 
 		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
@@ -339,6 +341,10 @@ static void scan_result(struct connman_element *device,
 		connman_element_add_static_array_property(element, "WiFi.SSID",
 			DBUS_TYPE_BYTE, &network->ssid, network->ssid_len);
 
+		mode = (network->adhoc == TRUE) ? "adhoc" : "managed";
+		connman_element_add_static_property(element, "WiFi.Mode",
+						DBUS_TYPE_STRING, &mode);
+
 		if (element->wifi.security == NULL) {
 			const char *security;
 
@@ -359,7 +365,7 @@ static void scan_result(struct connman_element *device,
 		connman_element_add_static_property(element, "Strength",
 					DBUS_TYPE_BYTE, &element->strength);
 
-		DBG("%s (%s) strength %d", network->identifier,
+		DBG("%s (%s %s) strength %d", network->identifier, mode,
 				element->wifi.security, element->strength);
 
 		if (connman_element_register(element, device) < 0) {

commit a551cd60c5dba4da4bfc883e97f6b1766506f4ea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 21:28:19 2008 +0100

    Add device policy constants

diff --git a/include/device.h b/include/device.h
index 85f35817..31531481 100644
--- a/include/device.h
+++ b/include/device.h
@@ -48,6 +48,13 @@ enum connman_device_capabilities {
 	CONNMAN_DEVICE_CAPABILITY_SCANNING = (1 << 0),
 };
 
+enum connman_device_policy {
+	CONNMAN_DEVICE_POLICY_UNKNOWN = 0,
+	CONNMAN_DEVICE_POLICY_IGNORE  = 1,
+	CONNMAN_DEVICE_POLICY_AUTO    = 2,
+	CONNMAN_DEVICE_POLICY_OFF     = 3,
+};
+
 enum connman_device_state {
 	CONNMAN_DEVICE_STATE_UNKNOWN = 0,
 	CONNMAN_DEVICE_STATE_OFF     = 1,
@@ -58,6 +65,7 @@ struct connman_device_driver;
 struct connman_device {
 	struct connman_element *element;
 	unsigned long capabilities;
+	enum connman_device_policy policy;
 	enum connman_device_state state;
 
 	struct connman_device_driver *driver;

commit 9b8b75ff570c8c6ca38daf0a9c2a4ddf4356e9a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 21:33:01 2008 +0100

    Re-enable generic device driver infrastructure

diff --git a/src/device.c b/src/device.c
index 3ad61ffb..f49c5e77 100644
--- a/src/device.c
+++ b/src/device.c
@@ -29,7 +29,6 @@
 
 static GSList *driver_list = NULL;
 
-#if 0
 static gboolean match_driver(struct connman_device *device,
 					struct connman_device_driver *driver)
 {
@@ -94,21 +93,19 @@ static struct connman_driver device_driver = {
 	.probe		= device_probe,
 	.remove		= device_remove,
 };
-#endif
 
 int __connman_device_init(void)
 {
 	DBG("");
 
-	//return connman_driver_register(&device_driver);
-	return 0;
+	return connman_driver_register(&device_driver);
 }
 
 void __connman_device_cleanup(void)
 {
 	DBG("");
 
-	//connman_driver_unregister(&device_driver);
+	connman_driver_unregister(&device_driver);
 }
 
 static gint compare_priority(gconstpointer a, gconstpointer b)

commit 336ea570b5b9ba6f9e474de882cd91c9a665e22f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 22:29:25 2008 +0100

    Check for udhcpc binary

diff --git a/configure.ac b/configure.ac
index 72cf4467..87ec786f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -45,6 +45,7 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
+AC_PATH_PROG(UDHCPC, [udhcpc], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(DHCLIENT, [dhclient], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
 

commit e69a80ed4b1e7cd4c4fa1718d429b1515a251409
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 22:30:45 2008 +0100

    Check for resolvconf binary

diff --git a/configure.ac b/configure.ac
index 87ec786f..fea11302 100644
--- a/configure.ac
+++ b/configure.ac
@@ -47,6 +47,7 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 
 AC_PATH_PROG(UDHCPC, [udhcpc], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(DHCLIENT, [dhclient], ,$PATH:/sbin:/usr/sbin)
+AC_PATH_PROG(RESOLVCONF, [resolvconf], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
 
 AC_CHECK_LIB(dl, dlopen, dummy=yes,

commit 8f683573410f1ad35e700347c5018c8c4de22258
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 22:34:19 2008 +0100

    Use resolvconf binary found during configuration

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 25ec3565..7178e024 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -30,6 +30,7 @@ rtnllink_la_SOURCES = rtnllink.c inet.h inet.c
 dnsproxy_la_SOURCES = dnsproxy.c
 
 resolvconf_la_SOURCES = resolvconf.c
+resolvconf_la_CFLAGS = @GLIB_CFLAGS@ -DRESOLVCONF=\"@RESOLVCONF@\"
 
 resolvfile_la_SOURCES = resolvfile.c
 
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 0a1c0360..7dc12052 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -33,8 +33,6 @@
 
 #include <glib.h>
 
-#define RESOLVCONF "/sbin/resolvconf"
-
 static int resolvconf_append(const char *interface, const char *domain,
 							const char *server)
 {

commit 11a58a90b94da926e1263e8cb74b52a271d21dd9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 22:37:45 2008 +0100

    Provide udhcpc binary location from configuration

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 7178e024..2cde74b6 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -18,6 +18,7 @@ bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
 udhcp_la_SOURCES = udhcp.c
+udhcp_la_CFLAGS = @GLIB_CFLAGS@ -DUDHCPC=\"@UDHCPC@\"
 
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \

commit 6e6b7abe7bd37d1da6cf32b4f07f3011daeba612
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 22:52:38 2008 +0100

    Add property for global connection policy.

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 7ebfa89b..bf3d1de9 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -45,6 +45,18 @@ Properties	string State [readonly]
 			values are "online" if at least one connection exists
 			and "offline" if no device is connected.
 
+		string Policy [readwrite]
+
+			The global connection policy of a system. This
+			allows to configure how connections are established
+			and also when they are taken down again.
+
+			Possible values are "single", "multiple" and "ask".
+
+			For the single policy, the priority setting of the
+			device defines which becomes the default connection
+			when multiple are available.
+
 		boolean FlightMode [readwrite]
 
 			The flight mode indicates the global setting for

commit f3570489ceb89d349f3212548f40eff98e33ecf0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 22:56:23 2008 +0100

    Add global Policy property and cleanup State property

diff --git a/src/manager.c b/src/manager.c
index df53feff..14c8a6e6 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -105,31 +105,12 @@ static void append_connections(DBusMessageIter *dict)
 	dbus_message_iter_close_container(dict, &entry);
 }
 
-static void append_state(DBusMessageIter *dict, const char *state)
-{
-	DBusMessageIter entry, value;
-	const char *key = "State";
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-					DBUS_TYPE_STRING_AS_STRING, &value);
-
-	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, &state);
-
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	const char *state, *policy = "single";
 
 	DBG("conn %p", conn);
 
@@ -150,9 +131,15 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	append_connections(&dict);
 
 	if (__connman_element_count(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION) > 0)
-		append_state(&dict, "online");
+		state = "online";
 	else
-		append_state(&dict, "offline");
+		state = "offline";
+
+	connman_dbus_dict_append_variant(&dict, "State",
+						DBUS_TYPE_STRING, &state);
+
+	connman_dbus_dict_append_variant(&dict, "Policy",
+						DBUS_TYPE_STRING, &policy);
 
 	dbus_message_iter_close_container(&array, &dict);
 

commit da067394411a7176d8f6844edc251ae2dcb50355
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 21 23:03:23 2008 +0100

    Add test script for setting addresses

diff --git a/test/Makefile.am b/test/Makefile.am
index 2087e881..30546b9c 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -2,7 +2,7 @@
 EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
-		set-passphrase simple-agent show-introspection \
+		set-passphrase set-address simple-agent show-introspection \
 		test-manager test-compat monitor-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/set-address b/test/set-address
new file mode 100755
index 00000000..ebff30ad
--- /dev/null
+++ b/test/set-address
@@ -0,0 +1,26 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 2):
+	print "Usage: %s <address>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Device')
+
+	print "Setting static address %s for %s" % (sys.argv[1], path)
+
+	device.SetProperty("IPv4.Method", "static")
+	device.SetProperty("IPv4.Address", sys.argv[1])
+
+	print

commit b62fdd5b4c9ce7ea5f9ff4280bc1433982ec37be
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 08:27:34 2008 +0100

    Change udhcp plugin to fail driver binding

diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index ccd2f58b..dd7dd8cd 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -31,7 +31,7 @@ static int udhcp_probe(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
-	return 0;
+	return -ENODEV;
 }
 
 static void udhcp_remove(struct connman_element *element)

commit b32471b21a6d8583db0329b9f2c788e8611822e0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 08:28:51 2008 +0100

    Ignore network devices in generic driver

diff --git a/src/device.c b/src/device.c
index f49c5e77..b70b95f8 100644
--- a/src/device.c
+++ b/src/device.c
@@ -46,6 +46,9 @@ static int device_probe(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_NETWORK)
+		return -ENODEV;
+
 	device = g_try_new0(struct connman_device, 1);
 	if (device == NULL)
 		return -ENOMEM;

commit ba68ec516ff25953c798a4dccd1d7867a9419a92
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 08:53:57 2008 +0100

    Add copy of RFC 2131 (DHCP system)

diff --git a/doc/rfc2131.txt b/doc/rfc2131.txt
new file mode 100644
index 00000000..f45d9b86
--- /dev/null
+++ b/doc/rfc2131.txt
@@ -0,0 +1,2523 @@
+
+
+
+
+
+
+Network Working Group                                           R. Droms
+Request for Comments: 2131                           Bucknell University
+Obsoletes: 1541                                               March 1997
+Category: Standards Track
+
+                  Dynamic Host Configuration Protocol
+
+Status of this memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   The Dynamic Host Configuration Protocol (DHCP) provides a framework
+   for passing configuration information to hosts on a TCPIP network.
+   DHCP is based on the Bootstrap Protocol (BOOTP) [7], adding the
+   capability of automatic allocation of reusable network addresses and
+   additional configuration options [19].  DHCP captures the behavior of
+   BOOTP relay agents [7, 21], and DHCP participants can interoperate
+   with BOOTP participants [9].
+
+Table of Contents
+
+   1.  Introduction. . . . . . . . . . . . . . . . . . . . . . . . .  2
+   1.1 Changes to RFC1541. . . . . . . . . . . . . . . . . . . . . .  3
+   1.2 Related Work. . . . . . . . . . . . . . . . . . . . . . . . .  4
+   1.3 Problem definition and issues . . . . . . . . . . . . . . . .  4
+   1.4 Requirements. . . . . . . . . . . . . . . . . . . . . . . . .  5
+   1.5 Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  6
+   1.6 Design goals. . . . . . . . . . . . . . . . . . . . . . . . .  6
+   2.  Protocol Summary. . . . . . . . . . . . . . . . . . . . . . .  8
+   2.1 Configuration parameters repository . . . . . . . . . . . . . 11
+   2.2 Dynamic allocation of network addresses . . . . . . . . . . . 12
+   3.  The Client-Server Protocol. . . . . . . . . . . . . . . . . . 13
+   3.1 Client-server interaction - allocating a network address. . . 13
+   3.2 Client-server interaction - reusing a  previously allocated
+       network address . . . . . . . . . . . . . . . . . . . . . . . 17
+   3.3 Interpretation and representation of time values. . . . . . . 20
+   3.4 Obtaining parameters with externally configured network
+       address . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
+   3.5 Client parameters in DHCP . . . . . . . . . . . . . . . . . . 21
+   3.6 Use of DHCP in clients with multiple interfaces . . . . . . . 22
+   3.7 When clients should use DHCP. . . . . . . . . . . . . . . . . 22
+   4.  Specification of the DHCP client-server protocol. . . . . . . 22
+
+
+
+Droms                       Standards Track                     [Page 1]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   4.1 Constructing and sending DHCP messages. . . . . . . . . . . . 22
+   4.2 DHCP server administrative controls . . . . . . . . . . . . . 25
+   4.3 DHCP server behavior. . . . . . . . . . . . . . . . . . . . . 26
+   4.4 DHCP client behavior. . . . . . . . . . . . . . . . . . . . . 34
+   5.  Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . .42
+   6.  References . . . . . . . . . . . . . . . . . . . . . . . . . .42
+   7.  Security Considerations. . . . . . . . . . . . . . . . . . . .43
+   8.  Author's Address . . . . . . . . . . . . . . . . . . . . . . .44
+   A.  Host Configuration Parameters  . . . . . . . . . . . . . . . .45
+List of Figures
+   1. Format of a DHCP message . . . . . . . . . . . . . . . . . . .  9
+   2. Format of the 'flags' field. . . . . . . . . . . . . . . . . . 11
+   3. Timeline diagram of messages exchanged between DHCP client and
+      servers when allocating a new network address. . . . . . . . . 15
+   4. Timeline diagram of messages exchanged between DHCP client and
+      servers when reusing a previously allocated network address. . 18
+   5. State-transition diagram for DHCP clients. . . . . . . . . . . 34
+List of Tables
+   1. Description of fields in a DHCP message. . . . . . . . . . . . 10
+   2. DHCP messages. . . . . . . . . . . . . . . . . . . . . . . . . 14
+   3. Fields and options used by DHCP servers. . . . . . . . . . . . 28
+   4. Client messages from various states. . . . . . . . . . . . . . 33
+   5. Fields and options used by DHCP clients. . . . . . . . . . . . 37
+
+1. Introduction
+
+   The Dynamic Host Configuration Protocol (DHCP) provides configuration
+   parameters to Internet hosts.  DHCP consists of two components: a
+   protocol for delivering host-specific configuration parameters from a
+   DHCP server to a host and a mechanism for allocation of network
+   addresses to hosts.
+
+   DHCP is built on a client-server model, where designated DHCP server
+   hosts allocate network addresses and deliver configuration parameters
+   to dynamically configured hosts.  Throughout the remainder of this
+   document, the term "server" refers to a host providing initialization
+   parameters through DHCP, and the term "client" refers to a host
+   requesting initialization parameters from a DHCP server.
+
+   A host should not act as a DHCP server unless explicitly configured
+   to do so by a system administrator.  The diversity of hardware and
+   protocol implementations in the Internet would preclude reliable
+   operation if random hosts were allowed to respond to DHCP requests.
+   For example, IP requires the setting of many parameters within the
+   protocol implementation software.  Because IP can be used on many
+   dissimilar kinds of network hardware, values for those parameters
+   cannot be guessed or assumed to have correct defaults.  Also,
+   distributed address allocation schemes depend on a polling/defense
+
+
+
+Droms                       Standards Track                     [Page 2]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   mechanism for discovery of addresses that are already in use.  IP
+   hosts may not always be able to defend their network addresses, so
+   that such a distributed address allocation scheme cannot be
+   guaranteed to avoid allocation of duplicate network addresses.
+
+   DHCP supports three mechanisms for IP address allocation.  In
+   "automatic allocation", DHCP assigns a permanent IP address to a
+   client.  In "dynamic allocation", DHCP assigns an IP address to a
+   client for a limited period of time (or until the client explicitly
+   relinquishes the address).  In "manual allocation", a client's IP
+   address is assigned by the network administrator, and DHCP is used
+   simply to convey the assigned address to the client.  A particular
+   network will use one or more of these mechanisms, depending on the
+   policies of the network administrator.
+
+   Dynamic allocation is the only one of the three mechanisms that
+   allows automatic reuse of an address that is no longer needed by the
+   client to which it was assigned.  Thus, dynamic allocation is
+   particularly useful for assigning an address to a client that will be
+   connected to the network only temporarily or for sharing a limited
+   pool of IP addresses among a group of clients that do not need
+   permanent IP addresses.  Dynamic allocation may also be a good choice
+   for assigning an IP address to a new client being permanently
+   connected to a network where IP addresses are sufficiently scarce
+   that it is important to reclaim them when old clients are retired.
+   Manual allocation allows DHCP to be used to eliminate the error-prone
+   process of manually configuring hosts with IP addresses in
+   environments where (for whatever reasons) it is desirable to manage
+   IP address assignment outside of the DHCP mechanisms.
+
+   The format of DHCP messages is based on the format of BOOTP messages,
+   to capture the BOOTP relay agent behavior described as part of the
+   BOOTP specification [7, 21] and to allow interoperability of existing
+   BOOTP clients with DHCP servers.  Using BOOTP relay agents eliminates
+   the necessity of having a DHCP server on each physical network
+   segment.
+
+1.1 Changes to RFC 1541
+
+   This document updates the DHCP protocol specification that appears in
+   RFC1541.  A new DHCP message type, DHCPINFORM, has been added; see
+   section 3.4, 4.3 and 4.4 for details.  The classing mechanism for
+   identifying DHCP clients to DHCP servers has been extended to include
+   "vendor" classes as defined in sections 4.2 and 4.3.  The minimum
+   lease time restriction has been removed.  Finally, many editorial
+   changes have been made to clarify the text as a result of experience
+   gained in DHCP interoperability tests.
+
+
+
+
+Droms                       Standards Track                     [Page 3]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+1.2 Related Work
+
+   There are several Internet protocols and related mechanisms that
+   address some parts of the dynamic host configuration problem.  The
+   Reverse Address Resolution Protocol (RARP) [10] (through the
+   extensions defined in the Dynamic RARP (DRARP) [5]) explicitly
+   addresses the problem of network address discovery, and includes an
+   automatic IP address assignment mechanism.  The Trivial File Transfer
+   Protocol (TFTP) [20] provides for transport of a boot image from a
+   boot server.  The Internet Control Message Protocol (ICMP) [16]
+   provides for informing hosts of additional routers via "ICMP
+   redirect" messages.  ICMP also can provide subnet mask information
+   through the "ICMP mask request" message and other information through
+   the (obsolete) "ICMP information request" message.  Hosts can locate
+   routers through the ICMP router discovery mechanism [8].
+
+   BOOTP is a transport mechanism for a collection of configuration
+   information.  BOOTP is also extensible, and official extensions [17]
+   have been defined for several configuration parameters.  Morgan has
+   proposed extensions to BOOTP for dynamic IP address assignment [15].
+   The Network Information Protocol (NIP), used by the Athena project at
+   MIT, is a distributed mechanism for dynamic IP address assignment
+   [19].  The Resource Location Protocol RLP [1] provides for location
+   of higher level services.  Sun Microsystems diskless workstations use
+   a boot procedure that employs RARP, TFTP and an RPC mechanism called
+   "bootparams" to deliver configuration information and operating
+   system code to diskless hosts.  (Sun Microsystems, Sun Workstation
+   and SunOS are trademarks of Sun Microsystems, Inc.)  Some Sun
+   networks also use DRARP and an auto-installation mechanism to
+   automate the configuration of new hosts in an existing network.
+
+   In other related work, the path minimum transmission unit (MTU)
+   discovery algorithm can determine the MTU of an arbitrary internet
+   path [14].  The Address Resolution Protocol (ARP) has been proposed
+   as a transport protocol for resource location and selection [6].
+   Finally, the Host Requirements RFCs [3, 4] mention specific
+   requirements for host reconfiguration and suggest a scenario for
+   initial configuration of diskless hosts.
+
+1.3 Problem definition and issues
+
+   DHCP is designed to supply DHCP clients with the configuration
+   parameters defined in the Host Requirements RFCs.  After obtaining
+   parameters via DHCP, a DHCP client should be able to exchange packets
+   with any other host in the Internet.  The TCP/IP stack parameters
+   supplied by DHCP are listed in Appendix A.
+
+
+
+
+
+Droms                       Standards Track                     [Page 4]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   Not all of these parameters are required for a newly initialized
+   client.  A client and server may negotiate for the transmission of
+   only those parameters required by the client or specific to a
+   particular subnet.
+
+   DHCP allows but does not require the configuration of client
+   parameters not directly related to the IP protocol.  DHCP also does
+   not address registration of newly configured clients with the Domain
+   Name System (DNS) [12, 13].
+
+   DHCP is not intended for use in configuring routers.
+
+1.4 Requirements
+
+   Throughout this document, the words that are used to define the
+   significance of particular requirements are capitalized.  These words
+   are:
+
+      o "MUST"
+
+        This word or the adjective "REQUIRED" means that the
+        item is an absolute requirement of this specification.
+
+      o "MUST NOT"
+
+        This phrase means that the item is an absolute prohibition
+        of this specification.
+
+      o "SHOULD"
+
+        This word or the adjective "RECOMMENDED" means that there
+        may exist valid reasons in particular circumstances to ignore
+        this item, but the full implications should be understood and
+        the case carefully weighed before choosing a different course.
+
+      o "SHOULD NOT"
+
+        This phrase means that there may exist valid reasons in
+        particular circumstances when the listed behavior is acceptable
+        or even useful, but the full implications should be understood
+        and the case carefully weighed before implementing any behavior
+        described with this label.
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                     [Page 5]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      o "MAY"
+
+        This word or the adjective "OPTIONAL" means that this item is
+        truly optional.  One vendor may choose to include the item
+        because a particular marketplace requires it or because it
+        enhances the product, for example; another vendor may omit the
+        same item.
+
+1.5 Terminology
+
+   This document uses the following terms:
+
+      o "DHCP client"
+
+      A DHCP client is an Internet host using DHCP to obtain
+      configuration parameters such as a network address.
+
+      o "DHCP server"
+
+      A DHCP server is an Internet host that returns configuration
+      parameters to DHCP clients.
+
+      o "BOOTP relay agent"
+
+      A BOOTP relay agent or relay agent is an Internet host or router
+      that passes DHCP messages between DHCP clients and DHCP servers.
+      DHCP is designed to use the same relay agent behavior as specified
+      in the BOOTP protocol specification.
+
+      o "binding"
+
+      A binding is a collection of configuration parameters, including
+      at least an IP address, associated with or "bound to" a DHCP
+      client.  Bindings are managed by DHCP servers.
+
+1.6 Design goals
+
+   The following list gives general design goals for DHCP.
+
+      o DHCP should be a mechanism rather than a policy.  DHCP must
+        allow local system administrators control over configuration
+        parameters where desired; e.g., local system administrators
+        should be able to enforce local policies concerning allocation
+        and access to local resources where desired.
+
+
+
+
+
+
+
+Droms                       Standards Track                     [Page 6]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      o Clients should require no manual configuration.  Each client
+        should be able to discover appropriate local configuration
+        parameters without user intervention and incorporate those
+        parameters into its own configuration.
+
+      o Networks should require no manual configuration for individual
+        clients.  Under normal circumstances, the network manager
+        should not have to enter any per-client configuration
+        parameters.
+
+      o DHCP should not require a server on each subnet.  To allow for
+        scale and economy, DHCP must work across routers or through the
+        intervention of BOOTP relay agents.
+
+      o A DHCP client must be prepared to receive multiple responses
+        to a request for configuration parameters.  Some installations
+        may include multiple, overlapping DHCP servers to enhance
+        reliability and increase performance.
+
+      o DHCP must coexist with statically configured, non-participating
+        hosts and with existing network protocol implementations.
+
+      o DHCP must interoperate with the BOOTP relay agent behavior as
+        described by RFC 951 and by RFC 1542 [21].
+
+      o DHCP must provide service to existing BOOTP clients.
+
+   The following list gives design goals specific to the transmission of
+   the network layer parameters.  DHCP must:
+
+      o Guarantee that any specific network address will not be in
+        use by more than one DHCP client at a time,
+
+      o Retain DHCP client configuration across DHCP client reboot.  A
+        DHCP client should, whenever possible, be assigned the same
+        configuration parameters (e.g., network address) in response
+        to each request,
+
+      o Retain DHCP client configuration across server reboots, and,
+        whenever possible, a DHCP client should be assigned the same
+        configuration parameters despite restarts of the DHCP mechanism,
+
+      o Allow automated assignment of configuration parameters to new
+        clients to avoid hand configuration for new clients,
+
+      o Support fixed or permanent allocation of configuration
+        parameters to specific clients.
+
+
+
+
+Droms                       Standards Track                     [Page 7]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+2. Protocol Summary
+
+   From the client's point of view, DHCP is an extension of the BOOTP
+   mechanism.  This behavior allows existing BOOTP clients to
+   interoperate with DHCP servers without requiring any change to the
+   clients' initialization software.  RFC 1542 [2] details the
+   interactions between BOOTP and DHCP clients and servers [9].  There
+   are some new, optional transactions that optimize the interaction
+   between DHCP clients and servers that are described in sections 3 and
+   4.
+
+   Figure 1 gives the format of a DHCP message and table 1 describes
+   each of the fields in the DHCP message.  The numbers in parentheses
+   indicate the size of each field in octets.  The names for the fields
+   given in the figure will be used throughout this document to refer to
+   the fields in DHCP messages.
+
+   There are two primary differences between DHCP and BOOTP.  First,
+   DHCP defines mechanisms through which clients can be assigned a
+   network address for a finite lease, allowing for serial reassignment
+   of network addresses to different clients.  Second, DHCP provides the
+   mechanism for a client to acquire all of the IP configuration
+   parameters that it needs in order to operate.
+
+   DHCP introduces a small change in terminology intended to clarify the
+   meaning of one of the fields.  What was the "vendor extensions" field
+   in BOOTP has been re-named the "options" field in DHCP. Similarly,
+   the tagged data items that were used inside the BOOTP "vendor
+   extensions" field, which were formerly referred to as "vendor
+   extensions," are now termed simply "options."
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                     [Page 8]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   0                   1                   2                   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
+   +---------------+---------------+---------------+---------------+
+   |                            xid (4)                            |
+   +-------------------------------+-------------------------------+
+   |           secs (2)            |           flags (2)           |
+   +-------------------------------+-------------------------------+
+   |                          ciaddr  (4)                          |
+   +---------------------------------------------------------------+
+   |                          yiaddr  (4)                          |
+   +---------------------------------------------------------------+
+   |                          siaddr  (4)                          |
+   +---------------------------------------------------------------+
+   |                          giaddr  (4)                          |
+   +---------------------------------------------------------------+
+   |                                                               |
+   |                          chaddr  (16)                         |
+   |                                                               |
+   |                                                               |
+   +---------------------------------------------------------------+
+   |                                                               |
+   |                          sname   (64)                         |
+   +---------------------------------------------------------------+
+   |                                                               |
+   |                          file    (128)                        |
+   +---------------------------------------------------------------+
+   |                                                               |
+   |                          options (variable)                   |
+   +---------------------------------------------------------------+
+
+                  Figure 1:  Format of a DHCP message
+
+   DHCP defines a new 'client identifier' option that is used to pass an
+   explicit client identifier to a DHCP server.  This change eliminates
+   the overloading of the 'chaddr' field in BOOTP messages, where
+   'chaddr' is used both as a hardware address for transmission of BOOTP
+   reply messages and as a client identifier.  The 'client identifier'
+   is an opaque key, not to be interpreted by the server; for example,
+   the 'client identifier' may contain a hardware address, identical to
+   the contents of the 'chaddr' field, or it may contain another type of
+   identifier, such as a DNS name.  The 'client identifier' chosen by a
+   DHCP client MUST be unique to that client within the subnet to which
+   the client is attached. If the client uses a 'client identifier' in
+   one message, it MUST use that same identifier in all subsequent
+   messages, to ensure that all servers correctly identify the client.
+
+
+
+
+Droms                       Standards Track                     [Page 9]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   DHCP clarifies the interpretation of the 'siaddr' field as the
+   address of the server to use in the next step of the client's
+   bootstrap process.  A DHCP server may return its own address in the
+   'siaddr' field, if the server is prepared to supply the next
+   bootstrap service (e.g., delivery of an operating system executable
+   image).  A DHCP server always returns its own address in the 'server
+   identifier' option.
+
+   FIELD      OCTETS       DESCRIPTION
+   -----      ------       -----------
+
+   op            1  Message op code / message type.
+                    1 = BOOTREQUEST, 2 = BOOTREPLY
+   htype         1  Hardware address type, see ARP section in "Assigned
+                    Numbers" RFC; e.g., '1' = 10mb ethernet.
+   hlen          1  Hardware address length (e.g.  '6' for 10mb
+                    ethernet).
+   hops          1  Client sets to zero, optionally used by relay agents
+                    when booting via a relay agent.
+   xid           4  Transaction ID, a random number chosen by the
+                    client, used by the client and server to associate
+                    messages and responses between a client and a
+                    server.
+   secs          2  Filled in by client, seconds elapsed since client
+                    began address acquisition or renewal process.
+   flags         2  Flags (see figure 2).
+   ciaddr        4  Client IP address; only filled in if client is in
+                    BOUND, RENEW or REBINDING state and can respond
+                    to ARP requests.
+   yiaddr        4  'your' (client) IP address.
+   siaddr        4  IP address of next server to use in bootstrap;
+                    returned in DHCPOFFER, DHCPACK by server.
+   giaddr        4  Relay agent IP address, used in booting via a
+                    relay agent.
+   chaddr       16  Client hardware address.
+   sname        64  Optional server host name, null terminated string.
+   file        128  Boot file name, null terminated string; "generic"
+                    name or null in DHCPDISCOVER, fully qualified
+                    directory-path name in DHCPOFFER.
+   options     var  Optional parameters field.  See the options
+                    documents for a list of defined options.
+
+           Table 1:  Description of fields in a DHCP message
+
+   The 'options' field is now variable length. A DHCP client must be
+   prepared to receive DHCP messages with an 'options' field of at least
+   length 312 octets.  This requirement implies that a DHCP client must
+   be prepared to receive a message of up to 576 octets, the minimum IP
+
+
+
+Droms                       Standards Track                    [Page 10]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   datagram size an IP host must be prepared to accept [3].  DHCP
+   clients may negotiate the use of larger DHCP messages through the
+   'maximum DHCP message size' option.  The options field may be further
+   extended into the 'file' and 'sname' fields.
+
+   In the case of a client using DHCP for initial configuration (before
+   the client's TCP/IP software has been completely configured), DHCP
+   requires creative use of the client's TCP/IP software and liberal
+   interpretation of RFC 1122.  The TCP/IP software SHOULD accept and
+   forward to the IP layer any IP packets delivered to the client's
+   hardware address before the IP address is configured; DHCP servers
+   and BOOTP relay agents may not be able to deliver DHCP messages to
+   clients that cannot accept hardware unicast datagrams before the
+   TCP/IP software is configured.
+
+   To work around some clients that cannot accept IP unicast datagrams
+   before the TCP/IP software is configured as discussed in the previous
+   paragraph, DHCP uses the 'flags' field [21].  The leftmost bit is
+   defined as the BROADCAST (B) flag.  The semantics of this flag are
+   discussed in section 4.1 of this document.  The remaining bits of the
+   flags field are reserved for future use.  They MUST be set to zero by
+   clients and ignored by servers and relay agents.  Figure 2 gives the
+   format of the 'flags' field.
+
+                                    1 1 1 1 1 1
+                0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                |B|             MBZ             |
+                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+                B:  BROADCAST flag
+
+                MBZ:  MUST BE ZERO (reserved for future use)
+
+                Figure 2:  Format of the 'flags' field
+
+2.1 Configuration parameters repository
+
+   The first service provided by DHCP is to provide persistent storage
+   of network parameters for network clients.  The model of DHCP
+   persistent storage is that the DHCP service stores a key-value entry
+   for each client, where the key is some unique identifier (for
+   example, an IP subnet number and a unique identifier within the
+   subnet) and the value contains the configuration parameters for the
+   client.
+
+   For example, the key might be the pair (IP-subnet-number, hardware-
+   address) (note that the "hardware-address" should be typed by the
+
+
+
+Droms                       Standards Track                    [Page 11]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   type of hardware to accommodate possible duplication of hardware
+   addresses resulting from bit-ordering problems in a mixed-media,
+   bridged network) allowing for serial or concurrent reuse of a
+   hardware address on different subnets, and for hardware addresses
+   that may not be globally unique.  Alternately, the key might be the
+   pair (IP-subnet-number, hostname), allowing the server to assign
+   parameters intelligently to a DHCP client that has been moved to a
+   different subnet or has changed hardware addresses (perhaps because
+   the network interface failed and was replaced). The protocol defines
+   that the key will be (IP-subnet-number, hardware-address) unless the
+   client explicitly supplies an identifier using the 'client
+   identifier' option.           A client can query the DHCP service to
+   retrieve its configuration parameters.  The client interface to the
+   configuration parameters repository consists of protocol messages to
+   request configuration parameters and responses from the server
+   carrying the configuration parameters.
+
+2.2 Dynamic allocation of network addresses
+
+   The second service provided by DHCP is the allocation of temporary or
+   permanent network (IP) addresses to clients.  The basic mechanism for
+   the dynamic allocation of network addresses is simple: a client
+   requests the use of an address for some period of time.  The
+   allocation mechanism (the collection of DHCP servers) guarantees not
+   to reallocate that address within the requested time and attempts to
+   return the same network address each time the client requests an
+   address.  In this document, the period over which a network address
+   is allocated to a client is referred to as a "lease" [11].  The
+   client may extend its lease with subsequent requests.  The client may
+   issue a message to release the address back to the server when the
+   client no longer needs the address.  The client may ask for a
+   permanent assignment by asking for an infinite lease.  Even when
+   assigning "permanent" addresses, a server may choose to give out
+   lengthy but non-infinite leases to allow detection of the fact that
+   the client has been retired.
+
+   In some environments it will be necessary to reassign network
+   addresses due to exhaustion of available addresses.  In such
+   environments, the allocation mechanism will reuse addresses whose
+   lease has expired.  The server should use whatever information is
+   available in the configuration information repository to choose an
+   address to reuse.  For example, the server may choose the least
+   recently assigned address.  As a consistency check, the allocating
+   server SHOULD probe the reused address before allocating the address,
+   e.g., with an ICMP echo request, and the client SHOULD probe the
+   newly received address, e.g., with ARP.
+
+
+
+
+
+Droms                       Standards Track                    [Page 12]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+3. The Client-Server Protocol
+
+   DHCP uses the BOOTP message format defined in RFC 951 and given in
+   table 1 and figure 1.  The 'op' field of each DHCP message sent from
+   a client to a server contains BOOTREQUEST. BOOTREPLY is used in the
+   'op' field of each DHCP message sent from a server to a client.
+
+   The first four octets of the 'options' field of the DHCP message
+   contain the (decimal) values 99, 130, 83 and 99, respectively (this
+   is the same magic cookie as is defined in RFC 1497 [17]).  The
+   remainder of the 'options' field consists of a list of tagged
+   parameters that are called "options".  All of the "vendor extensions"
+   listed in RFC 1497 are also DHCP options.  RFC 1533 gives the
+   complete set of options defined for use with DHCP.
+
+   Several options have been defined so far.  One particular option -
+   the "DHCP message type" option - must be included in every DHCP
+   message.  This option defines the "type" of the DHCP message.
+   Additional options may be allowed, required, or not allowed,
+   depending on the DHCP message type.
+
+   Throughout this document, DHCP messages that include a 'DHCP message
+   type' option will be referred to by the type of the message; e.g., a
+   DHCP message with 'DHCP message type' option type 1 will be referred
+   to as a "DHCPDISCOVER" message.
+
+3.1 Client-server interaction - allocating a network address
+
+   The following summary of the protocol exchanges between clients and
+   servers refers to the DHCP messages described in table 2.  The
+   timeline diagram in figure 3 shows the timing relationships in a
+   typical client-server interaction.  If the client already knows its
+   address, some steps may be omitted; this abbreviated interaction is
+   described in section 3.2.
+
+   1. The client broadcasts a DHCPDISCOVER message on its local physical
+      subnet.  The DHCPDISCOVER message MAY include options that suggest
+      values for the network address and lease duration.  BOOTP relay
+      agents may pass the message on to DHCP servers not on the same
+      physical subnet.
+
+   2. Each server may respond with a DHCPOFFER message that includes an
+      available network address in the 'yiaddr' field (and other
+      configuration parameters in DHCP options).  Servers need not
+      reserve the offered network address, although the protocol will
+      work more efficiently if the server avoids allocating the offered
+      network address to another client.  When allocating a new address,
+      servers SHOULD check that the offered network address is not
+
+
+
+Droms                       Standards Track                    [Page 13]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      already in use; e.g., the server may probe the offered address
+      with an ICMP Echo Request.  Servers SHOULD be implemented so that
+      network administrators MAY choose to disable probes of newly
+      allocated addresses.  The server transmits the DHCPOFFER message
+      to the client, using the BOOTP relay agent if necessary.
+
+   Message         Use
+   -------         ---
+
+   DHCPDISCOVER -  Client broadcast to locate available servers.
+
+   DHCPOFFER    -  Server to client in response to DHCPDISCOVER with
+                   offer of configuration parameters.
+
+   DHCPREQUEST  -  Client message to servers either (a) requesting
+                   offered parameters from one server and implicitly
+                   declining offers from all others, (b) confirming
+                   correctness of previously allocated address after,
+                   e.g., system reboot, or (c) extending the lease on a
+                   particular network address.
+
+   DHCPACK      -  Server to client with configuration parameters,
+                   including committed network address.
+
+   DHCPNAK      -  Server to client indicating client's notion of network
+                   address is incorrect (e.g., client has moved to new
+                   subnet) or client's lease as expired
+
+   DHCPDECLINE  -  Client to server indicating network address is already
+                   in use.
+
+   DHCPRELEASE  -  Client to server relinquishing network address and
+                   cancelling remaining lease.
+
+   DHCPINFORM   -  Client to server, asking only for local configuration
+                   parameters; client already has externally configured
+                   network address.
+
+                          Table 2:  DHCP messages
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 14]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+                Server          Client          Server
+            (not selected)                    (selected)
+
+                  v               v               v
+                  |               |               |
+                  |     Begins initialization     |
+                  |               |               |
+                  | _____________/|\____________  |
+                  |/DHCPDISCOVER | DHCPDISCOVER  \|
+                  |               |               |
+              Determines          |          Determines
+             configuration        |         configuration
+                  |               |               |
+                  |\             |  ____________/ |
+                  | \________    | /DHCPOFFER     |
+                  | DHCPOFFER\   |/               |
+                  |           \  |                |
+                  |       Collects replies        |
+                  |             \|                |
+                  |     Selects configuration     |
+                  |               |               |
+                  | _____________/|\____________  |
+                  |/ DHCPREQUEST  |  DHCPREQUEST\ |
+                  |               |               |
+                  |               |     Commits configuration
+                  |               |               |
+                  |               | _____________/|
+                  |               |/ DHCPACK      |
+                  |               |               |
+                  |    Initialization complete    |
+                  |               |               |
+                  .               .               .
+                  .               .               .
+                  |               |               |
+                  |      Graceful shutdown        |
+                  |               |               |
+                  |               |\ ____________ |
+                  |               | DHCPRELEASE  \|
+                  |               |               |
+                  |               |        Discards lease
+                  |               |               |
+                  v               v               v
+     Figure 3: Timeline diagram of messages exchanged between DHCP
+               client and servers when allocating a new network address
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 15]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+  3. The client receives one or more DHCPOFFER messages from one or more
+     servers.  The client may choose to wait for multiple responses.
+     The client chooses one server from which to request configuration
+     parameters, based on the configuration parameters offered in the
+     DHCPOFFER messages.  The client broadcasts a DHCPREQUEST message
+     that MUST include the 'server identifier' option to indicate which
+     server it has selected, and that MAY include other options
+     specifying desired configuration values.  The 'requested IP
+     address' option MUST be set to the value of 'yiaddr' in the
+     DHCPOFFER message from the server.  This DHCPREQUEST message is
+     broadcast and relayed through DHCP/BOOTP relay agents.  To help
+     ensure that any BOOTP relay agents forward the DHCPREQUEST message
+     to the same set of DHCP servers that received the original
+     DHCPDISCOVER message, the DHCPREQUEST message MUST use the same
+     value in the DHCP message header's 'secs' field and be sent to the
+     same IP broadcast address as the original DHCPDISCOVER message.
+     The client times out and retransmits the DHCPDISCOVER message if
+     the client receives no DHCPOFFER messages.
+
+  4. The servers receive the DHCPREQUEST broadcast from the client.
+     Those servers not selected by the DHCPREQUEST message use the
+     message as notification that the client has declined that server's
+     offer.  The server selected in the DHCPREQUEST message commits the
+     binding for the client to persistent storage and responds with a
+     DHCPACK message containing the configuration parameters for the
+     requesting client.  The combination of 'client identifier' or
+     'chaddr' and assigned network address constitute a unique
+     identifier for the client's lease and are used by both the client
+     and server to identify a lease referred to in any DHCP messages.
+     Any configuration parameters in the DHCPACK message SHOULD NOT
+     conflict with those in the earlier DHCPOFFER message to which the
+     client is responding.  The server SHOULD NOT check the offered
+     network address at this point. The 'yiaddr' field in the DHCPACK
+     messages is filled in with the selected network address.
+
+     If the selected server is unable to satisfy the DHCPREQUEST message
+     (e.g., the requested network address has been allocated), the
+     server SHOULD respond with a DHCPNAK message.
+
+     A server MAY choose to mark addresses offered to clients in
+     DHCPOFFER messages as unavailable.  The server SHOULD mark an
+     address offered to a client in a DHCPOFFER message as available if
+     the server receives no DHCPREQUEST message from that client.
+
+  5. The client receives the DHCPACK message with configuration
+     parameters.  The client SHOULD perform a final check on the
+     parameters (e.g., ARP for allocated network address), and notes the
+     duration of the lease specified in the DHCPACK message.  At this
+
+
+
+Droms                       Standards Track                    [Page 16]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+     point, the client is configured.  If the client detects that the
+     address is already in use (e.g., through the use of ARP), the
+     client MUST send a DHCPDECLINE message to the server and restarts
+     the configuration process.  The client SHOULD wait a minimum of ten
+     seconds before restarting the configuration process to avoid
+     excessive network traffic in case of looping.
+
+     If the client receives a DHCPNAK message, the client restarts the
+     configuration process.
+
+     The client times out and retransmits the DHCPREQUEST message if the
+     client receives neither a DHCPACK or a DHCPNAK message.  The client
+     retransmits the DHCPREQUEST according to the retransmission
+     algorithm in section 4.1.  The client should choose to retransmit
+     the DHCPREQUEST enough times to give adequate probability of
+     contacting the server without causing the client (and the user of
+     that client) to wait overly long before giving up; e.g., a client
+     retransmitting as described in section 4.1 might retransmit the
+     DHCPREQUEST message four times, for a total delay of 60 seconds,
+     before restarting the initialization procedure.  If the client
+     receives neither a DHCPACK or a DHCPNAK message after employing the
+     retransmission algorithm, the client reverts to INIT state and
+     restarts the initialization process.  The client SHOULD notify the
+     user that the initialization process has failed and is restarting.
+
+  6. The client may choose to relinquish its lease on a network address
+     by sending a DHCPRELEASE message to the server.  The client
+     identifies the lease to be released with its 'client identifier',
+     or 'chaddr' and network address in the DHCPRELEASE message. If the
+     client used a 'client identifier' when it obtained the lease, it
+     MUST use the same 'client identifier' in the DHCPRELEASE message.
+
+3.2 Client-server interaction - reusing a previously allocated network
+    address
+
+   If a client remembers and wishes to reuse a previously allocated
+   network address, a client may choose to omit some of the steps
+   described in the previous section.  The timeline diagram in figure 4
+   shows the timing relationships in a typical client-server interaction
+   for a client reusing a previously allocated network address.
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 17]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   1. The client broadcasts a DHCPREQUEST message on its local subnet.
+      The message includes the client's network address in the
+      'requested IP address' option. As the client has not received its
+      network address, it MUST NOT fill in the 'ciaddr' field. BOOTP
+      relay agents pass the message on to DHCP servers not on the same
+      subnet.  If the client used a 'client identifier' to obtain its
+      address, the client MUST use the same 'client identifier' in the
+      DHCPREQUEST message.
+
+   2. Servers with knowledge of the client's configuration parameters
+      respond with a DHCPACK message to the client.  Servers SHOULD NOT
+      check that the client's network address is already in use; the
+      client may respond to ICMP Echo Request messages at this point.
+
+                Server          Client          Server
+
+                  v               v               v
+                  |                |               |
+                  |              Begins            |
+                  |          initialization        |
+                  |                |               |
+                  |                /|\             |
+                  |   _________ __/ | \__________  |
+                  | /DHCPREQU EST  |  DHCPREQUEST\ |
+                  |/               |              \|
+                  |                |               |
+               Locates             |            Locates
+            configuration          |         configuration
+                  |                |               |
+                  |\               |              /|
+                  | \              |  ___________/ |
+                  |  \             | /  DHCPACK    |
+                  |   \ _______    |/              |
+                  |     DHCPACK\   |               |
+                  |          Initialization        |
+                  |             complete           |
+                  |               \|               |
+                  |                |               |
+                  |           (Subsequent          |
+                  |             DHCPACKS           |
+                  |             ignored)           |
+                  |                |               |
+                  |                |               |
+                  v                v               v
+
+     Figure 4: Timeline diagram of messages exchanged between DHCP
+               client and servers when reusing a previously allocated
+               network address
+
+
+
+Droms                       Standards Track                    [Page 18]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      If the client's request is invalid (e.g., the client has moved
+      to a new subnet), servers SHOULD respond with a DHCPNAK message to
+      the client. Servers SHOULD NOT respond if their information is not
+      guaranteed to be accurate.  For example, a server that identifies a
+      request for an expired binding that is owned by another server SHOULD
+      NOT respond with a DHCPNAK unless the servers are using an explicit
+      mechanism to maintain coherency among the servers.
+
+      If 'giaddr' is 0x0 in the DHCPREQUEST message, the client is on
+      the same subnet as the server.  The server MUST
+      broadcast the DHCPNAK message to the 0xffffffff broadcast address
+      because the client may not have a correct network address or subnet
+      mask, and the client may not be answering ARP requests.
+      Otherwise, the server MUST send the DHCPNAK message to the IP
+      address of the BOOTP relay agent, as recorded in 'giaddr'.  The
+      relay agent will, in turn, forward the message directly to the
+      client's hardware address, so that the DHCPNAK can be delivered even
+      if the client has moved to a new network.
+
+   3. The client receives the DHCPACK message with configuration
+      parameters.  The client performs a final check on the parameters
+      (as in section 3.1), and notes the duration of the lease specified
+      in the DHCPACK message.  The specific lease is implicitly identified
+      by the 'client identifier' or 'chaddr' and the network address.  At
+      this point, the client is configured.
+
+      If the client detects that the IP address in the DHCPACK message
+      is already in use, the client MUST send a DHCPDECLINE message to the
+      server and restarts the configuration process by requesting a
+      new network address.  This action corresponds to the client
+      moving to the INIT state in the DHCP state diagram, which is
+      described in section 4.4.
+
+      If the client receives a DHCPNAK message, it cannot reuse its
+      remembered network address.  It must instead request a new
+      address by restarting the configuration process, this time
+      using the (non-abbreviated) procedure described in section
+      3.1.  This action also corresponds to the client moving to
+      the INIT state in the DHCP state diagram.
+
+      The client times out and retransmits the DHCPREQUEST message if
+      the client receives neither a DHCPACK nor a DHCPNAK message.  The
+      client retransmits the DHCPREQUEST according to the retransmission
+      algorithm in section 4.1.  The client should choose to retransmit
+      the DHCPREQUEST enough times to give adequate probability of
+      contacting the server without causing the client (and the user of
+      that client) to wait overly long before giving up; e.g., a client
+      retransmitting as described in section 4.1 might retransmit the
+
+
+
+Droms                       Standards Track                    [Page 19]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      DHCPREQUEST message four times, for a total delay of 60 seconds,
+      before restarting the initialization procedure.  If the client
+      receives neither a DHCPACK or a DHCPNAK message after employing
+      the retransmission algorithm, the client MAY choose to use the
+      previously allocated network address and configuration parameters
+      for the remainder of the unexpired lease.  This corresponds to
+      moving to BOUND state in the client state transition diagram shown
+      in figure 5.
+
+   4. The client may choose to relinquish its lease on a network
+      address by sending a DHCPRELEASE message to the server.  The
+      client identifies the lease to be released with its
+      'client identifier', or 'chaddr' and network address in the
+      DHCPRELEASE message.
+
+      Note that in this case, where the client retains its network
+      address locally, the client will not normally relinquish its
+      lease during a graceful shutdown.  Only in the case where the
+      client explicitly needs to relinquish its lease, e.g., the client
+      is about to be moved to a different subnet, will the client send
+      a DHCPRELEASE message.
+
+3.3 Interpretation and representation of time values
+
+   A client acquires a lease for a network address for a fixed period of
+   time (which may be infinite).  Throughout the protocol, times are to
+   be represented in units of seconds.  The time value of 0xffffffff is
+   reserved to represent "infinity".
+
+   As clients and servers may not have synchronized clocks, times are
+   represented in DHCP messages as relative times, to be interpreted
+   with respect to the client's local clock.  Representing relative
+   times in units of seconds in an unsigned 32 bit word gives a range of
+   relative times from 0 to approximately 100 years, which is sufficient
+   for the relative times to be measured using DHCP.
+
+   The algorithm for lease duration interpretation given in the previous
+   paragraph assumes that client and server clocks are stable relative
+   to each other.  If there is drift between the two clocks, the server
+   may consider the lease expired before the client does.  To
+   compensate, the server may return a shorter lease duration to the
+   client than the server commits to its local database of client
+   information.
+
+3.4 Obtaining parameters with externally configured network address
+
+   If a client has obtained a network address through some other means
+   (e.g., manual configuration), it may use a DHCPINFORM request message
+
+
+
+Droms                       Standards Track                    [Page 20]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   to obtain other local configuration parameters.  Servers receiving a
+   DHCPINFORM message construct a DHCPACK message with any local
+   configuration parameters appropriate for the client without:
+   allocating a new address, checking for an existing binding, filling
+   in 'yiaddr' or including lease time parameters.  The servers SHOULD
+   unicast the DHCPACK reply to the address given in the 'ciaddr' field
+   of the DHCPINFORM message.
+
+   The server SHOULD check the network address in a DHCPINFORM message
+   for consistency, but MUST NOT check for an existing lease.  The
+   server forms a DHCPACK message containing the configuration
+   parameters for the requesting client and sends the DHCPACK message
+   directly to the client.
+
+3.5 Client parameters in DHCP
+
+   Not all clients require initialization of all parameters listed in
+   Appendix A.  Two techniques are used to reduce the number of
+   parameters transmitted from the server to the client.  First, most of
+   the parameters have defaults defined in the Host Requirements RFCs;
+   if the client receives no parameters from the server that override
+   the defaults, a client uses those default values.  Second, in its
+   initial DHCPDISCOVER or DHCPREQUEST message, a client may provide the
+   server with a list of specific parameters the client is interested
+   in.  If the client includes a list of parameters in a DHCPDISCOVER
+   message, it MUST include that list in any subsequent DHCPREQUEST
+   messages.
+
+   The client SHOULD include the 'maximum DHCP message size' option to
+   let the server know how large the server may make its DHCP messages.
+   The parameters returned to a client may still exceed the space
+   allocated to options in a DHCP message.  In this case, two additional
+   options flags (which must appear in the 'options' field of the
+   message) indicate that the 'file' and 'sname' fields are to be used
+   for options.
+
+   The client can inform the server which configuration parameters the
+   client is interested in by including the 'parameter request list'
+   option.  The data portion of this option explicitly lists the options
+   requested by tag number.
+
+   In addition, the client may suggest values for the network address
+   and lease time in the DHCPDISCOVER message.  The client may include
+   the 'requested IP address' option to suggest that a particular IP
+   address be assigned, and may include the 'IP address lease time'
+   option to suggest the lease time it would like.  Other options
+   representing "hints" at configuration parameters are allowed in a
+   DHCPDISCOVER or DHCPREQUEST message.  However, additional options may
+
+
+
+Droms                       Standards Track                    [Page 21]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   be ignored by servers, and multiple servers may, therefore, not
+   return identical values for some options.  The 'requested IP address'
+   option is to be filled in only in a DHCPREQUEST message when the
+   client is verifying network parameters obtained previously. The
+   client fills in the 'ciaddr' field only when correctly configured
+   with an IP address in BOUND, RENEWING or REBINDING state.
+
+   If a server receives a DHCPREQUEST message with an invalid 'requested
+   IP address', the server SHOULD respond to the client with a DHCPNAK
+   message and may choose to report the problem to the system
+   administrator.  The server may include an error message in the
+   'message' option.
+
+3.6 Use of DHCP in clients with multiple interfaces
+
+   A client with multiple network interfaces must use DHCP through each
+   interface independently to obtain configuration information
+   parameters for those separate interfaces.
+
+3.7 When clients should use DHCP
+
+   A client SHOULD use DHCP to reacquire or verify its IP address and
+   network parameters whenever the local network parameters may have
+   changed; e.g., at system boot time or after a disconnection from the
+   local network, as the local network configuration may change without
+   the client's or user's knowledge.
+
+   If a client has knowledge of a previous network address and is unable
+   to contact a local DHCP server, the client may continue to use the
+   previous network address until the lease for that address expires.
+   If the lease expires before the client can contact a DHCP server, the
+   client must immediately discontinue use of the previous network
+   address and may inform local users of the problem.
+
+4. Specification of the DHCP client-server protocol
+
+   In this section, we assume that a DHCP server has a block of network
+   addresses from which it can satisfy requests for new addresses.  Each
+   server also maintains a database of allocated addresses and leases in
+   local permanent storage.
+
+4.1 Constructing and sending DHCP messages
+
+   DHCP clients and servers both construct DHCP messages by filling in
+   fields in the fixed format section of the message and appending
+   tagged data items in the variable length option area.  The options
+   area includes first a four-octet 'magic cookie' (which was described
+   in section 3), followed by the options.  The last option must always
+
+
+
+Droms                       Standards Track                    [Page 22]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   be the 'end' option.
+
+   DHCP uses UDP as its transport protocol.  DHCP messages from a client
+   to a server are sent to the 'DHCP server' port (67), and DHCP
+   messages from a server to a client are sent to the 'DHCP client' port
+   (68). A server with multiple network address (e.g., a multi-homed
+   host) MAY use any of its network addresses in outgoing DHCP messages.
+
+   The 'server identifier' field is used both to identify a DHCP server
+   in a DHCP message and as a destination address from clients to
+   servers.  A server with multiple network addresses MUST be prepared
+   to to accept any of its network addresses as identifying that server
+   in a DHCP message.  To accommodate potentially incomplete network
+   connectivity, a server MUST choose an address as a 'server
+   identifier' that, to the best of the server's knowledge, is reachable
+   from the client.  For example, if the DHCP server and the DHCP client
+   are connected to the same subnet (i.e., the 'giaddr' field in the
+   message from the client is zero), the server SHOULD select the IP
+   address the server is using for communication on that subnet as the
+   'server identifier'.  If the server is using multiple IP addresses on
+   that subnet, any such address may be used.  If the server has
+   received a message through a DHCP relay agent, the server SHOULD
+   choose an address from the interface on which the message was
+   recieved as the 'server identifier' (unless the server has other,
+   better information on which to make its choice).  DHCP clients MUST
+   use the IP address provided in the 'server identifier' option for any
+   unicast requests to the DHCP server.
+
+   DHCP messages broadcast by a client prior to that client obtaining
+   its IP address must have the source address field in the IP header
+   set to 0.
+
+   If the 'giaddr' field in a DHCP message from a client is non-zero,
+   the server sends any return messages to the 'DHCP server' port on the
+   BOOTP relay agent whose address appears in 'giaddr'. If the 'giaddr'
+   field is zero and the 'ciaddr' field is nonzero, then the server
+   unicasts DHCPOFFER and DHCPACK messages to the address in 'ciaddr'.
+   If 'giaddr' is zero and 'ciaddr' is zero, and the broadcast bit is
+   set, then the server broadcasts DHCPOFFER and DHCPACK messages to
+   0xffffffff. If the broadcast bit is not set and 'giaddr' is zero and
+   'ciaddr' is zero, then the server unicasts DHCPOFFER and DHCPACK
+   messages to the client's hardware address and 'yiaddr' address.  In
+   all cases, when 'giaddr' is zero, the server broadcasts any DHCPNAK
+   messages to 0xffffffff.
+
+   If the options in a DHCP message extend into the 'sname' and 'file'
+   fields, the 'option overload' option MUST appear in the 'options'
+   field, with value 1, 2 or 3, as specified in RFC 1533.  If the
+
+
+
+Droms                       Standards Track                    [Page 23]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   'option overload' option is present in the 'options' field, the
+   options in the 'options' field MUST be terminated by an 'end' option,
+   and MAY contain one or more 'pad' options to fill the options field.
+   The options in the 'sname' and 'file' fields (if in use as indicated
+   by the 'options overload' option) MUST begin with the first octet of
+   the field, MUST be terminated by an 'end' option, and MUST be
+   followed by 'pad' options to fill the remainder of the field.  Any
+   individual option in the 'options', 'sname' and 'file' fields MUST be
+   entirely contained in that field.  The options in the 'options' field
+   MUST be interpreted first, so that any 'option overload' options may
+   be interpreted.  The 'file' field MUST be interpreted next (if the
+   'option overload' option indicates that the 'file' field contains
+   DHCP options), followed by the 'sname' field.
+
+   The values to be passed in an 'option' tag may be too long to fit in
+   the 255 octets available to a single option (e.g., a list of routers
+   in a 'router' option [21]).  Options may appear only once, unless
+   otherwise specified in the options document.  The client concatenates
+   the values of multiple instances of the same option into a single
+   parameter list for configuration.
+
+   DHCP clients are responsible for all message retransmission.  The
+   client MUST adopt a retransmission strategy that incorporates a
+   randomized exponential backoff algorithm to determine the delay
+   between retransmissions.  The delay between retransmissions SHOULD be
+   chosen to allow sufficient time for replies from the server to be
+   delivered based on the characteristics of the internetwork between
+   the client and the server.  For example, in a 10Mb/sec Ethernet
+   internetwork, the delay before the first retransmission SHOULD be 4
+   seconds randomized by the value of a uniform random number chosen
+   from the range -1 to +1.  Clients with clocks that provide resolution
+   granularity of less than one second may choose a non-integer
+   randomization value.  The delay before the next retransmission SHOULD
+   be 8 seconds randomized by the value of a uniform number chosen from
+   the range -1 to +1.  The retransmission delay SHOULD be doubled with
+   subsequent retransmissions up to a maximum of 64 seconds.  The client
+   MAY provide an indication of retransmission attempts to the user as
+   an indication of the progress of the configuration process.
+
+   The 'xid' field is used by the client to match incoming DHCP messages
+   with pending requests.  A DHCP client MUST choose 'xid's in such a
+   way as to minimize the chance of using an 'xid' identical to one used
+   by another client. For example, a client may choose a different,
+   random initial 'xid' each time the client is rebooted, and
+   subsequently use sequential 'xid's until the next reboot.  Selecting
+   a new 'xid' for each retransmission is an implementation decision.  A
+   client may choose to reuse the same 'xid' or select a new 'xid' for
+   each retransmitted message.
+
+
+
+Droms                       Standards Track                    [Page 24]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   Normally, DHCP servers and BOOTP relay agents attempt to deliver
+   DHCPOFFER, DHCPACK and DHCPNAK messages directly to the client using
+   uicast delivery.  The IP destination address (in the IP header) is
+   set to the DHCP 'yiaddr' address and the link-layer destination
+   address is set to the DHCP 'chaddr' address.  Unfortunately, some
+   client implementations are unable to receive such unicast IP
+   datagrams until the implementation has been configured with a valid
+   IP address (leading to a deadlock in which the client's IP address
+   cannot be delivered until the client has been configured with an IP
+   address).
+
+   A client that cannot receive unicast IP datagrams until its protocol
+   software has been configured with an IP address SHOULD set the
+   BROADCAST bit in the 'flags' field to 1 in any DHCPDISCOVER or
+   DHCPREQUEST messages that client sends.  The BROADCAST bit will
+   provide a hint to the DHCP server and BOOTP relay agent to broadcast
+   any messages to the client on the client's subnet.  A client that can
+   receive unicast IP datagrams before its protocol software has been
+   configured SHOULD clear the BROADCAST bit to 0.  The BOOTP
+   clarifications document discusses the ramifications of the use of the
+   BROADCAST bit [21].
+
+   A server or relay agent sending or relaying a DHCP message directly
+   to a DHCP client (i.e., not to a relay agent specified in the
+   'giaddr' field) SHOULD examine the BROADCAST bit in the 'flags'
+   field.  If this bit is set to 1, the DHCP message SHOULD be sent as
+   an IP broadcast using an IP broadcast address (preferably 0xffffffff)
+   as the IP destination address and the link-layer broadcast address as
+   the link-layer destination address.  If the BROADCAST bit is cleared
+   to 0, the message SHOULD be sent as an IP unicast to the IP address
+   specified in the 'yiaddr' field and the link-layer address specified
+   in the 'chaddr' field.  If unicasting is not possible, the message
+   MAY be sent as an IP broadcast using an IP broadcast address
+   (preferably 0xffffffff) as the IP destination address and the link-
+   layer broadcast address as the link-layer destination address.
+
+4.2 DHCP server administrative controls
+
+   DHCP servers are not required to respond to every DHCPDISCOVER and
+   DHCPREQUEST message they receive.  For example, a network
+   administrator, to retain stringent control over the clients attached
+   to the network, may choose to configure DHCP servers to respond only
+   to clients that have been previously registered through some external
+   mechanism.  The DHCP specification describes only the interactions
+   between clients and servers when the clients and servers choose to
+   interact; it is beyond the scope of the DHCP specification to
+   describe all of the administrative controls that system
+   administrators might want to use.  Specific DHCP server
+
+
+
+Droms                       Standards Track                    [Page 25]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   implementations may incorporate any controls or policies desired by a
+   network administrator.
+
+   In some environments, a DHCP server will have to consider the values
+   of the vendor class options included in DHCPDISCOVER or DHCPREQUEST
+   messages when determining the correct parameters for a particular
+   client.
+
+   A DHCP server needs to use some unique identifier to associate a
+   client with its lease.  The client MAY choose to explicitly provide
+   the identifier through the 'client identifier' option.  If the client
+   supplies a 'client identifier', the client MUST use the same 'client
+   identifier' in all subsequent messages, and the server MUST use that
+   identifier to identify the client.  If the client does not provide a
+   'client identifier' option, the server MUST use the contents of the
+   'chaddr' field to identify the client. It is crucial for a DHCP
+   client to use an identifier unique within the subnet to which the
+   client is attached in the 'client identifier' option.  Use of
+   'chaddr' as the client's unique identifier may cause unexpected
+   results, as that identifier may be associated with a hardware
+   interface that could be moved to a new client.  Some sites may choose
+   to use a manufacturer's serial number as the 'client identifier', to
+   avoid unexpected changes in a clients network address due to transfer
+   of hardware interfaces among computers.  Sites may also choose to use
+   a DNS name as the 'client identifier', causing address leases to be
+   associated with the DNS name rather than a specific hardware box.
+
+   DHCP clients are free to use any strategy in selecting a DHCP server
+   among those from which the client receives a DHCPOFFER message.  The
+   client implementation of DHCP SHOULD provide a mechanism for the user
+   to select directly the 'vendor class identifier' values.
+
+4.3 DHCP server behavior
+
+   A DHCP server processes incoming DHCP messages from a client based on
+   the current state of the binding for that client.  A DHCP server can
+   receive the following messages from a client:
+
+      o DHCPDISCOVER
+
+      o DHCPREQUEST
+
+      o DHCPDECLINE
+
+      o DHCPRELEASE
+
+      o DHCPINFORM
+
+
+
+
+Droms                       Standards Track                    [Page 26]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   Table 3 gives the use of the fields and options in a DHCP message by
+   a server.  The remainder of this section describes the action of the
+   DHCP server for each possible incoming message.
+
+4.3.1 DHCPDISCOVER message
+
+   When a server receives a DHCPDISCOVER message from a client, the
+   server chooses a network address for the requesting client.  If no
+   address is available, the server may choose to report the problem to
+   the system administrator. If an address is available, the new address
+   SHOULD be chosen as follows:
+
+      o The client's current address as recorded in the client's current
+        binding, ELSE
+
+      o The client's previous address as recorded in the client's (now
+        expired or released) binding, if that address is in the server's
+        pool of available addresses and not already allocated, ELSE
+
+      o The address requested in the 'Requested IP Address' option, if that
+        address is valid and not already allocated, ELSE
+
+      o A new address allocated from the server's pool of available
+        addresses; the address is selected based on the subnet from which
+        the message was received (if 'giaddr' is 0) or on the address of
+        the relay agent that forwarded the message ('giaddr' when not 0).
+
+   As described in section 4.2, a server MAY, for administrative
+   reasons, assign an address other than the one requested, or may
+   refuse to allocate an address to a particular client even though free
+   addresses are available.
+
+   Note that, in some network architectures (e.g., internets with more
+   than one IP subnet assigned to a physical network segment), it may be
+   the case that the DHCP client should be assigned an address from a
+   different subnet than the address recorded in 'giaddr'.  Thus, DHCP
+   does not require that the client be assigned as address from the
+   subnet in 'giaddr'.  A server is free to choose some other subnet,
+   and it is beyond the scope of the DHCP specification to describe ways
+   in which the assigned IP address might be chosen.
+
+   While not required for correct operation of DHCP, the server SHOULD
+   NOT reuse the selected network address before the client responds to
+   the server's DHCPOFFER message.  The server may choose to record the
+   address as offered to the client.
+
+   The server must also choose an expiration time for the lease, as
+   follows:
+
+
+
+Droms                       Standards Track                    [Page 27]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   o IF the client has not requested a specific lease in the
+     DHCPDISCOVER message and the client already has an assigned network
+     address, the server returns the lease expiration time previously
+     assigned to that address (note that the client must explicitly
+     request a specific lease to extend the expiration time on a
+     previously assigned address), ELSE
+
+   o IF the client has not requested a specific lease in the
+     DHCPDISCOVER message and the client does not have an assigned
+     network address, the server assigns a locally configured default
+     lease time, ELSE
+
+   o IF the client has requested a specific lease in the DHCPDISCOVER
+     message (regardless of whether the client has an assigned network
+     address), the server may choose either to return the requested
+     lease (if the lease is acceptable to local policy) or select
+     another lease.
+
+Field      DHCPOFFER            DHCPACK             DHCPNAK
+-----      ---------            -------             -------
+'op'       BOOTREPLY            BOOTREPLY           BOOTREPLY
+'htype'    (From "Assigned Numbers" RFC)
+'hlen'     (Hardware address length in octets)
+'hops'     0                    0                   0
+'xid'      'xid' from client    'xid' from client   'xid' from client
+           DHCPDISCOVER         DHCPREQUEST         DHCPREQUEST
+           message              message             message
+'secs'     0                    0                   0
+'ciaddr'   0                    'ciaddr' from       0
+                                DHCPREQUEST or 0
+'yiaddr'   IP address offered   IP address          0
+           to client            assigned to client
+'siaddr'   IP address of next   IP address of next  0
+           bootstrap server     bootstrap server
+'flags'    'flags' from         'flags' from        'flags' from
+           client DHCPDISCOVER  client DHCPREQUEST  client DHCPREQUEST
+           message              message             message
+'giaddr'   'giaddr' from        'giaddr' from       'giaddr' from
+           client DHCPDISCOVER  client DHCPREQUEST  client DHCPREQUEST
+           message              message             message
+'chaddr'   'chaddr' from        'chaddr' from       'chaddr' from
+           client DHCPDISCOVER  client DHCPREQUEST  client DHCPREQUEST
+           message              message             message
+'sname'    Server host name     Server host name    (unused)
+           or options           or options
+'file'     Client boot file     Client boot file    (unused)
+           name or options      name or options
+'options'  options              options
+
+
+
+Droms                       Standards Track                    [Page 28]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+Option                    DHCPOFFER    DHCPACK            DHCPNAK
+------                    ---------    -------            -------
+Requested IP address      MUST NOT     MUST NOT           MUST NOT
+IP address lease time     MUST         MUST (DHCPREQUEST) MUST NOT
+                                       MUST NOT (DHCPINFORM)
+Use 'file'/'sname' fields MAY          MAY                MUST NOT
+DHCP message type         DHCPOFFER    DHCPACK            DHCPNAK
+Parameter request list    MUST NOT     MUST NOT           MUST NOT
+Message                   SHOULD       SHOULD             SHOULD
+Client identifier         MUST NOT     MUST NOT           MAY
+Vendor class identifier   MAY          MAY                MAY
+Server identifier         MUST         MUST               MUST
+Maximum message size      MUST NOT     MUST NOT           MUST NOT
+All others                MAY          MAY                MUST NOT
+
+           Table 3:  Fields and options used by DHCP servers
+
+   Once the network address and lease have been determined, the server
+   constructs a DHCPOFFER message with the offered configuration
+   parameters.  It is important for all DHCP servers to return the same
+   parameters (with the possible exception of a newly allocated network
+   address) to ensure predictable client behavior regardless of which
+   server the client selects.  The configuration parameters MUST be
+   selected by applying the following rules in the order given below.
+   The network administrator is responsible for configuring multiple
+   DHCP servers to ensure uniform responses from those servers.  The
+   server MUST return to the client:
+
+   o The client's network address, as determined by the rules given
+     earlier in this section,
+
+   o The expiration time for the client's lease, as determined by the
+     rules given earlier in this section,
+
+   o Parameters requested by the client, according to the following
+     rules:
+
+        -- IF the server has been explicitly configured with a default
+           value for the parameter, the server MUST include that value
+           in an appropriate option in the 'option' field, ELSE
+
+        -- IF the server recognizes the parameter as a parameter
+           defined in the Host Requirements Document, the server MUST
+           include the default value for that parameter as given in the
+           Host Requirements Document in an appropriate option in the
+           'option' field, ELSE
+
+        -- The server MUST NOT return a value for that parameter,
+
+
+
+Droms                       Standards Track                    [Page 29]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+     The server MUST supply as many of the requested parameters as
+     possible and MUST omit any parameters it cannot provide.  The
+     server MUST include each requested parameter only once unless
+     explicitly allowed in the DHCP Options and BOOTP Vendor
+     Extensions document.
+
+   o Any parameters from the existing binding that differ from the Host
+     Requirements Document defaults,
+
+   o Any parameters specific to this client (as identified by
+     the contents of 'chaddr' or 'client identifier' in the DHCPDISCOVER
+     or DHCPREQUEST message), e.g., as configured by the network
+     administrator,
+
+   o Any parameters specific to this client's class (as identified
+     by the contents of the 'vendor class identifier'
+     option in the DHCPDISCOVER or DHCPREQUEST message),
+     e.g., as configured by the network administrator; the parameters
+     MUST be identified by an exact match between the client's vendor
+     class identifiers and the client's classes identified in the
+     server,
+
+   o Parameters with non-default values on the client's subnet.
+
+   The server MAY choose to return the 'vendor class identifier' used to
+   determine the parameters in the DHCPOFFER message to assist the
+   client in selecting which DHCPOFFER to accept.  The server inserts
+   the 'xid' field from the DHCPDISCOVER message into the 'xid' field of
+   the DHCPOFFER message and sends the DHCPOFFER message to the
+   requesting client.
+
+4.3.2 DHCPREQUEST message
+
+   A DHCPREQUEST message may come from a client responding to a
+   DHCPOFFER message from a server, from a client verifying a previously
+   allocated IP address or from a client extending the lease on a
+   network address.  If the DHCPREQUEST message contains a 'server
+   identifier' option, the message is in response to a DHCPOFFER
+   message.  Otherwise, the message is a request to verify or extend an
+   existing lease.  If the client uses a 'client identifier' in a
+   DHCPREQUEST message, it MUST use that same 'client identifier' in all
+   subsequent messages. If the client included a list of requested
+   parameters in a DHCPDISCOVER message, it MUST include that list in
+   all subsequent messages.
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 30]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   Any configuration parameters in the DHCPACK message SHOULD NOT
+   conflict with those in the earlier DHCPOFFER message to which the
+   client is responding.  The client SHOULD use the parameters in the
+   DHCPACK message for configuration.
+
+   Clients send DHCPREQUEST messages as follows:
+
+   o DHCPREQUEST generated during SELECTING state:
+
+      Client inserts the address of the selected server in 'server
+      identifier', 'ciaddr' MUST be zero, 'requested IP address' MUST be
+      filled in with the yiaddr value from the chosen DHCPOFFER.
+
+      Note that the client may choose to collect several DHCPOFFER
+      messages and select the "best" offer.  The client indicates its
+      selection by identifying the offering server in the DHCPREQUEST
+      message.  If the client receives no acceptable offers, the client
+      may choose to try another DHCPDISCOVER message.  Therefore, the
+      servers may not receive a specific DHCPREQUEST from which they can
+      decide whether or not the client has accepted the offer.  Because
+      the servers have not committed any network address assignments on
+      the basis of a DHCPOFFER, servers are free to reuse offered
+      network addresses in response to subsequent requests.  As an
+      implementation detail, servers SHOULD NOT reuse offered addresses
+      and may use an implementation-specific timeout mechanism to decide
+      when to reuse an offered address.
+
+   o DHCPREQUEST generated during INIT-REBOOT state:
+
+      'server identifier' MUST NOT be filled in, 'requested IP address'
+      option MUST be filled in with client's notion of its previously
+      assigned address. 'ciaddr' MUST be zero. The client is seeking to
+      verify a previously allocated, cached configuration. Server SHOULD
+      send a DHCPNAK message to the client if the 'requested IP address'
+      is incorrect, or is on the wrong network.
+
+      Determining whether a client in the INIT-REBOOT state is on the
+      correct network is done by examining the contents of 'giaddr', the
+      'requested IP address' option, and a database lookup. If the DHCP
+      server detects that the client is on the wrong net (i.e., the
+      result of applying the local subnet mask or remote subnet mask (if
+      'giaddr' is not zero) to 'requested IP address' option value
+      doesn't match reality), then the server SHOULD send a DHCPNAK
+      message to the client.
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 31]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      If the network is correct, then the DHCP server should check if
+      the client's notion of its IP address is correct. If not, then the
+      server SHOULD send a DHCPNAK message to the client. If the DHCP
+      server has no record of this client, then it MUST remain silent,
+      and MAY output a warning to the network administrator. This
+      behavior is necessary for peaceful coexistence of non-
+      communicating DHCP servers on the same wire.
+
+      If 'giaddr' is 0x0 in the DHCPREQUEST message, the client is on
+      the same subnet as the server.  The server MUST broadcast the
+      DHCPNAK message to the 0xffffffff broadcast address because the
+      client may not have a correct network address or subnet mask, and
+      the client may not be answering ARP requests.
+
+      If 'giaddr' is set in the DHCPREQUEST message, the client is on a
+      different subnet.  The server MUST set the broadcast bit in the
+      DHCPNAK, so that the relay agent will broadcast the DHCPNAK to the
+      client, because the client may not have a correct network address
+      or subnet mask, and the client may not be answering ARP requests.
+
+   o DHCPREQUEST generated during RENEWING state:
+
+      'server identifier' MUST NOT be filled in, 'requested IP address'
+      option MUST NOT be filled in, 'ciaddr' MUST be filled in with
+      client's IP address. In this situation, the client is completely
+      configured, and is trying to extend its lease. This message will
+      be unicast, so no relay agents will be involved in its
+      transmission.  Because 'giaddr' is therefore not filled in, the
+      DHCP server will trust the value in 'ciaddr', and use it when
+      replying to the client.
+
+      A client MAY choose to renew or extend its lease prior to T1.  The
+      server may choose not to extend the lease (as a policy decision by
+      the network administrator), but should return a DHCPACK message
+      regardless.
+
+   o DHCPREQUEST generated during REBINDING state:
+
+      'server identifier' MUST NOT be filled in, 'requested IP address'
+      option MUST NOT be filled in, 'ciaddr' MUST be filled in with
+      client's IP address. In this situation, the client is completely
+      configured, and is trying to extend its lease. This message MUST
+      be broadcast to the 0xffffffff IP broadcast address.  The DHCP
+      server SHOULD check 'ciaddr' for correctness before replying to
+      the DHCPREQUEST.
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 32]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+      The DHCPREQUEST from a REBINDING client is intended to accommodate
+      sites that have multiple DHCP servers and a mechanism for
+      maintaining consistency among leases managed by multiple servers.
+      A DHCP server MAY extend a client's lease only if it has local
+      administrative authority to do so.
+
+4.3.3 DHCPDECLINE message
+
+   If the server receives a DHCPDECLINE message, the client has
+   discovered through some other means that the suggested network
+   address is already in use.  The server MUST mark the network address
+   as not available and SHOULD notify the local system administrator of
+   a possible configuration problem.
+
+4.3.4 DHCPRELEASE message
+
+   Upon receipt of a DHCPRELEASE message, the server marks the network
+   address as not allocated.  The server SHOULD retain a record of the
+   client's initialization parameters for possible reuse in response to
+   subsequent requests from the client.
+
+4.3.5 DHCPINFORM message
+
+   The server responds to a DHCPINFORM message by sending a DHCPACK
+   message directly to the address given in the 'ciaddr' field of the
+   DHCPINFORM message.  The server MUST NOT send a lease expiration time
+   to the client and SHOULD NOT fill in 'yiaddr'.  The server includes
+   other parameters in the DHCPACK message as defined in section 4.3.1.
+
+4.3.6 Client messages
+
+   Table 4 details the differences between messages from clients in
+   various states.
+
+   ---------------------------------------------------------------------
+   |              |INIT-REBOOT  |SELECTING    |RENEWING     |REBINDING |
+   ---------------------------------------------------------------------
+   |broad/unicast |broadcast    |broadcast    |unicast      |broadcast |
+   |server-ip     |MUST NOT     |MUST         |MUST NOT     |MUST NOT  |
+   |requested-ip  |MUST         |MUST         |MUST NOT     |MUST NOT  |
+   |ciaddr        |zero         |zero         |IP address   |IP address|
+   ---------------------------------------------------------------------
+
+              Table 4: Client messages from different states
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 33]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+4.4 DHCP client behavior
+
+   Figure 5 gives a state-transition diagram for a DHCP client.  A
+   client can receive the following messages from a server:
+
+         o DHCPOFFER
+
+         o DHCPACK
+
+         o DHCPNAK
+
+   The DHCPINFORM message is not shown in figure 5.  A client simply
+   sends the DHCPINFORM and waits for DHCPACK messages.  Once the client
+   has selected its parameters, it has completed the configuration
+   process.
+
+   Table 5 gives the use of the fields and options in a DHCP message by
+   a client.  The remainder of this section describes the action of the
+   DHCP client for each possible incoming message.  The description in
+   the following section corresponds to the full configuration procedure
+   previously described in section 3.1, and the text in the subsequent
+   section corresponds to the abbreviated configuration procedure
+   described in section 3.2.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 34]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+ --------                               -------
+|        | +-------------------------->|       |<-------------------+
+| INIT-  | |     +-------------------->| INIT  |                    |
+| REBOOT |DHCPNAK/         +---------->|       |<---+               |
+|        |Restart|         |            -------     |               |
+ --------  |  DHCPNAK/     |               |                        |
+    |      Discard offer   |      -/Send DHCPDISCOVER               |
+-/Send DHCPREQUEST         |               |                        |
+    |      |     |      DHCPACK            v        |               |
+ -----------     |   (not accept.)/   -----------   |               |
+|           |    |  Send DHCPDECLINE |           |                  |
+| REBOOTING |    |         |         | SELECTING |<----+            |
+|           |    |        /          |           |     |DHCPOFFER/  |
+ -----------     |       /            -----------   |  |Collect     |
+    |            |      /                  |   |       |  replies   |
+DHCPACK/         |     /  +----------------+   +-------+            |
+Record lease, set|    |   v   Select offer/                         |
+timers T1, T2   ------------  send DHCPREQUEST      |               |
+    |   +----->|            |             DHCPNAK, Lease expired/   |
+    |   |      | REQUESTING |                  Halt network         |
+    DHCPOFFER/ |            |                       |               |
+    Discard     ------------                        |               |
+    |   |        |        |                   -----------           |
+    |   +--------+     DHCPACK/              |           |          |
+    |              Record lease, set    -----| REBINDING |          |
+    |                timers T1, T2     /     |           |          |
+    |                     |        DHCPACK/   -----------           |
+    |                     v     Record lease, set   ^               |
+    +----------------> -------      /timers T1,T2   |               |
+               +----->|       |<---+                |               |
+               |      | BOUND |<---+                |               |
+  DHCPOFFER, DHCPACK, |       |    |            T2 expires/   DHCPNAK/
+   DHCPNAK/Discard     -------     |             Broadcast  Halt network
+               |       | |         |            DHCPREQUEST         |
+               +-------+ |        DHCPACK/          |               |
+                    T1 expires/   Record lease, set |               |
+                 Send DHCPREQUEST timers T1, T2     |               |
+                 to leasing server |                |               |
+                         |   ----------             |               |
+                         |  |          |------------+               |
+                         +->| RENEWING |                            |
+                            |          |----------------------------+
+                             ----------
+          Figure 5:  State-transition diagram for DHCP clients
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 35]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+4.4.1 Initialization and allocation of network address
+
+   The client begins in INIT state and forms a DHCPDISCOVER message.
+   The client SHOULD wait a random time between one and ten seconds to
+   desynchronize the use of DHCP at startup.  The client sets 'ciaddr'
+   to 0x00000000.  The client MAY request specific parameters by
+   including the 'parameter request list' option.  The client MAY
+   suggest a network address and/or lease time by including the
+   'requested IP address' and 'IP address lease time' options.  The
+   client MUST include its hardware address in the 'chaddr' field, if
+   necessary for delivery of DHCP reply messages.  The client MAY
+   include a different unique identifier in the 'client identifier'
+   option, as discussed in section 4.2.  If the client included a list
+   of requested parameters in a DHCPDISCOVER message, it MUST include
+   that list in all subsequent messages.
+
+   The client generates and records a random transaction identifier and
+   inserts that identifier into the 'xid' field.  The client records its
+   own local time for later use in computing the lease expiration.  The
+   client then broadcasts the DHCPDISCOVER on the local hardware
+   broadcast address to the 0xffffffff IP broadcast address and 'DHCP
+   server' UDP port.
+
+   If the 'xid' of an arriving DHCPOFFER message does not match the
+   'xid' of the most recent DHCPDISCOVER message, the DHCPOFFER message
+   must be silently discarded.  Any arriving DHCPACK messages must be
+   silently discarded.
+
+   The client collects DHCPOFFER messages over a period of time, selects
+   one DHCPOFFER message from the (possibly many) incoming DHCPOFFER
+   messages (e.g., the first DHCPOFFER message or the DHCPOFFER message
+   from the previously used server) and extracts the server address from
+   the 'server identifier' option in the DHCPOFFER message.  The time
+   over which the client collects messages and the mechanism used to
+   select one DHCPOFFER are implementation dependent.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 36]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+Field      DHCPDISCOVER          DHCPREQUEST           DHCPDECLINE,
+           DHCPINFORM                                  DHCPRELEASE
+-----      ------------          -----------           -----------
+'op'       BOOTREQUEST           BOOTREQUEST           BOOTREQUEST
+'htype'    (From "Assigned Numbers" RFC)
+'hlen'     (Hardware address length in octets)
+'hops'     0                     0                     0
+'xid'      selected by client    'xid' from server     selected by
+                                 DHCPOFFER message     client
+'secs'     0 or seconds since    0 or seconds since    0
+           DHCP process started  DHCP process started
+'flags'    Set 'BROADCAST'       Set 'BROADCAST'       0
+           flag if client        flag if client
+           requires broadcast    requires broadcast
+           reply                 reply
+'ciaddr'   0 (DHCPDISCOVER)      0 or client's         0 (DHCPDECLINE)
+           client's              network address       client's network
+           network address       (BOUND/RENEW/REBIND)  address
+           (DHCPINFORM)                                (DHCPRELEASE)
+'yiaddr'   0                     0                     0
+'siaddr'   0                     0                     0
+'giaddr'   0                     0                     0
+'chaddr'   client's hardware     client's hardware     client's hardware
+           address               address               address
+'sname'    options, if           options, if           (unused)
+           indicated in          indicated in
+           'sname/file'          'sname/file'
+           option; otherwise     option; otherwise
+           unused                unused
+'file'     options, if           options, if           (unused)
+           indicated in          indicated in
+           'sname/file'          'sname/file'
+           option; otherwise     option; otherwise
+           unused                unused
+'options'  options               options               (unused)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 37]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+Option                     DHCPDISCOVER  DHCPREQUEST      DHCPDECLINE,
+                           DHCPINFORM                     DHCPRELEASE
+------                     ------------  -----------      -----------
+Requested IP address       MAY           MUST (in         MUST
+                           (DISCOVER)    SELECTING or     (DHCPDECLINE),
+                           MUST NOT      INIT-REBOOT)     MUST NOT
+                           (INFORM)      MUST NOT (in     (DHCPRELEASE)
+                                         BOUND or
+                                         RENEWING)
+IP address lease time      MAY           MAY              MUST NOT
+                           (DISCOVER)
+                           MUST NOT
+                           (INFORM)
+Use 'file'/'sname' fields  MAY           MAY              MAY
+DHCP message type          DHCPDISCOVER/ DHCPREQUEST      DHCPDECLINE/
+                           DHCPINFORM                     DHCPRELEASE
+Client identifier          MAY           MAY              MAY
+Vendor class identifier    MAY           MAY              MUST NOT
+Server identifier          MUST NOT      MUST (after      MUST
+                                         SELECTING)
+                                         MUST NOT (after
+                                         INIT-REBOOT,
+                                         BOUND, RENEWING
+                                         or REBINDING)
+Parameter request list     MAY           MAY              MUST NOT
+Maximum message size       MAY           MAY              MUST NOT
+Message                    SHOULD NOT    SHOULD NOT       SHOULD
+Site-specific              MAY           MAY              MUST NOT
+All others                 MAY           MAY              MUST NOT
+
+             Table 5:  Fields and options used by DHCP clients
+
+   If the parameters are acceptable, the client records the address of
+   the server that supplied the parameters from the 'server identifier'
+   field and sends that address in the 'server identifier' field of a
+   DHCPREQUEST broadcast message.  Once the DHCPACK message from the
+   server arrives, the client is initialized and moves to BOUND state.
+   The DHCPREQUEST message contains the same 'xid' as the DHCPOFFER
+   message.  The client records the lease expiration time as the sum of
+   the time at which the original request was sent and the duration of
+   the lease from the DHCPACK message.    The client SHOULD perform a
+   check on the suggested address to ensure that the address is not
+   already in use.  For example, if the client is on a network that
+   supports ARP, the client may issue an ARP request for the suggested
+   request.  When broadcasting an ARP request for the suggested address,
+   the client must fill in its own hardware address as the sender's
+   hardware address, and 0 as the sender's IP address, to avoid
+   confusing ARP caches in other hosts on the same subnet.  If the
+
+
+
+Droms                       Standards Track                    [Page 38]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   network address appears to be in use, the client MUST send a
+   DHCPDECLINE message to the server. The client SHOULD broadcast an ARP
+   reply to announce the client's new IP address and clear any outdated
+   ARP cache entries in hosts on the client's subnet.
+
+4.4.2 Initialization with known network address
+
+   The client begins in INIT-REBOOT state and sends a DHCPREQUEST
+   message.  The client MUST insert its known network address as a
+   'requested IP address' option in the DHCPREQUEST message.  The client
+   may request specific configuration parameters by including the
+   'parameter request list' option.  The client generates and records a
+   random transaction identifier and inserts that identifier into the
+   'xid' field.  The client records its own local time for later use in
+   computing the lease expiration.  The client MUST NOT include a
+   'server identifier' in the DHCPREQUEST message.  The client then
+   broadcasts the DHCPREQUEST on the local hardware broadcast address to
+   the 'DHCP server' UDP port.
+
+   Once a DHCPACK message with an 'xid' field matching that in the
+   client's DHCPREQUEST message arrives from any server, the client is
+   initialized and moves to BOUND state.  The client records the lease
+   expiration time as the sum of the time at which the DHCPREQUEST
+   message was sent and the duration of the lease from the DHCPACK
+   message.
+
+4.4.3 Initialization with an externally assigned network address
+
+   The client sends a DHCPINFORM message. The client may request
+   specific configuration parameters by including the 'parameter request
+   list' option. The client generates and records a random transaction
+   identifier and inserts that identifier into the 'xid' field. The
+   client places its own network address in the 'ciaddr' field. The
+   client SHOULD NOT request lease time parameters.
+
+   The client then unicasts the DHCPINFORM to the DHCP server if it
+   knows the server's address, otherwise it broadcasts the message to
+   the limited (all 1s) broadcast address.  DHCPINFORM messages MUST be
+   directed to the 'DHCP server' UDP port.
+
+   Once a DHCPACK message with an 'xid' field matching that in the
+   client's DHCPINFORM message arrives from any server, the client is
+   initialized.
+
+   If the client does not receive a DHCPACK within a reasonable period
+   of time (60 seconds or 4 tries if using timeout suggested in section
+   4.1), then it SHOULD display a message informing the user of the
+   problem, and then SHOULD begin network processing using suitable
+
+
+
+Droms                       Standards Track                    [Page 39]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   defaults as per Appendix A.
+
+4.4.4 Use of broadcast and unicast
+
+   The DHCP client broadcasts DHCPDISCOVER, DHCPREQUEST and DHCPINFORM
+   messages, unless the client knows the address of a DHCP server.  The
+   client unicasts DHCPRELEASE messages to the server.  Because the
+   client is declining the use of the IP address supplied by the server,
+   the client broadcasts DHCPDECLINE messages.
+
+   When the DHCP client knows the address of a DHCP server, in either
+   INIT or REBOOTING state, the client may use that address in the
+   DHCPDISCOVER or DHCPREQUEST rather than the IP broadcast address.
+   The client may also use unicast to send DHCPINFORM messages to a
+   known DHCP server.  If the client receives no response to DHCP
+   messages sent to the IP address of a known DHCP server, the DHCP
+   client reverts to using the IP broadcast address.
+
+4.4.5 Reacquisition and expiration
+
+   The client maintains two times, T1 and T2, that specify the times at
+   which the client tries to extend its lease on its network address.
+   T1 is the time at which the client enters the RENEWING state and
+   attempts to contact the server that originally issued the client's
+   network address.  T2 is the time at which the client enters the
+   REBINDING state and attempts to contact any server. T1 MUST be
+   earlier than T2, which, in turn, MUST be earlier than the time at
+   which the client's lease will expire.
+
+   To avoid the need for synchronized clocks, T1 and T2 are expressed in
+   options as relative times [2].
+
+   At time T1 the client moves to RENEWING state and sends (via unicast)
+   a DHCPREQUEST message to the server to extend its lease.  The client
+   sets the 'ciaddr' field in the DHCPREQUEST to its current network
+   address. The client records the local time at which the DHCPREQUEST
+   message is sent for computation of the lease expiration time.  The
+   client MUST NOT include a 'server identifier' in the DHCPREQUEST
+   message.
+
+   Any DHCPACK messages that arrive with an 'xid' that does not match
+   the 'xid' of the client's DHCPREQUEST message are silently discarded.
+   When the client receives a DHCPACK from the server, the client
+   computes the lease expiration time as the sum of the time at which
+   the client sent the DHCPREQUEST message and the duration of the lease
+   in the DHCPACK message.  The client has successfully reacquired its
+   network address, returns to BOUND state and may continue network
+   processing.
+
+
+
+Droms                       Standards Track                    [Page 40]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   If no DHCPACK arrives before time T2, the client moves to REBINDING
+   state and sends (via broadcast) a DHCPREQUEST message to extend its
+   lease.  The client sets the 'ciaddr' field in the DHCPREQUEST to its
+   current network address.  The client MUST NOT include a 'server
+   identifier' in the DHCPREQUEST message.
+
+   Times T1 and T2 are configurable by the server through options.  T1
+   defaults to (0.5 * duration_of_lease).  T2 defaults to (0.875 *
+   duration_of_lease).  Times T1 and T2 SHOULD be chosen with some
+   random "fuzz" around a fixed value, to avoid synchronization of
+   client reacquisition.
+
+   A client MAY choose to renew or extend its lease prior to T1.  The
+   server MAY choose to extend the client's lease according to policy
+   set by the network administrator.  The server SHOULD return T1 and
+   T2, and their values SHOULD be adjusted from their original values to
+   take account of the time remaining on the lease.
+
+   In both RENEWING and REBINDING states, if the client receives no
+   response to its DHCPREQUEST message, the client SHOULD wait one-half
+   of the remaining time until T2 (in RENEWING state) and one-half of
+   the remaining lease time (in REBINDING state), down to a minimum of
+   60 seconds, before retransmitting the DHCPREQUEST message.
+
+   If the lease expires before the client receives a DHCPACK, the client
+   moves to INIT state, MUST immediately stop any other network
+   processing and requests network initialization parameters as if the
+   client were uninitialized.  If the client then receives a DHCPACK
+   allocating that client its previous network address, the client
+   SHOULD continue network processing.  If the client is given a new
+   network address, it MUST NOT continue using the previous network
+   address and SHOULD notify the local users of the problem.
+
+4.4.6 DHCPRELEASE
+
+   If the client no longer requires use of its assigned network address
+   (e.g., the client is gracefully shut down), the client sends a
+   DHCPRELEASE message to the server.  Note that the correct operation
+   of DHCP does not depend on the transmission of DHCPRELEASE messages.
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 41]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+5. Acknowledgments
+
+   The author thanks the many (and too numerous to mention!) members of
+   the DHC WG for their tireless and ongoing efforts in the development
+   of DHCP and this document.
+
+   The efforts of J Allard, Mike Carney, Dave Lapp, Fred Lien and John
+   Mendonca in organizing DHCP interoperability testing sessions are
+   gratefully acknowledged.
+
+   The development of this document was supported in part by grants from
+   the Corporation for National Research Initiatives (CNRI), Bucknell
+   University and Sun Microsystems.
+
+6. References
+
+   [1] Acetta, M., "Resource Location Protocol", RFC 887, CMU, December
+       1983.
+
+   [2] Alexander, S., and R. Droms, "DHCP Options and BOOTP Vendor
+       Extensions", RFC 1533, Lachman Technology, Inc., Bucknell
+       University, October 1993.
+
+   [3] Braden, R., Editor, "Requirements for Internet Hosts --
+       Communication Layers", STD 3, RFC 1122, USC/Information Sciences
+       Institute, October 1989.
+
+   [4] Braden, R., Editor, "Requirements for Internet Hosts --
+       Application and Support, STD 3, RFC 1123, USC/Information
+       Sciences Institute, October 1989.
+
+   [5] Brownell, D, "Dynamic Reverse Address Resolution Protocol
+       (DRARP)", Work in Progress.
+
+   [6] Comer, D., and R. Droms, "Uniform Access to Internet Directory
+       Services", Proc. of ACM SIGCOMM '90 (Special issue of Computer
+       Communications Review), 20(4):50--59, 1990.
+
+   [7] Croft, B., and J. Gilmore, "Bootstrap Protocol (BOOTP)", RFC 951,
+       Stanford and SUN Microsystems, September 1985.
+
+   [8] Deering, S., "ICMP Router Discovery Messages", RFC 1256, Xerox
+       PARC, September 1991.
+
+   [9] Droms, D., "Interoperation between DHCP and BOOTP", RFC 1534,
+       Bucknell University, October 1993.
+
+
+
+
+
+Droms                       Standards Track                    [Page 42]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   [10] Finlayson, R., Mann, T., Mogul, J., and M. Theimer, "A Reverse
+        Address Resolution Protocol", RFC 903, Stanford, June 1984.
+
+   [11] Gray C., and D. Cheriton, "Leases: An Efficient Fault-Tolerant
+        Mechanism for Distributed File Cache Consistency", In Proc. of
+        the Twelfth ACM Symposium on Operating Systems Design, 1989.
+
+   [12] Mockapetris, P., "Domain Names -- Concepts and Facilities", STD
+        13, RFC 1034, USC/Information Sciences Institute, November 1987.
+
+   [13] Mockapetris, P., "Domain Names -- Implementation and
+        Specification", STD 13, RFC 1035, USC/Information Sciences
+        Institute, November 1987.
+
+   [14] Mogul J., and S. Deering, "Path MTU Discovery", RFC 1191,
+        November 1990.
+
+   [15] Morgan, R., "Dynamic IP Address Assignment for Ethernet Attached
+        Hosts", Work in Progress.
+
+   [16] Postel, J., "Internet Control Message Protocol", STD 5, RFC 792,
+        USC/Information Sciences Institute, September 1981.
+
+   [17] Reynolds, J., "BOOTP Vendor Information Extensions", RFC 1497,
+        USC/Information Sciences Institute, August 1993.
+
+   [18] Reynolds, J., and J. Postel, "Assigned Numbers", STD 2, RFC 1700,
+        USC/Information Sciences Institute, October 1994.
+
+   [19] Jeffrey Schiller and Mark Rosenstein. A Protocol for the Dynamic
+        Assignment of IP Addresses for use on an Ethernet. (Available
+        from the Athena Project, MIT), 1989.
+
+   [20] Sollins, K., "The TFTP Protocol (Revision 2)",  RFC 783, NIC,
+        June 1981.
+
+   [21] Wimer, W., "Clarifications and Extensions for the Bootstrap
+        Protocol", RFC 1542, Carnegie Mellon University, October 1993.
+
+7. Security Considerations
+
+   DHCP is built directly on UDP and IP which are as yet inherently
+   insecure.  Furthermore, DHCP is generally intended to make
+   maintenance of remote and/or diskless hosts easier.  While perhaps
+   not impossible, configuring such hosts with passwords or keys may be
+   difficult and inconvenient.  Therefore, DHCP in its current form is
+   quite insecure.
+
+
+
+
+Droms                       Standards Track                    [Page 43]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+   Unauthorized DHCP servers may be easily set up.  Such servers can
+   then send false and potentially disruptive information to clients
+   such as incorrect or duplicate IP addresses, incorrect routing
+   information (including spoof routers, etc.), incorrect domain
+   nameserver addresses (such as spoof nameservers), and so on.
+   Clearly, once this seed information is in place, an attacker can
+   further compromise affected systems.
+
+   Malicious DHCP clients could masquerade as legitimate clients and
+   retrieve information intended for those legitimate clients.  Where
+   dynamic allocation of resources is used, a malicious client could
+   claim all resources for itself, thereby denying resources to
+   legitimate clients.
+
+8. Author's Address
+
+      Ralph Droms
+      Computer Science Department
+      323 Dana Engineering
+      Bucknell University
+      Lewisburg, PA 17837
+
+      Phone: (717) 524-1145
+      EMail: droms@bucknell.edu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Droms                       Standards Track                    [Page 44]
+
+RFC 2131          Dynamic Host Configuration Protocol         March 1997
+
+
+A. Host Configuration Parameters
+
+   IP-layer_parameters,_per_host:_
+
+   Be a router                     on/off                 HRC 3.1
+   Non-local source routing        on/off                 HRC 3.3.5
+   Policy filters for
+   non-local source routing        (list)                 HRC 3.3.5
+   Maximum reassembly size         integer                HRC 3.3.2
+   Default TTL                     integer                HRC 3.2.1.7
+   PMTU aging timeout              integer                MTU 6.6
+   MTU plateau table               (list)                 MTU 7
+   IP-layer_parameters,_per_interface:_
+   IP address                      (address)              HRC 3.3.1.6
+   Subnet mask                     (address mask)         HRC 3.3.1.6
+   MTU                             integer                HRC 3.3.3
+   All-subnets-MTU                 on/off                 HRC 3.3.3
+   Broadcast address flavor        0x00000000/0xffffffff  HRC 3.3.6
+   Perform mask discovery          on/off                 HRC 3.2.2.9
+   Be a mask supplier              on/off                 HRC 3.2.2.9
+   Perform router discovery        on/off                 RD 5.1
+   Router solicitation address     (address)              RD 5.1
+   Default routers, list of:
+           router address          (address)              HRC 3.3.1.6
+           preference level        integer                HRC 3.3.1.6
+   Static routes, list of:
+           destination             (host/subnet/net)      HRC 3.3.1.2
+           destination mask        (address mask)         HRC 3.3.1.2
+           type-of-service         integer                HRC 3.3.1.2
+           first-hop router        (address)              HRC 3.3.1.2
+           ignore redirects        on/off                 HRC 3.3.1.2
+           PMTU                    integer                MTU 6.6
+           perform PMTU discovery  on/off                 MTU 6.6
+
+   Link-layer_parameters,_per_interface:_
+   Trailers                       on/off                 HRC 2.3.1
+   ARP cache timeout              integer                HRC 2.3.2.1
+   Ethernet encapsulation         (RFC 894/RFC 1042)     HRC 2.3.3
+
+   TCP_parameters,_per_host:_
+   TTL                            integer                HRC 4.2.2.19
+   Keep-alive interval            integer                HRC 4.2.3.6
+   Keep-alive data size           0/1                    HRC 4.2.3.6
+
+Key:
+
+   MTU = Path MTU Discovery (RFC 1191, Proposed Standard)
+   RD = Router Discovery (RFC 1256, Proposed Standard)
+
+
+
+Droms                       Standards Track                    [Page 45]
+

commit b1ab32ee607c47dec613be7f5a10bb82d2941f3f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 08:55:37 2008 +0100

    Add copy of RFC 2132 (DHCP options)

diff --git a/doc/rfc2132.txt b/doc/rfc2132.txt
new file mode 100644
index 00000000..e9c4f4b3
--- /dev/null
+++ b/doc/rfc2132.txt
@@ -0,0 +1,1907 @@
+
+
+
+
+
+
+Network Working Group                                       S. Alexander
+Request for Comments: 2132                        Silicon Graphics, Inc.
+Obsoletes: 1533                                                 R. Droms
+Category: Standards Track                            Bucknell University
+                                                              March 1997
+
+                DHCP Options and BOOTP Vendor Extensions
+
+Status of this memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   The Dynamic Host Configuration Protocol (DHCP) [1] provides a
+   framework for passing configuration information to hosts on a TCP/IP
+   network.  Configuration parameters and other control information are
+   carried in tagged data items that are stored in the 'options' field
+   of the DHCP message.  The data items themselves are also called
+   "options."
+
+   This document specifies the current set of DHCP options.  Future
+   options will be specified in separate RFCs.  The current list of
+   valid options is also available in ftp://ftp.isi.edu/in-
+   notes/iana/assignments [22].
+
+   All of the vendor information extensions defined in RFC 1497 [2] may
+   be used as DHCP options.  The definitions given in RFC 1497 are
+   included in this document, which supersedes RFC 1497.  All of the
+   DHCP options defined in this document, except for those specific to
+   DHCP as defined in section 9, may be used as BOOTP vendor information
+   extensions.
+
+Table of Contents
+
+    1.  Introduction ..............................................  2
+    2.  BOOTP Extension/DHCP Option Field Format ..................  4
+    3.  RFC 1497 Vendor Extensions ................................  5
+    4.  IP Layer Parameters per Host .............................. 11
+    5.  IP Layer Parameters per Interface ........................  13
+    6.  Link Layer Parameters per Interface ....................... 16
+    7.  TCP Parameters ............................................ 17
+    8.  Application and Service Parameters ........................ 18
+    9.  DHCP Extensions ........................................... 25
+
+
+
+Alexander & Droms           Standards Track                     [Page 1]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   10.  Defining new extensions ................................... 31
+   11.  Acknowledgements .......................................... 31
+   12.  References ................................................ 32
+   13.  Security Considerations ................................... 33
+   14.  Authors' Addresses ........................................ 34
+
+1. Introduction
+
+   This document specifies options for use with both the Dynamic Host
+   Configuration Protocol and the Bootstrap Protocol.
+
+   The full description of DHCP packet formats may be found in the DHCP
+   specification document [1], and the full description of BOOTP packet
+   formats may be found in the BOOTP specification document [3].  This
+   document defines the format of information in the last field of DHCP
+   packets ('options') and of BOOTP packets ('vend').  The remainder of
+   this section defines a generalized use of this area for giving
+   information useful to a wide class of machines, operating systems and
+   configurations. Sites with a single DHCP or BOOTP server that is
+   shared among heterogeneous clients may choose to define other, site-
+   specific formats for the use of the 'options' field.
+
+   Section 2 of this memo describes the formats of DHCP options and
+   BOOTP vendor extensions.  Section 3 describes options defined in
+   previous documents for use with BOOTP (all may also be used with
+   DHCP).  Sections 4-8 define new options intended for use with both
+   DHCP and BOOTP. Section 9 defines options used only in DHCP.
+
+   References further describing most of the options defined in sections
+   2-6 can be found in section 12.  The use of the options defined in
+   section 9 is described in the DHCP specification [1].
+
+   Information on registering new options is contained in section 10.
+
+   This document updates the definition of DHCP/BOOTP options that
+   appears in RFC1533.  The classing mechanism has been extended to
+   include vendor classes as described in section 8.4 and 9.13.  The new
+   procedure for defining new DHCP/BOOTP options in described in section
+   10.  Several new options, including NIS+ domain and servers, Mobile
+   IP home agent, SMTP server, TFTP server and Bootfile server, have
+   been added.  Text giving definitions used throughout the document has
+   been added in section 1.1.  Text emphasizing the need for uniqueness
+   of client-identifiers has been added to section 9.14.
+
+
+
+
+
+
+
+
+Alexander & Droms           Standards Track                     [Page 2]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+1.1 Requirements
+
+   Throughout this document, the words that are used to define the
+   significance of particular requirements are capitalized.  These words
+   are:
+
+      o "MUST"
+
+       This word or the adjective "REQUIRED" means that the item is an
+       absolute requirement of this specification.
+
+      o "MUST NOT"
+
+       This phrase means that the item is an absolute prohibition of
+       this specification.
+
+      o "SHOULD"
+
+       This word or the adjective "RECOMMENDED" means that there may
+       exist valid reasons in particular circumstances to ignore this
+       item, but the full implications should be understood and the case
+       carefully weighed before choosing a different course.
+
+      o "SHOULD NOT"
+
+       This phrase means that there may exist valid reasons in
+       particular circumstances when the listed behavior is acceptable
+       or even useful, but the full implications should be understood
+       and the case carefully weighed before implementing any behavior
+       described with this label.
+
+      o "MAY"
+
+       This word or the adjective "OPTIONAL" means that this item is
+       truly optional.  One vendor may choose to include the item
+       because a particular marketplace requires it or because it
+       enhances the product, for example; another vendor may omit the
+       same item.
+
+1.2 Terminology
+
+   This document uses the following terms:
+
+      o "DHCP client"
+
+       A DHCP client or "client" is an Internet host using DHCP to
+       obtain configuration parameters such as a network address.
+
+
+
+
+Alexander & Droms           Standards Track                     [Page 3]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+      o "DHCP server"
+
+       A DHCP server of "server"is an Internet host that returns
+       configuration parameters to DHCP clients.
+
+      o "binding"
+
+       A binding is a collection of configuration parameters, including
+       at least an IP address, associated with or "bound to" a DHCP
+       client.  Bindings are managed by DHCP servers.
+
+2. BOOTP Extension/DHCP Option Field Format
+
+
+   DHCP options have the same format as the BOOTP 'vendor extensions'
+   defined in RFC 1497 [2].  Options may be fixed length or variable
+   length.  All options begin with a tag octet, which uniquely
+   identifies the option.  Fixed-length options without data consist of
+   only a tag octet.  Only options 0 and 255 are fixed length.  All
+   other options are variable-length with a length octet following the
+   tag octet.  The value of the length octet does not include the two
+   octets specifying the tag and length.  The length octet is followed
+   by "length" octets of data.  Options containing NVT ASCII data SHOULD
+   NOT include a trailing NULL; however, the receiver of such options
+   MUST be prepared to delete trailing nulls if they exist.  The
+   receiver MUST NOT require that a trailing null be included in the
+   data.  In the case of some variable-length options the length field
+   is a constant but must still be specified.
+
+   Any options defined subsequent to this document MUST contain a length
+   octet even if the length is fixed or zero.
+
+   All multi-octet quantities are in network byte-order.
+
+   When used with BOOTP, the first four octets of the vendor information
+   field have been assigned to the "magic cookie" (as suggested in RFC
+   951).  This field identifies the mode in which the succeeding data is
+   to be interpreted.  The value of the magic cookie is the 4 octet
+   dotted decimal 99.130.83.99 (or hexadecimal number 63.82.53.63) in
+   network byte order.
+
+   All of the "vendor extensions" defined in RFC 1497 are also DHCP
+   options.
+
+   Option codes 128 to 254 (decimal) are reserved for site-specific
+   options.
+
+
+
+
+
+Alexander & Droms           Standards Track                     [Page 4]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   Except for the options in section 9, all options may be used with
+   either DHCP or BOOTP.
+
+   Many of these options have their default values specified in other
+   documents.  In particular, RFC 1122 [4] specifies default values for
+   most IP and TCP configuration parameters.
+
+   Many options supply one or more 32-bit IP address.  Use of IP
+   addresses rather than fully-qualified Domain Names (FQDNs) may make
+   future renumbering of IP hosts more difficult.  Use of these
+   addresses is discouraged at sites that may require renumbering.
+
+3. RFC 1497 Vendor Extensions
+
+   This section lists the vendor extensions as defined in RFC 1497.
+   They are defined here for completeness.
+
+3.1. Pad Option
+
+   The pad option can be used to cause subsequent fields to align on
+   word boundaries.
+
+   The code for the pad option is 0, and its length is 1 octet.
+
+    Code
+   +-----+
+   |  0  |
+   +-----+
+
+3.2. End Option
+
+   The end option marks the end of valid information in the vendor
+   field.  Subsequent octets should be filled with pad options.
+
+   The code for the end option is 255, and its length is 1 octet.
+
+    Code
+   +-----+
+   | 255 |
+   +-----+
+
+3.3. Subnet Mask
+
+   The subnet mask option specifies the client's subnet mask as per RFC
+   950 [5].
+
+   If both the subnet mask and the router option are specified in a DHCP
+   reply, the subnet mask option MUST be first.
+
+
+
+Alexander & Droms           Standards Track                     [Page 5]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for the subnet mask option is 1, and its length is 4 octets.
+
+    Code   Len        Subnet Mask
+   +-----+-----+-----+-----+-----+-----+
+   |  1  |  4  |  m1 |  m2 |  m3 |  m4 |
+   +-----+-----+-----+-----+-----+-----+
+
+3.4. Time Offset
+
+   The time offset field specifies the offset of the client's subnet in
+   seconds from Coordinated Universal Time (UTC).  The offset is
+   expressed as a two's complement 32-bit integer.  A positive offset
+   indicates a location east of the zero meridian and a negative offset
+   indicates a location west of the zero meridian.
+
+   The code for the time offset option is 2, and its length is 4 octets.
+
+    Code   Len        Time Offset
+   +-----+-----+-----+-----+-----+-----+
+   |  2  |  4  |  n1 |  n2 |  n3 |  n4 |
+   +-----+-----+-----+-----+-----+-----+
+
+3.5. Router Option
+
+   The router option specifies a list of IP addresses for routers on the
+   client's subnet.  Routers SHOULD be listed in order of preference.
+
+   The code for the router option is 3.  The minimum length for the
+   router option is 4 octets, and the length MUST always be a multiple
+   of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  3  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.6. Time Server Option
+
+   The time server option specifies a list of RFC 868 [6] time servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+   The code for the time server option is 4.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+
+
+
+
+
+Alexander & Droms           Standards Track                     [Page 6]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  4  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.7. Name Server Option
+
+   The name server option specifies a list of IEN 116 [7] name servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+   The code for the name server option is 5.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  5  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.8. Domain Name Server Option
+
+   The domain name server option specifies a list of Domain Name System
+   (STD 13, RFC 1035 [8]) name servers available to the client.  Servers
+   SHOULD be listed in order of preference.
+
+   The code for the domain name server option is 6.  The minimum length
+   for this option is 4 octets, and the length MUST always be a multiple
+   of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  6  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.9. Log Server Option
+
+   The log server option specifies a list of MIT-LCS UDP log servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+   The code for the log server option is 7.  The minimum length for this
+   option is 4 octets, and the length MUST always be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  7  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+
+
+Alexander & Droms           Standards Track                     [Page 7]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+3.10. Cookie Server Option
+
+   The cookie server option specifies a list of RFC 865 [9] cookie
+   servers available to the client.  Servers SHOULD be listed in order
+   of preference.
+
+   The code for the log server option is 8.  The minimum length for this
+   option is 4 octets, and the length MUST always be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  8  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.11. LPR Server Option
+
+   The LPR server option specifies a list of RFC 1179 [10] line printer
+   servers available to the client.  Servers SHOULD be listed in order
+   of preference.
+
+   The code for the LPR server option is 9.  The minimum length for this
+   option is 4 octets, and the length MUST always be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  9  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.12. Impress Server Option
+
+   The Impress server option specifies a list of Imagen Impress servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+   The code for the Impress server option is 10.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  10 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.13. Resource Location Server Option
+
+   This option specifies a list of RFC 887 [11] Resource Location
+   servers available to the client.  Servers SHOULD be listed in order
+   of preference.
+
+
+
+Alexander & Droms           Standards Track                     [Page 8]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for this option is 11.  The minimum length for this option
+   is 4 octets, and the length MUST always be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  11 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.14. Host Name Option
+
+   This option specifies the name of the client.  The name may or may
+   not be qualified with the local domain name (see section 3.17 for the
+   preferred way to retrieve the domain name).  See RFC 1035 for
+   character set restrictions.
+
+   The code for this option is 12, and its minimum length is 1.
+
+    Code   Len                 Host Name
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  12 |  n  |  h1 |  h2 |  h3 |  h4 |  h5 |  h6 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+3.15. Boot File Size Option
+
+   This option specifies the length in 512-octet blocks of the default
+   boot image for the client.  The file length is specified as an
+   unsigned 16-bit integer.
+
+   The code for this option is 13, and its length is 2.
+
+    Code   Len   File Size
+   +-----+-----+-----+-----+
+   |  13 |  2  |  l1 |  l2 |
+   +-----+-----+-----+-----+
+
+3.16. Merit Dump File
+
+   This option specifies the path-name of a file to which the client's
+   core image should be dumped in the event the client crashes.  The
+   path is formatted as a character string consisting of characters from
+   the NVT ASCII character set.
+
+   The code for this option is 14.  Its minimum length is 1.
+
+    Code   Len      Dump File Pathname
+   +-----+-----+-----+-----+-----+-----+---
+   |  14 |  n  |  n1 |  n2 |  n3 |  n4 | ...
+   +-----+-----+-----+-----+-----+-----+---
+
+
+
+Alexander & Droms           Standards Track                     [Page 9]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+3.17. Domain Name
+
+   This option specifies the domain name that client should use when
+   resolving hostnames via the Domain Name System.
+
+   The code for this option is 15.  Its minimum length is 1.
+
+    Code   Len        Domain Name
+   +-----+-----+-----+-----+-----+-----+--
+   |  15 |  n  |  d1 |  d2 |  d3 |  d4 |  ...
+   +-----+-----+-----+-----+-----+-----+--
+
+3.18. Swap Server
+
+   This specifies the IP address of the client's swap server.
+
+   The code for this option is 16 and its length is 4.
+
+    Code   Len    Swap Server Address
+   +-----+-----+-----+-----+-----+-----+
+   |  16 |  n  |  a1 |  a2 |  a3 |  a4 |
+   +-----+-----+-----+-----+-----+-----+
+
+3.19. Root Path
+
+   This option specifies the path-name that contains the client's root
+   disk.  The path is formatted as a character string consisting of
+   characters from the NVT ASCII character set.
+
+   The code for this option is 17.  Its minimum length is 1.
+
+    Code   Len      Root Disk Pathname
+   +-----+-----+-----+-----+-----+-----+---
+   |  17 |  n  |  n1 |  n2 |  n3 |  n4 | ...
+   +-----+-----+-----+-----+-----+-----+---
+
+3.20. Extensions Path
+
+   A string to specify a file, retrievable via TFTP, which contains
+   information which can be interpreted in the same way as the 64-octet
+   vendor-extension field within the BOOTP response, with the following
+   exceptions:
+
+          - the length of the file is unconstrained;
+          - all references to Tag 18 (i.e., instances of the
+            BOOTP Extensions Path field) within the file are
+            ignored.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 10]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for this option is 18.  Its minimum length is 1.
+
+    Code   Len      Extensions Pathname
+   +-----+-----+-----+-----+-----+-----+---
+   |  18 |  n  |  n1 |  n2 |  n3 |  n4 | ...
+   +-----+-----+-----+-----+-----+-----+---
+
+4. IP Layer Parameters per Host
+
+   This section details the options that affect the operation of the IP
+   layer on a per-host basis.
+
+4.1. IP Forwarding Enable/Disable Option
+
+   This option specifies whether the client should configure its IP
+   layer for packet forwarding.  A value of 0 means disable IP
+   forwarding, and a value of 1 means enable IP forwarding.
+
+   The code for this option is 19, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  19 |  1  | 0/1 |
+   +-----+-----+-----+
+
+4.2. Non-Local Source Routing Enable/Disable Option
+
+   This option specifies whether the client should configure its IP
+   layer to allow forwarding of datagrams with non-local source routes
+   (see Section 3.3.5 of [4] for a discussion of this topic).  A value
+   of 0 means disallow forwarding of such datagrams, and a value of 1
+   means allow forwarding.
+
+   The code for this option is 20, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  20 |  1  | 0/1 |
+   +-----+-----+-----+
+
+4.3. Policy Filter Option
+
+   This option specifies policy filters for non-local source routing.
+   The filters consist of a list of IP addresses and masks which specify
+   destination/mask pairs with which to filter incoming source routes.
+
+   Any source routed datagram whose next-hop address does not match one
+   of the filters should be discarded by the client.
+
+
+
+Alexander & Droms           Standards Track                    [Page 11]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   See [4] for further information.
+
+   The code for this option is 21.  The minimum length of this option is
+   8, and the length MUST be a multiple of 8.
+
+    Code   Len         Address 1                  Mask 1
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+   |  21 |  n  |  a1 |  a2 |  a3 |  a4 |  m1 |  m2 |  m3 |  m4 |
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+           Address 2                  Mask 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+   |  a1 |  a2 |  a3 |  a4 |  m1 |  m2 |  m3 |  m4 | ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+
+4.4. Maximum Datagram Reassembly Size
+
+   This option specifies the maximum size datagram that the client
+   should be prepared to reassemble.  The size is specified as a 16-bit
+   unsigned integer.  The minimum value legal value is 576.
+
+   The code for this option is 22, and its length is 2.
+
+    Code   Len      Size
+   +-----+-----+-----+-----+
+   |  22 |  2  |  s1 |  s2 |
+   +-----+-----+-----+-----+
+
+4.5. Default IP Time-to-live
+
+   This option specifies the default time-to-live that the client should
+   use on outgoing datagrams.  The TTL is specified as an octet with a
+   value between 1 and 255.
+
+   The code for this option is 23, and its length is 1.
+
+    Code   Len   TTL
+   +-----+-----+-----+
+   |  23 |  1  | ttl |
+   +-----+-----+-----+
+
+4.6. Path MTU Aging Timeout Option
+
+   This option specifies the timeout (in seconds) to use when aging Path
+   MTU values discovered by the mechanism defined in RFC 1191 [12].  The
+   timeout is specified as a 32-bit unsigned integer.
+
+   The code for this option is 24, and its length is 4.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 12]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+    Code   Len           Timeout
+   +-----+-----+-----+-----+-----+-----+
+   |  24 |  4  |  t1 |  t2 |  t3 |  t4 |
+   +-----+-----+-----+-----+-----+-----+
+
+4.7. Path MTU Plateau Table Option
+
+   This option specifies a table of MTU sizes to use when performing
+   Path MTU Discovery as defined in RFC 1191.  The table is formatted as
+   a list of 16-bit unsigned integers, ordered from smallest to largest.
+   The minimum MTU value cannot be smaller than 68.
+
+   The code for this option is 25.  Its minimum length is 2, and the
+   length MUST be a multiple of 2.
+
+    Code   Len     Size 1      Size 2
+   +-----+-----+-----+-----+-----+-----+---
+   |  25 |  n  |  s1 |  s2 |  s1 |  s2 | ...
+   +-----+-----+-----+-----+-----+-----+---
+
+5. IP Layer Parameters per Interface
+
+   This section details the options that affect the operation of the IP
+   layer on a per-interface basis.  It is expected that a client can
+   issue multiple requests, one per interface, in order to configure
+   interfaces with their specific parameters.
+
+5.1. Interface MTU Option
+
+   This option specifies the MTU to use on this interface.  The MTU is
+   specified as a 16-bit unsigned integer.  The minimum legal value for
+   the MTU is 68.
+
+   The code for this option is 26, and its length is 2.
+
+    Code   Len      MTU
+   +-----+-----+-----+-----+
+   |  26 |  2  |  m1 |  m2 |
+   +-----+-----+-----+-----+
+
+5.2. All Subnets are Local Option
+
+   This option specifies whether or not the client may assume that all
+   subnets of the IP network to which the client is connected use the
+   same MTU as the subnet of that network to which the client is
+   directly connected.  A value of 1 indicates that all subnets share
+   the same MTU.  A value of 0 means that the client should assume that
+   some subnets of the directly connected network may have smaller MTUs.
+
+
+
+Alexander & Droms           Standards Track                    [Page 13]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for this option is 27, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  27 |  1  | 0/1 |
+   +-----+-----+-----+
+
+5.3. Broadcast Address Option
+
+   This option specifies the broadcast address in use on the client's
+   subnet.  Legal values for broadcast addresses are specified in
+   section 3.2.1.3 of [4].
+
+   The code for this option is 28, and its length is 4.
+
+    Code   Len     Broadcast Address
+   +-----+-----+-----+-----+-----+-----+
+   |  28 |  4  |  b1 |  b2 |  b3 |  b4 |
+   +-----+-----+-----+-----+-----+-----+
+
+5.4. Perform Mask Discovery Option
+
+   This option specifies whether or not the client should perform subnet
+   mask discovery using ICMP.  A value of 0 indicates that the client
+   should not perform mask discovery.  A value of 1 means that the
+   client should perform mask discovery.
+
+   The code for this option is 29, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  29 |  1  | 0/1 |
+   +-----+-----+-----+
+
+5.5. Mask Supplier Option
+
+   This option specifies whether or not the client should respond to
+   subnet mask requests using ICMP.  A value of 0 indicates that the
+   client should not respond.  A value of 1 means that the client should
+   respond.
+
+   The code for this option is 30, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  30 |  1  | 0/1 |
+   +-----+-----+-----+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 14]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+5.6. Perform Router Discovery Option
+
+   This option specifies whether or not the client should solicit
+   routers using the Router Discovery mechanism defined in RFC 1256
+   [13].  A value of 0 indicates that the client should not perform
+   router discovery.  A value of 1 means that the client should perform
+   router discovery.
+
+   The code for this option is 31, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  31 |  1  | 0/1 |
+   +-----+-----+-----+
+
+5.7. Router Solicitation Address Option
+
+   This option specifies the address to which the client should transmit
+   router solicitation requests.
+
+   The code for this option is 32, and its length is 4.
+
+    Code   Len            Address
+   +-----+-----+-----+-----+-----+-----+
+   |  32 |  4  |  a1 |  a2 |  a3 |  a4 |
+   +-----+-----+-----+-----+-----+-----+
+
+5.8. Static Route Option
+
+   This option specifies a list of static routes that the client should
+   install in its routing cache.  If multiple routes to the same
+   destination are specified, they are listed in descending order of
+   priority.
+
+   The routes consist of a list of IP address pairs.  The first address
+   is the destination address, and the second address is the router for
+   the destination.
+
+   The default route (0.0.0.0) is an illegal destination for a static
+   route.  See section 3.5 for information about the router option.
+
+   The code for this option is 33.  The minimum length of this option is
+   8, and the length MUST be a multiple of 8.
+
+
+
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 15]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+    Code   Len         Destination 1           Router 1
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+   |  33 |  n  |  d1 |  d2 |  d3 |  d4 |  r1 |  r2 |  r3 |  r4 |
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+           Destination 2           Router 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+   |  d1 |  d2 |  d3 |  d4 |  r1 |  r2 |  r3 |  r4 | ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+
+6. Link Layer Parameters per Interface
+
+   This section lists the options that affect the operation of the data
+   link layer on a per-interface basis.
+
+6.1. Trailer Encapsulation Option
+
+   This option specifies whether or not the client should negotiate the
+   use of trailers (RFC 893 [14]) when using the ARP protocol.  A value
+   of 0 indicates that the client should not attempt to use trailers.  A
+   value of 1 means that the client should attempt to use trailers.
+
+   The code for this option is 34, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  34 |  1  | 0/1 |
+   +-----+-----+-----+
+
+6.2. ARP Cache Timeout Option
+
+   This option specifies the timeout in seconds for ARP cache entries.
+   The time is specified as a 32-bit unsigned integer.
+
+   The code for this option is 35, and its length is 4.
+
+    Code   Len           Time
+   +-----+-----+-----+-----+-----+-----+
+   |  35 |  4  |  t1 |  t2 |  t3 |  t4 |
+   +-----+-----+-----+-----+-----+-----+
+
+6.3. Ethernet Encapsulation Option
+
+   This option specifies whether or not the client should use Ethernet
+   Version 2 (RFC 894 [15]) or IEEE 802.3 (RFC 1042 [16]) encapsulation
+   if the interface is an Ethernet.  A value of 0 indicates that the
+   client should use RFC 894 encapsulation.  A value of 1 means that the
+   client should use RFC 1042 encapsulation.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 16]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for this option is 36, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  36 |  1  | 0/1 |
+   +-----+-----+-----+
+
+7. TCP Parameters
+
+   This section lists the options that affect the operation of the TCP
+   layer on a per-interface basis.
+
+7.1. TCP Default TTL Option
+
+   This option specifies the default TTL that the client should use when
+   sending TCP segments.  The value is represented as an 8-bit unsigned
+   integer.  The minimum value is 1.
+
+   The code for this option is 37, and its length is 1.
+
+    Code   Len   TTL
+   +-----+-----+-----+
+   |  37 |  1  |  n  |
+   +-----+-----+-----+
+
+7.2. TCP Keepalive Interval Option
+
+   This option specifies the interval (in seconds) that the client TCP
+   should wait before sending a keepalive message on a TCP connection.
+   The time is specified as a 32-bit unsigned integer.  A value of zero
+   indicates that the client should not generate keepalive messages on
+   connections unless specifically requested by an application.
+
+   The code for this option is 38, and its length is 4.
+
+    Code   Len           Time
+   +-----+-----+-----+-----+-----+-----+
+   |  38 |  4  |  t1 |  t2 |  t3 |  t4 |
+   +-----+-----+-----+-----+-----+-----+
+
+7.3. TCP Keepalive Garbage Option
+
+   This option specifies the whether or not the client should send TCP
+   keepalive messages with a octet of garbage for compatibility with
+   older implementations.  A value of 0 indicates that a garbage octet
+   should not be sent. A value of 1 indicates that a garbage octet
+   should be sent.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 17]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for this option is 39, and its length is 1.
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  39 |  1  | 0/1 |
+   +-----+-----+-----+
+
+8. Application and Service Parameters
+
+   This section details some miscellaneous options used to configure
+   miscellaneous applications and services.
+
+8.1. Network Information Service Domain Option
+
+   This option specifies the name of the client's NIS [17] domain.  The
+   domain is formatted as a character string consisting of characters
+   from the NVT ASCII character set.
+
+   The code for this option is 40.  Its minimum length is 1.
+
+    Code   Len      NIS Domain Name
+   +-----+-----+-----+-----+-----+-----+---
+   |  40 |  n  |  n1 |  n2 |  n3 |  n4 | ...
+   +-----+-----+-----+-----+-----+-----+---
+
+8.2. Network Information Servers Option
+
+   This option specifies a list of IP addresses indicating NIS servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+   The code for this option is 41.  Its minimum length is 4, and the
+   length MUST be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  41 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.3. Network Time Protocol Servers Option
+
+   This option specifies a list of IP addresses indicating NTP [18]
+   servers available to the client.  Servers SHOULD be listed in order
+   of preference.
+
+   The code for this option is 42.  Its minimum length is 4, and the
+   length MUST be a multiple of 4.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 18]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  42 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.4. Vendor Specific Information
+
+   This option is used by clients and servers to exchange vendor-
+   specific information.  The information is an opaque object of n
+   octets, presumably interpreted by vendor-specific code on the clients
+   and servers.  The definition of this information is vendor specific.
+   The vendor is indicated in the vendor class identifier option.
+   Servers not equipped to interpret the vendor-specific information
+   sent by a client MUST ignore it (although it may be reported).
+   Clients which do not receive desired vendor-specific information
+   SHOULD make an attempt to operate without it, although they may do so
+   (and announce they are doing so) in a degraded mode.
+
+   If a vendor potentially encodes more than one item of information in
+   this option, then the vendor SHOULD encode the option using
+   "Encapsulated vendor-specific options" as described below:
+
+   The Encapsulated vendor-specific options field SHOULD be encoded as a
+   sequence of code/length/value fields of identical syntax to the DHCP
+   options field with the following exceptions:
+
+      1) There SHOULD NOT be a "magic cookie" field in the encapsulated
+         vendor-specific extensions field.
+
+      2) Codes other than 0 or 255 MAY be redefined by the vendor within
+         the encapsulated vendor-specific extensions field, but SHOULD
+         conform to the tag-length-value syntax defined in section 2.
+
+      3) Code 255 (END), if present, signifies the end of the
+         encapsulated vendor extensions, not the end of the vendor
+         extensions field. If no code 255 is present, then the end of
+         the enclosing vendor-specific information field is taken as the
+         end of the encapsulated vendor-specific extensions field.
+
+   The code for this option is 43 and its minimum length is 1.
+
+   Code   Len   Vendor-specific information
+   +-----+-----+-----+-----+---
+   |  43 |  n  |  i1 |  i2 | ...
+   +-----+-----+-----+-----+---
+
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 19]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   When encapsulated vendor-specific extensions are used, the
+   information bytes 1-n have the following format:
+
+    Code   Len   Data item        Code   Len   Data item       Code
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+   |  T1 |  n  |  d1 |  d2 | ... |  T2 |  n  |  D1 |  D2 | ... | ... |
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+
+8.5. NetBIOS over TCP/IP Name Server Option
+
+   The NetBIOS name server (NBNS) option specifies a list of RFC
+   1001/1002 [19] [20] NBNS name servers listed in order of preference.
+
+   The code for this option is 44.  The minimum length of the option is
+   4 octets, and the length must always be a multiple of 4.
+
+    Code   Len           Address 1              Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+----
+   |  44 |  n  |  a1 |  a2 |  a3 |  a4 |  b1 |  b2 |  b3 |  b4 | ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+----
+
+8.6. NetBIOS over TCP/IP Datagram Distribution Server Option
+
+   The NetBIOS datagram distribution server (NBDD) option specifies a
+   list of RFC 1001/1002 NBDD servers listed in order of preference. The
+   code for this option is 45.  The minimum length of the option is 4
+   octets, and the length must always be a multiple of 4.
+
+    Code   Len           Address 1              Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+----
+   |  45 |  n  |  a1 |  a2 |  a3 |  a4 |  b1 |  b2 |  b3 |  b4 | ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+----
+
+8.7. NetBIOS over TCP/IP Node Type Option
+
+   The NetBIOS node type option allows NetBIOS over TCP/IP clients which
+   are configurable to be configured as described in RFC 1001/1002.  The
+   value is specified as a single octet which identifies the client type
+   as follows:
+
+      Value         Node Type
+      -----         ---------
+      0x1           B-node
+      0x2           P-node
+      0x4           M-node
+      0x8           H-node
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 20]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   In the above chart, the notation '0x' indicates a number in base-16
+   (hexadecimal).
+
+   The code for this option is 46.  The length of this option is always
+   1.
+
+    Code   Len  Node Type
+   +-----+-----+-----------+
+   |  46 |  1  | see above |
+   +-----+-----+-----------+
+
+8.8. NetBIOS over TCP/IP Scope Option
+
+   The NetBIOS scope option specifies the NetBIOS over TCP/IP scope
+   parameter for the client as specified in RFC 1001/1002. See [19],
+   [20], and [8] for character-set restrictions.
+
+   The code for this option is 47.  The minimum length of this option is
+   1.
+
+    Code   Len       NetBIOS Scope
+   +-----+-----+-----+-----+-----+-----+----
+   |  47 |  n  |  s1 |  s2 |  s3 |  s4 | ...
+   +-----+-----+-----+-----+-----+-----+----
+
+8.9. X Window System Font Server Option
+
+   This option specifies a list of X Window System [21] Font servers
+   available to the client. Servers SHOULD be listed in order of
+   preference.
+
+   The code for this option is 48.  The minimum length of this option is
+   4 octets, and the length MUST be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+   |  48 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |   ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+
+8.10. X Window System Display Manager Option
+
+   This option specifies a list of IP addresses of systems that are
+   running the X Window System Display Manager and are available to the
+   client.
+
+   Addresses SHOULD be listed in order of preference.
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 21]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for the this option is 49. The minimum length of this option
+   is 4, and the length MUST be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+   |  49 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |   ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+---
+
+8.11. Network Information Service+ Domain Option
+
+   This option specifies the name of the client's NIS+ [17] domain.  The
+   domain is formatted as a character string consisting of characters
+   from the NVT ASCII character set.
+
+   The code for this option is 64.  Its minimum length is 1.
+
+    Code   Len      NIS Client Domain Name
+   +-----+-----+-----+-----+-----+-----+---
+   |  64 |  n  |  n1 |  n2 |  n3 |  n4 | ...
+   +-----+-----+-----+-----+-----+-----+---
+
+8.12. Network Information Service+ Servers Option
+
+   This option specifies a list of IP addresses indicating NIS+ servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+   The code for this option is 65.  Its minimum length is 4, and the
+   length MUST be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   |  65 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.13. Mobile IP Home Agent option
+
+   This option specifies a list of IP addresses indicating mobile IP
+   home agents available to the client.  Agents SHOULD be listed in
+   order of preference.
+
+   The code for this option is 68.  Its minimum length is 0 (indicating
+   no home agents are available) and the length MUST be a multiple of 4.
+   It is expected that the usual length will be four octets, containing
+   a single home agent's address.
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 22]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+    Code Len    Home Agent Addresses (zero or more)
+   +-----+-----+-----+-----+-----+-----+--
+   | 68  |  n  | a1  | a2  | a3  | a4  | ...
+   +-----+-----+-----+-----+-----+-----+--
+
+8.14. Simple Mail Transport Protocol (SMTP) Server Option
+
+   The SMTP server option specifies a list of SMTP servers available to
+   the client.  Servers SHOULD be listed in order of preference.
+
+   The code for the SMTP server option is 69.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 69  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.15. Post Office Protocol (POP3) Server Option
+
+   The POP3 server option specifies a list of POP3 available to the
+   client.  Servers SHOULD be listed in order of preference.
+
+   The code for the POP3 server option is 70.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 70  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.16. Network News Transport Protocol (NNTP) Server Option
+
+   The NNTP server option specifies a list of NNTP available to the
+   client.  Servers SHOULD be listed in order of preference.
+
+   The code for the NNTP server option is 71. The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 71  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 23]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+8.17. Default World Wide Web (WWW) Server Option
+
+   The WWW server option specifies a list of WWW available to the
+   client.  Servers SHOULD be listed in order of preference.
+
+   The code for the WWW server option is 72.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 72  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.18. Default Finger Server Option
+
+   The Finger server option specifies a list of Finger available to the
+   client.  Servers SHOULD be listed in order of preference.
+
+   The code for the Finger server option is 73.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 73  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.19. Default Internet Relay Chat (IRC) Server Option
+
+   The IRC server option specifies a list of IRC available to the
+   client.  Servers SHOULD be listed in order of preference.
+
+   The code for the IRC server option is 74.  The minimum length for
+   this option is 4 octets, and the length MUST always be a multiple of
+   4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 74  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.20. StreetTalk Server Option
+
+   The StreetTalk server option specifies a list of StreetTalk servers
+   available to the client.  Servers SHOULD be listed in order of
+   preference.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 24]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for the StreetTalk server option is 75.  The minimum length
+   for this option is 4 octets, and the length MUST always be a multiple
+   of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 75  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+8.21. StreetTalk Directory Assistance (STDA) Server Option
+
+   The StreetTalk Directory Assistance (STDA) server option specifies a
+   list of STDA servers available to the client.  Servers SHOULD be
+   listed in order of preference.
+
+   The code for the StreetTalk Directory Assistance server option is 76.
+   The minimum length for this option is 4 octets, and the length MUST
+   always be a multiple of 4.
+
+    Code   Len         Address 1               Address 2
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+   | 76  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
+   +-----+-----+-----+-----+-----+-----+-----+-----+--
+
+9. DHCP Extensions
+
+   This section details the options that are specific to DHCP.
+
+9.1. Requested IP Address
+
+   This option is used in a client request (DHCPDISCOVER) to allow the
+   client to request that a particular IP address be assigned.
+
+   The code for this option is 50, and its length is 4.
+
+    Code   Len          Address
+   +-----+-----+-----+-----+-----+-----+
+   |  50 |  4  |  a1 |  a2 |  a3 |  a4 |
+   +-----+-----+-----+-----+-----+-----+
+
+9.2. IP Address Lease Time
+
+   This option is used in a client request (DHCPDISCOVER or DHCPREQUEST)
+   to allow the client to request a lease time for the IP address.  In a
+   server reply (DHCPOFFER), a DHCP server uses this option to specify
+   the lease time it is willing to offer.
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 25]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The time is in units of seconds, and is specified as a 32-bit
+   unsigned integer.
+
+   The code for this option is 51, and its length is 4.
+
+    Code   Len         Lease Time
+   +-----+-----+-----+-----+-----+-----+
+   |  51 |  4  |  t1 |  t2 |  t3 |  t4 |
+   +-----+-----+-----+-----+-----+-----+
+
+9.3. Option Overload
+
+   This option is used to indicate that the DHCP 'sname' or 'file'
+   fields are being overloaded by using them to carry DHCP options. A
+   DHCP server inserts this option if the returned parameters will
+   exceed the usual space allotted for options.
+
+   If this option is present, the client interprets the specified
+   additional fields after it concludes interpretation of the standard
+   option fields.
+
+   The code for this option is 52, and its length is 1.  Legal values
+   for this option are:
+
+           Value   Meaning
+           -----   --------
+             1     the 'file' field is used to hold options
+             2     the 'sname' field is used to hold options
+             3     both fields are used to hold options
+
+    Code   Len  Value
+   +-----+-----+-----+
+   |  52 |  1  |1/2/3|
+   +-----+-----+-----+
+
+9.4 TFTP server name
+
+   This option is used to identify a TFTP server when the 'sname' field
+   in the DHCP header has been used for DHCP options.
+
+   The code for this option is 66, and its minimum length is 1.
+
+       Code  Len   TFTP server
+      +-----+-----+-----+-----+-----+---
+      | 66  |  n  |  c1 |  c2 |  c3 | ...
+      +-----+-----+-----+-----+-----+---
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 26]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+9.5 Bootfile name
+
+   This option is used to identify a bootfile when the 'file' field in
+   the DHCP header has been used for DHCP options.
+
+   The code for this option is 67, and its minimum length is 1.
+
+       Code  Len   Bootfile name
+      +-----+-----+-----+-----+-----+---
+      | 67  |  n  |  c1 |  c2 |  c3 | ...
+      +-----+-----+-----+-----+-----+---
+
+9.6. DHCP Message Type
+
+   This option is used to convey the type of the DHCP message.  The code
+   for this option is 53, and its length is 1.  Legal values for this
+   option are:
+
+           Value   Message Type
+           -----   ------------
+             1     DHCPDISCOVER
+             2     DHCPOFFER
+             3     DHCPREQUEST
+             4     DHCPDECLINE
+             5     DHCPACK
+             6     DHCPNAK
+             7     DHCPRELEASE
+             8     DHCPINFORM
+
+    Code   Len  Type
+   +-----+-----+-----+
+   |  53 |  1  | 1-9 |
+   +-----+-----+-----+
+
+9.7. Server Identifier
+
+   This option is used in DHCPOFFER and DHCPREQUEST messages, and may
+   optionally be included in the DHCPACK and DHCPNAK messages.  DHCP
+   servers include this option in the DHCPOFFER in order to allow the
+   client to distinguish between lease offers.  DHCP clients use the
+   contents of the 'server identifier' field as the destination address
+   for any DHCP messages unicast to the DHCP server.  DHCP clients also
+   indicate which of several lease offers is being accepted by including
+   this option in a DHCPREQUEST message.
+
+   The identifier is the IP address of the selected server.
+
+   The code for this option is 54, and its length is 4.
+
+
+
+Alexander & Droms           Standards Track                    [Page 27]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+    Code   Len            Address
+   +-----+-----+-----+-----+-----+-----+
+   |  54 |  4  |  a1 |  a2 |  a3 |  a4 |
+   +-----+-----+-----+-----+-----+-----+
+
+9.8. Parameter Request List
+
+   This option is used by a DHCP client to request values for specified
+   configuration parameters.  The list of requested parameters is
+   specified as n octets, where each octet is a valid DHCP option code
+   as defined in this document.
+
+   The client MAY list the options in order of preference.  The DHCP
+   server is not required to return the options in the requested order,
+   but MUST try to insert the requested options in the order requested
+   by the client.
+
+   The code for this option is 55.  Its minimum length is 1.
+
+    Code   Len   Option Codes
+   +-----+-----+-----+-----+---
+   |  55 |  n  |  c1 |  c2 | ...
+   +-----+-----+-----+-----+---
+
+9.9. Message
+
+   This option is used by a DHCP server to provide an error message to a
+   DHCP client in a DHCPNAK message in the event of a failure. A client
+   may use this option in a DHCPDECLINE message to indicate the why the
+   client declined the offered parameters.  The message consists of n
+   octets of NVT ASCII text, which the client may display on an
+   available output device.
+
+   The code for this option is 56 and its minimum length is 1.
+
+    Code   Len     Text
+   +-----+-----+-----+-----+---
+   |  56 |  n  |  c1 |  c2 | ...
+   +-----+-----+-----+-----+---
+
+9.10. Maximum DHCP Message Size
+
+   This option specifies the maximum length DHCP message that it is
+   willing to accept.  The length is specified as an unsigned 16-bit
+   integer.  A client may use the maximum DHCP message size option in
+   DHCPDISCOVER or DHCPREQUEST messages, but should not use the option
+   in DHCPDECLINE messages.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 28]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The code for this option is 57, and its length is 2.  The minimum
+   legal value is 576 octets.
+
+    Code   Len     Length
+   +-----+-----+-----+-----+
+   |  57 |  2  |  l1 |  l2 |
+   +-----+-----+-----+-----+
+
+9.11. Renewal (T1) Time Value
+
+   This option specifies the time interval from address assignment until
+   the client transitions to the RENEWING state.
+
+   The value is in units of seconds, and is specified as a 32-bit
+   unsigned integer.
+
+   The code for this option is 58, and its length is 4.
+
+    Code   Len         T1 Interval
+   +-----+-----+-----+-----+-----+-----+
+   |  58 |  4  |  t1 |  t2 |  t3 |  t4 |
+   +-----+-----+-----+-----+-----+-----+
+
+9.12. Rebinding (T2) Time Value
+
+   This option specifies the time interval from address assignment until
+   the client transitions to the REBINDING state.
+
+   The value is in units of seconds, and is specified as a 32-bit
+   unsigned integer.
+
+   The code for this option is 59, and its length is 4.
+
+    Code   Len         T2 Interval
+   +-----+-----+-----+-----+-----+-----+
+   |  59 |  4  |  t1 |  t2 |  t3 |  t4 |
+   +-----+-----+-----+-----+-----+-----+
+
+9.13. Vendor class identifier
+
+   This option is used by DHCP clients to optionally identify the vendor
+   type and configuration of a DHCP client.  The information is a string
+   of n octets, interpreted by servers.  Vendors may choose to define
+   specific vendor class identifiers to convey particular configuration
+   or other identification information about a client.  For example, the
+   identifier may encode the client's hardware configuration.  Servers
+   not equipped to interpret the class-specific information sent by a
+   client MUST ignore it (although it may be reported). Servers that
+
+
+
+Alexander & Droms           Standards Track                    [Page 29]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   respond SHOULD only use option 43 to return the vendor-specific
+   information to the client.
+
+   The code for this option is 60, and its minimum length is 1.
+
+   Code   Len   Vendor class Identifier
+   +-----+-----+-----+-----+---
+   |  60 |  n  |  i1 |  i2 | ...
+   +-----+-----+-----+-----+---
+
+9.14. Client-identifier
+
+   This option is used by DHCP clients to specify their unique
+   identifier.  DHCP servers use this value to index their database of
+   address bindings.  This value is expected to be unique for all
+   clients in an administrative domain.
+
+   Identifiers SHOULD be treated as opaque objects by DHCP servers.
+
+   The client identifier MAY consist of type-value pairs similar to the
+   'htype'/'chaddr' fields defined in [3]. For instance, it MAY consist
+   of a hardware type and hardware address. In this case the type field
+   SHOULD be one of the ARP hardware types defined in STD2 [22].  A
+   hardware type of 0 (zero) should be used when the value field
+   contains an identifier other than a hardware address (e.g. a fully
+   qualified domain name).
+
+   For correct identification of clients, each client's client-
+   identifier MUST be unique among the client-identifiers used on the
+   subnet to which the client is attached.  Vendors and system
+   administrators are responsible for choosing client-identifiers that
+   meet this requirement for uniqueness.
+
+   The code for this option is 61, and its minimum length is 2.
+
+   Code   Len   Type  Client-Identifier
+   +-----+-----+-----+-----+-----+---
+   |  61 |  n  |  t1 |  i1 |  i2 | ...
+   +-----+-----+-----+-----+-----+---
+
+
+
+
+
+
+
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 30]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+10. Defining new extensions
+
+   The author of a new DHCP option will follow these steps to obtain
+   acceptance of the option as a part of the DHCP Internet Standard:
+
+   1. The author devises the new option.
+   2. The author requests a number for the new option from IANA by
+      contacting:
+      Internet Assigned Numbers Authority (IANA)
+      USC/Information Sciences Institute
+      4676 Admiralty Way
+      Marina del Rey, California  90292-6695
+
+      or by email as: iana@iana.org
+
+   3. The author documents the new option, using the newly obtained
+      option number, as an Internet Draft.
+   4. The author submits the Internet Draft for review through the IETF
+      standards process as defined in "Internet Official Protocol
+      Standards" (STD 1).  The new option will be submitted for eventual
+      acceptance as an Internet Standard.
+   5. The new option progresses through the IETF standards process; the
+      new option will be reviewed by the Dynamic Host Configuration
+      Working Group (if that group still exists), or as an Internet
+      Draft not submitted by an IETF working group.
+   6. If the new option fails to gain acceptance as an Internet
+      Standard, the assigned option number will be returned to IANA for
+      reassignment.
+
+      This procedure for defining new extensions will ensure that:
+
+      * allocation of new option numbers is coordinated from a single
+        authority,
+      * new options are reviewed for technical correctness and
+        appropriateness, and
+      * documentation for new options is complete and published.
+
+11. Acknowledgements
+
+   The author thanks the many (and too numerous to mention!) members of
+   the DHC WG for their tireless and ongoing efforts in the development
+   of DHCP and this document.
+
+   The efforts of J Allard, Mike Carney, Dave Lapp, Fred Lien and John
+   Mendonca in organizing DHCP interoperability testing sessions are
+   gratefully acknowledged.
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 31]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   The development of this document was supported in part by grants from
+   the Corporation for National Research Initiatives (CNRI), Bucknell
+   University and Sun Microsystems.
+
+12. References
+
+   [1] Droms, R., "Dynamic Host Configuration Protocol", RFC 2131,
+       Bucknell University, March 1997.
+
+   [2] Reynolds, J., "BOOTP Vendor Information Extensions", RFC 1497,
+       USC/Information Sciences Institute, August 1993.
+
+   [3] Croft, W., and J. Gilmore, "Bootstrap Protocol", RFC 951,
+       Stanford University and Sun Microsystems, September 1985.
+
+   [4] Braden, R., Editor, "Requirements for Internet Hosts -
+       Communication Layers", STD 3, RFC 1122, USC/Information Sciences
+       Institute, October 1989.
+
+   [5] Mogul, J., and J. Postel, "Internet Standard Subnetting
+       Procedure", STD 5, RFC 950, USC/Information Sciences Institute,
+       August 1985.
+
+   [6] Postel, J., and K. Harrenstien, "Time Protocol", STD 26, RFC
+       868, USC/Information Sciences Institute, SRI, May 1983.
+
+   [7] Postel, J., "Name Server", IEN 116, USC/Information Sciences
+       Institute, August 1979.
+
+   [8] Mockapetris, P., "Domain Names - Implementation and
+       Specification", STD 13, RFC 1035, USC/Information Sciences
+       Institute, November 1987.
+
+   [9] Postel, J., "Quote of the Day Protocol", STD 23, RFC 865,
+       USC/Information Sciences Institute, May 1983.
+
+   [10] McLaughlin, L., "Line Printer Daemon Protocol", RFC 1179, The
+        Wollongong Group, August 1990.
+
+   [11] Accetta, M., "Resource Location Protocol", RFC 887, CMU,
+        December 1983.
+
+   [12] Mogul, J. and S. Deering, "Path MTU Discovery", RFC 1191,
+        DECWRL,  Stanford University, November 1990.
+
+   [13] Deering, S., "ICMP Router Discovery Messages", RFC 1256,
+        Xerox PARC, September 1991.
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 32]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+   [14] Leffler, S. and M. Karels, "Trailer Encapsulations", RFC 893,
+        U. C. Berkeley, April 1984.
+
+   [15] Hornig, C., "Standard for the Transmission of IP Datagrams over
+        Ethernet Networks", RFC 894, Symbolics, April 1984.
+
+   [16] Postel, J. and J. Reynolds, "Standard for the Transmission of
+        IP Datagrams Over IEEE 802 Networks", RFC 1042,  USC/Information
+        Sciences Institute, February 1988.
+
+   [17] Sun Microsystems, "System and Network Administration", March
+        1990.
+
+   [18] Mills, D., "Internet Time Synchronization: The Network Time
+        Protocol", RFC 1305, UDEL, March 1992.
+
+   [19] NetBIOS Working Group, "Protocol Standard for a NetBIOS Service
+        on a TCP/UDP transport: Concepts and Methods", STD 19, RFC 1001,
+        March 1987.
+
+   [20] NetBIOS Working Group, "Protocol Standard for a NetBIOS Service
+        on a TCP/UDP transport: Detailed Specifications", STD 19, RFC
+        1002, March 1987.
+
+   [21] Scheifler, R., "FYI On the X Window System", FYI 6, RFC 1198,
+        MIT Laboratory for Computer Science, January 1991.
+
+   [22] Reynolds, J., and J. Postel, "Assigned Numbers", STD 2, RFC 1700,
+        USC/Information Sciences Institute, July 1992.
+
+13. Security Considerations
+
+   Security issues are not discussed in this memo.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 33]
+
+RFC 2132        DHCP Options and BOOTP Vendor Extensions      March 1997
+
+
+14. Authors' Addresses
+
+   Steve Alexander
+   Silicon Graphics, Inc.
+   2011 N. Shoreline Boulevard
+   Mailstop 510
+   Mountain View, CA 94043-1389
+
+   Phone: (415) 933-6172
+   EMail: sca@engr.sgi.com
+
+
+   Ralph Droms
+   Bucknell University
+   Lewisburg, PA 17837
+
+   Phone: (717) 524-1145
+   EMail: droms@bucknell.edu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Alexander & Droms           Standards Track                    [Page 34]
+

commit 703d0fbd2847af1b54313554e38c7a00fca64cf3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 10:20:03 2008 +0100

    Don't start DHCP again after handshake

diff --git a/plugins/wifi.c b/plugins/wifi.c
index f72cdb8e..f70f0b63 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -228,7 +228,7 @@ static void state_change(struct connman_element *device,
 	if (element == NULL)
 		goto reconnect;
 
-	if (state == STATE_COMPLETED) {
+	if (state == STATE_COMPLETED && data->connected == FALSE) {
 		struct connman_element *dhcp;
 
 		data->connected = TRUE;

commit a9933b375fdf3a07a07d260b68200f0c2fda9331
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 13:11:23 2008 +0100

    Add really simple client application

diff --git a/.gitignore b/.gitignore
index f4b0834b..40db3806 100644
--- a/.gitignore
+++ b/.gitignore
@@ -29,6 +29,7 @@ src/connman.ver
 src/connman.service
 scripts/connman
 scripts/dhclient-script
+client/cm
 doc/*.bak
 doc/*.stamp
 doc/connman.*
diff --git a/client/Makefile.am b/client/Makefile.am
index 02742923..e198c8f8 100644
--- a/client/Makefile.am
+++ b/client/Makefile.am
@@ -1,2 +1,10 @@
 
+noinst_PROGRAMS = cm
+
+cm_SOURCES = main.c
+
+cm_LDADD = @DBUS_LIBS@
+
+AM_CFLAGS = @DBUS_CFLAGS@
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/client/main.c b/client/main.c
new file mode 100644
index 00000000..cb28257c
--- /dev/null
+++ b/client/main.c
@@ -0,0 +1,129 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dbus/dbus.h>
+
+#define CONNMAN_SERVICE			"org.moblin.connman"
+
+#define CONNMAN_MANAGER_INTERFACE	CONNMAN_SERVICE ".Manager"
+#define CONNMAN_MANAGER_PATH		"/"
+
+static const char *extract_state(DBusMessage *message)
+{
+	DBusMessageIter array, dict;
+
+	dbus_message_iter_init(message, &array);
+	dbus_message_iter_recurse(&array, &dict);
+
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		//dbus_message_iter_get_basic(&value, &val);
+
+		if (strcmp(key, "State") == 0) {
+			const char *val;
+			dbus_message_iter_get_basic(&value, &val);
+			return val;
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+
+	return NULL;
+}
+
+static int cmd_status(DBusConnection *connection)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+	const char *state;
+
+	message = dbus_message_new_method_call(CONNMAN_SERVICE,
+						CONNMAN_MANAGER_PATH,
+						CONNMAN_MANAGER_INTERFACE,
+							"GetProperties");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			fprintf(stderr, "%s\n", error.message);
+			dbus_error_free(&error);
+		} else
+			fprintf(stderr, "Failed to get properties\n");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_message_unref(message);
+
+	dbus_error_init(&error);
+
+	state = extract_state(reply);
+
+	dbus_message_unref(reply);
+
+	if (state == NULL)
+		return -EINVAL;
+
+	printf("System is %s\n", state);
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	DBusConnection *conn;
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+	if (!conn) {
+		fprintf(stderr, "Can't get on system bus\n");
+		exit(1);
+	}
+
+	cmd_status(conn);
+
+	dbus_connection_unref(conn);
+
+	return 0;
+}

commit ee6687c3d473d45ecb77bd221f4b4dcb7172117a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 13:18:53 2008 +0100

    Make the client application optional

diff --git a/bootstrap-configure b/bootstrap-configure
index 0714169e..5a7e4dc1 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -16,4 +16,4 @@ fi
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
 		--sysconfdir=/etc \
-		--disable-fake $*
+		--enable-client $*
diff --git a/client/Makefile.am b/client/Makefile.am
index e198c8f8..4dc16084 100644
--- a/client/Makefile.am
+++ b/client/Makefile.am
@@ -1,9 +1,11 @@
 
+if CLIENT
 noinst_PROGRAMS = cm
 
 cm_SOURCES = main.c
 
 cm_LDADD = @DBUS_LIBS@
+endif
 
 AM_CFLAGS = @DBUS_CFLAGS@
 
diff --git a/configure.ac b/configure.ac
index fea11302..15acdbcb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -86,6 +86,10 @@ AC_SUBST(POLKIT_CFLAGS)
 AC_SUBST(POLKIT_LIBS)
 AM_CONDITIONAL(POLKIT, test "${polkit_found}" = "yes")
 
+AC_ARG_ENABLE(client, AC_HELP_STRING([--enable-client],
+		[enable command line client]), [enable_client=${enableval}])
+AM_CONDITIONAL(CLIENT, test "${enable_client}" = "yes")
+
 AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
 			[enable fake plugin]), [enable_fake=${enableval}])
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")

commit 72cf57e982f6da1e1bfe3147de4ca1c7d7dc8b89
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 22 14:42:03 2008 +0100

    Add command to list device objects

diff --git a/client/main.c b/client/main.c
index cb28257c..bb1c39f4 100644
--- a/client/main.c
+++ b/client/main.c
@@ -35,6 +35,37 @@
 #define CONNMAN_MANAGER_INTERFACE	CONNMAN_SERVICE ".Manager"
 #define CONNMAN_MANAGER_PATH		"/"
 
+static DBusMessage *get_properties(DBusConnection *connection)
+{
+	DBusMessage *message, *reply;
+	DBusError error;
+
+	message = dbus_message_new_method_call(CONNMAN_SERVICE,
+						CONNMAN_MANAGER_PATH,
+						CONNMAN_MANAGER_INTERFACE,
+							"GetProperties");
+	if (message == NULL)
+		return NULL;
+
+	dbus_error_init(&error);
+
+	reply = dbus_connection_send_with_reply_and_block(connection,
+							message, -1, &error);
+	if (reply == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			fprintf(stderr, "%s\n", error.message);
+			dbus_error_free(&error);
+		} else
+			fprintf(stderr, "Failed to get properties\n");
+		dbus_message_unref(message);
+		return NULL;
+	}
+
+	dbus_message_unref(message);
+
+	return reply;
+}
+
 static const char *extract_state(DBusMessage *message)
 {
 	DBusMessageIter array, dict;
@@ -68,40 +99,66 @@ static const char *extract_state(DBusMessage *message)
 	return NULL;
 }
 
-static int cmd_status(DBusConnection *connection)
+static void print_objects(DBusMessageIter *array)
 {
-	DBusMessage *message, *reply;
-	DBusError error;
-	const char *state;
+	DBusMessageIter value;
 
-	message = dbus_message_new_method_call(CONNMAN_SERVICE,
-						CONNMAN_MANAGER_PATH,
-						CONNMAN_MANAGER_INTERFACE,
-							"GetProperties");
-	if (message == NULL)
-		return -ENOMEM;
+	if (dbus_message_iter_get_arg_type(array) != DBUS_TYPE_ARRAY)
+		return;
 
-	dbus_error_init(&error);
+	dbus_message_iter_recurse(array, &value);
 
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			fprintf(stderr, "%s\n", error.message);
-			dbus_error_free(&error);
-		} else
-			fprintf(stderr, "Failed to get properties\n");
-		dbus_message_unref(message);
-		return -EIO;
+	while (dbus_message_iter_get_arg_type(&value) == DBUS_TYPE_OBJECT_PATH) {
+		const char *path;
+
+		dbus_message_iter_get_basic(&value, &path);
+
+		printf("%s\n", path);
+
+		dbus_message_iter_next(&value);
 	}
+}
 
-	dbus_message_unref(message);
+static void extract_devices(DBusMessage *message)
+{
+	DBusMessageIter array, dict;
 
-	dbus_error_init(&error);
+	dbus_message_iter_init(message, &array);
+	dbus_message_iter_recurse(&array, &dict);
 
-	state = extract_state(reply);
+	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key;
+
+		dbus_message_iter_recurse(&dict, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
 
-	dbus_message_unref(reply);
+		dbus_message_iter_next(&entry);
+
+		dbus_message_iter_recurse(&entry, &value);
+
+		//type = dbus_message_iter_get_arg_type(&value);
+		//dbus_message_iter_get_basic(&value, &val);
+
+		if (strcmp(key, "Devices") == 0) {
+			print_objects(&value);
+			return;
+		}
+
+		dbus_message_iter_next(&dict);
+	}
+}
+
+static int cmd_status(DBusConnection *connection)
+{
+	DBusMessage *message;
+	const char *state;
+
+	message = get_properties(connection);
+
+	state = extract_state(message);
+
+	dbus_message_unref(message);
 
 	if (state == NULL)
 		return -EINVAL;
@@ -111,17 +168,52 @@ static int cmd_status(DBusConnection *connection)
 	return 0;
 }
 
+static int cmd_devices(DBusConnection *connection)
+{
+	DBusMessage *message;
+
+	message = get_properties(connection);
+
+	extract_devices(message);
+
+	dbus_message_unref(message);
+
+	return 0;
+}
+
+static void usage(const char *program)
+{
+	printf("ConnMan utility ver %s\n\n", VERSION);
+
+	printf("Usage:\n"
+		"\t%s <command>\n\n", program);
+
+	printf("Commands:\n"
+		"\thelp\n"
+		"\tdev\n"
+		"\n");
+}
+
 int main(int argc, char *argv[])
 {
 	DBusConnection *conn;
 
+	if (argc > 1 && strcmp(argv[1], "help") == 0) {
+		usage(argv[0]);
+		exit(0);
+	}
+
 	conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
 	if (!conn) {
 		fprintf(stderr, "Can't get on system bus\n");
 		exit(1);
 	}
 
-	cmd_status(conn);
+	if (argc > 1) {
+		if (strcmp(argv[1], "dev") == 0)
+			cmd_devices(conn);
+	} else
+		cmd_status(conn);
 
 	dbus_connection_unref(conn);
 

commit 6019cedabb291c6b34dd78a4e89f3f9632c6dd91
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 23 03:31:21 2008 +0100

    Fix issue with signed/unsigned comparison

diff --git a/gdbus/object.c b/gdbus/object.c
index 4375ec5e..432a8a0c 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -59,7 +59,8 @@ static void print_arguments(GString *gstr, const char *sig,
 
 	for (i = 0; sig[i]; i++) {
 		char type[32];
-		int len, struct_level, dict_level;
+		int struct_level, dict_level;
+		unsigned int len;
 		gboolean complete;
 
 		complete = FALSE;

commit 9f806bc18d3ef523c069636ecc28d68137f59786
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 23 03:34:00 2008 +0100

    Use global connman.h header file

diff --git a/src/dbus.c b/src/dbus.c
index 6960a40f..f985e950 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -23,7 +23,7 @@
 #include <config.h>
 #endif
 
-#include <connman/dbus.h>
+#include "connman.h"
 
 void connman_dbus_property_append_variant(DBusMessageIter *iter,
 					const char *key, int type, void *val)

commit e524dd47092369054fed1990ffb317f8b0b59a86
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 23 03:37:10 2008 +0100

    Use an unsigned iterator variable

diff --git a/plugins/wifi.c b/plugins/wifi.c
index f70f0b63..9a92ad51 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -304,7 +304,7 @@ static void scan_result(struct connman_element *device,
 	struct wifi_data *data = connman_element_get_data(device);
 	struct connman_element *element;
 	gchar *temp;
-	int i;
+	unsigned int i;
 
 	DBG("network %p identifier %s", network, network->identifier);
 

commit da9561f7d0b8eee43a26321dcf50527615d9655d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 23 06:06:09 2008 +0100

    Enable verbose compiler warnings in maintainer mode

diff --git a/acinclude.m4 b/acinclude.m4
index 9c51ddfc..84086fde 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -10,6 +10,21 @@ AC_DEFUN([AC_PROG_CC_PIE], [
 	])
 ])
 
+AC_DEFUN([COMPILER_FLAGS], [
+	if (test "${CFLAGS}" = ""); then
+		CFLAGS="-Wall -O2 -D_FORTIFY_SOURCE=2"
+	fi
+	if (test "$USE_MAINTAINER_MODE" = "yes"); then
+		CFLAGS+=" -Werror -Wextra"
+		CFLAGS+=" -Wno-unused-parameter"
+		CFLAGS+=" -Wno-missing-field-initializers"
+		CFLAGS+=" -Wdeclaration-after-statement"
+		CFLAGS+=" -Wmissing-declarations"
+		CFLAGS+=" -Wredundant-decls"
+		CFLAGS+=" -Wcast-align"
+	fi
+])
+
 AC_DEFUN([GTK_DOC_CHECK],
 [
   AC_BEFORE([AC_PROG_LIBTOOL],[$0])dnl setup libtool first
diff --git a/configure.ac b/configure.ac
index 15acdbcb..42789a75 100644
--- a/configure.ac
+++ b/configure.ac
@@ -8,9 +8,7 @@ AM_MAINTAINER_MODE
 
 AC_PREFIX_DEFAULT(/usr/local)
 
-if (test "${CFLAGS}" = ""); then
-	CFLAGS="-Wall -O2 -D_FORTIFY_SOURCE=2"
-fi
+COMPILER_FLAGS
 
 AC_LANG_C
 
@@ -32,7 +30,7 @@ AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
 				test "${ac_cv_prog_cc_g}" = "yes"); then
-		CFLAGS="$CFLAGS -g -O0 -Werror"
+		CFLAGS="$CFLAGS -g -O0"
 	fi
 ])
 

commit 32432074e42578a5acd4e47be993b81915d70581
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 00:25:36 2008 +0100

    Print signal strength as integer and not character

diff --git a/test/list-connections b/test/list-connections
index 806490db..a656e964 100755
--- a/test/list-connections
+++ b/test/list-connections
@@ -18,6 +18,10 @@ for path in properties["Connections"]:
 	print "[ %s ]" % (path)
 
 	for key in properties.keys():
-		print "    %s = %s" % (key, properties[key])
+		if key == "Strength":
+			val = int(properties[key])
+		else:
+			val = str(properties[key])
+		print "    %s = %s" % (key, val)
 
 	print

commit c6bc71abc37951b523e8f5917737bee6f5ca1f9c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 07:16:37 2008 +0100

    Check if path is valid before unregistering it

diff --git a/gdbus/object.c b/gdbus/object.c
index 432a8a0c..a41617d5 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -494,6 +494,9 @@ gboolean g_dbus_unregister_interface(DBusConnection *connection,
 	struct generic_data *data = NULL;
 	struct interface_data *iface;
 
+	if (!path)
+		return FALSE;
+
 	if (dbus_connection_get_object_path_data(connection, path,
 						(void *) &data) == FALSE)
 		return FALSE;

commit b02bc47fd3c6e55a529f11f7209b56d34ce4ce33
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 09:20:30 2008 +0100

    Postpone initial driver probing after all plugins are loaded

diff --git a/src/connman.h b/src/connman.h
index 70fcac1d..3c2f699e 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -83,6 +83,7 @@ void __connman_driver_rescan(struct connman_driver *driver);
 #include <connman/element.h>
 
 int __connman_element_init(DBusConnection *conn, const char *device);
+void __connman_element_start(void);
 void __connman_element_cleanup(void);
 
 void __connman_element_list(struct connman_element *element,
diff --git a/src/element.c b/src/element.c
index 0352646b..ea4bea4c 100644
--- a/src/element.c
+++ b/src/element.c
@@ -38,6 +38,8 @@ static GNode *element_root = NULL;
 static GSList *driver_list = NULL;
 static gchar *device_filter = NULL;
 
+static gboolean started = FALSE;
+
 static struct {
 	enum connman_property_id id;
 	int type;
@@ -1053,6 +1055,9 @@ int connman_driver_register(struct connman_driver *driver)
 	driver_list = g_slist_insert_sorted(driver_list, driver,
 							compare_priority);
 
+	if (started == FALSE)
+		return 0;
+
 	if (element_root != NULL)
 		g_node_traverse(element_root, G_PRE_ORDER,
 				G_TRAVERSE_ALL, -1, probe_driver, driver);
@@ -1894,11 +1899,35 @@ static void set_signal_strength(struct connman_element *connection)
 	}
 }
 
+static void probe_element(struct connman_element *element)
+{
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	for (list = driver_list; list; list = list->next) {
+		struct connman_driver *driver = list->data;
+
+		if (match_driver(element, driver) == FALSE)
+			continue;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		if (driver->probe(element) == 0) {
+			__connman_element_lock(element);
+			element->driver = driver;
+			__connman_element_unlock(element);
+
+			enable_element(element);
+			break;
+		}
+	}
+}
+
 static void register_element(gpointer data, gpointer user_data)
 {
 	struct connman_element *element = data;
 	const gchar *basepath;
-	GSList *list;
 	GNode *node;
 
 	__connman_element_lock(element);
@@ -1968,23 +1997,10 @@ static void register_element(gpointer data, gpointer user_data)
 
 	__connman_element_store(element);
 
-	for (list = driver_list; list; list = list->next) {
-		struct connman_driver *driver = list->data;
-
-		if (match_driver(element, driver) == FALSE)
-			continue;
-
-		DBG("driver %p name %s", driver, driver->name);
-
-		if (driver->probe(element) == 0) {
-			__connman_element_lock(element);
-			element->driver = driver;
-			__connman_element_unlock(element);
+	if (started == FALSE)
+		return;
 
-			enable_element(element);
-			break;
-		}
-	}
+	probe_element(element);
 }
 
 /**
@@ -2206,6 +2222,33 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 	return 0;
 }
 
+static gboolean probe_node(GNode *node, gpointer data)
+{
+	struct connman_element *element = node->data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return FALSE;
+
+	if (element->driver)
+		return FALSE;
+
+	probe_element(element);
+
+	return FALSE;
+}
+
+void __connman_element_start(void)
+{
+	DBG("");
+
+	g_node_traverse(element_root, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+							probe_node, NULL);
+
+	started = TRUE;
+}
+
 static gboolean free_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
diff --git a/src/main.c b/src/main.c
index 638ad0bc..357decb5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -166,6 +166,8 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_init();
 
+	__connman_element_start();
+
 	g_free(option_device);
 
 	memset(&sa, 0, sizeof(sa));

commit 6e099bc9ea968ac8b7d0328ca4a347f64250dfe5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 10:39:28 2008 +0100

    Add D-Bus interface features for device driver

diff --git a/include/device.h b/include/device.h
index 31531481..e59eb3e6 100644
--- a/include/device.h
+++ b/include/device.h
@@ -67,6 +67,7 @@ struct connman_device {
 	unsigned long capabilities;
 	enum connman_device_policy policy;
 	enum connman_device_state state;
+	gboolean powered;
 
 	struct connman_device_driver *driver;
 	void *driver_data;
@@ -74,8 +75,8 @@ struct connman_device {
 	GSList *networks;
 };
 
-extern int connman_device_set_enabled(struct connman_device *device,
-							gboolean enabled);
+extern int connman_device_set_powered(struct connman_device *device,
+							gboolean powered);
 
 struct connman_device_driver {
 	const char *name;
diff --git a/src/device.c b/src/device.c
index b70b95f8..5c95d686 100644
--- a/src/device.c
+++ b/src/device.c
@@ -24,11 +24,194 @@
 #endif
 
 #include <errno.h>
+#include <gdbus.h>
 
 #include "connman.h"
 
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_device *device = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	connman_dbus_dict_append_variant(&dict, "Powered",
+					DBUS_TYPE_BOOLEAN, &device->powered);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_element *element = data;
+	DBusMessageIter iter, value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	__connman_element_store(element);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *create_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBG("conn %p", conn);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	return __connman_error_invalid_arguments(msg);
+}
+
+static DBusMessage *remove_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBG("conn %p", conn);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	return __connman_error_invalid_arguments(msg);
+}
+
+static DBusMessage *propose_scan(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBG("conn %p", conn);
+
+	return __connman_error_failed(msg);
+}
+
+static GDBusMethodTable device_methods[] = {
+	{ "GetProperties", "",      "a{sv}", get_properties },
+	{ "SetProperty",   "sv",    "",      set_property   },
+	{ "CreateNetwork", "a{sv}", "o",     create_network },
+	{ "RemoveNetwork", "o",     "",      remove_network },
+	{ "ProposeScan",   "",      "",      propose_scan   },
+	{ },
+};
+
+static GDBusSignalTable device_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
+static DBusConnection *connection;
+
+static int register_interface(struct connman_element *element)
+{
+	struct connman_device *device = connman_element_get_data(element);
+
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_DEVICE_INTERFACE);
+
+	if (g_dbus_register_interface(connection, element->path,
+					CONNMAN_DEVICE_INTERFACE,
+					device_methods, device_signals,
+					NULL, device, NULL) == FALSE) {
+		connman_error("Failed to register %s device", element->path);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void unregister_interface(struct connman_element *element)
+{
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_DEVICE_INTERFACE);
+}
+
 static GSList *driver_list = NULL;
 
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_device_driver *driver1 = a;
+	const struct connman_device_driver *driver2 = b;
+
+	return driver2->priority - driver1->priority;
+}
+
+/**
+ * connman_device_driver_register:
+ * @driver: device driver definition
+ *
+ * Register a new device driver
+ *
+ * Returns: %0 on success
+ */
+int connman_device_driver_register(struct connman_device_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	driver_list = g_slist_insert_sorted(driver_list, driver,
+							compare_priority);
+
+	//__connman_driver_rescan(&device_driver);
+
+	return 0;
+}
+
+/**
+ * connman_device_driver_unregister:
+ * @driver: device driver definition
+ *
+ * Remove a previously registered device driver
+ */
+void connman_device_driver_unregister(struct connman_device_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	driver_list = g_slist_remove(driver_list, driver);
+}
+
+/**
+ * connman_device_set_powered:
+ * @device: device structure
+ *
+ * Change power state of device
+ */
+int connman_device_set_powered(struct connman_device *device,
+							gboolean powered)
+{
+	DBG("driver %p powered %d", device, powered);
+
+	if (device->powered == powered)
+		return -EALREADY;
+
+	device->powered = powered;
+
+	return 0;
+}
+
 static gboolean match_driver(struct connman_device *device,
 					struct connman_device_driver *driver)
 {
@@ -43,6 +226,7 @@ static int device_probe(struct connman_element *element)
 {
 	struct connman_device *device;
 	GSList *list;
+	int err;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -55,6 +239,14 @@ static int device_probe(struct connman_element *element)
 
 	device->element = element;
 
+	connman_element_set_data(element, device);
+
+	err = register_interface(element);
+	if (err < 0) {
+		g_free(device);
+		return err;
+	}
+
 	for (list = driver_list; list; list = list->next) {
 		struct connman_device_driver *driver = list->data;
 
@@ -65,14 +257,11 @@ static int device_probe(struct connman_element *element)
 
 		if (driver->probe(device) == 0) {
 			device->driver = driver;
-			connman_element_set_data(element, device);
-			return 0;
+			break;
 		}
 	}
 
-	g_free(device);
-
-	return -ENODEV;
+	return 0;
 }
 
 static void device_remove(struct connman_element *element)
@@ -81,6 +270,8 @@ static void device_remove(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	unregister_interface(element);
+
 	if (device->driver && device->driver->remove)
 		device->driver->remove(device);
 
@@ -101,6 +292,8 @@ int __connman_device_init(void)
 {
 	DBG("");
 
+	connection = connman_dbus_get_connection();
+
 	return connman_driver_register(&device_driver);
 }
 
@@ -109,45 +302,6 @@ void __connman_device_cleanup(void)
 	DBG("");
 
 	connman_driver_unregister(&device_driver);
-}
-
-static gint compare_priority(gconstpointer a, gconstpointer b)
-{
-	const struct connman_device_driver *driver1 = a;
-	const struct connman_device_driver *driver2 = b;
-
-	return driver2->priority - driver1->priority;
-}
 
-/**
- * connman_device_driver_register:
- * @driver: device driver definition
- *
- * Register a new device driver
- *
- * Returns: %0 on success
- */
-int connman_device_driver_register(struct connman_device_driver *driver)
-{
-	DBG("driver %p name %s", driver, driver->name);
-
-	driver_list = g_slist_insert_sorted(driver_list, driver,
-							compare_priority);
-
-	//__connman_driver_rescan(&device_driver);
-
-	return 0;
-}
-
-/**
- * connman_device_driver_unregister:
- * @driver: device driver definition
- *
- * Remove a previously registered device driver
- */
-void connman_device_driver_unregister(struct connman_device_driver *driver)
-{
-	DBG("driver %p name %s", driver, driver->name);
-
-	driver_list = g_slist_remove(driver_list, driver);
+	dbus_connection_unref(connection);
 }

commit 180502c98a76dff1ac48b4de5203fff4b6644418
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 10:47:05 2008 +0100

    Add functions for handling device driver data

diff --git a/include/device.h b/include/device.h
index e59eb3e6..1645a085 100644
--- a/include/device.h
+++ b/include/device.h
@@ -78,6 +78,17 @@ struct connman_device {
 extern int connman_device_set_powered(struct connman_device *device,
 							gboolean powered);
 
+static inline void *connman_device_get_data(struct connman_device *device)
+{
+	return device->driver_data;
+}
+
+static inline void connman_device_set_data(struct connman_device *device,
+								void *data)
+{
+	device->driver_data = data;
+}
+
 struct connman_device_driver {
 	const char *name;
 	enum connman_device_type type;

commit 7a3e397e2cc0c275f81eec419fa144ad258b4b87
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 11:42:18 2008 +0100

    Add support for device power functions

diff --git a/include/device.h b/include/device.h
index 1645a085..4985f6e8 100644
--- a/include/device.h
+++ b/include/device.h
@@ -95,6 +95,8 @@ struct connman_device_driver {
 	int priority;
 	int (*probe) (struct connman_device *device);
 	void (*remove) (struct connman_device *device);
+	int (*enable) (struct connman_device *device);
+	int (*disable) (struct connman_device *device);
 	int (*scan) (struct connman_device *device);
 };
 
diff --git a/src/device.c b/src/device.c
index 5c95d686..d39f18c8 100644
--- a/src/device.c
+++ b/src/device.c
@@ -28,6 +28,31 @@
 
 #include "connman.h"
 
+static int set_powered(struct connman_device *device, gboolean powered)
+{
+	struct connman_device_driver *driver = device->driver;
+	int err;
+
+	DBG("device %p powered %d", device, powered);
+
+	if (!driver)
+		return -EINVAL;
+
+	if (powered == TRUE) {
+		if (driver->enable)
+			err = driver->enable(device);
+		else
+			err = -EINVAL;
+	} else {
+		if (driver->disable)
+			err = driver->disable(device);
+		else
+			err = -EINVAL;
+	}
+
+	return err;
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -59,7 +84,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
-	struct connman_element *element = data;
+	struct connman_device *device = data;
 	DBusMessageIter iter, value;
 	const char *name;
 
@@ -75,7 +100,21 @@ static DBusMessage *set_property(DBusConnection *conn,
 	if (__connman_security_check_privileges(msg) < 0)
 		return __connman_error_permission_denied(msg);
 
-	__connman_element_store(element);
+	if (g_str_equal(name, "Powered") == TRUE) {
+		gboolean powered;
+		int err;
+
+		dbus_message_iter_get_basic(&value, &powered);
+
+		if (device->powered == powered)
+			return __connman_error_invalid_arguments(msg);
+
+		err = set_powered(device, powered);
+		if (err < 0 && err != -EINPROGRESS)
+			return __connman_error_failed(msg);
+	}
+
+	__connman_element_store(device->element);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }

commit 37b70174dc7f7e8e048a95bca7ecd9e102d14038
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 11:56:08 2008 +0100

    Add support for changing device power state

diff --git a/src/device.c b/src/device.c
index d39f18c8..23fd1b15 100644
--- a/src/device.c
+++ b/src/device.c
@@ -241,6 +241,10 @@ void connman_device_driver_unregister(struct connman_device_driver *driver)
 int connman_device_set_powered(struct connman_device *device,
 							gboolean powered)
 {
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Powered";
+
 	DBG("driver %p powered %d", device, powered);
 
 	if (device->powered == powered)
@@ -248,6 +252,22 @@ int connman_device_set_powered(struct connman_device *device,
 
 	device->powered = powered;
 
+	signal = dbus_message_new_signal(device->element->path,
+				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return 0;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN, &powered);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+
 	return 0;
 }
 

commit f972a47e85625348030e28998ae9923180b0255e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 11:57:25 2008 +0100

    Convert Ethernet plugin into a device driver

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 9cfa76bd..0b70462f 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -32,7 +32,7 @@
 #include <linux/rtnetlink.h>
 
 #include <connman/plugin.h>
-#include <connman/driver.h>
+#include <connman/device.h>
 #include <connman/rtnl.h>
 #include <connman/log.h>
 
@@ -43,6 +43,43 @@ struct ethernet_data {
 
 static GSList *ethernet_list = NULL;
 
+static void update_power(struct connman_device *device, unsigned flags)
+{
+	if (flags & IFF_UP) {
+		DBG("power on");
+
+		connman_device_set_powered(device, TRUE);
+	} else {
+		DBG("power off");
+
+		connman_device_set_powered(device, FALSE);
+	}
+}
+
+static void update_carrier(struct connman_device *device, unsigned flags)
+{
+	struct connman_element *netdev;
+
+	if (flags & IFF_LOWER_UP) {
+		DBG("carrier on");
+
+		netdev = connman_element_create(NULL);
+		if (netdev != NULL) {
+			netdev->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
+			netdev->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
+			netdev->index   = device->element->index;
+
+			if (connman_element_register(netdev,
+							device->element) < 0)
+				connman_element_unref(netdev);
+		}
+	} else {
+		DBG("carrier off");
+
+		connman_element_unregister_children(device->element);
+	}
+}
+
 static void ethernet_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
@@ -51,39 +88,23 @@ static void ethernet_newlink(unsigned short type, int index,
 	DBG("index %d flags %ld change %ld", index, flags, change);
 
 	for (list = ethernet_list; list; list = list->next) {
-		struct connman_element *element = list->data;
-		struct connman_element *netdev;
+		struct connman_device *device = list->data;
 		struct ethernet_data *ethernet;
 
-		ethernet = connman_element_get_data(element);
+		ethernet = connman_device_get_data(device);
 		if (ethernet == NULL)
 			continue;
 
 		if (ethernet->index != index)
 			continue;
 
-		if ((ethernet->flags & IFF_LOWER_UP) == (flags & IFF_LOWER_UP))
-			continue;
-
-		ethernet->flags = flags;
-
-		if (ethernet->flags & IFF_LOWER_UP) {
-			DBG("carrier on");
-
-			netdev = connman_element_create(NULL);
-			if (netdev != NULL) {
-				netdev->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
-				netdev->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
-				netdev->index   = element->index;
+		if ((ethernet->flags & IFF_UP) != (flags & IFF_UP))
+			update_power(device, flags);
 
-				if (connman_element_register(netdev, element) < 0)
-					connman_element_unref(netdev);
-			}
-		} else {
-			DBG("carrier off");
+		if ((ethernet->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP))
+			update_carrier(device, flags);
 
-			connman_element_unregister_children(element);
-		}
+		ethernet->flags = flags;
 	}
 }
 
@@ -178,66 +199,61 @@ done:
 	return err;
 }
 
-static int ethernet_probe(struct connman_element *element)
+static int ethernet_probe(struct connman_device *device)
 {
 	struct ethernet_data *ethernet;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
 	ethernet = g_try_new0(struct ethernet_data, 1);
 	if (ethernet == NULL)
 		return -ENOMEM;
 
-	ethernet_list = g_slist_append(ethernet_list, element);
+	ethernet_list = g_slist_append(ethernet_list, device);
 
-	connman_element_set_data(element, ethernet);
+	connman_device_set_data(device, ethernet);
 
-	ethernet->index = element->index;
+	ethernet->index = device->element->index;
 
 	connman_rtnl_send_getlink();
 
 	return 0;
 }
 
-static void ethernet_remove(struct connman_element *element)
+static void ethernet_remove(struct connman_device *device)
 {
-	struct ethernet_data *ethernet = connman_element_get_data(element);
+	struct ethernet_data *ethernet = connman_device_get_data(device);
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
-	connman_element_set_data(element, NULL);
+	connman_device_set_data(device, NULL);
 
-	ethernet_list = g_slist_remove(ethernet_list, element);
+	ethernet_list = g_slist_remove(ethernet_list, device);
 
 	g_free(ethernet);
 }
 
-static int ethernet_enable(struct connman_element *element)
+static int ethernet_enable(struct connman_device *device)
 {
-	struct ethernet_data *ethernet = connman_element_get_data(element);
-
-	DBG("element %p name %s", element, element->name);
+	struct ethernet_data *ethernet = connman_device_get_data(device);
 
-	iface_up(ethernet);
+	DBG("device %p", device);
 
-	return 0;
+	return iface_up(ethernet);
 }
 
-static int ethernet_disable(struct connman_element *element)
+static int ethernet_disable(struct connman_device *device)
 {
-	struct ethernet_data *ethernet = connman_element_get_data(element);
-
-	DBG("element %p name %s", element, element->name);
+	struct ethernet_data *ethernet = connman_device_get_data(device);
 
-	iface_down(ethernet);
+	DBG("device %p", device);
 
-	return 0;
+	return iface_down(ethernet);
 }
 
-static struct connman_driver ethernet_driver = {
+static struct connman_device_driver ethernet_driver = {
 	.name		= "ethernet",
-	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_ETHERNET,
+	.type		= CONNMAN_DEVICE_TYPE_ETHERNET,
 	.probe		= ethernet_probe,
 	.remove		= ethernet_remove,
 	.enable		= ethernet_enable,
@@ -252,7 +268,7 @@ static int ethernet_init(void)
 	if (err < 0)
 		return err;
 
-	err = connman_driver_register(&ethernet_driver);
+	err = connman_device_driver_register(&ethernet_driver);
 	if (err < 0) {
 		connman_rtnl_unregister(&ethernet_rtnl);
 		return err;
@@ -263,7 +279,7 @@ static int ethernet_init(void)
 
 static void ethernet_exit(void)
 {
-	connman_driver_unregister(&ethernet_driver);
+	connman_device_driver_unregister(&ethernet_driver);
 
 	connman_rtnl_unregister(&ethernet_rtnl);
 }

commit 27da31329144c6a2473db49798d96f53f25a5fc5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 12:20:06 2008 +0100

    Add support for scanning property of devices

diff --git a/include/device.h b/include/device.h
index 4985f6e8..48363957 100644
--- a/include/device.h
+++ b/include/device.h
@@ -68,6 +68,7 @@ struct connman_device {
 	enum connman_device_policy policy;
 	enum connman_device_state state;
 	gboolean powered;
+	gboolean scanning;
 
 	struct connman_device_driver *driver;
 	void *driver_data;
@@ -77,6 +78,8 @@ struct connman_device {
 
 extern int connman_device_set_powered(struct connman_device *device,
 							gboolean powered);
+extern int connman_device_set_scanning(struct connman_device *device,
+							gboolean scanning);
 
 static inline void *connman_device_get_data(struct connman_device *device)
 {
diff --git a/src/device.c b/src/device.c
index 23fd1b15..2c07a172 100644
--- a/src/device.c
+++ b/src/device.c
@@ -76,6 +76,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &device->powered);
 
+	if (device->driver && device->driver->scan)
+		connman_dbus_dict_append_variant(&dict, "Scanning",
+					DBUS_TYPE_BOOLEAN, &device->scanning);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -271,6 +275,51 @@ int connman_device_set_powered(struct connman_device *device,
 	return 0;
 }
 
+/**
+ * connman_device_set_scanning:
+ * @device: device structure
+ *
+ * Change scanning state of device
+ */
+int connman_device_set_scanning(struct connman_device *device,
+							gboolean scanning)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Scanning";
+
+	DBG("driver %p scanning %d", device, scanning);
+
+	if (!device->driver)
+		return -EINVAL;
+
+	if (!device->driver->scan)
+		return -EINVAL;
+
+	if (device->scanning == scanning)
+		return -EALREADY;
+
+	device->scanning = scanning;
+
+	signal = dbus_message_new_signal(device->element->path,
+				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return 0;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN, &scanning);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+
+	return 0;
+}
+
 static gboolean match_driver(struct connman_device *device,
 					struct connman_device_driver *driver)
 {

commit 20bbe80f88aa0047bf6849ad7e5482417bce8129
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 12:20:40 2008 +0100

    Convert Bluetooth plugin into a device driver

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 9bb29d46..68c0a6f4 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -28,6 +28,7 @@
 #include <gdbus.h>
 
 #include <connman/plugin.h>
+#include <connman/device.h>
 #include <connman/driver.h>
 #include <connman/dbus.h>
 #include <connman/log.h>
@@ -50,11 +51,11 @@ struct adapter_data {
 	DBusConnection *connection;
 };
 
-static int bluetooth_probe(struct connman_element *adapter)
+static int bluetooth_probe(struct connman_device *adapter)
 {
 	struct adapter_data *data;
 
-	DBG("adapter %p name %s", adapter, adapter->name);
+	DBG("adapter %p", adapter);
 
 	data = g_try_new0(struct adapter_data, 1);
 	if (data == NULL)
@@ -66,18 +67,18 @@ static int bluetooth_probe(struct connman_element *adapter)
 		return -EIO;
 	}
 
-	connman_element_set_data(adapter, data);
+	connman_device_set_data(adapter, data);
 
 	return 0;
 }
 
-static void bluetooth_remove(struct connman_element *adapter)
+static void bluetooth_remove(struct connman_device *adapter)
 {
-	struct adapter_data *data = connman_element_get_data(adapter);
+	struct adapter_data *data = connman_device_get_data(adapter);
 
-	DBG("adapter %p name %s", adapter, adapter->name);
+	DBG("adapter %p", adapter);
 
-	connman_element_set_data(adapter, NULL);
+	connman_device_set_data(adapter, NULL);
 
 	dbus_connection_unref(data->connection);
 
@@ -127,32 +128,41 @@ static int change_powered(DBusConnection *connection, const char *path,
 	return -EINPROGRESS;
 }
 
-static int bluetooth_enable(struct connman_element *adapter)
+static int bluetooth_enable(struct connman_device *adapter)
 {
-	struct adapter_data *data = connman_element_get_data(adapter);
+	struct adapter_data *data = connman_device_get_data(adapter);
 
-	DBG("adapter %p name %s", adapter, adapter->name);
+	DBG("adapter %p", adapter);
 
-	return change_powered(data->connection, adapter->devpath, TRUE);
+	return change_powered(data->connection,
+					adapter->element->devpath, TRUE);
 }
 
-static int bluetooth_disable(struct connman_element *adapter)
+static int bluetooth_disable(struct connman_device *adapter)
 {
-	struct adapter_data *data = connman_element_get_data(adapter);
+	struct adapter_data *data = connman_device_get_data(adapter);
 
-	DBG("adapter %p name %s", adapter, adapter->name);
+	DBG("adapter %p", adapter);
+
+	return change_powered(data->connection,
+					adapter->element->devpath, FALSE);
+}
+
+static int bluetooth_scan(struct connman_device *adapter)
+{
+	DBG("adapter %p", adapter);
 
-	return change_powered(data->connection, adapter->devpath, FALSE);
+	return -EIO;
 }
 
-static struct connman_driver bluetooth_driver = {
+static struct connman_device_driver bluetooth_driver = {
 	.name		= "bluetooth",
-	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
+	.type		= CONNMAN_DEVICE_TYPE_BLUETOOTH,
 	.probe		= bluetooth_probe,
 	.remove		= bluetooth_remove,
 	.enable		= bluetooth_enable,
 	.disable	= bluetooth_disable,
+	.scan		= bluetooth_scan,
 };
 
 static GSList *device_list = NULL;
@@ -218,15 +228,19 @@ static void property_changed(DBusConnection *connection, DBusMessage *message)
 	dbus_message_iter_recurse(&iter, &value);
 
 	if (g_str_equal(key, "Powered") == TRUE) {
+		struct connman_device *dev = connman_element_get_data(device);
 		gboolean val;
 
 		dbus_message_iter_get_basic(&value, &val);
-		connman_element_set_enabled(device, val);
+		if (dev != NULL)
+			connman_device_set_powered(dev, val);
 	} else if (g_str_equal(key, "Discovering") == TRUE) {
+		struct connman_device *dev = connman_element_get_data(device);
 		gboolean val;
 
 		dbus_message_iter_get_basic(&value, &val);
-		connman_element_set_scanning(device, val);
+		if (dev != NULL)
+			connman_device_set_scanning(dev, val);
 	}
 }
 
@@ -257,6 +271,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 	dbus_message_iter_recurse(&array, &dict);
 	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
+		struct connman_device *dev = connman_element_get_data(device);
 		DBusMessageIter entry, value;
 		const char *key;
 
@@ -270,12 +285,14 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 			gboolean val;
 
 			dbus_message_iter_get_basic(&value, &val);
-			connman_element_set_enabled(device, val);
+			if (dev != NULL)
+				connman_device_set_powered(dev, val);
 		} else if (g_str_equal(key, "Discovering") == TRUE) {
 			gboolean val;
 
 			dbus_message_iter_get_basic(&value, &val);
-			connman_element_set_scanning(device, val);
+			if (dev != NULL)
+				connman_device_set_scanning(dev, val);
 		} else if (g_str_equal(key, "Devices") == TRUE) {
 			check_devices(device, &value);
 		}
@@ -471,14 +488,14 @@ static int bluetooth_init(void)
 							NULL, NULL) == FALSE)
 		goto unref;
 
-	err = connman_driver_register(&bluetooth_driver);
+	err = connman_device_driver_register(&bluetooth_driver);
 	if (err < 0)
 		goto remove;
 
 	watch = g_dbus_add_service_watch(connection, BLUEZ_SERVICE,
 			bluetooth_connect, bluetooth_disconnect, NULL, NULL);
 	if (watch == 0) {
-		connman_driver_unregister(&bluetooth_driver);
+		connman_device_driver_unregister(&bluetooth_driver);
 		err = -EIO;
 		goto remove;
 	}
@@ -513,7 +530,7 @@ static void bluetooth_exit(void)
 
 	bluetooth_disconnect(connection, NULL);
 
-	connman_driver_unregister(&bluetooth_driver);
+	connman_device_driver_unregister(&bluetooth_driver);
 
 	dbus_connection_remove_filter(connection, bluetooth_signal, NULL);
 

commit 04c45750075f5558499fd5e4079fc6a88bf8beb5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 12:29:12 2008 +0100

    Install device header file by default

diff --git a/include/Makefile.am b/include/Makefile.am
index 8c6617e6..40f07ebe 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -2,9 +2,8 @@
 includedir = @includedir@/connman
 
 include_HEADERS = log.h plugin.h security.h resolver.h driver.h \
-			element.h property.h network.h ipv4.h rtnl.h dbus.h
-
-noinst_HEADERS = device.h
+				element.h property.h rtnl.h dbus.h \
+						device.h network.h ipv4.h
 
 MAINTAINERCLEANFILES = Makefile.in
 

commit 84562870a1fa54e4ef768a52433044194efb2359
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 12:37:58 2008 +0100

    Add skeleton for generic network driver

diff --git a/src/connman.h b/src/connman.h
index 3c2f699e..175a6cc1 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -114,6 +114,11 @@ static inline void __connman_element_unlock(struct connman_element *element)
 int __connman_device_init(void);
 void __connman_device_cleanup(void);
 
+#include <connman/network.h>
+
+int __connman_network_init(void);
+void __connman_network_cleanup(void);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/element.c b/src/element.c
index ea4bea4c..145d6fa2 100644
--- a/src/element.c
+++ b/src/element.c
@@ -2218,6 +2218,7 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 	element_root = g_node_new(element);
 
 	__connman_device_init();
+	__connman_network_init();
 
 	return 0;
 }
@@ -2285,6 +2286,7 @@ void __connman_element_cleanup(void)
 {
 	DBG("");
 
+	__connman_network_cleanup();
 	__connman_device_cleanup();
 
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
diff --git a/src/network.c b/src/network.c
index 715e8c49..6a27d035 100644
--- a/src/network.c
+++ b/src/network.c
@@ -24,3 +24,34 @@
 #endif
 
 #include "connman.h"
+
+static int network_probe(struct connman_element *element)
+{
+	return 0;
+}
+
+static void network_remove(struct connman_element *element)
+{
+}
+
+static struct connman_driver network_driver = {
+	.name		= "network",
+	.type		= CONNMAN_ELEMENT_TYPE_NETWORK,
+	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
+	.probe		= network_probe,
+	.remove		= network_remove,
+};
+
+int __connman_network_init(void)
+{
+	DBG("");
+
+	return connman_driver_register(&network_driver);
+}
+
+void __connman_network_cleanup(void)
+{
+	DBG("");
+
+	connman_driver_unregister(&network_driver);
+}

commit 720b8692c453b14829b85b0c5647e7babe7a4752
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 24 13:34:45 2008 +0100

    Add Type property to generic device driver

diff --git a/include/device.h b/include/device.h
index 48363957..ba7fe1e0 100644
--- a/include/device.h
+++ b/include/device.h
@@ -42,6 +42,7 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_WIMAX     = CONNMAN_ELEMENT_SUBTYPE_WIMAX,
 	CONNMAN_DEVICE_TYPE_MODEM     = CONNMAN_ELEMENT_SUBTYPE_MODEM,
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
+	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
 };
 
 enum connman_device_capabilities {
@@ -64,6 +65,7 @@ struct connman_device_driver;
 
 struct connman_device {
 	struct connman_element *element;
+	enum connman_device_type type;
 	unsigned long capabilities;
 	enum connman_device_policy policy;
 	enum connman_device_state state;
diff --git a/src/device.c b/src/device.c
index 2c07a172..de686183 100644
--- a/src/device.c
+++ b/src/device.c
@@ -28,6 +28,24 @@
 
 #include "connman.h"
 
+static const char *type2string(enum connman_device_type type)
+{
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		return "ethernet";
+	case CONNMAN_DEVICE_TYPE_WIFI:
+		return "wifi";
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+		return "wimax";
+	case CONNMAN_DEVICE_TYPE_MODEM:
+		return "modem";
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+		return "bluetooth";
+	default:
+		return NULL;
+	}
+}
+
 static int set_powered(struct connman_device *device, gboolean powered)
 {
 	struct connman_device_driver *driver = device->driver;
@@ -59,6 +77,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	struct connman_device *device = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -73,6 +92,11 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = type2string(device->type);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
+
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &device->powered);
 
@@ -346,6 +370,7 @@ static int device_probe(struct connman_element *element)
 		return -ENOMEM;
 
 	device->element = element;
+	device->type = element->subtype;
 
 	connman_element_set_data(element, device);
 

commit 990d345674c6dc7d8f07655d1d2e1ea61d173853
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 03:36:25 2008 +0100

    Add destruct callback to element structure

diff --git a/include/element.h b/include/element.h
index 083533da..e8199b76 100644
--- a/include/element.h
+++ b/include/element.h
@@ -103,6 +103,13 @@ struct connman_element {
 	struct connman_driver *driver;
 	void *driver_data;
 
+	void (*destruct) (struct connman_element *element);
+
+	union {
+		void *private;
+		struct connman_device *device;
+	};
+
 	GSList *properties;
 
 	struct {
diff --git a/src/element.c b/src/element.c
index 145d6fa2..fba5fb88 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1192,6 +1192,8 @@ void connman_element_unref(struct connman_element *element)
 				g_atomic_int_get(&element->refcount) - 1);
 
 	if (g_atomic_int_dec_and_test(&element->refcount) == TRUE) {
+		if (element->destruct)
+			element->destruct(element);
 		free_properties(element);
 		g_free(element->ipv4.address);
 		g_free(element->ipv4.netmask);

commit 008e44508b96501af3ce9b997f5a9dbbe9431525
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 04:22:55 2008 +0100

    Fix reference docs inclusion

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 542c4e18..8d51f3b6 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -102,8 +102,7 @@
     <xi:include href="xml/log.xml" />
     <xi:include href="xml/plugin.xml" />
     <xi:include href="xml/security.xml" />
-    <xi:include href="xml/element.xml" />
-    <xi:include href="xml/driver.xml" />
+    <xi:include href="xml/resolver.xml" />
   </reference>
 
   <appendix id="license">

commit 48551ded08069a2d39d701bc78bab33a52ea96e0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 04:24:08 2008 +0100

    Add advanced device specific API

diff --git a/include/device.h b/include/device.h
index ba7fe1e0..8b860967 100644
--- a/include/device.h
+++ b/include/device.h
@@ -30,8 +30,8 @@ extern "C" {
 
 /**
  * SECTION:device
- * @title: Device driver premitives
- * @short_description: Functions for registering device drivers
+ * @title: Device premitives
+ * @short_description: Functions for handling devices
  */
 
 enum connman_device_type {
@@ -45,10 +45,6 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
 };
 
-enum connman_device_capabilities {
-	CONNMAN_DEVICE_CAPABILITY_SCANNING = (1 << 0),
-};
-
 enum connman_device_policy {
 	CONNMAN_DEVICE_POLICY_UNKNOWN = 0,
 	CONNMAN_DEVICE_POLICY_IGNORE  = 1,
@@ -56,43 +52,32 @@ enum connman_device_policy {
 	CONNMAN_DEVICE_POLICY_OFF     = 3,
 };
 
-enum connman_device_state {
-	CONNMAN_DEVICE_STATE_UNKNOWN = 0,
-	CONNMAN_DEVICE_STATE_OFF     = 1,
-};
+struct connman_device;
 
-struct connman_device_driver;
-
-struct connman_device {
-	struct connman_element *element;
-	enum connman_device_type type;
-	unsigned long capabilities;
-	enum connman_device_policy policy;
-	enum connman_device_state state;
-	gboolean powered;
-	gboolean scanning;
+extern struct connman_device *connman_device_create(const char *node,
+						enum connman_device_type type);
+extern struct connman_device *connman_device_ref(struct connman_device *device);
+extern void connman_device_unref(struct connman_device *device);
 
-	struct connman_device_driver *driver;
-	void *driver_data;
-
-	GSList *networks;
-};
+extern void connman_device_set_index(struct connman_device *device,
+								int index);
+extern int connman_device_get_index(struct connman_device *device);
+extern void connman_device_set_interface(struct connman_device *device,
+							const char *interface);
+extern const char *connman_device_get_interface(struct connman_device *device);
 
 extern int connman_device_set_powered(struct connman_device *device,
 							gboolean powered);
+extern int connman_device_set_carrier(struct connman_device *device,
+							gboolean carrier);
 extern int connman_device_set_scanning(struct connman_device *device,
 							gboolean scanning);
 
-static inline void *connman_device_get_data(struct connman_device *device)
-{
-	return device->driver_data;
-}
+extern int connman_device_register(struct connman_device *device);
+extern void connman_device_unregister(struct connman_device *device);
 
-static inline void connman_device_set_data(struct connman_device *device,
-								void *data)
-{
-	device->driver_data = data;
-}
+extern void *connman_device_get_data(struct connman_device *device);
+extern void connman_device_set_data(struct connman_device *device, void *data);
 
 struct connman_device_driver {
 	const char *name;
diff --git a/src/device.c b/src/device.c
index de686183..cd49b293 100644
--- a/src/device.c
+++ b/src/device.c
@@ -28,6 +28,21 @@
 
 #include "connman.h"
 
+struct connman_device {
+	struct connman_element element;
+	enum connman_device_type type;
+	enum connman_device_policy policy;
+	gboolean powered;
+	gboolean carrier;
+	gboolean scanning;
+	char *interface;
+
+	struct connman_device_driver *driver;
+	void *driver_data;
+
+	GSList *networks;
+};
+
 static const char *type2string(enum connman_device_type type)
 {
 	switch (type) {
@@ -46,6 +61,20 @@ static const char *type2string(enum connman_device_type type)
 	}
 }
 
+static const char *policy2string(enum connman_device_policy policy)
+{
+	switch (policy) {
+	case CONNMAN_DEVICE_POLICY_IGNORE:
+		return "ignore";
+	case CONNMAN_DEVICE_POLICY_AUTO:
+		return "auto";
+	case CONNMAN_DEVICE_POLICY_OFF:
+		return "off";
+	default:
+		return NULL;
+	}
+}
+
 static int set_powered(struct connman_device *device, gboolean powered)
 {
 	struct connman_device_driver *driver = device->driver;
@@ -97,6 +126,15 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &str);
 
+	if (device->interface != NULL)
+		connman_dbus_dict_append_variant(&dict, "Interface",
+					DBUS_TYPE_STRING, &device->interface);
+
+	str = policy2string(device->policy);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Policy",
+						DBUS_TYPE_STRING, &str);
+
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &device->powered);
 
@@ -142,7 +180,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 			return __connman_error_failed(msg);
 	}
 
-	__connman_element_store(device->element);
+	__connman_element_store(&device->element);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -195,7 +233,7 @@ static DBusConnection *connection;
 
 static int register_interface(struct connman_element *element)
 {
-	struct connman_device *device = connman_element_get_data(element);
+	struct connman_device *device = element->device;
 
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_DEVICE_INTERFACE);
@@ -260,9 +298,130 @@ void connman_device_driver_unregister(struct connman_device_driver *driver)
 	driver_list = g_slist_remove(driver_list, driver);
 }
 
+static void device_destruct(struct connman_element *element)
+{
+	struct connman_device *device = element->device;
+
+	DBG("element %p name %s", element, element->name);
+
+	g_free(device->interface);
+}
+
+/**
+ * connman_device_create:
+ * @node: device node name (for example an address)
+ * @type: device type
+ *
+ * Allocate a new device of given #type and assign the #node name to it.
+ *
+ * Returns: a newly-allocated #connman_device structure
+ */
+struct connman_device *connman_device_create(const char *node,
+						enum connman_device_type type)
+{
+	struct connman_device *device;
+
+	DBG("node %s type %d", node, type);
+
+	device = g_try_new0(struct connman_device, 1);
+	if (device == NULL)
+		return NULL;
+
+	DBG("device %p", device);
+
+	device->element.name = g_strdup(node);
+	device->element.type = CONNMAN_ELEMENT_TYPE_DEVICE;
+	device->element.index = -1;
+
+	device->element.device = device;
+	device->element.destruct = device_destruct;
+
+	device->type = type;
+	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
+
+	return device;
+}
+
+/**
+ * connman_device_ref:
+ * @device: device structure
+ *
+ * Increase reference counter of device
+ */
+struct connman_device *connman_device_ref(struct connman_device *device)
+{
+	if (connman_element_ref(&device->element) == NULL)
+		return NULL;
+
+	return device;
+}
+
+/**
+ * connman_device_unref:
+ * @device: device structure
+ *
+ * Decrease reference counter of device
+ */
+void connman_device_unref(struct connman_device *device)
+{
+	connman_element_unref(&device->element);
+}
+
+/**
+ * connman_device_set_interface:
+ * @device: device structure
+ * @index: index number
+ *
+ * Set index number of device
+ */
+void connman_device_set_index(struct connman_device *device, int index)
+{
+	device->element.index = index;
+}
+
+/**
+ * connman_device_get_index:
+ * @device: device structure
+ *
+ * Get index number of device
+ */
+int connman_device_get_index(struct connman_device *device)
+{
+	return device->element.index;
+}
+
+/**
+ * connman_device_set_interface:
+ * @device: device structure
+ * @interface: interface name
+ *
+ * Set interface name of device
+ */
+void connman_device_set_interface(struct connman_device *device,
+							const char *interface)
+{
+	g_free(device->element.devname);
+	device->element.devname = g_strdup(interface);
+
+	g_free(device->interface);
+	device->interface = g_strdup(interface);
+}
+
+/**
+ * connman_device_get_interface:
+ * @device: device structure
+ *
+ * Get interface name of device
+ */
+const char *connman_device_get_interface(struct connman_device *device)
+{
+	return device->interface;
+}
+
 /**
  * connman_device_set_powered:
  * @device: device structure
+ * @powered: powered state
  *
  * Change power state of device
  */
@@ -280,7 +439,7 @@ int connman_device_set_powered(struct connman_device *device,
 
 	device->powered = powered;
 
-	signal = dbus_message_new_signal(device->element->path,
+	signal = dbus_message_new_signal(device->element.path,
 				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
 	if (signal == NULL)
 		return 0;
@@ -299,9 +458,52 @@ int connman_device_set_powered(struct connman_device *device,
 	return 0;
 }
 
+/**
+ * connman_device_set_carrier:
+ * @device: device structure
+ * @carrier: carrier state
+ *
+ * Change carrier state of device (only for device without scanning)
+ */
+int connman_device_set_carrier(struct connman_device *device,
+							gboolean carrier)
+{
+	DBG("driver %p carrier %d", device, carrier);
+
+	if (!device->driver)
+		return -EINVAL;
+
+	if (device->driver->scan)
+		return -EINVAL;
+
+	if (device->carrier == carrier)
+		return -EALREADY;
+
+	device->carrier = carrier;
+
+	if (carrier == TRUE) {
+		struct connman_element *element;
+
+		element = connman_element_create(NULL);
+		if (element != NULL) {
+			element->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
+			element->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
+			element->index   = device->element.index;
+
+			if (connman_element_register(element,
+							&device->element) < 0)
+				connman_element_unref(element);
+		}
+	} else
+		connman_element_unregister_children(&device->element);
+
+	return 0;
+}
+
 /**
  * connman_device_set_scanning:
  * @device: device structure
+ * @scanning: scanning state
  *
  * Change scanning state of device
  */
@@ -325,7 +527,7 @@ int connman_device_set_scanning(struct connman_device *device,
 
 	device->scanning = scanning;
 
-	signal = dbus_message_new_signal(device->element->path,
+	signal = dbus_message_new_signal(device->element.path,
 				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
 	if (signal == NULL)
 		return 0;
@@ -344,10 +546,83 @@ int connman_device_set_scanning(struct connman_device *device,
 	return 0;
 }
 
+/**
+ * connman_device_register:
+ * @device: device structure
+ *
+ * Register device with the system
+ */
+int connman_device_register(struct connman_device *device)
+{
+	return connman_element_register(&device->element, NULL);
+}
+
+/**
+ * connman_device_unregister:
+ * @device: device structure
+ *
+ * Unregister device with the system
+ */
+void connman_device_unregister(struct connman_device *device)
+{
+	connman_element_unregister(&device->element);
+}
+
+/**
+ * connman_device_get_data:
+ * @device: device structure
+ *
+ * Get private device data pointer
+ */
+void *connman_device_get_data(struct connman_device *device)
+{
+	return device->driver_data;
+}
+
+/**
+ * connman_device_set_data:
+ * @device: device structure
+ * @data: data pointer
+ *
+ * Set private device data pointer
+ */
+void connman_device_set_data(struct connman_device *device, void *data)
+{
+	device->driver_data = data;
+}
+
+static void device_enable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
+		return;
+
+	if (device->powered == TRUE)
+		return;
+
+	if (device->driver->enable)
+		device->driver->enable(device);
+}
+
+static void device_disable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
+		return;
+
+	if (device->powered == FALSE)
+		return;
+
+	if (device->driver->disable)
+		device->driver->disable(device);
+}
+
 static gboolean match_driver(struct connman_device *device,
 					struct connman_device_driver *driver)
 {
-	if (device->element->subtype == driver->type ||
+	if (device->type == driver->type ||
 			driver->type == CONNMAN_DEVICE_TYPE_UNKNOWN)
 		return TRUE;
 
@@ -356,29 +631,18 @@ static gboolean match_driver(struct connman_device *device,
 
 static int device_probe(struct connman_element *element)
 {
-	struct connman_device *device;
+	struct connman_device *device = element->device;
 	GSList *list;
 	int err;
 
 	DBG("element %p name %s", element, element->name);
 
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_NETWORK)
-		return -ENODEV;
-
-	device = g_try_new0(struct connman_device, 1);
 	if (device == NULL)
-		return -ENOMEM;
-
-	device->element = element;
-	device->type = element->subtype;
-
-	connman_element_set_data(element, device);
+		return -ENODEV;
 
 	err = register_interface(element);
-	if (err < 0) {
-		g_free(device);
+	if (err < 0)
 		return err;
-	}
 
 	for (list = driver_list; list; list = list->next) {
 		struct connman_device_driver *driver = list->data;
@@ -390,6 +654,7 @@ static int device_probe(struct connman_element *element)
 
 		if (driver->probe(device) == 0) {
 			device->driver = driver;
+			device_enable(device);
 			break;
 		}
 	}
@@ -399,18 +664,21 @@ static int device_probe(struct connman_element *element)
 
 static void device_remove(struct connman_element *element)
 {
-	struct connman_device *device = connman_element_get_data(element);
+	struct connman_device *device = element->device;
 
 	DBG("element %p name %s", element, element->name);
 
-	unregister_interface(element);
+	if (device == NULL)
+		return;
 
-	if (device->driver && device->driver->remove)
-		device->driver->remove(device);
+	unregister_interface(element);
 
-	connman_element_set_data(element, NULL);
+	if (device->driver) {
+		device_disable(device);
 
-	g_free(device);
+		if (device->driver->remove)
+			device->driver->remove(device);
+	}
 }
 
 static struct connman_driver device_driver = {

commit 899be488360ad24f079bbb204dc32a47c6aae093
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 04:26:09 2008 +0100

    Create devices instead of raw elements

diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
index e7acc5ff..8ac07158 100644
--- a/plugins/rtnllink.c
+++ b/plugins/rtnllink.c
@@ -33,7 +33,7 @@
 #include <linux/wireless.h>
 
 #include <connman/plugin.h>
-#include <connman/element.h>
+#include <connman/device.h>
 #include <connman/rtnl.h>
 #include <connman/log.h>
 
@@ -41,30 +41,33 @@
 
 static GSList *device_list = NULL;
 
-static void rtnllink_newlink(unsigned short type, int index,
-					unsigned flags, unsigned change)
+static struct connman_device *find_device(int index)
 {
-	enum connman_element_subtype subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
-	struct connman_element *device;
 	GSList *list;
-	gboolean exists = FALSE;
-	gchar *name, *devname;
-
-	DBG("index %d", index);
 
 	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
+		struct connman_device *device = list->data;
 
-		if (device->index == index) {
-			exists = TRUE;
-			break;
-		}
+		if (connman_device_get_index(device) == index)
+			return device;
 	}
 
-	if (exists == TRUE)
+	return NULL;
+}
+
+static void rtnllink_newlink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+	struct connman_device *device;
+	gchar *name, *devname;
+
+	DBG("index %d", index);
+
+	device = find_device(index);
+	if (device != NULL)
 		return;
 
-	name = inet_index2ident(index, "dev_");
 	devname = inet_index2name(index);
 
 	if (type == ARPHRD_ETHER) {
@@ -83,35 +86,42 @@ static void rtnllink_newlink(unsigned short type, int index,
 
 		sk = socket(PF_INET, SOCK_DGRAM, 0);
 
-		if (g_str_has_prefix(name, "bnep") == TRUE)
-			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+		if (g_str_has_prefix(devname, "bnep") == TRUE)
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
-			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
-			subtype = CONNMAN_ELEMENT_SUBTYPE_WIMAX;
+			devtype = CONNMAN_DEVICE_TYPE_WIMAX;
 		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
-			subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else
-			subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
+			devtype = CONNMAN_DEVICE_TYPE_ETHERNET;
 
 		close(sk);
 	}
 
-	if (subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN) {
+	if (devtype == CONNMAN_DEVICE_TYPE_UNKNOWN) {
+		g_free(devname);
+		return;
+	}
+
+	name = inet_index2ident(index, "dev_");
+
+	device = connman_device_create(name, devtype);
+	if (device == NULL) {
+		g_free(devname);
 		g_free(name);
 		return;
 	}
 
-	device = connman_element_create(NULL);
-	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	device->subtype = subtype;
+	connman_device_set_index(device, index);
+	connman_device_set_interface(device, devname);
 
-	device->index = index;
-	device->name = name;
-	device->devname = devname;
+	g_free(devname);
+	g_free(name);
 
-	if (connman_element_register(device, NULL) < 0) {
-		connman_element_unref(device);
+	if (connman_device_register(device) < 0) {
+		connman_device_unref(device);
 		return;
 	}
 
@@ -121,20 +131,18 @@ static void rtnllink_newlink(unsigned short type, int index,
 static void rtnllink_dellink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
-	GSList *list;
+	struct connman_device *device;
 
 	DBG("index %d", index);
 
-	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
-
-		if (device->index == index) {
-			device_list = g_slist_remove(device_list, device);
-			connman_element_unregister(device);
-			connman_element_unref(device);
-			break;
-		}
-	}
+	device = find_device(index);
+	if (device == NULL)
+		return;
+
+	device_list = g_slist_remove(device_list, device);
+
+	connman_device_unregister(device);
+	connman_device_unref(device);
 }
 
 static struct connman_rtnl rtnllink_rtnl = {
@@ -163,10 +171,10 @@ static void rtnllink_exit(void)
 	connman_rtnl_unregister(&rtnllink_rtnl);
 
 	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
+		struct connman_device *device = list->data;
 
-		connman_element_unregister(device);
-		connman_element_unref(device);
+		connman_device_unregister(device);
+		connman_device_unref(device);
 	}
 
 	g_slist_free(device_list);

commit e29b62b9491e0d4a0ad3d47de9a5ce47df93f2b5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 04:27:23 2008 +0100

    Use device helpers to set power and carrier states

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 0b70462f..08cfb4fe 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -43,43 +43,6 @@ struct ethernet_data {
 
 static GSList *ethernet_list = NULL;
 
-static void update_power(struct connman_device *device, unsigned flags)
-{
-	if (flags & IFF_UP) {
-		DBG("power on");
-
-		connman_device_set_powered(device, TRUE);
-	} else {
-		DBG("power off");
-
-		connman_device_set_powered(device, FALSE);
-	}
-}
-
-static void update_carrier(struct connman_device *device, unsigned flags)
-{
-	struct connman_element *netdev;
-
-	if (flags & IFF_LOWER_UP) {
-		DBG("carrier on");
-
-		netdev = connman_element_create(NULL);
-		if (netdev != NULL) {
-			netdev->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
-			netdev->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
-			netdev->index   = device->element->index;
-
-			if (connman_element_register(netdev,
-							device->element) < 0)
-				connman_element_unref(netdev);
-		}
-	} else {
-		DBG("carrier off");
-
-		connman_element_unregister_children(device->element);
-	}
-}
-
 static void ethernet_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
@@ -98,11 +61,25 @@ static void ethernet_newlink(unsigned short type, int index,
 		if (ethernet->index != index)
 			continue;
 
-		if ((ethernet->flags & IFF_UP) != (flags & IFF_UP))
-			update_power(device, flags);
+		if ((ethernet->flags & IFF_UP) != (flags & IFF_UP)) {
+			if (flags & IFF_UP) {
+				DBG("power on");
+				connman_device_set_powered(device, TRUE);
+			} else {
+				DBG("power off");
+				connman_device_set_powered(device, FALSE);
+			}
+		}
 
-		if ((ethernet->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP))
-			update_carrier(device, flags);
+		if ((ethernet->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP)) {
+			if (flags & IFF_LOWER_UP) {
+				DBG("carrier on");
+				connman_device_set_carrier(device, TRUE);
+			} else {
+				DBG("carrier off");
+				connman_device_set_carrier(device, FALSE);
+			}
+		}
 
 		ethernet->flags = flags;
 	}
@@ -213,7 +190,7 @@ static int ethernet_probe(struct connman_device *device)
 
 	connman_device_set_data(device, ethernet);
 
-	ethernet->index = device->element->index;
+	ethernet->index = connman_device_get_index(device);
 
 	connman_rtnl_send_getlink();
 

commit f6cc9bb6d4c1531d05fecee991db3f7c92f66e3b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 18:52:26 2008 +0100

    Add functions for handling path value

diff --git a/include/device.h b/include/device.h
index 8b860967..88ec0fc4 100644
--- a/include/device.h
+++ b/include/device.h
@@ -59,6 +59,9 @@ extern struct connman_device *connman_device_create(const char *node,
 extern struct connman_device *connman_device_ref(struct connman_device *device);
 extern void connman_device_unref(struct connman_device *device);
 
+extern void connman_device_set_path(struct connman_device *device,
+							const char *path);
+extern const char *connman_device_get_path(struct connman_device *device);
 extern void connman_device_set_index(struct connman_device *device,
 								int index);
 extern int connman_device_get_index(struct connman_device *device);
diff --git a/src/device.c b/src/device.c
index cd49b293..2ac98c00 100644
--- a/src/device.c
+++ b/src/device.c
@@ -35,6 +35,7 @@ struct connman_device {
 	gboolean powered;
 	gboolean carrier;
 	gboolean scanning;
+	char *path;
 	char *interface;
 
 	struct connman_device_driver *driver;
@@ -368,7 +369,34 @@ void connman_device_unref(struct connman_device *device)
 }
 
 /**
- * connman_device_set_interface:
+ * connman_device_set_path:
+ * @device: device structure
+ * @path: path name
+ *
+ * Set path name of device
+ */
+void connman_device_set_path(struct connman_device *device, const char *path)
+{
+	g_free(device->element.devpath);
+	device->element.devpath = g_strdup(path);
+
+	g_free(device->path);
+	device->path = g_strdup(path);
+}
+
+/**
+ * connman_device_get_path:
+ * @device: device structure
+ *
+ * Get path name of device
+ */
+const char *connman_device_get_path(struct connman_device *device)
+{
+	return device->path;
+}
+
+/**
+ * connman_device_set_index:
  * @device: device structure
  * @index: index number
  *

commit 2fbe1fce4d2444da9af1b5c9316550c66164732e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 18:55:34 2008 +0100

    Fix broken device driver details of Bluetooth plugin

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 68c0a6f4..20d13916 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -24,12 +24,12 @@
 #endif
 
 #include <errno.h>
+#include <stdlib.h>
 
 #include <gdbus.h>
 
 #include <connman/plugin.h>
 #include <connman/device.h>
-#include <connman/driver.h>
 #include <connman/dbus.h>
 #include <connman/log.h>
 
@@ -131,21 +131,21 @@ static int change_powered(DBusConnection *connection, const char *path,
 static int bluetooth_enable(struct connman_device *adapter)
 {
 	struct adapter_data *data = connman_device_get_data(adapter);
+	const char *path = connman_device_get_path(adapter);
 
 	DBG("adapter %p", adapter);
 
-	return change_powered(data->connection,
-					adapter->element->devpath, TRUE);
+	return change_powered(data->connection, path, TRUE);
 }
 
 static int bluetooth_disable(struct connman_device *adapter)
 {
 	struct adapter_data *data = connman_device_get_data(adapter);
+	const char *path = connman_device_get_path(adapter);
 
 	DBG("adapter %p", adapter);
 
-	return change_powered(data->connection,
-					adapter->element->devpath, FALSE);
+	return change_powered(data->connection, path, FALSE);
 }
 
 static int bluetooth_scan(struct connman_device *adapter)
@@ -165,31 +165,50 @@ static struct connman_device_driver bluetooth_driver = {
 	.scan		= bluetooth_scan,
 };
 
-static GSList *device_list = NULL;
+static GSList *adapter_list = NULL;
 
-static struct connman_element *find_adapter(const char *path)
+static void free_adapters(void)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = adapter_list; list; list = list->next) {
+		struct connman_device *adapter = list->data;
+
+		connman_device_unregister(adapter);
+		connman_device_unref(adapter);
+	}
+
+	g_slist_free(adapter_list);
+	adapter_list = NULL;
+}
+
+static struct connman_device *find_adapter(const char *path)
 {
 	GSList *list;
 
 	DBG("path %s", path);
 
-	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
+	for (list = adapter_list; list; list = list->next) {
+		struct connman_device *adapter = list->data;
+		const char *adapter_path = connman_device_get_path(adapter);
+
+		if (adapter_path == NULL)
+			continue;
 
-		if (g_str_equal(device->devpath, path) == TRUE)
-			return device;
+		if (g_str_equal(adapter_path, path) == TRUE)
+			return adapter;
 	}
 
 	return NULL;
 }
 
-static void check_devices(struct connman_element *adapter,
+static void check_devices(struct connman_device *adapter,
 						DBusMessageIter *array)
 {
 	DBusMessageIter value;
 
-	DBG("adapter %p name %s", adapter, adapter->name);
-
 	if (dbus_message_iter_get_arg_type(array) != DBUS_TYPE_ARRAY)
 		return;
 
@@ -209,14 +228,14 @@ static void check_devices(struct connman_element *adapter,
 static void property_changed(DBusConnection *connection, DBusMessage *message)
 {
 	const char *path = dbus_message_get_path(message);
-	struct connman_element *device;
+	struct connman_device *adapter;
 	DBusMessageIter iter, value;
 	const char *key;
 
 	DBG("path %s", path);
 
-	device = find_adapter(path);
-	if (device == NULL)
+	adapter = find_adapter(path);
+	if (adapter == NULL)
 		return;
 
 	if (dbus_message_iter_init(message, &iter) == FALSE)
@@ -228,19 +247,15 @@ static void property_changed(DBusConnection *connection, DBusMessage *message)
 	dbus_message_iter_recurse(&iter, &value);
 
 	if (g_str_equal(key, "Powered") == TRUE) {
-		struct connman_device *dev = connman_element_get_data(device);
 		gboolean val;
 
 		dbus_message_iter_get_basic(&value, &val);
-		if (dev != NULL)
-			connman_device_set_powered(dev, val);
+		connman_device_set_powered(adapter, val);
 	} else if (g_str_equal(key, "Discovering") == TRUE) {
-		struct connman_device *dev = connman_element_get_data(device);
 		gboolean val;
 
 		dbus_message_iter_get_basic(&value, &val);
-		if (dev != NULL)
-			connman_device_set_scanning(dev, val);
+		connman_device_set_scanning(adapter, val);
 	}
 }
 
@@ -248,19 +263,19 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 {
 	DBusMessage *message = user_data;
 	const char *path = dbus_message_get_path(message);
-	struct connman_element *device;
+	struct connman_device *adapter;
 	DBusMessageIter array, dict;
 	DBusMessage *reply;
 
 	DBG("path %s", path);
 
-	device = find_adapter(path);
+	adapter = find_adapter(path);
 
 	dbus_message_unref(message);
 
 	reply = dbus_pending_call_steal_reply(call);
 
-	if (device == NULL)
+	if (adapter == NULL)
 		goto done;
 
 	if (dbus_message_iter_init(reply, &array) == FALSE)
@@ -271,7 +286,6 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 	dbus_message_iter_recurse(&array, &dict);
 	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
-		struct connman_device *dev = connman_element_get_data(device);
 		DBusMessageIter entry, value;
 		const char *key;
 
@@ -285,16 +299,14 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 			gboolean val;
 
 			dbus_message_iter_get_basic(&value, &val);
-			if (dev != NULL)
-				connman_device_set_powered(dev, val);
+			connman_device_set_powered(adapter, val);
 		} else if (g_str_equal(key, "Discovering") == TRUE) {
 			gboolean val;
 
 			dbus_message_iter_get_basic(&value, &val);
-			if (dev != NULL)
-				connman_device_set_scanning(dev, val);
+			connman_device_set_scanning(adapter, val);
 		} else if (g_str_equal(key, "Devices") == TRUE) {
-			check_devices(device, &value);
+			check_devices(adapter, &value);
 		}
 
 		dbus_message_iter_next(&dict);
@@ -306,30 +318,37 @@ done:
 
 static void add_adapter(DBusConnection *connection, const char *path)
 {
-	struct connman_element *device;
+	const char *node = g_basename(path);
+	struct connman_device *adapter;
 	DBusMessage *message;
 	DBusPendingCall *call;
 
 	DBG("path %s", path);
 
-	device = find_adapter(path);
-	if (device != NULL)
+	adapter = find_adapter(path);
+	if (adapter != NULL)
 		return;
 
-	device = connman_element_create(NULL);
-	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	device->subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
-	device->policy = CONNMAN_ELEMENT_POLICY_IGNORE;
+	adapter = connman_device_create(node, CONNMAN_DEVICE_TYPE_BLUETOOTH);
+
+	connman_device_set_path(adapter, path);
 
-	device->name = g_path_get_basename(path);
-	device->devpath = g_strdup(path);
+	if (g_str_has_prefix(node, "hci") == TRUE) {
+		int index;
+		errno = 0;
+		index = atoi(node + 3);
+		if (errno == 0)
+			connman_device_set_index(adapter, index);
+	}
 
-	if (connman_element_register(device, NULL) < 0) {
-		connman_element_unref(device);
+	connman_device_set_interface(adapter, node);
+
+	if (connman_device_register(adapter) < 0) {
+		connman_device_unref(adapter);
 		return;
 	}
 
-	device_list = g_slist_append(device_list, device);
+	adapter_list = g_slist_append(adapter_list, adapter);
 
 	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
 				BLUEZ_ADAPTER_INTERFACE, GET_PROPERTIES);
@@ -348,18 +367,18 @@ static void add_adapter(DBusConnection *connection, const char *path)
 
 static void remove_adapter(DBusConnection *connection, const char *path)
 {
-	struct connman_element *device;
+	struct connman_device *adapter;
 
 	DBG("path %s", path);
 
-	device = find_adapter(path);
-	if (device == NULL)
+	adapter = find_adapter(path);
+	if (adapter == NULL)
 		return;
 
-	device_list = g_slist_remove(device_list, device);
+	adapter_list = g_slist_remove(adapter_list, adapter);
 
-	connman_element_unregister(device);
-	connman_element_unref(device);
+	connman_device_unregister(adapter);
+	connman_device_unref(adapter);
 }
 
 static void adapters_reply(DBusPendingCall *call, void *user_data)
@@ -423,24 +442,20 @@ static void bluetooth_connect(DBusConnection *connection, void *user_data)
 
 static void bluetooth_disconnect(DBusConnection *connection, void *user_data)
 {
-	GSList *list;
-
 	DBG("connection %p", connection);
 
-	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
-
-		connman_element_unregister(device);
-		connman_element_unref(device);
-	}
-
-	g_slist_free(device_list);
-	device_list = NULL;
+	free_adapters();
 }
 
 static DBusHandlerResult bluetooth_signal(DBusConnection *connection,
 					DBusMessage *message, void *user_data)
 {
+	if (dbus_message_has_interface(message,
+			BLUEZ_MANAGER_INTERFACE) == FALSE &&
+				dbus_message_has_interface(message,
+					BLUEZ_ADAPTER_INTERFACE) == FALSE)
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
 	DBG("connection %p", connection);
 
 	if (dbus_message_is_signal(message, BLUEZ_ADAPTER_INTERFACE,
@@ -528,7 +543,7 @@ static void bluetooth_exit(void)
 
 	g_dbus_remove_watch(connection, watch);
 
-	bluetooth_disconnect(connection, NULL);
+	free_adapters();
 
 	connman_device_driver_unregister(&bluetooth_driver);
 

commit f82ea40ef6d608e695d9041b8176a9a6f7bc85d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 19:05:02 2008 +0100

    Add details about Interface property

diff --git a/doc/device-api.txt b/doc/device-api.txt
index 45c72155..7d1b86fc 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -54,6 +54,13 @@ Properties	string Name [readonly]
 
 			The device type (for example "ethernet", "wifi" etc.)
 
+		string Interface [readonly]
+
+			The device interface (for example "eth0" etc.)
+
+			This value is for pure informational purposes. It
+			is not guaranteed that it is always present.
+
 		string Policy [readwrite]
 
 			Setting of the device power policy. Possible values

commit a78d60bdd0986e79f453fe1cf41a79f8c3a68eb3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 19:05:22 2008 +0100

    Add support for Name property to generic driver

diff --git a/src/device.c b/src/device.c
index 2ac98c00..561cd358 100644
--- a/src/device.c
+++ b/src/device.c
@@ -44,6 +44,22 @@ struct connman_device {
 	GSList *networks;
 };
 
+static const char *type2description(enum connman_device_type type)
+{
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		return "Ethernet";
+	case CONNMAN_DEVICE_TYPE_WIFI:
+		return "Wireless";
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+		return "WiMAX";
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+		return "Bluetooth";
+	default:
+		return NULL;
+	}
+}
+
 static const char *type2string(enum connman_device_type type)
 {
 	switch (type) {
@@ -122,6 +138,15 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = type2description(device->type);
+	if (str != NULL && device->interface != NULL) {
+		char *name = g_strdup_printf("%s (%s)", str, device->interface);
+		if (name != NULL)
+			connman_dbus_dict_append_variant(&dict, "Name",
+						DBUS_TYPE_STRING, &name);
+		g_free(name);
+	}
+
 	str = type2string(device->type);
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "Type",

commit 4cd41ba34edb0575535c564110fcf72aa837693d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 19:09:11 2008 +0100

    Add not supported error and use it

diff --git a/src/connman.h b/src/connman.h
index 175a6cc1..44ff9543 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -33,6 +33,7 @@ void __connman_dbus_cleanup(void);
 DBusMessage *__connman_error_failed(DBusMessage *msg);
 DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
+DBusMessage *__connman_error_not_supported(DBusMessage *msg);
 
 int __connman_selftest(void);
 
diff --git a/src/device.c b/src/device.c
index 561cd358..71e4dc2b 100644
--- a/src/device.c
+++ b/src/device.c
@@ -238,7 +238,7 @@ static DBusMessage *propose_scan(DBusConnection *conn,
 {
 	DBG("conn %p", conn);
 
-	return __connman_error_failed(msg);
+	return __connman_error_not_supported(msg);
 }
 
 static GDBusMethodTable device_methods[] = {
diff --git a/src/error.c b/src/error.c
index 21606cbc..a78c7990 100644
--- a/src/error.c
+++ b/src/error.c
@@ -44,3 +44,9 @@ DBusMessage *__connman_error_permission_denied(DBusMessage *msg)
 	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
 						".PermissionDenied", NULL);
 }
+
+DBusMessage *__connman_error_not_supported(DBusMessage *msg)
+{
+	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
+						".NotSupported", NULL);
+}

commit 67e671bdba08cdd555a32551bcd18f34abeac2ae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 19:29:48 2008 +0100

    Add basic network definitions

diff --git a/include/network.h b/include/network.h
index da7b67f5..c261d330 100644
--- a/include/network.h
+++ b/include/network.h
@@ -26,6 +26,35 @@
 extern "C" {
 #endif
 
+/**
+ * SECTION:network
+ * @title: Network premitives
+ * @short_description: Functions for handling networks
+ */
+
+enum connman_network_mode {
+	CONNMAN_NETWORK_MODE_NONE     = 0,
+	CONNMAN_NETWORK_MODE_SINGLE   = 1,
+	CONNMAN_NETWORK_MODE_MULTIPLE = 2,
+};
+
+enum connman_network_type {
+	CONNMAN_NETWORK_TYPE_UNKNOWN = 0,
+};
+
+struct connman_network;
+
+struct connman_network_driver {
+	const char *name;
+	enum connman_network_type type;
+	int priority;
+	int (*probe) (struct connman_network *network);
+	void (*remove) (struct connman_network *network);
+};
+
+extern int connman_network_driver_register(struct connman_network_driver *driver);
+extern void connman_network_driver_unregister(struct connman_network_driver *driver);
+
 #ifdef __cplusplus
 }
 #endif

commit 08898a3702fd821da3239eb93f8a0af02cff5573
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 19:37:48 2008 +0100

    Add support for different network modes

diff --git a/include/device.h b/include/device.h
index 88ec0fc4..a3d9ad38 100644
--- a/include/device.h
+++ b/include/device.h
@@ -45,6 +45,12 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
 };
 
+enum connman_device_mode {
+	CONNMAN_DEVICE_MODE_NO_NETWORK        = 0,
+	CONNMAN_DEVICE_MODE_SINGLE_NETWORK    = 1,
+	CONNMAN_DEVICE_MODE_MULTIPLE_NETWORKS = 2,
+};
+
 enum connman_device_policy {
 	CONNMAN_DEVICE_POLICY_UNKNOWN = 0,
 	CONNMAN_DEVICE_POLICY_IGNORE  = 1,
@@ -69,6 +75,9 @@ extern void connman_device_set_interface(struct connman_device *device,
 							const char *interface);
 extern const char *connman_device_get_interface(struct connman_device *device);
 
+extern void connman_device_set_mode(struct connman_device *device,
+						enum connman_device_mode mode);
+
 extern int connman_device_set_powered(struct connman_device *device,
 							gboolean powered);
 extern int connman_device_set_carrier(struct connman_device *device,
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 20d13916..e09a8600 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -343,6 +343,8 @@ static void add_adapter(DBusConnection *connection, const char *path)
 
 	connman_device_set_interface(adapter, node);
 
+	connman_device_set_mode(adapter, CONNMAN_DEVICE_MODE_MULTIPLE_NETWORKS);
+
 	if (connman_device_register(adapter) < 0) {
 		connman_device_unref(adapter);
 		return;
diff --git a/src/device.c b/src/device.c
index 71e4dc2b..7bda8c25 100644
--- a/src/device.c
+++ b/src/device.c
@@ -31,6 +31,7 @@
 struct connman_device {
 	struct connman_element element;
 	enum connman_device_type type;
+	enum connman_device_mode mode;
 	enum connman_device_policy policy;
 	gboolean powered;
 	gboolean carrier;
@@ -363,6 +364,7 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.destruct = device_destruct;
 
 	device->type = type;
+	device->mode = CONNMAN_DEVICE_MODE_NO_NETWORK;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
 
 	return device;
@@ -471,6 +473,19 @@ const char *connman_device_get_interface(struct connman_device *device)
 	return device->interface;
 }
 
+/**
+ * connman_device_set_mode:
+ * @device: device structure
+ * @mode: network mode
+ *
+ * Change network mode of device
+ */
+void connman_device_set_mode(struct connman_device *device,
+						enum connman_device_mode mode)
+{
+	device->mode = mode;
+}
+
 /**
  * connman_device_set_powered:
  * @device: device structure
@@ -523,10 +538,7 @@ int connman_device_set_carrier(struct connman_device *device,
 {
 	DBG("driver %p carrier %d", device, carrier);
 
-	if (!device->driver)
-		return -EINVAL;
-
-	if (device->driver->scan)
+	if (device->mode != CONNMAN_DEVICE_MODE_NO_NETWORK)
 		return -EINVAL;
 
 	if (device->carrier == carrier)
@@ -569,10 +581,7 @@ int connman_device_set_scanning(struct connman_device *device,
 
 	DBG("driver %p scanning %d", device, scanning);
 
-	if (!device->driver)
-		return -EINVAL;
-
-	if (!device->driver->scan)
+	if (!device->driver || !device->driver->scan)
 		return -EINVAL;
 
 	if (device->scanning == scanning)

commit 07f1877243d7fb7127a4892478d88dcf9395ed73
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 21:55:54 2008 +0100

    Add functions for network creation

diff --git a/include/network.h b/include/network.h
index c261d330..c025ca5a 100644
--- a/include/network.h
+++ b/include/network.h
@@ -32,18 +32,18 @@ extern "C" {
  * @short_description: Functions for handling networks
  */
 
-enum connman_network_mode {
-	CONNMAN_NETWORK_MODE_NONE     = 0,
-	CONNMAN_NETWORK_MODE_SINGLE   = 1,
-	CONNMAN_NETWORK_MODE_MULTIPLE = 2,
-};
-
 enum connman_network_type {
 	CONNMAN_NETWORK_TYPE_UNKNOWN = 0,
+	CONNMAN_NETWORK_TYPE_WIFI    = 1,
 };
 
 struct connman_network;
 
+extern struct connman_network *connman_network_create(const char *identifier,
+						enum connman_network_type type);
+extern struct connman_network *connman_network_ref(struct connman_network *network);
+extern void connman_network_unref(struct connman_network *network);
+
 struct connman_network_driver {
 	const char *name;
 	enum connman_network_type type;
diff --git a/src/network.c b/src/network.c
index 6a27d035..02067e69 100644
--- a/src/network.c
+++ b/src/network.c
@@ -25,6 +25,79 @@
 
 #include "connman.h"
 
+struct connman_network {
+	struct connman_element element;
+	enum connman_network_type type;
+
+	struct connman_network_driver *driver;
+	void *driver_data;
+};
+
+static void network_destruct(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+/**
+ * connman_network_create:
+ * @identifier: network identifier (for example an unqiue name)
+ *
+ * Allocate a new network and assign the #identifier to it.
+ *
+ * Returns: a newly-allocated #connman_network structure
+ */
+struct connman_network *connman_network_create(const char *identifier,
+						enum connman_network_type type)
+{
+	struct connman_network *network;
+
+	DBG("identifier %s type %d", identifier, type);
+
+	network = g_try_new0(struct connman_network, 1);
+	if (network == NULL)
+		return NULL;
+
+	DBG("network %p", network);
+
+	network->element.refcount = 1;
+
+	network->element.name = g_strdup(identifier);
+	network->element.type = CONNMAN_ELEMENT_TYPE_NETWORK;
+	network->element.index = -1;
+
+	network->element.network = network;
+	network->element.destruct = network_destruct;
+
+	network->type = type;
+
+	return network;
+}
+
+/**
+ * connman_network_ref:
+ * @network: network structure
+ *
+ * Increase reference counter of  network
+ */
+struct connman_network *connman_network_ref(struct connman_network *network)
+{
+	if (connman_element_ref(&network->element) == NULL)
+		return NULL;
+
+	return network;
+}
+
+/**
+ * connman_network_unref:
+ * @network: network structure
+ *
+ * Decrease reference counter of network
+ */
+void connman_network_unref(struct connman_network *network)
+{
+	connman_element_unref(&network->element);
+}
+
 static int network_probe(struct connman_element *element)
 {
 	return 0;

commit 72736b791ef6d2772da9f4e676659449e7b4decf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 21:56:27 2008 +0100

    Add private date pointer for networks

diff --git a/include/element.h b/include/element.h
index e8199b76..afe7b0c2 100644
--- a/include/element.h
+++ b/include/element.h
@@ -108,6 +108,7 @@ struct connman_element {
 	union {
 		void *private;
 		struct connman_device *device;
+		struct connman_network *network;
 	};
 
 	GSList *properties;

commit 1440a12d34f626a3041838af3001a894bc2089c8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Dec 25 21:57:52 2008 +0100

    Initialize the element reference count

diff --git a/src/device.c b/src/device.c
index 7bda8c25..22c6927d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -356,6 +356,8 @@ struct connman_device *connman_device_create(const char *node,
 
 	DBG("device %p", device);
 
+	device->element.refcount = 1;
+
 	device->element.name = g_strdup(node);
 	device->element.type = CONNMAN_ELEMENT_TYPE_DEVICE;
 	device->element.index = -1;

commit aa2e6dc4b4896e1b3a440736e7c27271a1bbd2d0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 07:47:45 2008 +0100

    Add support for identifier and driver data

diff --git a/include/network.h b/include/network.h
index c025ca5a..292dd9f6 100644
--- a/include/network.h
+++ b/include/network.h
@@ -44,6 +44,11 @@ extern struct connman_network *connman_network_create(const char *identifier,
 extern struct connman_network *connman_network_ref(struct connman_network *network);
 extern void connman_network_unref(struct connman_network *network);
 
+extern const char *connman_network_get_identifier(struct connman_network *network);
+
+extern void *connman_network_get_data(struct connman_network *network);
+extern void connman_network_set_data(struct connman_network *network, void *data);
+
 struct connman_network_driver {
 	const char *name;
 	enum connman_network_type type;
diff --git a/src/network.c b/src/network.c
index 02067e69..cfd30120 100644
--- a/src/network.c
+++ b/src/network.c
@@ -28,6 +28,7 @@
 struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
+	char *identifier;
 
 	struct connman_network_driver *driver;
 	void *driver_data;
@@ -35,7 +36,11 @@ struct connman_network {
 
 static void network_destruct(struct connman_element *element)
 {
+	struct connman_network *network = element->network;
+
 	DBG("element %p name %s", element, element->name);
+
+	g_free(network->identifier);
 }
 
 /**
@@ -69,6 +74,7 @@ struct connman_network *connman_network_create(const char *identifier,
 	network->element.destruct = network_destruct;
 
 	network->type = type;
+	network->identifier = g_strdup(identifier);
 
 	return network;
 }
@@ -98,6 +104,40 @@ void connman_network_unref(struct connman_network *network)
 	connman_element_unref(&network->element);
 }
 
+/**
+ * connman_network_get_identifier:
+ * @network: network structure
+ *
+ * Get identifier of network
+ */
+const char *connman_network_get_identifier(struct connman_network *network)
+{
+	return network->identifier;
+}
+
+/**
+ * connman_network_get_data:
+ * @network: network structure
+ *
+ * Get private network data pointer
+ */
+void *connman_network_get_data(struct connman_network *network)
+{
+	return network->driver_data;
+}
+
+/**
+ * connman_network_set_data:
+ * @network: network structure
+ * @data: data pointer
+ *
+ * Set private network data pointer
+ */
+void connman_network_set_data(struct connman_network *network, void *data)
+{
+	network->driver_data = data;
+}
+
 static int network_probe(struct connman_element *element)
 {
 	return 0;

commit 365854ddf4a9b8d717f6c455cd8124c1ee9d670e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 07:48:27 2008 +0100

    Add support for handling network details

diff --git a/include/device.h b/include/device.h
index a3d9ad38..95ffeeeb 100644
--- a/include/device.h
+++ b/include/device.h
@@ -26,6 +26,7 @@
 extern "C" {
 #endif
 
+#include <connman/network.h>
 #include <connman/element.h>
 
 /**
@@ -85,6 +86,13 @@ extern int connman_device_set_carrier(struct connman_device *device,
 extern int connman_device_set_scanning(struct connman_device *device,
 							gboolean scanning);
 
+extern int connman_device_add_network(struct connman_device *device,
+					struct connman_network *network);
+extern struct connman_network *connman_device_get_network(struct connman_device *device,
+							const char *identifier);
+extern int connman_device_remove_network(struct connman_device *device,
+							const char *identifier);
+
 extern int connman_device_register(struct connman_device *device);
 extern void connman_device_unregister(struct connman_device *device);
 
diff --git a/src/device.c b/src/device.c
index 22c6927d..1b23d7f3 100644
--- a/src/device.c
+++ b/src/device.c
@@ -42,7 +42,7 @@ struct connman_device {
 	struct connman_device_driver *driver;
 	void *driver_data;
 
-	GSList *networks;
+	GHashTable *networks;
 };
 
 static const char *type2description(enum connman_device_type type)
@@ -118,12 +118,32 @@ static int set_powered(struct connman_device *device, gboolean powered)
 	return err;
 }
 
+static void append_networks(struct connman_device *device,
+						DBusMessageIter *entry)
+{
+	DBusMessageIter value, iter;
+	const char *key = "Networks";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	/* FIXME append networks */
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_device *device = data;
 	DBusMessage *reply;
-	DBusMessageIter array, dict;
+	DBusMessageIter array, dict, entry;
 	const char *str;
 
 	DBG("conn %p", conn);
@@ -169,6 +189,13 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Scanning",
 					DBUS_TYPE_BOOLEAN, &device->scanning);
 
+	if (device->mode != CONNMAN_DEVICE_MODE_NO_NETWORK) {
+		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+		append_networks(device, &entry);
+		dbus_message_iter_close_container(&dict, &entry);
+	}
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -237,9 +264,22 @@ static DBusMessage *remove_network(DBusConnection *conn,
 static DBusMessage *propose_scan(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_device *device = data;
+	int err;
+
 	DBG("conn %p", conn);
 
-	return __connman_error_not_supported(msg);
+	if (device->mode == CONNMAN_DEVICE_MODE_NO_NETWORK)
+		return __connman_error_not_supported(msg);
+
+	if (!device->driver || !device->driver->scan)
+		return __connman_error_not_supported(msg);
+
+	err = device->driver->scan(device);
+	if (err < 0)
+		return __connman_error_failed(msg);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
 static GDBusMethodTable device_methods[] = {
@@ -325,6 +365,17 @@ void connman_device_driver_unregister(struct connman_device_driver *driver)
 	driver_list = g_slist_remove(driver_list, driver);
 }
 
+static void unregister_network(gpointer data)
+{
+	struct connman_network *network = data;
+
+	DBG("network %p", network);
+
+	connman_element_unregister((struct connman_element *) network);
+
+	connman_network_unref(network);
+}
+
 static void device_destruct(struct connman_element *element)
 {
 	struct connman_device *device = element->device;
@@ -332,6 +383,8 @@ static void device_destruct(struct connman_element *element)
 	DBG("element %p name %s", element, element->name);
 
 	g_free(device->interface);
+
+	g_hash_table_destroy(device->networks);
 }
 
 /**
@@ -369,6 +422,9 @@ struct connman_device *connman_device_create(const char *node,
 	device->mode = CONNMAN_DEVICE_MODE_NO_NETWORK;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
 
+	device->networks = g_hash_table_new_full(g_str_hash, g_str_equal,
+						g_free, unregister_network);
+
 	return device;
 }
 
@@ -610,6 +666,67 @@ int connman_device_set_scanning(struct connman_device *device,
 	return 0;
 }
 
+/**
+ * connman_device_add_network:
+ * @device: device structure
+ * @network: network structure
+ *
+ * Add new network to the device
+ */
+int connman_device_add_network(struct connman_device *device,
+					struct connman_network *network)
+{
+	const char *identifier = connman_network_get_identifier(network);
+	int err;
+
+	DBG("device %p network %p", device, network);
+
+	if (device->mode == CONNMAN_DEVICE_MODE_NO_NETWORK)
+		return -EINVAL;
+
+	err = connman_element_register(&device->element,
+					(struct connman_element *) network);
+	if (err < 0)
+		return err;
+
+	g_hash_table_insert(device->networks, g_strdup(identifier),
+								network);
+
+	return 0;
+}
+
+/**
+ * connman_device_get_network:
+ * @device: device structure
+ * @indentifier: network identifier
+ *
+ * Get network for given identifier
+ */
+struct connman_network *connman_device_get_network(struct connman_device *device,
+							const char *identifier)
+{
+	DBG("device %p identifier %s", device, identifier);
+
+	return g_hash_table_lookup(device->networks, identifier);
+}
+
+/**
+ * connman_device_remove_network:
+ * @device: device structure
+ * @indentifier: network identifier
+ *
+ * Remove network for given identifier
+ */
+int connman_device_remove_network(struct connman_device *device,
+							const char *identifier)
+{
+	DBG("device %p identifier %s", device, identifier);
+
+	g_hash_table_remove(device->networks, identifier);
+
+	return 0;
+}
+
 /**
  * connman_device_register:
  * @device: device structure

commit 9b52307fecf2603a21c11e84b6cb70a416cf2901
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 11:57:32 2008 +0100

    Fix documentation typos

diff --git a/src/device.c b/src/device.c
index 1b23d7f3..86be103a 100644
--- a/src/device.c
+++ b/src/device.c
@@ -698,7 +698,7 @@ int connman_device_add_network(struct connman_device *device,
 /**
  * connman_device_get_network:
  * @device: device structure
- * @indentifier: network identifier
+ * @identifier: network identifier
  *
  * Get network for given identifier
  */
@@ -713,7 +713,7 @@ struct connman_network *connman_device_get_network(struct connman_device *device
 /**
  * connman_device_remove_network:
  * @device: device structure
- * @indentifier: network identifier
+ * @identifier: network identifier
  *
  * Remove network for given identifier
  */

commit 219aefaa626b3b0c695d079acef6c08b30bfdd66
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 12:34:05 2008 +0100

    Fix wrong order of arguments

diff --git a/src/device.c b/src/device.c
index 86be103a..0f74c20a 100644
--- a/src/device.c
+++ b/src/device.c
@@ -684,8 +684,8 @@ int connman_device_add_network(struct connman_device *device,
 	if (device->mode == CONNMAN_DEVICE_MODE_NO_NETWORK)
 		return -EINVAL;
 
-	err = connman_element_register(&device->element,
-					(struct connman_element *) network);
+	err = connman_element_register((struct connman_element *) network,
+							&device->element);
 	if (err < 0)
 		return err;
 

commit 552094eba3795ba2dd398dd30cfa69fae929753d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 12:43:26 2008 +0100

    Convert scripts using type lists

diff --git a/test/list-networks b/test/list-networks
index b4462103..d8958fb2 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -25,7 +25,7 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
-	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
+	if properties["Type"] not in ["wifi", "wimax", "bluetooth"]:
 		continue;
 
 	print "[ %s ]" % (path)
diff --git a/test/start-scanning b/test/start-scanning
index aaa3e58a..cf36477d 100755
--- a/test/start-scanning
+++ b/test/start-scanning
@@ -17,11 +17,8 @@ for path in properties["Devices"]:
 
 	print "[ %s ]" % (path)
 
-	if (properties["Type"] == "wifi"):
-		print "   Started WiFi scanning"
-		device.ProposeScan()
-	elif (properties["Type"] == "wimax"):
-		print "   Started WiMAX scanning"
+	if properties["Type"] in ["wifi", "wimax"]:
+		print "   Started scanning"
 		device.ProposeScan()
 	else:
 		print "   No scanning"

commit d39c4913a08577025f5fe102d2c9d8739b01d9b1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 12:45:41 2008 +0100

    Fix networks list of devices

diff --git a/src/device.c b/src/device.c
index 0f74c20a..3d5136d7 100644
--- a/src/device.c
+++ b/src/device.c
@@ -132,7 +132,8 @@ static void append_networks(struct connman_device *device,
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	/* FIXME append networks */
+	__connman_element_list((struct connman_element *) device,
+					CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(entry, &value);

commit a5ebd7dd2d6b5d0c2d8d3a87d14d09e2779e8df1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 22:52:03 2008 +0100

    Remove device interface handling from element functions

diff --git a/src/element.c b/src/element.c
index fba5fb88..a690046e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -147,28 +147,6 @@ static const char *subtype2string(enum connman_element_subtype type)
 	return NULL;
 }
 
-static const char *subtype2description(enum connman_element_subtype type)
-{
-	switch (type) {
-	case CONNMAN_ELEMENT_SUBTYPE_UNKNOWN:
-	case CONNMAN_ELEMENT_SUBTYPE_FAKE:
-	case CONNMAN_ELEMENT_SUBTYPE_NETWORK:
-		return NULL;
-	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:
-		return "Ethernet";
-	case CONNMAN_ELEMENT_SUBTYPE_WIFI:
-		return "Wireless";
-	case CONNMAN_ELEMENT_SUBTYPE_WIMAX:
-		return "WiMAX";
-	case CONNMAN_ELEMENT_SUBTYPE_MODEM:
-		return "Modem";
-	case CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH:
-		return "Bluetooth";
-	}
-
-	return NULL;
-}
-
 const char *__connman_element_policy2string(enum connman_element_policy policy)
 {
 	switch (policy) {
@@ -413,26 +391,6 @@ static void emit_scanning_signal(DBusConnection *conn,
 	g_dbus_send_message(conn, signal);
 }
 
-static DBusMessage *do_update(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-
-	DBG("conn %p", conn);
-
-	if (element->enabled == FALSE)
-		return __connman_error_failed(msg);
-
-	if (element->driver && element->driver->update) {
-		DBG("Calling update callback");
-		if (element->driver->update(element) < 0)
-			return __connman_error_failed(msg);
-
-	}
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
 static DBusMessage *do_enable(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -479,207 +437,6 @@ static DBusMessage *do_disable(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static void append_networks(struct connman_element *element,
-						DBusMessageIter *entry)
-{
-	DBusMessageIter value, iter;
-	const char *key = "Networks";
-
-	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
-		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
-								&value);
-
-	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
-	__connman_element_list(element, CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
-
-	dbus_message_iter_close_container(&value, &iter);
-
-	dbus_message_iter_close_container(entry, &value);
-}
-
-static DBusMessage *device_get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict, entry;
-	const char *str;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	str = subtype2description(element->subtype);
-	if (str != NULL && element->devname != NULL) {
-		char *name = g_strdup_printf("%s (%s)", str, element->devname);
-		if (name != NULL)
-			connman_dbus_dict_append_variant(&dict, "Name",
-						DBUS_TYPE_STRING, &name);
-		g_free(name);
-	}
-
-	str = subtype2string(element->subtype);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Type",
-						DBUS_TYPE_STRING, &str);
-
-	str = __connman_element_policy2string(element->policy);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Policy",
-						DBUS_TYPE_STRING, &str);
-
-	connman_dbus_dict_append_variant(&dict, "Powered",
-					DBUS_TYPE_BOOLEAN, &element->enabled);
-
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH) {
-		connman_dbus_dict_append_variant(&dict, "Scanning",
-					DBUS_TYPE_BOOLEAN, &element->scanning);
-
-		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-		append_networks(element, &entry);
-		dbus_message_iter_close_container(&dict, &entry);
-	}
-
-	add_common_properties(element, &dict);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
-static DBusMessage *device_set_property(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessageIter iter, value;
-	const char *name;
-
-	DBG("conn %p", conn);
-
-	if (dbus_message_iter_init(msg, &iter) == FALSE)
-		return __connman_error_invalid_arguments(msg);
-
-	dbus_message_iter_get_basic(&iter, &name);
-	dbus_message_iter_next(&iter);
-	dbus_message_iter_recurse(&iter, &value);
-
-	if (__connman_security_check_privileges(msg) < 0)
-		return __connman_error_permission_denied(msg);
-
-	if (g_str_equal(name, "Powered") == TRUE) {
-		dbus_bool_t powered;
-
-		dbus_message_iter_get_basic(&value, &powered);
-
-		if (powered == TRUE)
-			do_enable(conn, msg, element);
-		else
-			do_disable(conn, msg, element);
-	} else
-		set_common_property(element, name, &value);
-
-	__connman_element_store(element);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static int parse_network_dict(DBusMessageIter *iter, const char **ssid,
-				const char **security, const char **passphrase)
-{
-	while (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_DICT_ENTRY) {
-		DBusMessageIter entry, value;
-		const char *key;
-
-		dbus_message_iter_recurse(iter, &entry);
-		dbus_message_iter_get_basic(&entry, &key);
-
-		dbus_message_iter_next(&entry);
-		dbus_message_iter_recurse(&entry, &value);
-
-		switch (dbus_message_iter_get_arg_type(&value)) {
-		case DBUS_TYPE_STRING:
-			if (g_str_equal(key, "WiFi.SSID") == TRUE)
-				dbus_message_iter_get_basic(&value, ssid);
-			else if (g_str_equal(key, "WiFi.Security") == TRUE)
-				dbus_message_iter_get_basic(&value, security);
-			else if (g_str_equal(key, "WiFi.Passphrase") == TRUE)
-				dbus_message_iter_get_basic(&value, passphrase);
-			break;
-		}
-
-		dbus_message_iter_next(iter);
-	}
-
-	return 0;
-}
-
-static DBusMessage *device_create_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	struct connman_element *network;
-	DBusMessageIter iter, array;
-	const char *ssid = NULL, *security = NULL, *passphrase = NULL;
-
-	DBG("conn %p", conn);
-
-	if (element->subtype != CONNMAN_ELEMENT_SUBTYPE_WIFI)
-		return __connman_error_invalid_arguments(msg);
-
-	if (dbus_message_iter_init(msg, &iter) == FALSE)
-		return __connman_error_invalid_arguments(msg);
-
-	dbus_message_iter_recurse(&iter, &array);
-	parse_network_dict(&array, &ssid, &security, &passphrase);
-	if (ssid == NULL)
-		return __connman_error_invalid_arguments(msg);
-
-	DBG("ssid %s security %s passphrase %s", ssid, security, passphrase);
-
-	network = connman_element_create(ssid);
-
-	network->type = CONNMAN_ELEMENT_TYPE_NETWORK;
-	network->index = element->index;
-
-	network->remember = TRUE;
-
-	connman_element_add_static_property(network, "Name",
-						DBUS_TYPE_STRING, &ssid);
-
-	connman_element_add_static_array_property(element, "WiFi.SSID",
-					DBUS_TYPE_BYTE, &ssid, strlen(ssid));
-
-	network->wifi.security = g_strdup(security);
-	network->wifi.passphrase = g_strdup(passphrase);
-
-	connman_element_register(network, element);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_OBJECT_PATH, &network->path,
-							DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *device_remove_network(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
 static DBusMessage *network_get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -836,15 +593,6 @@ static DBusMessage *connection_set_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static GDBusMethodTable device_methods[] = {
-	{ "GetProperties", "",      "a{sv}", device_get_properties },
-	{ "SetProperty",   "sv",    "",      device_set_property   },
-	{ "CreateNetwork", "a{sv}", "o",     device_create_network },
-	{ "RemoveNetwork", "o",     "",      device_remove_network },
-	{ "ProposeScan",   "",      "",      do_update             },
-	{ },
-};
-
 static GDBusMethodTable network_methods[] = {
 	{ "GetProperties", "",   "a{sv}", network_get_properties },
 	{ "SetProperty",   "sv", "",      network_set_property   },
@@ -1756,10 +1504,11 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 	return result;
 }
 
-static void append_devices(DBusMessageIter *entry)
+static void append_networks(struct connman_element *element,
+						DBusMessageIter *entry)
 {
 	DBusMessageIter value, iter;
-	const char *key = "Devices";
+	const char *key = "Networks";
 
 	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
 
@@ -1769,31 +1518,12 @@ static void append_devices(DBusMessageIter *entry)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+	__connman_element_list(element, CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(entry, &value);
 }
 
-static void emit_devices_signal(DBusConnection *conn)
-{
-	DBusMessage *signal;
-	DBusMessageIter entry;
-
-	DBG("conn %p", conn);
-
-	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
-	if (signal == NULL)
-		return;
-
-	dbus_message_iter_init_append(signal, &entry);
-
-	append_devices(&entry);
-
-	g_dbus_send_message(conn, signal);
-}
-
 static void emit_networks_signal(DBusConnection *conn,
 					struct connman_element *device)
 {
@@ -1960,18 +1690,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_node_append_data(node, element);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
-			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
-		if (g_dbus_register_interface(connection, element->path,
-					CONNMAN_DEVICE_INTERFACE,
-					device_methods, element_signals,
-					NULL, element, NULL) == FALSE)
-			connman_error("Failed to register %s device",
-								element->path);
-		else
-			emit_devices_signal(connection);
-	}
-
 	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
 		if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_NETWORK_INTERFACE,
@@ -2098,14 +1816,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 						CONNMAN_NETWORK_INTERFACE);
 	}
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
-			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
-		emit_devices_signal(connection);
-
-		g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_DEVICE_INTERFACE);
-	}
-
 	connman_element_unref(element);
 
 	return FALSE;

commit 7efb49e571b228f9c4ef55449cf03ab0f7fdf638
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 22:53:11 2008 +0100

    Unlink node before calling remove callback

diff --git a/src/element.c b/src/element.c
index a690046e..fbc5cc90 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1783,6 +1783,9 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 	if (element == root)
 		return FALSE;
 
+	if (node != NULL)
+		g_node_unlink(node);
+
 	if (element->driver) {
 		disable_element(element);
 
@@ -1794,10 +1797,8 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		__connman_element_unlock(element);
 	}
 
-	if (node != NULL) {
-		g_node_unlink(node);
+	if (node != NULL)
 		g_node_destroy(node);
-	}
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
 		if (__connman_element_count(NULL,

commit 1449d2e54341dd7d174fef91426f539a0b5fd13a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 22:54:18 2008 +0100

    Emit signal when list of devices changes

diff --git a/src/device.c b/src/device.c
index 3d5136d7..86493a50 100644
--- a/src/device.c
+++ b/src/device.c
@@ -299,13 +299,46 @@ static GDBusSignalTable device_signals[] = {
 
 static DBusConnection *connection;
 
+static void append_devices(DBusMessageIter *entry)
+{
+	DBusMessageIter value, iter;
+	const char *key = "Devices";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
+static void emit_devices_signal(void)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_devices(&entry);
+
+	g_dbus_send_message(connection, signal);
+}
+
 static int register_interface(struct connman_element *element)
 {
 	struct connman_device *device = element->device;
 
-	g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_DEVICE_INTERFACE);
-
 	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_DEVICE_INTERFACE,
 					device_methods, device_signals,
@@ -314,11 +347,15 @@ static int register_interface(struct connman_element *element)
 		return -EIO;
 	}
 
+	emit_devices_signal();
+
 	return 0;
 }
 
 static void unregister_interface(struct connman_element *element)
 {
+	emit_devices_signal();
+
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_DEVICE_INTERFACE);
 }

commit f1d42616b9c8ad0158678f22256418c9c312b43b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 23:18:32 2008 +0100

    Convert WiFi device handling to generic driver

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 0b84903e..daff3a23 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -42,7 +42,7 @@
 struct supplicant_task {
 	int ifindex;
 	gchar *ifname;
-	struct connman_element *element;
+	struct connman_device *device;
 	struct supplicant_callback *callback;
 	gchar *path;
 	gboolean created;
@@ -732,7 +732,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	}
 
 	if (task->callback && task->callback->scan_result)
-		task->callback->scan_result(task->element, network);
+		task->callback->scan_result(task->device, network);
 
 	g_free(network->identifier);
 	g_free(network->ssid);
@@ -795,7 +795,7 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 	}
 
 	if (task->callback && task->callback->clear_results)
-			task->callback->clear_results(task->element);
+			task->callback->clear_results(task->device);
 
 	for (i = 0; i < num_results; i++)
 		get_network_properties(task, results[i]);
@@ -871,7 +871,7 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 		task->state = STATE_DISCONNECTED;
 
 	if (task->callback && task->callback->state_change)
-		task->callback->state_change(task->element, task->state);
+		task->callback->state_change(task->device, task->state);
 
 	switch (task->state) {
 	case STATE_COMPLETED:
@@ -965,21 +965,21 @@ static int remove_filter(struct supplicant_task *task)
 	return 0;
 }
 
-int __supplicant_start(struct connman_element *element,
+int __supplicant_start(struct connman_device *device,
 					struct supplicant_callback *callback)
 {
 	struct supplicant_task *task;
 	int err;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
 	task = g_try_new0(struct supplicant_task, 1);
 	if (task == NULL)
 		return -ENOMEM;
 
-	task->ifindex = element->index;
-	task->ifname = inet_index2name(element->index);
-	task->element = element;
+	task->ifindex = connman_device_get_index(device);
+	task->ifname = inet_index2name(task->ifindex);
+	task->device = device;
 	task->callback = callback;
 
 	if (task->ifname == NULL) {
@@ -1008,13 +1008,14 @@ int __supplicant_start(struct connman_element *element,
 	return 0;
 }
 
-int __supplicant_stop(struct connman_element *element)
+int __supplicant_stop(struct connman_device *device)
 {
+	int index = connman_device_get_index(device);
 	struct supplicant_task *task;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
-	task = find_task_by_index(element->index);
+	task = find_task_by_index(index);
 	if (task == NULL)
 		return -ENODEV;
 
@@ -1035,14 +1036,15 @@ int __supplicant_stop(struct connman_element *element)
 	return 0;
 }
 
-int __supplicant_scan(struct connman_element *element)
+int __supplicant_scan(struct connman_device *device)
 {
+	int index = connman_device_get_index(device);
 	struct supplicant_task *task;
 	int err;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
-	task = find_task_by_index(element->index);
+	task = find_task_by_index(index);
 	if (task == NULL)
 		return -ENODEV;
 
@@ -1069,7 +1071,7 @@ int __supplicant_connect(struct connman_element *element,
 {
 	struct supplicant_task *task;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("element %p", element);
 
 	task = find_task_by_index(element->index);
 	if (task == NULL)
@@ -1091,7 +1093,7 @@ int __supplicant_disconnect(struct connman_element *element)
 {
 	struct supplicant_task *task;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("element %p", element);
 
 	task = find_task_by_index(element->index);
 	if (task == NULL)
@@ -1112,7 +1114,7 @@ void __supplicant_activate(DBusConnection *conn)
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, "/",
 				DBUS_INTERFACE_INTROSPECTABLE, "Introspect");
-        if (message == NULL)
+	if (message == NULL)
 		return;
 
 	dbus_message_set_no_reply(message, TRUE);
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 2afd003b..ef207d5c 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -19,6 +19,7 @@
  *
  */
 
+#include <connman/device.h>
 #include <connman/element.h>
 
 #define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
@@ -52,10 +53,10 @@ struct supplicant_network {
 };
 
 struct supplicant_callback {
-	void (*state_change) (struct connman_element *element,
+	void (*state_change) (struct connman_device *device,
 						enum supplicant_state state);
-	void (*clear_results) (struct connman_element *element);
-	void (*scan_result) (struct connman_element *element,
+	void (*clear_results) (struct connman_device *device);
+	void (*scan_result) (struct connman_device *device,
 					struct supplicant_network *network);
 };
 
@@ -64,11 +65,11 @@ void __supplicant_activate(DBusConnection *conn);
 int __supplicant_init(DBusConnection *conn);
 void __supplicant_exit(void);
 
-int __supplicant_start(struct connman_element *element,
+int __supplicant_start(struct connman_device *device,
 					struct supplicant_callback *callback);
-int __supplicant_stop(struct connman_element *element);
+int __supplicant_stop(struct connman_device *device);
 
-int __supplicant_scan(struct connman_element *element);
+int __supplicant_scan(struct connman_device *device);
 
 int __supplicant_connect(struct connman_element *element,
 				const unsigned char *ssid, int ssid_len,
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 9a92ad51..ca39cecd 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -68,7 +68,7 @@ static void network_remove(struct connman_element *element)
 
 static int network_enable(struct connman_element *element)
 {
-	struct connman_element *device = element->parent;
+	struct connman_device *device = (struct connman_device *) element->parent;
 	char *name, *security = NULL, *passphrase = NULL;
 	unsigned char *ssid;
 	int ssid_len;
@@ -84,7 +84,7 @@ static int network_enable(struct connman_element *element)
 		return -EIO;
 
 	if (device != NULL) {
-		struct wifi_data *data = connman_element_get_data(device);
+		struct wifi_data *data = connman_device_get_data(device);
 
 		if (data != NULL) {
 			if (data->connected == TRUE)
@@ -166,10 +166,10 @@ static struct connman_element *find_pending_element(struct wifi_data *data,
 
 static gboolean inactive_scan(gpointer user_data)
 {
-	struct connman_element *device = user_data;
-	struct wifi_data *data = connman_element_get_data(device);
+	struct connman_device *device = user_data;
+	struct wifi_data *data = connman_device_get_data(device);
 
-	DBG("");
+	DBG("device %p", device);
 
 	__supplicant_scan(device);
 
@@ -178,12 +178,12 @@ static gboolean inactive_scan(gpointer user_data)
 	return FALSE;
 }
 
-static void connect_known_networks(struct connman_element *device)
+static void connect_known_networks(struct connman_device *device)
 {
-	struct wifi_data *data = connman_element_get_data(device);
+	struct wifi_data *data = connman_device_get_data(device);
 	GSList *list;
 
-	DBG("");
+	DBG("device %p", device);
 
 	if (data->inactive_timer > 0) {
 		g_source_remove(data->inactive_timer);
@@ -205,22 +205,24 @@ static void connect_known_networks(struct connman_element *device)
 							inactive_scan, device);
 }
 
-static void state_change(struct connman_element *device,
+static void state_change(struct connman_device *device,
 						enum supplicant_state state)
 {
-	struct wifi_data *data = connman_element_get_data(device);
+	struct wifi_data *data = connman_device_get_data(device);
 	struct connman_element *element;
 
-	DBG("state %d", state);
+	DBG("device %p state %d", device, state);
 
 	if (state == STATE_SCANNING)
-		connman_element_set_scanning(device, TRUE);
+		connman_device_set_scanning(device, TRUE);
 	else
-		connman_element_set_scanning(device, FALSE);
+		connman_device_set_scanning(device, FALSE);
 
 	if (data == NULL)
 		return;
 
+	DBG("identifier %s", data->identifier);
+
 	if (data->identifier == NULL)
 		goto reconnect;
 
@@ -279,9 +281,9 @@ static gboolean cleanup_pending(gpointer user_data)
 	return FALSE;
 }
 
-static void clear_results(struct connman_element *device)
+static void clear_results(struct connman_device *device)
 {
-	struct wifi_data *data = connman_element_get_data(device);
+	struct wifi_data *data = connman_device_get_data(device);
 
 	DBG("pending %d", g_slist_length(data->pending));
 	DBG("current %d", g_slist_length(data->current));
@@ -298,15 +300,15 @@ static void clear_results(struct connman_element *device)
 							cleanup_pending, data);
 }
 
-static void scan_result(struct connman_element *device,
+static void scan_result(struct connman_device *device,
 					struct supplicant_network *network)
 {
-	struct wifi_data *data = connman_element_get_data(device);
+	struct wifi_data *data = connman_device_get_data(device);
 	struct connman_element *element;
 	gchar *temp;
 	unsigned int i;
 
-	DBG("network %p identifier %s", network, network->identifier);
+	DBG("device %p identifier %s", device, network->identifier);
 
 	if (data == NULL)
 		return;
@@ -332,8 +334,9 @@ static void scan_result(struct connman_element *device,
 
 		element = connman_element_create(temp);
 
-		element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
-		element->index = device->index;
+		element->type    = CONNMAN_ELEMENT_TYPE_NETWORK;
+		element->subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+		element->index   = connman_device_get_index(device);
 
 		connman_element_add_static_property(element, "Name",
 				DBUS_TYPE_STRING, &network->identifier);
@@ -368,7 +371,8 @@ static void scan_result(struct connman_element *device,
 		DBG("%s (%s %s) strength %d", network->identifier, mode,
 				element->wifi.security, element->strength);
 
-		if (connman_element_register(element, device) < 0) {
+		if (connman_element_register(element,
+				(struct connman_element *) device) < 0) {
 			connman_element_unref(element);
 			goto done;
 		}
@@ -399,11 +403,11 @@ static struct supplicant_callback wifi_callback = {
 	.scan_result	= scan_result,
 };
 
-static int wifi_probe(struct connman_element *element)
+static int wifi_probe(struct connman_device *device)
 {
 	struct wifi_data *data;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
 	data = g_try_new0(struct wifi_data, 1);
 	if (data == NULL)
@@ -411,53 +415,46 @@ static int wifi_probe(struct connman_element *element)
 
 	data->connected = FALSE;
 
-	connman_element_set_data(element, data);
+	connman_device_set_data(device, data);
 
 	return 0;
 }
 
-static void wifi_remove(struct connman_element *element)
+static void wifi_remove(struct connman_device *device)
 {
-	struct wifi_data *data = connman_element_get_data(element);
+	struct wifi_data *data = connman_device_get_data(device);
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
-	connman_element_set_data(element, NULL);
+	connman_device_set_data(device, NULL);
 
 	g_free(data->identifier);
 	g_free(data);
 }
 
-static int wifi_update(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	__supplicant_scan(element);
-
-	return 0;
-}
-
-static int wifi_enable(struct connman_element *element)
+static int wifi_enable(struct connman_device *device)
 {
 	int err;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
-	err = __supplicant_start(element, &wifi_callback);
+	err = __supplicant_start(device, &wifi_callback);
 	if (err < 0)
 		return err;
 
-	__supplicant_scan(element);
+	connman_device_set_powered(device, TRUE);
+
+	__supplicant_scan(device);
 
 	return 0;
 }
 
-static int wifi_disable(struct connman_element *element)
+static int wifi_disable(struct connman_device *device)
 {
-	struct wifi_data *data = connman_element_get_data(element);
+	struct wifi_data *data = connman_device_get_data(device);
 	GSList *list;
 
-	DBG("element %p name %s", element, element->name);
+	DBG("device %p", device);
 
 	if (data->cleanup_timer > 0) {
 		g_source_remove(data->cleanup_timer);
@@ -469,33 +466,44 @@ static int wifi_disable(struct connman_element *element)
 		data->inactive_timer = 0;
 	}
 
-	__supplicant_disconnect(element);
-
 	for (list = data->current; list; list = list->next) {
 		struct connman_element *network = list->data;
 
+		if (network->enabled == TRUE)
+			__supplicant_disconnect(network);
+
 		connman_element_unref(network);
 	}
 
 	g_slist_free(data->current);
 	data->current = NULL;
 
-	connman_element_unregister_children(element);
+	connman_element_unregister_children((struct connman_element *) device);
+
+	__supplicant_stop(device);
+
+	connman_device_set_powered(device, FALSE);
 
-	__supplicant_stop(element);
+	return 0;
+}
+
+static int wifi_scan(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	__supplicant_scan(device);
 
 	return 0;
 }
 
-static struct connman_driver wifi_driver = {
+static struct connman_device_driver wifi_driver = {
 	.name		= "wifi-device",
-	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_WIFI,
+	.type		= CONNMAN_DEVICE_TYPE_WIFI,
 	.probe		= wifi_probe,
 	.remove		= wifi_remove,
-	.update		= wifi_update,
 	.enable		= wifi_enable,
 	.disable	= wifi_disable,
+	.scan		= wifi_scan,
 };
 
 static GSList *device_list = NULL;
@@ -503,7 +511,7 @@ static GSList *device_list = NULL;
 static void wifi_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
-	struct connman_element *device;
+	struct connman_device *device;
 	GSList *list;
 	gboolean exists = FALSE;
 	gchar *name, *devname;
@@ -515,7 +523,6 @@ static void wifi_newlink(unsigned short type, int index,
 	if (type != ARPHRD_ETHER)
 		return;
 
-	name = inet_index2ident(index, "dev_");
 	devname = inet_index2name(index);
 
 	memset(&iwr, 0, sizeof(iwr));
@@ -524,7 +531,7 @@ static void wifi_newlink(unsigned short type, int index,
 	sk = socket(PF_INET, SOCK_DGRAM, 0);
 
 	if (ioctl(sk, SIOCGIWNAME, &iwr) < 0) {
-		g_free(name);
+		g_free(devname);
 		close(sk);
 		return;
 	}
@@ -532,29 +539,38 @@ static void wifi_newlink(unsigned short type, int index,
 	close(sk);
 
 	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
+		struct connman_device *device = list->data;
 
-		if (device->index == index) {
+		if (connman_device_get_index(device) == index) {
 			exists = TRUE;
 			break;
 		}
 	}
 
 	if (exists == TRUE) {
+		g_free(devname);
+		return;
+	}
+
+	name = inet_index2ident(index, "dev_");
+
+	device = connman_device_create(name, CONNMAN_DEVICE_TYPE_WIFI);
+	if (device == NULL) {
+		g_free(devname);
 		g_free(name);
 		return;
 	}
 
-	device = connman_element_create(NULL);
-	device->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	device->subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+	connman_device_set_index(device, index);
+	connman_device_set_interface(device, devname);
+
+	g_free(devname);
+	g_free(name);
 
-	device->index = index;
-	device->name = name;
-	device->devname = devname;
+	connman_device_set_mode(device, CONNMAN_DEVICE_MODE_SINGLE_NETWORK);
 
-	if (connman_element_register(device, NULL) < 0) {
-		connman_element_unregister(device);
+	if (connman_device_register(device) < 0) {
+		connman_device_unregister(device);
 		return;
 	}
 
@@ -569,12 +585,12 @@ static void wifi_dellink(unsigned short type, int index,
 	DBG("index %d", index);
 
 	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
+		struct connman_device *device = list->data;
 
-		if (device->index == index) {
+		if (connman_device_get_index(device) == index) {
 			device_list = g_slist_remove(device_list, device);
-			connman_element_unregister(device);
-			connman_element_unref(device);
+			connman_device_unregister(device);
+			connman_device_unref(device);
 			break;
 		}
 	}
@@ -607,10 +623,10 @@ static void supplicant_disconnect(DBusConnection *connection, void *user_data)
 	connman_rtnl_unregister(&wifi_rtnl);
 
 	for (list = device_list; list; list = list->next) {
-		struct connman_element *device = list->data;
+		struct connman_device *device = list->data;
 
-		connman_element_unregister(device);
-		connman_element_unref(device);
+		connman_device_unregister(device);
+		connman_device_unref(device);
 	}
 
 	g_slist_free(device_list);
@@ -636,7 +652,7 @@ static int wifi_init(void)
 		return err;
 	}
 
-	err = connman_driver_register(&wifi_driver);
+	err = connman_device_driver_register(&wifi_driver);
 	if (err < 0) {
 		connman_driver_unregister(&network_driver);
 		dbus_connection_unref(connection);
@@ -657,7 +673,7 @@ static int wifi_init(void)
 static void wifi_exit(void)
 {
 	connman_driver_unregister(&network_driver);
-	connman_driver_unregister(&wifi_driver);
+	connman_device_driver_unregister(&wifi_driver);
 
 	if (watch > 0)
 		g_dbus_remove_watch(connection, watch);

commit 4c1c88e40a46a41510faa3f1544bfc2aaf9d1063
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 26 23:25:24 2008 +0100

    Add initial support for Bluetooth networks

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index e09a8600..46f8f421 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -36,6 +36,7 @@
 #define BLUEZ_SERVICE			"org.bluez"
 #define BLUEZ_MANAGER_INTERFACE		BLUEZ_SERVICE ".Manager"
 #define BLUEZ_ADAPTER_INTERFACE		BLUEZ_SERVICE ".Adapter"
+#define BLUEZ_DEVICE_INTERFACE		BLUEZ_SERVICE ".Device"
 
 #define LIST_ADAPTERS			"ListAdapters"
 #define ADAPTER_ADDED			"AdapterAdded"
@@ -47,6 +48,76 @@
 
 #define TIMEOUT 5000
 
+typedef void (* properties_callback_t) (DBusConnection *connection,
+							const char *path,
+							DBusMessage *message,
+							void *user_data);
+
+struct properties_data {
+	DBusConnection *connection;
+	DBusMessage *message;
+	properties_callback_t callback;
+	void *user_data;
+};
+
+static void get_properties_reply(DBusPendingCall *call, void *user_data)
+{
+	struct properties_data *data = user_data;
+	DBusMessage *reply;
+	const char *path;
+
+	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL)
+		goto done;
+
+	path = dbus_message_get_path(data->message);
+
+	data->callback(data->connection, path, reply, data->user_data);
+
+	dbus_message_unref(reply);
+
+done:
+	dbus_message_unref(data->message);
+	g_free(data);
+}
+
+static void get_properties(DBusConnection *connection,
+				const char *path, const char *interface,
+				properties_callback_t callback, void *user_data)
+{
+	struct properties_data *data;
+	DBusMessage *message;
+	DBusPendingCall *call;
+
+	DBG("path %s interface %s", path, interface);
+
+	data = g_try_new0(struct properties_data, 1);
+	if (data == NULL)
+		return;
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
+						interface, GET_PROPERTIES);
+	if (message == NULL) {
+		g_free(data);
+		return;
+	}
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get properties for %s", interface);
+		dbus_message_unref(message);
+		g_free(data);
+		return;
+	}
+
+	data->connection = connection;
+	data->message    = message;
+	data->callback   = callback;
+	data->user_data  = user_data;
+
+	dbus_pending_call_set_notify(call, get_properties_reply, data, NULL);
+}
+
 struct adapter_data {
 	DBusConnection *connection;
 };
@@ -204,8 +275,28 @@ static struct connman_device *find_adapter(const char *path)
 	return NULL;
 }
 
+static void device_properties(DBusConnection *connection, const char *path,
+				DBusMessage *message, void *user_data)
+{
+	struct connman_device *device = user_data;
+	const char *node = g_basename(path);
+	struct connman_network *network;
+
+	DBG("path %s", path);
+
+	network = connman_device_get_network(device, node);
+	if (network != NULL)
+		return;
+
+	network = connman_network_create(node, CONNMAN_NETWORK_TYPE_WIFI);
+	if (network == NULL)
+		return;
+
+	connman_device_add_network(device, network);
+}
+
 static void check_devices(struct connman_device *adapter,
-						DBusMessageIter *array)
+			DBusConnection *connection, DBusMessageIter *array)
 {
 	DBusMessageIter value;
 
@@ -219,7 +310,8 @@ static void check_devices(struct connman_device *adapter,
 
 		dbus_message_iter_get_basic(&value, &path);
 
-		DBG("device %s", path);
+		get_properties(connection, path, BLUEZ_DEVICE_INTERFACE,
+						device_properties, adapter);
 
 		dbus_message_iter_next(&value);
 	}
@@ -259,32 +351,20 @@ static void property_changed(DBusConnection *connection, DBusMessage *message)
 	}
 }
 
-static void properties_reply(DBusPendingCall *call, void *user_data)
+static void parse_adapter_properties(struct connman_device *adapter,
+						DBusConnection *connection,
+							DBusMessage *reply)
 {
-	DBusMessage *message = user_data;
-	const char *path = dbus_message_get_path(message);
-	struct connman_device *adapter;
 	DBusMessageIter array, dict;
-	DBusMessage *reply;
-
-	DBG("path %s", path);
-
-	adapter = find_adapter(path);
-
-	dbus_message_unref(message);
-
-	reply = dbus_pending_call_steal_reply(call);
-
-	if (adapter == NULL)
-		goto done;
 
 	if (dbus_message_iter_init(reply, &array) == FALSE)
-		goto done;
+		return;
 
 	if (dbus_message_iter_get_arg_type(&array) != DBUS_TYPE_ARRAY)
-		goto done;
+		return;
 
 	dbus_message_iter_recurse(&array, &dict);
+
 	while (dbus_message_iter_get_arg_type(&dict) == DBUS_TYPE_DICT_ENTRY) {
 		DBusMessageIter entry, value;
 		const char *key;
@@ -306,30 +386,28 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 			dbus_message_iter_get_basic(&value, &val);
 			connman_device_set_scanning(adapter, val);
 		} else if (g_str_equal(key, "Devices") == TRUE) {
-			check_devices(adapter, &value);
+			check_devices(adapter, connection, &value);
 		}
 
 		dbus_message_iter_next(&dict);
 	}
-
-done:
-	dbus_message_unref(reply);
 }
 
-static void add_adapter(DBusConnection *connection, const char *path)
+static void adapter_properties(DBusConnection *connection, const char *path,
+				DBusMessage *message, void *user_data)
 {
 	const char *node = g_basename(path);
 	struct connman_device *adapter;
-	DBusMessage *message;
-	DBusPendingCall *call;
 
 	DBG("path %s", path);
 
 	adapter = find_adapter(path);
 	if (adapter != NULL)
-		return;
+		goto done;
 
 	adapter = connman_device_create(node, CONNMAN_DEVICE_TYPE_BLUETOOTH);
+	if (adapter == NULL)
+		return;
 
 	connman_device_set_path(adapter, path);
 
@@ -352,19 +430,16 @@ static void add_adapter(DBusConnection *connection, const char *path)
 
 	adapter_list = g_slist_append(adapter_list, adapter);
 
-	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
-				BLUEZ_ADAPTER_INTERFACE, GET_PROPERTIES);
-	if (message == NULL)
-		return;
+done:
+	parse_adapter_properties(adapter, connection, message);
+}
 
-	if (dbus_connection_send_with_reply(connection, message,
-						&call, TIMEOUT) == FALSE) {
-		connman_error("Failed to get adapter properties");
-		dbus_message_unref(message);
-		return;
-	}
+static void add_adapter(DBusConnection *connection, const char *path)
+{
+	DBG("path %s", path);
 
-	dbus_pending_call_set_notify(call, properties_reply, message, NULL);
+	get_properties(connection, path, BLUEZ_ADAPTER_INTERFACE,
+						adapter_properties, NULL);
 }
 
 static void remove_adapter(DBusConnection *connection, const char *path)
@@ -383,7 +458,7 @@ static void remove_adapter(DBusConnection *connection, const char *path)
 	connman_device_unref(adapter);
 }
 
-static void adapters_reply(DBusPendingCall *call, void *user_data)
+static void list_adapters_reply(DBusPendingCall *call, void *user_data)
 {
 	DBusConnection *connection = user_data;
 	DBusMessage *reply;
@@ -410,7 +485,9 @@ static void adapters_reply(DBusPendingCall *call, void *user_data)
 	}
 
 	for (i = 0; i < num_adapters; i++)
-		add_adapter(connection, adapters[i]);
+		get_properties(connection, adapters[i],
+					BLUEZ_ADAPTER_INTERFACE,
+						adapter_properties, NULL);
 
 	g_strfreev(adapters);
 
@@ -437,7 +514,8 @@ static void bluetooth_connect(DBusConnection *connection, void *user_data)
 		return;
 	}
 
-	dbus_pending_call_set_notify(call, adapters_reply, connection, NULL);
+	dbus_pending_call_set_notify(call, list_adapters_reply,
+							connection, NULL);
 
 	dbus_message_unref(message);
 }

commit fd31f66180b7960edb1283bcbc80897eca134a03
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 07:00:31 2008 +0100

    Register device interface only when driver is bound

diff --git a/src/device.c b/src/device.c
index 86493a50..d884a3f9 100644
--- a/src/device.c
+++ b/src/device.c
@@ -859,10 +859,6 @@ static int device_probe(struct connman_element *element)
 	if (device == NULL)
 		return -ENODEV;
 
-	err = register_interface(element);
-	if (err < 0)
-		return err;
-
 	for (list = driver_list; list; list = list->next) {
 		struct connman_device_driver *driver = list->data;
 
@@ -873,11 +869,22 @@ static int device_probe(struct connman_element *element)
 
 		if (driver->probe(device) == 0) {
 			device->driver = driver;
-			device_enable(device);
 			break;
 		}
 	}
 
+	if (!device->driver)
+		return -ENODEV;
+
+	err = register_interface(element);
+	if (err < 0) {
+		if (device->driver->remove)
+			device->driver->remove(device);
+		return err;
+	}
+
+	device_enable(device);
+
 	return 0;
 }
 
@@ -890,14 +897,15 @@ static void device_remove(struct connman_element *element)
 	if (device == NULL)
 		return;
 
-	unregister_interface(element);
+	if (!device->driver)
+		return;
 
-	if (device->driver) {
-		device_disable(device);
+	device_disable(device);
 
-		if (device->driver->remove)
-			device->driver->remove(device);
-	}
+	unregister_interface(element);
+
+	if (device->driver->remove)
+		device->driver->remove(device);
 }
 
 static struct connman_driver device_driver = {

commit ebbf5aeca9880a3dce73effa17ba13caf3be3837
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 08:26:12 2008 +0100

    Add stage for stopping element registration

diff --git a/src/connman.h b/src/connman.h
index 44ff9543..918cc7c5 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -85,6 +85,7 @@ void __connman_driver_rescan(struct connman_driver *driver);
 
 int __connman_element_init(DBusConnection *conn, const char *device);
 void __connman_element_start(void);
+void __connman_element_stop(void);
 void __connman_element_cleanup(void);
 
 void __connman_element_list(struct connman_element *element,
diff --git a/src/element.c b/src/element.c
index fbc5cc90..fbed4f6b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1963,6 +1963,11 @@ void __connman_element_start(void)
 	started = TRUE;
 }
 
+void __connman_element_stop(void)
+{
+	DBG("");
+}
+
 static gboolean free_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
diff --git a/src/main.c b/src/main.c
index 357decb5..51e1530b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -177,6 +177,8 @@ int main(int argc, char *argv[])
 
 	g_main_loop_run(main_loop);
 
+	__connman_element_stop();
+
 	__connman_plugin_cleanup();
 
 	__connman_rtnl_cleanup();

commit a63f375583ede1f9b42626dc145db3fa657ea3ae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 08:39:11 2008 +0100

    Remove RTNL link detection plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2cde74b6..2ef85439 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,8 +1,8 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = loopback.la netdev.la ethernet.la wifi.la bluetooth.la \
-				udhcp.la dhclient.la ipv4.la rtnllink.la \
+plugin_LTLIBRARIES = loopback.la netdev.la ethernet.la wifi.la \
+			bluetooth.la udhcp.la dhclient.la ipv4.la \
 				dnsproxy.la resolvconf.la resolvfile.la
 
 loopback_la_SOURCES = loopback.c
diff --git a/plugins/rtnllink.c b/plugins/rtnllink.c
deleted file mode 100644
index 8ac07158..00000000
--- a/plugins/rtnllink.c
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <linux/if_arp.h>
-#include <linux/wireless.h>
-
-#include <connman/plugin.h>
-#include <connman/device.h>
-#include <connman/rtnl.h>
-#include <connman/log.h>
-
-#include "inet.h"
-
-static GSList *device_list = NULL;
-
-static struct connman_device *find_device(int index)
-{
-	GSList *list;
-
-	for (list = device_list; list; list = list->next) {
-		struct connman_device *device = list->data;
-
-		if (connman_device_get_index(device) == index)
-			return device;
-	}
-
-	return NULL;
-}
-
-static void rtnllink_newlink(unsigned short type, int index,
-					unsigned flags, unsigned change)
-{
-	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-	struct connman_device *device;
-	gchar *name, *devname;
-
-	DBG("index %d", index);
-
-	device = find_device(index);
-	if (device != NULL)
-		return;
-
-	devname = inet_index2name(index);
-
-	if (type == ARPHRD_ETHER) {
-		char bridge_path[PATH_MAX], wimax_path[PATH_MAX];
-		struct stat st;
-		struct iwreq iwr;
-		int sk;
-
-		snprintf(bridge_path, PATH_MAX,
-					"/sys/class/net/%s/bridge", devname);
-		snprintf(wimax_path, PATH_MAX,
-					"/sys/class/net/%s/wimax", devname);
-
-		memset(&iwr, 0, sizeof(iwr));
-		strncpy(iwr.ifr_ifrn.ifrn_name, devname, IFNAMSIZ);
-
-		sk = socket(PF_INET, SOCK_DGRAM, 0);
-
-		if (g_str_has_prefix(devname, "bnep") == TRUE)
-			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
-			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
-			devtype = CONNMAN_DEVICE_TYPE_WIMAX;
-		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
-			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else
-			devtype = CONNMAN_DEVICE_TYPE_ETHERNET;
-
-		close(sk);
-	}
-
-	if (devtype == CONNMAN_DEVICE_TYPE_UNKNOWN) {
-		g_free(devname);
-		return;
-	}
-
-	name = inet_index2ident(index, "dev_");
-
-	device = connman_device_create(name, devtype);
-	if (device == NULL) {
-		g_free(devname);
-		g_free(name);
-		return;
-	}
-
-	connman_device_set_index(device, index);
-	connman_device_set_interface(device, devname);
-
-	g_free(devname);
-	g_free(name);
-
-	if (connman_device_register(device) < 0) {
-		connman_device_unref(device);
-		return;
-	}
-
-	device_list = g_slist_append(device_list, device);
-}
-
-static void rtnllink_dellink(unsigned short type, int index,
-					unsigned flags, unsigned change)
-{
-	struct connman_device *device;
-
-	DBG("index %d", index);
-
-	device = find_device(index);
-	if (device == NULL)
-		return;
-
-	device_list = g_slist_remove(device_list, device);
-
-	connman_device_unregister(device);
-	connman_device_unref(device);
-}
-
-static struct connman_rtnl rtnllink_rtnl = {
-	.name		= "rtnllink",
-	.newlink	= rtnllink_newlink,
-	.dellink	= rtnllink_dellink,
-};
-
-static int rtnllink_init(void)
-{
-	int err;
-
-	err = connman_rtnl_register(&rtnllink_rtnl);
-	if (err < 0)
-		return err;
-
-	connman_rtnl_send_getlink();
-
-	return 0;
-}
-
-static void rtnllink_exit(void)
-{
-	GSList *list;
-
-	connman_rtnl_unregister(&rtnllink_rtnl);
-
-	for (list = device_list; list; list = list->next) {
-		struct connman_device *device = list->data;
-
-		connman_device_unregister(device);
-		connman_device_unref(device);
-	}
-
-	g_slist_free(device_list);
-	device_list = NULL;
-}
-
-CONNMAN_PLUGIN_DEFINE(rtnllink, "RTNL link detection plugin", VERSION,
-						rtnllink_init, rtnllink_exit)

commit 3d52695c2fa60c2e8cb6b7bc4af5aeb504981974
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 08:41:14 2008 +0100

    Add generic device detection support

diff --git a/src/Makefile.am b/src/Makefile.am
index 018fb15f..42a8a488 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -6,8 +6,9 @@ dbus_DATA = connman.conf
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
-			profile.c element.c device.c network.c security.c \
-			resolver.c storage.c manager.c agent.c rtnl.c dbus.c
+				profile.c element.c device.c network.c \
+				security.c resolver.c storage.c manager.c \
+				agent.c detect.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/connman.h b/src/connman.h
index 918cc7c5..55f78c0a 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -111,6 +111,9 @@ static inline void __connman_element_unlock(struct connman_element *element)
 {
 }
 
+int __connman_detect_init(void);
+void __connman_detect_cleanup(void);
+
 #include <connman/device.h>
 
 int __connman_device_init(void);
diff --git a/src/detect.c b/src/detect.c
new file mode 100644
index 00000000..85fb077a
--- /dev/null
+++ b/src/detect.c
@@ -0,0 +1,256 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/ethernet.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+
+#include <connman/device.h>
+#include <connman/rtnl.h>
+#include <connman/log.h>
+
+#include "connman.h"
+
+static GSList *device_list = NULL;
+
+static struct connman_device *find_device(int index)
+{
+	GSList *list;
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_device *device = list->data;
+
+		if (connman_device_get_index(device) == index)
+			return device;
+	}
+
+	return NULL;
+}
+
+static char *index2name(int index)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	if (index < 0)
+		return NULL;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	return strdup(ifr.ifr_name);
+}
+
+static char *index2ident(int index, const char *prefix)
+{
+	struct ifreq ifr;
+	struct ether_addr *eth;
+	char *str;
+	int sk, err, len;
+
+	if (index < 0)
+		return NULL;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	len = prefix ? strlen(prefix) + 18 : 18;
+
+	str = malloc(len);
+	if (!str)
+		return NULL;
+
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	snprintf(str, len, "%s%02X_%02X_%02X_%02X_%02X_%02X",
+						prefix ? prefix : "",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
+	return str;
+}
+
+static void detect_newlink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+	struct connman_device *device;
+	gchar *name, *devname;
+
+	DBG("index %d", index);
+
+	device = find_device(index);
+	if (device != NULL)
+		return;
+
+	devname = index2name(index);
+
+	if (type == ARPHRD_ETHER) {
+		char bridge_path[PATH_MAX], wimax_path[PATH_MAX];
+		struct stat st;
+		struct iwreq iwr;
+		int sk;
+
+		snprintf(bridge_path, PATH_MAX,
+					"/sys/class/net/%s/bridge", devname);
+		snprintf(wimax_path, PATH_MAX,
+					"/sys/class/net/%s/wimax", devname);
+
+		memset(&iwr, 0, sizeof(iwr));
+		strncpy(iwr.ifr_ifrn.ifrn_name, devname, IFNAMSIZ);
+
+		sk = socket(PF_INET, SOCK_DGRAM, 0);
+
+		if (g_str_has_prefix(devname, "bnep") == TRUE)
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
+			devtype = CONNMAN_DEVICE_TYPE_WIMAX;
+		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+		else
+			devtype = CONNMAN_DEVICE_TYPE_ETHERNET;
+
+		close(sk);
+	}
+
+	if (devtype == CONNMAN_DEVICE_TYPE_UNKNOWN) {
+		g_free(devname);
+		return;
+	}
+
+	name = index2ident(index, "dev_");
+
+	device = connman_device_create(name, devtype);
+	if (device == NULL) {
+		g_free(devname);
+		g_free(name);
+		return;
+	}
+
+	connman_device_set_index(device, index);
+	connman_device_set_interface(device, devname);
+
+	g_free(devname);
+	g_free(name);
+
+	if (connman_device_register(device) < 0) {
+		connman_device_unref(device);
+		return;
+	}
+
+	device_list = g_slist_append(device_list, device);
+}
+
+static void detect_dellink(unsigned short type, int index,
+					unsigned flags, unsigned change)
+{
+	struct connman_device *device;
+
+	DBG("index %d", index);
+
+	device = find_device(index);
+	if (device == NULL)
+		return;
+
+	device_list = g_slist_remove(device_list, device);
+
+	connman_device_unregister(device);
+	connman_device_unref(device);
+}
+
+static struct connman_rtnl detect_rtnl = {
+	.name		= "detect",
+	.priority	= CONNMAN_RTNL_PRIORITY_LOW,
+	.newlink	= detect_newlink,
+	.dellink	= detect_dellink,
+};
+
+int __connman_detect_init(void)
+{
+	int err;
+
+	err = connman_rtnl_register(&detect_rtnl);
+	if (err < 0)
+		return err;
+
+	connman_rtnl_send_getlink();
+
+	return 0;
+}
+
+void __connman_detect_cleanup(void)
+{
+	GSList *list;
+
+	connman_rtnl_unregister(&detect_rtnl);
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_device *device = list->data;
+
+		connman_device_unregister(device);
+		connman_device_unref(device);
+	}
+
+	g_slist_free(device_list);
+	device_list = NULL;
+}
diff --git a/src/element.c b/src/element.c
index fbed4f6b..9045c9ba 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1961,11 +1961,15 @@ void __connman_element_start(void)
 							probe_node, NULL);
 
 	started = TRUE;
+
+	__connman_detect_init();
 }
 
 void __connman_element_stop(void)
 {
 	DBG("");
+
+	__connman_detect_cleanup();
 }
 
 static gboolean free_driver(GNode *node, gpointer data)

commit a5a91a7189c48532309888a150e973fed1f12852
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 08:44:05 2008 +0100

    Remove unused statement

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2ef85439..19515e2a 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -26,8 +26,6 @@ dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 
 ipv4_la_SOURCES = ipv4.c
 
-rtnllink_la_SOURCES = rtnllink.c inet.h inet.c
-
 dnsproxy_la_SOURCES = dnsproxy.c
 
 resolvconf_la_SOURCES = resolvconf.c

commit 7e090d498e11ae435d973bea44e393a6e42beb3d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 08:54:35 2008 +0100

    Add basic detection of Option HSO devices

diff --git a/include/device.h b/include/device.h
index 95ffeeeb..172d9590 100644
--- a/include/device.h
+++ b/include/device.h
@@ -44,6 +44,7 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_MODEM     = CONNMAN_ELEMENT_SUBTYPE_MODEM,
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
+	CONNMAN_DEVICE_TYPE_HSO,
 };
 
 enum connman_device_mode {
diff --git a/src/detect.c b/src/detect.c
index 85fb077a..f6c66a79 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -135,7 +135,7 @@ static void detect_newlink(unsigned short type, int index,
 	struct connman_device *device;
 	gchar *name, *devname;
 
-	DBG("index %d", index);
+	DBG("type %d index %d", type, index);
 
 	device = find_device(index);
 	if (device != NULL)
@@ -171,6 +171,9 @@ static void detect_newlink(unsigned short type, int index,
 			devtype = CONNMAN_DEVICE_TYPE_ETHERNET;
 
 		close(sk);
+	} else if (type == ARPHRD_NONE) {
+		if (g_str_has_prefix(devname, "hso") == TRUE)
+			devtype = CONNMAN_DEVICE_TYPE_HSO;
 	}
 
 	if (devtype == CONNMAN_DEVICE_TYPE_UNKNOWN) {
@@ -206,7 +209,7 @@ static void detect_dellink(unsigned short type, int index,
 {
 	struct connman_device *device;
 
-	DBG("index %d", index);
+	DBG("type %d index %d", type, index);
 
 	device = find_device(index);
 	if (device == NULL)

commit 21a89f85e212d694db038a201aebbcccb90a3c5b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 09:03:59 2008 +0100

    Use interface name as device name for HSO devices

diff --git a/src/detect.c b/src/detect.c
index f6c66a79..f2d811d4 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -181,7 +181,14 @@ static void detect_newlink(unsigned short type, int index,
 		return;
 	}
 
-	name = index2ident(index, "dev_");
+	switch (devtype) {
+	case CONNMAN_DEVICE_TYPE_HSO:
+		name = strdup(devname);
+		break;
+	default:
+		name = index2ident(index, "dev_");
+		break;
+	}
 
 	device = connman_device_create(name, devtype);
 	if (device == NULL) {

commit d3327fdbc45b8c5509e5a680dca367c945e9bd47
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 09:05:02 2008 +0100

    Add skeleton for Option HSO driver

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 19515e2a..09ca6f7f 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,7 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = loopback.la netdev.la ethernet.la wifi.la \
-			bluetooth.la udhcp.la dhclient.la ipv4.la \
+			bluetooth.la hso.la udhcp.la dhclient.la ipv4.la \
 				dnsproxy.la resolvconf.la resolvfile.la
 
 loopback_la_SOURCES = loopback.c
@@ -17,6 +17,8 @@ wifi_la_LIBADD = @GDBUS_LIBS@
 bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
+hso_la_SOURCES = hso.c
+
 udhcp_la_SOURCES = udhcp.c
 udhcp_la_CFLAGS = @GLIB_CFLAGS@ -DUDHCPC=\"@UDHCPC@\"
 
diff --git a/plugins/hso.c b/plugins/hso.c
new file mode 100644
index 00000000..f42900f1
--- /dev/null
+++ b/plugins/hso.c
@@ -0,0 +1,60 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <connman/plugin.h>
+#include <connman/device.h>
+#include <connman/log.h>
+
+static int hso_probe(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static void hso_remove(struct connman_device *device)
+{
+	DBG("device %p", device);
+}
+
+static struct connman_device_driver hso_driver = {
+	.name		= "hso",
+	.type		= CONNMAN_DEVICE_TYPE_HSO,
+	.probe		= hso_probe,
+	.remove		= hso_remove,
+};
+
+static int hso_init(void)
+{
+	return connman_device_driver_register(&hso_driver);
+}
+
+static void hso_exit(void)
+{
+	connman_device_driver_unregister(&hso_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE(hso, "Option HSO device plugin", VERSION,
+						hso_init, hso_exit)

commit f0444b7be4f6b38137796489b2c6a258b431af27
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 27 10:33:06 2008 +0100

    Classify HSO devices as cellular

diff --git a/src/device.c b/src/device.c
index d884a3f9..8f5def7a 100644
--- a/src/device.c
+++ b/src/device.c
@@ -56,6 +56,8 @@ static const char *type2description(enum connman_device_type type)
 		return "WiMAX";
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "Bluetooth";
+	case CONNMAN_DEVICE_TYPE_HSO:
+		return "Cellular";
 	default:
 		return NULL;
 	}
@@ -74,6 +76,8 @@ static const char *type2string(enum connman_device_type type)
 		return "modem";
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "bluetooth";
+	case CONNMAN_DEVICE_TYPE_HSO:
+		return "cellular";
 	default:
 		return NULL;
 	}

commit c867b6b07870792c5efe275e2f79cb9ba9595164
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:13:50 2008 +0100

    Add manual policy to device settings

diff --git a/doc/device-api.txt b/doc/device-api.txt
index 7d1b86fc..6d8f348a 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -63,21 +63,29 @@ Properties	string Name [readonly]
 
 		string Policy [readwrite]
 
-			Setting of the device power policy. Possible values
-			are "off", "ignore" and "auto".
+			Setting of the device power and connection policy.
+			Possible values are "ignore", "off", "auto"
+			and "manual".
 
 			The policy defines on how the device is initialized
-			when brought up. The actual device power state can
-			be changed independently to this value.
+			when brought up and how it connects. The actual
+			device power state can be changed independently to
+			this value.
 
 			If a device is switched off and the policy is changed
-			to "auto", the device will be switched. For a current
-			active device changing the policy to "off" results
-			in powering down the device.
+			to "auto" or "manual", the device will be switched
+			on. For a current active device changing the policy
+			to "off" results in powering down the device.
 
 			The "ignore" policy can be set for devices that are
 			detected, but managed by a different entity on the
-			system. For example complex network setups.
+			system. For example for complex network setups.
+
+			Devices that can connect to various networks, the
+			difference between "auto" or "manual" defines if
+			known networks are connected automatically or not.
+			For simple devices like Ethernet cards, setting
+			the "manual" policy might fail.
 
 		boolean Powered [readwrite]
 
diff --git a/include/device.h b/include/device.h
index 172d9590..b282d032 100644
--- a/include/device.h
+++ b/include/device.h
@@ -56,8 +56,9 @@ enum connman_device_mode {
 enum connman_device_policy {
 	CONNMAN_DEVICE_POLICY_UNKNOWN = 0,
 	CONNMAN_DEVICE_POLICY_IGNORE  = 1,
-	CONNMAN_DEVICE_POLICY_AUTO    = 2,
-	CONNMAN_DEVICE_POLICY_OFF     = 3,
+	CONNMAN_DEVICE_POLICY_OFF     = 2,
+	CONNMAN_DEVICE_POLICY_AUTO    = 3,
+	CONNMAN_DEVICE_POLICY_MANUAL  = 4,
 };
 
 struct connman_device;
diff --git a/src/device.c b/src/device.c
index 8f5def7a..0a7fe053 100644
--- a/src/device.c
+++ b/src/device.c
@@ -88,10 +88,12 @@ static const char *policy2string(enum connman_device_policy policy)
 	switch (policy) {
 	case CONNMAN_DEVICE_POLICY_IGNORE:
 		return "ignore";
-	case CONNMAN_DEVICE_POLICY_AUTO:
-		return "auto";
 	case CONNMAN_DEVICE_POLICY_OFF:
 		return "off";
+	case CONNMAN_DEVICE_POLICY_AUTO:
+		return "auto";
+	case CONNMAN_DEVICE_POLICY_MANUAL:
+		return "manual";
 	default:
 		return NULL;
 	}

commit c5d973cf54a9fe54ec4e82a5780144b3b1f0afb0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:18:36 2008 +0100

    Add function to change initial policy setting

diff --git a/include/device.h b/include/device.h
index b282d032..6d172e80 100644
--- a/include/device.h
+++ b/include/device.h
@@ -78,6 +78,8 @@ extern void connman_device_set_interface(struct connman_device *device,
 							const char *interface);
 extern const char *connman_device_get_interface(struct connman_device *device);
 
+extern void connman_device_set_policy(struct connman_device *device,
+					enum connman_device_policy policy);
 extern void connman_device_set_mode(struct connman_device *device,
 						enum connman_device_mode mode);
 
diff --git a/src/device.c b/src/device.c
index 0a7fe053..d74b6349 100644
--- a/src/device.c
+++ b/src/device.c
@@ -575,6 +575,19 @@ const char *connman_device_get_interface(struct connman_device *device)
 	return device->interface;
 }
 
+/**
+ * connman_device_set_policy:
+ * @device: device structure
+ * @policy: power and connection policy
+ *
+ * Change power and connection policy of device
+ */
+void connman_device_set_policy(struct connman_device *device,
+					enum connman_device_policy policy)
+{
+	device->policy = policy;
+}
+
 /**
  * connman_device_set_mode:
  * @device: device structure

commit f1ccee1d9e378a3a0fe8d75afc947d5d42ce0aa1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:22:14 2008 +0100

    Set manual policy for Bluetooth and HSO devices as default

diff --git a/src/detect.c b/src/detect.c
index f2d811d4..bac075b3 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -197,6 +197,15 @@ static void detect_newlink(unsigned short type, int index,
 		return;
 	}
 
+	switch (devtype) {
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_HSO:
+		connman_device_set_policy(device, CONNMAN_DEVICE_POLICY_MANUAL);
+		break;
+	default:
+		break;
+	}
+
 	connman_device_set_index(device, index);
 	connman_device_set_interface(device, devname);
 

commit 0e0df318a9d596ebe32f6691418e99f2eb750e40
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:25:37 2008 +0100

    Enable devices when policy is set to manual

diff --git a/src/device.c b/src/device.c
index d74b6349..854fc173 100644
--- a/src/device.c
+++ b/src/device.c
@@ -833,7 +833,8 @@ static void device_enable(struct connman_device *device)
 {
 	DBG("device %p", device);
 
-	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
+	if (device->policy == CONNMAN_DEVICE_POLICY_IGNORE ||
+				device->policy == CONNMAN_DEVICE_POLICY_OFF)
 		return;
 
 	if (device->powered == TRUE)
@@ -847,7 +848,7 @@ static void device_disable(struct connman_device *device)
 {
 	DBG("device %p", device);
 
-	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
+	if (device->policy == CONNMAN_DEVICE_POLICY_IGNORE)
 		return;
 
 	if (device->powered == FALSE)

commit dba2854c4a36e8848aeec7b1e7d8c24b17147222
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:54:09 2008 +0100

    Add test script for changing device policy

diff --git a/test/Makefile.am b/test/Makefile.am
index 30546b9c..f39d13e2 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -3,6 +3,6 @@ EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
 		set-passphrase set-address simple-agent show-introspection \
-		test-manager test-compat monitor-connman
+		set-policy test-manager test-compat monitor-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/set-policy b/test/set-policy
new file mode 100755
index 00000000..5f26690a
--- /dev/null
+++ b/test/set-policy
@@ -0,0 +1,28 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 3):
+	print "Usage: %s <device> <policy>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	if properties["Interface"] != sys.argv[1]:
+		continue;
+
+	print "Setting policy \"%s\" for %s" % (sys.argv[2], path)
+
+	device.SetProperty("Policy", sys.argv[2])

commit 9f5303e643adbfeb9a636c0f800509ebfd33f66c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:58:21 2008 +0100

    Add device argument to enable and disable scripts

diff --git a/test/disable-device b/test/disable-device
index 31e9f951..7aadab01 100755
--- a/test/disable-device
+++ b/test/disable-device
@@ -1,7 +1,12 @@
 #!/usr/bin/python
 
+import sys
 import dbus
 
+if (len(sys.argv) < 2):
+	print "Usage: %s <device>" % (sys.argv[0])
+	sys.exit(1)
+
 bus = dbus.SystemBus()
 
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
@@ -15,9 +20,9 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
-	if (properties["Powered"] == dbus.Boolean(0)):
-		continue
+	if properties["Interface"] != sys.argv[1]:
+		continue;
 
-	print "[ %s ]" % (path)
+	print "Disabling device %s" % (path)
 
 	device.SetProperty("Powered", dbus.Boolean(0));
diff --git a/test/enable-device b/test/enable-device
index e79b7361..b5b1a9cc 100755
--- a/test/enable-device
+++ b/test/enable-device
@@ -1,7 +1,12 @@
 #!/usr/bin/python
 
+import sys
 import dbus
 
+if (len(sys.argv) < 2):
+	print "Usage: %s <device>" % (sys.argv[0])
+	sys.exit(1)
+
 bus = dbus.SystemBus()
 
 manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
@@ -15,9 +20,9 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
-	if (properties["Powered"] == dbus.Boolean(1)):
-		continue
+	if properties["Interface"] != sys.argv[1]:
+		continue;
 
-	print "[ %s ]" % (path)
+	print "Enabling device %s" % (path)
 
 	device.SetProperty("Powered", dbus.Boolean(1));

commit 4ce9f90d4d689d492cd9650e55bf615699e1616f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 02:59:16 2008 +0100

    Add support for changing policy over D-Bus

diff --git a/src/device.c b/src/device.c
index 854fc173..ef899332 100644
--- a/src/device.c
+++ b/src/device.c
@@ -99,6 +99,20 @@ static const char *policy2string(enum connman_device_policy policy)
 	}
 }
 
+static enum connman_device_policy string2policy(const char *policy)
+{
+	if (g_str_equal(policy, "ignore") == TRUE)
+		return CONNMAN_DEVICE_POLICY_IGNORE;
+	else if (g_str_equal(policy, "off") == TRUE)
+		return CONNMAN_DEVICE_POLICY_OFF;
+	else if (g_str_equal(policy, "auto") == TRUE)
+		return CONNMAN_DEVICE_POLICY_AUTO;
+	else if (g_str_equal(policy, "manual") == TRUE)
+		return CONNMAN_DEVICE_POLICY_MANUAL;
+	else
+		return CONNMAN_DEVICE_POLICY_UNKNOWN;
+}
+
 static int set_powered(struct connman_device *device, gboolean powered)
 {
 	struct connman_device_driver *driver = device->driver;
@@ -124,6 +138,60 @@ static int set_powered(struct connman_device *device, gboolean powered)
 	return err;
 }
 
+static int set_policy(DBusConnection *connection,
+				struct connman_device *device,
+					enum connman_device_policy policy)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *str, *key = "Policy";
+	int err = 0;
+
+	DBG("device %p policy %d", device, policy);
+
+	if (device->policy == policy)
+		return 0;
+
+	switch (policy) {
+	case CONNMAN_DEVICE_POLICY_OFF:
+		if (device->powered == TRUE)
+			err = set_powered(device, FALSE);
+		break;
+	case CONNMAN_DEVICE_POLICY_AUTO:
+	case CONNMAN_DEVICE_POLICY_MANUAL:
+		if (device->powered == FALSE)
+			err = set_powered(device, TRUE);
+		break;
+	default:
+		break;
+	}
+
+	if (err < 0)
+		return err;
+
+	device->policy = policy;
+
+	signal = dbus_message_new_signal(device->element.path,
+				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return 0;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	str = policy2string(policy);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_STRING_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, &str);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+
+	return 0;
+}
+
 static void append_networks(struct connman_device *device,
 						DBusMessageIter *entry)
 {
@@ -239,6 +307,19 @@ static DBusMessage *set_property(DBusConnection *conn,
 		err = set_powered(device, powered);
 		if (err < 0 && err != -EINPROGRESS)
 			return __connman_error_failed(msg);
+	} else if (g_str_equal(name, "Policy") == TRUE) {
+		enum connman_device_policy policy;
+		const char *str;
+		int err;
+
+		dbus_message_iter_get_basic(&value, &str);
+		policy = string2policy(str);
+		if (policy == CONNMAN_DEVICE_POLICY_UNKNOWN)
+			return __connman_error_invalid_arguments(msg);
+
+		err = set_policy(conn, device, policy);
+		if (err < 0)
+			return __connman_error_failed(msg);
 	}
 
 	__connman_element_store(&device->element);

commit 6877247bb62d3492570a4ee4c134f495cb680e92
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 03:14:53 2008 +0100

    Use manual policy as default

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 46f8f421..8993ca66 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -421,6 +421,7 @@ static void adapter_properties(DBusConnection *connection, const char *path,
 
 	connman_device_set_interface(adapter, node);
 
+	connman_device_set_policy(adapter, CONNMAN_DEVICE_POLICY_MANUAL);
 	connman_device_set_mode(adapter, CONNMAN_DEVICE_MODE_MULTIPLE_NETWORKS);
 
 	if (connman_device_register(adapter) < 0) {

commit 1c74d1d740d16d2ede335693052b52342717b5d8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 03:29:31 2008 +0100

    Add helpers for ifup and ifdown

diff --git a/plugins/inet.c b/plugins/inet.c
index ab0fcdcd..e3fedfb9 100644
--- a/plugins/inet.c
+++ b/plugins/inet.c
@@ -105,3 +105,85 @@ char *inet_index2ident(int index, const char *prefix)
 
 	return str;
 }
+
+int inet_ifup(int index)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ifr.ifr_flags & IFF_UP) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags |= IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}
+
+int inet_ifdown(int index)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -errno;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
+		err = -errno;
+		goto done;
+	}
+
+	if (!(ifr.ifr_flags & IFF_UP)) {
+		err = -EALREADY;
+		goto done;
+	}
+
+	ifr.ifr_flags &= ~IFF_UP;
+
+	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
+		err = -errno;
+	else
+		err = 0;
+
+done:
+	close(sk);
+
+	return err;
+}
diff --git a/plugins/inet.h b/plugins/inet.h
index afa80253..3246cc13 100644
--- a/plugins/inet.h
+++ b/plugins/inet.h
@@ -21,3 +21,6 @@
 
 char *inet_index2name(int index);
 char *inet_index2ident(int index, const char *prefix);
+
+int inet_ifup(int index);
+int inet_ifdown(int index);

commit b972ec96236afc662b21ace09d6adaa29d222411
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 03:30:12 2008 +0100

    Use helpers for ifup and ifdown

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 09ca6f7f..b71e6b9c 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -9,7 +9,7 @@ loopback_la_SOURCES = loopback.c
 
 netdev_la_SOURCES = netdev.c
 
-ethernet_la_SOURCES = ethernet.c
+ethernet_la_SOURCES = ethernet.c inet.h inet.c
 
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 08cfb4fe..5ddc7653 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -36,6 +36,8 @@
 #include <connman/rtnl.h>
 #include <connman/log.h>
 
+#include "inet.h"
+
 struct ethernet_data {
 	int index;
 	unsigned flags;
@@ -90,92 +92,6 @@ static struct connman_rtnl ethernet_rtnl = {
 	.newlink	= ethernet_newlink,
 };
 
-static int iface_up(struct ethernet_data *ethernet)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	DBG("index %d flags %d", ethernet->index, ethernet->flags);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -errno;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = ethernet->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (ifr.ifr_flags & IFF_UP) {
-		err = -EALREADY;
-		goto done;
-	}
-
-	ifr.ifr_flags |= IFF_UP;
-
-	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	err = 0;
-
-done:
-	close(sk);
-
-	return err;
-}
-
-static int iface_down(struct ethernet_data *ethernet)
-{
-	struct ifreq ifr;
-	int sk, err;
-
-	DBG("index %d flags %d", ethernet->index, ethernet->flags);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -errno;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = ethernet->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (ioctl(sk, SIOCGIFFLAGS, &ifr) < 0) {
-		err = -errno;
-		goto done;
-	}
-
-	if (!(ifr.ifr_flags & IFF_UP)) {
-		err = -EALREADY;
-		goto done;
-	}
-
-	ifr.ifr_flags &= ~IFF_UP;
-
-	if (ioctl(sk, SIOCSIFFLAGS, &ifr) < 0)
-		err = -errno;
-	else
-		err = 0;
-
-done:
-	close(sk);
-
-	return err;
-}
-
 static int ethernet_probe(struct connman_device *device)
 {
 	struct ethernet_data *ethernet;
@@ -216,7 +132,7 @@ static int ethernet_enable(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	return iface_up(ethernet);
+	return inet_ifup(ethernet->index);
 }
 
 static int ethernet_disable(struct connman_device *device)
@@ -225,7 +141,7 @@ static int ethernet_disable(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	return iface_down(ethernet);
+	return inet_ifdown(ethernet->index);
 }
 
 static struct connman_device_driver ethernet_driver = {

commit 2e2686dc1b229252fae150bfe97d1c3010563eb9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 06:18:29 2008 +0100

    Add helper for getting index from interface names

diff --git a/plugins/inet.c b/plugins/inet.c
index e3fedfb9..97f338ec 100644
--- a/plugins/inet.c
+++ b/plugins/inet.c
@@ -35,6 +35,31 @@
 
 #include "inet.h"
 
+int inet_name2index(const char *name)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	if (name == NULL)
+		return -1;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
+
+	err = ioctl(sk, SIOCGIFINDEX, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return -1;
+
+	return ifr.ifr_ifindex;
+}
+
 char *inet_index2name(int index)
 {
 	struct ifreq ifr;
diff --git a/plugins/inet.h b/plugins/inet.h
index 3246cc13..23437ac5 100644
--- a/plugins/inet.h
+++ b/plugins/inet.h
@@ -19,6 +19,8 @@
  *
  */
 
+int inet_name2index(const char *name);
+
 char *inet_index2name(int index);
 char *inet_index2ident(int index, const char *prefix);
 

commit e0a0733fe56afa691e93e9e396a7fbbed6ae1002
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 06:30:56 2008 +0100

    Add helpers for task handling

diff --git a/plugins/task.c b/plugins/task.c
new file mode 100644
index 00000000..dae54c75
--- /dev/null
+++ b/plugins/task.c
@@ -0,0 +1,145 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <unistd.h>
+#include <sys/wait.h>
+
+#include <glib.h>
+
+#include <connman/log.h>
+
+#include "task.h"
+
+struct task_data {
+	pid_t pid;
+	int index;
+	task_cb_t callback;
+	void *user_data;
+};
+
+static GSList *task_list = NULL;
+
+struct task_data *task_find_by_pid(pid_t pid)
+{
+	GSList *list;
+
+	for (list = task_list; list; list = list->next) {
+		struct task_data *task = list->data;
+
+		if (task->pid == pid)
+			return task;
+	}
+
+	return NULL;
+}
+
+struct task_data *task_find_by_index(int index)
+{
+	GSList *list;
+
+	for (list = task_list; list; list = list->next) {
+		struct task_data *task = list->data;
+
+		if (task->index == index)
+			return task;
+	}
+
+	return NULL;
+}
+
+static void task_died(GPid pid, gint status, gpointer user_data)
+{
+	struct task_data *task = user_data;
+
+	if (WIFEXITED(status))
+		DBG("task %p exit status %d", task, WEXITSTATUS(status));
+	else
+		DBG("task %p signal %d", task, WTERMSIG(status));
+
+	g_spawn_close_pid(pid);
+	task->pid = 0;
+
+	task_list = g_slist_remove(task_list, task);
+
+	if (task->callback)
+		task->callback(task->index, task->user_data);
+
+	g_free(task);
+}
+
+static void task_setup(gpointer user_data)
+{
+	struct task_data *task = user_data;
+
+	DBG("task %p", task);
+}
+
+struct task_data *task_spawn(int index, char **argv, char **envp,
+					task_cb_t callback, void *user_data)
+{
+	GSpawnFlags flags = G_SPAWN_DO_NOT_REAP_CHILD |
+						G_SPAWN_STDOUT_TO_DEV_NULL;
+	struct task_data *task;
+
+	DBG("index %d", index);
+
+	task = g_try_new0(struct task_data, 1);
+	if (task == NULL)
+		return NULL;
+
+	task->index = index;
+
+	task->callback  = callback;
+	task->user_data = user_data;
+
+	if (g_spawn_async(NULL, argv, envp, flags,
+				task_setup, task, &task->pid, NULL) == FALSE) {
+		connman_error("Failed to spawn task");
+		return NULL;
+	}
+
+	task_list = g_slist_append(task_list, task);
+
+	g_child_watch_add(task->pid, task_died, task);
+
+	DBG("task %p pid %d", task, task->pid);
+
+	return task;
+}
+
+int task_kill(struct task_data *task)
+{
+	DBG("task %p", task);
+
+	if (task->pid > 0)
+		kill(task->pid, SIGTERM);
+
+	return 0;
+}
+
+void *task_get_data(struct task_data *task)
+{
+	return task->user_data;
+}
diff --git a/plugins/task.h b/plugins/task.h
new file mode 100644
index 00000000..0234d47a
--- /dev/null
+++ b/plugins/task.h
@@ -0,0 +1,35 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <sys/types.h>
+
+struct task_data;
+
+typedef void (* task_cb_t) (int index, void *user_data);
+
+struct task_data *task_find_by_pid(pid_t pid);
+struct task_data *task_find_by_index(int index);
+
+struct task_data *task_spawn(int index, char **argv, char **envp,
+					task_cb_t callback, void *user_data);
+int task_kill(struct task_data *task);
+
+void *task_get_data(struct task_data *task);

commit 4d49d7072590206594f1f6e2e591b8bd9e25712e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 06:37:25 2008 +0100

    Add initial implementation for uDHCP support

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index b71e6b9c..f616c0d0 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -19,8 +19,9 @@ bluetooth_la_LIBADD = @GDBUS_LIBS@
 
 hso_la_SOURCES = hso.c
 
-udhcp_la_SOURCES = udhcp.c
-udhcp_la_CFLAGS = @GLIB_CFLAGS@ -DUDHCPC=\"@UDHCPC@\"
+udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
+udhcp_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DUDHCPC=\"@UDHCPC@\" \
+		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index dd7dd8cd..597488d4 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -23,20 +23,73 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <unistd.h>
+
 #include <connman/plugin.h>
 #include <connman/driver.h>
+#include <connman/dbus.h>
 #include <connman/log.h>
 
+#include "inet.h"
+#include "task.h"
+
+#define UDHCPC_INTF  "org.busybox.udhcpc"
+#define UDHCPC_PATH  "/org/busybox/udhcpc"
+
 static int udhcp_probe(struct connman_element *element)
 {
+	struct task_data *task;
+	char *argv[9], *envp[2], *ifname;
+	char pidfile[PATH_MAX], script[PATH_MAX];
+
 	DBG("element %p name %s", element, element->name);
 
-	return -ENODEV;
+	if (access(UDHCPC, X_OK) < 0)
+		return -errno;
+
+	ifname = inet_index2name(element->index);
+	if (ifname == NULL)
+		return -ENOMEM;
+
+	snprintf(pidfile, sizeof(pidfile) - 1,
+				"%s/udhcpc.%s.pid", STATEDIR, ifname);
+	snprintf(script, sizeof(script) - 1, "%s/udhcpc-script", SCRIPTDIR);
+
+	argv[0] = UDHCPC;
+	argv[1] = "-f";
+	argv[2] = "-i";
+	argv[3] = ifname;
+	argv[4] = "-p";
+	argv[5] = pidfile;
+	argv[6] = "-s";
+	argv[7] = script;
+	argv[8] = NULL;
+
+	envp[0] = NULL;
+
+	task = task_spawn(element->index, argv, envp, NULL, element);
+	if (task == NULL) {
+		g_free(ifname);
+		return -EIO;
+	}
+
+	g_free(ifname);
+
+	return 0;
 }
 
 static void udhcp_remove(struct connman_element *element)
 {
+	struct task_data *task;
+
 	DBG("element %p name %s", element, element->name);
+
+	task = task_find_by_index(element->index);
+	if (task == NULL)
+		return;
+
+	task_kill(task);
 }
 
 static struct connman_driver udhcp_driver = {
@@ -47,14 +100,114 @@ static struct connman_driver udhcp_driver = {
 	.remove		= udhcp_remove,
 };
 
+static void udhcp_bound(DBusMessage *msg, gboolean renew)
+{
+	struct task_data *task;
+	struct connman_element *element, *parent;
+	const char *interface, *address, *netmask, *broadcast, *gateway, *dns;
+	int index;
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &interface,
+					DBUS_TYPE_STRING, &address,
+					DBUS_TYPE_STRING, &netmask,
+					DBUS_TYPE_STRING, &broadcast,
+					DBUS_TYPE_STRING, &gateway,
+					DBUS_TYPE_STRING, &dns,
+							DBUS_TYPE_INVALID);
+
+	DBG("%s ==> address %s gateway %s", interface, address, gateway);
+
+	index = inet_name2index(interface);
+	if (index < 0)
+		return;
+
+	task = task_find_by_index(index);
+	if (task == NULL)
+		return;
+
+	parent = task_get_data(task);
+	if (parent == NULL)
+		return;
+
+	g_free(parent->ipv4.address);
+	parent->ipv4.address = g_strdup(address);
+
+	g_free(parent->ipv4.netmask);
+	parent->ipv4.netmask = g_strdup(netmask);
+
+	g_free(parent->ipv4.broadcast);
+	parent->ipv4.broadcast = g_strdup(broadcast);
+
+	g_free(parent->ipv4.gateway);
+	parent->ipv4.gateway = g_strdup(gateway);
+
+	g_free(parent->ipv4.nameserver);
+	parent->ipv4.nameserver = g_strdup(dns);
+
+	connman_element_update(parent);
+
+	if (renew == TRUE)
+		return;
+
+	element = connman_element_create(NULL);
+	if (element == NULL)
+		return;
+
+	element->type = CONNMAN_ELEMENT_TYPE_IPV4;
+	element->index = index;
+
+	if (connman_element_register(element, parent) < 0)
+		connman_element_unref(element);
+}
+
+static DBusHandlerResult udhcp_filter(DBusConnection *conn,
+						DBusMessage *msg, void *data)
+{
+	if (dbus_message_is_method_call(msg, UDHCPC_INTF, "bound") == TRUE) {
+		udhcp_bound(msg, FALSE);
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+
+	if (dbus_message_is_method_call(msg, UDHCPC_INTF, "renew") == TRUE) {
+		udhcp_bound(msg, TRUE);
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static DBusConnection *connection;
+
+static const char *udhcp_rule = "path=" UDHCPC_PATH ",interface=" UDHCPC_INTF;
+
 static int udhcp_init(void)
 {
-	return connman_driver_register(&udhcp_driver);
+	int err;
+
+	connection = connman_dbus_get_connection();
+
+	dbus_connection_add_filter(connection, udhcp_filter, NULL, NULL);
+
+	dbus_bus_add_match(connection, udhcp_rule, NULL);
+
+	err = connman_driver_register(&udhcp_driver);
+	if (err < 0) {
+		dbus_connection_unref(connection);
+		return err;
+	}
+
+	return 0;
 }
 
 static void udhcp_exit(void)
 {
 	connman_driver_unregister(&udhcp_driver);
+
+	dbus_bus_remove_match(connection, udhcp_rule, NULL);
+
+	dbus_connection_remove_filter(connection, udhcp_filter, NULL);
+
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE(dhclient, "uDHCP client plugin", VERSION,
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 1247398f..b28f64fe 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -9,7 +9,9 @@ scriptdir = $(libdir)/connman/scripts
 
 script_DATA = dhclient.conf
 
-script_PROGRAMS = dhclient-script
+script_PROGRAMS = udhcpc-script dhclient-script
+
+udhcpc_script_LDADD = @DBUS_LIBS@
 
 dhclient_script_LDADD = @DBUS_LIBS@
 
diff --git a/scripts/udhcpc-script.c b/scripts/udhcpc-script.c
new file mode 100644
index 00000000..c7a7ae21
--- /dev/null
+++ b/scripts/udhcpc-script.c
@@ -0,0 +1,97 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dbus/dbus.h>
+
+#define UDHCPC_INTF  "org.busybox.udhcpc"
+#define UDHCPC_PATH  "/org/busybox/udhcpc"
+
+int main(int argc, char *argv[])
+{
+	DBusConnection *conn;
+	DBusError error;
+	DBusMessage *msg;
+	char *busname, *interface, *address, *netmask, *broadcast;
+	char *gateway, *dns;
+
+	if (argc < 2)
+		return 0;
+
+	if (strcmp(argv[1], "bound") != 0 && strcmp(argv[1], "renew") != 0)
+		return 0;
+
+	busname = "org.moblin.connman";
+
+	interface = getenv("interface");
+
+	address = getenv("ip");
+	netmask = getenv("subnet");
+	broadcast = getenv("broadcast");
+	gateway = getenv("router");
+	dns = getenv("dns");
+
+	dbus_error_init(&error);
+
+	conn = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+	if (conn == NULL) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			fprintf(stderr, "%s\n", error.message);
+			dbus_error_free(&error);
+		} else
+			fprintf(stderr, "Failed to get on system bus\n");
+		return 0;
+	}
+
+	msg = dbus_message_new_method_call(busname, UDHCPC_PATH,
+						UDHCPC_INTF, argv[1]);
+	if (msg == NULL) {
+		dbus_connection_unref(conn);
+		fprintf(stderr, "Failed to allocate method call\n");
+		return 0;
+	}
+
+	dbus_message_set_no_reply(msg, TRUE);
+
+	dbus_message_append_args(msg, DBUS_TYPE_STRING, &interface,
+					DBUS_TYPE_STRING, &address,
+					DBUS_TYPE_STRING, &netmask,
+					DBUS_TYPE_STRING, &broadcast,
+					DBUS_TYPE_STRING, &gateway,
+					DBUS_TYPE_STRING, &dns,
+							DBUS_TYPE_INVALID);
+
+	if (dbus_connection_send(conn, msg, NULL) == FALSE)
+		fprintf(stderr, "Failed to send message\n");
+
+	dbus_message_unref(msg);
+
+	dbus_connection_unref(conn);
+
+	return 0;
+}

commit 62dd8d00c2f5b7bf19b44e7541aa419cd50dd104
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 07:21:07 2008 +0100

    Add missing includes

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 5ddc7653..7b5ca41a 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/ioctl.h>
@@ -31,6 +32,8 @@
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 
+#include <glib.h>
+
 #include <connman/plugin.h>
 #include <connman/device.h>
 #include <connman/rtnl.h>
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index daff3a23..d9075344 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -27,6 +27,8 @@
 #include <string.h>
 #include <dbus/dbus.h>
 
+#include <glib.h>
+
 #include <connman/log.h>
 #include <connman/dbus.h>
 
diff --git a/src/detect.c b/src/detect.c
index bac075b3..c6988df8 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -35,6 +35,8 @@
 #include <linux/if_arp.h>
 #include <linux/wireless.h>
 
+#include <glib.h>
+
 #include <connman/device.h>
 #include <connman/rtnl.h>
 #include <connman/log.h>

commit 94b1272c0d8f0c33d56765a0c51a0c49802853bd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 07:32:21 2008 +0100

    Fix list of device types

diff --git a/include/device.h b/include/device.h
index 6d172e80..7d26cc97 100644
--- a/include/device.h
+++ b/include/device.h
@@ -27,7 +27,6 @@ extern "C" {
 #endif
 
 #include <connman/network.h>
-#include <connman/element.h>
 
 /**
  * SECTION:device
@@ -36,15 +35,13 @@ extern "C" {
  */
 
 enum connman_device_type {
-	CONNMAN_DEVICE_TYPE_UNKNOWN   = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN,
-	CONNMAN_DEVICE_TYPE_FAKE      = CONNMAN_ELEMENT_SUBTYPE_FAKE,
-	CONNMAN_DEVICE_TYPE_ETHERNET  = CONNMAN_ELEMENT_SUBTYPE_ETHERNET,
-	CONNMAN_DEVICE_TYPE_WIFI      = CONNMAN_ELEMENT_SUBTYPE_WIFI,
-	CONNMAN_DEVICE_TYPE_WIMAX     = CONNMAN_ELEMENT_SUBTYPE_WIMAX,
-	CONNMAN_DEVICE_TYPE_MODEM     = CONNMAN_ELEMENT_SUBTYPE_MODEM,
-	CONNMAN_DEVICE_TYPE_BLUETOOTH = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH,
+	CONNMAN_DEVICE_TYPE_UNKNOWN   = 0,
+	CONNMAN_DEVICE_TYPE_ETHERNET  = 1,
+	CONNMAN_DEVICE_TYPE_WIFI      = 2,
+	CONNMAN_DEVICE_TYPE_WIMAX     = 3,
+	CONNMAN_DEVICE_TYPE_BLUETOOTH = 4,
+	CONNMAN_DEVICE_TYPE_HSO       = 11,
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
-	CONNMAN_DEVICE_TYPE_HSO,
 };
 
 enum connman_device_mode {
diff --git a/src/device.c b/src/device.c
index ef899332..ec453e98 100644
--- a/src/device.c
+++ b/src/device.c
@@ -72,8 +72,6 @@ static const char *type2string(enum connman_device_type type)
 		return "wifi";
 	case CONNMAN_DEVICE_TYPE_WIMAX:
 		return "wimax";
-	case CONNMAN_DEVICE_TYPE_MODEM:
-		return "modem";
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:

commit 724dd78ca41f3a77f4fa03d359d420d89dd92083
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 07:33:11 2008 +0100

    Add udhcpc-script to list of ignored files

diff --git a/.gitignore b/.gitignore
index 40db3806..9c29734e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -28,6 +28,7 @@ src/connman.exp
 src/connman.ver
 src/connman.service
 scripts/connman
+scripts/udhcpc-script
 scripts/dhclient-script
 client/cm
 doc/*.bak

commit 4c9720135427e44a128e80462acec3cf55eba31d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 07:40:50 2008 +0100

    Set correct subtype for transition period

diff --git a/src/device.c b/src/device.c
index ec453e98..590b9557 100644
--- a/src/device.c
+++ b/src/device.c
@@ -538,6 +538,15 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.type = CONNMAN_ELEMENT_TYPE_DEVICE;
 	device->element.index = -1;
 
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
+		break;
+	default:
+		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+		break;
+	}
+
 	device->element.device = device;
 	device->element.destruct = device_destruct;
 

commit 90f711afacfc4858639990ea003ec32a4cfafb83
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 07:44:30 2008 +0100

    Don't add policy to network objects

diff --git a/src/element.c b/src/element.c
index 9045c9ba..42e4e87e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -443,7 +443,6 @@ static DBusMessage *network_get_properties(DBusConnection *conn,
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -462,11 +461,6 @@ static DBusMessage *network_get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Device",
 				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
 
-	str = __connman_element_policy2string(element->policy);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Policy",
-						DBUS_TYPE_STRING, &str);
-
 	connman_dbus_dict_append_variant(&dict, "Available",
 					DBUS_TYPE_BOOLEAN, &element->available);
 

commit 51e0e521dc0e141716ba1e790ee441df8582655a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 08:58:37 2008 +0100

    Update D-Bus filter registration and removal

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 2cb4930a..04787d19 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -313,9 +313,11 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 
 static DBusConnection *connection;
 
+static const char *dhclient_rule = "path=" DHCLIENT_PATH
+						",interface=" DHCLIENT_INTF;
+
 static int dhclient_init(void)
 {
-	gchar *filter;
 	int err;
 
 	connection = connman_dbus_get_connection();
@@ -325,12 +327,7 @@ static int dhclient_init(void)
 
 	dbus_connection_add_filter(connection, dhclient_filter, NULL, NULL);
 
-	filter = g_strdup_printf("interface=%s,path=%s",
-						DHCLIENT_INTF, DHCLIENT_PATH);
-
-	dbus_bus_add_match(connection, filter, NULL);
-
-	g_free(filter);
+	dbus_bus_add_match(connection, dhclient_rule, NULL);
 
 	err = connman_driver_register(&dhclient_driver);
 	if (err < 0) {
@@ -358,6 +355,10 @@ static void dhclient_exit(void)
 
 	connman_driver_unregister(&dhclient_driver);
 
+	dbus_bus_remove_match(connection, dhclient_rule, NULL);
+
+	dbus_connection_remove_filter(connection, dhclient_filter, NULL);
+
 	dbus_connection_unref(connection);
 }
 

commit c2afe171cceb352419c379bc2c713931960a7549
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 09:15:43 2008 +0100

    Add cellular type to device's network list

diff --git a/test/list-networks b/test/list-networks
index d8958fb2..8b1ade1c 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -25,7 +25,8 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
-	if properties["Type"] not in ["wifi", "wimax", "bluetooth"]:
+	if properties["Type"] not in ["wifi", "wimax",
+					"bluetooth", "cellular"]:
 		continue;
 
 	print "[ %s ]" % (path)

commit a9a626186bf087a4ecf36ca31c473c13df34572d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 09:16:52 2008 +0100

    Set HSO devices to single network mode

diff --git a/src/detect.c b/src/detect.c
index c6988df8..9ede7dbb 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -200,9 +200,10 @@ static void detect_newlink(unsigned short type, int index,
 	}
 
 	switch (devtype) {
-	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
 		connman_device_set_policy(device, CONNMAN_DEVICE_POLICY_MANUAL);
+		connman_device_set_mode(device,
+					CONNMAN_DEVICE_MODE_SINGLE_NETWORK);
 		break;
 	default:
 		break;

commit c93def76c9179707bf020ec023fa010ec706984c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 10:06:38 2008 +0100

    Remove networks when device gets disabled

diff --git a/src/device.c b/src/device.c
index 590b9557..e92798e1 100644
--- a/src/device.c
+++ b/src/device.c
@@ -127,6 +127,8 @@ static int set_powered(struct connman_device *device, gboolean powered)
 		else
 			err = -EINVAL;
 	} else {
+		g_hash_table_remove_all(device->networks);
+
 		if (driver->disable)
 			err = driver->disable(device);
 		else
@@ -942,6 +944,8 @@ static void device_disable(struct connman_device *device)
 	if (device->powered == FALSE)
 		return;
 
+	g_hash_table_remove_all(device->networks);
+
 	if (device->driver->disable)
 		device->driver->disable(device);
 }

commit 1c690efa00cb22a07f0472fdd9a93859c2bc18d3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 10:14:25 2008 +0100

    Add network driver matching support

diff --git a/src/network.c b/src/network.c
index cfd30120..3e35a38d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -34,6 +34,47 @@ struct connman_network {
 	void *driver_data;
 };
 
+static GSList *driver_list = NULL;
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_network_driver *driver1 = a;
+	const struct connman_network_driver *driver2 = b;
+
+	return driver2->priority - driver1->priority;
+}
+
+/**
+ * connman_network_driver_register:
+ * @driver: network driver definition
+ *
+ * Register a new network driver
+ *
+ * Returns: %0 on success
+ */
+int connman_network_driver_register(struct connman_network_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	driver_list = g_slist_insert_sorted(driver_list, driver,
+							compare_priority);
+
+	return 0;
+}
+
+/**
+ * connman_network_driver_unregister:
+ * @driver: network driver definition
+ *
+ * Remove a previously registered network driver
+ */
+void connman_network_driver_unregister(struct connman_network_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	driver_list = g_slist_remove(driver_list, driver);
+}
+
 static void network_destruct(struct connman_element *element)
 {
 	struct connman_network *network = element->network;
@@ -138,13 +179,60 @@ void connman_network_set_data(struct connman_network *network, void *data)
 	network->driver_data = data;
 }
 
+static gboolean match_driver(struct connman_network *network,
+					struct connman_network_driver *driver)
+{
+	if (network->type == driver->type ||
+			driver->type == CONNMAN_NETWORK_TYPE_UNKNOWN)
+		return TRUE;
+
+	return FALSE;
+}
+
 static int network_probe(struct connman_element *element)
 {
+	struct connman_network *network = element->network;
+	GSList *list;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (network == NULL)
+		return -ENODEV;
+
+	for (list = driver_list; list; list = list->next) {
+		struct connman_network_driver *driver = list->data;
+
+		if (match_driver(network, driver) == FALSE)
+			continue;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		if (driver->probe(network) == 0) {
+			network->driver = driver;
+			break;
+		}
+	}
+
+	if (!network->driver)
+		return -ENODEV;
+
 	return 0;
 }
 
 static void network_remove(struct connman_element *element)
 {
+	struct connman_network *network = element->network;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (network == NULL)
+		return;
+
+	if (!network->driver)
+		return;
+
+	if (network->driver->remove)
+		network->driver->remove(network);
 }
 
 static struct connman_driver network_driver = {

commit 3916cb0b7a49b40863a340f6b4b62e1f61609dcb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 28 13:05:23 2008 +0100

    Only install mandatory header files

diff --git a/include/Makefile.am b/include/Makefile.am
index 40f07ebe..67dbbcf9 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,9 +1,9 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h security.h resolver.h driver.h \
-				element.h property.h rtnl.h dbus.h \
-						device.h network.h ipv4.h
+include_HEADERS = log.h plugin.h security.h resolver.h device.h network.h
+
+noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h
 
 MAINTAINERCLEANFILES = Makefile.in
 

commit 3753d353f974dfc7033a380d7d598c0cf821eeb8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Dec 29 09:36:39 2008 +0100

    Use the correct domain for uDHCP

diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index 597488d4..9ac8c89a 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -34,8 +34,8 @@
 #include "inet.h"
 #include "task.h"
 
-#define UDHCPC_INTF  "org.busybox.udhcpc"
-#define UDHCPC_PATH  "/org/busybox/udhcpc"
+#define UDHCPC_INTF  "net.busybox.udhcpc"
+#define UDHCPC_PATH  "/net/busybox/udhcpc"
 
 static int udhcp_probe(struct connman_element *element)
 {
diff --git a/scripts/udhcpc-script.c b/scripts/udhcpc-script.c
index c7a7ae21..04487609 100644
--- a/scripts/udhcpc-script.c
+++ b/scripts/udhcpc-script.c
@@ -29,8 +29,8 @@
 
 #include <dbus/dbus.h>
 
-#define UDHCPC_INTF  "org.busybox.udhcpc"
-#define UDHCPC_PATH  "/org/busybox/udhcpc"
+#define UDHCPC_INTF  "net.busybox.udhcpc"
+#define UDHCPC_PATH  "/net/busybox/udhcpc"
 
 int main(int argc, char *argv[])
 {

commit f2d194037974daa0f57a7c5943e1bede13f8e92b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 01:38:52 2008 +0100

    Add header file for common types

diff --git a/include/Makefile.am b/include/Makefile.am
index 67dbbcf9..67ffb4ed 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,8 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = log.h plugin.h security.h resolver.h device.h network.h
+include_HEADERS = types.h log.h plugin.h security.h resolver.h \
+						device.h network.h
 
 noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h
 
diff --git a/include/types.h b/include/types.h
new file mode 100644
index 00000000..f99ff079
--- /dev/null
+++ b/include/types.h
@@ -0,0 +1,43 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_TYPES_H
+#define __CONNMAN_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+typedef int	connman_bool_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_TYPES_H */

commit 0eb5877de5a276486a8aa9bf57efa3d4ec0714b1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 01:45:13 2008 +0100

    Make use of connman_bool_t type

diff --git a/include/device.h b/include/device.h
index 7d26cc97..8eba617b 100644
--- a/include/device.h
+++ b/include/device.h
@@ -26,6 +26,7 @@
 extern "C" {
 #endif
 
+#include <connman/types.h>
 #include <connman/network.h>
 
 /**
@@ -81,11 +82,11 @@ extern void connman_device_set_mode(struct connman_device *device,
 						enum connman_device_mode mode);
 
 extern int connman_device_set_powered(struct connman_device *device,
-							gboolean powered);
+						connman_bool_t powered);
 extern int connman_device_set_carrier(struct connman_device *device,
-							gboolean carrier);
+						connman_bool_t carrier);
 extern int connman_device_set_scanning(struct connman_device *device,
-							gboolean scanning);
+						connman_bool_t scanning);
 
 extern int connman_device_add_network(struct connman_device *device,
 					struct connman_network *network);
diff --git a/src/device.c b/src/device.c
index e92798e1..07129ba0 100644
--- a/src/device.c
+++ b/src/device.c
@@ -699,7 +699,7 @@ void connman_device_set_mode(struct connman_device *device,
  * Change power state of device
  */
 int connman_device_set_powered(struct connman_device *device,
-							gboolean powered)
+						connman_bool_t powered)
 {
 	DBusMessage *signal;
 	DBusMessageIter entry, value;
@@ -739,7 +739,7 @@ int connman_device_set_powered(struct connman_device *device,
  * Change carrier state of device (only for device without scanning)
  */
 int connman_device_set_carrier(struct connman_device *device,
-							gboolean carrier)
+						connman_bool_t carrier)
 {
 	DBG("driver %p carrier %d", device, carrier);
 
@@ -778,7 +778,7 @@ int connman_device_set_carrier(struct connman_device *device,
  * Change scanning state of device
  */
 int connman_device_set_scanning(struct connman_device *device,
-							gboolean scanning)
+						connman_bool_t scanning)
 {
 	DBusMessage *signal;
 	DBusMessageIter entry, value;

commit 1eb4abe7768b5c550ce63ed426b17ed523456285
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 01:58:23 2008 +0100

    Remove unused include of header file

diff --git a/include/security.h b/include/security.h
index 895464ab..a7806321 100644
--- a/include/security.h
+++ b/include/security.h
@@ -26,8 +26,6 @@
 extern "C" {
 #endif
 
-#include <connman/element.h>
-
 /**
  * SECTION:security
  * @title: Security premitives

commit 0f4ccc394ccc563eb895f2846f631a47a65afa96
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 01:59:45 2008 +0100

    Move header includes before declarations

diff --git a/include/device.h b/include/device.h
index 8eba617b..c9f6d767 100644
--- a/include/device.h
+++ b/include/device.h
@@ -22,13 +22,13 @@
 #ifndef __CONNMAN_DEVICE_H
 #define __CONNMAN_DEVICE_H
 
+#include <connman/types.h>
+#include <connman/network.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <connman/types.h>
-#include <connman/network.h>
-
 /**
  * SECTION:device
  * @title: Device premitives

commit 185b4d27799da050c7f823e922cafa7834e9713a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 02:10:26 2008 +0100

    Fix documentation details

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 4a52ec27..745841be 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -17,7 +17,7 @@ MKTMPL_OPTIONS = --output-dir=.
 HFILE_GLOB = $(top_srcdir)/include/*.h
 CFILE_GLOB = $(top_srcdir)/src/*.c $(top_srcdir)/src/*.h
 
-IGNORE_HFILES = connman connman.h rtnl.h dbus.h iface.h
+IGNORE_HFILES = connman connman.h
 
 HTML_IMAGES =
 
diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 8d51f3b6..518c6d15 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -103,6 +103,8 @@
     <xi:include href="xml/plugin.xml" />
     <xi:include href="xml/security.xml" />
     <xi:include href="xml/resolver.xml" />
+    <!-- <xi:include href="xml/device.xml" /> -->
+    <!-- <xi:include href="xml/network.xml" /> -->
   </reference>
 
   <appendix id="license">

commit d519532b450d131316351c701ab389e7015a4000
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 02:38:46 2008 +0100

    Add really simple plugin example to documentation

diff --git a/include/plugin.h b/include/plugin.h
index 587e9d76..941229d1 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -49,6 +49,22 @@ struct connman_plugin_desc {
  * @exit: exit function called on plugin removal
  *
  * Macro for defining a plugin descriptor
+ *
+ * |[
+ * #include <connman/plugin.h>
+ *
+ * static int example_init(void)
+ * {
+ * 	return 0;
+ * }
+ *
+ * static void example_exit(void)
+ * {
+ * }
+ *
+ * CONNMAN_PLUGIN_DEFINE(example, "Example plugin", VERSION,
+ * 					example_init, example_exit)
+ * ]|
  */
 #define CONNMAN_PLUGIN_DEFINE(name, description, version, init, exit) \
 		struct connman_plugin_desc connman_plugin_desc = { \

commit fd24c47b801a63ff9a16384adcf3c73f8e3a77d8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 03:45:08 2008 +0100

    Add initial support for Network interface

diff --git a/include/network.h b/include/network.h
index 292dd9f6..6d2f3b79 100644
--- a/include/network.h
+++ b/include/network.h
@@ -22,6 +22,9 @@
 #ifndef __CONNMAN_NETWORK_H
 #define __CONNMAN_NETWORK_H
 
+#include <connman/types.h>
+#include <connman/device.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -35,6 +38,7 @@ extern "C" {
 enum connman_network_type {
 	CONNMAN_NETWORK_TYPE_UNKNOWN = 0,
 	CONNMAN_NETWORK_TYPE_WIFI    = 1,
+	CONNMAN_NETWORK_TYPE_HSO     = 23,
 };
 
 struct connman_network;
@@ -46,6 +50,8 @@ extern void connman_network_unref(struct connman_network *network);
 
 extern const char *connman_network_get_identifier(struct connman_network *network);
 
+extern struct connman_device *connman_network_get_device(struct connman_network *network);
+
 extern void *connman_network_get_data(struct connman_network *network);
 extern void connman_network_set_data(struct connman_network *network, void *data);
 
@@ -55,6 +61,8 @@ struct connman_network_driver {
 	int priority;
 	int (*probe) (struct connman_network *network);
 	void (*remove) (struct connman_network *network);
+	int (*connect) (struct connman_network *network);
+	int (*disconnect) (struct connman_network *network);
 };
 
 extern int connman_network_driver_register(struct connman_network_driver *driver);
diff --git a/src/connman.h b/src/connman.h
index 55f78c0a..45cb1914 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -124,6 +124,9 @@ void __connman_device_cleanup(void);
 int __connman_network_init(void);
 void __connman_network_cleanup(void);
 
+void __connman_network_set_device(struct connman_network *network,
+					struct connman_device *device);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/device.c b/src/device.c
index 07129ba0..e466c0c0 100644
--- a/src/device.c
+++ b/src/device.c
@@ -836,6 +836,8 @@ int connman_device_add_network(struct connman_device *device,
 	if (err < 0)
 		return err;
 
+	__connman_network_set_device(network, device);
+
 	g_hash_table_insert(device->networks, g_strdup(identifier),
 								network);
 
diff --git a/src/network.c b/src/network.c
index 3e35a38d..d2448951 100644
--- a/src/network.c
+++ b/src/network.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <gdbus.h>
+
 #include "connman.h"
 
 struct connman_network {
@@ -32,8 +34,118 @@ struct connman_network {
 
 	struct connman_network_driver *driver;
 	void *driver_data;
+
+	struct connman_device *device;
 };
 
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessageIter iter, value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *do_connect(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBG("conn %p", conn);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *do_disconnect(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBG("conn %p", conn);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static GDBusMethodTable network_methods[] = {
+	{ "GetProperties", "",   "a{sv}", get_properties },
+	{ "SetProperty",   "sv", "",      set_property   },
+	{ "Connect",       "",   "",      do_connect     },
+	{ "Disconnect",    "",   "",      do_disconnect  },
+	{ },
+};
+
+static GDBusSignalTable network_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
+static DBusConnection *connection;
+
+static void emit_networks_signal(void)
+{
+}
+
+static int register_interface(struct connman_element *element)
+{
+	struct connman_network *network = element->network;
+
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_NETWORK_INTERFACE);
+
+	if (g_dbus_register_interface(connection, element->path,
+					CONNMAN_NETWORK_INTERFACE,
+					network_methods, network_signals,
+					NULL, network, NULL) == FALSE) {
+		connman_error("Failed to register %s network", element->path);
+		return -EIO;
+	}
+
+	emit_networks_signal();
+
+	return 0;
+}
+
+static void unregister_interface(struct connman_element *element)
+{
+	emit_networks_signal();
+
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_NETWORK_INTERFACE);
+}
+
 static GSList *driver_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -156,6 +268,23 @@ const char *connman_network_get_identifier(struct connman_network *network)
 	return network->identifier;
 }
 
+void __connman_network_set_device(struct connman_network *network,
+					struct connman_device *device)
+{
+	network->device = device;
+}
+
+/**
+ * connman_network_get_device:
+ * @network: network structure
+ *
+ * Get parent device of network
+ */
+struct connman_device *connman_network_get_device(struct connman_network *network)
+{
+	return network->device;
+}
+
 /**
  * connman_network_get_data:
  * @network: network structure
@@ -193,6 +322,7 @@ static int network_probe(struct connman_element *element)
 {
 	struct connman_network *network = element->network;
 	GSList *list;
+	int err;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -216,6 +346,13 @@ static int network_probe(struct connman_element *element)
 	if (!network->driver)
 		return -ENODEV;
 
+	err = register_interface(element);
+	if (err < 0) {
+		if (network->driver->remove)
+			network->driver->remove(network);
+		return err;
+	}
+
 	return 0;
 }
 
@@ -231,6 +368,8 @@ static void network_remove(struct connman_element *element)
 	if (!network->driver)
 		return;
 
+	unregister_interface(element);
+
 	if (network->driver->remove)
 		network->driver->remove(network);
 }
@@ -247,6 +386,8 @@ int __connman_network_init(void)
 {
 	DBG("");
 
+	connection = connman_dbus_get_connection();
+
 	return connman_driver_register(&network_driver);
 }
 
@@ -255,4 +396,6 @@ void __connman_network_cleanup(void)
 	DBG("");
 
 	connman_driver_unregister(&network_driver);
+
+	dbus_connection_unref(connection);
 }

commit 8e65bc5177df5ac686c04986ed60d54a98f11fb2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 06:01:45 2008 +0100

    Add CONNMAN_API_SUBJECT_TO_CHANGE definition

diff --git a/include/plugin.h b/include/plugin.h
index 941229d1..cbd1c12a 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -26,6 +26,11 @@
 extern "C" {
 #endif
 
+#ifndef CONNMAN_API_SUBJECT_TO_CHANGE
+#error "Please define CONNMAN_API_SUBJECT_TO_CHANGE to acknowledge your \
+understanding that ConnMan hasn't reached a stable API."
+#endif
+
 /**
  * SECTION:plugin
  * @title: Plugin premitives
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 8993ca66..1799f770 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -28,6 +28,7 @@
 
 #include <gdbus.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/device.h>
 #include <connman/dbus.h>
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 04787d19..20de09ac 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -27,6 +27,7 @@
 #include <sys/wait.h>
 #include <glib/gstdio.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/dbus.h>
diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index 39eefec8..e8df6bff 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -29,6 +29,7 @@
 #include <arpa/inet.h>
 #include <netinet/in.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/resolver.h>
 #include <connman/log.h>
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 7b5ca41a..434e3b77 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -34,6 +34,7 @@
 
 #include <glib.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/device.h>
 #include <connman/rtnl.h>
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index b7d79be8..33c73a42 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -35,6 +35,7 @@
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/resolver.h>
diff --git a/plugins/loopback.c b/plugins/loopback.c
index 29e6547e..7dc47fe7 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -31,6 +31,7 @@
 #include <arpa/inet.h>
 #include <net/if.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/log.h>
 
diff --git a/plugins/netdev.c b/plugins/netdev.c
index b32c12f0..24993019 100644
--- a/plugins/netdev.c
+++ b/plugins/netdev.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/log.h>
diff --git a/plugins/polkit.c b/plugins/polkit.c
index 1bf3f900..5396ad2f 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -28,6 +28,7 @@
 #include <glib.h>
 #include <polkit-dbus/polkit-dbus.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/security.h>
 #include <connman/dbus.h>
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 7dc12052..30002d5c 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -27,6 +27,7 @@
 #include <unistd.h>
 #include <stdlib.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/resolver.h>
 #include <connman/log.h>
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index 440656af..a9009814 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -30,6 +30,7 @@
 #include <string.h>
 #include <sys/stat.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/resolver.h>
 #include <connman/log.h>
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index d9075344..c51be358 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -29,6 +29,7 @@
 
 #include <glib.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/log.h>
 #include <connman/dbus.h>
 
diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index 9ac8c89a..2cc3c61f 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -26,6 +26,7 @@
 #include <stdio.h>
 #include <unistd.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/dbus.h>
diff --git a/plugins/wifi.c b/plugins/wifi.c
index ca39cecd..10541f28 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -33,6 +33,7 @@
 
 #include <gdbus.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/rtnl.h>
diff --git a/src/connman.h b/src/connman.h
index 45cb1914..948fe771 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -21,6 +21,8 @@
 
 #include <glib.h>
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+
 #include <connman/dbus.h>
 
 #define NM_SERVICE    "org.freedesktop.NetworkManager"
diff --git a/src/detect.c b/src/detect.c
index 9ede7dbb..e97e9df8 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -37,10 +37,6 @@
 
 #include <glib.h>
 
-#include <connman/device.h>
-#include <connman/rtnl.h>
-#include <connman/log.h>
-
 #include "connman.h"
 
 static GSList *device_list = NULL;

commit faac710ab9f791c28a46b299a08e2f9bb020b313
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 17:09:36 2008 +0100

    Add missing CONNMAN_API_SUBJECT_TO_CHANGE

diff --git a/plugins/hso.c b/plugins/hso.c
index f42900f1..ac851d8d 100644
--- a/plugins/hso.c
+++ b/plugins/hso.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/device.h>
 #include <connman/log.h>

commit e7b4ef1fb306580fa5bb0baabe83149d6f7d93dc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 19:48:44 2008 +0100

    Add initial general purpose modem helper

diff --git a/plugins/modem.c b/plugins/modem.c
new file mode 100644
index 00000000..b7701704
--- /dev/null
+++ b/plugins/modem.c
@@ -0,0 +1,273 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <string.h>
+#include <termios.h>
+
+#include <glib.h>
+
+#include <connman/log.h>
+
+#include "modem.h"
+
+struct modem_data {
+	char *device;
+	GIOChannel *channel;
+	GSList *commands;
+	char buf[1024];
+	int offset;
+};
+
+struct modem_cmd {
+	char *cmd;
+	char *arg;
+	modem_cb_t callback;
+	void *user_data;
+};
+
+static int send_command(struct modem_data *modem, struct modem_cmd *cmd)
+{
+	char *buf;
+	int fd, err;
+
+	if (cmd->arg == NULL) {
+		DBG("AT%s", cmd->cmd);
+		buf = g_strdup_printf("AT%s\r\n", cmd->cmd);
+	} else {
+		DBG("AT%s=%s", cmd->cmd, cmd->arg);
+		buf = g_strdup_printf("AT%s=%s\r\n", cmd->cmd, cmd->arg);
+	}
+
+	fd = g_io_channel_unix_get_fd(modem->channel);
+	err = write(fd, buf, strlen(buf));
+
+	fsync(fd);
+
+	g_free(buf);
+
+	return err;
+}
+
+static int queue_command(struct modem_data *modem, struct modem_cmd *cmd)
+{
+	modem->commands = g_slist_append(modem->commands, cmd);
+
+	if (g_slist_length(modem->commands) > 1)
+		return 0;
+
+	return send_command(modem, cmd);
+}
+
+struct modem_data *modem_create(const char *device)
+{
+	struct modem_data *modem;
+
+	DBG("device %s", device);
+
+	modem = g_try_new0(struct modem_data, 1);
+	if (modem == NULL)
+		return NULL;
+
+	modem->device = g_strdup(device);
+
+	DBG("modem %p", modem);
+
+	return modem;
+}
+
+void modem_destroy(struct modem_data *modem)
+{
+	DBG("modem %p", modem);
+
+	if (modem == NULL)
+		return;
+
+	g_free(modem->device);
+	g_free(modem);
+}
+
+static gboolean modem_event(GIOChannel *channel,
+				GIOCondition condition, gpointer user_data)
+{
+	struct modem_data *modem = user_data;
+	struct modem_cmd *cmd;
+	gsize len;
+	GIOError err;
+
+	if (condition & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))
+		return FALSE;
+
+	err = g_io_channel_read(channel, modem->buf + modem->offset,
+				sizeof(modem->buf) - modem->offset, &len);
+	if (err) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		return FALSE;
+	}
+
+	DBG("Read %d bytes (offset %d)", len, modem->offset);
+
+	if (g_strrstr(modem->buf, "\r\nERROR\r\n") == NULL &&
+				g_strrstr(modem->buf, "\r\nOK\r\n") == NULL) {
+		modem->offset += len;
+		return TRUE;
+	}
+
+	modem->offset = 0;
+
+	cmd = g_slist_nth_data(modem->commands, 0);
+	if (cmd == NULL)
+		return TRUE;
+
+	modem->commands = g_slist_remove(modem->commands, cmd);
+
+	DBG("AT%s", cmd->cmd);
+
+	if (cmd->callback)
+		cmd->callback(modem->buf, cmd->user_data);
+
+	g_free(cmd->arg);
+	g_free(cmd->cmd);
+	g_free(cmd);
+
+	cmd = g_slist_nth_data(modem->commands, 0);
+	if (cmd == NULL)
+		return TRUE;
+
+	send_command(modem, cmd);
+
+	return TRUE;
+}
+
+static int open_device(const char *device)
+{
+	struct termios ti;
+	int fd;
+
+	fd = open(device, O_RDWR | O_NOCTTY);
+	if (fd < 0)
+		return -1;
+
+	tcflush(fd, TCIOFLUSH);
+
+	/* Switch TTY to raw mode */
+	cfmakeraw(&ti);
+	tcsetattr(fd, TCSANOW, &ti);
+
+	return fd;
+}
+
+int modem_open(struct modem_data *modem)
+{
+	int fd, try = 5;
+
+	DBG("modem %p", modem);
+
+	if (modem == NULL)
+		return -ENOENT;
+
+	while (try-- > 0) {
+		fd = open_device(modem->device);
+		if (fd < 0) {
+			sleep(1);
+			continue;
+		}
+		try = 0;
+	}
+
+	if (fd < 0) {
+		connman_error("Can't open %s device", modem->device);
+		return -EIO;
+	}
+
+	modem->channel = g_io_channel_unix_new(fd);
+	g_io_channel_set_close_on_unref(modem->channel, TRUE);
+
+	g_io_add_watch(modem->channel,
+				G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
+							modem_event, modem);
+
+	return 0;
+}
+
+int modem_close(struct modem_data *modem)
+{
+	DBG("modem %p", modem);
+
+	if (modem == NULL)
+		return -ENOENT;
+
+	g_io_channel_shutdown(modem->channel, TRUE, NULL);
+	g_io_channel_unref(modem->channel);
+
+	modem->channel = NULL;
+
+	return 0;
+}
+
+static int modem_command_valist(struct modem_data *modem, modem_cb_t callback,
+					void *user_data, const char *command,
+					const char *format, va_list var_args)
+{
+	struct modem_cmd *cmd;
+
+	cmd = g_try_new0(struct modem_cmd, 1);
+	if (cmd == NULL)
+		return -ENOMEM;
+
+	cmd->cmd = g_strdup(command);
+	if (format != NULL)
+		cmd->arg = g_strdup_vprintf(format, var_args);
+
+	cmd->callback  = callback;
+	cmd->user_data = user_data;
+
+	return queue_command(modem, cmd);
+}
+
+int modem_command(struct modem_data *modem,
+				modem_cb_t callback, void *user_data,
+				const char *command, const char *format, ...)
+{
+	va_list args;
+	int err;
+
+	DBG("modem %p", modem);
+
+	if (modem == NULL)
+		return -ENOENT;
+
+	va_start(args, format);
+	err = modem_command_valist(modem, callback, user_data,
+						command, format, args);
+	va_end(args);
+
+	return err;
+}
diff --git a/plugins/modem.h b/plugins/modem.h
new file mode 100644
index 00000000..ef474d6c
--- /dev/null
+++ b/plugins/modem.h
@@ -0,0 +1,36 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+typedef struct modem_data modem_t;
+
+struct modem_data;
+
+struct modem_data *modem_create(const char *device);
+void modem_destroy(struct modem_data *modem);
+
+int modem_open(struct modem_data *modem);
+int modem_close(struct modem_data *modem);
+
+typedef void (* modem_cb_t) (const char *buf, void *user_data);
+
+int modem_command(struct modem_data *modem,
+				modem_cb_t callback, void *user_data,
+				const char *command, const char *format, ...);

commit eee11dfca5d8c21eaad3f1958a4db2483e634734
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 20:17:23 2008 +0100

    Add support for async events callbacks

diff --git a/plugins/modem.c b/plugins/modem.c
index b7701704..4668bd38 100644
--- a/plugins/modem.c
+++ b/plugins/modem.c
@@ -40,11 +40,18 @@
 struct modem_data {
 	char *device;
 	GIOChannel *channel;
+	GSList *callbacks;
 	GSList *commands;
 	char buf[1024];
 	int offset;
 };
 
+struct modem_callback {
+	char *command;
+	modem_cb_t function;
+	void *user_data;
+};
+
 struct modem_cmd {
 	char *cmd;
 	char *arg;
@@ -118,6 +125,7 @@ static gboolean modem_event(GIOChannel *channel,
 {
 	struct modem_data *modem = user_data;
 	struct modem_cmd *cmd;
+	GSList *list;
 	gsize len;
 	GIOError err;
 
@@ -134,12 +142,26 @@ static gboolean modem_event(GIOChannel *channel,
 
 	DBG("Read %d bytes (offset %d)", len, modem->offset);
 
+	if (g_str_has_suffix(modem->buf, "\r\n") == TRUE) {
+		for (list = modem->callbacks; list; list = list->next) {
+			struct modem_callback *callback = list->data;
+
+			if (callback->function == NULL)
+				continue;
+
+			if (g_strrstr(modem->buf, callback->command) != NULL)
+				callback->function(modem->buf,
+							callback->user_data);
+		}
+	}
+
 	if (g_strrstr(modem->buf, "\r\nERROR\r\n") == NULL &&
 				g_strrstr(modem->buf, "\r\nOK\r\n") == NULL) {
 		modem->offset += len;
 		return TRUE;
 	}
 
+	memset(modem->buf, 0, sizeof(modem->buf));
 	modem->offset = 0;
 
 	cmd = g_slist_nth_data(modem->commands, 0);
@@ -232,6 +254,24 @@ int modem_close(struct modem_data *modem)
 	return 0;
 }
 
+int modem_add_callback(struct modem_data *modem, const char *command,
+					modem_cb_t function, void *user_data)
+{
+	struct modem_callback *callback;
+
+	callback = g_try_new0(struct modem_callback, 1);
+	if (callback == NULL)
+		return -ENOMEM;
+
+	callback->command   = g_strdup(command);
+	callback->function  = function;
+	callback->user_data = user_data;
+
+	modem->callbacks = g_slist_append(modem->callbacks, callback);
+
+	return 0;
+}
+
 static int modem_command_valist(struct modem_data *modem, modem_cb_t callback,
 					void *user_data, const char *command,
 					const char *format, va_list var_args)
diff --git a/plugins/modem.h b/plugins/modem.h
index ef474d6c..6fabcb36 100644
--- a/plugins/modem.h
+++ b/plugins/modem.h
@@ -31,6 +31,9 @@ int modem_close(struct modem_data *modem);
 
 typedef void (* modem_cb_t) (const char *buf, void *user_data);
 
+int modem_add_callback(struct modem_data *modem, const char *command,
+					modem_cb_t function, void *user_data);
+
 int modem_command(struct modem_data *modem,
 				modem_cb_t callback, void *user_data,
 				const char *command, const char *format, ...);

commit 655c0e47d64295fd94fbd4bfb09539cb9300e300
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 20:19:00 2008 +0100

    Add more HSO implementation details

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index f616c0d0..44d510ff 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -17,7 +17,7 @@ wifi_la_LIBADD = @GDBUS_LIBS@
 bluetooth_la_SOURCES = bluetooth.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
-hso_la_SOURCES = hso.c
+hso_la_SOURCES = hso.c modem.h modem.c
 
 udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
 udhcp_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DUDHCPC=\"@UDHCPC@\" \
diff --git a/plugins/hso.c b/plugins/hso.c
index ac851d8d..335655c9 100644
--- a/plugins/hso.c
+++ b/plugins/hso.c
@@ -23,38 +23,227 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+#include <glib.h>
+
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/device.h>
+#include <connman/resolver.h>
 #include <connman/log.h>
 
+#include "modem.h"
+
+struct hso_data {
+	int index;
+	GIOChannel *channel;
+	struct modem_data *modem;
+};
+
+static void owandata_callback(const char *buf, void *user_data)
+{
+	//struct hso_data *data = user_data;
+	char *str, ip[16], nm[16], ns1[16], ns2[16], ns3[16], ns4[16], val[20];
+	int err, num;
+
+	str = g_strrstr(buf, "_OWANDATA");
+	if (str == NULL || strstr(buf, "ERROR") != NULL)
+		return;
+
+	err = sscanf(str, "_OWANDATA: %d, %[^,], %[^,], "
+					"%[^,], %[^,], %[^,], %[^,], %s",
+				&num, ip, nm, ns1, ns2, ns3, ns4, val);
+
+	if (err != 8) {
+		DBG("parsed %d arguments", err);
+		return;
+	}
+
+	DBG("ip %s dns %s %s val %s", ip, ns1, ns2, val);
+
+	//connman_resolver_append(data->iface, NULL, ns1);
+	//connman_resolver_append(data->iface, NULL, ns2);
+}
+
+static void owancall_callback(const char *buf, void *user_data)
+{
+	struct hso_data *data = user_data;
+
+	DBG("");
+
+	if (g_strrstr(buf, "_OWANCALL: 1, 3") != NULL) {
+		DBG("%s", buf);
+		//modem_command(modem, owancall_callback, data,
+		//			"_OWANCALL", "%d,%d,%d", 1, 1, 1);
+	}
+
+	if (g_strrstr(buf, "_OWANCALL: 1, 1") != NULL) {
+		DBG("%s", buf);
+		modem_command(data->modem, owandata_callback, data,
+						"_OWANDATA", "%d", 1);
+	}
+
+	if (g_strrstr(buf, "\r\nOK\r\n") != NULL) {
+		modem_command(data->modem, owandata_callback, data,
+						"_OWANDATA", "%d", 1);
+	}
+}
+
+static int network_probe(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
+static void network_remove(struct connman_network *network)
+{
+	DBG("network %p", network);
+}
+
+static int network_connect(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
+static int network_disconnect(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
+static struct connman_network_driver network_driver = {
+	.name		= "hso-network",
+	.type		= CONNMAN_NETWORK_TYPE_HSO,
+	.probe		= network_probe,
+	.remove		= network_remove,
+	.connect	= network_connect,
+	.disconnect	= network_disconnect,
+};
+
 static int hso_probe(struct connman_device *device)
 {
+	struct hso_data *data;
+
 	DBG("device %p", device);
 
+	data = g_try_new0(struct hso_data, 1);
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->index = connman_device_get_index(device);
+
+	data->modem = modem_create("/dev/ttyHS0");
+	if (data->modem == NULL) {
+		g_free(data);
+		return -EIO;
+	}
+
+	connman_device_set_data(device, data);
+
+	modem_add_callback(data->modem, "_OWANCALL",
+						owancall_callback, data);
+
 	return 0;
 }
 
 static void hso_remove(struct connman_device *device)
 {
+	struct hso_data *data = connman_device_get_data(device);
+
 	DBG("device %p", device);
+
+	connman_device_set_data(device, NULL);
+
+	modem_destroy(data->modem);
+
+	g_free(data);
+}
+
+static int hso_enable(struct connman_device *device)
+{
+	struct hso_data *data = connman_device_get_data(device);
+	struct connman_network *network;
+	int err;
+
+	DBG("device %p", device);
+
+	err = modem_open(data->modem);
+	if (err < 0)
+		return err;
+
+	connman_device_set_powered(device, TRUE);
+
+	modem_command(data->modem, NULL, NULL, "Z", NULL);
+	modem_command(data->modem, NULL, NULL, "I", NULL);
+
+	modem_command(data->modem, owancall_callback, data,
+					"_OWANCALL", "%d,%d,%d", 1, 1, 1);
+
+	network = connman_network_create("internet", CONNMAN_NETWORK_TYPE_HSO);
+	connman_device_add_network(device, network);
+
+	return 0;
+}
+
+static int hso_disable(struct connman_device *device)
+{
+	struct hso_data *data = connman_device_get_data(device);
+	//const char *iface = connman_device_get_interface(device);
+
+	DBG("device %p", device);
+
+	//connman_resolver_remove_all(iface);
+
+	modem_command(data->modem, owancall_callback, data,
+					"_OWANCALL", "%d,%d,%d", 1, 0, 0);
+
+	connman_device_set_powered(device, FALSE);
+
+	modem_close(data->modem);
+
+	g_io_channel_shutdown(data->channel, TRUE, NULL);
+	g_io_channel_unref(data->channel);
+
+	return 0;
 }
 
 static struct connman_device_driver hso_driver = {
-	.name		= "hso",
+	.name		= "hso-device",
 	.type		= CONNMAN_DEVICE_TYPE_HSO,
 	.probe		= hso_probe,
 	.remove		= hso_remove,
+	.enable		= hso_enable,
+	.disable	= hso_disable,
 };
 
 static int hso_init(void)
 {
-	return connman_device_driver_register(&hso_driver);
+	int err;
+
+	err = connman_network_driver_register(&network_driver);
+	if (err < 0)
+		return err;
+
+	err = connman_device_driver_register(&hso_driver);
+	if (err < 0) {
+		connman_network_driver_unregister(&network_driver);
+		return err;
+	}
+
+	return 0;
 }
 
 static void hso_exit(void)
 {
 	connman_device_driver_unregister(&hso_driver);
+	connman_network_driver_register(&network_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE(hso, "Option HSO device plugin", VERSION,

commit 8f1eb1a308f2f7f65536b0a0224d1710afd8a1eb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 21:25:04 2008 +0100

    Fail if interface name can't be retrieved

diff --git a/src/detect.c b/src/detect.c
index e97e9df8..781b8fa9 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -140,6 +140,8 @@ static void detect_newlink(unsigned short type, int index,
 		return;
 
 	devname = index2name(index);
+	if (devname == NULL)
+		return;
 
 	if (type == ARPHRD_ETHER) {
 		char bridge_path[PATH_MAX], wimax_path[PATH_MAX];

commit 627abec2e1c39d15a9a917c14a7923b6ab58cfd1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 21:27:22 2008 +0100

    Check that device name is valid before using it

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 1799f770..13f7d928 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -412,7 +412,7 @@ static void adapter_properties(DBusConnection *connection, const char *path,
 
 	connman_device_set_path(adapter, path);
 
-	if (g_str_has_prefix(node, "hci") == TRUE) {
+	if (node != NULL && g_str_has_prefix(node, "hci") == TRUE) {
 		int index;
 		errno = 0;
 		index = atoi(node + 3);

commit 42dc3ed17eb90633b0b3a06dd9b1351ee28d73f3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 21:36:10 2008 +0100

    Add network types for Bluetooth

diff --git a/include/network.h b/include/network.h
index 6d2f3b79..de1cb659 100644
--- a/include/network.h
+++ b/include/network.h
@@ -36,9 +36,11 @@ extern "C" {
  */
 
 enum connman_network_type {
-	CONNMAN_NETWORK_TYPE_UNKNOWN = 0,
-	CONNMAN_NETWORK_TYPE_WIFI    = 1,
-	CONNMAN_NETWORK_TYPE_HSO     = 23,
+	CONNMAN_NETWORK_TYPE_UNKNOWN       = 0,
+	CONNMAN_NETWORK_TYPE_WIFI          = 1,
+	CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN = 8,
+	CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN = 9,
+	CONNMAN_NETWORK_TYPE_HSO           = 23,
 };
 
 struct connman_network;

commit 4167a753ea847d3733a736fc3f5c029662f3131a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 21:55:51 2008 +0100

    Add support for storing network specific path value

diff --git a/include/network.h b/include/network.h
index de1cb659..78f921e9 100644
--- a/include/network.h
+++ b/include/network.h
@@ -52,6 +52,10 @@ extern void connman_network_unref(struct connman_network *network);
 
 extern const char *connman_network_get_identifier(struct connman_network *network);
 
+extern void connman_network_set_path(struct connman_network *network,
+							const char *path);
+extern const char *connman_network_get_path(struct connman_network *network);
+
 extern struct connman_device *connman_network_get_device(struct connman_network *network);
 
 extern void *connman_network_get_data(struct connman_network *network);
diff --git a/src/network.c b/src/network.c
index d2448951..47c203fa 100644
--- a/src/network.c
+++ b/src/network.c
@@ -31,6 +31,7 @@ struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
 	char *identifier;
+	char *path;
 
 	struct connman_network_driver *driver;
 	void *driver_data;
@@ -193,6 +194,7 @@ static void network_destruct(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	g_free(network->path);
 	g_free(network->identifier);
 }
 
@@ -268,6 +270,33 @@ const char *connman_network_get_identifier(struct connman_network *network)
 	return network->identifier;
 }
 
+/**
+ * connman_network_set_path:
+ * @network: network structure
+ * @path: path name
+ *
+ * Set path name of network
+ */
+void connman_network_set_path(struct connman_network *network, const char *path)
+{
+	g_free(network->element.devpath);
+	network->element.devpath = g_strdup(path);
+
+	g_free(network->path);
+	network->path = g_strdup(path);
+}
+
+/**
+ * connman_network_get_path:
+ * @network: network structure
+ *
+ * Get path name of network
+ */
+const char *connman_network_get_path(struct connman_network *network)
+{
+	return network->path;
+}
+
 void __connman_network_set_device(struct connman_network *network,
 					struct connman_device *device)
 {

commit d0bb09fd8a90eba708c019ba0198e05dd2022e0a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 21:56:32 2008 +0100

    Free allocated path value

diff --git a/src/device.c b/src/device.c
index e466c0c0..10abe4dc 100644
--- a/src/device.c
+++ b/src/device.c
@@ -507,6 +507,7 @@ static void device_destruct(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	g_free(device->path);
 	g_free(device->interface);
 
 	g_hash_table_destroy(device->networks);

commit 12e6a9a5778b17e758f9085bd9863226fcf39521
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 22:46:03 2008 +0100

    Add more debug messages for interface registration

diff --git a/src/device.c b/src/device.c
index 10abe4dc..5b7ac4f8 100644
--- a/src/device.c
+++ b/src/device.c
@@ -426,6 +426,8 @@ static int register_interface(struct connman_element *element)
 {
 	struct connman_device *device = element->device;
 
+	DBG("element %p name %s", element, element->name);
+
 	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_DEVICE_INTERFACE,
 					device_methods, device_signals,
@@ -441,6 +443,8 @@ static int register_interface(struct connman_element *element)
 
 static void unregister_interface(struct connman_element *element)
 {
+	DBG("element %p name %s", element, element->name);
+
 	emit_devices_signal();
 
 	g_dbus_unregister_interface(connection, element->path,
@@ -988,7 +992,7 @@ static int device_probe(struct connman_element *element)
 		}
 	}
 
-	if (!device->driver)
+	if (device->driver == NULL)
 		return -ENODEV;
 
 	err = register_interface(element);
@@ -1012,7 +1016,7 @@ static void device_remove(struct connman_element *element)
 	if (device == NULL)
 		return;
 
-	if (!device->driver)
+	if (device->driver == NULL)
 		return;
 
 	device_disable(device);

commit 3cf39e356ec835dd019ed537fa5012efe61cf822
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 22:58:41 2008 +0100

    Set device before registering network

diff --git a/src/device.c b/src/device.c
index 5b7ac4f8..84be26ea 100644
--- a/src/device.c
+++ b/src/device.c
@@ -836,12 +836,14 @@ int connman_device_add_network(struct connman_device *device,
 	if (device->mode == CONNMAN_DEVICE_MODE_NO_NETWORK)
 		return -EINVAL;
 
+	__connman_network_set_device(network, device);
+
 	err = connman_element_register((struct connman_element *) network,
 							&device->element);
-	if (err < 0)
+	if (err < 0) {
+		__connman_network_set_device(network, NULL);
 		return err;
-
-	__connman_network_set_device(network, device);
+	}
 
 	g_hash_table_insert(device->networks, g_strdup(identifier),
 								network);

commit 5dabfd89b01cd2dfe0af03c23684c6083d4647cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 22:59:31 2008 +0100

    Add support for connecting and disconnecting networks

diff --git a/src/network.c b/src/network.c
index 47c203fa..3c4d6b89 100644
--- a/src/network.c
+++ b/src/network.c
@@ -42,6 +42,7 @@ struct connman_network {
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_network *network = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
 
@@ -58,6 +59,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	if (network->identifier != NULL)
+		connman_dbus_dict_append_variant(&dict, "Name",
+				DBUS_TYPE_STRING, &network->identifier);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -87,16 +92,34 @@ static DBusMessage *set_property(DBusConnection *conn,
 static DBusMessage *do_connect(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_network *network = data;
+	int err;
+
 	DBG("conn %p", conn);
 
+	if (network->driver && network->driver->connect) {
+		err = network->driver->connect(network);
+		if (err < 0 && err != -EINPROGRESS)
+			return __connman_error_failed(msg);
+	}
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
 static DBusMessage *do_disconnect(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_network *network = data;
+	int err;
+
 	DBG("conn %p", conn);
 
+	if (network->driver && network->driver->disconnect) {
+		err = network->driver->disconnect(network);
+		if (err < 0 && err != -EINPROGRESS)
+			return __connman_error_failed(msg);
+	}
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -123,6 +146,8 @@ static int register_interface(struct connman_element *element)
 {
 	struct connman_network *network = element->network;
 
+	DBG("element %p name %s", element, element->name);
+
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);
 
@@ -141,6 +166,8 @@ static int register_interface(struct connman_element *element)
 
 static void unregister_interface(struct connman_element *element)
 {
+	DBG("element %p name %s", element, element->name);
+
 	emit_networks_signal();
 
 	g_dbus_unregister_interface(connection, element->path,
@@ -372,7 +399,7 @@ static int network_probe(struct connman_element *element)
 		}
 	}
 
-	if (!network->driver)
+	if (network->driver == NULL)
 		return -ENODEV;
 
 	err = register_interface(element);
@@ -394,7 +421,7 @@ static void network_remove(struct connman_element *element)
 	if (network == NULL)
 		return;
 
-	if (!network->driver)
+	if (network->driver == NULL)
 		return;
 
 	unregister_interface(element);

commit 6601d98940b0d97b99afe71bcc2a8db90bd6a593
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 23:33:55 2008 +0100

    Add support for changing connection state

diff --git a/include/network.h b/include/network.h
index 78f921e9..3fd266ea 100644
--- a/include/network.h
+++ b/include/network.h
@@ -55,6 +55,12 @@ extern const char *connman_network_get_identifier(struct connman_network *networ
 extern void connman_network_set_path(struct connman_network *network,
 							const char *path);
 extern const char *connman_network_get_path(struct connman_network *network);
+extern void connman_network_set_index(struct connman_network *network,
+								int index);
+extern int connman_network_get_index(struct connman_network *network);
+
+extern int connman_network_set_connected(struct connman_network *network,
+						connman_bool_t connected);
 
 extern struct connman_device *connman_network_get_device(struct connman_network *network);
 
diff --git a/src/network.c b/src/network.c
index 3c4d6b89..fe5f399e 100644
--- a/src/network.c
+++ b/src/network.c
@@ -30,6 +30,7 @@
 struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
+	gboolean connected;
 	char *identifier;
 	char *path;
 
@@ -63,6 +64,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Name",
 				DBUS_TYPE_STRING, &network->identifier);
 
+	connman_dbus_dict_append_variant(&dict, "Connected",
+				DBUS_TYPE_BOOLEAN, &network->connected);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -324,6 +328,65 @@ const char *connman_network_get_path(struct connman_network *network)
 	return network->path;
 }
 
+/**
+ * connman_network_set_index:
+ * @network: network structure
+ * @index: index number
+ *
+ * Set index number of network
+ */
+void connman_network_set_index(struct connman_network *network, int index)
+{
+	network->element.index = index;
+}
+
+/**
+ * connman_network_get_index:
+ * @device: network structure
+ *
+ * Get index number of network
+ */
+int connman_network_get_index(struct connman_network *network)
+{
+	return network->element.index;
+}
+
+/**
+ * connman_network_set_connected:
+ * @netowrk: network structure
+ * @connected: connected state
+ *
+ * Change connected state of network
+ */
+int connman_network_set_connected(struct connman_network *network,
+						connman_bool_t connected)
+{
+	DBG("network %p connected %d", network, connected);
+
+	if (network->connected == connected)
+		return -EALREADY;
+
+	network->connected = connected;
+
+	if (connected == TRUE) {
+		struct connman_element *element;
+
+		element = connman_element_create(NULL);
+		if (element != NULL) {
+			element->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
+			element->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
+			element->index   = network->element.index;
+
+			if (connman_element_register(element,
+							&network->element) < 0)
+				connman_element_unref(element);
+		}
+	} else
+		connman_element_unregister_children(&network->element);
+
+	return 0;
+}
+
 void __connman_network_set_device(struct connman_network *network,
 					struct connman_device *device)
 {

commit c8f5c35d5d577642dcd014f4d8294d8f38f498df
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 23:39:43 2008 +0100

    Add test scripts for connecting and disconnecting networks

diff --git a/test/Makefile.am b/test/Makefile.am
index f39d13e2..7b4c12ba 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -2,7 +2,8 @@
 EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
-		set-passphrase set-address simple-agent show-introspection \
-		set-policy test-manager test-compat monitor-connman
+		set-passphrase set-address set-policy test-manager \
+		connect-network disconnect-network \
+		simple-agent show-introspection test-compat monitor-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/connect-network b/test/connect-network
new file mode 100755
index 00000000..8f4f26bf
--- /dev/null
+++ b/test/connect-network
@@ -0,0 +1,37 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 2):
+	print "Usage: %s <network>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	if properties["Type"] not in ["wifi", "wimax",
+					"bluetooth", "cellular"]:
+		continue;
+
+	for path in properties["Networks"]:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		dev = path[path.rfind("/") + 1:]
+
+		if dev == sys.argv[1] or properties["Name"] == sys.argv[1]:
+			print "Connecting %s" % (path)
+			network.Connect()
diff --git a/test/disconnect-network b/test/disconnect-network
new file mode 100755
index 00000000..8529c19c
--- /dev/null
+++ b/test/disconnect-network
@@ -0,0 +1,37 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 2):
+	print "Usage: %s <network>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	if properties["Type"] not in ["wifi", "wimax",
+					"bluetooth", "cellular"]:
+		continue;
+
+	for path in properties["Networks"]:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		dev = path[path.rfind("/") + 1:]
+
+		if dev == sys.argv[1] or properties["Name"] == sys.argv[1]:
+			print "Disconnecting %s" % (path)
+			network.Disconnect()

commit 403b9481d672d01c6e221968785bfa5ff25dd35d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Dec 30 23:42:10 2008 +0100

    Add support for connecting Bluetooth NAP networks

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 44d510ff..efcb5b71 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -14,7 +14,7 @@ ethernet_la_SOURCES = ethernet.c inet.h inet.c
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
 
-bluetooth_la_SOURCES = bluetooth.c
+bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
 hso_la_SOURCES = hso.c modem.h modem.c
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 13f7d928..8f90a98f 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -34,10 +34,13 @@
 #include <connman/dbus.h>
 #include <connman/log.h>
 
+#include "inet.h"
+
 #define BLUEZ_SERVICE			"org.bluez"
 #define BLUEZ_MANAGER_INTERFACE		BLUEZ_SERVICE ".Manager"
 #define BLUEZ_ADAPTER_INTERFACE		BLUEZ_SERVICE ".Adapter"
 #define BLUEZ_DEVICE_INTERFACE		BLUEZ_SERVICE ".Device"
+#define BLUEZ_NETWORK_INTERFACE		BLUEZ_SERVICE ".Network"
 
 #define LIST_ADAPTERS			"ListAdapters"
 #define ADAPTER_ADDED			"AdapterAdded"
@@ -47,6 +50,9 @@
 #define GET_PROPERTIES			"GetProperties"
 #define SET_PROPERTY			"SetProperty"
 
+#define CONNECT				"Connect"
+#define DISCONNECT			"Disconnect"
+
 #define TIMEOUT 5000
 
 typedef void (* properties_callback_t) (DBusConnection *connection,
@@ -123,6 +129,201 @@ struct adapter_data {
 	DBusConnection *connection;
 };
 
+struct network_data {
+	DBusConnection *connection;
+	char *interface;
+};
+
+static int pan_probe(struct connman_network *network)
+{
+	struct connman_device *device = connman_network_get_device(network);
+	struct adapter_data *adapter;
+	struct network_data *data;
+
+	DBG("network %p", network);
+
+	if (device == NULL)
+		return -EINVAL;
+
+	adapter = connman_device_get_data(device);
+	if (adapter == NULL)
+		return -EINVAL;
+
+	data = g_try_new0(struct network_data, 1);
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->connection = adapter->connection;
+
+	connman_network_set_data(network, data);
+
+	return 0;
+}
+
+static void pan_remove(struct connman_network *network)
+{
+	struct network_data *data = connman_network_get_data(network);
+
+	DBG("network %p", network);
+
+	connman_network_set_data(network, NULL);
+
+	g_free(data);
+}
+
+static void connect_reply(DBusPendingCall *call, void *user_data)
+{
+	struct connman_network *network = user_data;
+	struct network_data *data = connman_network_get_data(network);
+	DBusMessage *reply;
+	DBusError error;
+	const char *interface = NULL;
+	int index;
+
+	DBG("network %p", network);
+
+	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL)
+		return;
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error,
+					DBUS_TYPE_STRING, &interface,
+						DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for connect");
+		goto done;
+	}
+
+	if (interface == NULL)
+		goto done;
+
+	DBG("interface %s", interface);
+
+	data->interface = g_strdup(interface);
+
+	index = inet_name2index(interface);
+
+	connman_network_set_index(network, index);
+	connman_network_set_connected(network, TRUE);
+
+done:
+	dbus_message_unref(reply);
+}
+
+static int pan_connect(struct connman_network *network)
+{
+	struct network_data *data = connman_network_get_data(network);
+	const char *path = connman_network_get_path(network);
+	const char *uuid = "nap";
+	DBusMessage *message;
+	DBusPendingCall *call;
+
+	DBG("network %p", network);
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
+					BLUEZ_NETWORK_INTERFACE, CONNECT);
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &uuid,
+							DBUS_TYPE_INVALID);
+
+	if (dbus_connection_send_with_reply(data->connection, message,
+					&call, TIMEOUT * 10) == FALSE) {
+		connman_error("Failed to connect service");
+		dbus_message_unref(message);
+		return -EINVAL;
+	}
+
+	dbus_pending_call_set_notify(call, connect_reply, network, NULL);
+
+	dbus_message_unref(message);
+
+	return -EINPROGRESS;
+}
+
+static void disconnect_reply(DBusPendingCall *call, void *user_data)
+{
+	struct connman_network *network = user_data;
+	struct network_data *data = connman_network_get_data(network);
+	DBusMessage *reply;
+	DBusError error;
+
+	DBG("network %p", network);
+
+	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL)
+		return;
+
+	dbus_error_init(&error);
+
+	if (dbus_message_get_args(reply, &error, DBUS_TYPE_INVALID) == FALSE) {
+		if (dbus_error_is_set(&error) == TRUE) {
+			connman_error("%s", error.message);
+			dbus_error_free(&error);
+		} else
+			connman_error("Wrong arguments for disconnect");
+		goto done;
+	}
+
+	g_free(data->interface);
+	data->interface = NULL;
+
+	connman_network_set_connected(network, FALSE);
+	connman_network_set_index(network, -1);
+
+done:
+	dbus_message_unref(reply);
+}
+
+static int pan_disconnect(struct connman_network *network)
+{
+	struct network_data *data = connman_network_get_data(network);
+	const char *path = connman_network_get_path(network);
+	DBusMessage *message;
+	DBusPendingCall *call;
+
+	DBG("network %p", network);
+
+	if (data->interface == NULL)
+		return -EINVAL;
+
+	message = dbus_message_new_method_call(BLUEZ_SERVICE, path,
+					BLUEZ_NETWORK_INTERFACE, DISCONNECT);
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &data->interface,
+							DBUS_TYPE_INVALID);
+
+	if (dbus_connection_send_with_reply(data->connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to disconnect service");
+		dbus_message_unref(message);
+		return -EINVAL;
+	}
+
+	dbus_pending_call_set_notify(call, disconnect_reply, network, NULL);
+
+	dbus_message_unref(message);
+
+	return -EINPROGRESS;
+}
+
+static struct connman_network_driver pan_driver = {
+	.name		= "bluetooth-pan",
+	.type		= CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN,
+	.probe		= pan_probe,
+	.remove		= pan_remove,
+	.connect	= pan_connect,
+	.disconnect	= pan_disconnect,
+};
+
 static int bluetooth_probe(struct connman_device *adapter)
 {
 	struct adapter_data *data;
@@ -289,10 +490,13 @@ static void device_properties(DBusConnection *connection, const char *path,
 	if (network != NULL)
 		return;
 
-	network = connman_network_create(node, CONNMAN_NETWORK_TYPE_WIFI);
+	network = connman_network_create(node,
+					CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN);
 	if (network == NULL)
 		return;
 
+	connman_network_set_path(network, path);
+
 	connman_device_add_network(device, network);
 }
 
@@ -585,14 +789,21 @@ static int bluetooth_init(void)
 							NULL, NULL) == FALSE)
 		goto unref;
 
-	err = connman_device_driver_register(&bluetooth_driver);
+	err = connman_network_driver_register(&pan_driver);
 	if (err < 0)
 		goto remove;
 
+	err = connman_device_driver_register(&bluetooth_driver);
+	if (err < 0) {
+		connman_network_driver_unregister(&pan_driver);
+		goto remove;
+	}
+
 	watch = g_dbus_add_service_watch(connection, BLUEZ_SERVICE,
 			bluetooth_connect, bluetooth_disconnect, NULL, NULL);
 	if (watch == 0) {
 		connman_device_driver_unregister(&bluetooth_driver);
+		connman_network_driver_unregister(&pan_driver);
 		err = -EIO;
 		goto remove;
 	}
@@ -628,6 +839,7 @@ static void bluetooth_exit(void)
 	free_adapters();
 
 	connman_device_driver_unregister(&bluetooth_driver);
+	connman_network_driver_unregister(&pan_driver);
 
 	dbus_connection_remove_filter(connection, bluetooth_signal, NULL);
 

commit d482ccc485f98416b0df5bbcad97110bc390c35c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 08:12:48 2008 +0100

    Fix network types for Bluetooth and Cellular devices

diff --git a/include/element.h b/include/element.h
index afe7b0c2..812ac302 100644
--- a/include/element.h
+++ b/include/element.h
@@ -74,7 +74,7 @@ enum connman_element_subtype {
 	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 3,
 	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 4,
 	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 5,
-	CONNMAN_ELEMENT_SUBTYPE_MODEM     = 6,
+	CONNMAN_ELEMENT_SUBTYPE_CELLULAR  = 6,
 	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 7,
 };
 
diff --git a/src/element.c b/src/element.c
index 42e4e87e..5e795899 100644
--- a/src/element.c
+++ b/src/element.c
@@ -138,8 +138,8 @@ static const char *subtype2string(enum connman_element_subtype type)
 		return "wifi";
 	case CONNMAN_ELEMENT_SUBTYPE_WIMAX:
 		return "wimax";
-	case CONNMAN_ELEMENT_SUBTYPE_MODEM:
-		return "modem";
+	case CONNMAN_ELEMENT_SUBTYPE_CELLULAR:
+		return "cellular";
 	case CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH:
 		return "bluetooth";
 	}
diff --git a/src/network.c b/src/network.c
index fe5f399e..de48611f 100644
--- a/src/network.c
+++ b/src/network.c
@@ -256,6 +256,19 @@ struct connman_network *connman_network_create(const char *identifier,
 	network->element.type = CONNMAN_ELEMENT_TYPE_NETWORK;
 	network->element.index = -1;
 
+	switch (type) {
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
+		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
+		break;
+	case CONNMAN_NETWORK_TYPE_HSO:
+		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_CELLULAR;
+		break;
+	default:
+		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+		break;
+	}
+
 	network->element.network = network;
 	network->element.destruct = network_destruct;
 

commit c1ed62089c08b960fd7d16cdaa15e3215710af6c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 08:34:14 2008 +0100

    Add dbus_connection_flush() to DHCP scripts

diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
index 68b755a3..bf2316d0 100644
--- a/scripts/dhclient-script.c
+++ b/scripts/dhclient-script.c
@@ -118,6 +118,8 @@ int main(int argc, char *argv[])
 	if (dbus_connection_send(conn, msg, NULL) == FALSE)
 		fprintf(stderr, "Failed to send message\n");
 
+	dbus_connection_flush(conn);
+
 	dbus_message_unref(msg);
 
 	dbus_connection_unref(conn);
diff --git a/scripts/udhcpc-script.c b/scripts/udhcpc-script.c
index 04487609..fb2168bc 100644
--- a/scripts/udhcpc-script.c
+++ b/scripts/udhcpc-script.c
@@ -89,6 +89,8 @@ int main(int argc, char *argv[])
 	if (dbus_connection_send(conn, msg, NULL) == FALSE)
 		fprintf(stderr, "Failed to send message\n");
 
+	dbus_connection_flush(conn);
+
 	dbus_message_unref(msg);
 
 	dbus_connection_unref(conn);

commit 35475b9c854895dbb365d78d47b93fef97e31267
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 08:35:42 2008 +0100

    Fix documentation spelling mistakes

diff --git a/src/network.c b/src/network.c
index de48611f..a54049bf 100644
--- a/src/network.c
+++ b/src/network.c
@@ -355,7 +355,7 @@ void connman_network_set_index(struct connman_network *network, int index)
 
 /**
  * connman_network_get_index:
- * @device: network structure
+ * @network: network structure
  *
  * Get index number of network
  */
@@ -366,7 +366,7 @@ int connman_network_get_index(struct connman_network *network)
 
 /**
  * connman_network_set_connected:
- * @netowrk: network structure
+ * @network: network structure
  * @connected: connected state
  *
  * Change connected state of network

commit e6de96640ddfad332fa033f98863644c83343c4a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 08:47:08 2008 +0100

    Handle missing environment variables

diff --git a/scripts/udhcpc-script.c b/scripts/udhcpc-script.c
index fb2168bc..e5ac3e90 100644
--- a/scripts/udhcpc-script.c
+++ b/scripts/udhcpc-script.c
@@ -51,10 +51,24 @@ int main(int argc, char *argv[])
 	interface = getenv("interface");
 
 	address = getenv("ip");
+	if (address == NULL)
+		address = "";
+
 	netmask = getenv("subnet");
+	if (netmask == NULL)
+		netmask = "";
+
 	broadcast = getenv("broadcast");
+	if (broadcast == NULL)
+		broadcast = "";
+
 	gateway = getenv("router");
+	if (gateway == NULL)
+		gateway = "";
+
 	dns = getenv("dns");
+	if (dns == NULL)
+		dns = "";
 
 	dbus_error_init(&error);
 

commit c9fb635620bd63ed64b9af6d61828cbc7592971c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 09:07:53 2008 +0100

    Add Interface property for connections

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index c39c6d29..a0c97da3 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -21,6 +21,13 @@ Properties	string Type [readonly]
 
 			The connection type (for example wifi etc.)
 
+		string Interface [readonly]
+
+			The connection interface (for example "eth0" etc.)
+
+			This value is for pure informational purposes. It
+			is not guaranteed that it is always present.
+
 		uint8 Strength [readonly]
 
 			Indicates the signal strength of the connection.
diff --git a/src/element.c b/src/element.c
index 5e795899..0271107f 100644
--- a/src/element.c
+++ b/src/element.c
@@ -539,6 +539,10 @@ static DBusMessage *connection_get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &str);
 
+	if (element->devname != NULL)
+		connman_dbus_dict_append_variant(&dict, "Interface",
+					DBUS_TYPE_STRING, &element->devname);
+
 	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
 			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX)
 		connman_dbus_dict_append_variant(&dict, "Strength",

commit 897f9876936ce0a3f0ae6798725e1162a3e62ff9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 09:08:50 2008 +0100

    Set interface name for connection objects

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index efcb5b71..e663e14c 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -27,7 +27,7 @@ dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
-ipv4_la_SOURCES = ipv4.c
+ipv4_la_SOURCES = ipv4.c inet.h inet.c
 
 dnsproxy_la_SOURCES = dnsproxy.c
 
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 33c73a42..5e19cbb8 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -397,8 +397,9 @@ static int ipv4_probe(struct connman_element *element)
 
 	connection = connman_element_create(NULL);
 
-	connection->type = CONNMAN_ELEMENT_TYPE_CONNECTION;
-	connection->index = element->index;
+	connection->type    = CONNMAN_ELEMENT_TYPE_CONNECTION;
+	connection->index   = element->index;
+	connection->devname = inet_index2name(element->index);
 
 	if (connman_element_register(connection, element) < 0)
 		connman_element_unref(connection);

commit 63a37015b90200aa5dd9a0282dc260ea6d4b5afb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 09:56:33 2008 +0100

    Remove unused GIOChannel

diff --git a/plugins/hso.c b/plugins/hso.c
index 335655c9..98708ddd 100644
--- a/plugins/hso.c
+++ b/plugins/hso.c
@@ -39,7 +39,6 @@
 
 struct hso_data {
 	int index;
-	GIOChannel *channel;
 	struct modem_data *modem;
 };
 
@@ -208,9 +207,6 @@ static int hso_disable(struct connman_device *device)
 
 	modem_close(data->modem);
 
-	g_io_channel_shutdown(data->channel, TRUE, NULL);
-	g_io_channel_unref(data->channel);
-
 	return 0;
 }
 

commit 7eb8af13972e60a68013008ffc71a3495ad63144
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 19:27:56 2008 +0100

    Remove watch on shutdown

diff --git a/plugins/modem.c b/plugins/modem.c
index 4668bd38..47d7e218 100644
--- a/plugins/modem.c
+++ b/plugins/modem.c
@@ -40,6 +40,7 @@
 struct modem_data {
 	char *device;
 	GIOChannel *channel;
+	guint watch;
 	GSList *callbacks;
 	GSList *commands;
 	char buf[1024];
@@ -200,7 +201,9 @@ static int open_device(const char *device)
 	tcflush(fd, TCIOFLUSH);
 
 	/* Switch TTY to raw mode */
+	memset(&ti, 0, sizeof(ti));
 	cfmakeraw(&ti);
+
 	tcsetattr(fd, TCSANOW, &ti);
 
 	return fd;
@@ -232,7 +235,7 @@ int modem_open(struct modem_data *modem)
 	modem->channel = g_io_channel_unix_new(fd);
 	g_io_channel_set_close_on_unref(modem->channel, TRUE);
 
-	g_io_add_watch(modem->channel,
+	modem->watch = g_io_add_watch(modem->channel,
 				G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,
 							modem_event, modem);
 
@@ -246,9 +249,10 @@ int modem_close(struct modem_data *modem)
 	if (modem == NULL)
 		return -ENOENT;
 
-	g_io_channel_shutdown(modem->channel, TRUE, NULL);
-	g_io_channel_unref(modem->channel);
+	g_source_remove(modem->watch);
+	modem->watch = 0;
 
+	g_io_channel_unref(modem->channel);
 	modem->channel = NULL;
 
 	return 0;

commit 7a5d039927269f9f3f2fb5290e2ac5ca6f4b94a4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 19:30:32 2008 +0100

    Add check for pppd binary and header files

diff --git a/configure.ac b/configure.ac
index 42789a75..a22b82a4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -47,6 +47,10 @@ AC_PATH_PROG(UDHCPC, [udhcpc], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(DHCLIENT, [dhclient], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(RESOLVCONF, [resolvconf], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
+AC_PATH_PROG(PPPD, [pppd], ,$PATH:/sbin:/usr/sbin)
+
+AC_CHECK_HEADERS(pppd/pppd.h, pppd_found=no, pppd_found=yes)
+AM_CONDITIONAL(PPPD, test "${pppd_found}" = "yes")
 
 AC_CHECK_LIB(dl, dlopen, dummy=yes,
 			AC_MSG_ERROR(dynamic linking loader is required))

commit 2be69ed5050ac7bfa03af2ddce172e6fc02ddc84
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 19:42:37 2008 +0100

    Add basic pppd plugin

diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index b28f64fe..9cf4e009 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -15,6 +15,12 @@ udhcpc_script_LDADD = @DBUS_LIBS@
 
 dhclient_script_LDADD = @DBUS_LIBS@
 
+if PPPD
+script_LTLIBRARIES = pppd-plugin.la
+
+pppd_plugin_la_LDFLAGS = -module -avoid-version
+endif
+
 AM_CFLAGS = @DBUS_CFLAGS@
 
 EXTRA_DIST = $(script_DATA)
diff --git a/scripts/pppd-plugin.c b/scripts/pppd-plugin.c
new file mode 100644
index 00000000..232d58ac
--- /dev/null
+++ b/scripts/pppd-plugin.c
@@ -0,0 +1,80 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <pppd/pppd.h>
+#include <pppd/fsm.h>
+#include <pppd/ipcp.h>
+
+static void notifier_phasechange(void *data, int arg)
+{
+	printf("phasechange: data %p arg %d\n", data, arg);
+}
+
+static void notifier_exit(void *data, int arg)
+{
+	printf("exitnotify: data %p arg %d\n", data, arg);
+}
+
+static void notifier_ipup(void *data, int arg)
+{
+	ipcp_options opts = ipcp_gotoptions[0];
+	ipcp_options peer = ipcp_hisoptions[0];
+
+	printf("ipup: data %p arg %d\n", data, arg);
+
+	printf("%s: %s -> %s\n", ifname,
+				inet_ntoa(*((struct in_addr *) &opts.ouraddr)),
+				inet_ntoa(*((struct in_addr *) &peer.hisaddr)));
+
+	script_unsetenv("USEPEERDNS");
+	script_unsetenv("DNS1");
+	script_unsetenv("DNS2");
+}
+
+static void notifier_ipdown(void *data, int arg)
+{
+	printf("ipdown: data %p arg %d\n", data, arg);
+}
+
+char pppd_version[] = VERSION;
+
+int plugin_init(void);
+
+int plugin_init(void)
+{
+	path_ipup[0] = '\0';
+	path_ipdown[0] = '\0';
+
+	add_notifier(&phasechange, notifier_phasechange, NULL);
+	add_notifier(&exitnotify, notifier_exit, NULL);
+
+	add_notifier(&ip_up_notifier, notifier_ipup, NULL);
+	add_notifier(&ip_down_notifier, notifier_ipdown, NULL);
+
+	return 0;
+}

commit 2908e9d91aef3832151feb7294babcb7110e93d6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 19:44:33 2008 +0100

    Add element type for PPP

diff --git a/include/element.h b/include/element.h
index 812ac302..92f642fa 100644
--- a/include/element.h
+++ b/include/element.h
@@ -58,11 +58,12 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_DEVICE     = 3,
 	CONNMAN_ELEMENT_TYPE_NETWORK    = 4,
 	CONNMAN_ELEMENT_TYPE_SERVICE    = 5,
-	CONNMAN_ELEMENT_TYPE_IPV4       = 6,
-	CONNMAN_ELEMENT_TYPE_IPV6       = 7,
-	CONNMAN_ELEMENT_TYPE_DHCP       = 8,
-	CONNMAN_ELEMENT_TYPE_BOOTP      = 9,
-	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 10,
+	CONNMAN_ELEMENT_TYPE_PPP        = 6,
+	CONNMAN_ELEMENT_TYPE_IPV4       = 7,
+	CONNMAN_ELEMENT_TYPE_IPV6       = 8,
+	CONNMAN_ELEMENT_TYPE_DHCP       = 9,
+	CONNMAN_ELEMENT_TYPE_BOOTP      = 10,
+	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 11,
 
 	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
 };
diff --git a/src/element.c b/src/element.c
index 0271107f..a3bfa028 100644
--- a/src/element.c
+++ b/src/element.c
@@ -106,6 +106,8 @@ static const char *type2string(enum connman_element_type type)
 		return "network";
 	case CONNMAN_ELEMENT_TYPE_SERVICE:
 		return "service";
+	case CONNMAN_ELEMENT_TYPE_PPP:
+		return "ppp";
 	case CONNMAN_ELEMENT_TYPE_IPV4:
 		return "ipv4";
 	case CONNMAN_ELEMENT_TYPE_IPV6:

commit f883e5a75d0746b045a53cdeb9b82b645bdfcfee
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 01:53:18 2009 +0100

    Add option for network protocol

diff --git a/include/network.h b/include/network.h
index 3fd266ea..8dab190e 100644
--- a/include/network.h
+++ b/include/network.h
@@ -43,6 +43,12 @@ enum connman_network_type {
 	CONNMAN_NETWORK_TYPE_HSO           = 23,
 };
 
+enum connman_network_protocol {
+	CONNMAN_NETWORK_PROTOCOL_UNKNOWN = 0,
+	CONNMAN_NETWORK_PROTOCOL_IP      = 1,
+	CONNMAN_NETWORK_PROTOCOL_PPP     = 2,
+};
+
 struct connman_network;
 
 extern struct connman_network *connman_network_create(const char *identifier,
@@ -59,6 +65,9 @@ extern void connman_network_set_index(struct connman_network *network,
 								int index);
 extern int connman_network_get_index(struct connman_network *network);
 
+extern void connman_network_set_protocol(struct connman_network *network,
+					enum connman_network_protocol protocol);
+
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
 
diff --git a/src/network.c b/src/network.c
index a54049bf..69b61909 100644
--- a/src/network.c
+++ b/src/network.c
@@ -30,6 +30,7 @@
 struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
+	enum connman_network_protocol protocol;
 	gboolean connected;
 	char *identifier;
 	char *path;
@@ -364,6 +365,19 @@ int connman_network_get_index(struct connman_network *network)
 	return network->element.index;
 }
 
+/**
+ * connman_network_set_protocol:
+ * @network: network structure
+ * @protocol: network protocol
+ *
+ * Change protocol of network
+ */
+void connman_network_set_protocol(struct connman_network *network,
+					enum connman_network_protocol protocol)
+{
+	network->protocol = protocol;
+}
+
 /**
  * connman_network_set_connected:
  * @network: network structure

commit e77d5b6ca6caf487af324e7ebc1f2d7384c39ad4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 02:04:05 2009 +0100

    Fix broken check for pppd header files

diff --git a/configure.ac b/configure.ac
index a22b82a4..ad37741f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -49,7 +49,7 @@ AC_PATH_PROG(RESOLVCONF, [resolvconf], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
 AC_PATH_PROG(PPPD, [pppd], ,$PATH:/sbin:/usr/sbin)
 
-AC_CHECK_HEADERS(pppd/pppd.h, pppd_found=no, pppd_found=yes)
+AC_CHECK_HEADERS(pppd/pppd.h, pppd_found=yes, pppd_found=no)
 AM_CONDITIONAL(PPPD, test "${pppd_found}" = "yes")
 
 AC_CHECK_LIB(dl, dlopen, dummy=yes,

commit 5be6dc3d4b22d736bb47e6fd6d4d5c8c11f70364
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 02:04:35 2009 +0100

    Add skeleton for PPP plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index e663e14c..045c3f0b 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -27,6 +27,12 @@ dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
+if PPPD
+plugin_LTLIBRARIES += pppd.la
+
+pppd_la_SOURCES = pppd.c
+endif
+
 ipv4_la_SOURCES = ipv4.c inet.h inet.c
 
 dnsproxy_la_SOURCES = dnsproxy.c
diff --git a/plugins/pppd.c b/plugins/pppd.c
new file mode 100644
index 00000000..1cf304f6
--- /dev/null
+++ b/plugins/pppd.c
@@ -0,0 +1,61 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+#include <connman/plugin.h>
+#include <connman/driver.h>
+#include <connman/log.h>
+
+static int pppd_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	return -ENODEV;
+}
+
+static void pppd_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver pppd_driver = {
+	.name		= "pppd",
+	.type		= CONNMAN_ELEMENT_TYPE_PPP,
+	.probe		= pppd_probe,
+	.remove		= pppd_remove,
+};
+
+static int pppd_init(void)
+{
+	return connman_driver_register(&pppd_driver);
+}
+
+static void pppd_exit(void)
+{
+	connman_driver_unregister(&pppd_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE(pppd, "Point-to-point protocol plugin", VERSION,
+							pppd_init, pppd_exit)

commit 3909f166fb41fba2521bf84ed5fc87d367c163b8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 18:52:16 2009 +0100

    Allow transport definition for device mode

diff --git a/include/device.h b/include/device.h
index c9f6d767..b434db54 100644
--- a/include/device.h
+++ b/include/device.h
@@ -46,9 +46,10 @@ enum connman_device_type {
 };
 
 enum connman_device_mode {
-	CONNMAN_DEVICE_MODE_NO_NETWORK        = 0,
-	CONNMAN_DEVICE_MODE_SINGLE_NETWORK    = 1,
-	CONNMAN_DEVICE_MODE_MULTIPLE_NETWORKS = 2,
+	CONNMAN_DEVICE_MODE_UNKNOWN          = 0,
+	CONNMAN_DEVICE_MODE_NETWORK_SINGLE   = 1,
+	CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE = 2,
+	CONNMAN_DEVICE_MODE_TRANSPORT_IP     = 3,
 };
 
 enum connman_device_policy {
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 8f90a98f..ba5c3a29 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -627,7 +627,7 @@ static void adapter_properties(DBusConnection *connection, const char *path,
 	connman_device_set_interface(adapter, node);
 
 	connman_device_set_policy(adapter, CONNMAN_DEVICE_POLICY_MANUAL);
-	connman_device_set_mode(adapter, CONNMAN_DEVICE_MODE_MULTIPLE_NETWORKS);
+	connman_device_set_mode(adapter, CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE);
 
 	if (connman_device_register(adapter) < 0) {
 		connman_device_unref(adapter);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 10541f28..e07901c8 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -568,7 +568,7 @@ static void wifi_newlink(unsigned short type, int index,
 	g_free(devname);
 	g_free(name);
 
-	connman_device_set_mode(device, CONNMAN_DEVICE_MODE_SINGLE_NETWORK);
+	connman_device_set_mode(device, CONNMAN_DEVICE_MODE_NETWORK_SINGLE);
 
 	if (connman_device_register(device) < 0) {
 		connman_device_unregister(device);
diff --git a/src/detect.c b/src/detect.c
index 781b8fa9..57ea83ee 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -130,6 +130,7 @@ static void detect_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
 	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+	enum connman_device_mode mode;
 	struct connman_device *device;
 	gchar *name, *devname;
 
@@ -198,15 +199,28 @@ static void detect_newlink(unsigned short type, int index,
 	}
 
 	switch (devtype) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+		mode = CONNMAN_DEVICE_MODE_UNKNOWN;
+		break;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		mode = CONNMAN_DEVICE_MODE_TRANSPORT_IP;
+		break;
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+		mode = CONNMAN_DEVICE_MODE_NETWORK_SINGLE;
+		break;
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+		mode = CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE;
+		break;
 	case CONNMAN_DEVICE_TYPE_HSO:
+		mode = CONNMAN_DEVICE_MODE_NETWORK_SINGLE;
 		connman_device_set_policy(device, CONNMAN_DEVICE_POLICY_MANUAL);
-		connman_device_set_mode(device,
-					CONNMAN_DEVICE_MODE_SINGLE_NETWORK);
-		break;
-	default:
 		break;
 	}
 
+	connman_device_set_mode(device, mode);
+
 	connman_device_set_index(device, index);
 	connman_device_set_interface(device, devname);
 
diff --git a/src/device.c b/src/device.c
index 84be26ea..d5e836b7 100644
--- a/src/device.c
+++ b/src/device.c
@@ -48,6 +48,9 @@ struct connman_device {
 static const char *type2description(enum connman_device_type type)
 {
 	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
 		return "Ethernet";
 	case CONNMAN_DEVICE_TYPE_WIFI:
@@ -58,14 +61,17 @@ static const char *type2description(enum connman_device_type type)
 		return "Bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
 		return "Cellular";
-	default:
-		return NULL;
 	}
+
+	return NULL;
 }
 
 static const char *type2string(enum connman_device_type type)
 {
 	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
 		return "ethernet";
 	case CONNMAN_DEVICE_TYPE_WIFI:
@@ -76,9 +82,9 @@ static const char *type2string(enum connman_device_type type)
 		return "bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
 		return "cellular";
-	default:
-		return NULL;
 	}
+
+	return NULL;
 }
 
 static const char *policy2string(enum connman_device_policy policy)
@@ -264,11 +270,17 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Scanning",
 					DBUS_TYPE_BOOLEAN, &device->scanning);
 
-	if (device->mode != CONNMAN_DEVICE_MODE_NO_NETWORK) {
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		break;
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
 		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
 		append_networks(device, &entry);
 		dbus_message_iter_close_container(&dict, &entry);
+		break;
 	}
 
 	dbus_message_iter_close_container(&array, &dict);
@@ -357,8 +369,14 @@ static DBusMessage *propose_scan(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
-	if (device->mode == CONNMAN_DEVICE_MODE_NO_NETWORK)
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
 		return __connman_error_not_supported(msg);
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		break;
+	}
 
 	if (!device->driver || !device->driver->scan)
 		return __connman_error_not_supported(msg);
@@ -557,8 +575,8 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.device = device;
 	device->element.destruct = device_destruct;
 
-	device->type = type;
-	device->mode = CONNMAN_DEVICE_MODE_NO_NETWORK;
+	device->type   = type;
+	device->mode   = CONNMAN_DEVICE_MODE_UNKNOWN;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
 
 	device->networks = g_hash_table_new_full(g_str_hash, g_str_equal,
@@ -748,8 +766,14 @@ int connman_device_set_carrier(struct connman_device *device,
 {
 	DBG("driver %p carrier %d", device, carrier);
 
-	if (device->mode != CONNMAN_DEVICE_MODE_NO_NETWORK)
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
 		return -EINVAL;
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		break;
+	}
 
 	if (device->carrier == carrier)
 		return -EALREADY;
@@ -833,8 +857,14 @@ int connman_device_add_network(struct connman_device *device,
 
 	DBG("device %p network %p", device, network);
 
-	if (device->mode == CONNMAN_DEVICE_MODE_NO_NETWORK)
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
 		return -EINVAL;
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		break;
+	}
 
 	__connman_network_set_device(network, device);
 

commit bffaaf7bd6f31a0c873d358bc0119e2de9f55a9c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 19:07:00 2009 +0100

    Remove deprecated network subtype

diff --git a/include/element.h b/include/element.h
index 92f642fa..906601e6 100644
--- a/include/element.h
+++ b/include/element.h
@@ -71,7 +71,6 @@ enum connman_element_type {
 enum connman_element_subtype {
 	CONNMAN_ELEMENT_SUBTYPE_UNKNOWN   = 0,
 	CONNMAN_ELEMENT_SUBTYPE_FAKE      = 1,
-	CONNMAN_ELEMENT_SUBTYPE_NETWORK   = 2,
 	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 3,
 	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 4,
 	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 5,
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 045c3f0b..78e6b441 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,14 +1,12 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = loopback.la netdev.la ethernet.la wifi.la \
-			bluetooth.la hso.la udhcp.la dhclient.la ipv4.la \
-				dnsproxy.la resolvconf.la resolvfile.la
+plugin_LTLIBRARIES = loopback.la ethernet.la wifi.la bluetooth.la hso.la \
+				udhcp.la dhclient.la ipv4.la dnsproxy.la \
+						resolvconf.la resolvfile.la
 
 loopback_la_SOURCES = loopback.c
 
-netdev_la_SOURCES = netdev.c
-
 ethernet_la_SOURCES = ethernet.c inet.h inet.c
 
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
diff --git a/plugins/netdev.c b/plugins/netdev.c
deleted file mode 100644
index 24993019..00000000
--- a/plugins/netdev.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define CONNMAN_API_SUBJECT_TO_CHANGE
-#include <connman/plugin.h>
-#include <connman/driver.h>
-#include <connman/log.h>
-
-static void create_element(struct connman_element *parent,
-					enum connman_element_type type)
-{
-	struct connman_element *element;
-
-	DBG("parent %p name %s", parent, parent->name);
-
-	element = connman_element_create(NULL);
-	if (element == NULL)
-		return;
-
-	element->type = type;
-	element->index = parent->index;
-
-	if (parent->parent)
-		element->subtype = parent->parent->subtype;
-	else
-		element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
-
-	if (connman_element_register(element, parent) < 0)
-		connman_element_unref(element);
-}
-
-static int netdev_probe(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	create_element(element, CONNMAN_ELEMENT_TYPE_DHCP);
-	create_element(element, CONNMAN_ELEMENT_TYPE_ZEROCONF);
-
-	return 0;
-}
-
-static void netdev_remove(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-}
-
-static struct connman_driver netdev_driver = {
-	.name		= "netdev",
-	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_NETWORK,
-	.probe		= netdev_probe,
-	.remove		= netdev_remove,
-};
-
-static int netdev_init(void)
-{
-	return connman_driver_register(&netdev_driver);
-}
-
-static void netdev_exit(void)
-{
-	connman_driver_unregister(&netdev_driver);
-}
-
-CONNMAN_PLUGIN_DEFINE(netdev, "Network device plugin", VERSION,
-						netdev_init, netdev_exit)
diff --git a/src/device.c b/src/device.c
index d5e836b7..3a1ae260 100644
--- a/src/device.c
+++ b/src/device.c
@@ -785,8 +785,8 @@ int connman_device_set_carrier(struct connman_device *device,
 
 		element = connman_element_create(NULL);
 		if (element != NULL) {
-			element->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
-			element->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
+			element->type    = CONNMAN_ELEMENT_TYPE_DHCP;
+			element->subtype = device->element.subtype;
 			element->index   = device->element.index;
 
 			if (connman_element_register(element,
diff --git a/src/element.c b/src/element.c
index a3bfa028..85d92fda 100644
--- a/src/element.c
+++ b/src/element.c
@@ -132,8 +132,6 @@ static const char *subtype2string(enum connman_element_subtype type)
 		return "unknown";
 	case CONNMAN_ELEMENT_SUBTYPE_FAKE:
 		return "fake";
-	case CONNMAN_ELEMENT_SUBTYPE_NETWORK:
-		return "network";
 	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:
 		return "ethernet";
 	case CONNMAN_ELEMENT_SUBTYPE_WIFI:
@@ -631,10 +629,6 @@ static gboolean append_path(GNode *node, gpointer user_data)
 					filter->type != element->type)
 		return FALSE;
 
-	if (filter->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_NETWORK)
-		return FALSE;
-
 	dbus_message_iter_append_basic(filter->iter,
 				DBUS_TYPE_OBJECT_PATH, &element->path);
 
@@ -1741,8 +1735,7 @@ int connman_element_register(struct connman_element *element,
 	if (element->devname == NULL)
 		element->devname = g_strdup(element->name);
 
-	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
-			element->subtype != CONNMAN_ELEMENT_SUBTYPE_NETWORK) {
+	if (device_filter && element->type == CONNMAN_ELEMENT_TYPE_DEVICE) {
 		if (g_pattern_match_simple(device_filter,
 						element->devname) == FALSE) {
 			DBG("ignoring %s [%s] device", element->name,
diff --git a/src/network.c b/src/network.c
index 69b61909..6e966e34 100644
--- a/src/network.c
+++ b/src/network.c
@@ -397,11 +397,23 @@ int connman_network_set_connected(struct connman_network *network,
 
 	if (connected == TRUE) {
 		struct connman_element *element;
+		enum connman_element_type type;
+
+		switch (network->protocol) {
+		case CONNMAN_NETWORK_PROTOCOL_UNKNOWN:
+			return 0;
+		case CONNMAN_NETWORK_PROTOCOL_IP:
+			type = CONNMAN_ELEMENT_TYPE_DHCP;
+			break;
+		case CONNMAN_NETWORK_PROTOCOL_PPP:
+			type = CONNMAN_ELEMENT_TYPE_PPP;
+			break;
+		}
 
 		element = connman_element_create(NULL);
 		if (element != NULL) {
-			element->type    = CONNMAN_ELEMENT_TYPE_DEVICE;
-			element->subtype = CONNMAN_ELEMENT_SUBTYPE_NETWORK;
+			element->type    = type;
+			element->subtype = network->element.subtype;
 			element->index   = network->element.index;
 
 			if (connman_element_register(element,
diff --git a/src/storage.c b/src/storage.c
index e0e3dc55..3ed0fc17 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -165,8 +165,7 @@ int __connman_element_store(struct connman_element *element)
 				element->type != CONNMAN_ELEMENT_TYPE_NETWORK)
 		return -EINVAL;
 
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_FAKE ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_NETWORK)
+	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_FAKE)
 		return -EINVAL;
 
 	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);

commit 991fe1e5f6458aa30ee82ad73b2f0411b74b1d3e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 19:28:12 2009 +0100

    Update copyright information

diff --git a/README b/README
index 9b6402ad..70e88268 100644
--- a/README
+++ b/README
@@ -1,7 +1,7 @@
 Connection Manager
 ******************
 
-Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
 
 
 Compilation and installation
@@ -16,8 +16,8 @@ In order to compile Connection Manager you need following software packages:
 
 To configure run:
 	./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var
- 
-Configure automatically searches for all required components and packages. 
+
+Configure automatically searches for all required components and packages.
 
 To compile and install run:
 	make && make install
diff --git a/client/main.c b/client/main.c
index bb1c39f4..b317c9c6 100644
--- a/client/main.c
+++ b/client/main.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/gdbus/gdbus.h b/gdbus/gdbus.h
index e0d653a5..fa618a52 100644
--- a/gdbus/gdbus.h
+++ b/gdbus/gdbus.h
@@ -2,7 +2,7 @@
  *
  *  D-Bus helper library
  *
- *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2004-2009  Marcel Holtmann <marcel@holtmann.org>
  *
  *
  *  This program is free software; you can redistribute it and/or modify
diff --git a/gdbus/mainloop.c b/gdbus/mainloop.c
index 9e493268..eaba42ea 100644
--- a/gdbus/mainloop.c
+++ b/gdbus/mainloop.c
@@ -2,7 +2,7 @@
  *
  *  D-Bus helper library
  *
- *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2004-2009  Marcel Holtmann <marcel@holtmann.org>
  *
  *
  *  This program is free software; you can redistribute it and/or modify
diff --git a/gdbus/object.c b/gdbus/object.c
index a41617d5..0786aebe 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -2,7 +2,7 @@
  *
  *  D-Bus helper library
  *
- *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2004-2009  Marcel Holtmann <marcel@holtmann.org>
  *
  *
  *  This program is free software; you can redistribute it and/or modify
diff --git a/gdbus/watch.c b/gdbus/watch.c
index ec3be640..38bf3d75 100644
--- a/gdbus/watch.c
+++ b/gdbus/watch.c
@@ -2,7 +2,7 @@
  *
  *  D-Bus helper library
  *
- *  Copyright (C) 2004-2008  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2004-2009  Marcel Holtmann <marcel@holtmann.org>
  *
  *
  *  This program is free software; you can redistribute it and/or modify
diff --git a/include/dbus.h b/include/dbus.h
index a0fe3fdc..895a96dc 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/device.h b/include/device.h
index b434db54..9487b70c 100644
--- a/include/device.h
+++ b/include/device.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/driver.h b/include/driver.h
index 696c53f2..2932d4d2 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/element.h b/include/element.h
index 906601e6..7e7774b0 100644
--- a/include/element.h
+++ b/include/element.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/ipv4.h b/include/ipv4.h
index 3cbf85b2..2f57d0c1 100644
--- a/include/ipv4.h
+++ b/include/ipv4.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/log.h b/include/log.h
index 81a5bc4f..e9ee8e49 100644
--- a/include/log.h
+++ b/include/log.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/network.h b/include/network.h
index 8dab190e..b0138f44 100644
--- a/include/network.h
+++ b/include/network.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/plugin.h b/include/plugin.h
index cbd1c12a..11a06095 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/property.h b/include/property.h
index fe734c26..35dbe5cf 100644
--- a/include/property.h
+++ b/include/property.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/resolver.h b/include/resolver.h
index d849e08a..d5fefe99 100644
--- a/include/resolver.h
+++ b/include/resolver.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/rtnl.h b/include/rtnl.h
index 5637fb9d..dcab14d2 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/security.h b/include/security.h
index a7806321..123e6fb3 100644
--- a/include/security.h
+++ b/include/security.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/include/types.h b/include/types.h
index f99ff079..648fee1e 100644
--- a/include/types.h
+++ b/include/types.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index ba5c3a29..5bde01d7 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 20de09ac..cb0e8753 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index e8df6bff..c97553d3 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 434e3b77..1ddf1fa9 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/fake.c b/plugins/fake.c
index 33165dab..b2e4b0f6 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/hso.c b/plugins/hso.c
index 98708ddd..bf7c2b3a 100644
--- a/plugins/hso.c
+++ b/plugins/hso.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/inet.c b/plugins/inet.c
index 97f338ec..b7d4a9f0 100644
--- a/plugins/inet.c
+++ b/plugins/inet.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/inet.h b/plugins/inet.h
index 23437ac5..af5799be 100644
--- a/plugins/inet.h
+++ b/plugins/inet.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index 5e19cbb8..b611fb04 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/loopback.c b/plugins/loopback.c
index 7dc47fe7..c0a8f3b9 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/modem.c b/plugins/modem.c
index 47d7e218..17036466 100644
--- a/plugins/modem.c
+++ b/plugins/modem.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/modem.h b/plugins/modem.h
index 6fabcb36..f26425cf 100644
--- a/plugins/modem.h
+++ b/plugins/modem.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/polkit.c b/plugins/polkit.c
index 5396ad2f..d3ca6924 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/pppd.c b/plugins/pppd.c
index 1cf304f6..3cd65bf0 100644
--- a/plugins/pppd.c
+++ b/plugins/pppd.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index 30002d5c..d59fc5e4 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
index a9009814..e89b2ca8 100644
--- a/plugins/resolvfile.c
+++ b/plugins/resolvfile.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index c51be358..0d7d293a 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index ef207d5c..4543d115 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/task.c b/plugins/task.c
index dae54c75..f0ef6584 100644
--- a/plugins/task.c
+++ b/plugins/task.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/task.h b/plugins/task.h
index 0234d47a..6472576a 100644
--- a/plugins/task.h
+++ b/plugins/task.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index 2cc3c61f..e53c4354 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/plugins/wifi.c b/plugins/wifi.c
index e07901c8..cdec24ff 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/scripts/dhclient-script.c b/scripts/dhclient-script.c
index bf2316d0..94543a05 100644
--- a/scripts/dhclient-script.c
+++ b/scripts/dhclient-script.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/scripts/pppd-plugin.c b/scripts/pppd-plugin.c
index 232d58ac..2dfdabc2 100644
--- a/scripts/pppd-plugin.c
+++ b/scripts/pppd-plugin.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/scripts/udhcpc-script.c b/scripts/udhcpc-script.c
index e5ac3e90..b5f9c54f 100644
--- a/scripts/udhcpc-script.c
+++ b/scripts/udhcpc-script.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/agent.c b/src/agent.c
index fbd8df3c..5ae62b23 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/connman.h b/src/connman.h
index 948fe771..4f781bd6 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/dbus.c b/src/dbus.c
index f985e950..062cc7ab 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/detect.c b/src/detect.c
index 57ea83ee..b82974ab 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/device.c b/src/device.c
index 3a1ae260..3930d75e 100644
--- a/src/device.c
+++ b/src/device.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/element.c b/src/element.c
index 85d92fda..e82337d6 100644
--- a/src/element.c
+++ b/src/element.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/error.c b/src/error.c
index a78c7990..5556d589 100644
--- a/src/error.c
+++ b/src/error.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/log.c b/src/log.c
index b195df2f..3d8a4e92 100644
--- a/src/log.c
+++ b/src/log.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/main.c b/src/main.c
index 51e1530b..8af1d6d8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/manager.c b/src/manager.c
index 14c8a6e6..ec579ff5 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/network.c b/src/network.c
index 6e966e34..977a48ee 100644
--- a/src/network.c
+++ b/src/network.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/plugin.c b/src/plugin.c
index c128505d..2ebe327f 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/profile.c b/src/profile.c
index 86907701..44dcf55f 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/resolver.c b/src/resolver.c
index 01e8cf9c..0f351888 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/rtnl.c b/src/rtnl.c
index e3584065..8107933d 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/security.c b/src/security.c
index 41d45e40..31c7734b 100644
--- a/src/security.c
+++ b/src/security.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/selftest.c b/src/selftest.c
index 17f77587..727181da 100644
--- a/src/selftest.c
+++ b/src/selftest.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/storage.c b/src/storage.c
index 3ed0fc17..41cfd420 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff --git a/src/udev.c b/src/udev.c
index 40ec8242..4896a1d8 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -2,7 +2,7 @@
  *
  *  Connection Manager
  *
- *  Copyright (C) 2007-2008  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as

commit 98ffc630a2e7a982174f698fc99c6c905e4896a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 19:45:18 2009 +0100

    Fix subtype conversion for networks

diff --git a/src/network.c b/src/network.c
index 977a48ee..1f4b265b 100644
--- a/src/network.c
+++ b/src/network.c
@@ -258,6 +258,12 @@ struct connman_network *connman_network_create(const char *identifier,
 	network->element.index = -1;
 
 	switch (type) {
+	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+		break;
+	case CONNMAN_NETWORK_TYPE_WIFI:
+		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
+		break;
 	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
 	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
 		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
@@ -265,9 +271,6 @@ struct connman_network *connman_network_create(const char *identifier,
 	case CONNMAN_NETWORK_TYPE_HSO:
 		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_CELLULAR;
 		break;
-	default:
-		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
-		break;
 	}
 
 	network->element.network = network;

commit f89b202b68eaf920e969e155aee2f40f5b063c45
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 19:46:14 2009 +0100

    Don't use default for enum based switch statements

diff --git a/src/detect.c b/src/detect.c
index b82974ab..8d64aeba 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -177,18 +177,20 @@ static void detect_newlink(unsigned short type, int index,
 			devtype = CONNMAN_DEVICE_TYPE_HSO;
 	}
 
-	if (devtype == CONNMAN_DEVICE_TYPE_UNKNOWN) {
+	switch (devtype) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
 		g_free(devname);
 		return;
-	}
-
-	switch (devtype) {
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+		name = index2ident(index, "dev_");
+		break;
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
 		name = strdup(devname);
 		break;
-	default:
-		name = index2ident(index, "dev_");
-		break;
 	}
 
 	device = connman_device_create(name, devtype);
diff --git a/src/device.c b/src/device.c
index 3930d75e..ee4d91cd 100644
--- a/src/device.c
+++ b/src/device.c
@@ -90,6 +90,8 @@ static const char *type2string(enum connman_device_type type)
 static const char *policy2string(enum connman_device_policy policy)
 {
 	switch (policy) {
+	case CONNMAN_DEVICE_POLICY_UNKNOWN:
+		break;
 	case CONNMAN_DEVICE_POLICY_IGNORE:
 		return "ignore";
 	case CONNMAN_DEVICE_POLICY_OFF:
@@ -98,9 +100,9 @@ static const char *policy2string(enum connman_device_policy policy)
 		return "auto";
 	case CONNMAN_DEVICE_POLICY_MANUAL:
 		return "manual";
-	default:
-		return NULL;
 	}
+
+	return NULL;
 }
 
 static enum connman_device_policy string2policy(const char *policy)
@@ -159,6 +161,10 @@ static int set_policy(DBusConnection *connection,
 		return 0;
 
 	switch (policy) {
+	case CONNMAN_DEVICE_POLICY_UNKNOWN:
+		return -EINVAL;
+	case CONNMAN_DEVICE_POLICY_IGNORE:
+		break;
 	case CONNMAN_DEVICE_POLICY_OFF:
 		if (device->powered == TRUE)
 			err = set_powered(device, FALSE);
@@ -168,8 +174,6 @@ static int set_policy(DBusConnection *connection,
 		if (device->powered == FALSE)
 			err = set_powered(device, TRUE);
 		break;
-	default:
-		break;
 	}
 
 	if (err < 0)
@@ -564,12 +568,17 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.index = -1;
 
 	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_HSO:
+		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
+		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
 		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
 		break;
-	default:
-		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
-		break;
 	}
 
 	device->element.device = device;

commit ee0c975fd361a75584040cc245ee5b4dbe6da381
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 20:01:19 2009 +0100

    Fix uninitialized varible warnings

diff --git a/src/detect.c b/src/detect.c
index 8d64aeba..e5f0db17 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -130,7 +130,7 @@ static void detect_newlink(unsigned short type, int index,
 					unsigned flags, unsigned change)
 {
 	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-	enum connman_device_mode mode;
+	enum connman_device_mode mode = CONNMAN_DEVICE_MODE_UNKNOWN;
 	struct connman_device *device;
 	gchar *name, *devname;
 
diff --git a/src/network.c b/src/network.c
index 1f4b265b..3bcb340b 100644
--- a/src/network.c
+++ b/src/network.c
@@ -400,7 +400,7 @@ int connman_network_set_connected(struct connman_network *network,
 
 	if (connected == TRUE) {
 		struct connman_element *element;
-		enum connman_element_type type;
+		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 
 		switch (network->protocol) {
 		case CONNMAN_NETWORK_PROTOCOL_UNKNOWN:

commit d7415ae9768d6bb51145ffc5327d78f1dd33aeff
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 20:19:24 2009 +0100

    Add udev rules definitions

diff --git a/.gitignore b/.gitignore
index 9c29734e..cff64720 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,6 +27,7 @@ src/connmand
 src/connman.exp
 src/connman.ver
 src/connman.service
+src/*-connman.rules
 scripts/connman
 scripts/udhcpc-script
 scripts/dhclient-script
diff --git a/src/Makefile.am b/src/Makefile.am
index 42a8a488..3ea9035a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,6 +12,10 @@ connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
 
 if UDEV
 connmand_SOURCES += udev.c
+
+rulesdir = $(sysconfdir)/udev/rules.d
+
+rules_DATA = 92-connman.rules
 endif
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @UDEV_LIBS@ -ldl
@@ -20,7 +24,7 @@ connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
 connmand_DEPENDENCIES = connman.ver
 
-CLEANFILES = connman.ver connman.exp
+CLEANFILES = connman.ver connman.exp 92-connman.rules
 
 statedir = $(localstatedir)/run/connman
 
@@ -36,10 +40,9 @@ AM_CFLAGS = @UDEV_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
 				-DSTATEDIR=\""$(statedir)"\" \
 					-DSTORAGEDIR=\""$(storagedir)\"" \
 						-DPLUGINDIR=\""$(plugindir)"\"
-
 INCLUDES = -I$(top_builddir)/include
 
-EXTRA_DIST = $(dbus_DATA)
+EXTRA_DIST = $(dbus_DATA) connman.rules
 
 MAINTAINERCLEANFILES = Makefile.in
 
@@ -50,3 +53,6 @@ connman.ver: connman.exp
 	echo "{ global:" > $@
 	cat $< | sed -e "s/\(.*\)/\1;/" >> $@
 	echo "local: *; };" >> $@
+
+92-connman.rules: connman.rules
+	cp $< $@
diff --git a/src/connman.rules b/src/connman.rules
new file mode 100644
index 00000000..35645134
--- /dev/null
+++ b/src/connman.rules
@@ -0,0 +1,6 @@
+
+DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
+
+SUBSYSTEM=="usb", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1003", ENV{CONNMAN_TYPE}="huawei"
+
+ENV{CONNMAN_TYPE}=="?*", RUN+="socket:@/org/moblin/connman/udev"

commit e44c851c368936f756d1c6b9aa20d3607a4af33c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 1 21:06:15 2009 +0100

    Add basic support for monitoring udev events

diff --git a/src/connman.h b/src/connman.h
index 4f781bd6..5dafe767 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -116,6 +116,9 @@ static inline void __connman_element_unlock(struct connman_element *element)
 int __connman_detect_init(void);
 void __connman_detect_cleanup(void);
 
+int __connman_udev_init(void);
+void __connman_udev_cleanup(void);
+
 #include <connman/device.h>
 
 int __connman_device_init(void);
diff --git a/src/main.c b/src/main.c
index 8af1d6d8..65cc9d4a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -163,6 +163,7 @@ int main(int argc, char *argv[])
 	__connman_profile_init(conn);
 
 	__connman_rtnl_init();
+	__connman_udev_init();
 
 	__connman_plugin_init();
 
@@ -181,6 +182,7 @@ int main(int argc, char *argv[])
 
 	__connman_plugin_cleanup();
 
+	__connman_udev_cleanup();
 	__connman_rtnl_cleanup();
 
 	__connman_profile_cleanup();
diff --git a/src/udev.c b/src/udev.c
index 4896a1d8..fcb0c4c8 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -29,4 +29,89 @@
 #define LIBUDEV_I_KNOW_THE_API_IS_SUBJECT_TO_CHANGE
 #include <libudev.h>
 
+#include <glib.h>
+
 #include "connman.h"
+
+static gboolean udev_event(GIOChannel *channel,
+				GIOCondition condition, gpointer user_data)
+{
+	struct udev_monitor *monitor = user_data;
+	struct udev_device *device;
+	const char *action, *sysname;
+
+	device = udev_monitor_receive_device(monitor);
+	if (device == NULL)
+		return TRUE;
+
+	action = udev_device_get_action(device);
+	if (action == NULL)
+		return TRUE;
+
+	sysname = udev_device_get_sysname(device);
+
+	DBG("%s %s", action, sysname);
+
+	return TRUE;
+}
+
+static struct udev *udev_ctx;
+static struct udev_monitor *udev_mon;
+static guint udev_watch = 0;
+
+int __connman_udev_init(void)
+{
+	GIOChannel *channel;
+	int fd;
+
+	DBG("");
+
+	udev_ctx = udev_new();
+	if (udev_ctx == NULL) {
+		connman_error("Failed to create udev context");
+		return -1;
+	}
+
+	udev_mon = udev_monitor_new_from_socket(udev_ctx,
+						"@/org/moblin/connman/udev");
+	if (udev_mon == NULL) {
+		connman_error("Failed to create udev monitor");
+		udev_unref(udev_ctx);
+		udev_ctx = NULL;
+		return -1;
+	}
+
+	if (udev_monitor_enable_receiving(udev_mon) < 0) {
+		connman_error("Failed to enable udev monitor");
+		udev_unref(udev_ctx);
+		udev_ctx = NULL;
+		udev_monitor_unref(udev_mon);
+		return -1;
+	}
+
+	fd = udev_monitor_get_fd(udev_mon);
+
+	channel = g_io_channel_unix_new(fd);
+	if (channel == NULL)
+		return 0;
+
+	udev_watch = g_io_add_watch(channel, G_IO_IN, udev_event, udev_mon);
+
+	g_io_channel_unref(channel);
+
+	return 0;
+}
+
+void __connman_udev_cleanup(void)
+{
+	DBG("");
+
+	if (udev_watch > 0)
+		g_source_remove(udev_watch);
+
+	if (udev_ctx == NULL)
+		return;
+
+	udev_monitor_unref(udev_mon);
+	udev_unref(udev_ctx);
+}

commit 963adcd8ba61a01d6d805002ed475ea65f4e8178
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 03:02:28 2009 +0100

    Update udev rules

diff --git a/src/connman.rules b/src/connman.rules
index 35645134..3cf20e1a 100644
--- a/src/connman.rules
+++ b/src/connman.rules
@@ -1,6 +1,8 @@
 
-DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
+SUBSYSTEM=="net", DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
 
-SUBSYSTEM=="usb", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1003", ENV{CONNMAN_TYPE}="huawei"
+SUBSYSTEM=="tty", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1003", \
+						ENV{CONNMAN_TYPE}="huawei"
 
-ENV{CONNMAN_TYPE}=="?*", RUN+="socket:@/org/moblin/connman/udev"
+ENV{CONNMAN_TYPE}=="?*", ENV{CONNMAN_INTERFACE}="$kernel", \
+				RUN+="socket:@/org/moblin/connman/udev"

commit 9b54445c85e6d93072d995d898e74348e4607c92
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 18:13:38 2009 +0100

    Add configure options to select plugins

diff --git a/Makefile.am b/Makefile.am
index 78c98b87..7f61d2b2 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -5,7 +5,10 @@ pkgconfigdir = $(libdir)/pkgconfig
 
 pkgconfig_DATA = connman.pc
 
-DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc
+DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
+				--enable-loopback \
+				--enable-wifi \
+				--enable-client
 
 DISTCLEANFILES = $(pkgconfig_DATA)
 
diff --git a/README b/README
index 70e88268..1cad5ab8 100644
--- a/README
+++ b/README
@@ -13,6 +13,7 @@ In order to compile Connection Manager you need following software packages:
 	- D-Bus library
 	- udev library (optional)
 	- PolicyKit (optional)
+	- PPP support (optional)
 
 To configure run:
 	./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var
diff --git a/bootstrap-configure b/bootstrap-configure
index 5a7e4dc1..54926b43 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -16,4 +16,10 @@ fi
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
 		--sysconfdir=/etc \
+		--enable-loopback \
+		--enable-wifi \
+		--enable-hso \
+		--enable-ppp \
+		--enable-udev \
+		--enable-polkit \
 		--enable-client $*
diff --git a/configure.ac b/configure.ac
index ad37741f..64000e1a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -43,14 +43,37 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
-AC_PATH_PROG(UDHCPC, [udhcpc], ,$PATH:/sbin:/usr/sbin)
-AC_PATH_PROG(DHCLIENT, [dhclient], ,$PATH:/sbin:/usr/sbin)
-AC_PATH_PROG(RESOLVCONF, [resolvconf], ,$PATH:/sbin:/usr/sbin)
-AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], ,$PATH:/sbin:/usr/sbin)
-AC_PATH_PROG(PPPD, [pppd], ,$PATH:/sbin:/usr/sbin)
-
-AC_CHECK_HEADERS(pppd/pppd.h, pppd_found=yes, pppd_found=no)
-AM_CONDITIONAL(PPPD, test "${pppd_found}" = "yes")
+AC_ARG_ENABLE(threads, AC_HELP_STRING([--enable-threads],
+		[enable threading support]), [enable_threads=${enableval}])
+
+AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
+AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
+AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
+
+AC_ARG_ENABLE(loopback, AC_HELP_STRING([--enable-loopback],
+		[enable loopback support]), [enable_loopback=${enableval}])
+AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" = "yes")
+
+AC_ARG_ENABLE(wifi, AC_HELP_STRING([--enable-wifi],
+		[enable WiFi support]), [enable_wifi=${enableval}])
+if (test "${enable_wifi}" = "yes"); then
+	AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], [],
+						$PATH:/sbin:/usr/sbin)
+fi
+AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
+
+AC_ARG_ENABLE(hso, AC_HELP_STRING([--enable-hso],
+		[enable HSO support]), [enable_hso=${enableval}])
+AM_CONDITIONAL(HSO, test "${enable_hso}" = "yes")
+
+AC_ARG_ENABLE(ppp, AC_HELP_STRING([--enable-ppp],
+		[enable PPP support]), [enable_udev=${enableval}])
+if (test "${enable_ppp}" = "yes"); then
+	AC_PATH_PROG(PPPD, [pppd], [], $PATH:/sbin:/usr/sbin)
+	AC_CHECK_HEADERS(pppd/pppd.h, enable_ppp=yes,
+			AC_MSG_ERROR(PPP development files are required))
+fi
+AM_CONDITIONAL(PPPD, test "${enable_ppp}" = "yes")
 
 AC_CHECK_LIB(dl, dlopen, dummy=yes,
 			AC_MSG_ERROR(dynamic linking loader is required))
@@ -60,15 +83,13 @@ PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
-AC_ARG_ENABLE(threads, AC_HELP_STRING([--enable-threads],
-					[enable threading support]), [
+if (test "${enable_threads}" = "yes"); then
 	AC_DEFINE(NEED_THREADS, 1, [Define if threading support is required])
-
 	PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
 				AC_MSG_ERROR(gthread is required))
 	GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
 	GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
-])
+fi
 
 PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(libdbus is required))
@@ -78,22 +99,33 @@ AC_SUBST(DBUS_LIBS)
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
 AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 
-PKG_CHECK_MODULES(UDEV, libudev >= 127, udev_found=yes, udev_found=no)
+AC_ARG_ENABLE(udev, AC_HELP_STRING([--enable-udev],
+		[enable udev support]), [enable_udev=${enableval}])
+if (test "${enable_udev}" = "yes"); then
+	AC_DEFINE(HAVE_UDEV, 1, [Define if udev support is available])
+	PKG_CHECK_MODULES(UDEV, libudev >= 127, enable_udev=yes,
+				AC_MSG_ERROR(udev >= 127 is required))
+fi
 AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
-AM_CONDITIONAL(UDEV, test "${udev_found}" = "yes")
-
-PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, polkit_found=yes, polkit_found=no)
-AC_SUBST(POLKIT_CFLAGS)
-AC_SUBST(POLKIT_LIBS)
-AM_CONDITIONAL(POLKIT, test "${polkit_found}" = "yes")
+AM_CONDITIONAL(UDEV, test "${enable_udev}" = "yes")
+
+AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
+		[enable PolicyKit support]), [enable_polkit=${enableval}])
+if (test "${enable_polkit}" = "yes"); then
+	PKG_CHECK_MODULES(POLKIT, polkit-dbus >= 0.7, enable_polkit=yes,
+				AC_MSG_ERROR(PolicyKit >= 0.7 is required))
+	AC_SUBST(POLKIT_CFLAGS)
+	AC_SUBST(POLKIT_LIBS)
+fi
+AM_CONDITIONAL(POLKIT, test "${enable_polkit}" = "yes")
 
 AC_ARG_ENABLE(client, AC_HELP_STRING([--enable-client],
 		[enable command line client]), [enable_client=${enableval}])
 AM_CONDITIONAL(CLIENT, test "${enable_client}" = "yes")
 
 AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
-			[enable fake plugin]), [enable_fake=${enableval}])
+		[enable fake device support]), [enable_fake=${enableval}])
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")
 
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile src/Makefile doc/Makefile
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 78e6b441..4d8815b6 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,21 +1,35 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = loopback.la ethernet.la wifi.la bluetooth.la hso.la \
-				udhcp.la dhclient.la ipv4.la dnsproxy.la \
-						resolvconf.la resolvfile.la
+plugin_LTLIBRARIES = ethernet.la bluetooth.la \
+				ipv4.la udhcp.la dhclient.la \
+				dnsproxy.la resolvconf.la resolvfile.la
+
+if LOOPBACK
+plugin_LTLIBRARIES += loopback.la
 
 loopback_la_SOURCES = loopback.c
+endif
 
 ethernet_la_SOURCES = ethernet.c inet.h inet.c
 
+if WIFI
+plugin_LTLIBRARIES += wifi.la
+
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
+endif
 
 bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
+if HSO
+plugin_LTLIBRARIES += hso.la
+
 hso_la_SOURCES = hso.c modem.h modem.c
+endif
+
+ipv4_la_SOURCES = ipv4.c inet.h inet.c
 
 udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
 udhcp_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DUDHCPC=\"@UDHCPC@\" \
@@ -31,8 +45,6 @@ plugin_LTLIBRARIES += pppd.la
 pppd_la_SOURCES = pppd.c
 endif
 
-ipv4_la_SOURCES = ipv4.c inet.h inet.c
-
 dnsproxy_la_SOURCES = dnsproxy.c
 
 resolvconf_la_SOURCES = resolvconf.c
diff --git a/src/connman.h b/src/connman.h
index 5dafe767..25f50858 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -116,8 +116,19 @@ static inline void __connman_element_unlock(struct connman_element *element)
 int __connman_detect_init(void);
 void __connman_detect_cleanup(void);
 
+#ifdef HAVE_UDEV
 int __connman_udev_init(void);
 void __connman_udev_cleanup(void);
+#else
+static inline int __connman_udev_init(void)
+{
+	return 0;
+}
+
+static inline void __connman_udev_cleanup(void)
+{
+}
+#endif
 
 #include <connman/device.h>
 

commit 1f2eb2336bf8a931b8be27d9ff5030d6e324c76f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 19:47:45 2009 +0100

    Fix typo in PPP enabling check

diff --git a/configure.ac b/configure.ac
index 64000e1a..ce99f4ea 100644
--- a/configure.ac
+++ b/configure.ac
@@ -67,7 +67,7 @@ AC_ARG_ENABLE(hso, AC_HELP_STRING([--enable-hso],
 AM_CONDITIONAL(HSO, test "${enable_hso}" = "yes")
 
 AC_ARG_ENABLE(ppp, AC_HELP_STRING([--enable-ppp],
-		[enable PPP support]), [enable_udev=${enableval}])
+		[enable PPP support]), [enable_ppp=${enableval}])
 if (test "${enable_ppp}" = "yes"); then
 	AC_PATH_PROG(PPPD, [pppd], [], $PATH:/sbin:/usr/sbin)
 	AC_CHECK_HEADERS(pppd/pppd.h, enable_ppp=yes,

commit 7c00f5fc19e3fbc03e62a8f1a6edb6068afbaa06
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 20:03:55 2009 +0100

    Add checks for unavailable udev functions

diff --git a/configure.ac b/configure.ac
index ce99f4ea..8b2abcdc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -103,6 +103,14 @@ AC_ARG_ENABLE(udev, AC_HELP_STRING([--enable-udev],
 		[enable udev support]), [enable_udev=${enableval}])
 if (test "${enable_udev}" = "yes"); then
 	AC_DEFINE(HAVE_UDEV, 1, [Define if udev support is available])
+	AC_CHECK_LIB(udev, udev_monitor_receive_device, dummy=yes,
+		AC_DEFINE(NEED_UDEV_MONITOR_RECEIVE_DEVICE, 1,
+			[Define to 1 if you need the
+				udev_monitor_receive_device() function.]))
+	AC_CHECK_LIB(udev, udev_device_get_action, dummy=yes,
+		AC_DEFINE(NEED_UDEV_DEVICE_GET_ACTION, 1,
+			[Define to 1 if you need the
+				udev_device_get_action() function.]))
 	PKG_CHECK_MODULES(UDEV, libudev >= 127, enable_udev=yes,
 				AC_MSG_ERROR(udev >= 127 is required))
 fi
diff --git a/src/udev.c b/src/udev.c
index fcb0c4c8..a14ce93b 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -33,12 +33,26 @@
 
 #include "connman.h"
 
+#ifdef NEED_UDEV_MONITOR_RECEIVE_DEVICE
+static struct udev_device *udev_monitor_receive_device(struct udev_monitor *monitor);
+{
+	return udev_monitor_get_device(monitor);
+}
+#endif
+
+#ifdef NEED_UDEV_DEVICE_GET_ACTION
+static const char *udev_device_get_action(struct udev_device *device)
+{
+	return NULL;
+}
+#endif
+
 static gboolean udev_event(GIOChannel *channel,
 				GIOCondition condition, gpointer user_data)
 {
 	struct udev_monitor *monitor = user_data;
 	struct udev_device *device;
-	const char *action, *sysname;
+	const char *action;
 
 	device = udev_monitor_receive_device(monitor);
 	if (device == NULL)
@@ -46,11 +60,12 @@ static gboolean udev_event(GIOChannel *channel,
 
 	action = udev_device_get_action(device);
 	if (action == NULL)
-		return TRUE;
+		goto done;
 
-	sysname = udev_device_get_sysname(device);
+	connman_debug("=== %s ===", action);
 
-	DBG("%s %s", action, sysname);
+done:
+	udev_device_unref(device);
 
 	return TRUE;
 }

commit 28be89368b487e1d524a1aec78c892e2dbc857ad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 20:08:59 2009 +0100

    Add check for udev_monitor_enable_receiving() function

diff --git a/configure.ac b/configure.ac
index 8b2abcdc..564f7c0f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -103,6 +103,10 @@ AC_ARG_ENABLE(udev, AC_HELP_STRING([--enable-udev],
 		[enable udev support]), [enable_udev=${enableval}])
 if (test "${enable_udev}" = "yes"); then
 	AC_DEFINE(HAVE_UDEV, 1, [Define if udev support is available])
+	AC_CHECK_LIB(udev, udev_monitor_enable_receiving, dummy=yes,
+		AC_DEFINE(NEED_UDEV_MONITOR_ENABLE_RECEIVING, 1,
+			[Define to 1 if you need the
+				udev_monitor_enable_receiving() function.]))
 	AC_CHECK_LIB(udev, udev_monitor_receive_device, dummy=yes,
 		AC_DEFINE(NEED_UDEV_MONITOR_RECEIVE_DEVICE, 1,
 			[Define to 1 if you need the
diff --git a/src/udev.c b/src/udev.c
index a14ce93b..5c90112c 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -33,6 +33,13 @@
 
 #include "connman.h"
 
+#ifdef NEED_UDEV_MONITOR_ENABLE_RECEIVING
+static int udev_monitor_enable_receiving(struct udev_monitor *monitor)
+{
+	return 0;
+}
+#endif
+
 #ifdef NEED_UDEV_MONITOR_RECEIVE_DEVICE
 static struct udev_device *udev_monitor_receive_device(struct udev_monitor *monitor);
 {

commit 6d38280e351fc249725e6928bd330cf2dbb23717
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 20:11:41 2009 +0100

    Remove wrongly placed semicolon

diff --git a/src/udev.c b/src/udev.c
index 5c90112c..0496da43 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -41,7 +41,7 @@ static int udev_monitor_enable_receiving(struct udev_monitor *monitor)
 #endif
 
 #ifdef NEED_UDEV_MONITOR_RECEIVE_DEVICE
-static struct udev_device *udev_monitor_receive_device(struct udev_monitor *monitor);
+static struct udev_device *udev_monitor_receive_device(struct udev_monitor *monitor)
 {
 	return udev_monitor_get_device(monitor);
 }

commit f9581a61c40273285f637dce99ab8a901f8de2bd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 20:37:49 2009 +0100

    Require udev >= 129 and add enumeration support

diff --git a/configure.ac b/configure.ac
index 564f7c0f..77197de7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -103,20 +103,16 @@ AC_ARG_ENABLE(udev, AC_HELP_STRING([--enable-udev],
 		[enable udev support]), [enable_udev=${enableval}])
 if (test "${enable_udev}" = "yes"); then
 	AC_DEFINE(HAVE_UDEV, 1, [Define if udev support is available])
-	AC_CHECK_LIB(udev, udev_monitor_enable_receiving, dummy=yes,
-		AC_DEFINE(NEED_UDEV_MONITOR_ENABLE_RECEIVING, 1,
+	PKG_CHECK_MODULES(UDEV, libudev >= 129, enable_udev=yes,
+				AC_MSG_ERROR(udev >= 129 is required))
+	AC_CHECK_LIB(udev, udev_device_get_parent_with_devtype, dummy=yes,
+		AC_DEFINE(NEED_UDEV_DEVICE_GET_PARENT_WITH_DEVTYPE, 1,
 			[Define to 1 if you need the
-				udev_monitor_enable_receiving() function.]))
-	AC_CHECK_LIB(udev, udev_monitor_receive_device, dummy=yes,
-		AC_DEFINE(NEED_UDEV_MONITOR_RECEIVE_DEVICE, 1,
+				udev_device_get_parent_with_devtype() function.]))
+	AC_CHECK_LIB(udev, udev_enumerate_add_match_property, dummy=yes,
+		AC_DEFINE(NEED_UDEV_ENUMERATE_ADD_MATCH_PROPERTY, 1,
 			[Define to 1 if you need the
-				udev_monitor_receive_device() function.]))
-	AC_CHECK_LIB(udev, udev_device_get_action, dummy=yes,
-		AC_DEFINE(NEED_UDEV_DEVICE_GET_ACTION, 1,
-			[Define to 1 if you need the
-				udev_device_get_action() function.]))
-	PKG_CHECK_MODULES(UDEV, libudev >= 127, enable_udev=yes,
-				AC_MSG_ERROR(udev >= 127 is required))
+				udev_enumerate_add_match_property() function.]))
 fi
 AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
diff --git a/src/udev.c b/src/udev.c
index 0496da43..eb14655c 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -23,7 +23,6 @@
 #include <config.h>
 #endif
 
-#include <stdarg.h>
 #include <sys/types.h>
 
 #define LIBUDEV_I_KNOW_THE_API_IS_SUBJECT_TO_CHANGE
@@ -33,26 +32,80 @@
 
 #include "connman.h"
 
-#ifdef NEED_UDEV_MONITOR_ENABLE_RECEIVING
-static int udev_monitor_enable_receiving(struct udev_monitor *monitor)
+#ifdef NEED_UDEV_DEVICE_GET_PARENT_WITH_DEVTYPE
+static struct udev_device *udev_device_get_parent_with_devtype(struct udev_device *device,
+								const char *devtype)
 {
-	return 0;
+	return NULL;
 }
 #endif
 
-#ifdef NEED_UDEV_MONITOR_RECEIVE_DEVICE
-static struct udev_device *udev_monitor_receive_device(struct udev_monitor *monitor)
+#ifdef NEED_UDEV_ENUMERATE_ADD_MATCH_PROPERTY
+static int udev_enumerate_add_match_property(struct udev_enumerate *enumerate,
+					const char *property, const char *value)
 {
-	return udev_monitor_get_device(monitor);
+	return 0;
 }
 #endif
 
-#ifdef NEED_UDEV_DEVICE_GET_ACTION
-static const char *udev_device_get_action(struct udev_device *device)
+static void print_properties(struct udev_device *device, const char *prefix)
 {
-	return NULL;
+	struct udev_list_entry *entry;
+
+	entry = udev_device_get_properties_list_entry(device);
+	while (entry) {
+		const char *name = udev_list_entry_get_name(entry);
+		const char *value = udev_list_entry_get_value(entry);
+
+		if (g_str_has_prefix(name, "CONNMAN") == TRUE ||
+				g_str_equal(name, "DEVNAME") == TRUE ||
+					g_str_equal(name, "DEVPATH") == TRUE)
+			connman_debug("%s%s = %s", prefix, name, value);
+
+		entry = udev_list_entry_get_next(entry);
+	}
+}
+
+static void print_device(struct udev_device *device, const char *action)
+{
+	struct udev_device *parent;
+
+	connman_debug("=== %s ===", action);
+	print_properties(device, "");
+
+	parent = udev_device_get_parent_with_devtype(device, "usb_device");
+	print_properties(parent, "    ");
+}
+
+static void enumerate_devices(struct udev *context)
+{
+	struct udev_enumerate *enumerate;
+	struct udev_list_entry *entry;
+
+	enumerate = udev_enumerate_new(context);
+	if (enumerate == NULL)
+		return;
+
+	udev_enumerate_add_match_property(enumerate, "CONNMAN_TYPE", "?*");
+
+	udev_enumerate_scan_devices(enumerate);
+
+	entry = udev_enumerate_get_list_entry(enumerate);
+	while (entry) {
+		const char *syspath = udev_list_entry_get_name(entry);
+		struct udev_device *device;
+
+		device = udev_device_new_from_syspath(context, syspath);
+
+		print_device(device, "coldplug");
+
+		udev_device_unref(device);
+
+		entry = udev_list_entry_get_next(entry);
+	}
+
+	udev_enumerate_unref(enumerate);
 }
-#endif
 
 static gboolean udev_event(GIOChannel *channel,
 				GIOCondition condition, gpointer user_data)
@@ -69,7 +122,7 @@ static gboolean udev_event(GIOChannel *channel,
 	if (action == NULL)
 		goto done;
 
-	connman_debug("=== %s ===", action);
+	print_device(device, action);
 
 done:
 	udev_device_unref(device);
@@ -111,6 +164,8 @@ int __connman_udev_init(void)
 		return -1;
 	}
 
+	enumerate_devices(udev_ctx);
+
 	fd = udev_monitor_get_fd(udev_mon);
 
 	channel = g_io_channel_unix_new(fd);

commit 384763cf5951681441c1828ca20d3fc21d8553b3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 21:26:39 2009 +0100

    Add device type for HUAWEI Mobile

diff --git a/include/device.h b/include/device.h
index 9487b70c..fb3c075c 100644
--- a/include/device.h
+++ b/include/device.h
@@ -42,6 +42,7 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_WIMAX     = 3,
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = 4,
 	CONNMAN_DEVICE_TYPE_HSO       = 11,
+	CONNMAN_DEVICE_TYPE_HUAWEI    = 12,
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
 };
 
diff --git a/src/detect.c b/src/detect.c
index e5f0db17..b7d43ffc 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -188,6 +188,7 @@ static void detect_newlink(unsigned short type, int index,
 		break;
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
 		name = strdup(devname);
 		break;
@@ -203,6 +204,7 @@ static void detect_newlink(unsigned short type, int index,
 	switch (devtype) {
 	case CONNMAN_DEVICE_TYPE_UNKNOWN:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
 		mode = CONNMAN_DEVICE_MODE_UNKNOWN;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
diff --git a/src/device.c b/src/device.c
index ee4d91cd..4696084d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -60,6 +60,7 @@ static const char *type2description(enum connman_device_type type)
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "Bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
 		return "Cellular";
 	}
 
@@ -81,6 +82,7 @@ static const char *type2string(enum connman_device_type type)
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
 		return "cellular";
 	}
 
@@ -574,6 +576,7 @@ struct connman_device *connman_device_create(const char *node,
 	case CONNMAN_DEVICE_TYPE_WIMAX:
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
 		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:

commit 109c78bb7a0e8dd9decf1ee234d76b56a4a062d3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:07:17 2009 +0100

    Add generic element iteration function

diff --git a/src/connman.h b/src/connman.h
index 25f50858..78fc4302 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -90,6 +90,11 @@ void __connman_element_start(void);
 void __connman_element_stop(void);
 void __connman_element_cleanup(void);
 
+typedef void (* element_cb_t) (struct connman_element *element, void *user_data);
+
+void __connman_element_foreach(struct connman_element *element,
+				enum connman_element_type type,
+				element_cb_t callback, gpointer user_data);
 void __connman_element_list(struct connman_element *element,
 					enum connman_element_type type,
 							DBusMessageIter *iter);
diff --git a/src/element.c b/src/element.c
index e82337d6..31eb9a5c 100644
--- a/src/element.c
+++ b/src/element.c
@@ -610,6 +610,53 @@ static GDBusSignalTable element_signals[] = {
 	{ },
 };
 
+struct foreach_data {
+	enum connman_element_type type;
+	element_cb_t callback;
+	gpointer user_data;
+};
+
+static gboolean foreach_callback(GNode *node, gpointer user_data)
+{
+	struct connman_element *element = node->data;
+	struct foreach_data *data = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return FALSE;
+
+	if (data->type != CONNMAN_ELEMENT_TYPE_UNKNOWN &&
+					data->type != element->type)
+		return FALSE;
+
+	if (data->callback)
+		data->callback(element, data->user_data);
+
+	return FALSE;
+}
+
+void __connman_element_foreach(struct connman_element *element,
+				enum connman_element_type type,
+				element_cb_t callback, gpointer user_data)
+{
+	struct foreach_data data = { type, callback, user_data };
+	GNode *node;
+
+	DBG("");
+
+	if (element != NULL) {
+		node = g_node_find(element_root, G_PRE_ORDER,
+						G_TRAVERSE_ALL, element);
+		if (node == NULL)
+			return;
+	} else
+		node = element_root;
+
+	g_node_traverse(node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
+						foreach_callback, &data);
+}
+
 struct append_filter {
 	enum connman_element_type type;
 	DBusMessageIter *iter;

commit 058b97a987c51323282c2f4f6aeebcf5a2576d83
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:14:56 2009 +0100

    Use correct type for user data

diff --git a/src/connman.h b/src/connman.h
index 78fc4302..e410ac1c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -90,7 +90,8 @@ void __connman_element_start(void);
 void __connman_element_stop(void);
 void __connman_element_cleanup(void);
 
-typedef void (* element_cb_t) (struct connman_element *element, void *user_data);
+typedef void (* element_cb_t) (struct connman_element *element,
+							gpointer user_data);
 
 void __connman_element_foreach(struct connman_element *element,
 				enum connman_element_type type,

commit 0a23309f85839e8cd1c65b53e8e5ff07bf588d4c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:15:46 2009 +0100

    Call disable and remove callbacks when unregistering a driver

diff --git a/src/device.c b/src/device.c
index 4696084d..8a281a40 100644
--- a/src/device.c
+++ b/src/device.c
@@ -475,6 +475,37 @@ static void unregister_interface(struct connman_element *element)
 						CONNMAN_DEVICE_INTERFACE);
 }
 
+static void device_enable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	if (device->policy == CONNMAN_DEVICE_POLICY_IGNORE ||
+				device->policy == CONNMAN_DEVICE_POLICY_OFF)
+		return;
+
+	if (device->powered == TRUE)
+		return;
+
+	if (device->driver->enable)
+		device->driver->enable(device);
+}
+
+static void device_disable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	if (device->policy == CONNMAN_DEVICE_POLICY_IGNORE)
+		return;
+
+	if (device->powered == FALSE)
+		return;
+
+	g_hash_table_remove_all(device->networks);
+
+	if (device->driver->disable)
+		device->driver->disable(device);
+}
+
 static GSList *driver_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -505,6 +536,25 @@ int connman_device_driver_register(struct connman_device_driver *driver)
 	return 0;
 }
 
+static void remove_driver(struct connman_element *element, gpointer user_data)
+{
+	struct connman_device_driver *driver = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->device == NULL)
+		return;
+
+	if (element->device->driver == driver) {
+		device_disable(element->device);
+
+		if (driver->remove)
+			driver->remove(element->device);
+
+		element->device->driver = NULL;
+	}
+}
+
 /**
  * connman_device_driver_unregister:
  * @driver: device driver definition
@@ -516,6 +566,9 @@ void connman_device_driver_unregister(struct connman_device_driver *driver)
 	DBG("driver %p name %s", driver, driver->name);
 
 	driver_list = g_slist_remove(driver_list, driver);
+
+	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_DEVICE,
+						remove_driver, driver);
 }
 
 static void unregister_network(gpointer data)
@@ -539,6 +592,7 @@ static void device_destruct(struct connman_element *element)
 	g_free(device->interface);
 
 	g_hash_table_destroy(device->networks);
+	device->networks = NULL;
 }
 
 /**
@@ -970,37 +1024,6 @@ void connman_device_set_data(struct connman_device *device, void *data)
 	device->driver_data = data;
 }
 
-static void device_enable(struct connman_device *device)
-{
-	DBG("device %p", device);
-
-	if (device->policy == CONNMAN_DEVICE_POLICY_IGNORE ||
-				device->policy == CONNMAN_DEVICE_POLICY_OFF)
-		return;
-
-	if (device->powered == TRUE)
-		return;
-
-	if (device->driver->enable)
-		device->driver->enable(device);
-}
-
-static void device_disable(struct connman_device *device)
-{
-	DBG("device %p", device);
-
-	if (device->policy == CONNMAN_DEVICE_POLICY_IGNORE)
-		return;
-
-	if (device->powered == FALSE)
-		return;
-
-	g_hash_table_remove_all(device->networks);
-
-	if (device->driver->disable)
-		device->driver->disable(device);
-}
-
 static gboolean match_driver(struct connman_device *device,
 					struct connman_device_driver *driver)
 {

commit 5bbbce97de441f908dfdb738f8816b31153b75b4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:16:44 2009 +0100

    Add configure switch for HUAWEI support

diff --git a/bootstrap-configure b/bootstrap-configure
index 54926b43..67346d07 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -18,6 +18,7 @@ fi
 		--sysconfdir=/etc \
 		--enable-loopback \
 		--enable-wifi \
+		--enable-huawei \
 		--enable-hso \
 		--enable-ppp \
 		--enable-udev \
diff --git a/configure.ac b/configure.ac
index 77197de7..f114c114 100644
--- a/configure.ac
+++ b/configure.ac
@@ -62,13 +62,17 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
+AC_ARG_ENABLE(huawei, AC_HELP_STRING([--enable-huawei],
+		[enable HUAWEI support]), [enable_huawei=${enableval}])
+AM_CONDITIONAL(HUAWEI, test "${enable_huawei}" = "yes")
+
 AC_ARG_ENABLE(hso, AC_HELP_STRING([--enable-hso],
 		[enable HSO support]), [enable_hso=${enableval}])
 AM_CONDITIONAL(HSO, test "${enable_hso}" = "yes")
 
 AC_ARG_ENABLE(ppp, AC_HELP_STRING([--enable-ppp],
 		[enable PPP support]), [enable_ppp=${enableval}])
-if (test "${enable_ppp}" = "yes"); then
+if (test "${enable_ppp}" = "yes" || test "${enable_huawei}" = "yes"); then
 	AC_PATH_PROG(PPPD, [pppd], [], $PATH:/sbin:/usr/sbin)
 	AC_CHECK_HEADERS(pppd/pppd.h, enable_ppp=yes,
 			AC_MSG_ERROR(PPP development files are required))

commit e8a00fbb2a7cd2d85d67774b2bda11641e8586b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:17:14 2009 +0100

    Add plugin skeleton for HUAWEI devices

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 4d8815b6..a7db8732 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -23,6 +23,12 @@ endif
 bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
+if HUAWEI
+plugin_LTLIBRARIES += huawei.la
+
+huawei_la_SOURCES = huawei.c modem.h modem.
+endif
+
 if HSO
 plugin_LTLIBRARIES += hso.la
 
diff --git a/plugins/huawei.c b/plugins/huawei.c
new file mode 100644
index 00000000..d0dbe494
--- /dev/null
+++ b/plugins/huawei.c
@@ -0,0 +1,83 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+#include <connman/plugin.h>
+#include <connman/device.h>
+#include <connman/log.h>
+
+#include "modem.h"
+
+static int huawei_probe(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static void huawei_remove(struct connman_device *device)
+{
+	DBG("device %p", device);
+}
+
+static int huawei_enable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	connman_device_set_powered(device, TRUE);
+
+	return 0;
+}
+
+static int huawei_disable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	connman_device_set_powered(device, FALSE);
+
+	return 0;
+}
+
+static struct connman_device_driver huawei_driver = {
+	.name		= "huawei-device",
+	.type		= CONNMAN_DEVICE_TYPE_HUAWEI,
+	.probe		= huawei_probe,
+	.remove		= huawei_remove,
+	.enable		= huawei_enable,
+	.disable	= huawei_disable,
+};
+
+static int huawei_init(void)
+{
+	return connman_device_driver_register(&huawei_driver);
+}
+
+static void huawei_exit(void)
+{
+	connman_device_driver_unregister(&huawei_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE(huawei, "Option HUAWEI device plugin", VERSION,
+						huawei_init, huawei_exit)

commit 2304b24632178e1ca33d99ec7687fab58425969b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:18:20 2009 +0100

    Add detection support for HUAWEI devices

diff --git a/src/udev.c b/src/udev.c
index eb14655c..58510aa1 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -48,6 +48,111 @@ static int udev_enumerate_add_match_property(struct udev_enumerate *enumerate,
 }
 #endif
 
+static GSList *device_list = NULL;
+
+static struct connman_device *find_device(const char *interface)
+{
+	GSList *list;
+
+	if (interface == NULL)
+		return NULL;
+
+	for (list = device_list; list; list = list->next) {
+		struct connman_device *device = list->data;
+		const char *device_interface;
+
+		device_interface = connman_device_get_interface(device);
+		if (device_interface == NULL)
+			continue;
+
+		if (g_str_equal(device_interface, interface) == TRUE)
+			return device;
+	}
+
+	return NULL;
+}
+
+static void add_device(struct udev_device *udev_device)
+{
+	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+	struct connman_device *device;
+	struct udev_list_entry *entry;
+	const char *type = NULL, *interface = NULL;
+
+	DBG("");
+
+	entry = udev_device_get_properties_list_entry(udev_device);
+	while (entry) {
+		const char *name = udev_list_entry_get_name(entry);
+
+		if (g_str_has_prefix(name, "CONNMAN_TYPE") == TRUE)
+			type = udev_list_entry_get_value(entry);
+		else if (g_str_has_prefix(name, "CONNMAN_INTERFACE") == TRUE)
+			interface = udev_list_entry_get_value(entry);
+
+		entry = udev_list_entry_get_next(entry);
+	}
+
+	device = find_device(interface);
+	if (device != NULL)
+		return;
+
+	if (type == NULL || interface == NULL)
+		return;
+
+	if (g_str_equal(interface, "ttyUSB0") == FALSE)
+		return;
+
+	if (g_str_equal(type, "huawei") == TRUE)
+		devtype = CONNMAN_DEVICE_TYPE_HUAWEI;
+	else
+		return;
+
+	device = connman_device_create(interface, devtype);
+	if (device == NULL)
+		return;
+
+	connman_device_set_mode(device, CONNMAN_DEVICE_MODE_NETWORK_SINGLE);
+	connman_device_set_policy(device, CONNMAN_DEVICE_POLICY_MANUAL);
+
+	connman_device_set_interface(device, interface);
+
+	if (connman_device_register(device) < 0) {
+		connman_device_unref(device);
+		return;
+	}
+
+	device_list = g_slist_append(device_list, device);
+}
+
+static void remove_device(struct udev_device *udev_device)
+{
+	struct connman_device *device;
+	struct udev_list_entry *entry;
+	const char *interface = NULL;
+
+	DBG("");
+
+	entry = udev_device_get_properties_list_entry(udev_device);
+	while (entry) {
+		const char *name = udev_list_entry_get_name(entry);
+
+		if (g_str_has_prefix(name, "CONNMAN_INTERFACE") == TRUE)
+			interface = udev_list_entry_get_value(entry);
+
+		entry = udev_list_entry_get_next(entry);
+	}
+
+	device = find_device(interface);
+	if (device == NULL)
+		return;
+
+	device_list = g_slist_remove(device_list, device);
+
+	connman_device_unregister(device);
+	connman_device_unref(device);
+}
+
 static void print_properties(struct udev_device *device, const char *prefix)
 {
 	struct udev_list_entry *entry;
@@ -99,6 +204,8 @@ static void enumerate_devices(struct udev *context)
 
 		print_device(device, "coldplug");
 
+		add_device(device);
+
 		udev_device_unref(device);
 
 		entry = udev_list_entry_get_next(entry);
@@ -124,6 +231,11 @@ static gboolean udev_event(GIOChannel *channel,
 
 	print_device(device, action);
 
+	if (g_str_equal(action, "add") == TRUE)
+		add_device(device);
+	else if (g_str_equal(action, "remove") == TRUE)
+		remove_device(device);
+
 done:
 	udev_device_unref(device);
 
@@ -181,11 +293,23 @@ int __connman_udev_init(void)
 
 void __connman_udev_cleanup(void)
 {
+	GSList *list;
+
 	DBG("");
 
 	if (udev_watch > 0)
 		g_source_remove(udev_watch);
 
+	for (list = device_list; list; list = list->next) {
+		struct connman_device *device = list->data;
+
+		connman_device_unregister(device);
+		connman_device_unref(device);
+	}
+
+	g_slist_free(device_list);
+	device_list = NULL;
+
 	if (udev_ctx == NULL)
 		return;
 

commit fd27ef7eefdb003c1f1967020d6e6ddab9426c30
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:20:36 2009 +0100

    Fix typo in sources list

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index a7db8732..520abb8a 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -26,7 +26,7 @@ bluetooth_la_LIBADD = @GDBUS_LIBS@
 if HUAWEI
 plugin_LTLIBRARIES += huawei.la
 
-huawei_la_SOURCES = huawei.c modem.h modem.
+huawei_la_SOURCES = huawei.c modem.h modem.c
 endif
 
 if HSO

commit ce65c266ed92290f8e8b7ccafe1d55a12fc3e22e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:32:43 2009 +0100

    Add device type for Novatel Wireless

diff --git a/include/device.h b/include/device.h
index fb3c075c..fcd8cc03 100644
--- a/include/device.h
+++ b/include/device.h
@@ -43,6 +43,7 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = 4,
 	CONNMAN_DEVICE_TYPE_HSO       = 11,
 	CONNMAN_DEVICE_TYPE_HUAWEI    = 12,
+	CONNMAN_DEVICE_TYPE_NOVATEL   = 13,
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
 };
 
diff --git a/src/detect.c b/src/detect.c
index b7d43ffc..5ae90834 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -189,6 +189,7 @@ static void detect_newlink(unsigned short type, int index,
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
 		name = strdup(devname);
 		break;
@@ -205,6 +206,7 @@ static void detect_newlink(unsigned short type, int index,
 	case CONNMAN_DEVICE_TYPE_UNKNOWN:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		mode = CONNMAN_DEVICE_MODE_UNKNOWN;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
diff --git a/src/device.c b/src/device.c
index 8a281a40..2851cb46 100644
--- a/src/device.c
+++ b/src/device.c
@@ -61,6 +61,7 @@ static const char *type2description(enum connman_device_type type)
 		return "Bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		return "Cellular";
 	}
 
@@ -83,6 +84,7 @@ static const char *type2string(enum connman_device_type type)
 		return "bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		return "cellular";
 	}
 
@@ -631,6 +633,7 @@ struct connman_device *connman_device_create(const char *node,
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:

commit d56ce7071953aaccaa56a3e3effbd5d59838be11
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:33:21 2009 +0100

    Add detection support for Novatel devices

diff --git a/src/connman.rules b/src/connman.rules
index 3cf20e1a..8a935cef 100644
--- a/src/connman.rules
+++ b/src/connman.rules
@@ -4,5 +4,8 @@ SUBSYSTEM=="net", DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
 SUBSYSTEM=="tty", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1003", \
 						ENV{CONNMAN_TYPE}="huawei"
 
+SUBSYSTEM=="tty", ATTRS{idVendor}=="1410", ATTRS{idProduct}=="4400", \
+						ENV{CONNMAN_TYPE}="novatel"
+
 ENV{CONNMAN_TYPE}=="?*", ENV{CONNMAN_INTERFACE}="$kernel", \
 				RUN+="socket:@/org/moblin/connman/udev"
diff --git a/src/udev.c b/src/udev.c
index 58510aa1..623962af 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -105,6 +105,8 @@ static void add_device(struct udev_device *udev_device)
 
 	if (g_str_equal(type, "huawei") == TRUE)
 		devtype = CONNMAN_DEVICE_TYPE_HUAWEI;
+	else if (g_str_equal(type, "novatel") == TRUE)
+		devtype = CONNMAN_DEVICE_TYPE_NOVATEL;
 	else
 		return;
 

commit bc97df35e6b11b4044fe827d859276deaade4a53
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:43:18 2009 +0100

    Add plugin skeleton for Novatel devices

diff --git a/bootstrap-configure b/bootstrap-configure
index 67346d07..63bdf089 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -18,6 +18,7 @@ fi
 		--sysconfdir=/etc \
 		--enable-loopback \
 		--enable-wifi \
+		--enable-novatel \
 		--enable-huawei \
 		--enable-hso \
 		--enable-ppp \
diff --git a/configure.ac b/configure.ac
index f114c114..e6028d72 100644
--- a/configure.ac
+++ b/configure.ac
@@ -62,6 +62,10 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
+AC_ARG_ENABLE(novatel, AC_HELP_STRING([--enable-novatel],
+		[enable Novatel support]), [enable_novatel=${enableval}])
+AM_CONDITIONAL(NOVATEL, test "${enable_novatel}" = "yes")
+
 AC_ARG_ENABLE(huawei, AC_HELP_STRING([--enable-huawei],
 		[enable HUAWEI support]), [enable_huawei=${enableval}])
 AM_CONDITIONAL(HUAWEI, test "${enable_huawei}" = "yes")
@@ -72,7 +76,8 @@ AM_CONDITIONAL(HSO, test "${enable_hso}" = "yes")
 
 AC_ARG_ENABLE(ppp, AC_HELP_STRING([--enable-ppp],
 		[enable PPP support]), [enable_ppp=${enableval}])
-if (test "${enable_ppp}" = "yes" || test "${enable_huawei}" = "yes"); then
+if (test "${enable_ppp}" = "yes" || test "${enable_novatel}" = "yes" ||
+					test "${enable_huawei}" = "yes"); then
 	AC_PATH_PROG(PPPD, [pppd], [], $PATH:/sbin:/usr/sbin)
 	AC_CHECK_HEADERS(pppd/pppd.h, enable_ppp=yes,
 			AC_MSG_ERROR(PPP development files are required))
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 520abb8a..e7376254 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -23,6 +23,12 @@ endif
 bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 
+if NOVATEL
+plugin_LTLIBRARIES += novatel.la
+
+novatel_la_SOURCES = novatel.c modem.h modem.c
+endif
+
 if HUAWEI
 plugin_LTLIBRARIES += huawei.la
 
diff --git a/plugins/novatel.c b/plugins/novatel.c
new file mode 100644
index 00000000..f43c5eb6
--- /dev/null
+++ b/plugins/novatel.c
@@ -0,0 +1,83 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+#include <connman/plugin.h>
+#include <connman/device.h>
+#include <connman/log.h>
+
+#include "modem.h"
+
+static int novatel_probe(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static void novatel_remove(struct connman_device *device)
+{
+	DBG("device %p", device);
+}
+
+static int novatel_enable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	connman_device_set_powered(device, TRUE);
+
+	return 0;
+}
+
+static int novatel_disable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	connman_device_set_powered(device, FALSE);
+
+	return 0;
+}
+
+static struct connman_device_driver novatel_driver = {
+	.name		= "novatel-device",
+	.type		= CONNMAN_DEVICE_TYPE_NOVATEL,
+	.probe		= novatel_probe,
+	.remove		= novatel_remove,
+	.enable		= novatel_enable,
+	.disable	= novatel_disable,
+};
+
+static int novatel_init(void)
+{
+	return connman_device_driver_register(&novatel_driver);
+}
+
+static void novatel_exit(void)
+{
+	connman_device_driver_unregister(&novatel_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE(novatel, "Novatel Wireless device plugin", VERSION,
+						novatel_init, novatel_exit)

commit 6d9bc499e72dd2505e1cf8310e5d58a091118ace
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:43:55 2009 +0100

    Fix plugin name spelling mistake

diff --git a/plugins/huawei.c b/plugins/huawei.c
index d0dbe494..2249048e 100644
--- a/plugins/huawei.c
+++ b/plugins/huawei.c
@@ -79,5 +79,5 @@ static void huawei_exit(void)
 	connman_device_driver_unregister(&huawei_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE(huawei, "Option HUAWEI device plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(huawei, "HUAWEI Mobile device plugin", VERSION,
 						huawei_init, huawei_exit)

commit 788f462b1eab20aaa15929f6a6d0f404084ee3b8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:45:15 2009 +0100

    Enable 3G plugins for distcheck building

diff --git a/Makefile.am b/Makefile.am
index 7f61d2b2..12669d6d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -8,6 +8,9 @@ pkgconfig_DATA = connman.pc
 DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
 				--enable-loopback \
 				--enable-wifi \
+				--enable-novatel \
+				--enable-huawei \
+				--enable-hso \
 				--enable-client
 
 DISTCLEANFILES = $(pkgconfig_DATA)

commit ed818c906f79faa633834f44b2e54916a59e579e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 22:51:16 2009 +0100

    The path_ifup[] and path_ifdown[] are Debian specific

diff --git a/scripts/pppd-plugin.c b/scripts/pppd-plugin.c
index 2dfdabc2..e8bae0e1 100644
--- a/scripts/pppd-plugin.c
+++ b/scripts/pppd-plugin.c
@@ -67,8 +67,10 @@ int plugin_init(void);
 
 int plugin_init(void)
 {
+#if 0
 	path_ipup[0] = '\0';
 	path_ipdown[0] = '\0';
+#endif
 
 	add_notifier(&phasechange, notifier_phasechange, NULL);
 	add_notifier(&exitnotify, notifier_exit, NULL);

commit e332ca14596915316a66e671fd2e0fd7e4e0fbca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 23:47:11 2009 +0100

    Add device type for Nozomi based hardware

diff --git a/include/device.h b/include/device.h
index fcd8cc03..44032b03 100644
--- a/include/device.h
+++ b/include/device.h
@@ -41,9 +41,10 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_WIFI      = 2,
 	CONNMAN_DEVICE_TYPE_WIMAX     = 3,
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = 4,
-	CONNMAN_DEVICE_TYPE_HSO       = 11,
-	CONNMAN_DEVICE_TYPE_HUAWEI    = 12,
-	CONNMAN_DEVICE_TYPE_NOVATEL   = 13,
+	CONNMAN_DEVICE_TYPE_HSO       = 15,
+	CONNMAN_DEVICE_TYPE_NOZOMI    = 16,
+	CONNMAN_DEVICE_TYPE_HUAWEI    = 17,
+	CONNMAN_DEVICE_TYPE_NOVATEL   = 18,
 	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
 };
 
diff --git a/src/detect.c b/src/detect.c
index 5ae90834..fab79d40 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -188,6 +188,7 @@ static void detect_newlink(unsigned short type, int index,
 		break;
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
@@ -205,6 +206,7 @@ static void detect_newlink(unsigned short type, int index,
 	switch (devtype) {
 	case CONNMAN_DEVICE_TYPE_UNKNOWN:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		mode = CONNMAN_DEVICE_MODE_UNKNOWN;
diff --git a/src/device.c b/src/device.c
index 2851cb46..c972c081 100644
--- a/src/device.c
+++ b/src/device.c
@@ -60,6 +60,7 @@ static const char *type2description(enum connman_device_type type)
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "Bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		return "Cellular";
@@ -84,6 +85,7 @@ static const char *type2string(enum connman_device_type type)
 		return "bluetooth";
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		return "cellular";
 	}
@@ -632,6 +634,7 @@ struct connman_device *connman_device_create(const char *node,
 	case CONNMAN_DEVICE_TYPE_WIMAX:
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;

commit df8540c0cd1e8cf3fe1a1de8f0594ecca0eac41d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 2 23:53:25 2009 +0100

    Add detection support for Nozomi based hardware

diff --git a/src/connman.rules b/src/connman.rules
index 8a935cef..84b3b4b6 100644
--- a/src/connman.rules
+++ b/src/connman.rules
@@ -1,6 +1,8 @@
 
 SUBSYSTEM=="net", DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
 
+SUBSYSTEM=="tty", KERNEL=="noz[0-9]*", ENV{CONNMAN_TYPE}="nozomi"
+
 SUBSYSTEM=="tty", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1003", \
 						ENV{CONNMAN_TYPE}="huawei"
 
diff --git a/src/udev.c b/src/udev.c
index 623962af..95faf603 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -100,10 +100,13 @@ static void add_device(struct udev_device *udev_device)
 	if (type == NULL || interface == NULL)
 		return;
 
-	if (g_str_equal(interface, "ttyUSB0") == FALSE)
+	if (g_str_equal(interface, "ttyUSB0") == FALSE &&
+				g_str_equal(interface, "noz0") == FALSE)
 		return;
 
-	if (g_str_equal(type, "huawei") == TRUE)
+	if (g_str_equal(type, "nozomi") == TRUE)
+		devtype = CONNMAN_DEVICE_TYPE_NOZOMI;
+	else if (g_str_equal(type, "huawei") == TRUE)
 		devtype = CONNMAN_DEVICE_TYPE_HUAWEI;
 	else if (g_str_equal(type, "novatel") == TRUE)
 		devtype = CONNMAN_DEVICE_TYPE_NOVATEL;

commit 702997aac795e8ae435e6795ead195ee80bf169a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 00:35:43 2009 +0100

    Print properties with ID_MODEM prefix

diff --git a/src/udev.c b/src/udev.c
index 95faf603..f5c2f30d 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -168,7 +168,8 @@ static void print_properties(struct udev_device *device, const char *prefix)
 		const char *value = udev_list_entry_get_value(entry);
 
 		if (g_str_has_prefix(name, "CONNMAN") == TRUE ||
-				g_str_equal(name, "DEVNAME") == TRUE ||
+				g_str_has_prefix(name, "ID_MODEM") == TRUE ||
+					g_str_equal(name, "DEVNAME") == TRUE ||
 					g_str_equal(name, "DEVPATH") == TRUE)
 			connman_debug("%s%s = %s", prefix, name, value);
 

commit e2bef6e12a0fdbbe5bea8adf23de1c589e9207e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 03:14:58 2009 +0100

    Add configure options for udhcp and dhclient

diff --git a/Makefile.am b/Makefile.am
index 12669d6d..d30424ec 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -8,6 +8,8 @@ pkgconfig_DATA = connman.pc
 DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
 				--enable-loopback \
 				--enable-wifi \
+				--enable-udhcp \
+				--enable-dhclient \
 				--enable-novatel \
 				--enable-huawei \
 				--enable-hso \
diff --git a/bootstrap-configure b/bootstrap-configure
index 63bdf089..c9d8ebe0 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -18,6 +18,8 @@ fi
 		--sysconfdir=/etc \
 		--enable-loopback \
 		--enable-wifi \
+		--enable-udhcp \
+		--enable-dhclient \
 		--enable-novatel \
 		--enable-huawei \
 		--enable-hso \
diff --git a/configure.ac b/configure.ac
index e6028d72..6e461def 100644
--- a/configure.ac
+++ b/configure.ac
@@ -46,10 +46,6 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 AC_ARG_ENABLE(threads, AC_HELP_STRING([--enable-threads],
 		[enable threading support]), [enable_threads=${enableval}])
 
-AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
-AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
-AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
-
 AC_ARG_ENABLE(loopback, AC_HELP_STRING([--enable-loopback],
 		[enable loopback support]), [enable_loopback=${enableval}])
 AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" = "yes")
@@ -62,6 +58,22 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
+AC_ARG_ENABLE(UDHCP, AC_HELP_STRING([--enable-udhcp],
+		[enable uDHCP support]), [enable_udhcp=${enableval}])
+if (test "${enable_udhcp}" = "yes"); then
+	AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
+fi
+AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" = "yes")
+
+AC_ARG_ENABLE(DHCLIENT, AC_HELP_STRING([--enable-dhclient],
+		[enable dhclient support]), [enable_dhclient=${enableval}])
+if (test "${enable_dhclient}" = "yes"); then
+	AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
+fi
+AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" = "yes")
+
+AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
+
 AC_ARG_ENABLE(novatel, AC_HELP_STRING([--enable-novatel],
 		[enable Novatel support]), [enable_novatel=${enableval}])
 AM_CONDITIONAL(NOVATEL, test "${enable_novatel}" = "yes")
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index e7376254..597da4b2 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,8 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = ethernet.la bluetooth.la \
-				ipv4.la udhcp.la dhclient.la \
-				dnsproxy.la resolvconf.la resolvfile.la
+			ipv4.la dnsproxy.la resolvconf.la resolvfile.la
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -43,13 +42,21 @@ endif
 
 ipv4_la_SOURCES = ipv4.c inet.h inet.c
 
+if UDHCP
+plugin_LTLIBRARIES += udhcp.la
+
 udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
 udhcp_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DUDHCPC=\"@UDHCPC@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
+endif
+
+if DHCLIENT
+plugin_LTLIBRARIES += dhclient.la
 
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
+endif
 
 if PPPD
 plugin_LTLIBRARIES += pppd.la

commit 50fc4f8dc9db472923e43bc82daffa9fc7c4fc22
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 03:45:16 2009 +0100

    Add options to specific udhcpc and dhclient programs

diff --git a/configure.ac b/configure.ac
index 6e461def..5b9d9adb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,8 +24,6 @@ AC_PROG_LIBTOOL
 
 GTK_DOC_CHECK
 
-AC_PATH_PROG([XSLTPROC], [xsltproc])
-
 AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
@@ -58,17 +56,33 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
+AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
+		[Specific udhcpc binary]), [path_udhcpc=${withval}])
+
 AC_ARG_ENABLE(UDHCP, AC_HELP_STRING([--enable-udhcp],
 		[enable uDHCP support]), [enable_udhcp=${enableval}])
 if (test "${enable_udhcp}" = "yes"); then
-	AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
+	if (test -z "${path_udhcpc}"); then
+		AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
+	else
+		UDHCPC="${path_udhcpc}"
+		AC_SUBST(UDHCPC)
+	fi
 fi
 AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" = "yes")
 
+AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
+		[Specific dhclient binary]), [path_dhclient=${withval}])
+
 AC_ARG_ENABLE(DHCLIENT, AC_HELP_STRING([--enable-dhclient],
 		[enable dhclient support]), [enable_dhclient=${enableval}])
 if (test "${enable_dhclient}" = "yes"); then
-	AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
+	if (test -z "${path_dhclient}"); then
+		AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
+	else
+		UDHCPC="${path_dhclient}"
+		AC_SUBST(DHCLIENT)
+	fi
 fi
 AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" = "yes")
 

commit da179e47dc9e719c3fdfc86dadf08249f13b3c30
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 03:52:11 2009 +0100

    Add option for location of pppd binary

diff --git a/configure.ac b/configure.ac
index 5b9d9adb..adee2fe3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -57,7 +57,7 @@ fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
 AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
-		[Specific udhcpc binary]), [path_udhcpc=${withval}])
+	[specific location of udhcpc binary]), [path_udhcpc=${withval}])
 
 AC_ARG_ENABLE(UDHCP, AC_HELP_STRING([--enable-udhcp],
 		[enable uDHCP support]), [enable_udhcp=${enableval}])
@@ -72,7 +72,7 @@ fi
 AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" = "yes")
 
 AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
-		[Specific dhclient binary]), [path_dhclient=${withval}])
+	[specific location of dhclient binary]), [path_dhclient=${withval}])
 
 AC_ARG_ENABLE(DHCLIENT, AC_HELP_STRING([--enable-dhclient],
 		[enable dhclient support]), [enable_dhclient=${enableval}])
@@ -100,11 +100,19 @@ AC_ARG_ENABLE(hso, AC_HELP_STRING([--enable-hso],
 		[enable HSO support]), [enable_hso=${enableval}])
 AM_CONDITIONAL(HSO, test "${enable_hso}" = "yes")
 
+AC_ARG_WITH(pppd, AC_HELP_STRING([--with-pppd=PROGRAM],
+	[specific location of pppd binary]), [path_pppd=${withval}])
+
 AC_ARG_ENABLE(ppp, AC_HELP_STRING([--enable-ppp],
 		[enable PPP support]), [enable_ppp=${enableval}])
 if (test "${enable_ppp}" = "yes" || test "${enable_novatel}" = "yes" ||
 					test "${enable_huawei}" = "yes"); then
-	AC_PATH_PROG(PPPD, [pppd], [], $PATH:/sbin:/usr/sbin)
+	if (test -z "${path_pppd}"); then
+		AC_PATH_PROG(PPPD, [pppd], [], $PATH:/sbin:/usr/sbin)
+	else
+		PPPD="${path_pppd}"
+		AC_SUBST(PPPD)
+	fi
 	AC_CHECK_HEADERS(pppd/pppd.h, enable_ppp=yes,
 			AC_MSG_ERROR(PPP development files are required))
 fi

commit 7821ba72b7eed428523c54db877397c0f6bdff57
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 11:32:00 2009 +0100

    Use udev_device_get_parent_with_subsystem_devtype() function

diff --git a/configure.ac b/configure.ac
index adee2fe3..2a4900c9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -148,14 +148,15 @@ if (test "${enable_udev}" = "yes"); then
 	AC_DEFINE(HAVE_UDEV, 1, [Define if udev support is available])
 	PKG_CHECK_MODULES(UDEV, libudev >= 129, enable_udev=yes,
 				AC_MSG_ERROR(udev >= 129 is required))
-	AC_CHECK_LIB(udev, udev_device_get_parent_with_devtype, dummy=yes,
-		AC_DEFINE(NEED_UDEV_DEVICE_GET_PARENT_WITH_DEVTYPE, 1,
-			[Define to 1 if you need the
-				udev_device_get_parent_with_devtype() function.]))
 	AC_CHECK_LIB(udev, udev_enumerate_add_match_property, dummy=yes,
 		AC_DEFINE(NEED_UDEV_ENUMERATE_ADD_MATCH_PROPERTY, 1,
 			[Define to 1 if you need the
 				udev_enumerate_add_match_property() function.]))
+	AC_CHECK_LIB(udev, udev_device_get_parent_with_subsystem_devtype, dummy=yes,
+		AC_DEFINE(NEED_UDEV_DEVICE_GET_PARENT_WITH_SUBSYSTEM_DEVTYPE, 1,
+			[Define to 1 if you need the
+				udev_device_get_parent_with_subsystem_devtype()
+									function.]))
 fi
 AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
diff --git a/src/udev.c b/src/udev.c
index f5c2f30d..4ce3f4e9 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -32,19 +32,19 @@
 
 #include "connman.h"
 
-#ifdef NEED_UDEV_DEVICE_GET_PARENT_WITH_DEVTYPE
-static struct udev_device *udev_device_get_parent_with_devtype(struct udev_device *device,
-								const char *devtype)
+#ifdef NEED_UDEV_ENUMERATE_ADD_MATCH_PROPERTY
+static int udev_enumerate_add_match_property(struct udev_enumerate *enumerate,
+					const char *property, const char *value)
 {
-	return NULL;
+	return -EINVAL;
 }
 #endif
 
-#ifdef NEED_UDEV_ENUMERATE_ADD_MATCH_PROPERTY
-static int udev_enumerate_add_match_property(struct udev_enumerate *enumerate,
-					const char *property, const char *value)
+#ifdef NEED_UDEV_DEVICE_GET_PARENT_WITH_SUBSYSTEM_DEVTYPE
+static struct udev_device *udev_device_get_parent_with_subsystem_devtype(struct udev_device *device,
+						const char *subsystem, const char *devtype)
 {
-	return 0;
+	return NULL;
 }
 #endif
 
@@ -179,12 +179,18 @@ static void print_properties(struct udev_device *device, const char *prefix)
 
 static void print_device(struct udev_device *device, const char *action)
 {
+	const char *subsystem = udev_device_get_subsystem(device);
+	const char *devtype = NULL;
 	struct udev_device *parent;
 
 	connman_debug("=== %s ===", action);
 	print_properties(device, "");
 
-	parent = udev_device_get_parent_with_devtype(device, "usb_device");
+	if (subsystem != NULL && g_str_equal(subsystem, "usb") == TRUE)
+		devtype = "usb_device";
+
+	parent = udev_device_get_parent_with_subsystem_devtype(device,
+							subsystem, devtype);
 	print_properties(parent, "    ");
 }
 

commit ef15fdd2b73da041cb3cd623ca0b4ce0c856644a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 11:41:53 2009 +0100

    Remove some empty lines to make it more readable

diff --git a/src/main.c b/src/main.c
index 65cc9d4a..88afc111 100644
--- a/src/main.c
+++ b/src/main.c
@@ -153,13 +153,10 @@ int main(int argc, char *argv[])
 	__connman_dbus_init(conn);
 
 	__connman_storage_init();
-
 	__connman_element_init(conn, option_device);
 
 	__connman_agent_init(conn);
-
 	__connman_manager_init(conn, option_compat);
-
 	__connman_profile_init(conn);
 
 	__connman_rtnl_init();
@@ -186,13 +183,10 @@ int main(int argc, char *argv[])
 	__connman_rtnl_cleanup();
 
 	__connman_profile_cleanup();
-
 	__connman_manager_cleanup();
-
 	__connman_agent_cleanup();
 
 	__connman_element_cleanup();
-
 	__connman_storage_cleanup();
 
 	__connman_dbus_cleanup();

commit 136ce2c05ed1fdd3033215bd9f15867c56b6dc4f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 11:49:58 2009 +0100

    Make /etc/resolv.conf modification part of the daemon

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 597da4b2..1d9c85a3 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -2,7 +2,7 @@
 plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES = ethernet.la bluetooth.la \
-			ipv4.la dnsproxy.la resolvconf.la resolvfile.la
+					ipv4.la dnsproxy.la resolvconf.la
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -69,8 +69,6 @@ dnsproxy_la_SOURCES = dnsproxy.c
 resolvconf_la_SOURCES = resolvconf.c
 resolvconf_la_CFLAGS = @GLIB_CFLAGS@ -DRESOLVCONF=\"@RESOLVCONF@\"
 
-resolvfile_la_SOURCES = resolvfile.c
-
 if POLKIT
 plugin_LTLIBRARIES += polkit.la
 
diff --git a/plugins/resolvfile.c b/plugins/resolvfile.c
deleted file mode 100644
index e89b2ca8..00000000
--- a/plugins/resolvfile.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *
- *  Connection Manager
- *
- *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/stat.h>
-
-#define CONNMAN_API_SUBJECT_TO_CHANGE
-#include <connman/plugin.h>
-#include <connman/resolver.h>
-#include <connman/log.h>
-
-#include <glib.h>
-
-static int resolvfile_append(const char *interface, const char *domain,
-							const char *server)
-{
-	char *cmd;
-	int fd, len, err;
-
-	DBG("server %s", server);
-
-	fd = open("/etc/resolv.conf", O_RDWR | O_CREAT,
-					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
-	if (fd < 0)
-		return errno;
-
-	err = ftruncate(fd, 0);
-
-	cmd = g_strdup_printf("nameserver %s\n", server);
-
-	len = write(fd, cmd, strlen(cmd));
-
-	g_free(cmd);
-
-	close(fd);
-
-	return 0;
-}
-
-static int resolvfile_remove(const char *interface, const char *domain,
-							const char *server)
-{
-	DBG("server %s", server);
-
-	return 0;
-}
-
-static struct connman_resolver resolvfile_resolver = {
-	.name		= "resolvfile",
-	.priority	= CONNMAN_RESOLVER_PRIORITY_LOW,
-	.append		= resolvfile_append,
-	.remove		= resolvfile_remove,
-};
-
-static int resolvfile_init(void)
-{
-	return connman_resolver_register(&resolvfile_resolver);
-}
-
-static void resolvfile_exit(void)
-{
-	connman_resolver_unregister(&resolvfile_resolver);
-}
-
-CONNMAN_PLUGIN_DEFINE(resolvfile, "Name resolver plugin", VERSION,
-					resolvfile_init, resolvfile_exit)
diff --git a/src/connman.h b/src/connman.h
index e410ac1c..cb5f72a8 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -77,6 +77,9 @@ enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
 
 #include <connman/resolver.h>
 
+int __connman_resolver_init(void);
+void __connman_resolver_cleanup(void);
+
 int __connman_resolver_selftest(void);
 
 #include <connman/driver.h>
diff --git a/src/main.c b/src/main.c
index 88afc111..971359de 100644
--- a/src/main.c
+++ b/src/main.c
@@ -159,6 +159,7 @@ int main(int argc, char *argv[])
 	__connman_manager_init(conn, option_compat);
 	__connman_profile_init(conn);
 
+	__connman_resolver_init();
 	__connman_rtnl_init();
 	__connman_udev_init();
 
@@ -181,6 +182,7 @@ int main(int argc, char *argv[])
 
 	__connman_udev_cleanup();
 	__connman_rtnl_cleanup();
+	__connman_resolver_cleanup();
 
 	__connman_profile_cleanup();
 	__connman_manager_cleanup();
diff --git a/src/resolver.c b/src/resolver.c
index 0f351888..de60cf13 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -23,6 +23,13 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/stat.h>
+
 #include "connman.h"
 
 struct entry_data {
@@ -231,3 +238,58 @@ int __connman_resolver_selftest(void)
 
 	return 0;
 }
+
+static int resolvfile_append(const char *interface, const char *domain,
+							const char *server)
+{
+	char *cmd;
+	int fd, len, err;
+
+	DBG("interface %s server %s", interface, server);
+
+	fd = open("/etc/resolv.conf", O_RDWR | O_CREAT,
+					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+	if (fd < 0)
+		return errno;
+
+	err = ftruncate(fd, 0);
+
+	cmd = g_strdup_printf("nameserver %s\n", server);
+
+	len = write(fd, cmd, strlen(cmd));
+
+	g_free(cmd);
+
+	close(fd);
+
+	return 0;
+}
+
+static int resolvfile_remove(const char *interface, const char *domain,
+							const char *server)
+{
+	DBG("interface %s server %s", interface, server);
+
+	return 0;
+}
+
+static struct connman_resolver resolvfile_resolver = {
+	.name		= "resolvfile",
+	.priority	= CONNMAN_RESOLVER_PRIORITY_LOW,
+	.append		= resolvfile_append,
+	.remove		= resolvfile_remove,
+};
+
+int __connman_resolver_init(void)
+{
+	DBG("");
+
+	return connman_resolver_register(&resolvfile_resolver);
+}
+
+void __connman_resolver_cleanup(void)
+{
+	DBG("");
+
+	connman_resolver_unregister(&resolvfile_resolver);
+}

commit 264e2b2c025b44104ac97f084ba3ad2ff3ed67c9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 11:57:07 2009 +0100

    Add option for selecting resolvconf support

diff --git a/bootstrap-configure b/bootstrap-configure
index c9d8ebe0..5abeb4b1 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -20,6 +20,7 @@ fi
 		--enable-wifi \
 		--enable-udhcp \
 		--enable-dhclient \
+		--enable-resolvconf \
 		--enable-novatel \
 		--enable-huawei \
 		--enable-hso \
diff --git a/configure.ac b/configure.ac
index 2a4900c9..9b70b041 100644
--- a/configure.ac
+++ b/configure.ac
@@ -86,7 +86,20 @@ if (test "${enable_dhclient}" = "yes"); then
 fi
 AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" = "yes")
 
-AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
+AC_ARG_WITH(resolvconf, AC_HELP_STRING([--with-resolvconf=PROGRAM],
+	[specific location of resolvconf binary]), [path_resolvconf=${withval}])
+
+AC_ARG_ENABLE(RESOLVCONF, AC_HELP_STRING([--enable-resolvconf],
+		[enable resolvconf support]), [enable_resolvconf=${enableval}])
+if (test "${enable_resolvconf}" = "yes"); then
+	if (test -z "${path_resolvconf}"); then
+		AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
+	else
+		UDHCPC="${path_resolvconf}"
+		AC_SUBST(RESOLVCONF)
+	fi
+fi
+AM_CONDITIONAL(RESOLVCONF, test "${enable_resolvconf}" = "yes")
 
 AC_ARG_ENABLE(novatel, AC_HELP_STRING([--enable-novatel],
 		[enable Novatel support]), [enable_novatel=${enableval}])
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 1d9c85a3..4f72e8a3 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,8 +1,7 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = ethernet.la bluetooth.la \
-					ipv4.la dnsproxy.la resolvconf.la
+plugin_LTLIBRARIES = ethernet.la bluetooth.la ipv4.la dnsproxy.la
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -66,8 +65,12 @@ endif
 
 dnsproxy_la_SOURCES = dnsproxy.c
 
+if RESOLVCONF
+plugin_LTLIBRARIES += resolvconf.la
+
 resolvconf_la_SOURCES = resolvconf.c
 resolvconf_la_CFLAGS = @GLIB_CFLAGS@ -DRESOLVCONF=\"@RESOLVCONF@\"
+endif
 
 if POLKIT
 plugin_LTLIBRARIES += polkit.la

commit d8d3470ebc609dd702a1bce7b1ab07b105f9e4ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 11:58:22 2009 +0100

    Use correct flags for PPP plugin

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 4f72e8a3..f2b280c2 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -61,6 +61,7 @@ if PPPD
 plugin_LTLIBRARIES += pppd.la
 
 pppd_la_SOURCES = pppd.c
+pppd_la_CFLAGS = @GLIB_CFLAGS@ -DPPPD=\"@PPPD@\"
 endif
 
 dnsproxy_la_SOURCES = dnsproxy.c

commit 18a1d464eceb21cfb1956f4991fa6d5ddc7b31c2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:01:18 2009 +0100

    Fix minor spelling mistake

diff --git a/configure.ac b/configure.ac
index 9b70b041..39dbced2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -57,7 +57,7 @@ fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
 AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
-	[specific location of udhcpc binary]), [path_udhcpc=${withval}])
+	[specify location of udhcpc binary]), [path_udhcpc=${withval}])
 
 AC_ARG_ENABLE(UDHCP, AC_HELP_STRING([--enable-udhcp],
 		[enable uDHCP support]), [enable_udhcp=${enableval}])
@@ -72,7 +72,7 @@ fi
 AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" = "yes")
 
 AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
-	[specific location of dhclient binary]), [path_dhclient=${withval}])
+	[specify location of dhclient binary]), [path_dhclient=${withval}])
 
 AC_ARG_ENABLE(DHCLIENT, AC_HELP_STRING([--enable-dhclient],
 		[enable dhclient support]), [enable_dhclient=${enableval}])
@@ -87,7 +87,7 @@ fi
 AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" = "yes")
 
 AC_ARG_WITH(resolvconf, AC_HELP_STRING([--with-resolvconf=PROGRAM],
-	[specific location of resolvconf binary]), [path_resolvconf=${withval}])
+	[specify location of resolvconf binary]), [path_resolvconf=${withval}])
 
 AC_ARG_ENABLE(RESOLVCONF, AC_HELP_STRING([--enable-resolvconf],
 		[enable resolvconf support]), [enable_resolvconf=${enableval}])
@@ -114,7 +114,7 @@ AC_ARG_ENABLE(hso, AC_HELP_STRING([--enable-hso],
 AM_CONDITIONAL(HSO, test "${enable_hso}" = "yes")
 
 AC_ARG_WITH(pppd, AC_HELP_STRING([--with-pppd=PROGRAM],
-	[specific location of pppd binary]), [path_pppd=${withval}])
+	[specify location of pppd binary]), [path_pppd=${withval}])
 
 AC_ARG_ENABLE(ppp, AC_HELP_STRING([--enable-ppp],
 		[enable PPP support]), [enable_ppp=${enableval}])

commit e74ab412afdec651878550085ac24b32398c34cc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:12:08 2009 +0100

    Add option for selecting DNS proxy support

diff --git a/bootstrap-configure b/bootstrap-configure
index 5abeb4b1..3a25cd3b 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -21,6 +21,7 @@ fi
 		--enable-udhcp \
 		--enable-dhclient \
 		--enable-resolvconf \
+		--enable-dnsproxy \
 		--enable-novatel \
 		--enable-huawei \
 		--enable-hso \
diff --git a/configure.ac b/configure.ac
index 39dbced2..987b8175 100644
--- a/configure.ac
+++ b/configure.ac
@@ -101,6 +101,10 @@ if (test "${enable_resolvconf}" = "yes"); then
 fi
 AM_CONDITIONAL(RESOLVCONF, test "${enable_resolvconf}" = "yes")
 
+AC_ARG_ENABLE(dnsproxy, AC_HELP_STRING([--enable-dnsproxy],
+		[enable DNS proxy support]), [enable_dnsproxy=${enableval}])
+AM_CONDITIONAL(DNSPROXY, test "${enable_dnsproxy}" = "yes")
+
 AC_ARG_ENABLE(novatel, AC_HELP_STRING([--enable-novatel],
 		[enable Novatel support]), [enable_novatel=${enableval}])
 AM_CONDITIONAL(NOVATEL, test "${enable_novatel}" = "yes")
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index f2b280c2..ac6714dd 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,7 +1,7 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = ethernet.la bluetooth.la ipv4.la dnsproxy.la
+plugin_LTLIBRARIES = ethernet.la bluetooth.la ipv4.la
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -64,8 +64,6 @@ pppd_la_SOURCES = pppd.c
 pppd_la_CFLAGS = @GLIB_CFLAGS@ -DPPPD=\"@PPPD@\"
 endif
 
-dnsproxy_la_SOURCES = dnsproxy.c
-
 if RESOLVCONF
 plugin_LTLIBRARIES += resolvconf.la
 
@@ -73,6 +71,12 @@ resolvconf_la_SOURCES = resolvconf.c
 resolvconf_la_CFLAGS = @GLIB_CFLAGS@ -DRESOLVCONF=\"@RESOLVCONF@\"
 endif
 
+if DNSPROXY
+plugin_LTLIBRARIES += dnsproxy.la
+
+dnsproxy_la_SOURCES = dnsproxy.c
+endif
+
 if POLKIT
 plugin_LTLIBRARIES += polkit.la
 

commit 5a092b90341686a22614b9b17098b774bc5c6a8b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:12:58 2009 +0100

    Enable resolver plugins for distcheck building

diff --git a/Makefile.am b/Makefile.am
index d30424ec..baa7ebfe 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -10,6 +10,8 @@ DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
 				--enable-wifi \
 				--enable-udhcp \
 				--enable-dhclient \
+				--enable-resolvconf \
+				--enable-dnsproxy \
 				--enable-novatel \
 				--enable-huawei \
 				--enable-hso \

commit bd8061321a42dc36b4f7550bf2d094d0ff00d4d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:30:36 2009 +0100

    Add option for selecting Ethernet support

diff --git a/Makefile.am b/Makefile.am
index baa7ebfe..57b99799 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -7,6 +7,7 @@ pkgconfig_DATA = connman.pc
 
 DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
 				--enable-loopback \
+				--enable-ethernet \
 				--enable-wifi \
 				--enable-udhcp \
 				--enable-dhclient \
diff --git a/bootstrap-configure b/bootstrap-configure
index 3a25cd3b..aa133719 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -17,6 +17,7 @@ fi
 		--localstatedir=/var \
 		--sysconfdir=/etc \
 		--enable-loopback \
+		--enable-ethernet \
 		--enable-wifi \
 		--enable-udhcp \
 		--enable-dhclient \
diff --git a/configure.ac b/configure.ac
index 987b8175..24ee83ff 100644
--- a/configure.ac
+++ b/configure.ac
@@ -48,6 +48,10 @@ AC_ARG_ENABLE(loopback, AC_HELP_STRING([--enable-loopback],
 		[enable loopback support]), [enable_loopback=${enableval}])
 AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" = "yes")
 
+AC_ARG_ENABLE(ethernet, AC_HELP_STRING([--enable-ethernet],
+		[enable Ethernet support]), [enable_ethernet=${enableval}])
+AM_CONDITIONAL(ETHERNET, test "${enable_ethernet}" = "yes")
+
 AC_ARG_ENABLE(wifi, AC_HELP_STRING([--enable-wifi],
 		[enable WiFi support]), [enable_wifi=${enableval}])
 if (test "${enable_wifi}" = "yes"); then
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index ac6714dd..e90f4944 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,7 +1,7 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = ethernet.la bluetooth.la ipv4.la
+plugin_LTLIBRARIES = bluetooth.la ipv4.la
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -9,7 +9,11 @@ plugin_LTLIBRARIES += loopback.la
 loopback_la_SOURCES = loopback.c
 endif
 
+if ETHERNET
+plugin_LTLIBRARIES += ethernet.la
+
 ethernet_la_SOURCES = ethernet.c inet.h inet.c
+endif
 
 if WIFI
 plugin_LTLIBRARIES += wifi.la

commit 0e3549125f6144e25c466fd4a6846a952a0e4208
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:36:08 2009 +0100

    Add proper enabled checks for DHCP scripts

diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 9cf4e009..3beb16a7 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -9,14 +9,23 @@ scriptdir = $(libdir)/connman/scripts
 
 script_DATA = dhclient.conf
 
-script_PROGRAMS = udhcpc-script dhclient-script
+script_PROGRAMS =
+script_LTLIBRARIES =
+
+if UDHCP
+script_PROGRAMS += udhcpc-script
 
 udhcpc_script_LDADD = @DBUS_LIBS@
+endif
+
+if DHCLIENT
+script_PROGRAMS += dhclient-script
 
 dhclient_script_LDADD = @DBUS_LIBS@
+endif
 
 if PPPD
-script_LTLIBRARIES = pppd-plugin.la
+script_LTLIBRARIES += pppd-plugin.la
 
 pppd_plugin_la_LDFLAGS = -module -avoid-version
 endif

commit e14024bc43c7dfe0b5876826c55b84ecfedae5f2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:42:26 2009 +0100

    Don't install dhclient.conf if not enabled

diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 3beb16a7..47664d23 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -7,8 +7,7 @@ DISTCLEANFILES = $(init_SCRIPTS)
 
 scriptdir = $(libdir)/connman/scripts
 
-script_DATA = dhclient.conf
-
+script_DATA =
 script_PROGRAMS =
 script_LTLIBRARIES =
 
@@ -19,6 +18,7 @@ udhcpc_script_LDADD = @DBUS_LIBS@
 endif
 
 if DHCLIENT
+script_DATA += dhclient.conf
 script_PROGRAMS += dhclient-script
 
 dhclient_script_LDADD = @DBUS_LIBS@

commit 8bb3839b86abf6d024044aac95292ad52cc77cf8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:47:15 2009 +0100

    Include dhclient.conf in distribution

diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 47664d23..a0c63633 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -32,6 +32,6 @@ endif
 
 AM_CFLAGS = @DBUS_CFLAGS@
 
-EXTRA_DIST = $(script_DATA)
+EXTRA_DIST = dhclient.conf
 
 MAINTAINERCLEANFILES = Makefile.in

commit 4113a9a26b4ecdef89de8006cbf9755cc8656e4f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:50:58 2009 +0100

    Fix broken option names

diff --git a/configure.ac b/configure.ac
index 24ee83ff..f31adace 100644
--- a/configure.ac
+++ b/configure.ac
@@ -63,7 +63,7 @@ AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
 	[specify location of udhcpc binary]), [path_udhcpc=${withval}])
 
-AC_ARG_ENABLE(UDHCP, AC_HELP_STRING([--enable-udhcp],
+AC_ARG_ENABLE(udhcp, AC_HELP_STRING([--enable-udhcp],
 		[enable uDHCP support]), [enable_udhcp=${enableval}])
 if (test "${enable_udhcp}" = "yes"); then
 	if (test -z "${path_udhcpc}"); then
@@ -78,7 +78,7 @@ AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" = "yes")
 AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
 	[specify location of dhclient binary]), [path_dhclient=${withval}])
 
-AC_ARG_ENABLE(DHCLIENT, AC_HELP_STRING([--enable-dhclient],
+AC_ARG_ENABLE(dhclient, AC_HELP_STRING([--enable-dhclient],
 		[enable dhclient support]), [enable_dhclient=${enableval}])
 if (test "${enable_dhclient}" = "yes"); then
 	if (test -z "${path_dhclient}"); then
@@ -93,7 +93,7 @@ AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" = "yes")
 AC_ARG_WITH(resolvconf, AC_HELP_STRING([--with-resolvconf=PROGRAM],
 	[specify location of resolvconf binary]), [path_resolvconf=${withval}])
 
-AC_ARG_ENABLE(RESOLVCONF, AC_HELP_STRING([--enable-resolvconf],
+AC_ARG_ENABLE(resolvconf, AC_HELP_STRING([--enable-resolvconf],
 		[enable resolvconf support]), [enable_resolvconf=${enableval}])
 if (test "${enable_resolvconf}" = "yes"); then
 	if (test -z "${path_resolvconf}"); then

commit ff0c50794b063e961775fc8fbe4fe7277bd7102d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 12:59:19 2009 +0100

    Add option for selecting Bluetooth support

diff --git a/Makefile.am b/Makefile.am
index 57b99799..5f40b57e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -9,6 +9,7 @@ DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
 				--enable-loopback \
 				--enable-ethernet \
 				--enable-wifi \
+				--enable-bluetooth \
 				--enable-udhcp \
 				--enable-dhclient \
 				--enable-resolvconf \
diff --git a/bootstrap-configure b/bootstrap-configure
index aa133719..164c535a 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -19,6 +19,7 @@ fi
 		--enable-loopback \
 		--enable-ethernet \
 		--enable-wifi \
+		--enable-bluetooth \
 		--enable-udhcp \
 		--enable-dhclient \
 		--enable-resolvconf \
diff --git a/configure.ac b/configure.ac
index f31adace..f9f9a8a5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -60,6 +60,10 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
+AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--enable-bluetooth],
+		[enable Bluetooth support]), [enable_bluetooth=${enableval}])
+AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" = "yes")
+
 AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
 	[specify location of udhcpc binary]), [path_udhcpc=${withval}])
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index e90f4944..9b013ad2 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,7 +1,7 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = bluetooth.la ipv4.la
+plugin_LTLIBRARIES = ipv4.la
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -22,8 +22,12 @@ wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
 endif
 
+if BLUETOOTH
+plugin_LTLIBRARIES += bluetooth.la
+
 bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
+endif
 
 if NOVATEL
 plugin_LTLIBRARIES += novatel.la

commit 3a6bc9d1470e1196923e95d0095e38a4b710e078
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 13:41:58 2009 +0100

    Add documentation for configure options

diff --git a/README b/README
index 1cad5ab8..989198c3 100644
--- a/README
+++ b/README
@@ -22,3 +22,104 @@ Configure automatically searches for all required components and packages.
 
 To compile and install run:
 	make && make install
+
+
+Configuration and options
+=========================
+
+For a working system, certain configuration options need to be enabled:
+
+	--enable-ethernet
+
+		Enable support for Ethernet network cards
+
+	--enable-wifi
+
+		Enable support for WiFi devices (requires wpa_supplicant)
+
+
+	--enable-bluetooth
+
+		Enable support for Bluetooth devices (requires BlueZ)
+
+	--enable-ppp
+
+		Enable PPP support for dialup connections (requires pppd)
+
+		The location of the pppd binary is auto-detected, but it
+		can be overwritten via --with-pppd=<path-to-binary>.
+
+	--enable-udhcp
+
+		Enable DHCP client support for BusyBox based systems
+
+		The location of the udhcpc binary is auto-detected, but it
+		can be overwritten via --with-udhcpc=<path-to-binary>.
+
+	--enable-dhclient
+
+		Enable DHCP client support for ISC dhclient based systems
+
+		The location of the dhclient binary is auto-detected, but it
+		can be overwritten via --with-dhclient=<path-to-binary>.
+
+		At least one DHCP client option should be selected. It is
+		possible to select both and then uDHCP will be tried first
+		before falling back to dhclient.
+
+	--enable-dnsproxy
+
+		Enable DNS proxy support for /etc/resolv.conf abstraction
+
+		The best solution for multiple connections and proper DNS
+		handling is a DNS proxy server. This binds a DNS proxy
+		server to port 53 on the loopback interface (127.0.0.1).
+
+		The /etc/resolv.conf file needs a "nameserver 127.0.0.1"
+		entry, but can now set the immutable bit or be on a read-only
+		filesystem. No further modification to that file will be made.
+
+		It is important that this is not used together with other
+		DNS proxy solution like dnsmasq.
+
+	--enable-resolvconf
+
+		Enable resolvconf support for Debian/Ubuntu based systems
+
+		The resolvconf package from Debian can be used to handle
+		configuration of the /etc/resolv.conf file.
+
+		It is safe to select this option even when resolvconf is not
+		installed. A missing resolvconf will be detected and in that
+		case it falls back to modifying /etc/resolv.conf directly.
+
+		The location of the resolvconf binary is auto-detected, but it
+		can be overwritten via --with-resolvconf=<path-to-binary>.
+
+	--enable-loopback
+
+		Enable setup of loopback device
+
+		For distributions with a really minimal init system and no
+		networking scripts this can take care of setting up the
+		loopback device and enabling it.
+
+		It is safe to select this option even if networking scripts
+		are in place. It detects an already configured loopback
+		device and leaves it as it is.
+
+	--enable-udev
+
+		Enable device detection support via udev
+
+		Network devices are by default detected via the builtin RTNL
+		functionality. This allows to detect TTY based modem devices
+		via udev.
+
+	--enable-polkit
+
+		Enable support for PolicyKit authorization
+
+		This allows to check every D-Bus access against a security
+		policy and so restrict access to certain functionality.
+

commit 8d21832bcf8cef0708c9d19a771d679140135ea5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 15:01:35 2009 +0100

    Add skeleton for future WiMAX plugin

diff --git a/bootstrap-configure b/bootstrap-configure
index 164c535a..340d80b4 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -19,6 +19,7 @@ fi
 		--enable-loopback \
 		--enable-ethernet \
 		--enable-wifi \
+		--enable-wimax \
 		--enable-bluetooth \
 		--enable-udhcp \
 		--enable-dhclient \
diff --git a/configure.ac b/configure.ac
index f9f9a8a5..393bee61 100644
--- a/configure.ac
+++ b/configure.ac
@@ -60,6 +60,10 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
+AC_ARG_ENABLE(wimax, AC_HELP_STRING([--enable-wimax],
+		[enable WiMAX support]), [enable_wimax=${enableval}])
+AM_CONDITIONAL(WIMAX, test "${enable_wimax}" = "yes")
+
 AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--enable-bluetooth],
 		[enable Bluetooth support]), [enable_bluetooth=${enableval}])
 AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" = "yes")
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 9b013ad2..71ae0cf9 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -22,6 +22,12 @@ wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
 endif
 
+if WIMAX
+plugin_LTLIBRARIES += wimax.la
+
+wimax_la_SOURCES = wimax.c
+endif
+
 if BLUETOOTH
 plugin_LTLIBRARIES += bluetooth.la
 
diff --git a/plugins/wimax.c b/plugins/wimax.c
new file mode 100644
index 00000000..e008dc92
--- /dev/null
+++ b/plugins/wimax.c
@@ -0,0 +1,77 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+#include <connman/plugin.h>
+#include <connman/device.h>
+#include <connman/log.h>
+
+static int wimax_probe(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static void wimax_remove(struct connman_device *device)
+{
+	DBG("device %p", device);
+}
+
+static int wimax_enable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static int wimax_disable(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static struct connman_device_driver wimax_driver = {
+	.name		= "wimax",
+	.type		= CONNMAN_DEVICE_TYPE_WIMAX,
+	.probe		= wimax_probe,
+	.remove		= wimax_remove,
+	.enable		= wimax_enable,
+	.disable	= wimax_disable,
+};
+
+static int wimax_init(void)
+{
+	return connman_device_driver_register(&wimax_driver);
+}
+
+static void wimax_exit(void)
+{
+	connman_device_driver_unregister(&wimax_driver);
+}
+
+CONNMAN_PLUGIN_DEFINE(wimax, "WiMAX interface plugin", VERSION,
+						wimax_init, wimax_exit)

commit 46bf753b500e4d4246cfca7626e14e8d0fbfff66
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 15:28:20 2009 +0100

    Fix detection of common parent device

diff --git a/src/udev.c b/src/udev.c
index 4ce3f4e9..0109f644 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -169,8 +169,10 @@ static void print_properties(struct udev_device *device, const char *prefix)
 
 		if (g_str_has_prefix(name, "CONNMAN") == TRUE ||
 				g_str_has_prefix(name, "ID_MODEM") == TRUE ||
-					g_str_equal(name, "DEVNAME") == TRUE ||
-					g_str_equal(name, "DEVPATH") == TRUE)
+				g_str_equal(name, "ID_VENDOR") == TRUE ||
+				g_str_equal(name, "ID_MODEL") == TRUE ||
+				g_str_equal(name, "DEVNAME") == TRUE ||
+				g_str_equal(name, "DEVPATH") == TRUE)
 			connman_debug("%s%s = %s", prefix, name, value);
 
 		entry = udev_list_entry_get_next(entry);
@@ -179,15 +181,23 @@ static void print_properties(struct udev_device *device, const char *prefix)
 
 static void print_device(struct udev_device *device, const char *action)
 {
-	const char *subsystem = udev_device_get_subsystem(device);
-	const char *devtype = NULL;
+	const char *subsystem, *devtype = NULL;
 	struct udev_device *parent;
 
 	connman_debug("=== %s ===", action);
 	print_properties(device, "");
 
-	if (subsystem != NULL && g_str_equal(subsystem, "usb") == TRUE)
+	parent = udev_device_get_parent(device);
+	if (parent == NULL)
+		return;
+
+	subsystem = udev_device_get_subsystem(parent);
+
+	if (subsystem != NULL &&
+			g_str_equal(subsystem, "usb-serial") == TRUE) {
+		subsystem = "usb";
 		devtype = "usb_device";
+	}
 
 	parent = udev_device_get_parent_with_subsystem_devtype(device,
 							subsystem, devtype);

commit a9462d1a974d2ba42948234f5ada7ee2cc8372bb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 16:03:35 2009 +0100

    Add another missing CONNMAN_API_SUBJECT_TO_CHANGE

diff --git a/plugins/fake.c b/plugins/fake.c
index b2e4b0f6..1ea9cc5a 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
 #include <connman/element.h>

commit 652df3c51e689741df34c905554b8264f70026b5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 3 16:13:40 2009 +0100

    Release 0.6

diff --git a/ChangeLog b/ChangeLog
index 8955af96..d41905e4 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,20 @@
+ver 0.6:
+	Add CONNMAN_API_SUBJECT_TO_CHANGE definition.
+	Add detailed configuration options.
+	Add various D-Bus helper functions.
+	Add generic device driver infrastructure.
+	Add generic network driver infrastructure.
+	Add property for WiFi network mode.
+	Add property for network interface name.
+	Add property for global connection policy.
+	Add support for verbose compiler warnings.
+	Add support for device detection via udev.
+	Add support for systems with udhcpc.
+	Add support for Bluetooth PAN networks.
+	Fix WiFi issue with DHCP restart after handshake.
+	Fix exported symbols list creation.
+	Remove deprecated and unused plugins.
+
 ver 0.5:
 	Add support for handling Bluetooth adapters.
 	Add support for activating wpa_supplicant on demand.
diff --git a/configure.ac b/configure.ac
index 393bee61..570d95f4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.5)
+AM_INIT_AUTOMAKE(connman, 0.6)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit aaf7e33db53954cc5a8c87e0cc6f3264fcc62b51
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 02:57:15 2009 +0100

    Don't list devices without drivers

diff --git a/src/connman.h b/src/connman.h
index cb5f72a8..889a8276 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -144,6 +144,8 @@ static inline void __connman_udev_cleanup(void)
 int __connman_device_init(void);
 void __connman_device_cleanup(void);
 
+connman_bool_t __connman_device_has_driver(struct connman_device *device);
+
 #include <connman/network.h>
 
 int __connman_network_init(void);
diff --git a/src/device.c b/src/device.c
index c972c081..e8095734 100644
--- a/src/device.c
+++ b/src/device.c
@@ -42,6 +42,8 @@ struct connman_device {
 	struct connman_device_driver *driver;
 	void *driver_data;
 
+	connman_bool_t registered;
+
 	GHashTable *networks;
 };
 
@@ -464,6 +466,8 @@ static int register_interface(struct connman_element *element)
 		return -EIO;
 	}
 
+	device->registered = TRUE;
+
 	emit_devices_signal();
 
 	return 0;
@@ -471,8 +475,12 @@ static int register_interface(struct connman_element *element)
 
 static void unregister_interface(struct connman_element *element)
 {
+	struct connman_device *device = element->device;
+
 	DBG("element %p name %s", element, element->name);
 
+	device->registered = FALSE;
+
 	emit_devices_signal();
 
 	g_dbus_unregister_interface(connection, element->path,
@@ -510,6 +518,77 @@ static void device_disable(struct connman_device *device)
 		device->driver->disable(device);
 }
 
+static int setup_device(struct connman_device *device)
+{
+	int err;
+
+	DBG("device %p", device);
+
+	err = register_interface(&device->element);
+	if (err < 0) {
+		if (device->driver->remove)
+			device->driver->remove(device);
+		device->driver = NULL;
+		return err;
+	}
+
+	device_enable(device);
+
+	return 0;
+}
+
+static void probe_driver(struct connman_element *element, gpointer user_data)
+{
+	struct connman_device_driver *driver = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->device == NULL)
+		return;
+
+	if (driver->probe(element->device) < 0)
+		return;
+
+	element->device->driver = driver;
+
+	setup_device(element->device);
+}
+
+static void remove_device(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	device_disable(device);
+
+	unregister_interface(&device->element);
+
+	if (device->driver->remove)
+		device->driver->remove(device);
+
+	device->driver = NULL;
+}
+
+static void remove_driver(struct connman_element *element, gpointer user_data)
+{
+	struct connman_device_driver *driver = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->device == NULL)
+		return;
+
+	if (element->device->driver == driver)
+		remove_device(element->device);
+}
+
+connman_bool_t __connman_device_has_driver(struct connman_device *device)
+{
+	if (device->driver == NULL)
+		return FALSE;
+
+	return device->registered;
+}
+
 static GSList *driver_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -535,30 +614,12 @@ int connman_device_driver_register(struct connman_device_driver *driver)
 	driver_list = g_slist_insert_sorted(driver_list, driver,
 							compare_priority);
 
-	//__connman_driver_rescan(&device_driver);
+	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_DEVICE,
+						probe_driver, driver);
 
 	return 0;
 }
 
-static void remove_driver(struct connman_element *element, gpointer user_data)
-{
-	struct connman_device_driver *driver = user_data;
-
-	DBG("element %p name %s", element, element->name);
-
-	if (element->device == NULL)
-		return;
-
-	if (element->device->driver == driver) {
-		device_disable(element->device);
-
-		if (driver->remove)
-			driver->remove(element->device);
-
-		element->device->driver = NULL;
-	}
-}
-
 /**
  * connman_device_driver_unregister:
  * @driver: device driver definition
@@ -1044,7 +1105,6 @@ static int device_probe(struct connman_element *element)
 {
 	struct connman_device *device = element->device;
 	GSList *list;
-	int err;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -1068,16 +1128,7 @@ static int device_probe(struct connman_element *element)
 	if (device->driver == NULL)
 		return -ENODEV;
 
-	err = register_interface(element);
-	if (err < 0) {
-		if (device->driver->remove)
-			device->driver->remove(device);
-		return err;
-	}
-
-	device_enable(device);
-
-	return 0;
+	return setup_device(device);
 }
 
 static void device_remove(struct connman_element *element)
@@ -1092,12 +1143,7 @@ static void device_remove(struct connman_element *element)
 	if (device->driver == NULL)
 		return;
 
-	device_disable(device);
-
-	unregister_interface(element);
-
-	if (device->driver->remove)
-		device->driver->remove(device);
+	remove_device(device);
 }
 
 static struct connman_driver device_driver = {
diff --git a/src/element.c b/src/element.c
index 31eb9a5c..2599e66c 100644
--- a/src/element.c
+++ b/src/element.c
@@ -676,6 +676,10 @@ static gboolean append_path(GNode *node, gpointer user_data)
 					filter->type != element->type)
 		return FALSE;
 
+	if (filter->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
+			__connman_device_has_driver(element->device) == FALSE)
+		return FALSE;
+
 	dbus_message_iter_append_basic(filter->iter,
 				DBUS_TYPE_OBJECT_PATH, &element->path);
 

commit b28ec057616f661f980e96defa991ab7ee702c4f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 02:58:54 2009 +0100

    Use global device detection for WiFi

diff --git a/plugins/wifi.c b/plugins/wifi.c
index cdec24ff..3c8fa80f 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -36,7 +36,6 @@
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/driver.h>
-#include <connman/rtnl.h>
 #include <connman/dbus.h>
 #include <connman/log.h>
 
@@ -507,131 +506,20 @@ static struct connman_device_driver wifi_driver = {
 	.scan		= wifi_scan,
 };
 
-static GSList *device_list = NULL;
-
-static void wifi_newlink(unsigned short type, int index,
-					unsigned flags, unsigned change)
-{
-	struct connman_device *device;
-	GSList *list;
-	gboolean exists = FALSE;
-	gchar *name, *devname;
-	struct iwreq iwr;
-	int sk;
-
-	DBG("index %d", index);
-
-	if (type != ARPHRD_ETHER)
-		return;
-
-	devname = inet_index2name(index);
-
-	memset(&iwr, 0, sizeof(iwr));
-	strncpy(iwr.ifr_ifrn.ifrn_name, devname, IFNAMSIZ);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-
-	if (ioctl(sk, SIOCGIWNAME, &iwr) < 0) {
-		g_free(devname);
-		close(sk);
-		return;
-	}
-
-	close(sk);
-
-	for (list = device_list; list; list = list->next) {
-		struct connman_device *device = list->data;
-
-		if (connman_device_get_index(device) == index) {
-			exists = TRUE;
-			break;
-		}
-	}
-
-	if (exists == TRUE) {
-		g_free(devname);
-		return;
-	}
-
-	name = inet_index2ident(index, "dev_");
-
-	device = connman_device_create(name, CONNMAN_DEVICE_TYPE_WIFI);
-	if (device == NULL) {
-		g_free(devname);
-		g_free(name);
-		return;
-	}
-
-	connman_device_set_index(device, index);
-	connman_device_set_interface(device, devname);
-
-	g_free(devname);
-	g_free(name);
-
-	connman_device_set_mode(device, CONNMAN_DEVICE_MODE_NETWORK_SINGLE);
-
-	if (connman_device_register(device) < 0) {
-		connman_device_unregister(device);
-		return;
-	}
-
-	device_list = g_slist_append(device_list, device);
-}
-
-static void wifi_dellink(unsigned short type, int index,
-					unsigned flags, unsigned change)
-{
-	GSList *list;
-
-	DBG("index %d", index);
-
-	for (list = device_list; list; list = list->next) {
-		struct connman_device *device = list->data;
-
-		if (connman_device_get_index(device) == index) {
-			device_list = g_slist_remove(device_list, device);
-			connman_device_unregister(device);
-			connman_device_unref(device);
-			break;
-		}
-	}
-}
-
-static struct connman_rtnl wifi_rtnl = {
-	.name		= "wifi",
-	.newlink	= wifi_newlink,
-	.dellink	= wifi_dellink,
-};
-
 static void supplicant_connect(DBusConnection *connection, void *user_data)
 {
 	DBG("connection %p", connection);
 
 	__supplicant_init(connection);
 
-	if (connman_rtnl_register(&wifi_rtnl) < 0)
-		return;
-
-	connman_rtnl_send_getlink();
+	connman_device_driver_register(&wifi_driver);
 }
 
 static void supplicant_disconnect(DBusConnection *connection, void *user_data)
 {
-	GSList *list;
-
 	DBG("connection %p", connection);
 
-	connman_rtnl_unregister(&wifi_rtnl);
-
-	for (list = device_list; list; list = list->next) {
-		struct connman_device *device = list->data;
-
-		connman_device_unregister(device);
-		connman_device_unref(device);
-	}
-
-	g_slist_free(device_list);
-	device_list = NULL;
+	connman_device_driver_unregister(&wifi_driver);
 
 	__supplicant_exit();
 }
@@ -653,13 +541,6 @@ static int wifi_init(void)
 		return err;
 	}
 
-	err = connman_device_driver_register(&wifi_driver);
-	if (err < 0) {
-		connman_driver_unregister(&network_driver);
-		dbus_connection_unref(connection);
-		return err;
-	}
-
 	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
 			supplicant_connect, supplicant_disconnect, NULL, NULL);
 
@@ -674,7 +555,6 @@ static int wifi_init(void)
 static void wifi_exit(void)
 {
 	connman_driver_unregister(&network_driver);
-	connman_device_driver_unregister(&wifi_driver);
 
 	if (watch > 0)
 		g_dbus_remove_watch(connection, watch);
diff --git a/src/detect.c b/src/detect.c
index fab79d40..bd51822d 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -167,7 +167,7 @@ static void detect_newlink(unsigned short type, int index,
 		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			devtype = CONNMAN_DEVICE_TYPE_WIMAX;
 		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
-			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+			devtype = CONNMAN_DEVICE_TYPE_WIFI;
 		else
 			devtype = CONNMAN_DEVICE_TYPE_ETHERNET;
 

commit 5ae55853fca4017221895b03cece096e361dac36
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 15:37:48 2009 +0100

    Add extern declarations to public functions

diff --git a/include/rtnl.h b/include/rtnl.h
index dcab14d2..758e5497 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -50,8 +50,8 @@ struct connman_rtnl {
 extern int connman_rtnl_register(struct connman_rtnl *rtnl);
 extern void connman_rtnl_unregister(struct connman_rtnl *rtnl);
 
-int connman_rtnl_send_getlink(void);
-int connman_rtnl_send_getroute(void);
+extern int connman_rtnl_send_getlink(void);
+extern int connman_rtnl_send_getroute(void);
 
 #ifdef __cplusplus
 }

commit 3ff7262ed26840a697c914a7905543d6c3efac6c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:13:35 2009 +0100

    Add support for RTNL newlink watches

diff --git a/include/rtnl.h b/include/rtnl.h
index 758e5497..c78556b9 100644
--- a/include/rtnl.h
+++ b/include/rtnl.h
@@ -32,6 +32,13 @@ extern "C" {
  * @short_description: Functions for registering RTNL modules
  */
 
+typedef void (* connman_rtnl_link_cb_t) (unsigned flags, unsigned change,
+							void *user_data);
+
+extern unsigned int connman_rtnl_add_newlink_watch(int index,
+			connman_rtnl_link_cb_t callback, void *user_data);
+extern void connman_rtnl_remove_watch(unsigned int id);
+
 #define CONNMAN_RTNL_PRIORITY_LOW      -100
 #define CONNMAN_RTNL_PRIORITY_DEFAULT     0
 #define CONNMAN_RTNL_PRIORITY_HIGH      100
diff --git a/src/rtnl.c b/src/rtnl.c
index 8107933d..3ea7608c 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -36,6 +36,74 @@
 
 #include "connman.h"
 
+struct watch_data {
+	unsigned int id;
+	int index;
+	connman_rtnl_link_cb_t newlink;
+	void *user_data;
+};
+
+static GSList *watch_list = NULL;
+static unsigned int watch_id = 0;
+
+/**
+ * connman_rtnl_add_newlink_watch:
+ * @index: network device index
+ * @callback: callback function
+ * @user_data: callback data;
+ *
+ * Add a new RTNL watch for newlink events
+ *
+ * Returns: %0 on failure and a unique id on success
+ */
+unsigned int connman_rtnl_add_newlink_watch(int index,
+			connman_rtnl_link_cb_t callback, void *user_data)
+{
+	struct watch_data *watch;
+
+	watch = g_try_new0(struct watch_data, 1);
+	if (watch == NULL)
+		return 0;
+
+	watch->id = ++watch_id;
+	watch->index = index;
+
+	watch->newlink = callback;
+	watch->user_data = user_data;
+
+	watch_list = g_slist_prepend(watch_list, watch);
+
+	DBG("id %d", watch->id);
+
+	return watch->id;
+}
+
+/**
+ * connman_rtnl_remove_watch:
+ * @id: watch identifier
+ *
+ * Remove the RTNL watch for the identifier
+ */
+void connman_rtnl_remove_watch(unsigned int id)
+{
+	GSList *list;
+
+	DBG("id %d", id);
+
+	if (id == 0)
+		return;
+
+	for (list = watch_list; list; list = list->next) {
+		struct watch_data *watch = list->data;
+
+		if (watch->id  == id) {
+			watch_list = g_slist_remove(watch_list, watch);
+			g_free(watch);
+			break;
+		}
+	}
+}
+
 static GSList *rtnl_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)
@@ -88,6 +156,16 @@ static void process_newlink(unsigned short type, int index,
 		if (rtnl->newlink)
 			rtnl->newlink(type, index, flags, change);
 	}
+
+	for (list = watch_list; list; list = list->next) {
+		struct watch_data *watch = list->data;
+
+		if (watch->index != index)
+			continue;
+
+		if (watch->newlink)
+			watch->newlink(flags, change, watch->user_data);
+	}
 }
 
 static void process_dellink(unsigned short type, int index,
@@ -687,6 +765,18 @@ void __connman_rtnl_cleanup(void)
 
 	DBG("");
 
+	for (list = watch_list; list; list = list->next) {
+		struct watch_data *watch = list->data;
+
+		DBG("removing watch %d", watch->id);
+
+		g_free(watch);
+		list->data = NULL;
+	}
+
+	g_slist_free(watch_list);
+	watch_list = NULL;
+
 	for (list = request_list; list; list = list->next) {
 		struct rtnl_request *req = list->data;
 

commit 91620bc550205144b793d4f8e7d96f7b9f78e9c6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:14:13 2009 +0100

    Use RTNL newlink watch to reduce code complexity

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 1ddf1fa9..1e797c08 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -45,56 +45,38 @@
 struct ethernet_data {
 	int index;
 	unsigned flags;
+	unsigned int watch;
 };
 
-static GSList *ethernet_list = NULL;
-
-static void ethernet_newlink(unsigned short type, int index,
-					unsigned flags, unsigned change)
+static void ethernet_newlink(unsigned flags, unsigned change, void *user_data)
 {
-	GSList *list;
-
-	DBG("index %d flags %ld change %ld", index, flags, change);
-
-	for (list = ethernet_list; list; list = list->next) {
-		struct connman_device *device = list->data;
-		struct ethernet_data *ethernet;
-
-		ethernet = connman_device_get_data(device);
-		if (ethernet == NULL)
-			continue;
+	struct connman_device *device = user_data;
+	struct ethernet_data *ethernet = connman_device_get_data(device);
 
-		if (ethernet->index != index)
-			continue;
+	DBG("index %d flags %ld change %ld", ethernet->index, flags, change);
 
-		if ((ethernet->flags & IFF_UP) != (flags & IFF_UP)) {
-			if (flags & IFF_UP) {
-				DBG("power on");
-				connman_device_set_powered(device, TRUE);
-			} else {
-				DBG("power off");
-				connman_device_set_powered(device, FALSE);
-			}
+	if ((ethernet->flags & IFF_UP) != (flags & IFF_UP)) {
+		if (flags & IFF_UP) {
+			DBG("power on");
+			connman_device_set_powered(device, TRUE);
+		} else {
+			DBG("power off");
+			connman_device_set_powered(device, FALSE);
 		}
+	}
 
-		if ((ethernet->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP)) {
-			if (flags & IFF_LOWER_UP) {
-				DBG("carrier on");
-				connman_device_set_carrier(device, TRUE);
-			} else {
-				DBG("carrier off");
-				connman_device_set_carrier(device, FALSE);
-			}
+	if ((ethernet->flags & IFF_LOWER_UP) != (flags & IFF_LOWER_UP)) {
+		if (flags & IFF_LOWER_UP) {
+			DBG("carrier on");
+			connman_device_set_carrier(device, TRUE);
+		} else {
+			DBG("carrier off");
+			connman_device_set_carrier(device, FALSE);
 		}
-
-		ethernet->flags = flags;
 	}
-}
 
-static struct connman_rtnl ethernet_rtnl = {
-	.name		= "ethernet",
-	.newlink	= ethernet_newlink,
-};
+	ethernet->flags = flags;
+}
 
 static int ethernet_probe(struct connman_device *device)
 {
@@ -106,11 +88,13 @@ static int ethernet_probe(struct connman_device *device)
 	if (ethernet == NULL)
 		return -ENOMEM;
 
-	ethernet_list = g_slist_append(ethernet_list, device);
-
 	connman_device_set_data(device, ethernet);
 
 	ethernet->index = connman_device_get_index(device);
+	ethernet->flags = 0;
+
+	ethernet->watch = connman_rtnl_add_newlink_watch(ethernet->index,
+						ethernet_newlink, device);
 
 	connman_rtnl_send_getlink();
 
@@ -125,7 +109,7 @@ static void ethernet_remove(struct connman_device *device)
 
 	connman_device_set_data(device, NULL);
 
-	ethernet_list = g_slist_remove(ethernet_list, device);
+	connman_rtnl_remove_watch(ethernet->watch);
 
 	g_free(ethernet);
 }
@@ -159,26 +143,12 @@ static struct connman_device_driver ethernet_driver = {
 
 static int ethernet_init(void)
 {
-	int err;
-
-	err = connman_rtnl_register(&ethernet_rtnl);
-	if (err < 0)
-		return err;
-
-	err = connman_device_driver_register(&ethernet_driver);
-	if (err < 0) {
-		connman_rtnl_unregister(&ethernet_rtnl);
-		return err;
-	}
-
-	return 0;
+	return connman_device_driver_register(&ethernet_driver);
 }
 
 static void ethernet_exit(void)
 {
 	connman_device_driver_unregister(&ethernet_driver);
-
-	connman_rtnl_unregister(&ethernet_rtnl);
 }
 
 CONNMAN_PLUGIN_DEFINE(ethernet, "Ethernet interface plugin", VERSION,

commit 9911ffd65ccd2d2cacfa1bf55ac70e3c1ec00a67
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:33:18 2009 +0100

    Add function to retrieve current debug status

diff --git a/src/connman.h b/src/connman.h
index 889a8276..87fe9278 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -61,6 +61,8 @@ void __connman_profile_list(DBusMessageIter *iter);
 int __connman_log_init(gboolean detach, gboolean debug);
 void __connman_log_cleanup(void);
 
+gboolean __connman_debug_enabled(void);
+
 #include <connman/plugin.h>
 
 int __connman_plugin_init(void);
diff --git a/src/log.c b/src/log.c
index 3d8a4e92..33d2bf50 100644
--- a/src/log.c
+++ b/src/log.c
@@ -112,3 +112,8 @@ void __connman_log_cleanup(void)
 
 	closelog();
 }
+
+gboolean __connman_debug_enabled(void)
+{
+	return debug_enabled;
+}

commit c7799147ac67fe1670bf05e7ccb6beae80c0e300
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:33:56 2009 +0100

    Add support for element based debugging

diff --git a/include/dbus.h b/include/dbus.h
index 895a96dc..77766c72 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -30,6 +30,7 @@ extern "C" {
 
 #define CONNMAN_SERVICE			"org.moblin.connman"
 
+#define CONNMAN_DEBUG_INTERFACE		CONNMAN_SERVICE ".Debug"
 #define CONNMAN_ERROR_INTERFACE		CONNMAN_SERVICE ".Error"
 #define CONNMAN_AGENT_INTERFACE		CONNMAN_SERVICE ".Agent"
 
diff --git a/src/element.c b/src/element.c
index 2599e66c..2f860c0a 100644
--- a/src/element.c
+++ b/src/element.c
@@ -311,6 +311,27 @@ static void set_common_property(struct connman_element *element,
 	__connman_element_unlock(element);
 }
 
+static void emit_element_signal(DBusConnection *conn, const char *member,
+					struct connman_element *element)
+{
+	DBusMessage *signal;
+
+	if (__connman_debug_enabled() == FALSE)
+		return;
+
+	DBG("conn %p member %s", conn, member);
+
+	if (element == NULL)
+		return;
+
+	signal = dbus_message_new_signal(element->path,
+					CONNMAN_DEBUG_INTERFACE, member);
+	if (signal == NULL)
+		return;
+
+	g_dbus_send_message(conn, signal);
+}
+
 static void emit_enabled_signal(DBusConnection *conn,
 					struct connman_element *element)
 {
@@ -1760,6 +1781,8 @@ static void register_element(gpointer data, gpointer user_data)
 		}
 	}
 
+	emit_element_signal(connection, "ElementAdded", element);
+
 	__connman_element_store(element);
 
 	if (started == FALSE)
@@ -1861,6 +1884,8 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 						CONNMAN_NETWORK_INTERFACE);
 	}
 
+	emit_element_signal(connection, "ElementRemoved", element);
+
 	connman_element_unref(element);
 
 	return FALSE;
@@ -1911,6 +1936,8 @@ static gboolean update_element(GNode *node, gpointer user_data)
 		}
 	}
 
+	emit_element_signal(connection, "ElementUpdated", element);
+
 	return FALSE;
 }
 

commit c16fbb9f4c69084d43cbacba834ba2b4b2cc4b17
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:36:10 2009 +0100

    Add script to debug element details

diff --git a/test/Makefile.am b/test/Makefile.am
index 7b4c12ba..11f19fd7 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -3,7 +3,7 @@ EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
 		set-passphrase set-address set-policy test-manager \
-		connect-network disconnect-network \
-		simple-agent show-introspection test-compat monitor-connman
+		connect-network disconnect-network simple-agent \
+		show-introspection test-compat monitor-connman debug-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/debug-connman b/test/debug-connman
new file mode 100755
index 00000000..8d7cbb71
--- /dev/null
+++ b/test/debug-connman
@@ -0,0 +1,41 @@
+#!/usr/bin/python
+
+import gobject
+
+import dbus
+import dbus.mainloop.glib
+
+def element_signal(path, member):
+	if member == "ElementAdded":
+		action = "Add   "
+	elif member == "ElementRemoved":
+		action = "Remove"
+	elif member == "ElementUpdated":
+		action = "Update"
+	else:
+		return
+	print "%s  [ %s ]" % (action, path)
+
+if __name__ == '__main__':
+	dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
+
+	bus = dbus.SystemBus()
+
+	bus.add_signal_receiver(element_signal,
+					bus_name="org.moblin.connman",
+					signal_name = "ElementAdded",
+						path_keyword="path",
+						member_keyword="member")
+	bus.add_signal_receiver(element_signal,
+					bus_name="org.moblin.connman",
+					signal_name = "ElementRemoved",
+						path_keyword="path",
+						member_keyword="member")
+	bus.add_signal_receiver(element_signal,
+					bus_name="org.moblin.connman",
+					signal_name = "ElementUpdated",
+						path_keyword="path",
+						member_keyword="member")
+
+	mainloop = gobject.MainLoop()
+	mainloop.run()

commit aca8be4723ea5f08ba98c49eb042477920405fea
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:43:05 2009 +0100

    Remove unused includes and define IFF_LOWER_UP

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 1e797c08..4ef163c6 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -24,13 +24,11 @@
 #endif
 
 #include <errno.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <linux/if.h>
-#include <linux/netlink.h>
-#include <linux/rtnetlink.h>
+#include <net/if.h>
+
+#ifndef IFF_LOWER_UP
+#define IFF_LOWER_UP	0x10000
+#endif
 
 #include <glib.h>
 

commit dee314f2f013fd11b6fc15a0765d672cd788271c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:51:10 2009 +0100

    All vendor specific types start at 10000

diff --git a/include/device.h b/include/device.h
index 44032b03..b14b9b16 100644
--- a/include/device.h
+++ b/include/device.h
@@ -45,7 +45,7 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_NOZOMI    = 16,
 	CONNMAN_DEVICE_TYPE_HUAWEI    = 17,
 	CONNMAN_DEVICE_TYPE_NOVATEL   = 18,
-	CONNMAN_DEVICE_TYPE_VENDOR    = 42,
+	CONNMAN_DEVICE_TYPE_VENDOR    = 10000,
 };
 
 enum connman_device_mode {
diff --git a/include/element.h b/include/element.h
index 7e7774b0..83c146be 100644
--- a/include/element.h
+++ b/include/element.h
@@ -64,8 +64,8 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_DHCP       = 9,
 	CONNMAN_ELEMENT_TYPE_BOOTP      = 10,
 	CONNMAN_ELEMENT_TYPE_ZEROCONF   = 11,
-
 	CONNMAN_ELEMENT_TYPE_CONNECTION = 42,
+	CONNMAN_ELEMENT_TYPE_VENDOR     = 10000,
 };
 
 enum connman_element_subtype {
diff --git a/include/network.h b/include/network.h
index b0138f44..61faf473 100644
--- a/include/network.h
+++ b/include/network.h
@@ -41,6 +41,7 @@ enum connman_network_type {
 	CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN = 8,
 	CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN = 9,
 	CONNMAN_NETWORK_TYPE_HSO           = 23,
+	CONNMAN_NETWORK_TYPE_VENDOR        = 10000,
 };
 
 enum connman_network_protocol {
diff --git a/src/element.c b/src/element.c
index 2f860c0a..74f7087d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -120,6 +120,8 @@ static const char *type2string(enum connman_element_type type)
 		return "zeroconf";
 	case CONNMAN_ELEMENT_TYPE_CONNECTION:
 		return "connection";
+	case CONNMAN_ELEMENT_TYPE_VENDOR:
+		return "vendor";
 	}
 
 	return NULL;
diff --git a/src/network.c b/src/network.c
index 3bcb340b..b21a224f 100644
--- a/src/network.c
+++ b/src/network.c
@@ -259,6 +259,7 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	switch (type) {
 	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+	case CONNMAN_NETWORK_TYPE_VENDOR:
 		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 		break;
 	case CONNMAN_NETWORK_TYPE_WIFI:

commit 1c914879892265fa8cbcf85bd81c262f7c19dfb5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 16:54:42 2009 +0100

    Remove useless suffix of device driver names

diff --git a/plugins/hso.c b/plugins/hso.c
index bf7c2b3a..9489cf1a 100644
--- a/plugins/hso.c
+++ b/plugins/hso.c
@@ -211,7 +211,7 @@ static int hso_disable(struct connman_device *device)
 }
 
 static struct connman_device_driver hso_driver = {
-	.name		= "hso-device",
+	.name		= "hso",
 	.type		= CONNMAN_DEVICE_TYPE_HSO,
 	.probe		= hso_probe,
 	.remove		= hso_remove,
diff --git a/plugins/huawei.c b/plugins/huawei.c
index 2249048e..c165aeab 100644
--- a/plugins/huawei.c
+++ b/plugins/huawei.c
@@ -61,7 +61,7 @@ static int huawei_disable(struct connman_device *device)
 }
 
 static struct connman_device_driver huawei_driver = {
-	.name		= "huawei-device",
+	.name		= "huawei",
 	.type		= CONNMAN_DEVICE_TYPE_HUAWEI,
 	.probe		= huawei_probe,
 	.remove		= huawei_remove,
diff --git a/plugins/novatel.c b/plugins/novatel.c
index f43c5eb6..b1d7bb40 100644
--- a/plugins/novatel.c
+++ b/plugins/novatel.c
@@ -61,7 +61,7 @@ static int novatel_disable(struct connman_device *device)
 }
 
 static struct connman_device_driver novatel_driver = {
-	.name		= "novatel-device",
+	.name		= "novatel",
 	.type		= CONNMAN_DEVICE_TYPE_NOVATEL,
 	.probe		= novatel_probe,
 	.remove		= novatel_remove,
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 3c8fa80f..f52d8480 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -497,7 +497,7 @@ static int wifi_scan(struct connman_device *device)
 }
 
 static struct connman_device_driver wifi_driver = {
-	.name		= "wifi-device",
+	.name		= "wifi",
 	.type		= CONNMAN_DEVICE_TYPE_WIFI,
 	.probe		= wifi_probe,
 	.remove		= wifi_remove,

commit decb27a1cd8cfb19eafd80fc46bc328161738898
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 17:48:41 2009 +0100

    Add basics for a supplicant driver and use it

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 0d7d293a..66cf36ff 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -25,9 +25,8 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <dbus/dbus.h>
 
-#include <glib.h>
+#include <gdbus.h>
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/log.h>
@@ -1109,7 +1108,7 @@ int __supplicant_disconnect(struct connman_element *element)
 	return 0;
 }
 
-void __supplicant_activate(DBusConnection *conn)
+static void supplicant_activate(DBusConnection *conn)
 {
 	DBusMessage *message;
 
@@ -1127,24 +1126,108 @@ void __supplicant_activate(DBusConnection *conn)
 	dbus_message_unref(message);
 }
 
-int __supplicant_init(DBusConnection *conn)
+static GSList *driver_list = NULL;
+
+static void supplicant_probe(DBusConnection *conn, void *user_data)
+{
+	GSList *list;
+
+	DBG("conn %p", conn);
+
+	for (list = driver_list; list; list = list->next) {
+		struct supplicant_driver *driver = list->data;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		if (driver->probe)
+			driver->probe();
+	}
+}
+
+static void supplicant_remove(DBusConnection *conn, void *user_data)
 {
+	GSList *list;
+
 	DBG("conn %p", conn);
 
-	connection = conn;
+	for (list = driver_list; list; list = list->next) {
+		struct supplicant_driver *driver = list->data;
+
+		DBG("driver %p name %s", driver, driver->name);
+
+		if (driver->remove)
+			driver->remove();
+	}
+}
+
+static guint watch;
+
+static int supplicant_create(void)
+{
+	if (g_slist_length(driver_list) > 0)
+		return 0;
+
+	connection = connman_dbus_get_connection();
+	if (connection == NULL)
+		return -EIO;
+
+	DBG("connection %p", connection);
 
 	if (dbus_connection_add_filter(connection,
 				supplicant_filter, NULL, NULL) == FALSE) {
-		dbus_connection_unref(connection);
+		connection = connman_dbus_get_connection();
 		return -EIO;
 	}
 
+	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
+			supplicant_probe, supplicant_remove, NULL, NULL);
+
 	return 0;
 }
 
-void __supplicant_exit(void)
+static void supplicant_destroy(void)
 {
-	DBG("conn %p", connection);
+	if (g_slist_length(driver_list) > 0)
+		return;
+
+	DBG("connection %p", connection);
+
+	if (watch > 0)
+		g_dbus_remove_watch(connection, watch);
 
 	dbus_connection_remove_filter(connection, supplicant_filter, NULL);
+
+	dbus_connection_unref(connection);
+	connection = NULL;
+}
+
+int supplicant_register(struct supplicant_driver *driver)
+{
+	int err;
+
+	DBG("driver %p name %s", driver, driver->name);
+
+	err = supplicant_create();
+	if (err < 0)
+		return err;
+
+	driver_list = g_slist_append(driver_list, driver);
+
+	if (g_dbus_check_service(connection, SUPPLICANT_NAME) == TRUE)
+		supplicant_probe(connection, NULL);
+	else
+		supplicant_activate(connection);
+
+	return 0;
+}
+
+void supplicant_unregister(struct supplicant_driver *driver)
+{
+	DBG("driver %p name %s", driver, driver->name);
+
+	supplicant_remove(connection, NULL);
+
+	driver_list = g_slist_remove(driver_list, driver);
+
+	supplicant_destroy();
 }
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 4543d115..849a59da 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -60,10 +60,16 @@ struct supplicant_callback {
 					struct supplicant_network *network);
 };
 
-void __supplicant_activate(DBusConnection *conn);
+struct supplicant_driver {
+	const char *name;
+	void (*probe) (void);
+	void (*remove) (void);
+};
 
-int __supplicant_init(DBusConnection *conn);
-void __supplicant_exit(void);
+int supplicant_register(struct supplicant_driver *driver);
+void supplicant_unregister(struct supplicant_driver *driver);
+
+void __supplicant_activate(DBusConnection *conn);
 
 int __supplicant_start(struct connman_device *device,
 					struct supplicant_callback *callback);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index f52d8480..6459f760 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -31,12 +31,12 @@
 #include <linux/if_arp.h>
 #include <linux/wireless.h>
 
-#include <gdbus.h>
+#include <dbus/dbus.h>
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
+#include <connman/device.h>
 #include <connman/driver.h>
-#include <connman/dbus.h>
 #include <connman/log.h>
 
 #include "inet.h"
@@ -506,62 +506,48 @@ static struct connman_device_driver wifi_driver = {
 	.scan		= wifi_scan,
 };
 
-static void supplicant_connect(DBusConnection *connection, void *user_data)
+static void wifi_register(void)
 {
-	DBG("connection %p", connection);
-
-	__supplicant_init(connection);
+	DBG("");
 
 	connman_device_driver_register(&wifi_driver);
 }
 
-static void supplicant_disconnect(DBusConnection *connection, void *user_data)
+static void wifi_unregister(void)
 {
-	DBG("connection %p", connection);
+	DBG("");
 
 	connman_device_driver_unregister(&wifi_driver);
-
-	__supplicant_exit();
 }
 
-static DBusConnection *connection;
-static guint watch;
+static struct supplicant_driver supplicant = {
+	.name		= "wifi",
+	.probe		= wifi_register,
+	.remove		= wifi_unregister,
+};
 
 static int wifi_init(void)
 {
 	int err;
 
-	connection = connman_dbus_get_connection();
-	if (connection == NULL)
-		return -EIO;
-
 	err = connman_driver_register(&network_driver);
+	if (err < 0)
+		return err;
+
+	err = supplicant_register(&supplicant);
 	if (err < 0) {
-		dbus_connection_unref(connection);
+		connman_driver_unregister(&network_driver);
 		return err;
 	}
 
-	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
-			supplicant_connect, supplicant_disconnect, NULL, NULL);
-
-	if (g_dbus_check_service(connection, SUPPLICANT_NAME) == TRUE)
-		supplicant_connect(connection, NULL);
-	else
-		__supplicant_activate(connection);
-
 	return 0;
 }
 
 static void wifi_exit(void)
 {
-	connman_driver_unregister(&network_driver);
-
-	if (watch > 0)
-		g_dbus_remove_watch(connection, watch);
+	supplicant_unregister(&supplicant);
 
-	supplicant_disconnect(connection, NULL);
-
-	dbus_connection_unref(connection);
+	connman_driver_unregister(&network_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE(wifi, "WiFi interface plugin", VERSION,

commit 9becf7a55594656e9eab6ee11e7a72af4924ad2c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 17:49:33 2009 +0100

    Remove unused prototype declaration

diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 849a59da..498f7074 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -69,8 +69,6 @@ struct supplicant_driver {
 int supplicant_register(struct supplicant_driver *driver);
 void supplicant_unregister(struct supplicant_driver *driver);
 
-void __supplicant_activate(DBusConnection *conn);
-
 int __supplicant_start(struct connman_device *device,
 					struct supplicant_callback *callback);
 int __supplicant_stop(struct connman_device *device);

commit 0890f0dcc8c42b4d2de01e42a577fb570b29b6a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 18:06:11 2009 +0100

    Use global supplicant filter matching rule

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 66cf36ff..a51a5173 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -41,6 +41,8 @@
 #define IEEE80211_CAP_IBSS      0x0002
 #define IEEE80211_CAP_PRIVACY   0x0010
 
+static GSList *driver_list = NULL;
+
 struct supplicant_task {
 	int ifindex;
 	gchar *ifname;
@@ -919,54 +921,6 @@ static DBusHandlerResult supplicant_filter(DBusConnection *conn,
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
-static int add_filter(struct supplicant_task *task)
-{
-	DBusError error;
-	gchar *filter;
-
-	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
-						SUPPLICANT_INTF, task->path);
-
-	DBG("filter %s", filter);
-
-	dbus_error_init(&error);
-
-	dbus_bus_add_match(connection, filter, &error);
-
-	g_free(filter);
-
-	if (dbus_error_is_set(&error) == TRUE) {
-		connman_error("Can't add match: %s", error.message);
-		dbus_error_free(&error);
-	}
-
-	return 0;
-}
-
-static int remove_filter(struct supplicant_task *task)
-{
-	DBusError error;
-	gchar *filter;
-
-	filter = g_strdup_printf("type=signal,interface=%s.Interface,path=%s",
-						SUPPLICANT_INTF, task->path);
-
-	DBG("filter %s", filter);
-
-	dbus_error_init(&error);
-
-	dbus_bus_remove_match(connection, filter, &error);
-
-	g_free(filter);
-
-	if (dbus_error_is_set(&error) == TRUE) {
-		connman_error("Can't add match: %s", error.message);
-		dbus_error_free(&error);
-	}
-
-	return 0;
-}
-
 int __supplicant_start(struct connman_device *device,
 					struct supplicant_callback *callback)
 {
@@ -1003,8 +957,6 @@ int __supplicant_start(struct connman_device *device,
 		}
 	}
 
-	add_filter(task);
-
 	set_ap_scan(task);
 
 	return 0;
@@ -1027,8 +979,6 @@ int __supplicant_stop(struct connman_device *device)
 
 	remove_network(task);
 
-	remove_filter(task);
-
 	remove_interface(task);
 
 	g_free(task->ifname);
@@ -1126,8 +1076,6 @@ static void supplicant_activate(DBusConnection *conn)
 	dbus_message_unref(message);
 }
 
-static GSList *driver_list = NULL;
-
 static void supplicant_probe(DBusConnection *conn, void *user_data)
 {
 	GSList *list;
@@ -1160,6 +1108,8 @@ static void supplicant_remove(DBusConnection *conn, void *user_data)
 	}
 }
 
+static const char *supplicant_rule = "type=signal,"
+				"interface=" SUPPLICANT_INTF ".Interface";
 static guint watch;
 
 static int supplicant_create(void)
@@ -1179,6 +1129,9 @@ static int supplicant_create(void)
 		return -EIO;
 	}
 
+	dbus_bus_add_match(connection, supplicant_rule, NULL);
+	dbus_connection_flush(connection);
+
 	watch = g_dbus_add_service_watch(connection, SUPPLICANT_NAME,
 			supplicant_probe, supplicant_remove, NULL, NULL);
 
@@ -1195,6 +1148,9 @@ static void supplicant_destroy(void)
 	if (watch > 0)
 		g_dbus_remove_watch(connection, watch);
 
+	dbus_bus_remove_match(connection, supplicant_rule, NULL);
+	dbus_connection_flush(connection);
+
 	dbus_connection_remove_filter(connection, supplicant_filter, NULL);
 
 	dbus_connection_unref(connection);
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 498f7074..691b9616 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -72,7 +72,6 @@ void supplicant_unregister(struct supplicant_driver *driver);
 int __supplicant_start(struct connman_device *device,
 					struct supplicant_callback *callback);
 int __supplicant_stop(struct connman_device *device);
-
 int __supplicant_scan(struct connman_device *device);
 
 int __supplicant_connect(struct connman_element *element,
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 6459f760..454c6a0f 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -510,7 +510,8 @@ static void wifi_register(void)
 {
 	DBG("");
 
-	connman_device_driver_register(&wifi_driver);
+	if (connman_device_driver_register(&wifi_driver) < 0)
+		connman_error("Failed to register WiFi driver");
 }
 
 static void wifi_unregister(void)

commit 94fca351c2cd0a75ea6b71462a084dc8ffe2e78d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 18:18:24 2009 +0100

    Add callbacks to supplicant driver

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index a51a5173..7edbb916 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -43,11 +43,48 @@
 
 static GSList *driver_list = NULL;
 
+static void process_state_change(struct connman_device *device,
+						enum supplicant_state state)
+{
+	GSList *list;
+
+	for (list = driver_list; list; list = list->next) {
+		struct supplicant_driver *driver = list->data;
+
+		if (driver->state_change)
+			driver->state_change(device, state);
+	}
+}
+
+static void process_clear_results(struct connman_device *device)
+{
+	GSList *list;
+
+	for (list = driver_list; list; list = list->next) {
+		struct supplicant_driver *driver = list->data;
+
+		if (driver->clear_results)
+			driver->clear_results(device);
+	}
+}
+
+static void process_scan_result(struct connman_device *device,
+					struct supplicant_network *network)
+{
+	GSList *list;
+
+	for (list = driver_list; list; list = list->next) {
+		struct supplicant_driver *driver = list->data;
+
+		if (driver->scan_result)
+			driver->scan_result(device, network);
+	}
+}
+
 struct supplicant_task {
 	int ifindex;
 	gchar *ifname;
 	struct connman_device *device;
-	struct supplicant_callback *callback;
 	gchar *path;
 	gboolean created;
 	gchar *network;
@@ -735,8 +772,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		dbus_message_iter_next(&dict);
 	}
 
-	if (task->callback && task->callback->scan_result)
-		task->callback->scan_result(task->device, network);
+	process_scan_result(task->device, network);
 
 	g_free(network->identifier);
 	g_free(network->ssid);
@@ -798,8 +834,7 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 		goto done;
 	}
 
-	if (task->callback && task->callback->clear_results)
-			task->callback->clear_results(task->device);
+	process_clear_results(task->device);
 
 	for (i = 0; i < num_results; i++)
 		get_network_properties(task, results[i]);
@@ -874,8 +909,7 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
 		task->state = STATE_DISCONNECTED;
 
-	if (task->callback && task->callback->state_change)
-		task->callback->state_change(task->device, task->state);
+	process_state_change(task->device, task->state);
 
 	switch (task->state) {
 	case STATE_COMPLETED:
@@ -921,8 +955,7 @@ static DBusHandlerResult supplicant_filter(DBusConnection *conn,
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
-int __supplicant_start(struct connman_device *device,
-					struct supplicant_callback *callback)
+int supplicant_start(struct connman_device *device)
 {
 	struct supplicant_task *task;
 	int err;
@@ -936,7 +969,6 @@ int __supplicant_start(struct connman_device *device,
 	task->ifindex = connman_device_get_index(device);
 	task->ifname = inet_index2name(task->ifindex);
 	task->device = device;
-	task->callback = callback;
 
 	if (task->ifname == NULL) {
 		g_free(task);
@@ -962,7 +994,7 @@ int __supplicant_start(struct connman_device *device,
 	return 0;
 }
 
-int __supplicant_stop(struct connman_device *device)
+int supplicant_stop(struct connman_device *device)
 {
 	int index = connman_device_get_index(device);
 	struct supplicant_task *task;
@@ -988,7 +1020,7 @@ int __supplicant_stop(struct connman_device *device)
 	return 0;
 }
 
-int __supplicant_scan(struct connman_device *device)
+int supplicant_scan(struct connman_device *device)
 {
 	int index = connman_device_get_index(device);
 	struct supplicant_task *task;
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 691b9616..4dc6d7f7 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -52,7 +52,11 @@ struct supplicant_network {
 	gint32 maxrate;
 };
 
-struct supplicant_callback {
+struct supplicant_driver {
+	const char *name;
+	void (*probe) (void);
+	void (*remove) (void);
+
 	void (*state_change) (struct connman_device *device,
 						enum supplicant_state state);
 	void (*clear_results) (struct connman_device *device);
@@ -60,19 +64,12 @@ struct supplicant_callback {
 					struct supplicant_network *network);
 };
 
-struct supplicant_driver {
-	const char *name;
-	void (*probe) (void);
-	void (*remove) (void);
-};
-
 int supplicant_register(struct supplicant_driver *driver);
 void supplicant_unregister(struct supplicant_driver *driver);
 
-int __supplicant_start(struct connman_device *device,
-					struct supplicant_callback *callback);
-int __supplicant_stop(struct connman_device *device);
-int __supplicant_scan(struct connman_device *device);
+int supplicant_start(struct connman_device *device);
+int supplicant_stop(struct connman_device *device);
+int supplicant_scan(struct connman_device *device);
 
 int __supplicant_connect(struct connman_element *element,
 				const unsigned char *ssid, int ssid_len,
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 454c6a0f..6c3efde6 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -171,7 +171,7 @@ static gboolean inactive_scan(gpointer user_data)
 
 	DBG("device %p", device);
 
-	__supplicant_scan(device);
+	supplicant_scan(device);
 
 	data->inactive_timer = 0;
 
@@ -397,12 +397,6 @@ done:
 	g_free(temp);
 }
 
-static struct supplicant_callback wifi_callback = {
-	.state_change	= state_change,
-	.clear_results	= clear_results,
-	.scan_result	= scan_result,
-};
-
 static int wifi_probe(struct connman_device *device)
 {
 	struct wifi_data *data;
@@ -438,13 +432,13 @@ static int wifi_enable(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	err = __supplicant_start(device, &wifi_callback);
+	err = supplicant_start(device);
 	if (err < 0)
 		return err;
 
 	connman_device_set_powered(device, TRUE);
 
-	__supplicant_scan(device);
+	supplicant_scan(device);
 
 	return 0;
 }
@@ -480,7 +474,7 @@ static int wifi_disable(struct connman_device *device)
 
 	connman_element_unregister_children((struct connman_element *) device);
 
-	__supplicant_stop(device);
+	supplicant_stop(device);
 
 	connman_device_set_powered(device, FALSE);
 
@@ -491,7 +485,7 @@ static int wifi_scan(struct connman_device *device)
 {
 	DBG("device %p", device);
 
-	__supplicant_scan(device);
+	supplicant_scan(device);
 
 	return 0;
 }
@@ -525,6 +519,10 @@ static struct supplicant_driver supplicant = {
 	.name		= "wifi",
 	.probe		= wifi_register,
 	.remove		= wifi_unregister,
+
+	.state_change	= state_change,
+	.clear_results	= clear_results,
+	.scan_result	= scan_result,
 };
 
 static int wifi_init(void)

commit 186c1b8419c70a5649462e35fe0910099501a412
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:02:00 2009 +0100

    Add skeleton for storage drivers

diff --git a/include/Makefile.am b/include/Makefile.am
index 67ffb4ed..84eece9e 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -2,7 +2,7 @@
 includedir = @includedir@/connman
 
 include_HEADERS = types.h log.h plugin.h security.h resolver.h \
-						device.h network.h
+					storage.h device.h network.h
 
 noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h
 
diff --git a/include/storage.h b/include/storage.h
new file mode 100644
index 00000000..de4107cf
--- /dev/null
+++ b/include/storage.h
@@ -0,0 +1,56 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_STORAGE_H
+#define __CONNMAN_STORAGE_H
+
+#include <connman/device.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * SECTION:storage
+ * @title: Storage premitives
+ * @short_description: Functions for registering storage modules
+ */
+
+#define CONNMAN_STORAGE_PRIORITY_LOW      -100
+#define CONNMAN_STORAGE_PRIORITY_DEFAULT     0
+#define CONNMAN_STORAGE_PRIORITY_HIGH      100
+
+struct connman_storage {
+	const char *name;
+	int priority;
+	enum connman_device_type device_type;
+	int (*device_load) (struct connman_device *device);
+	int (*device_save) (struct connman_device *device);
+};
+
+extern int connman_storage_register(struct connman_storage *storage);
+extern void connman_storage_unregister(struct connman_storage *storage);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_STORAGE_H */
diff --git a/src/connman.h b/src/connman.h
index 87fe9278..a87c49f0 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -39,9 +39,6 @@ DBusMessage *__connman_error_not_supported(DBusMessage *msg);
 
 int __connman_selftest(void);
 
-int __connman_storage_init(void);
-void __connman_storage_cleanup(void);
-
 int __connman_manager_init(DBusConnection *conn, gboolean compat);
 void __connman_manager_cleanup(void);
 
@@ -84,6 +81,11 @@ void __connman_resolver_cleanup(void);
 
 int __connman_resolver_selftest(void);
 
+#include <connman/storage.h>
+
+int __connman_storage_init(void);
+void __connman_storage_cleanup(void);
+
 #include <connman/driver.h>
 
 void __connman_driver_rescan(struct connman_driver *driver);
diff --git a/src/storage.c b/src/storage.c
index 41cfd420..1266fc28 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -25,6 +25,47 @@
 
 #include "connman.h"
 
+static GSList *storage_list = NULL;
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_storage *storage1 = a;
+	const struct connman_storage *storage2 = b;
+
+	return storage2->priority - storage1->priority;
+}
+
+/**
+ * connman_storage_register:
+ * @storage: storage module
+ *
+ * Register a new storage module
+ *
+ * Returns: %0 on success
+ */
+int connman_storage_register(struct connman_storage *storage)
+{
+	DBG("storage %p name %s", storage, storage->name);
+
+	storage_list = g_slist_insert_sorted(storage_list, storage,
+							compare_priority);
+
+	return 0;
+}
+
+/**
+ * connman_storage_unregister:
+ * @storage: storage module
+ *
+ * Remove a previously registered storage module
+ */
+void connman_storage_unregister(struct connman_storage *storage)
+{
+	DBG("storage %p name %s", storage, storage->name);
+
+	storage_list = g_slist_remove(storage_list, storage);
+}
+
 int __connman_storage_init(void)
 {
 	DBG("");

commit 832779e0248011f09edf32e4d9daec13ee5daa93
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:07:56 2009 +0100

    Register default device and network storage drivers

diff --git a/src/device.c b/src/device.c
index e8095734..9f30a8a3 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1154,12 +1154,20 @@ static struct connman_driver device_driver = {
 	.remove		= device_remove,
 };
 
+static struct connman_storage device_storage = {
+	.name		= "device",
+	.priority	= CONNMAN_STORAGE_PRIORITY_LOW,
+};
+
 int __connman_device_init(void)
 {
 	DBG("");
 
 	connection = connman_dbus_get_connection();
 
+	if (connman_storage_register(&device_storage) < 0)
+		connman_error("Failed to register device storage");
+
 	return connman_driver_register(&device_driver);
 }
 
@@ -1169,5 +1177,7 @@ void __connman_device_cleanup(void)
 
 	connman_driver_unregister(&device_driver);
 
+	connman_storage_unregister(&device_storage);
+
 	dbus_connection_unref(connection);
 }
diff --git a/src/network.c b/src/network.c
index b21a224f..e5353f5a 100644
--- a/src/network.c
+++ b/src/network.c
@@ -544,12 +544,20 @@ static struct connman_driver network_driver = {
 	.remove		= network_remove,
 };
 
+static struct connman_storage network_storage = {
+	.name		= "network",
+	.priority	= CONNMAN_STORAGE_PRIORITY_LOW,
+};
+
 int __connman_network_init(void)
 {
 	DBG("");
 
 	connection = connman_dbus_get_connection();
 
+	if (connman_storage_register(&network_storage) < 0)
+		connman_error("Failed to register network storage");
+
 	return connman_driver_register(&network_driver);
 }
 
@@ -559,5 +567,7 @@ void __connman_network_cleanup(void)
 
 	connman_driver_unregister(&network_driver);
 
+	connman_storage_unregister(&network_storage);
+
 	dbus_connection_unref(connection);
 }

commit 409f3e68cc39cb66fe706c164484518e3706c81e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:24:10 2009 +0100

    Add storage callbacks for networks

diff --git a/include/storage.h b/include/storage.h
index de4107cf..9182675a 100644
--- a/include/storage.h
+++ b/include/storage.h
@@ -23,6 +23,7 @@
 #define __CONNMAN_STORAGE_H
 
 #include <connman/device.h>
+#include <connman/network.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -44,6 +45,9 @@ struct connman_storage {
 	enum connman_device_type device_type;
 	int (*device_load) (struct connman_device *device);
 	int (*device_save) (struct connman_device *device);
+	enum connman_network_type network_type;
+	int (*network_load) (struct connman_network *network);
+	int (*network_save) (struct connman_network *network);
 };
 
 extern int connman_storage_register(struct connman_storage *storage);

commit 92fcf25b006be340a57d75882365f1a6747dc668
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:25:07 2009 +0100

    Add functions for loading and saving information

diff --git a/src/connman.h b/src/connman.h
index a87c49f0..e803ddcf 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -86,6 +86,11 @@ int __connman_resolver_selftest(void);
 int __connman_storage_init(void);
 void __connman_storage_cleanup(void);
 
+int __connman_storage_load_device(struct connman_device *device);
+int __connman_storage_save_device(struct connman_device *device);
+int __connman_storage_load_network(struct connman_network *network);
+int __connman_storage_save_network(struct connman_network *network);
+
 #include <connman/driver.h>
 
 void __connman_driver_rescan(struct connman_driver *driver);
diff --git a/src/storage.c b/src/storage.c
index 1266fc28..5bf3f3f7 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -66,6 +66,86 @@ void connman_storage_unregister(struct connman_storage *storage)
 	storage_list = g_slist_remove(storage_list, storage);
 }
 
+int __connman_storage_load_device(struct connman_device *device)
+{
+	GSList *list;
+
+	DBG("device %p", device);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->device_load) {
+			DBG("%s", storage->name);
+
+			if (storage->device_load(device) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
+int __connman_storage_save_device(struct connman_device *device)
+{
+	GSList *list;
+
+	DBG("device %p", device);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->device_save) {
+			DBG("%s", storage->name);
+
+			if (storage->device_save(device) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
+int __connman_storage_load_network(struct connman_network *network)
+{
+	GSList *list;
+
+	DBG("network %p", network);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->network_load) {
+			DBG("%s", storage->name);
+
+			if (storage->network_load(network) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
+int __connman_storage_save_network(struct connman_network *network)
+{
+	GSList *list;
+
+	DBG("network %p", network);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->network_save) {
+			DBG("%s", storage->name);
+
+			if (storage->network_save(network) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
 int __connman_storage_init(void)
 {
 	DBG("");

commit 837f2fa6404de09d312ad5d41c0b67029bd6b266
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:25:42 2009 +0100

    Hook up loading and saving functions

diff --git a/src/device.c b/src/device.c
index 9f30a8a3..85a6d85b 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1001,6 +1001,8 @@ int connman_device_add_network(struct connman_device *device,
 
 	__connman_network_set_device(network, device);
 
+	__connman_storage_load_network(network);
+
 	err = connman_element_register((struct connman_element *) network,
 							&device->element);
 	if (err < 0) {
@@ -1054,6 +1056,8 @@ int connman_device_remove_network(struct connman_device *device,
  */
 int connman_device_register(struct connman_device *device)
 {
+	__connman_storage_load_device(device);
+
 	return connman_element_register(&device->element, NULL);
 }
 
@@ -1065,6 +1069,8 @@ int connman_device_register(struct connman_device *device)
  */
 void connman_device_unregister(struct connman_device *device)
 {
+	__connman_storage_save_device(device);
+
 	connman_element_unregister(&device->element);
 }
 

commit e68f7d8da19c66c657fd3d2cfff0cfc61ba1bda0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:28:59 2009 +0100

    Remove useless driver debugging details

diff --git a/src/storage.c b/src/storage.c
index 5bf3f3f7..6bbe0519 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -76,8 +76,6 @@ int __connman_storage_load_device(struct connman_device *device)
 		struct connman_storage *storage = list->data;
 
 		if (storage->device_load) {
-			DBG("%s", storage->name);
-
 			if (storage->device_load(device) == 0)
 				return 0;
 		}
@@ -96,8 +94,6 @@ int __connman_storage_save_device(struct connman_device *device)
 		struct connman_storage *storage = list->data;
 
 		if (storage->device_save) {
-			DBG("%s", storage->name);
-
 			if (storage->device_save(device) == 0)
 				return 0;
 		}
@@ -116,8 +112,6 @@ int __connman_storage_load_network(struct connman_network *network)
 		struct connman_storage *storage = list->data;
 
 		if (storage->network_load) {
-			DBG("%s", storage->name);
-
 			if (storage->network_load(network) == 0)
 				return 0;
 		}
@@ -136,8 +130,6 @@ int __connman_storage_save_network(struct connman_network *network)
 		struct connman_storage *storage = list->data;
 
 		if (storage->network_save) {
-			DBG("%s", storage->name);
-
 			if (storage->network_save(network) == 0)
 				return 0;
 		}

commit 625f2806e7d80e99709ef3b1441e8bc1db9dae4e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:31:17 2009 +0100

    Hook up default storage callbacks

diff --git a/src/device.c b/src/device.c
index 85a6d85b..5ff4b5a5 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1160,9 +1160,25 @@ static struct connman_driver device_driver = {
 	.remove		= device_remove,
 };
 
+static int device_load(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+static int device_save(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
 static struct connman_storage device_storage = {
 	.name		= "device",
 	.priority	= CONNMAN_STORAGE_PRIORITY_LOW,
+	.device_load	= device_load,
+	.device_save	= device_save,
 };
 
 int __connman_device_init(void)
diff --git a/src/network.c b/src/network.c
index e5353f5a..703ccd28 100644
--- a/src/network.c
+++ b/src/network.c
@@ -544,9 +544,25 @@ static struct connman_driver network_driver = {
 	.remove		= network_remove,
 };
 
+static int network_load(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
+static int network_save(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
 static struct connman_storage network_storage = {
 	.name		= "network",
 	.priority	= CONNMAN_STORAGE_PRIORITY_LOW,
+	.network_load	= network_load,
+	.network_save	= network_save,
 };
 
 int __connman_network_init(void)

commit 44ed8df3ee8197d0cb06a4250cf51484b88e5b5b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 19:58:06 2009 +0100

    Add support for device default storage

diff --git a/src/device.c b/src/device.c
index 5ff4b5a5..e63b8d24 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1162,15 +1162,87 @@ static struct connman_driver device_driver = {
 
 static int device_load(struct connman_device *device)
 {
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+	const char *str;
+
 	DBG("device %p", device);
 
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							device->element.name);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE) {
+		g_free(pathname);
+		return -ENOENT;
+	}
+
+	g_free(pathname);
+
+	if (g_key_file_load_from_data(keyfile, data, length,
+							0, NULL) == FALSE) {
+		g_free(data);
+		return -EILSEQ;
+	}
+
+	g_free(data);
+
+	str = g_key_file_get_string(keyfile, "Configuration", "Policy", NULL);
+	if (str != NULL)
+		device->policy = string2policy(str);
+
+	g_key_file_free(keyfile);
+
 	return 0;
 }
 
 static int device_save(struct connman_device *device)
 {
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+	const char *str;
+
 	DBG("device %p", device);
 
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR,
+							device->element.name);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
+		goto update;
+
+	if (length > 0) {
+		if (g_key_file_load_from_data(keyfile, data, length,
+							0, NULL) == FALSE)
+			goto done;
+	}
+
+	g_free(data);
+
+update:
+	str = policy2string(device->policy);
+	if (str != NULL)
+		g_key_file_set_string(keyfile, "Configuration", "Policy", str);
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents(pathname, data, length, NULL);
+
+done:
+	g_free(data);
+
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
 	return 0;
 }
 

commit 307c129f118759615c60832264b856b8ba63fef7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 20:52:07 2009 +0100

    Don't attempt scanning if device is switched off

diff --git a/src/device.c b/src/device.c
index e63b8d24..f481175c 100644
--- a/src/device.c
+++ b/src/device.c
@@ -393,6 +393,9 @@ static DBusMessage *propose_scan(DBusConnection *conn,
 	if (!device->driver || !device->driver->scan)
 		return __connman_error_not_supported(msg);
 
+	if (device->powered == FALSE)
+		return __connman_error_failed(msg);
+
 	err = device->driver->scan(device);
 	if (err < 0)
 		return __connman_error_failed(msg);

commit f419f84ecd0fc2d642befbe1ffb2bfea9607230e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 20:58:07 2009 +0100

    Use async creation and removal for supplicant interfaces

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 7edbb916..88e8123d 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -95,6 +95,15 @@ static GSList *task_list = NULL;
 
 static DBusConnection *connection;
 
+static void free_task(struct supplicant_task *task)
+{
+	DBG("task %p", task);
+
+	g_free(task->ifname);
+	g_free(task->path);
+	g_free(task);
+}
+
 static struct supplicant_task *find_task_by_index(int index)
 {
 	GSList *list;
@@ -123,37 +132,21 @@ static struct supplicant_task *find_task_by_path(const char *path)
 	return NULL;
 }
 
-static int get_interface(struct supplicant_task *task)
+static void add_interface_reply(DBusPendingCall *call, void *user_data)
 {
-	DBusMessage *message, *reply;
+	struct supplicant_task *task = user_data;
+	DBusMessage *reply;
 	DBusError error;
 	const char *path;
 
 	DBG("task %p", task);
 
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
-					SUPPLICANT_INTF, "getInterface");
-	if (message == NULL)
-		return -ENOMEM;
-
-	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
-							DBUS_TYPE_INVALID);
-
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to get interface");
-		dbus_message_unref(message);
-		return -EIO;
-	}
+	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL)
+		return;
 
-	dbus_message_unref(message);
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR)
+		goto done;
 
 	dbus_error_init(&error);
 
@@ -164,25 +157,24 @@ static int get_interface(struct supplicant_task *task)
 			dbus_error_free(&error);
 		} else
 			connman_error("Wrong arguments for interface");
-		dbus_message_unref(reply);
-		return -EIO;
+		goto done;
 	}
 
 	DBG("path %s", path);
 
 	task->path = g_strdup(path);
-	task->created = FALSE;
+	task->created = TRUE;
 
-	dbus_message_unref(reply);
+	connman_device_set_powered(task->device, TRUE);
 
-	return 0;
+done:
+	dbus_message_unref(reply);
 }
 
 static int add_interface(struct supplicant_task *task)
 {
-	DBusMessage *message, *reply;
-	DBusError error;
-	const char *path;
+	DBusMessage *message;
+	DBusPendingCall *call;
 
 	DBG("task %p", task);
 
@@ -191,25 +183,41 @@ static int add_interface(struct supplicant_task *task)
 	if (message == NULL)
 		return -ENOMEM;
 
-	dbus_error_init(&error);
-
 	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
 							DBUS_TYPE_INVALID);
 
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to add interface");
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to add interface");
 		dbus_message_unref(message);
 		return -EIO;
 	}
 
+	dbus_pending_call_set_notify(call, add_interface_reply, task, NULL);
+
 	dbus_message_unref(message);
 
+	return -EINPROGRESS;
+}
+
+static void get_interface_reply(DBusPendingCall *call, void *user_data)
+{
+	struct supplicant_task *task = user_data;
+	DBusMessage *reply;
+	DBusError error;
+	const char *path;
+
+	DBG("task %p", task);
+
+	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL)
+		return;
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		add_interface(task);
+		goto done;
+	}
+
 	dbus_error_init(&error);
 
 	if (dbus_message_get_args(reply, &error, DBUS_TYPE_OBJECT_PATH, &path,
@@ -219,29 +227,76 @@ static int add_interface(struct supplicant_task *task)
 			dbus_error_free(&error);
 		} else
 			connman_error("Wrong arguments for interface");
-		dbus_message_unref(reply);
-		return -EIO;
+		goto done;
 	}
 
 	DBG("path %s", path);
 
 	task->path = g_strdup(path);
-	task->created = TRUE;
+	task->created = FALSE;
 
+	connman_device_set_powered(task->device, TRUE);
+
+done:
 	dbus_message_unref(reply);
+}
 
-	return 0;
+static int create_interface(struct supplicant_task *task)
+{
+	DBusMessage *message;
+	DBusPendingCall *call;
+
+	DBG("task %p", task);
+
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
+					SUPPLICANT_INTF, "getInterface");
+	if (message == NULL)
+		return -ENOMEM;
+
+	dbus_message_append_args(message, DBUS_TYPE_STRING, &task->ifname,
+							DBUS_TYPE_INVALID);
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get interface");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
+	dbus_pending_call_set_notify(call, get_interface_reply, task, NULL);
+
+	dbus_message_unref(message);
+
+	return -EINPROGRESS;
+}
+
+static void remove_interface_reply(DBusPendingCall *call, void *user_data)
+{
+	struct supplicant_task *task = user_data;
+	DBusMessage *reply;
+
+	DBG("task %p", task);
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	connman_device_set_powered(task->device, FALSE);
+
+	free_task(task);
+
+	dbus_message_unref(reply);
 }
 
 static int remove_interface(struct supplicant_task *task)
 {
-	DBusMessage *message, *reply;
-	DBusError error;
+	DBusMessage *message;
+	DBusPendingCall *call;
 
 	DBG("task %p", task);
 
-	if (task->created == FALSE)
-		return -EINVAL;
+	if (task->created == FALSE) {
+		connman_device_set_powered(task->device, FALSE);
+		return 0;
+	}
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, SUPPLICANT_PATH,
 					SUPPLICANT_INTF, "removeInterface");
@@ -251,27 +306,21 @@ static int remove_interface(struct supplicant_task *task)
 	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->path,
 							DBUS_TYPE_INVALID);
 
-	dbus_error_init(&error);
-
-	reply = dbus_connection_send_with_reply_and_block(connection,
-							message, -1, &error);
-	if (reply == NULL) {
-		if (dbus_error_is_set(&error) == TRUE) {
-			connman_error("%s", error.message);
-			dbus_error_free(&error);
-		} else
-			connman_error("Failed to remove interface");
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to remove interface");
 		dbus_message_unref(message);
 		return -EIO;
 	}
 
-	dbus_message_unref(message);
+	dbus_pending_call_set_notify(call, remove_interface_reply, task, NULL);
 
-	dbus_message_unref(reply);
+	dbus_message_unref(message);
 
-	return 0;
+	return -EINPROGRESS;
 }
 
+#if 0
 static int set_ap_scan(struct supplicant_task *task)
 {
 	DBusMessage *message, *reply;
@@ -308,6 +357,7 @@ static int set_ap_scan(struct supplicant_task *task)
 
 	return 0;
 }
+#endif
 
 static int add_network(struct supplicant_task *task)
 {
@@ -958,7 +1008,6 @@ static DBusHandlerResult supplicant_filter(DBusConnection *conn,
 int supplicant_start(struct connman_device *device)
 {
 	struct supplicant_task *task;
-	int err;
 
 	DBG("device %p", device);
 
@@ -980,18 +1029,7 @@ int supplicant_start(struct connman_device *device)
 
 	task_list = g_slist_append(task_list, task);
 
-	err = get_interface(task);
-	if (err < 0) {
-		err = add_interface(task);
-		if (err < 0) {
-			g_free(task);
-			return err;
-		}
-	}
-
-	set_ap_scan(task);
-
-	return 0;
+	return create_interface(task);
 }
 
 int supplicant_stop(struct connman_device *device)
@@ -1011,13 +1049,7 @@ int supplicant_stop(struct connman_device *device)
 
 	remove_network(task);
 
-	remove_interface(task);
-
-	g_free(task->ifname);
-	g_free(task->path);
-	g_free(task);
-
-	return 0;
+	return remove_interface(task);
 }
 
 int supplicant_scan(struct connman_device *device)
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 6c3efde6..0ae1014f 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -428,19 +428,9 @@ static void wifi_remove(struct connman_device *device)
 
 static int wifi_enable(struct connman_device *device)
 {
-	int err;
-
 	DBG("device %p", device);
 
-	err = supplicant_start(device);
-	if (err < 0)
-		return err;
-
-	connman_device_set_powered(device, TRUE);
-
-	supplicant_scan(device);
-
-	return 0;
+	return supplicant_start(device);
 }
 
 static int wifi_disable(struct connman_device *device)
@@ -474,20 +464,14 @@ static int wifi_disable(struct connman_device *device)
 
 	connman_element_unregister_children((struct connman_element *) device);
 
-	supplicant_stop(device);
-
-	connman_device_set_powered(device, FALSE);
-
-	return 0;
+	return supplicant_stop(device);
 }
 
 static int wifi_scan(struct connman_device *device)
 {
 	DBG("device %p", device);
 
-	supplicant_scan(device);
-
-	return 0;
+	return supplicant_scan(device);
 }
 
 static struct connman_device_driver wifi_driver = {

commit 3f83680866994c2859b9b7286595f2d8d17accb8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 21:12:27 2009 +0100

    Fix error messages for interface replies

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 88e8123d..c11b8858 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -156,7 +156,7 @@ static void add_interface_reply(DBusPendingCall *call, void *user_data)
 			connman_error("%s", error.message);
 			dbus_error_free(&error);
 		} else
-			connman_error("Wrong arguments for interface");
+			connman_error("Wrong arguments for add interface");
 		goto done;
 	}
 
@@ -226,7 +226,7 @@ static void get_interface_reply(DBusPendingCall *call, void *user_data)
 			connman_error("%s", error.message);
 			dbus_error_free(&error);
 		} else
-			connman_error("Wrong arguments for interface");
+			connman_error("Wrong arguments for get interface");
 		goto done;
 	}
 

commit 79b06da8b3eb03ed8da7f9a3a3ea11822c75fa1d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 4 21:17:42 2009 +0100

    Fix typo in state parsing

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index c11b8858..4f03b424 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -951,7 +951,7 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	else if (g_str_equal(state, "ASSOCIATED") == TRUE)
 		task->state = STATE_ASSOCIATED;
 	else if (g_str_equal(state, "GROUP_HANDSHAKE") == TRUE)
-		task->state = STATE_4WAY_HANDSHAKE;
+		task->state = STATE_GROUP_HANDSHAKE;
 	else if (g_str_equal(state, "4WAY_HANDSHAKE") == TRUE)
 		task->state = STATE_4WAY_HANDSHAKE;
 	else if (g_str_equal(state, "COMPLETED") == TRUE)

commit a2a0ab77eb03a56044c13ca5886065d092364481
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:00:55 2009 +0100

    Add functions for setting network properties

diff --git a/include/network.h b/include/network.h
index 61faf473..7249264d 100644
--- a/include/network.h
+++ b/include/network.h
@@ -72,6 +72,13 @@ extern void connman_network_set_protocol(struct connman_network *network,
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
 
+extern int connman_network_set_string(struct connman_network *network,
+					const char *key, const char *value);
+extern int connman_network_set_uint8(struct connman_network *network,
+					const char *key, connman_uint8_t value);
+extern int connman_network_set_blob(struct connman_network *network,
+			const char *key, const void *data, unsigned int size);
+
 extern struct connman_device *connman_network_get_device(struct connman_network *network);
 
 extern void *connman_network_get_data(struct connman_network *network);
diff --git a/include/types.h b/include/types.h
index 648fee1e..af2a81bc 100644
--- a/include/types.h
+++ b/include/types.h
@@ -34,7 +34,8 @@ extern "C" {
 #define	TRUE	(!FALSE)
 #endif
 
-typedef int	connman_bool_t;
+typedef int		connman_bool_t;
+typedef unsigned char	connman_uint8_t;
 
 #ifdef __cplusplus
 }
diff --git a/src/network.c b/src/network.c
index 703ccd28..cd0bb759 100644
--- a/src/network.c
+++ b/src/network.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <string.h>
+
 #include <gdbus.h>
 
 #include "connman.h"
@@ -31,14 +33,24 @@ struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
 	enum connman_network_protocol protocol;
-	gboolean connected;
+	connman_bool_t connected;
+	connman_uint8_t strength;
 	char *identifier;
+	char *name;
 	char *path;
 
 	struct connman_network_driver *driver;
 	void *driver_data;
 
 	struct connman_device *device;
+
+	struct {
+		void *ssid;
+		int ssid_len;
+		char *mode;
+		char *security;
+		char *passphrase;
+	} wifi;
 };
 
 static DBusMessage *get_properties(DBusConnection *conn,
@@ -61,13 +73,34 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	if (network->identifier != NULL)
+	if (network->name != NULL)
 		connman_dbus_dict_append_variant(&dict, "Name",
-				DBUS_TYPE_STRING, &network->identifier);
+					DBUS_TYPE_STRING, &network->name);
 
 	connman_dbus_dict_append_variant(&dict, "Connected",
 				DBUS_TYPE_BOOLEAN, &network->connected);
 
+	if (network->strength > 0)
+		connman_dbus_dict_append_variant(&dict, "Strength",
+					DBUS_TYPE_BYTE, &network->strength);
+
+	if (network->wifi.ssid != NULL && network->wifi.ssid_len > 0)
+		connman_dbus_dict_append_array(&dict, "WiFi.SSID",
+				DBUS_TYPE_BYTE, &network->wifi.ssid,
+						network->wifi.ssid_len);
+
+	if (network->wifi.mode != NULL)
+		connman_dbus_dict_append_variant(&dict, "WiFi.Mode",
+				DBUS_TYPE_STRING, &network->wifi.mode);
+
+	if (network->wifi.security != NULL)
+		connman_dbus_dict_append_variant(&dict, "WiFi.Security",
+				DBUS_TYPE_STRING, &network->wifi.security);
+
+	if (network->wifi.passphrase != NULL)
+		connman_dbus_dict_append_variant(&dict, "WiFi.Passphrase",
+				DBUS_TYPE_STRING, &network->wifi.passphrase);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -153,9 +186,6 @@ static int register_interface(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_NETWORK_INTERFACE);
-
 	if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_NETWORK_INTERFACE,
 					network_methods, network_signals,
@@ -226,7 +256,13 @@ static void network_destruct(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	g_free(network->wifi.ssid);
+	g_free(network->wifi.mode);
+	g_free(network->wifi.security);
+	g_free(network->wifi.passphrase);
+
 	g_free(network->path);
+	g_free(network->name);
 	g_free(network->identifier);
 }
 
@@ -430,6 +466,79 @@ int connman_network_set_connected(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_set_string:
+ * @network: network structure
+ * @key: unique identifier
+ * @value: string value
+ *
+ * Set string value for specific key
+ */
+int connman_network_set_string(struct connman_network *network,
+					const char *key, const char *value)
+{
+	DBG("network %p key %s value %s", network, key, value);
+
+	if (g_str_equal(key, "Name") == TRUE) {
+		g_free(network->name);
+		network->name = g_strdup(value);
+	} else if (g_str_equal(key, "WiFi.Mode") == TRUE) {
+		g_free(network->wifi.mode);
+		network->wifi.mode = g_strdup(value);
+	} else if (g_str_equal(key, "WiFi.Security") == TRUE) {
+		g_free(network->wifi.security);
+		network->wifi.security = g_strdup(value);
+	}
+
+	return 0;
+}
+
+/**
+ * connman_network_set_uint8:
+ * @network: network structure
+ * @key: unique identifier
+ * @value: integer value
+ *
+ * Set integer value for specific key
+ */
+int connman_network_set_uint8(struct connman_network *network,
+					const char *key, connman_uint8_t value)
+{
+	DBG("network %p key %s value %d", network, key, value);
+
+	if (g_str_equal(key, "Strength") == TRUE)
+		network->strength = value;
+
+	return 0;
+}
+
+/**
+ * connman_network_set_blob:
+ * @network: network structure
+ * @key: unique identifier
+ * @data: blob data
+ * @size: blob size
+ *
+ * Set binary blob value for specific key
+ */
+int connman_network_set_blob(struct connman_network *network,
+			const char *key, const void *data, unsigned int size)
+{
+	DBG("network %p key %s size %d", network, key, size);
+
+	if (g_str_equal(key, "WiFi.SSID") == TRUE) {
+		g_free(network->wifi.ssid);
+		network->wifi.ssid = g_try_malloc(size);
+		if (network->wifi.ssid != NULL) {
+			memcpy(network->wifi.ssid, data, size);
+			network->wifi.ssid_len = size;
+		} else
+			network->wifi.ssid_len = 0;
+	}
+
+	return 0;
+}
+
 void __connman_network_set_device(struct connman_network *network,
 					struct connman_device *device)
 {

commit e061175d100cbb068b572030b88981f83984287c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:23:29 2009 +0100

    Add support for more device and network properties

diff --git a/include/device.h b/include/device.h
index b14b9b16..8af7d282 100644
--- a/include/device.h
+++ b/include/device.h
@@ -70,8 +70,6 @@ extern struct connman_device *connman_device_create(const char *node,
 extern struct connman_device *connman_device_ref(struct connman_device *device);
 extern void connman_device_unref(struct connman_device *device);
 
-extern void connman_device_set_path(struct connman_device *device,
-							const char *path);
 extern const char *connman_device_get_path(struct connman_device *device);
 extern void connman_device_set_index(struct connman_device *device,
 								int index);
@@ -92,6 +90,11 @@ extern int connman_device_set_carrier(struct connman_device *device,
 extern int connman_device_set_scanning(struct connman_device *device,
 						connman_bool_t scanning);
 
+extern int connman_device_set_string(struct connman_device *device,
+					const char *key, const char *value);
+extern const char *connman_device_get_string(struct connman_device *device,
+							const char *key);
+
 extern int connman_device_add_network(struct connman_device *device,
 					struct connman_network *network);
 extern struct connman_network *connman_device_get_network(struct connman_device *device,
diff --git a/include/network.h b/include/network.h
index 7249264d..14e9d871 100644
--- a/include/network.h
+++ b/include/network.h
@@ -59,8 +59,6 @@ extern void connman_network_unref(struct connman_network *network);
 
 extern const char *connman_network_get_identifier(struct connman_network *network);
 
-extern void connman_network_set_path(struct connman_network *network,
-							const char *path);
 extern const char *connman_network_get_path(struct connman_network *network);
 extern void connman_network_set_index(struct connman_network *network,
 								int index);
@@ -74,6 +72,8 @@ extern int connman_network_set_connected(struct connman_network *network,
 
 extern int connman_network_set_string(struct connman_network *network,
 					const char *key, const char *value);
+extern const char *connman_network_get_string(struct connman_network *network,
+							const char *key);
 extern int connman_network_set_uint8(struct connman_network *network,
 					const char *key, connman_uint8_t value);
 extern int connman_network_set_blob(struct connman_network *network,
diff --git a/src/device.c b/src/device.c
index f481175c..48f3f7d2 100644
--- a/src/device.c
+++ b/src/device.c
@@ -36,7 +36,8 @@ struct connman_device {
 	gboolean powered;
 	gboolean carrier;
 	gboolean scanning;
-	char *path;
+	char *name;
+	char *node;
 	char *interface;
 
 	struct connman_device_driver *driver;
@@ -656,7 +657,8 @@ static void device_destruct(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
-	g_free(device->path);
+	g_free(device->node);
+	g_free(device->name);
 	g_free(device->interface);
 
 	g_hash_table_destroy(device->networks);
@@ -746,22 +748,6 @@ void connman_device_unref(struct connman_device *device)
 	connman_element_unref(&device->element);
 }
 
-/**
- * connman_device_set_path:
- * @device: device structure
- * @path: path name
- *
- * Set path name of device
- */
-void connman_device_set_path(struct connman_device *device, const char *path)
-{
-	g_free(device->element.devpath);
-	device->element.devpath = g_strdup(path);
-
-	g_free(device->path);
-	device->path = g_strdup(path);
-}
-
 /**
  * connman_device_get_path:
  * @device: device structure
@@ -770,7 +756,7 @@ void connman_device_set_path(struct connman_device *device, const char *path)
  */
 const char *connman_device_get_path(struct connman_device *device)
 {
-	return device->path;
+	return device->element.path;
 }
 
 /**
@@ -978,6 +964,50 @@ int connman_device_set_scanning(struct connman_device *device,
 	return 0;
 }
 
+/**
+ * connman_device_set_string:
+ * @device: device structure
+ * @key: unique identifier
+ * @value: string value
+ *
+ * Set string value for specific key
+ */
+int connman_device_set_string(struct connman_device *device,
+					const char *key, const char *value)
+{
+	DBG("device %p key %s value %s", device, key, value);
+
+	if (g_str_equal(key, "Name") == TRUE) {
+		g_free(device->name);
+		device->name = g_strdup(value);
+	} else if (g_str_equal(key, "Node") == TRUE) {
+		g_free(device->node);
+		device->node = g_strdup(value);
+	}
+
+	return 0;
+}
+
+/**
+ * connman_device_get_string:
+ * @device: device structure
+ * @key: unique identifier
+ *
+ * Get string value for specific key
+ */
+const char *connman_device_get_string(struct connman_device *device,
+							const char *key)
+{
+	DBG("device %p key %s", device);
+
+	if (g_str_equal(key, "Name") == TRUE)
+		return device->name;
+	else if (g_str_equal(key, "Node") == TRUE)
+		return device->node;
+
+	return NULL;
+}
+
 /**
  * connman_device_add_network:
  * @device: device structure
diff --git a/src/network.c b/src/network.c
index cd0bb759..898bed5a 100644
--- a/src/network.c
+++ b/src/network.c
@@ -37,7 +37,7 @@ struct connman_network {
 	connman_uint8_t strength;
 	char *identifier;
 	char *name;
-	char *path;
+	char *node;
 
 	struct connman_network_driver *driver;
 	void *driver_data;
@@ -73,6 +73,13 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	if (network->device) {
+		const char *path = connman_device_get_path(network->device);
+		if (path != NULL)
+			connman_dbus_dict_append_variant(&dict, "Device",
+						DBUS_TYPE_OBJECT_PATH, &path);
+	}
+
 	if (network->name != NULL)
 		connman_dbus_dict_append_variant(&dict, "Name",
 					DBUS_TYPE_STRING, &network->name);
@@ -261,7 +268,7 @@ static void network_destruct(struct connman_element *element)
 	g_free(network->wifi.security);
 	g_free(network->wifi.passphrase);
 
-	g_free(network->path);
+	g_free(network->node);
 	g_free(network->name);
 	g_free(network->identifier);
 }
@@ -355,22 +362,6 @@ const char *connman_network_get_identifier(struct connman_network *network)
 	return network->identifier;
 }
 
-/**
- * connman_network_set_path:
- * @network: network structure
- * @path: path name
- *
- * Set path name of network
- */
-void connman_network_set_path(struct connman_network *network, const char *path)
-{
-	g_free(network->element.devpath);
-	network->element.devpath = g_strdup(path);
-
-	g_free(network->path);
-	network->path = g_strdup(path);
-}
-
 /**
  * connman_network_get_path:
  * @network: network structure
@@ -379,7 +370,7 @@ void connman_network_set_path(struct connman_network *network, const char *path)
  */
 const char *connman_network_get_path(struct connman_network *network)
 {
-	return network->path;
+	return network->element.path;
 }
 
 /**
@@ -482,6 +473,9 @@ int connman_network_set_string(struct connman_network *network,
 	if (g_str_equal(key, "Name") == TRUE) {
 		g_free(network->name);
 		network->name = g_strdup(value);
+	} else if (g_str_equal(key, "Node") == TRUE) {
+		g_free(network->node);
+		network->node = g_strdup(value);
 	} else if (g_str_equal(key, "WiFi.Mode") == TRUE) {
 		g_free(network->wifi.mode);
 		network->wifi.mode = g_strdup(value);
@@ -493,6 +487,30 @@ int connman_network_set_string(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_get_string:
+ * @network: network structure
+ * @key: unique identifier
+ *
+ * Get string value for specific key
+ */
+const char *connman_network_get_string(struct connman_network *network,
+							const char *key)
+{
+	DBG("network %p key %s", network);
+
+	if (g_str_equal(key, "Name") == TRUE)
+		return network->name;
+	else if (g_str_equal(key, "Node") == TRUE)
+		return network->node;
+	else if (g_str_equal(key, "WiFi.Mode") == TRUE)
+		return network->wifi.mode;
+	else if (g_str_equal(key, "WiFi.Security") == TRUE)
+		return network->wifi.security;
+
+	return NULL;
+}
+
 /**
  * connman_network_set_uint8:
  * @network: network structure

commit b3e54c3c8b2a4f83da7e7bf6c3c91b4b7f501151
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:23:53 2009 +0100

    Use the property functions for path data

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 5bde01d7..200c3ff3 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -218,7 +218,7 @@ done:
 static int pan_connect(struct connman_network *network)
 {
 	struct network_data *data = connman_network_get_data(network);
-	const char *path = connman_network_get_path(network);
+	const char *path = connman_network_get_string(network, "Node");
 	const char *uuid = "nap";
 	DBusMessage *message;
 	DBusPendingCall *call;
@@ -284,7 +284,7 @@ done:
 static int pan_disconnect(struct connman_network *network)
 {
 	struct network_data *data = connman_network_get_data(network);
-	const char *path = connman_network_get_path(network);
+	const char *path = connman_network_get_string(network, "Node");
 	DBusMessage *message;
 	DBusPendingCall *call;
 
@@ -404,7 +404,7 @@ static int change_powered(DBusConnection *connection, const char *path,
 static int bluetooth_enable(struct connman_device *adapter)
 {
 	struct adapter_data *data = connman_device_get_data(adapter);
-	const char *path = connman_device_get_path(adapter);
+	const char *path = connman_device_get_string(adapter, "Node");
 
 	DBG("adapter %p", adapter);
 
@@ -414,7 +414,7 @@ static int bluetooth_enable(struct connman_device *adapter)
 static int bluetooth_disable(struct connman_device *adapter)
 {
 	struct adapter_data *data = connman_device_get_data(adapter);
-	const char *path = connman_device_get_path(adapter);
+	const char *path = connman_device_get_string(adapter, "Node");
 
 	DBG("adapter %p", adapter);
 
@@ -465,7 +465,8 @@ static struct connman_device *find_adapter(const char *path)
 
 	for (list = adapter_list; list; list = list->next) {
 		struct connman_device *adapter = list->data;
-		const char *adapter_path = connman_device_get_path(adapter);
+		const char *adapter_path = connman_device_get_string(adapter,
+									"Node");
 
 		if (adapter_path == NULL)
 			continue;
@@ -495,7 +496,7 @@ static void device_properties(DBusConnection *connection, const char *path,
 	if (network == NULL)
 		return;
 
-	connman_network_set_path(network, path);
+	connman_network_set_string(network, "Node", path);
 
 	connman_device_add_network(device, network);
 }
@@ -614,7 +615,7 @@ static void adapter_properties(DBusConnection *connection, const char *path,
 	if (adapter == NULL)
 		return;
 
-	connman_device_set_path(adapter, path);
+	connman_device_set_string(adapter, "Node", path);
 
 	if (node != NULL && g_str_has_prefix(node, "hci") == TRUE) {
 		int index;

commit 3d4f387859e9ea1ed36af5c42a791a7597e1adec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:27:45 2009 +0100

    Remove network interface support from elements

diff --git a/src/element.c b/src/element.c
index 74f7087d..9701ba97 100644
--- a/src/element.c
+++ b/src/element.c
@@ -278,6 +278,7 @@ static void add_common_properties(struct connman_element *element,
 	__connman_element_unlock(element);
 }
 
+#if 0
 static void set_common_property(struct connman_element *element,
 				const char *name, DBusMessageIter *value)
 {
@@ -312,6 +313,7 @@ static void set_common_property(struct connman_element *element,
 
 	__connman_element_unlock(element);
 }
+#endif
 
 static void emit_element_signal(DBusConnection *conn, const char *member,
 					struct connman_element *element)
@@ -460,82 +462,6 @@ static DBusMessage *do_disable(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static DBusMessage *network_get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	if (element->parent)
-		connman_dbus_dict_append_variant(&dict, "Device",
-				DBUS_TYPE_OBJECT_PATH, &element->parent->path);
-
-	connman_dbus_dict_append_variant(&dict, "Available",
-					DBUS_TYPE_BOOLEAN, &element->available);
-
-	connman_dbus_dict_append_variant(&dict, "Connected",
-					DBUS_TYPE_BOOLEAN, &element->enabled);
-
-	connman_dbus_dict_append_variant(&dict, "Remember",
-					DBUS_TYPE_BOOLEAN, &element->remember);
-
-	add_common_properties(element, &dict);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
-static DBusMessage *network_set_property(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessageIter iter;
-	DBusMessageIter value;
-	const char *name;
-
-	DBG("conn %p", conn);
-
-	if (dbus_message_iter_init(msg, &iter) == FALSE)
-		return __connman_error_invalid_arguments(msg);
-
-	dbus_message_iter_get_basic(&iter, &name);
-	dbus_message_iter_next(&iter);
-	dbus_message_iter_recurse(&iter, &value);
-
-	if (__connman_security_check_privileges(msg) < 0)
-		return __connman_error_permission_denied(msg);
-
-	if (g_str_equal(name, "Remember") == TRUE) {
-		dbus_message_iter_get_basic(&value, &element->remember);
-	} else if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
-		const char *str;
-
-		dbus_message_iter_get_basic(&value, &str);
-		g_free(element->wifi.passphrase);
-		element->wifi.passphrase = g_strdup(str);
-	} else
-		set_common_property(element, name, &value);
-
-	__connman_element_store(element);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
 static DBusMessage *connection_get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -614,14 +540,6 @@ static DBusMessage *connection_set_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
-static GDBusMethodTable network_methods[] = {
-	{ "GetProperties", "",   "a{sv}", network_get_properties },
-	{ "SetProperty",   "sv", "",      network_set_property   },
-	{ "Connect",       "",   "",      do_enable              },
-	{ "Disconnect",    "",   "",      do_disable             },
-	{ },
-};
-
 static GDBusMethodTable connection_methods[] = {
 	{ "GetProperties", "",   "a{sv}", connection_get_properties },
 	{ "SetProperty",   "sv", "",      connection_set_property   },
@@ -1572,49 +1490,6 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 	return result;
 }
 
-static void append_networks(struct connman_element *element,
-						DBusMessageIter *entry)
-{
-	DBusMessageIter value, iter;
-	const char *key = "Networks";
-
-	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
-		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
-								&value);
-
-	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_element_list(element, CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
-	dbus_message_iter_close_container(&value, &iter);
-
-	dbus_message_iter_close_container(entry, &value);
-}
-
-static void emit_networks_signal(DBusConnection *conn,
-					struct connman_element *device)
-{
-	DBusMessage *signal;
-	DBusMessageIter entry;
-
-	DBG("conn %p", conn);
-
-	if (device == NULL)
-		return;
-
-	signal = dbus_message_new_signal(device->path,
-				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
-	if (signal == NULL)
-		return;
-
-	dbus_message_iter_init_append(signal, &entry);
-
-	append_networks(device, &entry);
-
-	g_dbus_send_message(conn, signal);
-}
-
 static void append_connections(DBusMessageIter *entry)
 {
 	DBusMessageIter value, iter;
@@ -1758,17 +1633,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_node_append_data(node, element);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
-		if (g_dbus_register_interface(connection, element->path,
-					CONNMAN_NETWORK_INTERFACE,
-					network_methods, element_signals,
-					NULL, element, NULL) == FALSE)
-			connman_error("Failed to register %s network",
-								element->path);
-		else
-			emit_networks_signal(connection, element->parent);
-	}
-
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
 		if (g_dbus_register_interface(connection, element->path,
 					CONNMAN_CONNECTION_INTERFACE,
@@ -1879,13 +1743,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 						CONNMAN_CONNECTION_INTERFACE);
 	}
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
-		emit_networks_signal(connection, element->parent);
-
-		g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_NETWORK_INTERFACE);
-	}
-
 	emit_element_signal(connection, "ElementRemoved", element);
 
 	connman_element_unref(element);

commit e7a8f816ab9cb02249659bc3523722e0b86de05d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:30:27 2009 +0100

    Remove special handling for devices and networks

diff --git a/src/element.c b/src/element.c
index 9701ba97..aa2d54c2 100644
--- a/src/element.c
+++ b/src/element.c
@@ -349,14 +349,6 @@ static void emit_enabled_signal(DBusConnection *conn,
 		return;
 
 	switch (element->type) {
-	case CONNMAN_ELEMENT_TYPE_DEVICE:
-		iface = CONNMAN_DEVICE_INTERFACE;
-		key = "Powered";
-		break;
-	case CONNMAN_ELEMENT_TYPE_NETWORK:
-		iface = CONNMAN_NETWORK_INTERFACE;
-		key = "Connected";
-		break;
 	case CONNMAN_ELEMENT_TYPE_CONNECTION:
 		iface = CONNMAN_CONNECTION_INTERFACE;
 		key = "Default";
@@ -993,12 +985,6 @@ static void emit_property_changed(DBusConnection *conn,
 	DBG("conn %p", conn);
 
 	switch (element->type) {
-	case CONNMAN_ELEMENT_TYPE_DEVICE:
-		iface = CONNMAN_DEVICE_INTERFACE;
-		break;
-	case CONNMAN_ELEMENT_TYPE_NETWORK:
-		iface = CONNMAN_NETWORK_INTERFACE;
-		break;
 	case CONNMAN_ELEMENT_TYPE_CONNECTION:
 		iface = CONNMAN_CONNECTION_INTERFACE;
 		break;

commit 14a162c1c42466791a655475289770da076bfd71
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:32:28 2009 +0100

    Remove scanning support from elements

diff --git a/include/element.h b/include/element.h
index 83c146be..1334a038 100644
--- a/include/element.h
+++ b/include/element.h
@@ -90,7 +90,6 @@ struct connman_element {
 	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
-	gboolean scanning;
 	gboolean available;
 	gboolean remember;
 	guint16 priority;
diff --git a/src/element.c b/src/element.c
index aa2d54c2..95157dc5 100644
--- a/src/element.c
+++ b/src/element.c
@@ -375,39 +375,6 @@ static void emit_enabled_signal(DBusConnection *conn,
 	g_dbus_send_message(conn, signal);
 }
 
-static void emit_scanning_signal(DBusConnection *conn,
-					struct connman_element *element)
-{
-	DBusMessage *signal;
-	DBusMessageIter entry, value;
-	const char *key = "Scanning";
-
-	DBG("conn %p", conn);
-
-	if (element == NULL)
-		return;
-
-	if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE)
-		return;
-
-	signal = dbus_message_new_signal(element->path,
-				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
-	if (signal == NULL)
-		return;
-
-	dbus_message_iter_init_append(signal, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
-	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN,
-							&element->scanning);
-	dbus_message_iter_close_container(&entry, &value);
-
-	g_dbus_send_message(conn, signal);
-}
-
 static DBusMessage *do_enable(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -1812,19 +1779,6 @@ int connman_element_set_enabled(struct connman_element *element,
 	return 0;
 }
 
-int connman_element_set_scanning(struct connman_element *element,
-							gboolean scanning)
-{
-	if (element->scanning == scanning)
-		return 0;
-
-	element->scanning = scanning;
-
-	emit_scanning_signal(connection, element);
-
-	return 0;
-}
-
 int __connman_element_init(DBusConnection *conn, const char *device)
 {
 	struct connman_element *element;

commit 888b54002e0ba4e465f0ae1628c475dfc54ffef1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 00:45:05 2009 +0100

    Update WiFi plugin for new network helper functions

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 4f03b424..5672f379 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -29,8 +29,9 @@
 #include <gdbus.h>
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
-#include <connman/log.h>
+#include <connman/device.h>
 #include <connman/dbus.h>
+#include <connman/log.h>
 
 #include "inet.h"
 #include "supplicant.h"
@@ -41,45 +42,35 @@
 #define IEEE80211_CAP_IBSS      0x0002
 #define IEEE80211_CAP_PRIVACY   0x0010
 
-static GSList *driver_list = NULL;
-
-static void process_state_change(struct connman_device *device,
-						enum supplicant_state state)
-{
-	GSList *list;
-
-	for (list = driver_list; list; list = list->next) {
-		struct supplicant_driver *driver = list->data;
-
-		if (driver->state_change)
-			driver->state_change(device, state);
-	}
-}
-
-static void process_clear_results(struct connman_device *device)
-{
-	GSList *list;
-
-	for (list = driver_list; list; list = list->next) {
-		struct supplicant_driver *driver = list->data;
-
-		if (driver->clear_results)
-			driver->clear_results(device);
-	}
-}
-
-static void process_scan_result(struct connman_device *device,
-					struct supplicant_network *network)
-{
-	GSList *list;
-
-	for (list = driver_list; list; list = list->next) {
-		struct supplicant_driver *driver = list->data;
+#define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
+#define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
+
+enum supplicant_state {
+	STATE_INACTIVE,
+	STATE_SCANNING,
+	STATE_ASSOCIATING,
+	STATE_ASSOCIATED,
+	STATE_4WAY_HANDSHAKE,
+	STATE_GROUP_HANDSHAKE,
+	STATE_COMPLETED,
+	STATE_DISCONNECTED,
+};
 
-		if (driver->scan_result)
-			driver->scan_result(device, network);
-	}
-}
+struct supplicant_result {
+	char *identifier;
+	unsigned char *ssid;
+	unsigned int ssid_len;
+	dbus_uint16_t capabilities;
+	gboolean adhoc;
+	gboolean has_wep;
+	gboolean has_wpa;
+	gboolean has_rsn;
+	dbus_int32_t quality;
+	dbus_int32_t noise;
+	dbus_int32_t level;
+	dbus_int32_t maxrate;
+};
 
 struct supplicant_task {
 	int ifindex;
@@ -89,6 +80,7 @@ struct supplicant_task {
 	gboolean created;
 	gchar *network;
 	enum supplicant_state state;
+	GSList *scan_results;
 };
 
 static GSList *task_list = NULL;
@@ -686,8 +678,8 @@ static int initiate_scan(struct supplicant_task *task)
 	return 0;
 }
 
-static void extract_ssid(struct supplicant_network *network,
-						DBusMessageIter *value)
+static void extract_ssid(DBusMessageIter *value,
+					struct supplicant_result *result)
 {
 	DBusMessageIter array;
 	unsigned char *ssid;
@@ -699,22 +691,22 @@ static void extract_ssid(struct supplicant_network *network,
 	if (ssid_len < 1)
 		return;
 
-	network->ssid = g_try_malloc(ssid_len);
-	if (network->ssid == NULL)
+	result->ssid = g_try_malloc(ssid_len);
+	if (result->ssid == NULL)
 		return;
 
-	memcpy(network->ssid, ssid, ssid_len);
-	network->ssid_len = ssid_len;
+	memcpy(result->ssid, ssid, ssid_len);
+	result->ssid_len = ssid_len;
 
-	network->identifier = g_try_malloc0(ssid_len + 1);
-	if (network->identifier == NULL)
+	result->identifier = g_try_malloc0(ssid_len + 1);
+	if (result->identifier == NULL)
 		return;
 
-	memcpy(network->identifier, ssid, ssid_len);
+	memcpy(result->identifier, ssid, ssid_len);
 }
 
-static void extract_wpaie(struct supplicant_network *network,
-						DBusMessageIter *value)
+static void extract_wpaie(DBusMessageIter *value,
+					struct supplicant_result *result)
 {
 	DBusMessageIter array;
 	unsigned char *ie;
@@ -724,11 +716,11 @@ static void extract_wpaie(struct supplicant_network *network,
 	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
 
 	if (ie_len > 0)
-		network->has_wpa = TRUE;
+		result->has_wpa = TRUE;
 }
 
-static void extract_rsnie(struct supplicant_network *network,
-						DBusMessageIter *value)
+static void extract_rsnie(DBusMessageIter *value,
+					struct supplicant_result *result)
 {
 	DBusMessageIter array;
 	unsigned char *ie;
@@ -738,37 +730,45 @@ static void extract_rsnie(struct supplicant_network *network,
 	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
 
 	if (ie_len > 0)
-		network->has_rsn = TRUE;
+		result->has_rsn = TRUE;
 }
 
-static void extract_capabilites(struct supplicant_network *network,
-						DBusMessageIter *value)
+static void extract_capabilites(DBusMessageIter *value,
+					struct supplicant_result *result)
 {
-	dbus_message_iter_get_basic(value, &network->capabilities);
+	dbus_message_iter_get_basic(value, &result->capabilities);
 
-	if (network->capabilities & IEEE80211_CAP_ESS)
-		network->adhoc = FALSE;
-	else if (network->capabilities & IEEE80211_CAP_IBSS)
-		network->adhoc = TRUE;
+	if (result->capabilities & IEEE80211_CAP_ESS)
+		result->adhoc = FALSE;
+	else if (result->capabilities & IEEE80211_CAP_IBSS)
+		result->adhoc = TRUE;
 
-	if (network->capabilities & IEEE80211_CAP_PRIVACY)
-		network->has_wep = TRUE;
+	if (result->capabilities & IEEE80211_CAP_PRIVACY)
+		result->has_wep = TRUE;
 }
 
+static int get_properties(struct supplicant_task *task);
+
 static void properties_reply(DBusPendingCall *call, void *user_data)
 {
 	struct supplicant_task *task = user_data;
-	struct supplicant_network *network;
+	struct supplicant_result result;
+	struct connman_network *network;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	char *temp = NULL;
+	unsigned char strength;
+	unsigned int i;
 
 	DBG("task %p", task);
 
 	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL) {
+		get_properties(task);
+		return;
+	}
 
-	network = g_try_new0(struct supplicant_network, 1);
-	if (network == NULL)
-		goto done;
+	memset(&result, 0, sizeof(result));
 
 	dbus_message_iter_init(reply, &array);
 
@@ -802,45 +802,112 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		 */
 
 		if (g_str_equal(key, "ssid") == TRUE)
-			extract_ssid(network, &value);
+			extract_ssid(&value, &result);
 		else if (g_str_equal(key, "wpaie") == TRUE)
-			extract_wpaie(network, &value);
+			extract_wpaie(&value, &result);
 		else if (g_str_equal(key, "rsnie") == TRUE)
-			extract_rsnie(network, &value);
+			extract_rsnie(&value, &result);
 		else if (g_str_equal(key, "capabilities") == TRUE)
-			extract_capabilites(network, &value);
+			extract_capabilites(&value, &result);
 		else if (g_str_equal(key, "quality") == TRUE)
-			dbus_message_iter_get_basic(&value, &network->quality);
+			dbus_message_iter_get_basic(&value, &result.quality);
 		else if (g_str_equal(key, "noise") == TRUE)
-			dbus_message_iter_get_basic(&value, &network->noise);
+			dbus_message_iter_get_basic(&value, &result.noise);
 		else if (g_str_equal(key, "level") == TRUE)
-			dbus_message_iter_get_basic(&value, &network->level);
+			dbus_message_iter_get_basic(&value, &result.level);
 		else if (g_str_equal(key, "maxrate") == TRUE)
-			dbus_message_iter_get_basic(&value, &network->maxrate);
-
+			dbus_message_iter_get_basic(&value, &result.maxrate);
 
 		dbus_message_iter_next(&dict);
 	}
 
-	process_scan_result(task->device, network);
+	if (result.identifier == NULL)
+		goto done;
+
+	if (result.identifier[0] == '\0')
+		goto done;
+
+	temp = g_strdup(result.identifier);
+	if (temp == NULL)
+		goto done;
+
+	for (i = 0; i < strlen(temp); i++) {
+		char tmp = temp[i];
+		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
+						(tmp < 'a' || tmp > 'z'))
+			temp[i] = '_';
+	}
+
+	strength = result.quality;
+
+	network = connman_device_get_network(task->device, temp);
+	if (network == NULL) {
+		const char *mode, *security;
+		unsigned char strength;
+
+		network = connman_network_create(temp,
+						CONNMAN_NETWORK_TYPE_WIFI);
+		if (network == NULL)
+			goto done;
+
+		connman_network_set_string(network, "Name", result.identifier);
+
+		connman_network_set_blob(network, "WiFi.SSID",
+						result.ssid, result.ssid_len);
 
-	g_free(network->identifier);
-	g_free(network->ssid);
-	g_free(network);
+		mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
+		connman_network_set_string(network, "WiFi.Mode", mode);
+
+		if (result.has_rsn == TRUE)
+			security = "wpa2";
+		else if (result.has_wpa == TRUE)
+			security = "wpa";
+		else if (result.has_wep == TRUE)
+			security = "wep";
+		else
+			security = "none";
+		connman_network_set_string(network, "WiFi.Security", security);
+
+		DBG("%s (%s %s) strength %d", result.identifier, mode,
+							security, strength);
+
+		if (connman_device_add_network(task->device, network) < 0) {
+			connman_network_unref(network);
+			goto done;
+		}
+	}
+
+	connman_network_set_uint8(network, "Strength", strength);
 
 done:
+	g_free(result.identifier);
+	g_free(result.ssid);
+	g_free(temp);
+
 	dbus_message_unref(reply);
+
+	get_properties(task);
 }
 
-static int get_network_properties(struct supplicant_task *task,
-							const char *path)
+static int get_properties(struct supplicant_task *task)
 {
 	DBusMessage *message;
 	DBusPendingCall *call;
+	char *path;
+
+	path = g_slist_nth_data(task->scan_results, 0);
+	if (path == NULL) {
+		connman_device_set_scanning(task->device, FALSE);
+		return 0;
+	}
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, path,
 						SUPPLICANT_INTF ".BSSID",
 								"properties");
+
+	task->scan_results = g_slist_remove(task->scan_results, path);
+	g_free(path);
+
 	if (message == NULL)
 		return -ENOMEM;
 
@@ -869,6 +936,10 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 	DBG("task %p", task);
 
 	reply = dbus_pending_call_steal_reply(call);
+	if (reply == NULL) {
+		connman_device_set_scanning(task->device, FALSE);
+		return;
+	}
 
 	dbus_error_init(&error);
 
@@ -881,16 +952,22 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 			dbus_error_free(&error);
 		} else
 			connman_error("Wrong arguments for scan result");
+		connman_device_set_scanning(task->device, FALSE);
 		goto done;
 	}
 
-	process_clear_results(task->device);
+	for (i = 0; i < num_results; i++) {
+		char *path = g_strdup(results[i]);
+		if (path == NULL)
+			continue;
 
-	for (i = 0; i < num_results; i++)
-		get_network_properties(task, results[i]);
+		task->scan_results = g_slist_append(task->scan_results, path);
+	}
 
 	g_strfreev(results);
 
+	get_properties(task);
+
 done:
 	dbus_message_unref(reply);
 }
@@ -915,6 +992,8 @@ static int scan_results_available(struct supplicant_task *task)
 		return -EIO;
 	}
 
+	connman_device_set_scanning(task->device, TRUE);
+
 	dbus_pending_call_set_notify(call, scan_results_reply, task, NULL);
 
 	dbus_message_unref(message);
@@ -959,7 +1038,8 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
 		task->state = STATE_DISCONNECTED;
 
-	process_state_change(task->device, task->state);
+	if (task->state == STATE_SCANNING)
+		connman_device_set_scanning(task->device, TRUE);
 
 	switch (task->state) {
 	case STATE_COMPLETED:
@@ -1140,6 +1220,8 @@ static void supplicant_activate(DBusConnection *conn)
 	dbus_message_unref(message);
 }
 
+static GSList *driver_list = NULL;
+
 static void supplicant_probe(DBusConnection *conn, void *user_data)
 {
 	GSList *list;
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index 4dc6d7f7..ca65f699 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -22,46 +22,10 @@
 #include <connman/device.h>
 #include <connman/element.h>
 
-#define SUPPLICANT_NAME  "fi.epitest.hostap.WPASupplicant"
-#define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
-#define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
-
-enum supplicant_state {
-	STATE_INACTIVE,
-	STATE_SCANNING,
-	STATE_ASSOCIATING,
-	STATE_ASSOCIATED,
-	STATE_4WAY_HANDSHAKE,
-	STATE_GROUP_HANDSHAKE,
-	STATE_COMPLETED,
-	STATE_DISCONNECTED,
-};
-
-struct supplicant_network {
-	gchar *identifier;
-	guint8 *ssid;
-	guint ssid_len;
-	guint16 capabilities;
-	gboolean adhoc;
-	gboolean has_wep;
-	gboolean has_wpa;
-	gboolean has_rsn;
-	gint32 quality;
-	gint32 noise;
-	gint32 level;
-	gint32 maxrate;
-};
-
 struct supplicant_driver {
 	const char *name;
 	void (*probe) (void);
 	void (*remove) (void);
-
-	void (*state_change) (struct connman_device *device,
-						enum supplicant_state state);
-	void (*clear_results) (struct connman_device *device);
-	void (*scan_result) (struct connman_device *device,
-					struct supplicant_network *network);
 };
 
 int supplicant_register(struct supplicant_driver *driver);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 0ae1014f..f44cdd8c 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -23,20 +23,11 @@
 #include <config.h>
 #endif
 
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <linux/if_arp.h>
-#include <linux/wireless.h>
-
 #include <dbus/dbus.h>
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/device.h>
-#include <connman/driver.h>
 #include <connman/log.h>
 
 #include "inet.h"
@@ -46,357 +37,29 @@
 #define INACTIVE_TIMEOUT  12	/* in seconds */
 
 struct wifi_data {
-	GSList *current;
-	GSList *pending;
-	guint cleanup_timer;
-	guint inactive_timer;
-	gchar *identifier;
-	gboolean connected;
+	char *identifier;
+	connman_bool_t connected;
 };
 
-static int network_probe(struct connman_element *element)
+static int network_probe(struct connman_network *network)
 {
-	DBG("element %p name %s", element, element->name);
+	DBG("network %p", network);
 
 	return 0;
 }
 
-static void network_remove(struct connman_element *element)
+static void network_remove(struct connman_network *network)
 {
-	DBG("element %p name %s", element, element->name);
+	DBG("network %p", network);
 }
 
-static int network_enable(struct connman_element *element)
-{
-	struct connman_device *device = (struct connman_device *) element->parent;
-	char *name, *security = NULL, *passphrase = NULL;
-	unsigned char *ssid;
-	int ssid_len;
-
-	DBG("element %p name %s", element, element->name);
-
-	if (connman_element_get_static_property(element,
-						"Name", &name) == FALSE)
-		return -EIO;
-
-	if (connman_element_get_static_array_property(element,
-				"WiFi.SSID", &ssid, &ssid_len) == FALSE)
-		return -EIO;
-
-	if (device != NULL) {
-		struct wifi_data *data = connman_device_get_data(device);
-
-		if (data != NULL) {
-			if (data->connected == TRUE)
-				return -EBUSY;
-
-			g_free(data->identifier);
-			data->identifier = g_strdup(name);
-		}
-	}
-
-	connman_element_get_value(element,
-			CONNMAN_PROPERTY_ID_WIFI_SECURITY, &security);
-
-	connman_element_get_value(element,
-			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &passphrase);
-
-	DBG("name %s security %s passhprase %s",
-					name, security, passphrase);
-
-	if (__supplicant_connect(element, ssid, ssid_len,
-						security, passphrase) < 0)
-		connman_error("Failed to initiate connect");
-
-	return 0;
-}
-
-static int network_disable(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-
-	connman_element_unregister_children(element);
-
-	__supplicant_disconnect(element);
-
-	return 0;
-}
-
-static struct connman_driver network_driver = {
-	.name		= "wifi-network",
-	.type		= CONNMAN_ELEMENT_TYPE_NETWORK,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_WIFI,
+static struct connman_network_driver network_driver = {
+	.name		= "wifi",
+	.type		= CONNMAN_NETWORK_TYPE_WIFI,
 	.probe		= network_probe,
 	.remove		= network_remove,
-	.enable		= network_enable,
-	.disable	= network_disable,
 };
 
-static struct connman_element *find_current_element(struct wifi_data *data,
-							const char *identifier)
-{
-	GSList *list;
-
-	for (list = data->current; list; list = list->next) {
-		struct connman_element *element = list->data;
-
-		if (connman_element_match_static_property(element,
-						"Name", &identifier) == TRUE)
-			return element;
-	}
-
-	return NULL;
-}
-
-static struct connman_element *find_pending_element(struct wifi_data *data,
-							const char *identifier)
-{
-	GSList *list;
-
-	for (list = data->pending; list; list = list->next) {
-		struct connman_element *element = list->data;
-
-		if (connman_element_match_static_property(element,
-						"Name", &identifier) == TRUE)
-			return element;
-	}
-
-	return NULL;
-}
-
-static gboolean inactive_scan(gpointer user_data)
-{
-	struct connman_device *device = user_data;
-	struct wifi_data *data = connman_device_get_data(device);
-
-	DBG("device %p", device);
-
-	supplicant_scan(device);
-
-	data->inactive_timer = 0;
-
-	return FALSE;
-}
-
-static void connect_known_networks(struct connman_device *device)
-{
-	struct wifi_data *data = connman_device_get_data(device);
-	GSList *list;
-
-	DBG("device %p", device);
-
-	if (data->inactive_timer > 0) {
-		g_source_remove(data->inactive_timer);
-		data->inactive_timer = 0;
-	}
-
-	for (list = data->current; list; list = list->next) {
-		struct connman_element *element = list->data;
-
-		if (element->policy == CONNMAN_ELEMENT_POLICY_AUTO &&
-						element->remember == TRUE &&
-						element->available == TRUE) {
-			if (network_enable(element) == 0)
-				return;
-		}
-	}
-
-	data->inactive_timer = g_timeout_add_seconds(INACTIVE_TIMEOUT,
-							inactive_scan, device);
-}
-
-static void state_change(struct connman_device *device,
-						enum supplicant_state state)
-{
-	struct wifi_data *data = connman_device_get_data(device);
-	struct connman_element *element;
-
-	DBG("device %p state %d", device, state);
-
-	if (state == STATE_SCANNING)
-		connman_device_set_scanning(device, TRUE);
-	else
-		connman_device_set_scanning(device, FALSE);
-
-	if (data == NULL)
-		return;
-
-	DBG("identifier %s", data->identifier);
-
-	if (data->identifier == NULL)
-		goto reconnect;
-
-	element = find_current_element(data, data->identifier);
-	if (element == NULL)
-		goto reconnect;
-
-	if (state == STATE_COMPLETED && data->connected == FALSE) {
-		struct connman_element *dhcp;
-
-		data->connected = TRUE;
-		connman_element_set_enabled(element, TRUE);
-
-		dhcp = connman_element_create(NULL);
-
-		dhcp->type = CONNMAN_ELEMENT_TYPE_DHCP;
-		dhcp->index = element->index;
-
-		if (connman_element_register(dhcp, element) < 0)
-			connman_element_unref(dhcp);
-	} else if (state == STATE_INACTIVE || state == STATE_DISCONNECTED) {
-		data->connected = FALSE;
-		connman_element_set_enabled(element, FALSE);
-
-		connman_element_unregister_children(element);
-	}
-
-reconnect:
-	if (state == STATE_INACTIVE) {
-		data->connected = FALSE;
-		connect_known_networks(device);
-	}
-}
-
-static gboolean cleanup_pending(gpointer user_data)
-{
-	struct wifi_data *data = user_data;
-	GSList *list;
-
-	DBG("");
-
-	for (list = data->pending; list; list = list->next) {
-		struct connman_element *element = list->data;
-
-		DBG("element %p name %s", element, element->name);
-
-		connman_element_unregister(element);
-		connman_element_unref(element);
-	}
-
-	g_slist_free(data->pending);
-	data->pending = NULL;
-
-	data->cleanup_timer = 0;
-
-	return FALSE;
-}
-
-static void clear_results(struct connman_device *device)
-{
-	struct wifi_data *data = connman_device_get_data(device);
-
-	DBG("pending %d", g_slist_length(data->pending));
-	DBG("current %d", g_slist_length(data->current));
-
-	if (data->cleanup_timer > 0) {
-		g_source_remove(data->cleanup_timer);
-		cleanup_pending(data);
-	}
-
-	data->pending = data->current;
-	data->current = NULL;
-
-	data->cleanup_timer = g_timeout_add_seconds(CLEANUP_TIMEOUT,
-							cleanup_pending, data);
-}
-
-static void scan_result(struct connman_device *device,
-					struct supplicant_network *network)
-{
-	struct wifi_data *data = connman_device_get_data(device);
-	struct connman_element *element;
-	gchar *temp;
-	unsigned int i;
-
-	DBG("device %p identifier %s", device, network->identifier);
-
-	if (data == NULL)
-		return;
-
-	if (network->identifier == NULL)
-		return;
-
-	if (network->identifier[0] == '\0')
-		return;
-
-	temp = g_strdup(network->identifier);
-
-	for (i = 0; i < strlen(temp); i++) {
-		char tmp = temp[i];
-		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
-						(tmp < 'a' || tmp > 'z'))
-			temp[i] = '_';
-	}
-
-	element = find_pending_element(data, network->identifier);
-	if (element == NULL) {
-		const char *mode;
-
-		element = connman_element_create(temp);
-
-		element->type    = CONNMAN_ELEMENT_TYPE_NETWORK;
-		element->subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
-		element->index   = connman_device_get_index(device);
-
-		connman_element_add_static_property(element, "Name",
-				DBUS_TYPE_STRING, &network->identifier);
-
-		connman_element_add_static_array_property(element, "WiFi.SSID",
-			DBUS_TYPE_BYTE, &network->ssid, network->ssid_len);
-
-		mode = (network->adhoc == TRUE) ? "adhoc" : "managed";
-		connman_element_add_static_property(element, "WiFi.Mode",
-						DBUS_TYPE_STRING, &mode);
-
-		if (element->wifi.security == NULL) {
-			const char *security;
-
-			if (network->has_rsn == TRUE)
-				security = "wpa2";
-			else if (network->has_wpa == TRUE)
-				security = "wpa";
-			else if (network->has_wep == TRUE)
-				security = "wep";
-			else
-				security = "none";
-
-			element->wifi.security = g_strdup(security);
-		}
-
-		element->strength = network->quality;
-
-		connman_element_add_static_property(element, "Strength",
-					DBUS_TYPE_BYTE, &element->strength);
-
-		DBG("%s (%s %s) strength %d", network->identifier, mode,
-				element->wifi.security, element->strength);
-
-		if (connman_element_register(element,
-				(struct connman_element *) device) < 0) {
-			connman_element_unref(element);
-			goto done;
-		}
-	} else {
-		data->pending = g_slist_remove(data->pending, element);
-
-		if (element->strength != network->quality) {
-			element->strength = network->quality;
-
-			connman_element_set_static_property(element, "Strength",
-					DBUS_TYPE_BYTE, &element->strength);
-
-			connman_element_update(element);
-		}
-	}
-
-	data->current = g_slist_append(data->current, element);
-
-	element->available = TRUE;
-
-done:
-	g_free(temp);
-}
-
 static int wifi_probe(struct connman_device *device)
 {
 	struct wifi_data *data;
@@ -436,34 +99,13 @@ static int wifi_enable(struct connman_device *device)
 static int wifi_disable(struct connman_device *device)
 {
 	struct wifi_data *data = connman_device_get_data(device);
-	GSList *list;
 
 	DBG("device %p", device);
 
-	if (data->cleanup_timer > 0) {
-		g_source_remove(data->cleanup_timer);
-		cleanup_pending(data);
-	}
-
-	if (data->inactive_timer > 0) {
-		g_source_remove(data->inactive_timer);
-		data->inactive_timer = 0;
-	}
-
-	for (list = data->current; list; list = list->next) {
-		struct connman_element *network = list->data;
-
-		if (network->enabled == TRUE)
-			__supplicant_disconnect(network);
-
-		connman_element_unref(network);
-	}
-
-	g_slist_free(data->current);
-	data->current = NULL;
-
 	connman_element_unregister_children((struct connman_element *) device);
 
+	data->connected = FALSE;
+
 	return supplicant_stop(device);
 }
 
@@ -503,23 +145,19 @@ static struct supplicant_driver supplicant = {
 	.name		= "wifi",
 	.probe		= wifi_register,
 	.remove		= wifi_unregister,
-
-	.state_change	= state_change,
-	.clear_results	= clear_results,
-	.scan_result	= scan_result,
 };
 
 static int wifi_init(void)
 {
 	int err;
 
-	err = connman_driver_register(&network_driver);
+	err = connman_network_driver_register(&network_driver);
 	if (err < 0)
 		return err;
 
 	err = supplicant_register(&supplicant);
 	if (err < 0) {
-		connman_driver_unregister(&network_driver);
+		connman_network_driver_unregister(&network_driver);
 		return err;
 	}
 
@@ -530,7 +168,7 @@ static void wifi_exit(void)
 {
 	supplicant_unregister(&supplicant);
 
-	connman_driver_unregister(&network_driver);
+	connman_network_driver_unregister(&network_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE(wifi, "WiFi interface plugin", VERSION,

commit 0413d2c1ec2a7d0c80cb4657c4bed22147a3c90e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:09:51 2009 +0100

    Check for invalid devices first

diff --git a/src/device.c b/src/device.c
index 48f3f7d2..832146fb 100644
--- a/src/device.c
+++ b/src/device.c
@@ -587,7 +587,7 @@ static void remove_driver(struct connman_element *element, gpointer user_data)
 
 connman_bool_t __connman_device_has_driver(struct connman_device *device)
 {
-	if (device->driver == NULL)
+	if (device == NULL || device->driver == NULL)
 		return FALSE;
 
 	return device->registered;

commit aec3be85b3858fd70f6ed6167e730f96f443c70f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:10:27 2009 +0100

    Only return networks that are registered

diff --git a/src/connman.h b/src/connman.h
index e803ddcf..4e59e533 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -163,6 +163,8 @@ void __connman_network_cleanup(void);
 void __connman_network_set_device(struct connman_network *network,
 					struct connman_device *device);
 
+connman_bool_t __connman_network_has_driver(struct connman_network *network);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/element.c b/src/element.c
index 95157dc5..28d362ec 100644
--- a/src/element.c
+++ b/src/element.c
@@ -580,6 +580,10 @@ static gboolean append_path(GNode *node, gpointer user_data)
 			__connman_device_has_driver(element->device) == FALSE)
 		return FALSE;
 
+	if (filter->type == CONNMAN_ELEMENT_TYPE_NETWORK &&
+			__connman_network_has_driver(element->network) == FALSE)
+		return FALSE;
+
 	dbus_message_iter_append_basic(filter->iter,
 				DBUS_TYPE_OBJECT_PATH, &element->path);
 
diff --git a/src/network.c b/src/network.c
index 898bed5a..dc6b60b0 100644
--- a/src/network.c
+++ b/src/network.c
@@ -42,6 +42,8 @@ struct connman_network {
 	struct connman_network_driver *driver;
 	void *driver_data;
 
+	connman_bool_t registered;
+
 	struct connman_device *device;
 
 	struct {
@@ -201,6 +203,8 @@ static int register_interface(struct connman_element *element)
 		return -EIO;
 	}
 
+	network->registered = TRUE;
+
 	emit_networks_signal();
 
 	return 0;
@@ -208,14 +212,26 @@ static int register_interface(struct connman_element *element)
 
 static void unregister_interface(struct connman_element *element)
 {
+	struct connman_network * network = element->network;
+
 	DBG("element %p name %s", element, element->name);
 
+	network->registered = FALSE;
+
 	emit_networks_signal();
 
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);
 }
 
+connman_bool_t __connman_network_has_driver(struct connman_network *network)
+{
+	if (network == NULL || network->driver == NULL)
+		return FALSE;
+
+	return network->registered;
+}
+
 static GSList *driver_list = NULL;
 
 static gint compare_priority(gconstpointer a, gconstpointer b)

commit 5cf5986084d5c8b68ee824a463b8ef41838465b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:18:50 2009 +0100

    Use dbus_bool_t for exported variables

diff --git a/src/device.c b/src/device.c
index 832146fb..9a8f07a7 100644
--- a/src/device.c
+++ b/src/device.c
@@ -33,9 +33,9 @@ struct connman_device {
 	enum connman_device_type type;
 	enum connman_device_mode mode;
 	enum connman_device_policy policy;
-	gboolean powered;
-	gboolean carrier;
-	gboolean scanning;
+	connman_bool_t powered;
+	connman_bool_t carrier;
+	connman_bool_t scanning;
 	char *name;
 	char *node;
 	char *interface;
@@ -128,7 +128,7 @@ static enum connman_device_policy string2policy(const char *policy)
 		return CONNMAN_DEVICE_POLICY_UNKNOWN;
 }
 
-static int set_powered(struct connman_device *device, gboolean powered)
+static int set_powered(struct connman_device *device, connman_bool_t powered)
 {
 	struct connman_device_driver *driver = device->driver;
 	int err;
@@ -321,7 +321,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 		return __connman_error_permission_denied(msg);
 
 	if (g_str_equal(name, "Powered") == TRUE) {
-		gboolean powered;
+		connman_bool_t powered;
 		int err;
 
 		dbus_message_iter_get_basic(&value, &powered);

commit fb1125eea6a02095e9a8763328b540e3d8fec718
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:19:25 2009 +0100

    Add support for setting network properties

diff --git a/src/network.c b/src/network.c
index dc6b60b0..1d7cc333 100644
--- a/src/network.c
+++ b/src/network.c
@@ -34,6 +34,7 @@ struct connman_network {
 	enum connman_network_type type;
 	enum connman_network_protocol protocol;
 	connman_bool_t connected;
+	connman_bool_t remember;
 	connman_uint8_t strength;
 	char *identifier;
 	char *name;
@@ -89,6 +90,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Connected",
 				DBUS_TYPE_BOOLEAN, &network->connected);
 
+	connman_dbus_dict_append_variant(&dict, "Remember",
+				DBUS_TYPE_BOOLEAN, &network->remember);
+
 	if (network->strength > 0)
 		connman_dbus_dict_append_variant(&dict, "Strength",
 					DBUS_TYPE_BYTE, &network->strength);
@@ -118,6 +122,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 static DBusMessage *set_property(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_network *network = data;
 	DBusMessageIter iter, value;
 	const char *name;
 
@@ -133,6 +138,22 @@ static DBusMessage *set_property(DBusConnection *conn,
 	if (__connman_security_check_privileges(msg) < 0)
 		return __connman_error_permission_denied(msg);
 
+	if (g_str_equal(name, "Remember") == TRUE) {
+		connman_bool_t remember;
+
+		dbus_message_iter_get_basic(&value, &remember);
+
+		if (network->remember == remember)
+			return __connman_error_invalid_arguments(msg);
+	} else if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
+		const char *passphrase;
+
+		dbus_message_iter_get_basic(&value, &passphrase);
+
+		g_free(network->wifi.passphrase);
+		network->wifi.passphrase = g_strdup(passphrase);
+	}
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 

commit 5d5856602967fb8e1055bb5923bac117093a8214
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:21:39 2009 +0100

    Use device and network specific storage helpers

diff --git a/src/device.c b/src/device.c
index 9a8f07a7..eb52ff60 100644
--- a/src/device.c
+++ b/src/device.c
@@ -347,7 +347,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 			return __connman_error_failed(msg);
 	}
 
-	__connman_element_store(&device->element);
+	__connman_storage_save_device(device);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
diff --git a/src/network.c b/src/network.c
index 1d7cc333..c41f5f22 100644
--- a/src/network.c
+++ b/src/network.c
@@ -154,6 +154,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 		network->wifi.passphrase = g_strdup(passphrase);
 	}
 
+	__connman_storage_save_network(network);
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 

commit 8b47a6c99ab920165ff2919cbf7a2b214fb0b0c1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:23:44 2009 +0100

    Remove element specific storage functions

diff --git a/src/connman.h b/src/connman.h
index 4e59e533..e36b45d2 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -120,9 +120,6 @@ const char *__connman_element_subtype2string(enum connman_element_subtype type);
 const char *__connman_element_policy2string(enum connman_element_policy policy);
 enum connman_element_policy __connman_element_string2policy(const char *policy);
 
-int __connman_element_load(struct connman_element *element);
-int __connman_element_store(struct connman_element *element);
-
 static inline void __connman_element_lock(struct connman_element *element)
 {
 }
diff --git a/src/element.c b/src/element.c
index 28d362ec..ebe52c66 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1586,8 +1586,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	DBG("element %p path %s", element, element->path);
 
-	__connman_element_load(element);
-
 	g_node_append_data(node, element);
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
@@ -1606,8 +1604,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	emit_element_signal(connection, "ElementAdded", element);
 
-	__connman_element_store(element);
-
 	if (started == FALSE)
 		return;
 
diff --git a/src/storage.c b/src/storage.c
index 6bbe0519..d881a5cc 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -149,168 +149,3 @@ void __connman_storage_cleanup(void)
 {
 	DBG("");
 }
-
-static int do_load(GKeyFile *keyfile, struct connman_element *element)
-{
-	const gchar *value;
-
-	DBG("element %p name %s", element, element->name);
-
-	value = g_key_file_get_string(keyfile, element->path,
-						"Policy", NULL);
-	if (value != NULL)
-		element->policy = __connman_element_string2policy(value);
-
-	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
-		element->remember = g_key_file_get_boolean(keyfile,
-					element->path, "Remember", NULL);
-
-	value = g_key_file_get_string(keyfile, element->path,
-						"WiFi.Security", NULL);
-	if (value != NULL)
-		connman_element_set_property(element,
-				CONNMAN_PROPERTY_ID_WIFI_SECURITY, &value);
-
-	value = g_key_file_get_string(keyfile, element->path,
-						"WiFi.Passphrase", NULL);
-	if (value != NULL)
-		connman_element_set_property(element,
-				CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &value);
-
-	return 0;
-}
-
-int __connman_element_load(struct connman_element *element)
-{
-	GKeyFile *keyfile;
-	gchar *pathname, *data = NULL;
-	gsize length;
-
-	DBG("element %p name %s", element, element->name);
-
-	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);
-	if (pathname == NULL)
-		return -ENOMEM;
-
-	keyfile = g_key_file_new();
-
-	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE) {
-		g_free(pathname);
-		return -ENOENT;
-	}
-
-	g_free(pathname);
-
-	if (g_key_file_load_from_data(keyfile, data, length,
-							0, NULL) == FALSE) {
-		g_free(data);
-		return -EILSEQ;
-	}
-
-	g_free(data);
-
-	do_load(keyfile, element);
-
-	g_key_file_free(keyfile);
-
-	return 0;
-}
-
-static void do_update(GKeyFile *keyfile, struct connman_element *element)
-{
-	GSList *list;
-	char *value;
-	const char *str;
-
-	DBG("element %p name %s", element, element->name);
-
-	g_key_file_set_string(keyfile, element->path, "Name", element->name);
-
-	str = __connman_element_policy2string(element->policy);
-	if (str != NULL)
-		g_key_file_set_string(keyfile, element->path, "Policy", str);
-
-	//g_key_file_set_boolean(keyfile, element->path, "Enabled",
-	//						element->enabled);
-
-	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK)
-		g_key_file_set_boolean(keyfile, element->path, "Remember",
-							element->remember);
-
-	__connman_element_lock(element);
-
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
-			continue;
-
-		if (property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE)
-			continue;
-
-		if (property->type == DBUS_TYPE_STRING)
-			g_key_file_set_string(keyfile, element->path,
-					property->name, property->value);
-	}
-
-	__connman_element_unlock(element);
-
-	if (connman_element_get_value(element,
-			CONNMAN_PROPERTY_ID_WIFI_SECURITY, &value) == 0)
-		g_key_file_set_string(keyfile, element->path,
-						"WiFi.Security", value);
-
-	if (connman_element_get_value(element,
-			CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE, &value) == 0)
-		g_key_file_set_string(keyfile, element->path,
-						"WiFi.Passphrase", value);
-}
-
-int __connman_element_store(struct connman_element *element)
-{
-	GKeyFile *keyfile;
-	gchar *pathname, *data = NULL;
-	gsize length;
-
-	DBG("element %p name %s", element, element->name);
-
-	if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE &&
-				element->type != CONNMAN_ELEMENT_TYPE_NETWORK)
-		return -EINVAL;
-
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_FAKE)
-		return -EINVAL;
-
-	pathname = g_strdup_printf("%s/elements.conf", STORAGEDIR);
-	if (pathname == NULL)
-		return -ENOMEM;
-
-	keyfile = g_key_file_new();
-
-	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
-		goto update;
-
-	if (length > 0) {
-		if (g_key_file_load_from_data(keyfile, data, length,
-							0, NULL) == FALSE)
-			goto done;
-	}
-
-	g_free(data);
-
-update:
-	do_update(keyfile, element);
-
-	data = g_key_file_to_data(keyfile, &length, NULL);
-
-	g_file_set_contents(pathname, data, length, NULL);
-
-done:
-	g_free(data);
-
-	g_key_file_free(keyfile);
-
-	g_free(pathname);
-
-	return 0;
-}

commit 95bdfbfe8962c3479527285088594dd657d7a6e0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:26:37 2009 +0100

    Remove unused available variable

diff --git a/include/element.h b/include/element.h
index 1334a038..fbd28f2d 100644
--- a/include/element.h
+++ b/include/element.h
@@ -90,7 +90,6 @@ struct connman_element {
 	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
-	gboolean available;
 	gboolean remember;
 	guint16 priority;
 	guint8 strength;

commit 42ec7c7c913713e48ff9c3c641db662e3522d3a8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:44:00 2009 +0100

    Add function to get device name

diff --git a/include/device.h b/include/device.h
index 8af7d282..350890fb 100644
--- a/include/device.h
+++ b/include/device.h
@@ -70,6 +70,7 @@ extern struct connman_device *connman_device_create(const char *node,
 extern struct connman_device *connman_device_ref(struct connman_device *device);
 extern void connman_device_unref(struct connman_device *device);
 
+extern const char *connman_device_get_name(struct connman_device *device);
 extern const char *connman_device_get_path(struct connman_device *device);
 extern void connman_device_set_index(struct connman_device *device,
 								int index);
diff --git a/src/device.c b/src/device.c
index eb52ff60..98669185 100644
--- a/src/device.c
+++ b/src/device.c
@@ -748,6 +748,17 @@ void connman_device_unref(struct connman_device *device)
 	connman_element_unref(&device->element);
 }
 
+/**
+ * connman_device_get_name:
+ * @device: device structure
+ *
+ * Get unique name of device
+ */
+const char *connman_device_get_name(struct connman_device *device)
+{
+	return device->element.name;
+}
+
 /**
  * connman_device_get_path:
  * @device: device structure

commit a131c9b98d4c40fbbc08d7bf0e0cc0fe3d37beda
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:45:04 2009 +0100

    Fix memory leak in loading function

diff --git a/src/device.c b/src/device.c
index 98669185..1bc0d837 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1209,7 +1209,7 @@ static int device_load(struct connman_device *device)
 	GKeyFile *keyfile;
 	gchar *pathname, *data = NULL;
 	gsize length;
-	const char *str;
+	char *str;
 
 	DBG("device %p", device);
 
@@ -1236,8 +1236,10 @@ static int device_load(struct connman_device *device)
 	g_free(data);
 
 	str = g_key_file_get_string(keyfile, "Configuration", "Policy", NULL);
-	if (str != NULL)
+	if (str != NULL) {
 		device->policy = string2policy(str);
+		g_free(str);
+	}
 
 	g_key_file_free(keyfile);
 

commit 0cd6ba6351d71f1a6738dd4fb1acc78cbc007c79
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:46:08 2009 +0100

    Add support for storing network details

diff --git a/src/network.c b/src/network.c
index c41f5f22..95122dd0 100644
--- a/src/network.c
+++ b/src/network.c
@@ -712,15 +712,107 @@ static struct connman_driver network_driver = {
 
 static int network_load(struct connman_network *network)
 {
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+	const char *name;
+
 	DBG("network %p", network);
 
+	name = connman_device_get_name(network->device);
+	if (name == NULL)
+		return -EINVAL;
+
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR, name);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE) {
+		g_free(pathname);
+		return -ENOENT;
+	}
+
+	g_free(pathname);
+
+	if (g_key_file_load_from_data(keyfile, data, length,
+							0, NULL) == FALSE) {
+		g_free(data);
+		return -EILSEQ;
+	}
+
+	g_free(data);
+
+	network->remember = g_key_file_get_boolean(keyfile,
+					network->identifier, "Remember", NULL);
+
+	g_free(network->wifi.security);
+	network->wifi.security = g_key_file_get_string(keyfile,
+				network->identifier, "WiFi.Security", NULL);
+
+	g_free(network->wifi.passphrase);
+	network->wifi.passphrase = g_key_file_get_string(keyfile,
+				network->identifier, "WiFi.Passphrase", NULL);
+
+	g_key_file_free(keyfile);
+
 	return 0;
 }
 
 static int network_save(struct connman_network *network)
 {
+	GKeyFile *keyfile;
+	gchar *pathname, *data = NULL;
+	gsize length;
+	const char *name;
+
 	DBG("network %p", network);
 
+	name = connman_device_get_name(network->device);
+	if (name == NULL)
+		return -EINVAL;
+
+	pathname = g_strdup_printf("%s/%s.conf", STORAGEDIR, name);
+	if (pathname == NULL)
+		return -ENOMEM;
+
+	keyfile = g_key_file_new();
+
+	if (g_file_get_contents(pathname, &data, &length, NULL) == FALSE)
+		goto update;
+
+	if (length > 0) {
+		if (g_key_file_load_from_data(keyfile, data, length,
+							0, NULL) == FALSE)
+			goto done;
+	}
+
+	g_free(data);
+
+update:
+	g_key_file_set_boolean(keyfile, network->identifier,
+					"Remember", network->remember);
+
+	if (network->wifi.security != NULL)
+		g_key_file_set_string(keyfile, network->identifier,
+				"WiFi.Security", network->wifi.security);
+
+	if (network->wifi.passphrase != NULL)
+		g_key_file_set_string(keyfile, network->identifier,
+				"WiFi.Passphrase", network->wifi.passphrase);
+
+	data = g_key_file_to_data(keyfile, &length, NULL);
+
+	g_file_set_contents(pathname, data, length, NULL);
+
+done:
+	g_free(data);
+
+	g_key_file_free(keyfile);
+
+	g_free(pathname);
+
 	return 0;
 }
 

commit 2959459da0a3bc085abf1ec2a523b4e444a580a3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 02:48:43 2009 +0100

    Detect changes in WiFi security setting

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 5672f379..159288b6 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -756,7 +756,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	struct connman_network *network;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	char *temp = NULL;
+	char *security, *temp = NULL;
 	unsigned char strength;
 	unsigned int i;
 
@@ -840,6 +840,15 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 	strength = result.quality;
 
+	if (result.has_rsn == TRUE)
+		security = "wpa2";
+	else if (result.has_wpa == TRUE)
+		security = "wpa";
+	else if (result.has_wep == TRUE)
+		security = "wep";
+	else
+		security = "none";
+
 	network = connman_device_get_network(task->device, temp);
 	if (network == NULL) {
 		const char *mode, *security;
@@ -858,16 +867,6 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
 		connman_network_set_string(network, "WiFi.Mode", mode);
 
-		if (result.has_rsn == TRUE)
-			security = "wpa2";
-		else if (result.has_wpa == TRUE)
-			security = "wpa";
-		else if (result.has_wep == TRUE)
-			security = "wep";
-		else
-			security = "none";
-		connman_network_set_string(network, "WiFi.Security", security);
-
 		DBG("%s (%s %s) strength %d", result.identifier, mode,
 							security, strength);
 
@@ -879,6 +878,8 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 	connman_network_set_uint8(network, "Strength", strength);
 
+	connman_network_set_string(network, "WiFi.Security", security);
+
 done:
 	g_free(result.identifier);
 	g_free(result.ssid);

commit ea1f8757bccdd6c52a9a3000849e1c79e4cb5a9a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 03:16:54 2009 +0100

    Add function to retrieve blob from network

diff --git a/include/network.h b/include/network.h
index 14e9d871..796c4f84 100644
--- a/include/network.h
+++ b/include/network.h
@@ -78,6 +78,8 @@ extern int connman_network_set_uint8(struct connman_network *network,
 					const char *key, connman_uint8_t value);
 extern int connman_network_set_blob(struct connman_network *network,
 			const char *key, const void *data, unsigned int size);
+extern const void *connman_network_get_blob(struct connman_network *network,
+					const char *key, unsigned int *size);
 
 extern struct connman_device *connman_network_get_device(struct connman_network *network);
 
diff --git a/src/network.c b/src/network.c
index 95122dd0..290f5883 100644
--- a/src/network.c
+++ b/src/network.c
@@ -596,6 +596,26 @@ int connman_network_set_blob(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_get_blob:
+ * @network: network structure
+ * @key: unique identifier
+ * @size: pointer to blob size
+ *
+ * Get binary blob value for specific key
+ */
+const void *connman_network_get_blob(struct connman_network *network,
+					const char *key, unsigned int *size)
+{
+	if (g_str_equal(key, "WiFi.SSID") == TRUE) {
+		if (size != NULL)
+			*size = network->wifi.ssid_len;
+		return network->wifi.ssid;
+	}
+
+	return NULL;
+}
+
 void __connman_network_set_device(struct connman_network *network,
 					struct connman_device *device)
 {

commit 474f7506381da61fd69cd3446951a2bb4bbafeae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 03:17:37 2009 +0100

    Add support for connecting WiFi networks

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 159288b6..959f61ec 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -23,6 +23,7 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
@@ -1162,15 +1163,24 @@ int supplicant_scan(struct connman_device *device)
 	return 0;
 }
 
-int __supplicant_connect(struct connman_element *element,
-				const unsigned char *ssid, int ssid_len,
-				const char *security, const char *passphrase)
+int supplicant_connect(struct connman_network *network)
 {
 	struct supplicant_task *task;
+	const char *security, *passphrase;
+	const void *ssid;
+	unsigned int ssid_len;
+	int index;
+
+	DBG("network %p", network);
+
+	security = connman_network_get_string(network, "WiFi.Security");
+	passphrase = connman_network_get_string(network, "WiFi.Passphrase");
 
-	DBG("element %p", element);
+	ssid = connman_network_get_blob(network, "WiFi.SSID", &ssid_len);
 
-	task = find_task_by_index(element->index);
+	index = connman_network_get_index(network);
+
+	task = find_task_by_index(index);
 	if (task == NULL)
 		return -ENODEV;
 
@@ -1186,13 +1196,16 @@ int __supplicant_connect(struct connman_element *element,
 	return 0;
 }
 
-int __supplicant_disconnect(struct connman_element *element)
+int supplicant_disconnect(struct connman_network *network)
 {
 	struct supplicant_task *task;
+	int index;
 
-	DBG("element %p", element);
+	DBG("network %p", network);
 
-	task = find_task_by_index(element->index);
+	index = connman_network_get_index(network);
+
+	task = find_task_by_index(index);
 	if (task == NULL)
 		return -ENODEV;
 
diff --git a/plugins/supplicant.h b/plugins/supplicant.h
index ca65f699..fb49722b 100644
--- a/plugins/supplicant.h
+++ b/plugins/supplicant.h
@@ -20,7 +20,7 @@
  */
 
 #include <connman/device.h>
-#include <connman/element.h>
+#include <connman/network.h>
 
 struct supplicant_driver {
 	const char *name;
@@ -35,7 +35,5 @@ int supplicant_start(struct connman_device *device);
 int supplicant_stop(struct connman_device *device);
 int supplicant_scan(struct connman_device *device);
 
-int __supplicant_connect(struct connman_element *element,
-				const unsigned char *ssid, int ssid_len,
-				const char *security, const char *passphrase);
-int __supplicant_disconnect(struct connman_element *element);
+int supplicant_connect(struct connman_network *network);
+int supplicant_disconnect(struct connman_network *network);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index f44cdd8c..abf15a49 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -23,7 +23,10 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+
 #include <dbus/dbus.h>
+#include <glib.h>
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
@@ -53,11 +56,29 @@ static void network_remove(struct connman_network *network)
 	DBG("network %p", network);
 }
 
+static int network_connect(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return supplicant_connect(network);
+}
+
+static int network_disconnect(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	//connman_element_unregister_children((struct connman_element *) network);
+
+	return supplicant_disconnect(network);
+}
+
 static struct connman_network_driver network_driver = {
 	.name		= "wifi",
 	.type		= CONNMAN_NETWORK_TYPE_WIFI,
 	.probe		= network_probe,
 	.remove		= network_remove,
+	.connect	= network_connect,
+	.disconnect	= network_disconnect,
 };
 
 static int wifi_probe(struct connman_device *device)
@@ -102,7 +123,7 @@ static int wifi_disable(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	connman_element_unregister_children((struct connman_element *) device);
+	//connman_element_unregister_children((struct connman_element *) device);
 
 	data->connected = FALSE;
 

commit 2d8a020fb34c412753aedafefd4963522ee64d8b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 03:21:57 2009 +0100

    Remove shadowed variables

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 959f61ec..02e466de 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -852,8 +852,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 	network = connman_device_get_network(task->device, temp);
 	if (network == NULL) {
-		const char *mode, *security;
-		unsigned char strength;
+		const char *mode;
 
 		network = connman_network_create(temp,
 						CONNMAN_NETWORK_TYPE_WIFI);

commit 1b30e42e2965c23e733fcca3d24e17f071742d37
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 03:22:34 2009 +0100

    Fix coding style issue

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 02e466de..c7da15bd 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -615,7 +615,7 @@ static int set_network(struct supplicant_task *task,
 					key[i] = (unsigned char) strtol(tmp,
 								NULL, 16);
 				}
-			        connman_dbus_dict_append_array(&dict,
+				connman_dbus_dict_append_array(&dict,
 						"wep_key0", DBUS_TYPE_BYTE,
 							&key, size / 2);
 				free(key);

commit 825852128bc6ebe2f922dd7213d7eaba0437facf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 03:59:47 2009 +0100

    Add function for handling WiFi passphrases

diff --git a/src/network.c b/src/network.c
index 290f5883..62dc4220 100644
--- a/src/network.c
+++ b/src/network.c
@@ -521,6 +521,9 @@ int connman_network_set_string(struct connman_network *network,
 	} else if (g_str_equal(key, "WiFi.Security") == TRUE) {
 		g_free(network->wifi.security);
 		network->wifi.security = g_strdup(value);
+	} else if (g_str_equal(key, "WiFi.Passphrase") == TRUE) {
+		g_free(network->wifi.passphrase);
+		network->wifi.passphrase = g_strdup(value);
 	}
 
 	return 0;
@@ -536,7 +539,7 @@ int connman_network_set_string(struct connman_network *network,
 const char *connman_network_get_string(struct connman_network *network,
 							const char *key)
 {
-	DBG("network %p key %s", network);
+	DBG("network %p key %s", network, key);
 
 	if (g_str_equal(key, "Name") == TRUE)
 		return network->name;
@@ -546,6 +549,8 @@ const char *connman_network_get_string(struct connman_network *network,
 		return network->wifi.mode;
 	else if (g_str_equal(key, "WiFi.Security") == TRUE)
 		return network->wifi.security;
+	else if (g_str_equal(key, "WiFi.Passphrase") == TRUE)
+		return network->wifi.passphrase;
 
 	return NULL;
 }
@@ -607,6 +612,8 @@ int connman_network_set_blob(struct connman_network *network,
 const void *connman_network_get_blob(struct connman_network *network,
 					const char *key, unsigned int *size)
 {
+	DBG("network %p key %s", network, key);
+
 	if (g_str_equal(key, "WiFi.SSID") == TRUE) {
 		if (size != NULL)
 			*size = network->wifi.ssid_len;

commit 97b08399a975d3b9891c2a7e63199fed23ac80ae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 04:00:39 2009 +0100

    Fix WiFi connection handling

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index c7da15bd..97216166 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -75,11 +75,12 @@ struct supplicant_result {
 
 struct supplicant_task {
 	int ifindex;
-	gchar *ifname;
+	char *ifname;
 	struct connman_device *device;
-	gchar *path;
+	struct connman_network *network;
+	char *path;
+	char *netpath;
 	gboolean created;
-	gchar *network;
 	enum supplicant_state state;
 	GSList *scan_results;
 };
@@ -360,7 +361,7 @@ static int add_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
-	if (task->network != NULL)
+	if (task->netpath != NULL)
 		return -EALREADY;
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
@@ -399,7 +400,7 @@ static int add_network(struct supplicant_task *task)
 
 	DBG("path %s", path);
 
-	task->network = g_strdup(path);
+	task->netpath = g_strdup(path);
 
 	dbus_message_unref(reply);
 
@@ -413,7 +414,7 @@ static int remove_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
-	if (task->network == NULL)
+	if (task->netpath == NULL)
 		return -EINVAL;
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
@@ -421,7 +422,7 @@ static int remove_network(struct supplicant_task *task)
 	if (message == NULL)
 		return -ENOMEM;
 
-	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->network,
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->netpath,
 							DBUS_TYPE_INVALID);
 
 	dbus_error_init(&error);
@@ -442,8 +443,8 @@ static int remove_network(struct supplicant_task *task)
 
 	dbus_message_unref(reply);
 
-	g_free(task->network);
-	task->network = NULL;
+	g_free(task->netpath);
+	task->netpath = NULL;
 
 	return 0;
 }
@@ -455,7 +456,7 @@ static int select_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
-	if (task->network == NULL)
+	if (task->netpath == NULL)
 		return -EINVAL;
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->path,
@@ -463,7 +464,7 @@ static int select_network(struct supplicant_task *task)
 	if (message == NULL)
 		return -ENOMEM;
 
-	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->network,
+	dbus_message_append_args(message, DBUS_TYPE_OBJECT_PATH, &task->netpath,
 							DBUS_TYPE_INVALID);
 
 	dbus_error_init(&error);
@@ -494,10 +495,10 @@ static int enable_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
-	if (task->network == NULL)
+	if (task->netpath == NULL)
 		return -EINVAL;
 
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->netpath,
 					SUPPLICANT_INTF ".Network", "enable");
 	if (message == NULL)
 		return -ENOMEM;
@@ -530,10 +531,10 @@ static int disable_network(struct supplicant_task *task)
 
 	DBG("task %p", task);
 
-	if (task->network == NULL)
+	if (task->netpath == NULL)
 		return -EINVAL;
 
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->netpath,
 					SUPPLICANT_INTF ".Network", "disable");
 	if (message == NULL)
 		return -ENOMEM;
@@ -569,10 +570,10 @@ static int set_network(struct supplicant_task *task,
 
 	DBG("task %p", task);
 
-	if (task->network == NULL)
+	if (task->netpath == NULL)
 		return -EINVAL;
 
-	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->network,
+	message = dbus_message_new_method_call(SUPPLICANT_NAME, task->netpath,
 					SUPPLICANT_INTF ".Network", "set");
 	if (message == NULL)
 		return -ENOMEM;
@@ -853,12 +854,19 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	network = connman_device_get_network(task->device, temp);
 	if (network == NULL) {
 		const char *mode;
+		int index;
 
 		network = connman_network_create(temp,
 						CONNMAN_NETWORK_TYPE_WIFI);
 		if (network == NULL)
 			goto done;
 
+		index = connman_device_get_index(task->device);
+		connman_network_set_index(network, index);
+
+		connman_network_set_protocol(network,
+						CONNMAN_NETWORK_PROTOCOL_IP);
+
 		connman_network_set_string(network, "Name", result.identifier);
 
 		connman_network_set_blob(network, "WiFi.SSID",
@@ -1045,9 +1053,11 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	switch (task->state) {
 	case STATE_COMPLETED:
 		/* carrier on */
+		connman_network_set_connected(task->network, TRUE);
 		break;
 	case STATE_DISCONNECTED:
 		/* carrier off */
+		connman_network_set_connected(task->network, FALSE);
 		break;
 	default:
 		break;
@@ -1177,12 +1187,22 @@ int supplicant_connect(struct connman_network *network)
 
 	ssid = connman_network_get_blob(network, "WiFi.SSID", &ssid_len);
 
+	DBG("security %s passphrase %s", security, passphrase);
+
+	if (security == NULL && passphrase == NULL)
+		return -EINVAL;
+
+	if (g_str_equal(security, "none") == FALSE && passphrase == NULL)
+		return -EINVAL;
+
 	index = connman_network_get_index(network);
 
 	task = find_task_by_index(index);
 	if (task == NULL)
 		return -ENODEV;
 
+	task->network = connman_network_ref(network);
+
 	add_network(task);
 
 	select_network(task);
@@ -1212,6 +1232,8 @@ int supplicant_disconnect(struct connman_network *network)
 
 	remove_network(task);
 
+	connman_network_unref(task->network);
+
 	return 0;
 }
 

commit 71d46c63b8394c8bcf029186a7d2f43073512e92
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 04:03:14 2009 +0100

    Fix problem with wpa_supplicant disconnect

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 97216166..1cf085ff 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1050,6 +1050,9 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	if (task->state == STATE_SCANNING)
 		connman_device_set_scanning(task->device, TRUE);
 
+	if (task->network == NULL)
+		return;
+
 	switch (task->state) {
 	case STATE_COMPLETED:
 		/* carrier on */

commit c795f784422e6b5ad03fe358b5ec6175826865b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 04:11:08 2009 +0100

    Check connected state and improve disconnect

diff --git a/src/network.c b/src/network.c
index 62dc4220..eed3c08d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -167,11 +167,15 @@ static DBusMessage *do_connect(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (network->connected == TRUE)
+		return __connman_error_failed(msg);
+
 	if (network->driver && network->driver->connect) {
 		err = network->driver->connect(network);
 		if (err < 0 && err != -EINPROGRESS)
 			return __connman_error_failed(msg);
-	}
+	} else
+		network->connected = TRUE;
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
@@ -184,11 +188,17 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (network->connected == FALSE)
+		return __connman_error_failed(msg);
+
+	connman_element_unregister_children(&network->element);
+
 	if (network->driver && network->driver->disconnect) {
 		err = network->driver->disconnect(network);
 		if (err < 0 && err != -EINPROGRESS)
 			return __connman_error_failed(msg);
-	}
+	} else
+		network->connected = FALSE;
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }

commit 9781e0c3e2c8284691c753eb9bf3941823fab46b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 04:11:52 2009 +0100

    Remove ununsed disconnect code

diff --git a/plugins/wifi.c b/plugins/wifi.c
index abf15a49..92e57871 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -67,8 +67,6 @@ static int network_disconnect(struct connman_network *network)
 {
 	DBG("network %p", network);
 
-	//connman_element_unregister_children((struct connman_element *) network);
-
 	return supplicant_disconnect(network);
 }
 
@@ -123,8 +121,6 @@ static int wifi_disable(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	//connman_element_unregister_children((struct connman_element *) device);
-
 	data->connected = FALSE;
 
 	return supplicant_stop(device);

commit 9b05cebe93ad885ee2a2156f6310eb7da365e581
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 04:50:18 2009 +0100

    Add support for automatic connection policy

diff --git a/src/connman.h b/src/connman.h
index e36b45d2..0b902dc3 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -150,6 +150,9 @@ static inline void __connman_udev_cleanup(void)
 int __connman_device_init(void);
 void __connman_device_cleanup(void);
 
+void __connman_device_increase_connections(struct connman_device *device);
+void __connman_device_decrease_connections(struct connman_device *device);
+
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
 #include <connman/network.h>
diff --git a/src/device.c b/src/device.c
index 1bc0d837..b4a4b0fd 100644
--- a/src/device.c
+++ b/src/device.c
@@ -39,6 +39,7 @@ struct connman_device {
 	char *name;
 	char *node;
 	char *interface;
+	unsigned int connections;
 
 	struct connman_device_driver *driver;
 	void *driver_data;
@@ -884,6 +885,15 @@ int connman_device_set_powered(struct connman_device *device,
 
 	g_dbus_send_message(connection, signal);
 
+	if (powered == FALSE)
+		return 0;
+
+	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
+		return 0;
+
+	if (device->driver->scan)
+		device->driver->scan(device);
+
 	return 0;
 }
 
@@ -932,6 +942,11 @@ int connman_device_set_carrier(struct connman_device *device,
 	return 0;
 }
 
+static void connect_known_network(struct connman_device *device)
+{
+	DBG("device %p", device);
+}
+
 /**
  * connman_device_set_scanning:
  * @device: device structure
@@ -972,6 +987,17 @@ int connman_device_set_scanning(struct connman_device *device,
 
 	g_dbus_send_message(connection, signal);
 
+	if (scanning == TRUE)
+		return 0;
+
+	if (device->connections > 0)
+		return 0;
+
+	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
+		return 0;
+
+	connect_known_network(device);
+
 	return 0;
 }
 
@@ -1019,6 +1045,16 @@ const char *connman_device_get_string(struct connman_device *device,
 	return NULL;
 }
 
+void __connman_device_increase_connections(struct connman_device *device)
+{
+	device->connections++;
+}
+
+void __connman_device_decrease_connections(struct connman_device *device)
+{
+	device->connections--;
+}
+
 /**
  * connman_device_add_network:
  * @device: device structure
diff --git a/src/network.c b/src/network.c
index eed3c08d..ae3e1e36 100644
--- a/src/network.c
+++ b/src/network.c
@@ -490,6 +490,8 @@ int connman_network_set_connected(struct connman_network *network,
 			break;
 		}
 
+		__connman_device_increase_connections(network->device);
+
 		element = connman_element_create(NULL);
 		if (element != NULL) {
 			element->type    = type;
@@ -497,12 +499,15 @@ int connman_network_set_connected(struct connman_network *network,
 			element->index   = network->element.index;
 
 			if (connman_element_register(element,
-							&network->element) < 0)
+						&network->element) < 0)
 				connman_element_unref(element);
 		}
-	} else
+	} else {
 		connman_element_unregister_children(&network->element);
 
+		__connman_device_decrease_connections(network->device);
+	}
+
 	return 0;
 }
 

commit 186b6fa635e755c824756db8e483eb6c92cb3167
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 05:37:51 2009 +0100

    Add support for connecting known networks

diff --git a/include/network.h b/include/network.h
index 796c4f84..70b7c35b 100644
--- a/include/network.h
+++ b/include/network.h
@@ -69,6 +69,9 @@ extern void connman_network_set_protocol(struct connman_network *network,
 
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
+extern connman_bool_t connman_network_get_remember(struct connman_network *network);
+
+extern int connman_network_connect(struct connman_network *network);
 
 extern int connman_network_set_string(struct connman_network *network,
 					const char *key, const char *value);
diff --git a/src/device.c b/src/device.c
index b4a4b0fd..57e370c1 100644
--- a/src/device.c
+++ b/src/device.c
@@ -944,7 +944,33 @@ int connman_device_set_carrier(struct connman_device *device,
 
 static void connect_known_network(struct connman_device *device)
 {
+	GHashTableIter iter;
+	gpointer key, value;
+	unsigned int count = 0;
+
 	DBG("device %p", device);
+
+	g_hash_table_iter_init(&iter, device->networks);
+
+	while (g_hash_table_iter_next(&iter, &key, &value) == TRUE) {
+		struct connman_network *network = value;
+		int err;
+
+		count++;
+
+		if (connman_network_get_remember(network) == FALSE)
+			continue;
+
+		err = connman_network_connect(network);
+		if (err == 0 || err == -EINPROGRESS)
+			return;
+	}
+
+	if (count > 0)
+		return;
+
+	if (device->driver && device->driver->scan)
+		device->driver->scan(device);
 }
 
 /**
diff --git a/src/network.c b/src/network.c
index ae3e1e36..6c17088e 100644
--- a/src/network.c
+++ b/src/network.c
@@ -511,6 +511,36 @@ int connman_network_set_connected(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_get_remember:
+ * @network: network structure
+ *
+ * Get network remember setting
+ */
+connman_bool_t connman_network_get_remember(struct connman_network *network)
+{
+	return network->remember;
+}
+
+/**
+ * connman_network_connect:
+ * @network: network structure
+ *
+ * Connect network
+ */
+int connman_network_connect(struct connman_network *network)
+{
+	if (network->connected == TRUE)
+		return -EALREADY;
+
+	if (network->driver && network->driver->connect)
+		return network->driver->connect(network);
+
+	network->connected = TRUE;
+
+	return 0;
+}
+
 /**
  * connman_network_set_string:
  * @network: network structure

commit 19262ea6023ca56de20d5b69950bed1146437849
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 05:38:28 2009 +0100

    Handle scanning status and connecting

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 1cf085ff..bc83be9f 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -82,6 +82,7 @@ struct supplicant_task {
 	char *netpath;
 	gboolean created;
 	enum supplicant_state state;
+	gboolean doscan;
 	GSList *scan_results;
 };
 
@@ -906,7 +907,8 @@ static int get_properties(struct supplicant_task *task)
 
 	path = g_slist_nth_data(task->scan_results, 0);
 	if (path == NULL) {
-		connman_device_set_scanning(task->device, FALSE);
+		if (task->doscan == FALSE)
+			connman_device_set_scanning(task->device, FALSE);
 		return 0;
 	}
 
@@ -946,7 +948,8 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 
 	reply = dbus_pending_call_steal_reply(call);
 	if (reply == NULL) {
-		connman_device_set_scanning(task->device, FALSE);
+		if (task->doscan == FALSE)
+			connman_device_set_scanning(task->device, FALSE);
 		return;
 	}
 
@@ -961,7 +964,8 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 			dbus_error_free(&error);
 		} else
 			connman_error("Wrong arguments for scan result");
-		connman_device_set_scanning(task->device, FALSE);
+		if (task->doscan == FALSE)
+			connman_device_set_scanning(task->device, FALSE);
 		goto done;
 	}
 
@@ -1047,8 +1051,13 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
 		task->state = STATE_DISCONNECTED;
 
-	if (task->state == STATE_SCANNING)
+	if (task->state == STATE_SCANNING) {
+		task->doscan = TRUE;
 		connman_device_set_scanning(task->device, TRUE);
+	} else if (task->state == STATE_INACTIVE) {
+		task->doscan = FALSE;
+		connman_device_set_scanning(task->device, FALSE);
+	}
 
 	if (task->network == NULL)
 		return;

commit 4f9a0637340e17790ad3c29546adc34ab6ce0362
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 17:02:46 2009 +0100

    Add skeleton for core connection driver

diff --git a/src/Makefile.am b/src/Makefile.am
index 3ea9035a..54c06d8d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -6,9 +6,9 @@ dbus_DATA = connman.conf
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
-				profile.c element.c device.c network.c \
-				security.c resolver.c storage.c manager.c \
-				agent.c detect.c rtnl.c dbus.c
+			profile.c element.c device.c network.c connection.c \
+			security.c resolver.c storage.c manager.c agent.c \
+			detect.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/connection.c b/src/connection.c
new file mode 100644
index 00000000..78080a44
--- /dev/null
+++ b/src/connection.c
@@ -0,0 +1,66 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+static int connection_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	return 0;
+}
+
+static void connection_remove(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+}
+
+static struct connman_driver connection_driver = {
+	.name		= "connection",
+	.type		= CONNMAN_ELEMENT_TYPE_CONNECTION,
+	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
+	.probe		= connection_probe,
+	.remove		= connection_remove,
+};
+
+static DBusConnection *connection;
+
+int __connman_connection_init(void)
+{
+	DBG("");
+
+	connection = connman_dbus_get_connection();
+
+	return connman_driver_register(&connection_driver);
+}
+
+void __connman_connection_cleanup(void)
+{
+	DBG("");
+
+	connman_driver_unregister(&connection_driver);
+
+	dbus_connection_unref(connection);
+}
diff --git a/src/connman.h b/src/connman.h
index 0b902dc3..b97d835b 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -131,6 +131,9 @@ static inline void __connman_element_unlock(struct connman_element *element)
 int __connman_detect_init(void);
 void __connman_detect_cleanup(void);
 
+int __connman_connection_init(void);
+void __connman_connection_cleanup(void);
+
 #ifdef HAVE_UDEV
 int __connman_udev_init(void);
 void __connman_udev_cleanup(void);
diff --git a/src/element.c b/src/element.c
index ebe52c66..873a5f5f 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1802,6 +1802,7 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 
 	__connman_device_init();
 	__connman_network_init();
+	__connman_connection_init();
 
 	return 0;
 }
@@ -1878,6 +1879,7 @@ void __connman_element_cleanup(void)
 {
 	DBG("");
 
+	__connman_connection_cleanup();
 	__connman_network_cleanup();
 	__connman_device_cleanup();
 

commit fb0fb9058f300222717a025e6f8a0c7a030bf303
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 17:32:23 2009 +0100

    Reorder device, network and connection setup

diff --git a/src/element.c b/src/element.c
index 873a5f5f..3c072ee7 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1800,9 +1800,8 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 
 	element_root = g_node_new(element);
 
-	__connman_device_init();
 	__connman_network_init();
-	__connman_connection_init();
+	__connman_device_init();
 
 	return 0;
 }
@@ -1833,6 +1832,7 @@ void __connman_element_start(void)
 
 	started = TRUE;
 
+	__connman_connection_init();
 	__connman_detect_init();
 }
 
@@ -1841,6 +1841,7 @@ void __connman_element_stop(void)
 	DBG("");
 
 	__connman_detect_cleanup();
+	__connman_connection_cleanup();
 }
 
 static gboolean free_driver(GNode *node, gpointer data)
@@ -1879,9 +1880,8 @@ void __connman_element_cleanup(void)
 {
 	DBG("");
 
-	__connman_connection_cleanup();
-	__connman_network_cleanup();
 	__connman_device_cleanup();
+	__connman_network_cleanup();
 
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_driver, NULL);

commit f48005d81c0983c77740c16abde90e02d9505304
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 17:34:02 2009 +0100

    Register connection interface

diff --git a/src/connection.c b/src/connection.c
index 78080a44..6c7e03b8 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -23,18 +23,111 @@
 #include <config.h>
 #endif
 
+#include <gdbus.h>
+
 #include "connman.h"
 
-static int connection_probe(struct connman_element *element)
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessageIter iter, value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static GDBusMethodTable connection_methods[] = {
+	{ "GetProperties", "",   "a{sv}", get_properties },
+	{ "SetProperty",   "sv", "",      set_property   },
+	{ },
+};
+
+static GDBusSignalTable connection_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
+static DBusConnection *connection;
+
+static void emit_connections_signal(void)
+{
+}
+
+static int register_interface(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
 
+	if (g_dbus_register_interface(connection, element->path,
+					CONNMAN_CONNECTION_INTERFACE,
+					connection_methods, connection_signals,
+					NULL, element, NULL) == FALSE) {
+		connman_error("Failed to register %s connection", element->path);
+		return -EIO;
+	}
+
+	emit_connections_signal();
+
 	return 0;
 }
 
+static void unregister_interface(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	emit_connections_signal();
+
+	g_dbus_unregister_interface(connection, element->path,
+						CONNMAN_CONNECTION_INTERFACE);
+}
+
+static int connection_probe(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	return register_interface(element);
+}
+
 static void connection_remove(struct connman_element *element)
 {
 	DBG("element %p name %s", element, element->name);
+
+	unregister_interface(element);
 }
 
 static struct connman_driver connection_driver = {
@@ -45,8 +138,6 @@ static struct connman_driver connection_driver = {
 	.remove		= connection_remove,
 };
 
-static DBusConnection *connection;
-
 int __connman_connection_init(void)
 {
 	DBG("");

commit d68748fc6f4e5b87f88b73519e353d4c2f21f4ba
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 17:50:04 2009 +0100

    Remove gateway setup into the core connection handling

diff --git a/plugins/ipv4.c b/plugins/ipv4.c
index b611fb04..c73c729c 100644
--- a/plugins/ipv4.c
+++ b/plugins/ipv4.c
@@ -30,10 +30,6 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <net/if.h>
-#include <net/route.h>
-
-#include <linux/netlink.h>
-#include <linux/rtnetlink.h>
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
@@ -58,34 +54,6 @@ struct connman_ipv4 {
 	struct in_addr broadcast;
 };
 
-struct gateway_data {
-	int index;
-	char *gateway;
-};
-
-static GSList *gateway_list = NULL;
-
-static struct gateway_data *find_gateway(int index, const char *gateway)
-{
-	GSList *list;
-
-	if (gateway == NULL)
-		return NULL;
-
-	for (list = gateway_list; list; list = list->next) {
-		struct gateway_data *data = list->data;
-
-		if (data->gateway == NULL)
-			continue;
-
-		if (data->index == index &&
-				g_str_equal(data->gateway, gateway) == TRUE)
-			return data;
-	}
-
-	return NULL;
-}
-
 static int set_ipv4(struct connman_element *element,
 			struct connman_ipv4 *ipv4, const char *nameserver)
 {
@@ -184,184 +152,6 @@ static int clear_ipv4(struct connman_element *element)
 	return 0;
 }
 
-static int set_route(struct connman_element *element, const char *gateway)
-{
-	struct ifreq ifr;
-	struct rtentry rt;
-	struct sockaddr_in *addr;
-	int sk, err;
-
-	DBG("element %p", element);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = element->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		close(sk);
-		return -1;
-	}
-
-	DBG("ifname %s", ifr.ifr_name);
-
-	memset(&rt, 0, sizeof(rt));
-	rt.rt_flags = RTF_UP | RTF_GATEWAY;
-
-	addr = (struct sockaddr_in *) &rt.rt_dst;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	addr = (struct sockaddr_in *) &rt.rt_gateway;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = inet_addr(gateway);
-
-	addr = (struct sockaddr_in *) &rt.rt_genmask;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	err = ioctl(sk, SIOCADDRT, &rt);
-	if (err < 0)
-		DBG("default route setting failed (%s)", strerror(errno));
-
-	close(sk);
-
-	return err;
-}
-
-static int del_route(struct connman_element *element, const char *gateway)
-{
-	struct ifreq ifr;
-	struct rtentry rt;
-	struct sockaddr_in *addr;
-	int sk, err;
-
-	DBG("element %p", element);
-
-	sk = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sk < 0)
-		return -1;
-
-	memset(&ifr, 0, sizeof(ifr));
-	ifr.ifr_ifindex = element->index;
-
-	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
-		close(sk);
-		return -1;
-	}
-
-	DBG("ifname %s", ifr.ifr_name);
-
-	memset(&rt, 0, sizeof(rt));
-	rt.rt_flags = RTF_UP | RTF_GATEWAY;
-
-	addr = (struct sockaddr_in *) &rt.rt_dst;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	addr = (struct sockaddr_in *) &rt.rt_gateway;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = inet_addr(gateway);
-
-	addr = (struct sockaddr_in *) &rt.rt_genmask;
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = INADDR_ANY;
-
-	err = ioctl(sk, SIOCDELRT, &rt);
-	if (err < 0)
-		DBG("default route removal failed (%s)", strerror(errno));
-
-	close(sk);
-
-	return err;
-}
-
-static int conn_probe(struct connman_element *element)
-{
-	const char *gateway = NULL;
-
-	DBG("element %p name %s", element, element->name);
-
-	if (element->parent == NULL)
-		return -ENODEV;
-
-	if (element->parent->type != CONNMAN_ELEMENT_TYPE_IPV4)
-		return -ENODEV;
-
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
-
-	DBG("gateway %s", gateway);
-
-	if (gateway == NULL)
-		return 0;
-
-	if (g_slist_length(gateway_list) > 0) {
-		DBG("default already present");
-		return 0;
-	}
-
-	set_route(element, gateway);
-
-	connman_element_set_enabled(element, TRUE);
-
-	return 0;
-}
-
-static void conn_remove(struct connman_element *element)
-{
-	DBG("element %p name %s", element, element->name);
-}
-
-static int conn_enable(struct connman_element *element)
-{
-	const char *gateway = NULL;
-
-	DBG("element %p name %s", element, element->name);
-
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
-
-	DBG("gateway %s", gateway);
-
-	if (gateway == NULL)
-		return -EINVAL;
-
-	set_route(element, gateway);
-
-	return 0;
-}
-
-static int conn_disable(struct connman_element *element)
-{
-	const char *gateway = NULL;
-
-	DBG("element %p name %s", element, element->name);
-
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
-
-	DBG("gateway %s", gateway);
-
-	if (gateway == NULL)
-		return -EINVAL;
-
-	del_route(element, gateway);
-
-	return 0;
-}
-
-static struct connman_driver conn_driver = {
-	.name		= "ipv4-connection",
-	.type		= CONNMAN_ELEMENT_TYPE_CONNECTION,
-	.probe		= conn_probe,
-	.remove		= conn_remove,
-	.enable		= conn_enable,
-	.disable	= conn_disable,
-};
-
 static int ipv4_probe(struct connman_element *element)
 {
 	struct connman_element *connection;
@@ -415,100 +205,20 @@ static void ipv4_remove(struct connman_element *element)
 }
 
 static struct connman_driver ipv4_driver = {
-	.name		= "ipv4-address",
+	.name		= "ipv4",
 	.type		= CONNMAN_ELEMENT_TYPE_IPV4,
 	.probe		= ipv4_probe,
 	.remove		= ipv4_remove,
 };
 
-static void ipv4_newgateway(int index, const char *gateway)
-{
-	struct gateway_data *data;
-
-	DBG("index %d gateway %s", index, gateway);
-
-	data = find_gateway(index, gateway);
-	if (data != NULL)
-		return;
-
-	data = g_try_new0(struct gateway_data, 1);
-	if (data == NULL)
-		return;
-
-	data->index = index;
-	data->gateway = g_strdup(gateway);
-
-	gateway_list = g_slist_append(gateway_list, data);
-}
-
-static void ipv4_delgateway(int index, const char *gateway)
-{
-	struct gateway_data *data;
-
-	DBG("index %d gateway %s", index, gateway);
-
-	data = find_gateway(index, gateway);
-	if (data == NULL)
-		return;
-
-	gateway_list = g_slist_remove(gateway_list, data);
-
-	g_free(data->gateway);
-	g_free(data);
-}
-
-static struct connman_rtnl ipv4_rtnl = {
-	.name		= "ipv4-rtnl",
-	.newgateway	= ipv4_newgateway,
-	.delgateway	= ipv4_delgateway,
-};
-
 static int ipv4_init(void)
 {
-	int err;
-
-	err = connman_rtnl_register(&ipv4_rtnl);
-	if (err < 0)
-		return err;
-
-	connman_rtnl_send_getroute();
-
-	err = connman_driver_register(&conn_driver);
-	if (err < 0) {
-		connman_rtnl_unregister(&ipv4_rtnl);
-		return err;
-	}
-
-	err = connman_driver_register(&ipv4_driver);
-	if (err < 0) {
-		connman_driver_unregister(&conn_driver);
-		connman_rtnl_unregister(&ipv4_rtnl);
-	}
-
-	return err;
+	return connman_driver_register(&ipv4_driver);
 }
 
 static void ipv4_exit(void)
 {
-	GSList *list;
-
-	connman_driver_unregister(&conn_driver);
 	connman_driver_unregister(&ipv4_driver);
-
-	connman_rtnl_unregister(&ipv4_rtnl);
-
-	for (list = gateway_list; list; list = list->next) {
-		struct gateway_data *data = list->data;
-
-		DBG("index %d gateway %s", data->index, data->gateway);
-
-		g_free(data->gateway);
-		g_free(data);
-		list->data = NULL;
-	}
-
-	g_slist_free(gateway_list);
-	gateway_list = NULL;
 }
 
 CONNMAN_PLUGIN_DEFINE(ipv4, "IPv4 configuration plugin", VERSION,
diff --git a/src/connection.c b/src/connection.c
index 6c7e03b8..9cd0f64c 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -23,10 +23,182 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <net/route.h>
+
 #include <gdbus.h>
 
 #include "connman.h"
 
+struct gateway_data {
+	int index;
+	char *gateway;
+};
+
+static GSList *gateway_list = NULL;
+
+static struct gateway_data *find_gateway(int index, const char *gateway)
+{
+	GSList *list;
+
+	if (gateway == NULL)
+		return NULL;
+
+	for (list = gateway_list; list; list = list->next) {
+		struct gateway_data *data = list->data;
+
+		if (data->gateway == NULL)
+			continue;
+
+		if (data->index == index &&
+				g_str_equal(data->gateway, gateway) == TRUE)
+			return data;
+	}
+
+	return NULL;
+}
+
+static void connection_newgateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	DBG("index %d gateway %s", index, gateway);
+
+	data = find_gateway(index, gateway);
+	if (data != NULL)
+		return;
+
+	data = g_try_new0(struct gateway_data, 1);
+	if (data == NULL)
+		return;
+
+	data->index = index;
+	data->gateway = g_strdup(gateway);
+
+	gateway_list = g_slist_append(gateway_list, data);
+}
+
+static void connection_delgateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	DBG("index %d gateway %s", index, gateway);
+
+	data = find_gateway(index, gateway);
+	if (data == NULL)
+		return;
+
+	gateway_list = g_slist_remove(gateway_list, data);
+
+	g_free(data->gateway);
+	g_free(data);
+}
+
+static struct connman_rtnl connection_rtnl = {
+	.name		= "connection",
+	.newgateway	= connection_newgateway,
+	.delgateway	= connection_delgateway,
+};
+
+static int set_route(struct connman_element *element, const char *gateway)
+{
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = inet_addr(gateway);
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCADDRT, &rt);
+	if (err < 0)
+		DBG("default route setting failed (%s)", strerror(errno));
+
+	close(sk);
+
+	return err;
+}
+
+static int del_route(struct connman_element *element, const char *gateway)
+{
+	struct ifreq ifr;
+	struct rtentry rt;
+	struct sockaddr_in *addr;
+	int sk, err;
+
+	DBG("element %p", element);
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return -1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = element->index;
+
+	if (ioctl(sk, SIOCGIFNAME, &ifr) < 0) {
+		close(sk);
+		return -1;
+	}
+
+	DBG("ifname %s", ifr.ifr_name);
+
+	memset(&rt, 0, sizeof(rt));
+	rt.rt_flags = RTF_UP | RTF_GATEWAY;
+
+	addr = (struct sockaddr_in *) &rt.rt_dst;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	addr = (struct sockaddr_in *) &rt.rt_gateway;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = inet_addr(gateway);
+
+	addr = (struct sockaddr_in *) &rt.rt_genmask;
+	addr->sin_family = AF_INET;
+	addr->sin_addr.s_addr = INADDR_ANY;
+
+	err = ioctl(sk, SIOCDELRT, &rt);
+	if (err < 0)
+		DBG("default route removal failed (%s)", strerror(errno));
+
+	close(sk);
+
+	return err;
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -118,16 +290,56 @@ static void unregister_interface(struct connman_element *element)
 
 static int connection_probe(struct connman_element *element)
 {
+	const char *gateway = NULL;
+
 	DBG("element %p name %s", element, element->name);
 
-	return register_interface(element);
+	if (element->parent == NULL)
+		return -ENODEV;
+
+	if (element->parent->type != CONNMAN_ELEMENT_TYPE_IPV4)
+		return -ENODEV;
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	DBG("gateway %s", gateway);
+
+	if (register_interface(element) < 0)
+		return -ENODEV;
+
+	if (gateway == NULL)
+		return 0;
+
+	if (g_slist_length(gateway_list) > 0) {
+		DBG("default gateway already present");
+		return 0;
+	}
+
+	set_route(element, gateway);
+
+	connman_element_set_enabled(element, TRUE);
+
+	return 0;
 }
 
 static void connection_remove(struct connman_element *element)
 {
+	const char *gateway = NULL;
+
 	DBG("element %p name %s", element, element->name);
 
 	unregister_interface(element);
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	DBG("gateway %s", gateway);
+
+	if (gateway == NULL)
+		return;
+
+	del_route(element, gateway);
 }
 
 static struct connman_driver connection_driver = {
@@ -144,14 +356,36 @@ int __connman_connection_init(void)
 
 	connection = connman_dbus_get_connection();
 
+	if (connman_rtnl_register(&connection_rtnl) < 0)
+		connman_error("Failed to setup RTNL gateway driver");
+
+	connman_rtnl_send_getroute();
+
 	return connman_driver_register(&connection_driver);
 }
 
 void __connman_connection_cleanup(void)
 {
+	GSList *list;
+
 	DBG("");
 
 	connman_driver_unregister(&connection_driver);
 
+	connman_rtnl_unregister(&connection_rtnl);
+
+	for (list = gateway_list; list; list = list->next) {
+		struct gateway_data *data = list->data;
+
+		DBG("index %d gateway %s", data->index, data->gateway);
+
+		g_free(data->gateway);
+		g_free(data);
+		list->data = NULL;
+	}
+
+	g_slist_free(gateway_list);
+	gateway_list = NULL;
+
 	dbus_connection_unref(connection);
 }

commit 1524a8a44dcdd5d5d50243d31ce2c2e1aba98208
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 17:56:20 2009 +0100

    Remove connection interface from element system

diff --git a/src/element.c b/src/element.c
index 3c072ee7..44e2f973 100644
--- a/src/element.c
+++ b/src/element.c
@@ -127,6 +127,7 @@ static const char *type2string(enum connman_element_type type)
 	return NULL;
 }
 
+#if 0
 static const char *subtype2string(enum connman_element_subtype type)
 {
 	switch (type) {
@@ -148,6 +149,7 @@ static const char *subtype2string(enum connman_element_subtype type)
 
 	return NULL;
 }
+#endif
 
 const char *__connman_element_policy2string(enum connman_element_policy policy)
 {
@@ -205,6 +207,7 @@ enum connman_ipv4_method __connman_ipv4_string2method(const char *method)
 		return CONNMAN_IPV4_METHOD_UNKNOWN;
 }
 
+#if 0
 static void append_property(DBusMessageIter *dict,
 				struct connman_property *property)
 {
@@ -278,7 +281,6 @@ static void add_common_properties(struct connman_element *element,
 	__connman_element_unlock(element);
 }
 
-#if 0
 static void set_common_property(struct connman_element *element,
 				const char *name, DBusMessageIter *value)
 {
@@ -336,180 +338,6 @@ static void emit_element_signal(DBusConnection *conn, const char *member,
 	g_dbus_send_message(conn, signal);
 }
 
-static void emit_enabled_signal(DBusConnection *conn,
-					struct connman_element *element)
-{
-	DBusMessage *signal;
-	DBusMessageIter entry, value;
-	const char *iface, *key;
-
-	DBG("conn %p", conn);
-
-	if (element == NULL)
-		return;
-
-	switch (element->type) {
-	case CONNMAN_ELEMENT_TYPE_CONNECTION:
-		iface = CONNMAN_CONNECTION_INTERFACE;
-		key = "Default";
-		break;
-	default:
-		return;
-	}
-
-	signal = dbus_message_new_signal(element->path,
-						iface, "PropertyChanged");
-	if (signal == NULL)
-		return;
-
-	dbus_message_iter_init_append(signal, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
-	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN,
-							&element->enabled);
-	dbus_message_iter_close_container(&entry, &value);
-
-	g_dbus_send_message(conn, signal);
-}
-
-static DBusMessage *do_enable(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-
-	DBG("conn %p", conn);
-
-	if (element->enabled == TRUE)
-		return __connman_error_failed(msg);
-
-	if (element->driver && element->driver->enable) {
-		DBG("Calling enable callback");
-		if (element->driver->enable(element) < 0)
-			return __connman_error_failed(msg);
-	}
-
-	element->enabled = TRUE;
-
-	emit_enabled_signal(connection, element);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *do_disable(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-
-	DBG("conn %p", conn);
-
-	if (element->enabled == FALSE)
-		return __connman_error_failed(msg);
-
-	if (element->driver && element->driver->disable) {
-		DBG("Calling disable callback");
-		if (element->driver->disable(element) < 0)
-			return __connman_error_failed(msg);
-	}
-
-	element->enabled = FALSE;
-
-	emit_enabled_signal(connection, element);
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *connection_get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	const char *str;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	str = subtype2string(element->subtype);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Type",
-						DBUS_TYPE_STRING, &str);
-
-	if (element->devname != NULL)
-		connman_dbus_dict_append_variant(&dict, "Interface",
-					DBUS_TYPE_STRING, &element->devname);
-
-	if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIFI ||
-			element->subtype == CONNMAN_ELEMENT_SUBTYPE_WIMAX)
-		connman_dbus_dict_append_variant(&dict, "Strength",
-					DBUS_TYPE_BYTE, &element->strength);
-
-	connman_dbus_dict_append_variant(&dict, "Default",
-					DBUS_TYPE_BOOLEAN, &element->enabled);
-
-	add_common_properties(element, &dict);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
-static DBusMessage *connection_set_property(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_element *element = data;
-	DBusMessageIter iter, value;
-	const char *name;
-
-	DBG("conn %p", conn);
-
-	if (dbus_message_iter_init(msg, &iter) == FALSE)
-		return __connman_error_invalid_arguments(msg);
-
-	dbus_message_iter_get_basic(&iter, &name);
-	dbus_message_iter_next(&iter);
-	dbus_message_iter_recurse(&iter, &value);
-
-	if (__connman_security_check_privileges(msg) < 0)
-		return __connman_error_permission_denied(msg);
-
-	if (g_str_equal(name, "Default") == TRUE) {
-		dbus_bool_t enabled;
-
-		dbus_message_iter_get_basic(&value, &enabled);
-
-		if (enabled == TRUE)
-			return do_enable(conn, msg, element);
-		else
-			return do_disable(conn, msg, element);
-	}
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static GDBusMethodTable connection_methods[] = {
-	{ "GetProperties", "",   "a{sv}", connection_get_properties },
-	{ "SetProperty",   "sv", "",      connection_set_property   },
-	{ },
-};
-
-static GDBusSignalTable element_signals[] = {
-	{ "PropertyChanged", "sv" },
-	{ },
-};
-
 struct foreach_data {
 	enum connman_element_type type;
 	element_cb_t callback;
@@ -691,10 +519,8 @@ static void enable_element(struct connman_element *element)
 		return;
 
 	if (element->driver && element->driver->enable) {
-		if (element->driver->enable(element) == 0) {
+		if (element->driver->enable(element) == 0)
 			element->enabled = TRUE;
-			emit_enabled_signal(connection, element);
-		}
 	}
 }
 
@@ -771,10 +597,8 @@ static void disable_element(struct connman_element *element)
 		return;
 
 	if (element->driver && element->driver->disable) {
-		if (element->driver->disable(element) == 0) {
+		if (element->driver->disable(element) == 0)
 			element->enabled = FALSE;
-			emit_enabled_signal(connection, element);
-		}
 	}
 }
 
@@ -945,53 +769,6 @@ int connman_element_add_static_property(struct connman_element *element,
 	return 0;
 }
 
-static void emit_property_changed(DBusConnection *conn,
-				struct connman_element *element,
-				const char *name, int type, const void *data)
-{
-	DBusMessage *signal;
-	DBusMessageIter entry, value;
-	const char *iface, *sig;
-
-	DBG("conn %p", conn);
-
-	switch (element->type) {
-	case CONNMAN_ELEMENT_TYPE_CONNECTION:
-		iface = CONNMAN_CONNECTION_INTERFACE;
-		break;
-	default:
-		return;
-	}
-
-	signal = dbus_message_new_signal(element->path,
-						iface, "PropertyChanged");
-	if (signal == NULL)
-		return;
-
-	dbus_message_iter_init_append(signal, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &name);
-
-	switch (type) {
-	case DBUS_TYPE_STRING:
-		sig = DBUS_TYPE_STRING_AS_STRING;
-		break;
-	case DBUS_TYPE_BYTE:
-		sig = DBUS_TYPE_BYTE_AS_STRING;
-		break;
-	default:
-		sig = DBUS_TYPE_VARIANT_AS_STRING;
-		break;
-	}
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-							sig, &value);
-	dbus_message_iter_append_basic(&value, type, data);
-	dbus_message_iter_close_container(&entry, &value);
-
-	g_dbus_send_message(conn, signal);
-}
-
 int connman_element_set_static_property(struct connman_element *element,
 				const char *name, int type, const void *value)
 {
@@ -1030,8 +807,6 @@ int connman_element_set_static_property(struct connman_element *element,
 
 	__connman_element_unlock(element);
 
-	emit_property_changed(connection, element, name, type, value);
-
 	return 0;
 }
 
@@ -1589,17 +1364,9 @@ static void register_element(gpointer data, gpointer user_data)
 	g_node_append_data(node, element);
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
-		if (g_dbus_register_interface(connection, element->path,
-					CONNMAN_CONNECTION_INTERFACE,
-					connection_methods, element_signals,
-					NULL, element, NULL) == FALSE)
-			connman_error("Failed to register %s connection",
-								element->path);
-		else {
-			set_signal_strength(element);
-			emit_connections_signal(connection);
-			emit_state_change(connection, "online");
-		}
+		set_signal_strength(element);
+		emit_connections_signal(connection);
+		emit_state_change(connection, "online");
 	}
 
 	emit_element_signal(connection, "ElementAdded", element);
@@ -1691,9 +1458,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 					CONNMAN_ELEMENT_TYPE_CONNECTION) == 0)
 			emit_state_change(connection, "offline");
 		emit_connections_signal(connection);
-
-		g_dbus_unregister_interface(connection, element->path,
-						CONNMAN_CONNECTION_INTERFACE);
 	}
 
 	emit_element_signal(connection, "ElementRemoved", element);
@@ -1741,11 +1505,8 @@ static gboolean update_element(GNode *node, gpointer user_data)
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION &&
 				root->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
-		if (element->strength != root->strength) {
+		if (element->strength != root->strength)
 			element->strength = root->strength;
-			emit_property_changed(connection, element, "Strength",
-					DBUS_TYPE_BYTE, &element->strength);
-		}
 	}
 
 	emit_element_signal(connection, "ElementUpdated", element);
@@ -1774,8 +1535,6 @@ int connman_element_set_enabled(struct connman_element *element,
 
 	element->enabled = enabled;
 
-	emit_enabled_signal(connection, element);
-
 	return 0;
 }
 

commit 46ba5103e9743547db0d67808883d83186e1934b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 18:04:25 2009 +0100

    Remove enable and disable element callbacks

diff --git a/include/driver.h b/include/driver.h
index 2932d4d2..6cf7d0d7 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -46,8 +46,6 @@ struct connman_driver {
 	int (*probe) (struct connman_element *element);
 	void (*remove) (struct connman_element *element);
 	int (*update) (struct connman_element *element);
-	int (*enable) (struct connman_element *element);
-	int (*disable) (struct connman_element *element);
 };
 
 extern int connman_driver_register(struct connman_driver *driver);
diff --git a/src/element.c b/src/element.c
index 44e2f973..2c7e7550 100644
--- a/src/element.c
+++ b/src/element.c
@@ -510,20 +510,6 @@ static gboolean match_driver(struct connman_element *element,
 	return FALSE;
 }
 
-static void enable_element(struct connman_element *element)
-{
-	if (element->type != CONNMAN_ELEMENT_TYPE_DEVICE)
-		return;
-
-	if (element->policy != CONNMAN_ELEMENT_POLICY_AUTO)
-		return;
-
-	if (element->driver && element->driver->enable) {
-		if (element->driver->enable(element) == 0)
-			element->enabled = TRUE;
-	}
-}
-
 static gboolean probe_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
@@ -538,8 +524,6 @@ static gboolean probe_driver(GNode *node, gpointer data)
 		__connman_element_lock(element);
 		element->driver = driver;
 		__connman_element_unlock(element);
-
-		enable_element(element);
 	}
 
 	return FALSE;
@@ -588,20 +572,6 @@ int connman_driver_register(struct connman_driver *driver)
 	return 0;
 }
 
-static void disable_element(struct connman_element *element)
-{
-	if (element->policy != CONNMAN_ELEMENT_POLICY_AUTO)
-		return;
-
-	if (element->enabled == FALSE)
-		return;
-
-	if (element->driver && element->driver->disable) {
-		if (element->driver->disable(element) == 0)
-			element->enabled = FALSE;
-	}
-}
-
 static gboolean remove_driver(GNode *node, gpointer data)
 {
 	struct connman_element *element = node->data;
@@ -610,8 +580,6 @@ static gboolean remove_driver(GNode *node, gpointer data)
 	DBG("element %p name %s", element, element->name);
 
 	if (element->driver == driver) {
-		disable_element(element);
-
 		if (driver->remove)
 			driver->remove(element);
 
@@ -1324,8 +1292,6 @@ static void probe_element(struct connman_element *element)
 			__connman_element_lock(element);
 			element->driver = driver;
 			__connman_element_unlock(element);
-
-			enable_element(element);
 			break;
 		}
 	}
@@ -1440,8 +1406,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		g_node_unlink(node);
 
 	if (element->driver) {
-		disable_element(element);
-
 		if (element->driver->remove)
 			element->driver->remove(element);
 
@@ -1610,8 +1574,6 @@ static gboolean free_driver(GNode *node, gpointer data)
 	DBG("element %p name %s", element, element->name);
 
 	if (element->driver) {
-		disable_element(element);
-
 		if (element->driver->remove)
 			element->driver->remove(element);
 

commit 63357f6bd54bb8ac0afd557ddd832c4085426897
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 18:05:49 2009 +0100

    Add storage driver documentation

diff --git a/doc/connman-docs.xml b/doc/connman-docs.xml
index 518c6d15..d4059a41 100644
--- a/doc/connman-docs.xml
+++ b/doc/connman-docs.xml
@@ -101,6 +101,7 @@
     </partintro>
     <xi:include href="xml/log.xml" />
     <xi:include href="xml/plugin.xml" />
+    <xi:include href="xml/storage.xml" />
     <xi:include href="xml/security.xml" />
     <xi:include href="xml/resolver.xml" />
     <!-- <xi:include href="xml/device.xml" /> -->

commit ef365b56fb876d1e02bbb7259f77c1945524df06
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 18:15:15 2009 +0100

    Move IPv4 handling into daemon core

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 71ae0cf9..de4b58bc 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1,7 +1,7 @@
 
 plugindir = $(libdir)/connman/plugins
 
-plugin_LTLIBRARIES = ipv4.la
+plugin_LTLIBRARIES =
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
@@ -53,8 +53,6 @@ plugin_LTLIBRARIES += hso.la
 hso_la_SOURCES = hso.c modem.h modem.c
 endif
 
-ipv4_la_SOURCES = ipv4.c inet.h inet.c
-
 if UDHCP
 plugin_LTLIBRARIES += udhcp.la
 
diff --git a/src/Makefile.am b/src/Makefile.am
index 54c06d8d..a1cfcc2d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -8,7 +8,7 @@ sbin_PROGRAMS = connmand
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
 			profile.c element.c device.c network.c connection.c \
 			security.c resolver.c storage.c manager.c agent.c \
-			detect.c rtnl.c dbus.c
+			ipv4.c detect.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/connman.h b/src/connman.h
index b97d835b..698c007c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -131,6 +131,9 @@ static inline void __connman_element_unlock(struct connman_element *element)
 int __connman_detect_init(void);
 void __connman_detect_cleanup(void);
 
+int __connman_ipv4_init(void);
+void __connman_ipv4_cleanup(void);
+
 int __connman_connection_init(void);
 void __connman_connection_cleanup(void);
 
diff --git a/src/element.c b/src/element.c
index 2c7e7550..eb26ae63 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1556,6 +1556,7 @@ void __connman_element_start(void)
 	started = TRUE;
 
 	__connman_connection_init();
+	__connman_ipv4_init();
 	__connman_detect_init();
 }
 
@@ -1564,6 +1565,7 @@ void __connman_element_stop(void)
 	DBG("");
 
 	__connman_detect_cleanup();
+	__connman_ipv4_cleanup();
 	__connman_connection_cleanup();
 }
 
diff --git a/plugins/ipv4.c b/src/ipv4.c
similarity index 89%
rename from plugins/ipv4.c
rename to src/ipv4.c
index c73c729c..4518d97c 100644
--- a/plugins/ipv4.c
+++ b/src/ipv4.c
@@ -31,21 +31,7 @@
 #include <arpa/inet.h>
 #include <net/if.h>
 
-#define CONNMAN_API_SUBJECT_TO_CHANGE
-#include <connman/plugin.h>
-#include <connman/driver.h>
-#include <connman/resolver.h>
-#include <connman/rtnl.h>
-#include <connman/log.h>
-
-#include "inet.h"
-
-enum connman_ipv4_method {
-	CONNMAN_IPV4_METHOD_UNKNOWN = 0,
-	CONNMAN_IPV4_METHOD_OFF     = 1,
-	CONNMAN_IPV4_METHOD_STATIC  = 2,
-	CONNMAN_IPV4_METHOD_DHCP    = 3,
-};
+#include "connman.h"
 
 struct connman_ipv4 {
 	enum connman_ipv4_method method;
@@ -152,6 +138,31 @@ static int clear_ipv4(struct connman_element *element)
 	return 0;
 }
 
+static char *index2name(int index)
+{
+	struct ifreq ifr;
+	int sk, err;
+
+	if (index < 0)
+		return NULL;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	return strdup(ifr.ifr_name);
+}
+
 static int ipv4_probe(struct connman_element *element)
 {
 	struct connman_element *connection;
@@ -189,7 +200,7 @@ static int ipv4_probe(struct connman_element *element)
 
 	connection->type    = CONNMAN_ELEMENT_TYPE_CONNECTION;
 	connection->index   = element->index;
-	connection->devname = inet_index2name(element->index);
+	connection->devname = index2name(element->index);
 
 	if (connman_element_register(connection, element) < 0)
 		connman_element_unref(connection);
@@ -207,19 +218,17 @@ static void ipv4_remove(struct connman_element *element)
 static struct connman_driver ipv4_driver = {
 	.name		= "ipv4",
 	.type		= CONNMAN_ELEMENT_TYPE_IPV4,
+	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
 	.probe		= ipv4_probe,
 	.remove		= ipv4_remove,
 };
 
-static int ipv4_init(void)
+int __connman_ipv4_init(void)
 {
 	return connman_driver_register(&ipv4_driver);
 }
 
-static void ipv4_exit(void)
+void __connman_ipv4_cleanup(void)
 {
 	connman_driver_unregister(&ipv4_driver);
 }
-
-CONNMAN_PLUGIN_DEFINE(ipv4, "IPv4 configuration plugin", VERSION,
-							ipv4_init, ipv4_exit)

commit 22a16114452511c732e2d72bf11666145f87eca8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 21:57:20 2009 +0100

    Remove element subtype details

diff --git a/include/driver.h b/include/driver.h
index 6cf7d0d7..f4c6187a 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -41,7 +41,6 @@ extern "C" {
 struct connman_driver {
 	const char *name;
 	enum connman_element_type type;
-	enum connman_element_subtype subtype;
 	int priority;
 	int (*probe) (struct connman_element *element);
 	void (*remove) (struct connman_element *element);
diff --git a/include/element.h b/include/element.h
index fbd28f2d..48247317 100644
--- a/include/element.h
+++ b/include/element.h
@@ -68,16 +68,6 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_VENDOR     = 10000,
 };
 
-enum connman_element_subtype {
-	CONNMAN_ELEMENT_SUBTYPE_UNKNOWN   = 0,
-	CONNMAN_ELEMENT_SUBTYPE_FAKE      = 1,
-	CONNMAN_ELEMENT_SUBTYPE_ETHERNET  = 3,
-	CONNMAN_ELEMENT_SUBTYPE_WIFI      = 4,
-	CONNMAN_ELEMENT_SUBTYPE_WIMAX     = 5,
-	CONNMAN_ELEMENT_SUBTYPE_CELLULAR  = 6,
-	CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH = 7,
-};
-
 struct connman_driver;
 
 struct connman_element {
@@ -86,7 +76,6 @@ struct connman_element {
 	gchar *name;
 	gchar *path;
 	enum connman_element_type type;
-	enum connman_element_subtype subtype;
 	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
diff --git a/src/connman.h b/src/connman.h
index 698c007c..b4276a45 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -115,7 +115,6 @@ int __connman_element_count(struct connman_element *element,
 					enum connman_element_type type);
 
 const char *__connman_element_type2string(enum connman_element_type type);
-const char *__connman_element_subtype2string(enum connman_element_subtype type);
 
 const char *__connman_element_policy2string(enum connman_element_policy policy);
 enum connman_element_policy __connman_element_string2policy(const char *policy);
diff --git a/src/device.c b/src/device.c
index 57e370c1..5bfd8e53 100644
--- a/src/device.c
+++ b/src/device.c
@@ -694,23 +694,6 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.type = CONNMAN_ELEMENT_TYPE_DEVICE;
 	device->element.index = -1;
 
-	switch (type) {
-	case CONNMAN_DEVICE_TYPE_UNKNOWN:
-	case CONNMAN_DEVICE_TYPE_VENDOR:
-	case CONNMAN_DEVICE_TYPE_WIFI:
-	case CONNMAN_DEVICE_TYPE_WIMAX:
-	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
-	case CONNMAN_DEVICE_TYPE_HSO:
-	case CONNMAN_DEVICE_TYPE_NOZOMI:
-	case CONNMAN_DEVICE_TYPE_HUAWEI:
-	case CONNMAN_DEVICE_TYPE_NOVATEL:
-		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
-		break;
-	case CONNMAN_DEVICE_TYPE_ETHERNET:
-		device->element.subtype = CONNMAN_ELEMENT_SUBTYPE_ETHERNET;
-		break;
-	}
-
 	device->element.device = device;
 	device->element.destruct = device_destruct;
 
@@ -928,9 +911,8 @@ int connman_device_set_carrier(struct connman_device *device,
 
 		element = connman_element_create(NULL);
 		if (element != NULL) {
-			element->type    = CONNMAN_ELEMENT_TYPE_DHCP;
-			element->subtype = device->element.subtype;
-			element->index   = device->element.index;
+			element->type  = CONNMAN_ELEMENT_TYPE_DHCP;
+			element->index = device->element.index;
 
 			if (connman_element_register(element,
 							&device->element) < 0)
diff --git a/src/element.c b/src/element.c
index eb26ae63..129fa62d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -127,30 +127,6 @@ static const char *type2string(enum connman_element_type type)
 	return NULL;
 }
 
-#if 0
-static const char *subtype2string(enum connman_element_subtype type)
-{
-	switch (type) {
-	case CONNMAN_ELEMENT_SUBTYPE_UNKNOWN:
-		return "unknown";
-	case CONNMAN_ELEMENT_SUBTYPE_FAKE:
-		return "fake";
-	case CONNMAN_ELEMENT_SUBTYPE_ETHERNET:
-		return "ethernet";
-	case CONNMAN_ELEMENT_SUBTYPE_WIFI:
-		return "wifi";
-	case CONNMAN_ELEMENT_SUBTYPE_WIMAX:
-		return "wimax";
-	case CONNMAN_ELEMENT_SUBTYPE_CELLULAR:
-		return "cellular";
-	case CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH:
-		return "bluetooth";
-	}
-
-	return NULL;
-}
-#endif
-
 const char *__connman_element_policy2string(enum connman_element_policy policy)
 {
 	switch (policy) {
@@ -499,12 +475,8 @@ static gboolean match_driver(struct connman_element *element,
 	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
 		return FALSE;
 
-	if (element->type != driver->type &&
-			driver->type != CONNMAN_ELEMENT_TYPE_UNKNOWN)
-		return FALSE;
-
-	if (element->subtype == driver->subtype ||
-			driver->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
+	if (element->type == driver->type ||
+			driver->type == CONNMAN_ELEMENT_TYPE_UNKNOWN)
 		return TRUE;
 
 	return FALSE;
@@ -631,7 +603,6 @@ struct connman_element *connman_element_create(const char *name)
 
 	element->name    = g_strdup(name);
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
-	element->subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
 	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
 	element->policy  = CONNMAN_ELEMENT_POLICY_AUTO;
 	element->index   = -1;
@@ -1309,9 +1280,6 @@ static void register_element(gpointer data, gpointer user_data)
 		node = g_node_find(element_root, G_PRE_ORDER,
 					G_TRAVERSE_ALL, element->parent);
 		basepath = element->parent->path;
-
-		if (element->subtype == CONNMAN_ELEMENT_SUBTYPE_UNKNOWN)
-			element->subtype = element->parent->subtype;
 	} else {
 		element->parent = element_root->data;
 
diff --git a/src/network.c b/src/network.c
index 6c17088e..9ed6dc4b 100644
--- a/src/network.c
+++ b/src/network.c
@@ -349,23 +349,6 @@ struct connman_network *connman_network_create(const char *identifier,
 	network->element.type = CONNMAN_ELEMENT_TYPE_NETWORK;
 	network->element.index = -1;
 
-	switch (type) {
-	case CONNMAN_NETWORK_TYPE_UNKNOWN:
-	case CONNMAN_NETWORK_TYPE_VENDOR:
-		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_UNKNOWN;
-		break;
-	case CONNMAN_NETWORK_TYPE_WIFI:
-		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_WIFI;
-		break;
-	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
-	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
-		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_BLUETOOTH;
-		break;
-	case CONNMAN_NETWORK_TYPE_HSO:
-		network->element.subtype = CONNMAN_ELEMENT_SUBTYPE_CELLULAR;
-		break;
-	}
-
 	network->element.network = network;
 	network->element.destruct = network_destruct;
 
@@ -494,9 +477,8 @@ int connman_network_set_connected(struct connman_network *network,
 
 		element = connman_element_create(NULL);
 		if (element != NULL) {
-			element->type    = type;
-			element->subtype = network->element.subtype;
-			element->index   = network->element.index;
+			element->type  = type;
+			element->index = network->element.index;
 
 			if (connman_element_register(element,
 						&network->element) < 0)

commit d829de8ea9a373bbc67ade2939102aedca50cd5f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:05:58 2009 +0100

    Add support for plugin pattern via command line

diff --git a/src/connman.h b/src/connman.h
index b4276a45..0afef062 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -62,7 +62,7 @@ gboolean __connman_debug_enabled(void);
 
 #include <connman/plugin.h>
 
-int __connman_plugin_init(void);
+int __connman_plugin_init(const char *pattern);
 void __connman_plugin_cleanup(void);
 
 #include <connman/security.h>
diff --git a/src/main.c b/src/main.c
index 971359de..b895b1c0 100644
--- a/src/main.c
+++ b/src/main.c
@@ -51,6 +51,7 @@ static void disconnect_callback(DBusConnection *conn, void *user_data)
 }
 
 static gchar *option_device = NULL;
+static gchar *option_plugin = NULL;
 static gboolean option_detach = TRUE;
 static gboolean option_selftest = FALSE;
 static gboolean option_compat = FALSE;
@@ -59,6 +60,8 @@ static gboolean option_debug = FALSE;
 static GOptionEntry options[] = {
 	{ "device", 'i', 0, G_OPTION_ARG_STRING, &option_device,
 				"Specify network device/interface", "DEV" },
+	{ "plugin", 'p', 0, G_OPTION_ARG_STRING, &option_plugin,
+				"Specify plugins to load", "NAME" },
 	{ "nodaemon", 'n', G_OPTION_FLAG_REVERSE,
 				G_OPTION_ARG_NONE, &option_detach,
 				"Don't fork daemon to background" },
@@ -163,11 +166,12 @@ int main(int argc, char *argv[])
 	__connman_rtnl_init();
 	__connman_udev_init();
 
-	__connman_plugin_init();
+	__connman_plugin_init(option_plugin);
 
 	__connman_element_start();
 
 	g_free(option_device);
+	g_free(option_plugin);
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
diff --git a/src/plugin.c b/src/plugin.c
index 2ebe327f..716eb7cc 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -60,7 +60,7 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	return TRUE;
 }
 
-int __connman_plugin_init(void)
+int __connman_plugin_init(const char *pattern)
 {
 	GDir *dir;
 	const gchar *file;
@@ -97,6 +97,13 @@ int __connman_plugin_init(void)
 				continue;
 			}
 
+			if (g_pattern_match_simple(pattern,
+							desc->name) == FALSE) {
+				DBG("ignoring %s", desc->description);
+				dlclose(handle);
+				continue;
+			}
+
 			if (add_plugin(handle, desc) == FALSE)
 				dlclose(handle);
 		}

commit 14fb68d9c0aa7a19fd1424b4b2bc84af1caab594
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:09:22 2009 +0100

    Apply plugin pattern only if specified

diff --git a/src/plugin.c b/src/plugin.c
index 716eb7cc..2103b66e 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -97,7 +97,7 @@ int __connman_plugin_init(const char *pattern)
 				continue;
 			}
 
-			if (g_pattern_match_simple(pattern,
+			if (pattern != NULL && g_pattern_match_simple(pattern,
 							desc->name) == FALSE) {
 				DBG("ignoring %s", desc->description);
 				dlclose(handle);

commit 8c525f8122631321a7170ce9409baca706d1aea3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:09:48 2009 +0100

    Export interface name via connection

diff --git a/src/connection.c b/src/connection.c
index 9cd0f64c..212242e1 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -202,6 +202,7 @@ static int del_route(struct connman_element *element, const char *gateway)
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
 
@@ -218,6 +219,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	if (element->devname != NULL)
+		connman_dbus_dict_append_variant(&dict, "Interface",
+					DBUS_TYPE_STRING, &element->devname);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;

commit c60ffbfbfe8bfedb7b75f94f5f042a206fb7940f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:12:23 2009 +0100

    Add property to indicate default connections

diff --git a/src/connection.c b/src/connection.c
index 212242e1..79ae34de 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -223,6 +223,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Interface",
 					DBUS_TYPE_STRING, &element->devname);
 
+	connman_dbus_dict_append_variant(&dict, "Default",
+					DBUS_TYPE_BOOLEAN, &element->enabled);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;

commit 9de932200a6f5b7bce5015bd2faee005da77e225
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:26:58 2009 +0100

    Add support for IPv4 details in connection interface

diff --git a/include/element.h b/include/element.h
index 48247317..70e1ae43 100644
--- a/include/element.h
+++ b/include/element.h
@@ -30,6 +30,7 @@ extern "C" {
 #include <glib.h>
 
 #include <connman/property.h>
+#include <connman/ipv4.h>
 
 /**
  * SECTION:element
@@ -101,6 +102,7 @@ struct connman_element {
 	GSList *properties;
 
 	struct {
+		enum connman_ipv4_method method;
 		gchar *address;
 		gchar *netmask;
 		gchar *gateway;
diff --git a/src/connection.c b/src/connection.c
index 79ae34de..01a84cc0 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -205,6 +205,8 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	const char *method = NULL;
+	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 
 	DBG("conn %p", conn);
 
@@ -226,6 +228,32 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Default",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_METHOD, &method);
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_ADDRESS, &address);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	if (method != NULL)
+		connman_dbus_dict_append_variant(&dict, "IPv4.Method",
+						DBUS_TYPE_STRING, &method);
+
+	if (address != NULL)
+		connman_dbus_dict_append_variant(&dict, "IPv4.Address",
+						DBUS_TYPE_STRING, &address);
+
+	if (netmask != NULL)
+		connman_dbus_dict_append_variant(&dict, "IPv4.Netmask",
+						DBUS_TYPE_STRING, &netmask);
+
+	if (gateway != NULL)
+		connman_dbus_dict_append_variant(&dict, "IPv4.Gateway",
+						DBUS_TYPE_STRING, &gateway);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
diff --git a/src/element.c b/src/element.c
index 129fa62d..a81f7550 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1005,6 +1005,14 @@ int connman_element_get_value(struct connman_element *element,
 		return -EINVAL;
 
 	switch (id) {
+	case CONNMAN_PROPERTY_ID_IPV4_METHOD:
+		if (element->ipv4.method == CONNMAN_IPV4_METHOD_UNKNOWN)
+			return connman_element_get_value(element->parent,
+								id, value);
+		__connman_element_lock(element);
+		*((const char **) value) = __connman_ipv4_method2string(element->ipv4.method);
+		__connman_element_unlock(element);
+		break;
 	case CONNMAN_PROPERTY_ID_IPV4_ADDRESS:
 		if (element->ipv4.address == NULL)
 			return connman_element_get_value(element->parent,
@@ -1351,6 +1359,9 @@ int connman_element_register(struct connman_element *element,
 		}
 	}
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_DHCP)
+		element->ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
+
 	element->parent = parent;
 
 	__connman_element_unlock(element);

commit 45ac2541f62eb93e4d58a42931c05e599e0bc23d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:28:05 2009 +0100

    Remove unused remember variable

diff --git a/include/element.h b/include/element.h
index 70e1ae43..30d9a11c 100644
--- a/include/element.h
+++ b/include/element.h
@@ -80,7 +80,6 @@ struct connman_element {
 	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
-	gboolean remember;
 	guint16 priority;
 	guint8 strength;
 	gchar *devpath;

commit 638b640f4bf4b731e0765d36b89682e428fb7a13
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:29:15 2009 +0100

    All elements are fully stateless

diff --git a/include/element.h b/include/element.h
index 30d9a11c..6a3f98fb 100644
--- a/include/element.h
+++ b/include/element.h
@@ -38,13 +38,6 @@ extern "C" {
  * @short_description: Functions for handling elements
  */
 
-enum connman_element_state {
-	CONNMAN_ELEMENT_STATE_UNKNOWN   = 0,
-	CONNMAN_ELEMENT_STATE_CONNECT   = 1,
-	CONNMAN_ELEMENT_STATE_CONNECTED = 2,
-	CONNMAN_ELEMENT_STATE_CLOSED    = 3,
-};
-
 enum connman_element_policy {
 	CONNMAN_ELEMENT_POLICY_UNKNOWN = 0,
 	CONNMAN_ELEMENT_POLICY_IGNORE  = 1,
@@ -77,7 +70,6 @@ struct connman_element {
 	gchar *name;
 	gchar *path;
 	enum connman_element_type type;
-	enum connman_element_state state;
 	enum connman_element_policy policy;
 	gboolean enabled;
 	guint16 priority;
diff --git a/src/element.c b/src/element.c
index a81f7550..f28e57d1 100644
--- a/src/element.c
+++ b/src/element.c
@@ -603,7 +603,6 @@ struct connman_element *connman_element_create(const char *name)
 
 	element->name    = g_strdup(name);
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
-	element->state   = CONNMAN_ELEMENT_STATE_CLOSED;
 	element->policy  = CONNMAN_ELEMENT_POLICY_AUTO;
 	element->index   = -1;
 	element->enabled = FALSE;

commit c90bc95e4a15388be52e0240799238fa9d9c3bf5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:30:52 2009 +0100

    All policy is now part of devices and networks

diff --git a/include/element.h b/include/element.h
index 6a3f98fb..5d126538 100644
--- a/include/element.h
+++ b/include/element.h
@@ -38,13 +38,6 @@ extern "C" {
  * @short_description: Functions for handling elements
  */
 
-enum connman_element_policy {
-	CONNMAN_ELEMENT_POLICY_UNKNOWN = 0,
-	CONNMAN_ELEMENT_POLICY_IGNORE  = 1,
-	CONNMAN_ELEMENT_POLICY_AUTO    = 2,
-	CONNMAN_ELEMENT_POLICY_ASK     = 3,
-};
-
 enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_UNKNOWN    = 0,
 	CONNMAN_ELEMENT_TYPE_ROOT       = 1,
@@ -70,7 +63,6 @@ struct connman_element {
 	gchar *name;
 	gchar *path;
 	enum connman_element_type type;
-	enum connman_element_policy policy;
 	gboolean enabled;
 	guint16 priority;
 	guint8 strength;
diff --git a/src/connman.h b/src/connman.h
index 0afef062..df2b4c44 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -116,9 +116,6 @@ int __connman_element_count(struct connman_element *element,
 
 const char *__connman_element_type2string(enum connman_element_type type);
 
-const char *__connman_element_policy2string(enum connman_element_policy policy);
-enum connman_element_policy __connman_element_string2policy(const char *policy);
-
 static inline void __connman_element_lock(struct connman_element *element)
 {
 }
diff --git a/src/element.c b/src/element.c
index f28e57d1..9dbcd686 100644
--- a/src/element.c
+++ b/src/element.c
@@ -127,34 +127,6 @@ static const char *type2string(enum connman_element_type type)
 	return NULL;
 }
 
-const char *__connman_element_policy2string(enum connman_element_policy policy)
-{
-	switch (policy) {
-	case CONNMAN_ELEMENT_POLICY_UNKNOWN:
-		return "unknown";
-	case CONNMAN_ELEMENT_POLICY_IGNORE:
-		return "ignore";
-	case CONNMAN_ELEMENT_POLICY_AUTO:
-		return "auto";
-	case CONNMAN_ELEMENT_POLICY_ASK:
-		return "ask";
-	}
-
-	return NULL;
-}
-
-enum connman_element_policy __connman_element_string2policy(const char *policy)
-{
-	if (strcasecmp(policy, "ignore") == 0)
-		return CONNMAN_ELEMENT_POLICY_IGNORE;
-	else if (strcasecmp(policy, "auto") == 0)
-		return CONNMAN_ELEMENT_POLICY_AUTO;
-	else if (strcasecmp(policy, "ask") == 0)
-		return CONNMAN_ELEMENT_POLICY_ASK;
-	else
-		return CONNMAN_ELEMENT_POLICY_UNKNOWN;
-}
-
 const char *__connman_ipv4_method2string(enum connman_ipv4_method method)
 {
 	switch (method) {
@@ -603,7 +575,6 @@ struct connman_element *connman_element_create(const char *name)
 
 	element->name    = g_strdup(name);
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
-	element->policy  = CONNMAN_ELEMENT_POLICY_AUTO;
 	element->index   = -1;
 	element->enabled = FALSE;
 

commit 6012d11b6cebd5b7dbfce13a711141ef41742f43
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:31:40 2009 +0100

    Remove the unused priority variable

diff --git a/include/element.h b/include/element.h
index 5d126538..9bb617e4 100644
--- a/include/element.h
+++ b/include/element.h
@@ -64,7 +64,6 @@ struct connman_element {
 	gchar *path;
 	enum connman_element_type type;
 	gboolean enabled;
-	guint16 priority;
 	guint8 strength;
 	gchar *devpath;
 	gchar *devname;

commit 5ba62c7f31f6e5e4d6836b5df26bb9212452b893
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:33:29 2009 +0100

    All WiFi properties are now part of network interface

diff --git a/include/element.h b/include/element.h
index 9bb617e4..17f96e4c 100644
--- a/include/element.h
+++ b/include/element.h
@@ -92,11 +92,6 @@ struct connman_element {
 		gchar *broadcast;
 		gchar *nameserver;
 	} ipv4;
-
-	struct {
-		gchar *security;
-		gchar *passphrase;
-	} wifi;
 };
 
 extern struct connman_element *connman_element_create(const char *name);
diff --git a/include/property.h b/include/property.h
index 35dbe5cf..e792487f 100644
--- a/include/property.h
+++ b/include/property.h
@@ -41,9 +41,6 @@ enum connman_property_id {
 	CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
 	CONNMAN_PROPERTY_ID_IPV4_BROADCAST,
 	CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
-
-	CONNMAN_PROPERTY_ID_WIFI_SECURITY,
-	CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE,
 };
 
 /**
diff --git a/src/element.c b/src/element.c
index 9dbcd686..6f347a76 100644
--- a/src/element.c
+++ b/src/element.c
@@ -58,12 +58,6 @@ static struct {
 		DBUS_TYPE_STRING, "IPv4.Broadcast" },
 	{ CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 		DBUS_TYPE_STRING, "IPv4.Nameserver" },
-
-	{ CONNMAN_PROPERTY_ID_WIFI_SECURITY,
-		DBUS_TYPE_STRING, "WiFi.Security" },
-	{ CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE,
-		DBUS_TYPE_STRING, "WiFi.Passphrase" },
-
 	{ }
 };
 
@@ -949,18 +943,6 @@ int connman_element_set_property(struct connman_element *element,
 		element->ipv4.nameserver = g_strdup(*((const char **) value));
 		__connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_ID_WIFI_SECURITY:
-		__connman_element_lock(element);
-		g_free(element->wifi.security);
-		element->wifi.security = g_strdup(*((const char **) value));
-		__connman_element_unlock(element);
-		break;
-	case CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE:
-		__connman_element_lock(element);
-		g_free(element->wifi.passphrase);
-		element->wifi.passphrase = g_strdup(*((const char **) value));
-		__connman_element_unlock(element);
-		break;
 	default:
 		return -EINVAL;
 	}
@@ -1023,22 +1005,6 @@ int connman_element_get_value(struct connman_element *element,
 		*((char **) value) = element->ipv4.nameserver;
 		__connman_element_unlock(element);
 		break;
-	case CONNMAN_PROPERTY_ID_WIFI_SECURITY:
-		if (element->wifi.security == NULL)
-			return connman_element_get_value(element->parent,
-								id, value);
-		__connman_element_lock(element);
-		*((char **) value) = element->wifi.security;
-		__connman_element_unlock(element);
-		break;
-	case CONNMAN_PROPERTY_ID_WIFI_PASSPHRASE:
-		if (element->wifi.passphrase == NULL)
-			return connman_element_get_value(element->parent,
-								id, value);
-		__connman_element_lock(element);
-		*((char **) value) = element->wifi.passphrase;
-		__connman_element_unlock(element);
-		break;
 	default:
 		return -EINVAL;
 	}

commit 8a46c875866dbda9406c0bf738ce95d721626739
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:34:59 2009 +0100

    Remove the unused devpath variable

diff --git a/include/element.h b/include/element.h
index 17f96e4c..8df0d5c4 100644
--- a/include/element.h
+++ b/include/element.h
@@ -65,7 +65,6 @@ struct connman_element {
 	enum connman_element_type type;
 	gboolean enabled;
 	guint8 strength;
-	gchar *devpath;
 	gchar *devname;
 
 	struct connman_element *parent;
diff --git a/src/element.c b/src/element.c
index 6f347a76..fef78bed 100644
--- a/src/element.c
+++ b/src/element.c
@@ -626,7 +626,6 @@ void connman_element_unref(struct connman_element *element)
 		g_free(element->ipv4.broadcast);
 		g_free(element->ipv4.nameserver);
 		g_free(element->devname);
-		g_free(element->devpath);
 		g_free(element->path);
 		g_free(element->name);
 		g_free(element);

commit d333a3b050767ef8b89b3a9e04ef7723cbcf8e0a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 22:36:59 2009 +0100

    Remove deprecated function prototype

diff --git a/include/element.h b/include/element.h
index 8df0d5c4..6f6aa699 100644
--- a/include/element.h
+++ b/include/element.h
@@ -125,8 +125,6 @@ extern void connman_element_update(struct connman_element *element);
 
 extern int connman_element_set_enabled(struct connman_element *element,
 							gboolean enabled);
-extern int connman_element_set_scanning(struct connman_element *element,
-							gboolean scanning);
 
 static inline void *connman_element_get_data(struct connman_element *element)
 {

commit 4c4a43fea3872b69c695573def36b1c146ee6712
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 23:03:35 2009 +0100

    Don't probe device drivers twice

diff --git a/src/device.c b/src/device.c
index 5bfd8e53..a3bbd895 100644
--- a/src/device.c
+++ b/src/device.c
@@ -551,6 +551,9 @@ static void probe_driver(struct connman_element *element, gpointer user_data)
 	if (element->device == NULL)
 		return;
 
+	if (element->device->driver != NULL)
+		return;
+
 	if (driver->probe(element->device) < 0)
 		return;
 
@@ -1205,6 +1208,9 @@ static int device_probe(struct connman_element *element)
 	if (device == NULL)
 		return -ENODEV;
 
+	if (device->driver != NULL)
+		return -EALREADY;
+
 	for (list = driver_list; list; list = list->next) {
 		struct connman_device_driver *driver = list->data;
 

commit 47c19cde9956bd22b021dc90d115079ddd743521
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 23:03:53 2009 +0100

    Handle cases for unknown network types

diff --git a/test/list-networks b/test/list-networks
index 8b1ade1c..f4d5075f 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -25,9 +25,12 @@ for path in properties["Devices"]:
 
 	properties = device.GetProperties()
 
-	if properties["Type"] not in ["wifi", "wimax",
+	try:
+		if properties["Type"] not in ["wifi", "wimax",
 					"bluetooth", "cellular"]:
-		continue;
+			continue
+	except:
+		continue
 
 	print "[ %s ]" % (path)
 

commit b478e2b56edf6343685b8941e0320a5e1323110f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 23:04:15 2009 +0100

    Fix fake testing plugin

diff --git a/plugins/fake.c b/plugins/fake.c
index 1ea9cc5a..4f57837a 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -23,102 +23,87 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
+
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
-#include <connman/driver.h>
-#include <connman/element.h>
+#include <connman/device.h>
 #include <connman/log.h>
 
-static void create_network(struct connman_element *parent, const char *name)
+static void create_network(struct connman_device *device, const char *name)
 {
-	struct connman_element *element;
+	struct connman_network *network;
 
-	element = connman_element_create(name);
-	element->type = CONNMAN_ELEMENT_TYPE_NETWORK;
-	element->subtype = CONNMAN_ELEMENT_SUBTYPE_FAKE;
+	network = connman_network_create(name, CONNMAN_NETWORK_TYPE_VENDOR);
+	if (network == NULL)
+		return;
 
-	connman_element_register(element, parent);
-	connman_element_unref(element);
+	connman_device_add_network(device, network);
+	connman_network_unref(network);
 }
 
-static int fake_device_probe(struct connman_element *element)
+static int device_probe(struct connman_device *device)
 {
 	DBG("");
 
 	return 0;
 }
 
-static void fake_device_remove(struct connman_element *element)
+static void device_remove(struct connman_device *device)
 {
 	DBG("");
 }
 
-static int fake_device_update(struct connman_element *element)
+static int device_enable(struct connman_device *device)
 {
 	DBG("");
 
-	create_network(element, "network_new");
+	create_network(device, "network_one");
+	create_network(device, "network_two");
 
 	return 0;
 }
 
-static int fake_device_enable(struct connman_element *element)
+static int device_disable(struct connman_device *device)
 {
 	DBG("");
 
-	create_network(element, "network_one");
-	create_network(element, "network_two");
-
-	return 0;
-}
-
-static int fake_device_disable(struct connman_element *element)
-{
-	DBG("");
-
-	connman_element_unregister_children(element);
-
 	return 0;
 }
 
-static struct connman_driver fake_device_driver = {
-	.name		= "fake-device",
-	.type		= CONNMAN_ELEMENT_TYPE_DEVICE,
-	.subtype	= CONNMAN_ELEMENT_SUBTYPE_FAKE,
-	.probe		= fake_device_probe,
-	.remove		= fake_device_remove,
-	.update		= fake_device_update,
-	.enable		= fake_device_enable,
-	.disable	= fake_device_disable,
+static struct connman_device_driver device_driver = {
+	.name		= "fake",
+	.type		= CONNMAN_DEVICE_TYPE_VENDOR,
+	.probe		= device_probe,
+	.remove		= device_remove,
+	.enable		= device_enable,
+	.disable	= device_disable,
 };
 
 static void create_device(const char *name)
 {
-	struct connman_element *element;
+	struct connman_device *device;
 
-	element = connman_element_create(name);
-	element->type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	element->subtype = CONNMAN_ELEMENT_SUBTYPE_FAKE;
+	device = connman_device_create(name, CONNMAN_DEVICE_TYPE_VENDOR);
+	if (device == NULL)
+		return;
 
-	//connman_element_define_properties(element,
-	//				CONNMAN_PROPERTY_ID_IPV4_METHOD,
-	//				CONNMAN_PROPERTY_ID_INVALID);
+	connman_device_set_mode(device, CONNMAN_DEVICE_MODE_NETWORK_SINGLE);
 
-	connman_element_register(element, NULL);
-	connman_element_unref(element);
+	connman_device_register(device);
+	connman_device_unref(device);
 }
 
 static int fake_init(void)
 {
-	create_device("fakeone");
-	create_device("faketwo");
+	create_device("fake");
 
-	return connman_driver_register(&fake_device_driver);
+	return connman_device_driver_register(&device_driver);
 }
 
 static void fake_exit(void)
 {
-	connman_driver_unregister(&fake_device_driver);
+	connman_device_driver_unregister(&device_driver);
 }
 
 CONNMAN_PLUGIN_DEFINE(fake, "Tesing plugin", VERSION, fake_init, fake_exit)

commit e0a71455440ba3ffd0c1403f5b146997f3ad936f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 23:18:45 2009 +0100

    Fix typo in debug message

diff --git a/src/device.c b/src/device.c
index a3bbd895..c1aa0046 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1046,7 +1046,7 @@ int connman_device_set_string(struct connman_device *device,
 const char *connman_device_get_string(struct connman_device *device,
 							const char *key)
 {
-	DBG("device %p key %s", device);
+	DBG("device %p key %s", device, key);
 
 	if (g_str_equal(key, "Name") == TRUE)
 		return device->name;

commit e10cccf70309a219f0068b636a5f466456008989
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 23:45:55 2009 +0100

    Add support for connection type property

diff --git a/src/connection.c b/src/connection.c
index 01a84cc0..7344cd48 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -205,7 +205,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	const char *method = NULL;
+	const char *type = NULL, *method = NULL;
 	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 
 	DBG("conn %p", conn);
@@ -221,6 +221,12 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	connman_element_get_static_property(element, "Type", &type);
+
+	if (type != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &type);
+
 	if (element->devname != NULL)
 		connman_dbus_dict_append_variant(&dict, "Interface",
 					DBUS_TYPE_STRING, &element->devname);
diff --git a/src/device.c b/src/device.c
index c1aa0046..f6bad3b2 100644
--- a/src/device.c
+++ b/src/device.c
@@ -682,6 +682,7 @@ struct connman_device *connman_device_create(const char *node,
 						enum connman_device_type type)
 {
 	struct connman_device *device;
+	const char *str;
 
 	DBG("node %s type %d", node, type);
 
@@ -700,6 +701,11 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.device = device;
 	device->element.destruct = device_destruct;
 
+	str = type2string(type);
+	if (str != NULL)
+		connman_element_add_static_property(&device->element,
+					"Type", DBUS_TYPE_STRING, &str);
+
 	device->type   = type;
 	device->mode   = CONNMAN_DEVICE_MODE_UNKNOWN;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
diff --git a/src/element.c b/src/element.c
index fef78bed..03bb5f55 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1040,6 +1040,10 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 
 	__connman_element_unlock(element);
 
+	if (found == FALSE && element->parent != NULL)
+		return connman_element_get_static_property(element->parent,
+								name, value);
+
 	return found;
 }
 
diff --git a/src/network.c b/src/network.c
index 9ed6dc4b..1bfc46df 100644
--- a/src/network.c
+++ b/src/network.c
@@ -56,6 +56,24 @@ struct connman_network {
 	} wifi;
 };
 
+static const char *type2string(enum connman_network_type type)
+{
+	switch (type) {
+	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+	case CONNMAN_NETWORK_TYPE_VENDOR:
+		break;
+	case CONNMAN_NETWORK_TYPE_WIFI:
+		return "wifi";
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
+		return "bluetooth";
+	case CONNMAN_NETWORK_TYPE_HSO:
+		return "cellular";
+	}
+
+	return NULL;
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -334,6 +352,7 @@ struct connman_network *connman_network_create(const char *identifier,
 						enum connman_network_type type)
 {
 	struct connman_network *network;
+	const char *str;
 
 	DBG("identifier %s type %d", identifier, type);
 
@@ -352,6 +371,11 @@ struct connman_network *connman_network_create(const char *identifier,
 	network->element.network = network;
 	network->element.destruct = network_destruct;
 
+	str = type2string(type);
+	if (str != NULL)
+		connman_element_add_static_property(&network->element,
+					"Type", DBUS_TYPE_STRING, &str);
+
 	network->type = type;
 	network->identifier = g_strdup(identifier);
 

commit 5d659bf8a8ba8f85e0d004956257ccb6d5507bef
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 5 23:59:35 2009 +0100

    Add support for connection strength property

diff --git a/src/connection.c b/src/connection.c
index 7344cd48..0b3e59c4 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -205,6 +205,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	connman_uint8_t strength = 0;
 	const char *type = NULL, *method = NULL;
 	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 
@@ -227,6 +228,11 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &type);
 
+	connman_element_get_static_property(element, "Strength", &strength);
+	if (strength > 0)
+		connman_dbus_dict_append_variant(&dict, "Strength",
+						DBUS_TYPE_BYTE, &strength);
+
 	if (element->devname != NULL)
 		connman_dbus_dict_append_variant(&dict, "Interface",
 					DBUS_TYPE_STRING, &element->devname);
diff --git a/src/network.c b/src/network.c
index 1bfc46df..c60cfa44 100644
--- a/src/network.c
+++ b/src/network.c
@@ -352,6 +352,7 @@ struct connman_network *connman_network_create(const char *identifier,
 						enum connman_network_type type)
 {
 	struct connman_network *network;
+	connman_uint8_t strength = 0;
 	const char *str;
 
 	DBG("identifier %s type %d", identifier, type);
@@ -376,6 +377,9 @@ struct connman_network *connman_network_create(const char *identifier,
 		connman_element_add_static_property(&network->element,
 					"Type", DBUS_TYPE_STRING, &str);
 
+	connman_element_add_static_property(&network->element,
+					"Strength", DBUS_TYPE_BYTE, &strength);
+
 	network->type = type;
 	network->identifier = g_strdup(identifier);
 
@@ -619,8 +623,11 @@ int connman_network_set_uint8(struct connman_network *network,
 {
 	DBG("network %p key %s value %d", network, key, value);
 
-	if (g_str_equal(key, "Strength") == TRUE)
+	if (g_str_equal(key, "Strength") == TRUE) {
 		network->strength = value;
+		connman_element_set_static_property(&network->element,
+					"Strength", DBUS_TYPE_BYTE, &value);
+	}
 
 	return 0;
 }

commit 839885f14c8b7bc9957b944e5c450bf921d47fe8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 00:45:06 2009 +0100

    Allow retrieving static properties with byte values

diff --git a/src/element.c b/src/element.c
index 03bb5f55..ba947059 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1033,6 +1033,10 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 				*((char **) value) = property->value;
 				found = TRUE;
 				break;
+			case DBUS_TYPE_BYTE:
+				memcpy(value, property->value, 1);
+				found = TRUE;
+				break;
 			}
 			break;
 		}

commit 301a728a5e1ba1f7d70d9430e75376de7867b5d7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 01:26:34 2009 +0100

    Fix signal emission for network creation and removal

diff --git a/src/network.c b/src/network.c
index c60cfa44..99bb40b8 100644
--- a/src/network.c
+++ b/src/network.c
@@ -236,8 +236,42 @@ static GDBusSignalTable network_signals[] = {
 
 static DBusConnection *connection;
 
-static void emit_networks_signal(void)
+static void append_networks(struct connman_device *device,
+						DBusMessageIter *entry)
 {
+	DBusMessageIter value, iter;
+	const char *key = "Networks";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	__connman_element_list((struct connman_element *) device,
+					CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
+static void emit_networks_signal(struct connman_device *device)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_networks(device, &entry);
+
+	g_dbus_send_message(connection, signal);
 }
 
 static int register_interface(struct connman_element *element)
@@ -256,7 +290,7 @@ static int register_interface(struct connman_element *element)
 
 	network->registered = TRUE;
 
-	emit_networks_signal();
+	emit_networks_signal(network->device);
 
 	return 0;
 }
@@ -269,7 +303,7 @@ static void unregister_interface(struct connman_element *element)
 
 	network->registered = FALSE;
 
-	emit_networks_signal();
+	emit_networks_signal(network->device);
 
 	g_dbus_unregister_interface(connection, element->path,
 						CONNMAN_NETWORK_INTERFACE);

commit f93ca201df00929db3f27625b0626a9f2e7ac3ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 01:29:30 2009 +0100

    Remove deprecated element strength handling

diff --git a/include/element.h b/include/element.h
index 6f6aa699..d91886b6 100644
--- a/include/element.h
+++ b/include/element.h
@@ -64,7 +64,6 @@ struct connman_element {
 	gchar *path;
 	enum connman_element_type type;
 	gboolean enabled;
-	guint8 strength;
 	gchar *devname;
 
 	struct connman_element *parent;
diff --git a/src/element.c b/src/element.c
index ba947059..57c25665 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1182,20 +1182,6 @@ static void emit_state_change(DBusConnection *conn, const char *state)
 	g_dbus_send_message(conn, signal);
 }
 
-static void set_signal_strength(struct connman_element *connection)
-{
-	struct connman_element *element = connection;
-
-	while (element != NULL) {
-		if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
-			connection->strength = element->strength;
-			break;
-		}
-
-		element = element->parent;
-	}
-}
-
 static void probe_element(struct connman_element *element)
 {
 	GSList *list;
@@ -1249,7 +1235,6 @@ static void register_element(gpointer data, gpointer user_data)
 	g_node_append_data(node, element);
 
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
-		set_signal_strength(element);
 		emit_connections_signal(connection);
 		emit_state_change(connection, "online");
 	}
@@ -1382,19 +1367,12 @@ void connman_element_unregister_children(struct connman_element *element)
 static gboolean update_element(GNode *node, gpointer user_data)
 {
 	struct connman_element *element = node->data;
-	struct connman_element *root = user_data;
 
 	DBG("element %p name %s", element, element->name);
 
 	if (element->driver && element->driver->update)
 		element->driver->update(element);
 
-	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION &&
-				root->type == CONNMAN_ELEMENT_TYPE_NETWORK) {
-		if (element->strength != root->strength)
-			element->strength = root->strength;
-	}
-
 	emit_element_signal(connection, "ElementUpdated", element);
 
 	return FALSE;

commit 64af510378fbd97f37553dc47db96d55e281afae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 01:40:06 2009 +0100

    Add support for showing flight mode

diff --git a/test/test-manager b/test/test-manager
index 09c6e19e..ea976cae 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -54,6 +54,12 @@ def print_properties(key, value):
 for key in properties.keys():
 	if key in ["Profiles", "Devices", "Connections"]:
 		print_properties(key, properties[key])
+	elif key in ["FlightMode"]:
+		print "%s" % (key)
+		if properties[key] == dbus.Boolean(1):
+			print "    true"
+		else:
+			print "    false"
 	else:
 		print "%s" % (key)
 		print "    %s" % (properties[key])

commit b8df778e082b32d410f8c5f7a42a59de13427b1a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 02:05:30 2009 +0100

    Add support for basic flight mode implementation

diff --git a/src/connman.h b/src/connman.h
index df2b4c44..b160719b 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -157,6 +157,8 @@ void __connman_device_decrease_connections(struct connman_device *device);
 
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
+int __connman_device_set_flightmode(connman_bool_t flightmode);
+
 #include <connman/network.h>
 
 int __connman_network_init(void);
diff --git a/src/device.c b/src/device.c
index f6bad3b2..1d888e91 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1062,6 +1062,35 @@ const char *connman_device_get_string(struct connman_device *device,
 	return NULL;
 }
 
+static void set_flightmode(struct connman_element *element, gpointer user_data)
+{
+	struct connman_device *device = element->device;
+	connman_bool_t flightmode = GPOINTER_TO_UINT(user_data);
+	connman_bool_t powered;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (device == NULL)
+		return;
+
+	powered = (flightmode == TRUE) ? FALSE : TRUE;
+
+	if (device->powered == powered)
+		return;
+
+	set_powered(device, powered);
+}
+
+int __connman_device_set_flightmode(connman_bool_t flightmode)
+{
+	DBG("flightmode %d", flightmode);
+
+	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_DEVICE,
+				set_flightmode, GUINT_TO_POINTER(flightmode));
+
+	return 0;
+}
+
 void __connman_device_increase_connections(struct connman_device *device)
 {
 	device->connections++;
diff --git a/src/manager.c b/src/manager.c
index ec579ff5..71439742 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -27,6 +27,44 @@
 
 #include "connman.h"
 
+enum connman_policy {
+	CONNMAN_POLICY_UNKNOWN  = 0,
+	CONNMAN_POLICY_SINGLE   = 1,
+	CONNMAN_POLICY_MULTIPLE = 2,
+	CONNMAN_POLICY_ASK      = 3,
+};
+
+static enum connman_policy global_policy = CONNMAN_POLICY_SINGLE;
+static connman_bool_t global_flightmode = FALSE;
+
+static const char *policy2string(enum connman_policy policy)
+{
+	switch (policy) {
+	case CONNMAN_POLICY_UNKNOWN:
+		break;
+	case CONNMAN_POLICY_SINGLE:
+		return "single";
+	case CONNMAN_POLICY_MULTIPLE:
+		return "multiple";
+	case CONNMAN_POLICY_ASK:
+		return "ask";
+	}
+
+	return NULL;
+}
+
+static enum connman_policy string2policy(const char *policy)
+{
+	if (g_str_equal(policy, "single") == TRUE)
+		return CONNMAN_POLICY_SINGLE;
+	else if (g_str_equal(policy, "multiple") == TRUE)
+		return CONNMAN_POLICY_MULTIPLE;
+	else if (g_str_equal(policy, "ask") == TRUE)
+		return CONNMAN_POLICY_ASK;
+	else
+		return CONNMAN_POLICY_UNKNOWN;
+}
+
 static void append_profiles(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
@@ -110,7 +148,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 {
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	const char *state, *policy = "single";
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -131,21 +169,70 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	append_connections(&dict);
 
 	if (__connman_element_count(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION) > 0)
-		state = "online";
+		str = "online";
 	else
-		state = "offline";
+		str = "offline";
 
 	connman_dbus_dict_append_variant(&dict, "State",
-						DBUS_TYPE_STRING, &state);
+						DBUS_TYPE_STRING, &str);
 
-	connman_dbus_dict_append_variant(&dict, "Policy",
-						DBUS_TYPE_STRING, &policy);
+	str = policy2string(global_policy);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Policy",
+						DBUS_TYPE_STRING, &str);
+
+	connman_dbus_dict_append_variant(&dict, "FlightMode",
+					DBUS_TYPE_BOOLEAN, &global_flightmode);
 
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
 }
 
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBusMessageIter iter, value;
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
+	if (g_str_equal(name, "Policy") == TRUE) {
+		enum connman_policy policy;
+		const char *str;
+
+		dbus_message_iter_get_basic(&value, &str);
+		policy = string2policy(str);
+		if (policy == CONNMAN_POLICY_UNKNOWN)
+			return __connman_error_invalid_arguments(msg);
+
+		global_policy = policy;
+	} else if (g_str_equal(name, "FlightMode") == TRUE) {
+		connman_bool_t flightmode;
+
+		dbus_message_iter_get_basic(&value, &flightmode);
+
+		if (global_flightmode == flightmode)
+			return __connman_error_invalid_arguments(msg);
+
+		global_flightmode = flightmode;
+
+		__connman_device_set_flightmode(flightmode);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *register_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -195,9 +282,10 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 }
 
 static GDBusMethodTable manager_methods[] = {
-	{ "GetProperties",   "",  "a{sv}", get_properties   },
-	{ "RegisterAgent",   "o", "",      register_agent   },
-	{ "UnregisterAgent", "o", "",      unregister_agent },
+	{ "GetProperties",   "",   "a{sv}", get_properties   },
+	{ "SetProperty",     "sv", "",      set_property     },
+	{ "RegisterAgent",   "o",  "",      register_agent   },
+	{ "UnregisterAgent", "o",  "",      unregister_agent },
 	{ },
 };
 

commit 681c8374ac7caf872a863ad8923df72b47495b02
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 03:04:54 2009 +0100

    Add support for device priority setting

diff --git a/doc/device-api.txt b/doc/device-api.txt
index 6d8f348a..b0cf440e 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -87,6 +87,11 @@ Properties	string Name [readonly]
 			For simple devices like Ethernet cards, setting
 			the "manual" policy might fail.
 
+		uint8 Priority [readwrite]
+
+			The device priority. Higher values indicate the
+			preference for this device.
+
 		boolean Powered [readwrite]
 
 			Switch a device on or off. This will also modify
diff --git a/src/device.c b/src/device.c
index 1d888e91..f07128f7 100644
--- a/src/device.c
+++ b/src/device.c
@@ -36,6 +36,7 @@ struct connman_device {
 	connman_bool_t powered;
 	connman_bool_t carrier;
 	connman_bool_t scanning;
+	connman_uint8_t priority;
 	char *name;
 	char *node;
 	char *interface;
@@ -277,6 +278,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Policy",
 						DBUS_TYPE_STRING, &str);
 
+	if (device->priority > 0)
+		connman_dbus_dict_append_variant(&dict, "Priority",
+					DBUS_TYPE_BYTE, &device->priority);
+
 	connman_dbus_dict_append_variant(&dict, "Powered",
 					DBUS_TYPE_BOOLEAN, &device->powered);
 
@@ -346,6 +351,12 @@ static DBusMessage *set_property(DBusConnection *conn,
 		err = set_policy(conn, device, policy);
 		if (err < 0)
 			return __connman_error_failed(msg);
+	} else if (g_str_equal(name, "Priority") == TRUE) {
+		connman_uint8_t priority;
+
+		dbus_message_iter_get_basic(&value, &priority);
+
+		device->priority = priority;
 	}
 
 	__connman_storage_save_device(device);
@@ -710,6 +721,29 @@ struct connman_device *connman_device_create(const char *node,
 	device->mode   = CONNMAN_DEVICE_MODE_UNKNOWN;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
 
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+		device->priority = 0;
+		break;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+		device->priority = 100;
+		break;
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+		device->priority = 20;
+		break;
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+		device->priority = 50;
+		break;
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+		device->priority = 60;
+		break;
+	}
+
 	device->networks = g_hash_table_new_full(g_str_hash, g_str_equal,
 						g_free, unregister_network);
 
@@ -1295,6 +1329,7 @@ static int device_load(struct connman_device *device)
 	gchar *pathname, *data = NULL;
 	gsize length;
 	char *str;
+	int val;
 
 	DBG("device %p", device);
 
@@ -1326,6 +1361,11 @@ static int device_load(struct connman_device *device)
 		g_free(str);
 	}
 
+	val = g_key_file_get_integer(keyfile, "Configuration",
+							"Priority", NULL);
+	if (val > 0)
+		device->priority = val;
+
 	g_key_file_free(keyfile);
 
 	return 0;
@@ -1363,6 +1403,10 @@ update:
 	if (str != NULL)
 		g_key_file_set_string(keyfile, "Configuration", "Policy", str);
 
+	if (device->priority > 0)
+		g_key_file_set_integer(keyfile, "Configuration",
+						"Priority", device->priority);
+
 	data = g_key_file_to_data(keyfile, &length, NULL);
 
 	g_file_set_contents(pathname, data, length, NULL);
diff --git a/test/list-connections b/test/list-connections
index a656e964..655e50a5 100755
--- a/test/list-connections
+++ b/test/list-connections
@@ -18,7 +18,7 @@ for path in properties["Connections"]:
 	print "[ %s ]" % (path)
 
 	for key in properties.keys():
-		if key == "Strength":
+		if key in ["Strength", "Priority"]:
 			val = int(properties[key])
 		else:
 			val = str(properties[key])
diff --git a/test/list-networks b/test/list-networks
index f4d5075f..e8fb00a5 100755
--- a/test/list-networks
+++ b/test/list-networks
@@ -43,10 +43,10 @@ for path in properties["Devices"]:
 		print "    [ %s ]" % (path)
 
 		for key in properties.keys():
-			if (key == "WiFi.SSID"):
+			if key == "WiFi.SSID":
 				ssid = convert_ssid(properties[key])
 				print "        %s = [ %s ]" % (key, ssid)
-			elif (key == "Strength"):
+			elif key in ["Strength", "Priority"]:
 				print "        %s = %d" % (key, properties[key])
 			else:
 				print "        %s = %s" % (key, properties[key])
diff --git a/test/monitor-connman b/test/monitor-connman
index 97d3a6b5..886373ac 100755
--- a/test/monitor-connman
+++ b/test/monitor-connman
@@ -7,7 +7,7 @@ import dbus.mainloop.glib
 
 def property_changed(name, value, path, interface):
 	iface = interface[interface.rfind(".") + 1:]
-	if (name == "Strength"):
+	if name in ["Strength", "Priority"]:
 		val = int(value)
 	else:
 		val = str(value)
diff --git a/test/test-manager b/test/test-manager
index ea976cae..e9f12313 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -37,7 +37,7 @@ def print_properties(key, value):
 					val = "true"
 				else:
 					val = "false"
-			elif key == "Strength":
+			elif key in ["Strength", "Priority"]:
 				val = int(properties[key])
 			else:
 				val = str(properties[key])

commit d2af3f8619ab6c62a9398a963a07bf04180eaf61
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 20:13:56 2009 +0100

    Fix handling of WiFi scanning state

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index bc83be9f..23acd086 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -47,15 +47,101 @@
 #define SUPPLICANT_INTF  "fi.epitest.hostap.WPASupplicant"
 #define SUPPLICANT_PATH  "/fi/epitest/hostap/WPASupplicant"
 
+/* Taken from "WPA Supplicant - Common definitions" */
 enum supplicant_state {
-	STATE_INACTIVE,
-	STATE_SCANNING,
-	STATE_ASSOCIATING,
-	STATE_ASSOCIATED,
-	STATE_4WAY_HANDSHAKE,
-	STATE_GROUP_HANDSHAKE,
-	STATE_COMPLETED,
-	STATE_DISCONNECTED,
+	/**
+	 * WPA_DISCONNECTED - Disconnected state
+	 *
+	 * This state indicates that client is not associated, but is likely to
+	 * start looking for an access point. This state is entered when a
+	 * connection is lost.
+	 */
+	WPA_DISCONNECTED,
+
+	/**
+	 * WPA_INACTIVE - Inactive state (wpa_supplicant disabled)
+	 *
+	 * This state is entered if there are no enabled networks in the
+	 * configuration. wpa_supplicant is not trying to associate with a new
+	 * network and external interaction (e.g., ctrl_iface call to add or
+	 * enable a network) is needed to start association.
+	 */
+	WPA_INACTIVE,
+
+	/**
+	 * WPA_SCANNING - Scanning for a network
+	 *
+	 * This state is entered when wpa_supplicant starts scanning for a
+	 * network.
+	 */
+	WPA_SCANNING,
+
+	/**
+	 * WPA_ASSOCIATING - Trying to associate with a BSS/SSID
+	 *
+	 * This state is entered when wpa_supplicant has found a suitable BSS
+	 * to associate with and the driver is configured to try to associate
+	 * with this BSS in ap_scan=1 mode. When using ap_scan=2 mode, this
+	 * state is entered when the driver is configured to try to associate
+	 * with a network using the configured SSID and security policy.
+	 */
+	WPA_ASSOCIATING,
+
+	/**
+	 * WPA_ASSOCIATED - Association completed
+	 *
+	 * This state is entered when the driver reports that association has
+	 * been successfully completed with an AP. If IEEE 802.1X is used
+	 * (with or without WPA/WPA2), wpa_supplicant remains in this state
+	 * until the IEEE 802.1X/EAPOL authentication has been completed.
+	 */
+	WPA_ASSOCIATED,
+
+	/**
+	 * WPA_4WAY_HANDSHAKE - WPA 4-Way Key Handshake in progress
+	 *
+	 * This state is entered when WPA/WPA2 4-Way Handshake is started. In
+	 * case of WPA-PSK, this happens when receiving the first EAPOL-Key
+	 * frame after association. In case of WPA-EAP, this state is entered
+	 * when the IEEE 802.1X/EAPOL authentication has been completed.
+	 */
+	WPA_4WAY_HANDSHAKE,
+
+	/**
+	 * WPA_GROUP_HANDSHAKE - WPA Group Key Handshake in progress
+	 *
+	 * This state is entered when 4-Way Key Handshake has been completed
+	 * (i.e., when the supplicant sends out message 4/4) and when Group
+	 * Key rekeying is started by the AP (i.e., when supplicant receives
+	 * message 1/2).
+	 */
+	WPA_GROUP_HANDSHAKE,
+
+	/**
+	 * WPA_COMPLETED - All authentication completed
+	 *
+	 * This state is entered when the full authentication process is
+	 * completed. In case of WPA2, this happens when the 4-Way Handshake is
+	 * successfully completed. With WPA, this state is entered after the
+	 * Group Key Handshake; with IEEE 802.1X (non-WPA) connection is
+	 * completed after dynamic keys are received (or if not used, after
+	 * the EAP authentication has been completed). With static WEP keys and
+	 * plaintext connections, this state is entered when an association
+	 * has been completed.
+	 *
+	 * This state indicates that the supplicant has completed its
+	 * processing for the association phase and that data connection is
+	 * fully configured.
+	 */
+	WPA_COMPLETED,
+
+	/**
+	 * WPA_INVALID - Invalid state (parsing error)
+	 *
+	 * This state is returned if the string input is invalid. It is not
+	 * an official wpa_supplicant state.
+	 */
+	WPA_INVALID,
 };
 
 struct supplicant_result {
@@ -82,7 +168,7 @@ struct supplicant_task {
 	char *netpath;
 	gboolean created;
 	enum supplicant_state state;
-	gboolean doscan;
+	gboolean noscan;
 	GSList *scan_results;
 };
 
@@ -750,7 +836,7 @@ static void extract_capabilites(DBusMessageIter *value,
 		result->has_wep = TRUE;
 }
 
-static int get_properties(struct supplicant_task *task);
+static void get_properties(struct supplicant_task *task);
 
 static void properties_reply(DBusPendingCall *call, void *user_data)
 {
@@ -771,6 +857,12 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		return;
 	}
 
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		dbus_message_unref(reply);
+		get_properties(task);
+		return;
+	}
+
 	memset(&result, 0, sizeof(result));
 
 	dbus_message_iter_init(reply, &array);
@@ -899,18 +991,15 @@ done:
 	get_properties(task);
 }
 
-static int get_properties(struct supplicant_task *task)
+static void get_properties(struct supplicant_task *task)
 {
 	DBusMessage *message;
 	DBusPendingCall *call;
 	char *path;
 
 	path = g_slist_nth_data(task->scan_results, 0);
-	if (path == NULL) {
-		if (task->doscan == FALSE)
-			connman_device_set_scanning(task->device, FALSE);
-		return 0;
-	}
+	if (path == NULL)
+		goto noscan;
 
 	message = dbus_message_new_method_call(SUPPLICANT_NAME, path,
 						SUPPLICANT_INTF ".BSSID",
@@ -920,20 +1009,24 @@ static int get_properties(struct supplicant_task *task)
 	g_free(path);
 
 	if (message == NULL)
-		return -ENOMEM;
+		goto noscan;
 
 	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to get network properties");
 		dbus_message_unref(message);
-		return -EIO;
+		goto noscan;
 	}
 
 	dbus_pending_call_set_notify(call, properties_reply, task, NULL);
 
 	dbus_message_unref(message);
 
-	return 0;
+	return;
+
+noscan:
+	if (task->noscan == FALSE)
+		connman_device_set_scanning(task->device, FALSE);
 }
 
 static void scan_results_reply(DBusPendingCall *call, void *user_data)
@@ -947,11 +1040,11 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 	DBG("task %p", task);
 
 	reply = dbus_pending_call_steal_reply(call);
-	if (reply == NULL) {
-		if (task->doscan == FALSE)
-			connman_device_set_scanning(task->device, FALSE);
-		return;
-	}
+	if (reply == NULL)
+		goto noscan;
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR)
+		goto done;
 
 	dbus_error_init(&error);
 
@@ -964,11 +1057,12 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 			dbus_error_free(&error);
 		} else
 			connman_error("Wrong arguments for scan result");
-		if (task->doscan == FALSE)
-			connman_device_set_scanning(task->device, FALSE);
 		goto done;
 	}
 
+	if (num_results == 0)
+		goto done;
+
 	for (i = 0; i < num_results; i++) {
 		char *path = g_strdup(results[i]);
 		if (path == NULL)
@@ -979,13 +1073,21 @@ static void scan_results_reply(DBusPendingCall *call, void *user_data)
 
 	g_strfreev(results);
 
+	dbus_message_unref(reply);
+
 	get_properties(task);
 
+	return;
+
 done:
 	dbus_message_unref(reply);
+
+noscan:
+	if (task->noscan == FALSE)
+		connman_device_set_scanning(task->device, FALSE);
 }
 
-static int scan_results_available(struct supplicant_task *task)
+static void scan_results_available(struct supplicant_task *task)
 {
 	DBusMessage *message;
 	DBusPendingCall *call;
@@ -996,33 +1098,55 @@ static int scan_results_available(struct supplicant_task *task)
 						SUPPLICANT_INTF ".Interface",
 							"scanResults");
 	if (message == NULL)
-		return -ENOMEM;
+		return;
 
 	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to request scan result");
-		dbus_message_unref(message);
-		return -EIO;
+		goto done;
 	}
 
-	connman_device_set_scanning(task->device, TRUE);
+	if (task->noscan == FALSE)
+		connman_device_set_scanning(task->device, TRUE);
 
 	dbus_pending_call_set_notify(call, scan_results_reply, task, NULL);
 
+done:
 	dbus_message_unref(message);
+}
 
-	return 0;
+static enum supplicant_state string2state(const char *state)
+{
+	if (g_str_equal(state, "INACTIVE") == TRUE)
+		return WPA_INACTIVE;
+	else if (g_str_equal(state, "SCANNING") == TRUE)
+		return WPA_SCANNING;
+	else if (g_str_equal(state, "ASSOCIATING") == TRUE)
+		return WPA_ASSOCIATING;
+	else if (g_str_equal(state, "ASSOCIATED") == TRUE)
+		return WPA_ASSOCIATED;
+	else if (g_str_equal(state, "GROUP_HANDSHAKE") == TRUE)
+		return WPA_GROUP_HANDSHAKE;
+	else if (g_str_equal(state, "4WAY_HANDSHAKE") == TRUE)
+		return WPA_4WAY_HANDSHAKE;
+	else if (g_str_equal(state, "COMPLETED") == TRUE)
+		return WPA_COMPLETED;
+	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
+		return WPA_DISCONNECTED;
+	else
+		return WPA_INVALID;
 }
 
 static void state_change(struct supplicant_task *task, DBusMessage *msg)
 {
 	DBusError error;
-	const char *state, *previous;
+	const char *newstate, *oldstate;
+	enum supplicant_state state;
 
 	dbus_error_init(&error);
 
-	if (dbus_message_get_args(msg, &error, DBUS_TYPE_STRING, &state,
-						DBUS_TYPE_STRING, &previous,
+	if (dbus_message_get_args(msg, &error, DBUS_TYPE_STRING, &newstate,
+						DBUS_TYPE_STRING, &oldstate,
 						DBUS_TYPE_INVALID) == FALSE) {
 		if (dbus_error_is_set(&error) == TRUE) {
 			connman_error("%s", error.message);
@@ -1032,44 +1156,50 @@ static void state_change(struct supplicant_task *task, DBusMessage *msg)
 		return;
 	}
 
-	DBG("state %s ==> %s", previous, state);
+	DBG("state %s ==> %s", oldstate, newstate);
 
-	if (g_str_equal(state, "INACTIVE") == TRUE)
-		task->state = STATE_INACTIVE;
-	else if (g_str_equal(state, "SCANNING") == TRUE)
-		task->state = STATE_SCANNING;
-	else if (g_str_equal(state, "ASSOCIATING") == TRUE)
-		task->state = STATE_ASSOCIATING;
-	else if (g_str_equal(state, "ASSOCIATED") == TRUE)
-		task->state = STATE_ASSOCIATED;
-	else if (g_str_equal(state, "GROUP_HANDSHAKE") == TRUE)
-		task->state = STATE_GROUP_HANDSHAKE;
-	else if (g_str_equal(state, "4WAY_HANDSHAKE") == TRUE)
-		task->state = STATE_4WAY_HANDSHAKE;
-	else if (g_str_equal(state, "COMPLETED") == TRUE)
-		task->state = STATE_COMPLETED;
-	else if (g_str_equal(state, "DISCONNECTED") == TRUE)
-		task->state = STATE_DISCONNECTED;
+	state = string2state(newstate);
+	if (state == WPA_INVALID)
+		return;
+
+	task->state = state;
 
-	if (task->state == STATE_SCANNING) {
-		task->doscan = TRUE;
+	switch (task->state) {
+	case WPA_SCANNING:
+		task->noscan = TRUE;
 		connman_device_set_scanning(task->device, TRUE);
-	} else if (task->state == STATE_INACTIVE) {
-		task->doscan = FALSE;
+		break;
+	case WPA_ASSOCIATING:
+	case WPA_ASSOCIATED:
+	case WPA_4WAY_HANDSHAKE:
+	case WPA_GROUP_HANDSHAKE:
+		task->noscan = TRUE;
+		break;
+	case WPA_COMPLETED:
+	case WPA_DISCONNECTED:
+		task->noscan = FALSE;
+		break;
+	case WPA_INACTIVE:
+		task->noscan = FALSE;
 		connman_device_set_scanning(task->device, FALSE);
+		break;
+	case WPA_INVALID:
+		break;
 	}
 
 	if (task->network == NULL)
 		return;
 
 	switch (task->state) {
-	case STATE_COMPLETED:
+	case WPA_COMPLETED:
 		/* carrier on */
 		connman_network_set_connected(task->network, TRUE);
+		connman_device_set_scanning(task->device, FALSE);
 		break;
-	case STATE_DISCONNECTED:
+	case WPA_DISCONNECTED:
 		/* carrier off */
 		connman_network_set_connected(task->network, FALSE);
+		connman_device_set_scanning(task->device, FALSE);
 		break;
 	default:
 		break;
@@ -1128,7 +1258,8 @@ int supplicant_start(struct connman_device *device)
 	}
 
 	task->created = FALSE;
-	task->state = STATE_INACTIVE;
+	task->noscan = FALSE;
+	task->state = WPA_INVALID;
 
 	task_list = g_slist_append(task_list, task);
 
@@ -1168,12 +1299,12 @@ int supplicant_scan(struct connman_device *device)
 		return -ENODEV;
 
 	switch (task->state) {
-	case STATE_SCANNING:
+	case WPA_SCANNING:
 		return -EALREADY;
-	case STATE_ASSOCIATING:
-	case STATE_ASSOCIATED:
-	case STATE_4WAY_HANDSHAKE:
-	case STATE_GROUP_HANDSHAKE:
+	case WPA_ASSOCIATING:
+	case WPA_ASSOCIATED:
+	case WPA_4WAY_HANDSHAKE:
+	case WPA_GROUP_HANDSHAKE:
 		return -EBUSY;
 	default:
 		break;

commit 0dd6156eaf461a25781a9f0b7dd727e03c6172b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 20:27:15 2009 +0100

    Protect Connect and Disconnect with security policy

diff --git a/src/network.c b/src/network.c
index 99bb40b8..4af71c37 100644
--- a/src/network.c
+++ b/src/network.c
@@ -185,6 +185,9 @@ static DBusMessage *do_connect(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
 	if (network->connected == TRUE)
 		return __connman_error_failed(msg);
 
@@ -206,6 +209,9 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (__connman_security_check_privileges(msg) < 0)
+		return __connman_error_permission_denied(msg);
+
 	if (network->connected == FALSE)
 		return __connman_error_failed(msg);
 

commit 77b134b5f3f2856cd6a915904b9ff3b207654c71
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 21:20:50 2009 +0100

    Add support for different security privileges

diff --git a/include/security.h b/include/security.h
index 123e6fb3..9e27a5f2 100644
--- a/include/security.h
+++ b/include/security.h
@@ -32,6 +32,12 @@ extern "C" {
  * @short_description: Functions for registering security modules
  */
 
+enum connman_security_privilege {
+	CONNMAN_SECURITY_PRIVILEGE_PUBLIC  = 0,
+	CONNMAN_SECURITY_PRIVILEGE_MODIFY  = 1,
+	CONNMAN_SECURITY_PRIVILEGE_SECRET  = 2,
+};
+
 #define CONNMAN_SECURITY_PRIORITY_LOW      -100
 #define CONNMAN_SECURITY_PRIORITY_DEFAULT     0
 #define CONNMAN_SECURITY_PRIORITY_HIGH      100
@@ -39,7 +45,8 @@ extern "C" {
 struct connman_security {
 	const char *name;
 	int priority;
-	int (*authorize_sender) (const char *sender);
+	int (*authorize_sender) (const char *sender,
+				enum connman_security_privilege privilege);
 };
 
 extern int connman_security_register(struct connman_security *security);
diff --git a/plugins/connman.policy b/plugins/connman.policy
index 1b34381b..bc36a6dd 100644
--- a/plugins/connman.policy
+++ b/plugins/connman.policy
@@ -6,10 +6,10 @@
 <policyconfig>
 
   <vendor>Connection Manager</vendor>
-  <icon_name>stock_internet</icon_name>
+  <icon_name>network-wireless</icon_name>
 
   <action id="org.moblin.connman.modify">
-    <description>Modify configuration</description>
+    <description>Settings configuration</description>
     <message>Policy prevents modification of settings</message>
     <defaults>
       <allow_inactive>no</allow_inactive>
@@ -17,9 +17,9 @@
     </defaults>
   </action>
 
-  <action id="org.moblin.connman.passphrase">
-    <description>Passphrase configuration</description>
-    <message>Policy prevents modification of passphrases</message>
+  <action id="org.moblin.connman.secret">
+    <description>Secrets configuration</description>
+    <message>Policy prevents modification of secrets</message>
     <defaults>
       <allow_inactive>no</allow_inactive>
       <allow_active>auth_admin_keep_always</allow_active>
diff --git a/plugins/polkit.c b/plugins/polkit.c
index d3ca6924..de183a27 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -34,20 +34,34 @@
 #include <connman/dbus.h>
 #include <connman/log.h>
 
-#define ACTION "org.moblin.connman.modify"
+#define ACTION_MODIFY "org.moblin.connman.modify"
+#define ACTION_SECRET "org.moblin.connman.secret"
 
 static DBusConnection *connection;
 static PolKitContext *polkit_context;
 
-static int polkit_authorize(const char *sender)
+static int polkit_authorize(const char *sender,
+				enum connman_security_privilege privilege)
 {
 	DBusError error;
 	PolKitCaller *caller;
 	PolKitAction *action;
 	PolKitResult result;
+	const char *id;
 
 	DBG("sender %s", sender);
 
+	switch (privilege) {
+	case CONNMAN_SECURITY_PRIVILEGE_PUBLIC:
+		return 0;
+	case CONNMAN_SECURITY_PRIVILEGE_MODIFY:
+		id = ACTION_MODIFY;
+		break;
+	case CONNMAN_SECURITY_PRIVILEGE_SECRET:
+		id = ACTION_SECRET;
+		break;
+	}
+
 	dbus_error_init(&error);
 
 	caller = polkit_caller_new_from_dbus_name(connection, sender, &error);
@@ -61,7 +75,7 @@ static int polkit_authorize(const char *sender)
 	}
 
 	action = polkit_action_new();
-	polkit_action_set_action_id(action, ACTION);
+	polkit_action_set_action_id(action, id);
 
 	result = polkit_context_is_caller_authorized(polkit_context,
 						action, caller, TRUE, NULL);
diff --git a/src/connection.c b/src/connection.c
index 0b3e59c4..ad381470 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -211,6 +211,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_PUBLIC) < 0)
+		return __connman_error_permission_denied(msg);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
@@ -286,7 +290,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 	dbus_message_iter_next(&iter);
 	dbus_message_iter_recurse(&iter, &value);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
diff --git a/src/connman.h b/src/connman.h
index b160719b..f98fc790 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -67,7 +67,8 @@ void __connman_plugin_cleanup(void);
 
 #include <connman/security.h>
 
-int __connman_security_check_privileges(DBusMessage *message);
+int __connman_security_check_privilege(DBusMessage *message,
+				enum connman_security_privilege privilege);
 
 #include <connman/ipv4.h>
 
diff --git a/src/device.c b/src/device.c
index f07128f7..d865ad47 100644
--- a/src/device.c
+++ b/src/device.c
@@ -244,6 +244,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_PUBLIC) < 0)
+		return __connman_error_permission_denied(msg);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
@@ -323,7 +327,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 	dbus_message_iter_next(&iter);
 	dbus_message_iter_recurse(&iter, &value);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	if (g_str_equal(name, "Powered") == TRUE) {
@@ -369,7 +374,8 @@ static DBusMessage *create_network(DBusConnection *conn,
 {
 	DBG("conn %p", conn);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	return __connman_error_invalid_arguments(msg);
@@ -380,7 +386,8 @@ static DBusMessage *remove_network(DBusConnection *conn,
 {
 	DBG("conn %p", conn);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	return __connman_error_invalid_arguments(msg);
diff --git a/src/manager.c b/src/manager.c
index 71439742..f943720e 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -152,6 +152,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_PUBLIC) < 0)
+		return __connman_error_permission_denied(msg);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
@@ -204,7 +208,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 	dbus_message_iter_next(&iter);
 	dbus_message_iter_recurse(&iter, &value);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	if (g_str_equal(name, "Policy") == TRUE) {
diff --git a/src/network.c b/src/network.c
index 4af71c37..7b0ed7a4 100644
--- a/src/network.c
+++ b/src/network.c
@@ -83,6 +83,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_PUBLIC) < 0)
+		return __connman_error_permission_denied(msg);
+
 	reply = dbus_message_new_method_return(msg);
 	if (reply == NULL)
 		return NULL;
@@ -153,7 +157,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 	dbus_message_iter_next(&iter);
 	dbus_message_iter_recurse(&iter, &value);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	if (g_str_equal(name, "Remember") == TRUE) {
@@ -185,7 +190,8 @@ static DBusMessage *do_connect(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	if (network->connected == TRUE)
@@ -209,7 +215,8 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 
 	DBG("conn %p", conn);
 
-	if (__connman_security_check_privileges(msg) < 0)
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
 	if (network->connected == FALSE)
diff --git a/src/security.c b/src/security.c
index 31c7734b..9b274239 100644
--- a/src/security.c
+++ b/src/security.c
@@ -66,7 +66,8 @@ void connman_security_unregister(struct connman_security *security)
 	security_list = g_slist_remove(security_list, security);
 }
 
-int __connman_security_check_privileges(DBusMessage *message)
+int __connman_security_check_privilege(DBusMessage *message,
+				enum connman_security_privilege privilege)
 {
 	GSList *list;
 	const char *sender;
@@ -82,7 +83,7 @@ int __connman_security_check_privileges(DBusMessage *message)
 		DBG("%s", security->name);
 
 		if (security->authorize_sender) {
-			err = security->authorize_sender(sender);
+			err = security->authorize_sender(sender, privilege);
 			break;
 		}
 	}

commit 4164f01e263c846434b2bd48649edd2f88a8af91
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 21:24:55 2009 +0100

    Restrict passphrase access to secret privilege

diff --git a/src/network.c b/src/network.c
index 7b0ed7a4..cf641e2d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -132,7 +132,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "WiFi.Security",
 				DBUS_TYPE_STRING, &network->wifi.security);
 
-	if (network->wifi.passphrase != NULL)
+	if (network->wifi.passphrase != NULL &&
+			__connman_security_check_privilege(msg,
+				CONNMAN_SECURITY_PRIVILEGE_SECRET) == 0)
 		connman_dbus_dict_append_variant(&dict, "WiFi.Passphrase",
 				DBUS_TYPE_STRING, &network->wifi.passphrase);
 
@@ -171,6 +173,10 @@ static DBusMessage *set_property(DBusConnection *conn,
 	} else if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
 		const char *passphrase;
 
+		if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_SECRET) < 0)
+			return __connman_error_permission_denied(msg);
+
 		dbus_message_iter_get_basic(&value, &passphrase);
 
 		g_free(network->wifi.passphrase);

commit ad004e33439795c2809aea26463bd440c17e3bf0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 6 21:34:51 2009 +0100

    Fix missing signal for connected state changes

diff --git a/src/network.c b/src/network.c
index cf641e2d..3e20245a 100644
--- a/src/network.c
+++ b/src/network.c
@@ -532,6 +532,10 @@ void connman_network_set_protocol(struct connman_network *network,
 int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected)
 {
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Connected";
+
 	DBG("network %p connected %d", network, connected);
 
 	if (network->connected == connected)
@@ -539,6 +543,22 @@ int connman_network_set_connected(struct connman_network *network,
 
 	network->connected = connected;
 
+	signal = dbus_message_new_signal(network->element.path,
+				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return 0;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN, &connected);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+
 	if (connected == TRUE) {
 		struct connman_element *element;
 		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;

commit 6f24662363c391c653d4a90518b0ff664f3ae5c4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 02:17:35 2009 +0100

    Add support for setting network availability

diff --git a/include/network.h b/include/network.h
index 70b7c35b..5c62502f 100644
--- a/include/network.h
+++ b/include/network.h
@@ -67,6 +67,8 @@ extern int connman_network_get_index(struct connman_network *network);
 extern void connman_network_set_protocol(struct connman_network *network,
 					enum connman_network_protocol protocol);
 
+extern int connman_network_set_available(struct connman_network *network,
+						connman_bool_t available);
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
 extern connman_bool_t connman_network_get_remember(struct connman_network *network);
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 23acd086..f9101066 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -977,6 +977,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		}
 	}
 
+	connman_network_set_available(network, TRUE);
 	connman_network_set_uint8(network, "Strength", strength);
 
 	connman_network_set_string(network, "WiFi.Security", security);
diff --git a/src/network.c b/src/network.c
index 3e20245a..a4f777ec 100644
--- a/src/network.c
+++ b/src/network.c
@@ -33,6 +33,7 @@ struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
 	enum connman_network_protocol protocol;
+	connman_bool_t available;
 	connman_bool_t connected;
 	connman_bool_t remember;
 	connman_uint8_t strength;
@@ -109,6 +110,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Name",
 					DBUS_TYPE_STRING, &network->name);
 
+	connman_dbus_dict_append_variant(&dict, "Available",
+				DBUS_TYPE_BOOLEAN, &network->available);
+
 	connman_dbus_dict_append_variant(&dict, "Connected",
 				DBUS_TYPE_BOOLEAN, &network->connected);
 
@@ -522,6 +526,52 @@ void connman_network_set_protocol(struct connman_network *network,
 	network->protocol = protocol;
 }
 
+/**
+ * connman_network_set_available:
+ * @network: network structure
+ * @available: availability state
+ *
+ * Change availability state of network (in range)
+ */
+int connman_network_set_available(struct connman_network *network,
+						connman_bool_t available)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Available";
+
+	DBG("network %p available %d", network, available);
+
+	if (network->available == available)
+		return -EALREADY;
+
+	network->available = available;
+
+	if (network->registered == FALSE)
+		return 0;
+
+	if (network->connected == FALSE && network->remember == FALSE)
+		return 0;
+
+	signal = dbus_message_new_signal(network->element.path,
+				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return 0;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN, &available);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+
+	return 0;
+}
+
 /**
  * connman_network_set_connected:
  * @network: network structure

commit 40c321540fce99a415c3bb49ced39a75399e1f5b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 02:18:20 2009 +0100

    Don't send signals for unregistered networks

diff --git a/src/network.c b/src/network.c
index a4f777ec..59c3e475 100644
--- a/src/network.c
+++ b/src/network.c
@@ -593,6 +593,9 @@ int connman_network_set_connected(struct connman_network *network,
 
 	network->connected = connected;
 
+	if (network->registered == FALSE)
+		return 0;
+
 	signal = dbus_message_new_signal(network->element.path,
 				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");
 	if (signal == NULL)

commit 27261f7a7c0c6299aafceae15c86f439af009b86
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 02:21:23 2009 +0100

    Add support for setting remember state

diff --git a/include/network.h b/include/network.h
index 5c62502f..7f32c3c7 100644
--- a/include/network.h
+++ b/include/network.h
@@ -71,6 +71,8 @@ extern int connman_network_set_available(struct connman_network *network,
 						connman_bool_t available);
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
+extern int connman_network_set_remember(struct connman_network *network,
+						connman_bool_t remember);
 extern connman_bool_t connman_network_get_remember(struct connman_network *network);
 
 extern int connman_network_connect(struct connman_network *network);
diff --git a/src/network.c b/src/network.c
index 59c3e475..e918b7a3 100644
--- a/src/network.c
+++ b/src/network.c
@@ -647,6 +647,49 @@ int connman_network_set_connected(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_set_remember:
+ * @network: network structure
+ * @remember: remember state
+ *
+ * Change remember state of network (known networks)
+ */
+int connman_network_set_remember(struct connman_network *network,
+						connman_bool_t remember)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Remember";
+
+	DBG("network %p remember %d", network, remember);
+
+	if (network->remember == remember)
+		return -EALREADY;
+
+	network->remember = remember;
+
+	if (network->registered == FALSE)
+		return 0;
+
+	signal = dbus_message_new_signal(network->element.path,
+				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return 0;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN, &remember);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+
+	return 0;
+}
+
 /**
  * connman_network_get_remember:
  * @network: network structure

commit c103c09d8716d7c59918c924b8de7b8b5b70cdda
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 03:37:41 2009 +0100

    Add support for getting network availability setting

diff --git a/include/network.h b/include/network.h
index 7f32c3c7..dd435eb4 100644
--- a/include/network.h
+++ b/include/network.h
@@ -69,6 +69,7 @@ extern void connman_network_set_protocol(struct connman_network *network,
 
 extern int connman_network_set_available(struct connman_network *network,
 						connman_bool_t available);
+extern connman_bool_t connman_network_get_available(struct connman_network *network);
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
 extern int connman_network_set_remember(struct connman_network *network,
diff --git a/src/network.c b/src/network.c
index e918b7a3..3a531ad1 100644
--- a/src/network.c
+++ b/src/network.c
@@ -572,6 +572,17 @@ int connman_network_set_available(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_get_available:
+ * @network: network structure
+ *
+ * Get network available setting
+ */
+connman_bool_t connman_network_get_available(struct connman_network *network)
+{
+	return network->available;
+}
+
 /**
  * connman_network_set_connected:
  * @network: network structure

commit cc62d0b1c13ce889b115c607ec206e3f0173e045
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 14:29:35 2009 +0100

    Add support for network priorities

diff --git a/src/network.c b/src/network.c
index 3a531ad1..f368ae80 100644
--- a/src/network.c
+++ b/src/network.c
@@ -36,6 +36,7 @@ struct connman_network {
 	connman_bool_t available;
 	connman_bool_t connected;
 	connman_bool_t remember;
+	connman_uint8_t priority;
 	connman_uint8_t strength;
 	char *identifier;
 	char *name;
@@ -119,6 +120,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Remember",
 				DBUS_TYPE_BOOLEAN, &network->remember);
 
+	if (network->priority > 0)
+		connman_dbus_dict_append_variant(&dict, "Priority",
+					DBUS_TYPE_BYTE, &network->priority);
+
 	if (network->strength > 0)
 		connman_dbus_dict_append_variant(&dict, "Strength",
 					DBUS_TYPE_BYTE, &network->strength);
@@ -185,6 +190,12 @@ static DBusMessage *set_property(DBusConnection *conn,
 
 		g_free(network->wifi.passphrase);
 		network->wifi.passphrase = g_strdup(passphrase);
+	} else if (g_str_equal(name, "Priority") == TRUE) {
+		connman_uint8_t priority;
+
+		dbus_message_iter_get_basic(&value, &priority);
+
+		network->priority = priority;
 	}
 
 	__connman_storage_save_network(network);
@@ -981,6 +992,7 @@ static int network_load(struct connman_network *network)
 	gchar *pathname, *data = NULL;
 	gsize length;
 	const char *name;
+	int val;
 
 	DBG("network %p", network);
 
@@ -1012,6 +1024,11 @@ static int network_load(struct connman_network *network)
 	network->remember = g_key_file_get_boolean(keyfile,
 					network->identifier, "Remember", NULL);
 
+	val = g_key_file_get_integer(keyfile, network->identifier,
+							"Priority", NULL);
+	if (val > 0)
+		network->priority = val;
+
 	g_free(network->wifi.security);
 	network->wifi.security = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Security", NULL);
@@ -1059,6 +1076,10 @@ update:
 	g_key_file_set_boolean(keyfile, network->identifier,
 					"Remember", network->remember);
 
+	if (network->priority > 0)
+		g_key_file_set_integer(keyfile, network->identifier,
+						"Priority", network->priority);
+
 	if (network->wifi.security != NULL)
 		g_key_file_set_string(keyfile, network->identifier,
 				"WiFi.Security", network->wifi.security);

commit fb423121afa4655615a496941c807323f16c9b9a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 14:30:44 2009 +0100

    Only store and load security details for known networks

diff --git a/src/network.c b/src/network.c
index f368ae80..2cf4f084 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1029,13 +1029,15 @@ static int network_load(struct connman_network *network)
 	if (val > 0)
 		network->priority = val;
 
-	g_free(network->wifi.security);
-	network->wifi.security = g_key_file_get_string(keyfile,
+	if (network->remember == TRUE) {
+		g_free(network->wifi.security);
+		network->wifi.security = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Security", NULL);
 
-	g_free(network->wifi.passphrase);
-	network->wifi.passphrase = g_key_file_get_string(keyfile,
+		g_free(network->wifi.passphrase);
+		network->wifi.passphrase = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Passphrase", NULL);
+	}
 
 	g_key_file_free(keyfile);
 
@@ -1080,13 +1082,15 @@ update:
 		g_key_file_set_integer(keyfile, network->identifier,
 						"Priority", network->priority);
 
-	if (network->wifi.security != NULL)
-		g_key_file_set_string(keyfile, network->identifier,
+	if (network->remember == TRUE) {
+		if (network->wifi.security != NULL)
+			g_key_file_set_string(keyfile, network->identifier,
 				"WiFi.Security", network->wifi.security);
 
-	if (network->wifi.passphrase != NULL)
-		g_key_file_set_string(keyfile, network->identifier,
+		if (network->wifi.passphrase != NULL)
+			g_key_file_set_string(keyfile, network->identifier,
 				"WiFi.Passphrase", network->wifi.passphrase);
+	}
 
 	data = g_key_file_to_data(keyfile, &length, NULL);
 

commit 0fc28e0291fd0d878a6605c7f62fcc7debfdbebe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 16:47:13 2009 +0100

    Add support for CONNMAN_VERSION declaration

diff --git a/configure.ac b/configure.ac
index 570d95f4..eafe9e61 100644
--- a/configure.ac
+++ b/configure.ac
@@ -209,6 +209,7 @@ AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
 		[enable fake device support]), [enable_fake=${enableval}])
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")
 
-AC_OUTPUT(Makefile gdbus/Makefile include/Makefile src/Makefile doc/Makefile
-		test/Makefile plugins/Makefile client/Makefile scripts/Makefile
-		scripts/connman src/connman.service doc/version.xml connman.pc)
+AC_OUTPUT(Makefile gdbus/Makefile include/Makefile include/version.h
+		src/Makefile src/connman.service scripts/connman
+		scripts/Makefile plugins/Makefile client/Makefile
+		test/Makefile doc/Makefile doc/version.xml connman.pc)
diff --git a/include/Makefile.am b/include/Makefile.am
index 84eece9e..2db02499 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -4,12 +4,20 @@ includedir = @includedir@/connman
 include_HEADERS = types.h log.h plugin.h security.h resolver.h \
 					storage.h device.h network.h
 
+nodist_include_HEADERS = version.h
+
 noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
 all-local:
-	@if [ ! -e connman ] ; then $(LN_S) $(top_srcdir)/include connman ; fi
+	@if [ ! -e connman ]; then \
+	  mkdir connman; \
+	  list='$(include_HEADERS) $(noinst_HEADERS)'; for i in $$list; \
+	    do cp $(top_srcdir)/include/$$i connman/; done; \
+	  list='$(nodist_include_HEADERS)'; for i in $$list; \
+	    do cp $(top_builddir)/include/$$i connman/; done; \
+	fi
 
 clean-local:
-	@rm -f connman
+	@rm -rf connman
diff --git a/include/plugin.h b/include/plugin.h
index 11a06095..d538dc7e 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -22,6 +22,8 @@
 #ifndef __CONNMAN_PLUGIN_H
 #define __CONNMAN_PLUGIN_H
 
+#include <connman/version.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/include/version.h.in b/include/version.h.in
new file mode 100644
index 00000000..c163f8ae
--- /dev/null
+++ b/include/version.h.in
@@ -0,0 +1,35 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_VERSION_H
+#define __CONNMAN_VERSION_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CONNMAN_VERSION	@VERSION@
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_VERSION_H */

commit 681cdd4a0c0bf186b9a0cca012992e8d654fd4ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:03:51 2009 +0100

    Only load plugins with the same version string

diff --git a/doc/plugin-api.txt b/doc/plugin-api.txt
index e329ced7..696e2c16 100644
--- a/doc/plugin-api.txt
+++ b/doc/plugin-api.txt
@@ -20,5 +20,5 @@ static void example_exit(void)
 {
 }
 
-CONNMAN_PLUGIN_DEFINE(example, "Example plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(example, "Example plugin", CONNMAN_VERSION,
 						example_init, example_exit)
diff --git a/include/plugin.h b/include/plugin.h
index d538dc7e..84e09586 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -69,7 +69,7 @@ struct connman_plugin_desc {
  * {
  * }
  *
- * CONNMAN_PLUGIN_DEFINE(example, "Example plugin", VERSION,
+ * CONNMAN_PLUGIN_DEFINE(example, "Example plugin", CONNMAN_VERSION,
  * 					example_init, example_exit)
  * ]|
  */
diff --git a/include/version.h.in b/include/version.h.in
index c163f8ae..5d44396f 100644
--- a/include/version.h.in
+++ b/include/version.h.in
@@ -26,7 +26,7 @@
 extern "C" {
 #endif
 
-#define CONNMAN_VERSION	@VERSION@
+#define CONNMAN_VERSION	"@VERSION@"
 
 #ifdef __cplusplus
 }
diff --git a/src/plugin.c b/src/plugin.c
index 2103b66e..7fb7d444 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -43,6 +43,9 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	if (desc->init == NULL)
 		return FALSE;
 
+	if (g_str_equal(desc->version, CONNMAN_VERSION) == FALSE)
+		return FALSE;
+
 	plugin = g_try_new0(struct connman_plugin, 1);
 	if (plugin == NULL)
 		return FALSE;

commit 7cfbb5b79dc8ec5524d8e78ab543c4597eeb3349
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:24:52 2009 +0100

    Add the generated version.h to ignore list

diff --git a/.gitignore b/.gitignore
index cff64720..8424ca8e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,6 +23,7 @@ autom4te.cache
 
 connman.pc
 include/connman
+src/version.h
 src/connmand
 src/connman.exp
 src/connman.ver

commit 0064506b824a1b7963d4fd1e136450453946a5e0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:25:25 2009 +0100

    Use priority and strength to select known network

diff --git a/include/network.h b/include/network.h
index dd435eb4..2232dfd3 100644
--- a/include/network.h
+++ b/include/network.h
@@ -84,6 +84,8 @@ extern const char *connman_network_get_string(struct connman_network *network,
 							const char *key);
 extern int connman_network_set_uint8(struct connman_network *network,
 					const char *key, connman_uint8_t value);
+extern connman_uint8_t connman_network_get_uint8(struct connman_network *network,
+							const char *key);
 extern int connman_network_set_blob(struct connman_network *network,
 			const char *key, const void *data, unsigned int size);
 extern const void *connman_network_get_blob(struct connman_network *network,
diff --git a/src/device.c b/src/device.c
index d865ad47..55e07f9d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -976,6 +976,7 @@ int connman_device_set_carrier(struct connman_device *device,
 
 static void connect_known_network(struct connman_device *device)
 {
+	struct connman_network *network = NULL;
 	GHashTableIter iter;
 	gpointer key, value;
 	unsigned int count = 0;
@@ -985,13 +986,37 @@ static void connect_known_network(struct connman_device *device)
 	g_hash_table_iter_init(&iter, device->networks);
 
 	while (g_hash_table_iter_next(&iter, &key, &value) == TRUE) {
-		struct connman_network *network = value;
-		int err;
+		connman_uint8_t old_priority, new_priority;
+		connman_uint8_t old_strength, new_strength;
 
 		count++;
 
-		if (connman_network_get_remember(network) == FALSE)
+		if (connman_network_get_remember(value) == FALSE)
+			continue;
+
+		if (network == NULL) {
+			network = value;
+			continue;
+		}
+
+		old_priority = connman_network_get_uint8(network, "Priority");
+		new_priority = connman_network_get_uint8(value, "Priority");
+
+		if (new_priority != old_priority) {
+			if (new_priority > old_priority)
+				network = value;
 			continue;
+		}
+
+		old_strength = connman_network_get_uint8(network, "Strength");
+		old_strength = connman_network_get_uint8(value, "Strength");
+
+		if (new_strength > old_strength)
+			network = value;
+	}
+
+	if (network != NULL) {
+		int err;
 
 		err = connman_network_connect(network);
 		if (err == 0 || err == -EINPROGRESS)
diff --git a/src/network.c b/src/network.c
index 2cf4f084..2c6d6b88 100644
--- a/src/network.c
+++ b/src/network.c
@@ -814,7 +814,9 @@ int connman_network_set_uint8(struct connman_network *network,
 {
 	DBG("network %p key %s value %d", network, key, value);
 
-	if (g_str_equal(key, "Strength") == TRUE) {
+	if (g_str_equal(key, "Priority") == TRUE)
+		network->priority = value;
+	else if (g_str_equal(key, "Strength") == TRUE) {
 		network->strength = value;
 		connman_element_set_static_property(&network->element,
 					"Strength", DBUS_TYPE_BYTE, &value);
@@ -823,6 +825,26 @@ int connman_network_set_uint8(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_get_uint8:
+ * @network: network structure
+ * @key: unique identifier
+ *
+ * Get integer value for specific key
+ */
+connman_uint8_t connman_network_get_uint8(struct connman_network *network,
+							const char *key)
+{
+	DBG("network %p key %s", network, key);
+
+	if (g_str_equal(key, "Priority") == TRUE)
+		return network->priority;
+	else if (g_str_equal(key, "Strength") == TRUE)
+		return network->strength;
+
+	return 0;
+}
+
 /**
  * connman_network_set_blob:
  * @network: network structure

commit a48010072c90de9278b63fff0fbdf6e98f138517
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:31:48 2009 +0100

    Fix wrong assignment of strength value

diff --git a/src/device.c b/src/device.c
index 55e07f9d..4575dd22 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1009,7 +1009,7 @@ static void connect_known_network(struct connman_device *device)
 		}
 
 		old_strength = connman_network_get_uint8(network, "Strength");
-		old_strength = connman_network_get_uint8(value, "Strength");
+		new_strength = connman_network_get_uint8(value, "Strength");
 
 		if (new_strength > old_strength)
 			network = value;

commit f5b24ac0b5d57328cf8649dcdae73c40db2bb59e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:37:26 2009 +0100

    Install different D-Bus configuration if PolicyKit is enabled

diff --git a/.gitignore b/.gitignore
index 8424ca8e..7165e383 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,6 +27,7 @@ src/version.h
 src/connmand
 src/connman.exp
 src/connman.ver
+src/connman.conf
 src/connman.service
 src/*-connman.rules
 scripts/connman
diff --git a/src/Makefile.am b/src/Makefile.am
index a1cfcc2d..a540bf12 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -24,7 +24,7 @@ connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
 connmand_DEPENDENCIES = connman.ver
 
-CLEANFILES = connman.ver connman.exp 92-connman.rules
+CLEANFILES = connman.ver connman.exp connman.conf 92-connman.rules
 
 statedir = $(localstatedir)/run/connman
 
@@ -42,7 +42,7 @@ AM_CFLAGS = @UDEV_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
 						-DPLUGINDIR=\""$(plugindir)"\"
 INCLUDES = -I$(top_builddir)/include
 
-EXTRA_DIST = $(dbus_DATA) connman.rules
+EXTRA_DIST = connman-dbus.conf connman-polkit.conf connman.rules
 
 MAINTAINERCLEANFILES = Makefile.in
 
@@ -54,5 +54,12 @@ connman.ver: connman.exp
 	cat $< | sed -e "s/\(.*\)/\1;/" >> $@
 	echo "local: *; };" >> $@
 
+connman.conf: connman-dbus.conf connman-polkit.conf
+if POLKIT
+	cp $(top_srcdir)/src/connman-polkit.conf $@
+else
+	cp $(top_srcdir)/src/connman-dbus.conf $@
+endif
+
 92-connman.rules: connman.rules
 	cp $< $@
diff --git a/src/connman.conf b/src/connman-dbus.conf
similarity index 90%
rename from src/connman.conf
rename to src/connman-dbus.conf
index 55f76d6a..b4d4acd1 100644
--- a/src/connman.conf
+++ b/src/connman-dbus.conf
@@ -10,7 +10,6 @@
         <allow send_destination="org.moblin.connman"/>
     </policy>
     <policy context="default">
-        <!-- use "allow" with enabled PolicyKit support -->
         <deny send_destination="org.moblin.connman"/>
     </policy>
 </busconfig>
diff --git a/src/connman-polkit.conf b/src/connman-polkit.conf
new file mode 100644
index 00000000..9e44b8b5
--- /dev/null
+++ b/src/connman-polkit.conf
@@ -0,0 +1,11 @@
+<!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+    <policy user="root">
+        <allow own="org.moblin.connman"/>
+        <allow send_interface="org.moblin.connman.Agent"/>
+    </policy>
+    <policy context="default">
+        <allow send_destination="org.moblin.connman"/>
+    </policy>
+</busconfig>

commit 384be7749672d1ad9e3575d0885d2295d9afaa7c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:38:31 2009 +0100

    Fix wrong reference to version.h

diff --git a/.gitignore b/.gitignore
index 7165e383..76255d3c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,7 +23,7 @@ autom4te.cache
 
 connman.pc
 include/connman
-src/version.h
+include/version.h
 src/connmand
 src/connman.exp
 src/connman.ver

commit 70c75fa16808fe7cfd6d98af4770972ebaeee332
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:48:28 2009 +0100

    Change name of policy configuration file for PolicyKit

diff --git a/.gitignore b/.gitignore
index 76255d3c..11710f8d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -30,6 +30,7 @@ src/connman.ver
 src/connman.conf
 src/connman.service
 src/*-connman.rules
+plugins/connman.policy
 scripts/connman
 scripts/udhcpc-script
 scripts/dhclient-script
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index de4b58bc..fc0d2521 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -122,6 +122,11 @@ AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
-EXTRA_DIST = connman.policy
+EXTRA_DIST = polkit.policy
+
+CLEANFILES = polkit.policy
 
 MAINTAINERCLEANFILES = Makefile.in
+
+connman.policy: polkit.policy
+	cp $< $@
diff --git a/plugins/connman.policy b/plugins/polkit.policy
similarity index 100%
rename from plugins/connman.policy
rename to plugins/polkit.policy

commit b675c7d61e7d27bdbc233951a5a3ae947a4c2486
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 17:50:30 2009 +0100

    Remove connman.policy and not polkit.policy on cleanup

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index fc0d2521..b4c187b2 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -122,9 +122,9 @@ AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
-EXTRA_DIST = polkit.policy
+CLEANFILES = connman.policy
 
-CLEANFILES = polkit.policy
+EXTRA_DIST = polkit.policy
 
 MAINTAINERCLEANFILES = Makefile.in
 

commit cecbeca745ed26cd6742dc897135c28778008ef6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 18:27:36 2009 +0100

    Release 0.7

diff --git a/ChangeLog b/ChangeLog
index d41905e4..a0448911 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,16 @@
+ver 0.7:
+	Add basic support for flight mode.
+	Add support for multiple storage drivers.
+	Add support for RTNL newlink watch API.
+	Add support for different security privileges.
+	Add support for device and network priorities.
+	Add functions for setting network properties.
+	Fix issue with listing devices without a driver.
+	Fix issue with WiFi scanning indication.
+	Fix detection of WiFi security changes.
+	Update WiFi driver to use new network helpers.
+	Install different D-Bus configuration for PolicyKit.
+
 ver 0.6:
 	Add CONNMAN_API_SUBJECT_TO_CHANGE definition.
 	Add detailed configuration options.
diff --git a/configure.ac b/configure.ac
index eafe9e61..1d8fc5ed 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.6)
+AM_INIT_AUTOMAKE(connman, 0.7)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit b1d822465166dba78f8ad54837f106c3ec513631
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 20:24:16 2009 +0100

    Add support for storage setup callbacks

diff --git a/include/storage.h b/include/storage.h
index 9182675a..cd31b691 100644
--- a/include/storage.h
+++ b/include/storage.h
@@ -43,9 +43,11 @@ struct connman_storage {
 	const char *name;
 	int priority;
 	enum connman_device_type device_type;
+	int (*device_init) (void);
 	int (*device_load) (struct connman_device *device);
 	int (*device_save) (struct connman_device *device);
 	enum connman_network_type network_type;
+	int (*network_init) (struct connman_device *device);
 	int (*network_load) (struct connman_network *network);
 	int (*network_save) (struct connman_network *network);
 };
diff --git a/src/connman.h b/src/connman.h
index f98fc790..cca7ea8a 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -87,8 +87,10 @@ int __connman_resolver_selftest(void);
 int __connman_storage_init(void);
 void __connman_storage_cleanup(void);
 
+int __connman_storage_init_device();
 int __connman_storage_load_device(struct connman_device *device);
 int __connman_storage_save_device(struct connman_device *device);
+int __connman_storage_init_network();
 int __connman_storage_load_network(struct connman_network *network);
 int __connman_storage_save_network(struct connman_network *network);
 
diff --git a/src/device.c b/src/device.c
index 4575dd22..2a65e69a 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1250,6 +1250,16 @@ int connman_device_register(struct connman_device *device)
 {
 	__connman_storage_load_device(device);
 
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		break;
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		__connman_storage_init_network(device);
+		break;
+	}
+
 	return connman_element_register(&device->element, NULL);
 }
 
diff --git a/src/element.c b/src/element.c
index 57c25665..fb11f79c 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1455,6 +1455,8 @@ void __connman_element_start(void)
 
 	started = TRUE;
 
+	__connman_storage_init_device();
+
 	__connman_connection_init();
 	__connman_ipv4_init();
 	__connman_detect_init();
diff --git a/src/network.c b/src/network.c
index 2c6d6b88..7b3d49b1 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1008,6 +1008,13 @@ static struct connman_driver network_driver = {
 	.remove		= network_remove,
 };
 
+static int network_init(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
 static int network_load(struct connman_network *network)
 {
 	GKeyFile *keyfile;
@@ -1131,6 +1138,7 @@ done:
 static struct connman_storage network_storage = {
 	.name		= "network",
 	.priority	= CONNMAN_STORAGE_PRIORITY_LOW,
+	.network_init	= network_init,
 	.network_load	= network_load,
 	.network_save	= network_save,
 };
diff --git a/src/storage.c b/src/storage.c
index d881a5cc..b63c43b5 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -66,6 +66,24 @@ void connman_storage_unregister(struct connman_storage *storage)
 	storage_list = g_slist_remove(storage_list, storage);
 }
 
+int __connman_storage_init_device(void)
+{
+	GSList *list;
+
+	DBG("");
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->device_init) {
+			if (storage->device_init() == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
 int __connman_storage_load_device(struct connman_device *device)
 {
 	GSList *list;
@@ -102,6 +120,24 @@ int __connman_storage_save_device(struct connman_device *device)
 	return -ENOENT;
 }
 
+int __connman_storage_init_network(struct connman_device *device)
+{
+	GSList *list;
+
+	DBG("device %p", device);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->network_init) {
+			if (storage->network_init(device) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
 int __connman_storage_load_network(struct connman_network *network)
 {
 	GSList *list;

commit 33eca46278b1b3d17a3f966758cb03ec52cd414c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 20:32:01 2009 +0100

    Use symlinks instead of copying header files

diff --git a/include/Makefile.am b/include/Makefile.am
index 2db02499..f8e9e73e 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -14,9 +14,9 @@ all-local:
 	@if [ ! -e connman ]; then \
 	  mkdir connman; \
 	  list='$(include_HEADERS) $(noinst_HEADERS)'; for i in $$list; \
-	    do cp $(top_srcdir)/include/$$i connman/; done; \
+	    do $(LN_S) $(abs_top_srcdir)/include/$$i connman/$$i; done; \
 	  list='$(nodist_include_HEADERS)'; for i in $$list; \
-	    do cp $(top_builddir)/include/$$i connman/; done; \
+	    do $(LN_S) $(abs_top_builddir)/include/$$i connman/$$i; done; \
 	fi
 
 clean-local:

commit 3df7e823d4476f56b86b809c80a1dfa57f7413bf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 7 20:45:28 2009 +0100

    Add general features section to documentation

diff --git a/README b/README
index 989198c3..37130dd7 100644
--- a/README
+++ b/README
@@ -4,6 +4,26 @@ Connection Manager
 Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
 
 
+Functionality and features
+==========================
+
+The following features are built-in into Connection Manager:
+	- Generic plugin infrastructure
+	- Device and network abstraction (with basic storage support)
+	- IPv4, routing and DNS configuration
+
+Various plugins can be enabled for networking support:
+	- Ethernet plugin
+	- WiFi plugin with WEP40/WEP128 and WPA/WPA2 (personal only) support
+	- Bluetooth plugin
+
+Also plugins with additional features are available:
+	- DHCP plugins (uDHCP and dhclient)
+	- Resolver plugins (resolvconf and DNS proxy)
+	- Loopback setup
+	- PolicyKit support
+
+
 Compilation and installation
 ============================
 

commit 6281c3a0f6026a77d68026c0e14c49b825fab2ef
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 18:38:19 2009 +0100

    Add command line option to show version number

diff --git a/src/main.c b/src/main.c
index b895b1c0..5da7c861 100644
--- a/src/main.c
+++ b/src/main.c
@@ -53,9 +53,10 @@ static void disconnect_callback(DBusConnection *conn, void *user_data)
 static gchar *option_device = NULL;
 static gchar *option_plugin = NULL;
 static gboolean option_detach = TRUE;
-static gboolean option_selftest = FALSE;
 static gboolean option_compat = FALSE;
 static gboolean option_debug = FALSE;
+static gboolean option_selftest = FALSE;
+static gboolean option_version = FALSE;
 
 static GOptionEntry options[] = {
 	{ "device", 'i', 0, G_OPTION_ARG_STRING, &option_device,
@@ -65,12 +66,14 @@ static GOptionEntry options[] = {
 	{ "nodaemon", 'n', G_OPTION_FLAG_REVERSE,
 				G_OPTION_ARG_NONE, &option_detach,
 				"Don't fork daemon to background" },
-	{ "selftest", 't', 0, G_OPTION_ARG_NONE, &option_selftest,
-				"Run self testing routines" },
 	{ "compat", 'c', 0, G_OPTION_ARG_NONE, &option_compat,
 				"Enable Network Manager compatibility" },
 	{ "debug", 'd', 0, G_OPTION_ARG_NONE, &option_debug,
 				"Enable debug information output" },
+	{ "selftest", 't', 0, G_OPTION_ARG_NONE, &option_selftest,
+				"Run self testing routines" },
+	{ "version", 'v', 0, G_OPTION_ARG_NONE, &option_version,
+				"Show version information and exit" },
 	{ NULL },
 };
 
@@ -101,6 +104,11 @@ int main(int argc, char *argv[])
 
 	g_option_context_free(context);
 
+	if (option_version == TRUE) {
+		printf("%s\n", VERSION);
+		exit(0);
+	}
+
 	if (option_detach == TRUE) {
 		if (daemon(0, 0)) {
 			perror("Can't start daemon");

commit 8e888241130e35ee140ba6c184d0ceff1598c430
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 21:02:04 2009 +0100

    Add support for reading policy directory from polkit.pc

diff --git a/configure.ac b/configure.ac
index 1d8fc5ed..223e1e0f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -198,6 +198,11 @@ if (test "${enable_polkit}" = "yes"); then
 				AC_MSG_ERROR(PolicyKit >= 0.7 is required))
 	AC_SUBST(POLKIT_CFLAGS)
 	AC_SUBST(POLKIT_LIBS)
+	POLKIT_DATADIR="`pkg-config --variable=policydir polkit`"
+	if (test -z "${POLKIT_DATADIR}"); then
+		POLKIT_DATADIR="${datadir}/PolicyKit/policy"
+	fi
+	AC_SUBST(POLKIT_DATADIR)
 fi
 AM_CONDITIONAL(POLKIT, test "${enable_polkit}" = "yes")
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index b4c187b2..befc2d93 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -96,7 +96,7 @@ polkit_la_SOURCES = polkit.c
 polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
 polkit_la_CFLAGS = @GLIB_CFLAGS@ @POLKIT_CFLAGS@
 
-policydir = $(datadir)/PolicyKit/policy
+policydir = @POLKIT_DATADIR@
 
 policy_DATA = connman.policy
 endif

commit 049eae8ec20f0b3dd37d6f4b843da318966d4346
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 21:09:18 2009 +0100

    Add support for reading rules directory from libudev.pc

diff --git a/configure.ac b/configure.ac
index 223e1e0f..a6cc07cc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -186,6 +186,11 @@ if (test "${enable_udev}" = "yes"); then
 			[Define to 1 if you need the
 				udev_device_get_parent_with_subsystem_devtype()
 									function.]))
+	UDEV_DATADIR="`pkg-config --variable=rulesdir libudev`"
+	if (test -z "${UDEV_DATADIR}"); then
+		UDEV_DATADIR="${sysconfdir}/udev/rules.d"
+	fi
+	AC_SUBST(UDEV_DATADIR)
 fi
 AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
diff --git a/src/Makefile.am b/src/Makefile.am
index a540bf12..5a11f4ff 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -13,7 +13,7 @@ connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
 if UDEV
 connmand_SOURCES += udev.c
 
-rulesdir = $(sysconfdir)/udev/rules.d
+rulesdir = @UDEV_DATADIR@
 
 rules_DATA = 92-connman.rules
 endif

commit 6b0565ed922f60d121a73f04444e58bc171e1a55
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 21:17:41 2009 +0100

    Add support for reading config directory from dbus-1.pc

diff --git a/configure.ac b/configure.ac
index a6cc07cc..96d37589 100644
--- a/configure.ac
+++ b/configure.ac
@@ -167,6 +167,13 @@ PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(libdbus is required))
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
+DBUS_DATADIR="`pkg-config --variable=sysconfdir dbus-1`"
+if (test -z "{DBUS_DATADIR}"); then
+	DBUS_DATADIR="${sysconfdir}/dbus-1/system.d"
+else
+	DBUS_DATADIR="$DBUS_DATADIR/dbus-1/system.d"
+fi
+AC_SUBST(DBUS_DATADIR)
 
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
 AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
diff --git a/src/Makefile.am b/src/Makefile.am
index 5a11f4ff..363cfc33 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,5 +1,5 @@
 
-dbusdir = $(sysconfdir)/dbus-1/system.d
+dbusdir = @DBUS_DATADIR@
 
 dbus_DATA = connman.conf
 

commit 0f3e594a00cbe7922640a4dc338fed62226c9243
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 21:26:15 2009 +0100

    Fix uninitialized action id variable

diff --git a/plugins/polkit.c b/plugins/polkit.c
index de183a27..247721ee 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -47,7 +47,7 @@ static int polkit_authorize(const char *sender,
 	PolKitCaller *caller;
 	PolKitAction *action;
 	PolKitResult result;
-	const char *id;
+	const char *id = NULL;
 
 	DBG("sender %s", sender);
 

commit b0799835aa141dd9f32d1d477e113507f8b47522
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 21:40:58 2009 +0100

    Use $PKG_CONFIG instead of pkg-config

diff --git a/configure.ac b/configure.ac
index 96d37589..8e6fa946 100644
--- a/configure.ac
+++ b/configure.ac
@@ -167,7 +167,7 @@ PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(libdbus is required))
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
-DBUS_DATADIR="`pkg-config --variable=sysconfdir dbus-1`"
+DBUS_DATADIR="`$PKG_CONFIG --variable=sysconfdir dbus-1`"
 if (test -z "{DBUS_DATADIR}"); then
 	DBUS_DATADIR="${sysconfdir}/dbus-1/system.d"
 else
@@ -193,7 +193,7 @@ if (test "${enable_udev}" = "yes"); then
 			[Define to 1 if you need the
 				udev_device_get_parent_with_subsystem_devtype()
 									function.]))
-	UDEV_DATADIR="`pkg-config --variable=rulesdir libudev`"
+	UDEV_DATADIR="`$PKG_CONFIG --variable=rulesdir libudev`"
 	if (test -z "${UDEV_DATADIR}"); then
 		UDEV_DATADIR="${sysconfdir}/udev/rules.d"
 	fi
@@ -210,7 +210,7 @@ if (test "${enable_polkit}" = "yes"); then
 				AC_MSG_ERROR(PolicyKit >= 0.7 is required))
 	AC_SUBST(POLKIT_CFLAGS)
 	AC_SUBST(POLKIT_LIBS)
-	POLKIT_DATADIR="`pkg-config --variable=policydir polkit`"
+	POLKIT_DATADIR="`$PKG_CONFIG --variable=policydir polkit`"
 	if (test -z "${POLKIT_DATADIR}"); then
 		POLKIT_DATADIR="${datadir}/PolicyKit/policy"
 	fi

commit ee789c58f87dc413529f51342b75fef525604aac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 21:57:51 2009 +0100

    Add option to disable installation for data files

diff --git a/Makefile.am b/Makefile.am
index 5f40b57e..37bb4e0e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -6,6 +6,7 @@ pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = connman.pc
 
 DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
+				--disable-datafiles \
 				--enable-loopback \
 				--enable-ethernet \
 				--enable-wifi \
diff --git a/bootstrap-configure b/bootstrap-configure
index 340d80b4..3264b322 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -16,6 +16,7 @@ fi
 		--mandir=/usr/share/man \
 		--localstatedir=/var \
 		--sysconfdir=/etc \
+		--disable-datafiles \
 		--enable-loopback \
 		--enable-ethernet \
 		--enable-wifi \
diff --git a/configure.ac b/configure.ac
index 8e6fa946..8e85d337 100644
--- a/configure.ac
+++ b/configure.ac
@@ -226,6 +226,11 @@ AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
 		[enable fake device support]), [enable_fake=${enableval}])
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")
 
+AC_ARG_ENABLE(datafiles, AC_HELP_STRING([--disable-datafiles],
+			[don't install configuration and data files]),
+					[enable_datafiles=${enableval}])
+AM_CONDITIONAL(DATAFILES, test "${enable_datafiles}" != "no")
+
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile include/version.h
 		src/Makefile src/connman.service scripts/connman
 		scripts/Makefile plugins/Makefile client/Makefile
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index befc2d93..0bda0288 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -96,10 +96,12 @@ polkit_la_SOURCES = polkit.c
 polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
 polkit_la_CFLAGS = @GLIB_CFLAGS@ @POLKIT_CFLAGS@
 
+if DATAFILES
 policydir = @POLKIT_DATADIR@
 
 policy_DATA = connman.policy
 endif
+endif
 
 if FAKE
 plugin_LTLIBRARIES += fake.la
diff --git a/src/Makefile.am b/src/Makefile.am
index 363cfc33..4eda6715 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,7 +1,9 @@
 
+if DATAFILES
 dbusdir = @DBUS_DATADIR@
 
 dbus_DATA = connman.conf
+endif
 
 sbin_PROGRAMS = connmand
 
@@ -13,10 +15,12 @@ connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
 if UDEV
 connmand_SOURCES += udev.c
 
+if DATAFILES
 rulesdir = @UDEV_DATADIR@
 
 rules_DATA = 92-connman.rules
 endif
+endif
 
 connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @UDEV_LIBS@ -ldl
 

commit a00f6a3cb44fa2f40b2ee3ceb12f575cc939e027
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 8 22:42:29 2009 +0100

    Listen to events from RFKILL subsystem

diff --git a/src/connman.rules b/src/connman.rules
index 84b3b4b6..7a1b97af 100644
--- a/src/connman.rules
+++ b/src/connman.rules
@@ -1,4 +1,6 @@
 
+SUBSYSTEM=="rfkill", ENV{CONNMAN_TYPE}="rfkill"
+
 SUBSYSTEM=="net", DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
 
 SUBSYSTEM=="tty", KERNEL=="noz[0-9]*", ENV{CONNMAN_TYPE}="nozomi"
diff --git a/src/udev.c b/src/udev.c
index 0109f644..44e09d5c 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -168,6 +168,7 @@ static void print_properties(struct udev_device *device, const char *prefix)
 		const char *value = udev_list_entry_get_value(entry);
 
 		if (g_str_has_prefix(name, "CONNMAN") == TRUE ||
+				g_str_has_prefix(name, "RFKILL") == TRUE ||
 				g_str_has_prefix(name, "ID_MODEM") == TRUE ||
 				g_str_equal(name, "ID_VENDOR") == TRUE ||
 				g_str_equal(name, "ID_MODEL") == TRUE ||

commit 44ce220955fd54779c4e46406216e79076e88152
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 9 00:07:41 2009 +0100

    Add TODO documentation for tracking work in progress

diff --git a/TODO b/TODO
new file mode 100644
index 00000000..cd8e18ce
--- /dev/null
+++ b/TODO
@@ -0,0 +1,16 @@
+
+  o Support for WPA/WPA2 Enterprise WiFi authentication
+
+	With wpa_supplicant the support for WPA/WPA2 Enterprise is already
+	present, but it needs properly hooked up. This involves a correct
+	security architecture since it uses personalized credentials.
+
+  o Support for multiple profiles
+
+	Currently only one active profile (the default profile) is supported.
+
+  o Support for static IPv4 configuration
+
+	This is in theory possible, but no D-Bus API has been defined on how
+	to configure it.
+

commit 8024e614794792da8f346d34ff329ba2d244b37e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 9 17:16:54 2009 +0100

    Change the default access policy for PolicyKit

diff --git a/plugins/polkit.policy b/plugins/polkit.policy
index bc36a6dd..79d5c738 100644
--- a/plugins/polkit.policy
+++ b/plugins/polkit.policy
@@ -13,7 +13,7 @@
     <message>Policy prevents modification of settings</message>
     <defaults>
       <allow_inactive>no</allow_inactive>
-      <allow_active>auth_admin_keep_always</allow_active>
+      <allow_active>auth_self_keep_session</allow_active>
     </defaults>
   </action>
 
@@ -22,7 +22,7 @@
     <message>Policy prevents modification of secrets</message>
     <defaults>
       <allow_inactive>no</allow_inactive>
-      <allow_active>auth_admin_keep_always</allow_active>
+      <allow_active>auth_admin_keep_session</allow_active>
     </defaults>
   </action>
 

commit 371e97b43c7ef5edede30ebc3f8745c500ed05da
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 9 18:06:33 2009 +0100

    Add comments about interface statistics and RFKILL

diff --git a/TODO b/TODO
index cd8e18ce..0fb4ff7e 100644
--- a/TODO
+++ b/TODO
@@ -14,3 +14,14 @@
 	This is in theory possible, but no D-Bus API has been defined on how
 	to configure it.
 
+  o Support for interface statistics
+
+	Information about carrier speed etc. should be exported.
+
+  o Support for handling RFKILL events
+
+	The RFKILL events are received via the udev infrastructure, but not
+	acted upon. Current problem is to assign the event to the correct
+	physical device. In case of platform RFKILL switches this is a real
+	problem and not solved yet.
+

commit b027a9990b942512b88b1cc6eb08c763d51fe81d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 9 20:30:17 2009 +0100

    Add support for networking device notifications

diff --git a/src/connman.rules b/src/connman.rules
index 7a1b97af..05ec054b 100644
--- a/src/connman.rules
+++ b/src/connman.rules
@@ -1,6 +1,9 @@
 
 SUBSYSTEM=="rfkill", ENV{CONNMAN_TYPE}="rfkill"
 
+SUBSYSTEM=="net", KERNEL=="eth*", ENV{CONNMAN_TYPE}="ethernet"
+SUBSYSTEM=="net", KERNEL=="wlan*", ENV{CONNMAN_TYPE}="wifi"
+
 SUBSYSTEM=="net", DRIVERS=="hso", ENV{CONNMAN_TYPE}="hso"
 
 SUBSYSTEM=="tty", KERNEL=="noz[0-9]*", ENV{CONNMAN_TYPE}="nozomi"
diff --git a/src/udev.c b/src/udev.c
index 44e09d5c..d38abe65 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -172,6 +172,8 @@ static void print_properties(struct udev_device *device, const char *prefix)
 				g_str_has_prefix(name, "ID_MODEM") == TRUE ||
 				g_str_equal(name, "ID_VENDOR") == TRUE ||
 				g_str_equal(name, "ID_MODEL") == TRUE ||
+				g_str_equal(name, "INTERFACE") == TRUE ||
+				g_str_equal(name, "IFINDEX") == TRUE ||
 				g_str_equal(name, "DEVNAME") == TRUE ||
 				g_str_equal(name, "DEVPATH") == TRUE)
 			connman_debug("%s%s = %s", prefix, name, value);

commit 4825219881946d6f37e78e0b7ecf6d74f3ac9c5d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 10 02:08:46 2009 +0100

    Fix signal emission for network changes

diff --git a/src/network.c b/src/network.c
index 7b3d49b1..aaa4254b 100644
--- a/src/network.c
+++ b/src/network.c
@@ -293,11 +293,12 @@ static void append_networks(struct connman_device *device,
 
 static void emit_networks_signal(struct connman_device *device)
 {
+	const char *path = connman_device_get_path(device);
 	DBusMessage *signal;
 	DBusMessageIter entry;
 
-	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	signal = dbus_message_new_signal(path,
+				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
 	if (signal == NULL)
 		return;
 

commit d3a2ba795b3c73199a643eb88b1d98e3b0dafed7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 10 02:36:34 2009 +0100

    Add Device and Network property to connection interface

diff --git a/doc/connection-api.txt b/doc/connection-api.txt
index a0c97da3..8e2e8bca 100644
--- a/doc/connection-api.txt
+++ b/doc/connection-api.txt
@@ -39,6 +39,18 @@ Properties	string Type [readonly]
 			Indicates if it is a default connection. It is
 			possible to have multiple default connections.
 
+		object Device [readonly]
+
+			The object path of the device this connection has
+			been established with.
+
+		object Network [readonly]
+
+			The object path of the network this connection
+			belongs to.
+
+			This property is optional and not always present.
+
 		string IPv4.Method [readonly]
 
 			Indicates the way how the IPv4 settings were
diff --git a/src/connection.c b/src/connection.c
index ad381470..980b770f 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -206,6 +206,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
 	connman_uint8_t strength = 0;
+	const char *device, *network;
 	const char *type = NULL, *method = NULL;
 	const char *address = NULL, *netmask = NULL, *gateway = NULL;
 
@@ -244,6 +245,16 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Default",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
+	device = __connman_element_get_device(element);
+	if (device != NULL)
+		connman_dbus_dict_append_variant(&dict, "Device",
+					DBUS_TYPE_OBJECT_PATH, &device);
+
+	network = __connman_element_get_network(element);
+	if (network != NULL)
+		connman_dbus_dict_append_variant(&dict, "Network",
+					DBUS_TYPE_OBJECT_PATH, &network);
+
 	connman_element_get_value(element,
 				CONNMAN_PROPERTY_ID_IPV4_METHOD, &method);
 
diff --git a/src/connman.h b/src/connman.h
index cca7ea8a..545183e3 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -117,6 +117,9 @@ void __connman_element_list(struct connman_element *element,
 int __connman_element_count(struct connman_element *element,
 					enum connman_element_type type);
 
+const char *__connman_element_get_device(struct connman_element *element);
+const char *__connman_element_get_network(struct connman_element *element);
+
 const char *__connman_element_type2string(enum connman_element_type type);
 
 static inline void __connman_element_lock(struct connman_element *element)
diff --git a/src/element.c b/src/element.c
index fb11f79c..2baeb1a3 100644
--- a/src/element.c
+++ b/src/element.c
@@ -427,6 +427,30 @@ int __connman_element_count(struct connman_element *element,
 	return data.count;
 }
 
+const char *__connman_element_get_device(struct connman_element *element)
+{
+	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
+						element->device != NULL)
+		return element->path;
+
+	if (element->parent == NULL)
+		return NULL;
+
+	return __connman_element_get_device(element->parent);
+}
+
+const char *__connman_element_get_network(struct connman_element *element)
+{
+	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK &&
+						element->network != NULL)
+		return element->path;
+
+	if (element->parent == NULL)
+		return NULL;
+
+	return __connman_element_get_network(element->parent);
+}
+
 static gint compare_priority(gconstpointer a, gconstpointer b)
 {
 	const struct connman_driver *driver1 = a;

commit 5de0b9357c57511f5b1d1da128d80973a07be1ed
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 10 02:47:40 2009 +0100

    Release 0.8

diff --git a/ChangeLog b/ChangeLog
index a0448911..61d9dba5 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+ver 0.8:
+	Add Device and Network property to connection interface.
+	Add option to disable installation of data files.
+	Add command line option to show version number.
+	Fix signal emission for network changes.
+
 ver 0.7:
 	Add basic support for flight mode.
 	Add support for multiple storage drivers.
diff --git a/configure.ac b/configure.ac
index 8e85d337..5ef18639 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.7)
+AM_INIT_AUTOMAKE(connman, 0.8)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit b7bcc65f4a1527a698a2e00832ccd5ed6db22300
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 12 05:45:16 2009 +0100

    Fix setting network remember status

diff --git a/src/network.c b/src/network.c
index aaa4254b..35635151 100644
--- a/src/network.c
+++ b/src/network.c
@@ -179,6 +179,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 
 		if (network->remember == remember)
 			return __connman_error_invalid_arguments(msg);
+
+		network->remember = remember;
 	} else if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
 		const char *passphrase;
 

commit 04cde7cfde844455325ad03cf2e61ea2da4adf15
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 18 13:40:15 2009 +0100

    Require GLib 2.16 or later for GHashTableIter support

diff --git a/configure.ac b/configure.ac
index 5ef18639..61870b68 100644
--- a/configure.ac
+++ b/configure.ac
@@ -150,21 +150,21 @@ AM_CONDITIONAL(PPPD, test "${enable_ppp}" = "yes")
 AC_CHECK_LIB(dl, dlopen, dummy=yes,
 			AC_MSG_ERROR(dynamic linking loader is required))
 
-PKG_CHECK_MODULES(GLIB, glib-2.0, dummy=yes,
-				AC_MSG_ERROR(glib is required))
+PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
+				AC_MSG_ERROR(GLib >= 2.16 is required))
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
 if (test "${enable_threads}" = "yes"); then
 	AC_DEFINE(NEED_THREADS, 1, [Define if threading support is required])
-	PKG_CHECK_MODULES(GTHREAD, gthread-2.0, dummy=yes,
-				AC_MSG_ERROR(gthread is required))
+	PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
+				AC_MSG_ERROR(GThread >= 2.16 is required))
 	GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
 	GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
 fi
 
 PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
-				AC_MSG_ERROR(libdbus is required))
+				AC_MSG_ERROR(D-Bus >= 1.0 is required))
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 DBUS_DATADIR="`$PKG_CONFIG --variable=sysconfdir dbus-1`"

commit 7b9ccd0409be6c683f4954d417d507e06ed561d5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 20 14:56:37 2009 +0100

    Remove networks that are no longer available

diff --git a/src/device.c b/src/device.c
index 2a65e69a..d107bf4d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1030,6 +1030,31 @@ static void connect_known_network(struct connman_device *device)
 		device->driver->scan(device);
 }
 
+static void mark_network_unavailable(gpointer key, gpointer value,
+							gpointer user_data)
+{
+	struct connman_network *network = value;
+
+	if (connman_network_get_remember(network) == TRUE)
+		return;
+
+	connman_network_set_available(network, FALSE);
+}
+
+static gboolean remove_unavailable_network(gpointer key, gpointer value,
+							gpointer user_data)
+{
+	struct connman_network *network = value;
+
+	if (connman_network_get_remember(network) == TRUE)
+		return FALSE;
+
+	if (connman_network_get_available(network) == TRUE)
+		return FALSE;
+
+	return TRUE;
+}
+
 /**
  * connman_device_set_scanning:
  * @device: device structure
@@ -1070,8 +1095,14 @@ int connman_device_set_scanning(struct connman_device *device,
 
 	g_dbus_send_message(connection, signal);
 
-	if (scanning == TRUE)
+	if (scanning == TRUE) {
+		g_hash_table_foreach(device->networks,
+					mark_network_unavailable, NULL);
 		return 0;
+	}
+
+	g_hash_table_foreach_remove(device->networks,
+					remove_unavailable_network, NULL);
 
 	if (device->connections > 0)
 		return 0;

commit 31200365b3a59e89ee6d2d00b01b6cec33075688
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 20 17:44:01 2009 +0100

    Rename FlightMode to OfflineMode

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index bf3d1de9..5ff5f6a8 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -57,15 +57,15 @@ Properties	string State [readonly]
 			device defines which becomes the default connection
 			when multiple are available.
 
-		boolean FlightMode [readwrite]
+		boolean OfflineMode [readwrite]
 
-			The flight mode indicates the global setting for
-			switching all radios on or off. Changing flight mode
+			The offline mode indicates the global setting for
+			switching all radios on or off. Changing offline mode
 			to true results in powering down all devices. When
-			leaving flight mode the individual policy of each
+			leaving offline mode the individual policy of each
 			device decides to switch the radio back on or not.
 
-			During flight mode, it is still possible to switch
+			During offline mode, it is still possible to switch
 			certain technologies manually back on. For example
 			the limited usage of WiFi or Bluetooth devices might
 			be allowed in some situations.
diff --git a/src/connman.h b/src/connman.h
index 545183e3..b944465d 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -163,7 +163,7 @@ void __connman_device_decrease_connections(struct connman_device *device);
 
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
-int __connman_device_set_flightmode(connman_bool_t flightmode);
+int __connman_device_set_offlinemode(connman_bool_t offlinemode);
 
 #include <connman/network.h>
 
diff --git a/src/device.c b/src/device.c
index d107bf4d..f9c153d2 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1159,10 +1159,10 @@ const char *connman_device_get_string(struct connman_device *device,
 	return NULL;
 }
 
-static void set_flightmode(struct connman_element *element, gpointer user_data)
+static void set_offlinemode(struct connman_element *element, gpointer user_data)
 {
 	struct connman_device *device = element->device;
-	connman_bool_t flightmode = GPOINTER_TO_UINT(user_data);
+	connman_bool_t offlinemode = GPOINTER_TO_UINT(user_data);
 	connman_bool_t powered;
 
 	DBG("element %p name %s", element, element->name);
@@ -1170,7 +1170,7 @@ static void set_flightmode(struct connman_element *element, gpointer user_data)
 	if (device == NULL)
 		return;
 
-	powered = (flightmode == TRUE) ? FALSE : TRUE;
+	powered = (offlinemode == TRUE) ? FALSE : TRUE;
 
 	if (device->powered == powered)
 		return;
@@ -1178,12 +1178,12 @@ static void set_flightmode(struct connman_element *element, gpointer user_data)
 	set_powered(device, powered);
 }
 
-int __connman_device_set_flightmode(connman_bool_t flightmode)
+int __connman_device_set_offlinemode(connman_bool_t offlinemode)
 {
-	DBG("flightmode %d", flightmode);
+	DBG("offlinmode %d", offlinemode);
 
 	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_DEVICE,
-				set_flightmode, GUINT_TO_POINTER(flightmode));
+			set_offlinemode, GUINT_TO_POINTER(offlinemode));
 
 	return 0;
 }
diff --git a/src/manager.c b/src/manager.c
index f943720e..a2f1be81 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -35,7 +35,7 @@ enum connman_policy {
 };
 
 static enum connman_policy global_policy = CONNMAN_POLICY_SINGLE;
-static connman_bool_t global_flightmode = FALSE;
+static connman_bool_t global_offlinemode = FALSE;
 
 static const char *policy2string(enum connman_policy policy)
 {
@@ -185,8 +185,8 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Policy",
 						DBUS_TYPE_STRING, &str);
 
-	connman_dbus_dict_append_variant(&dict, "FlightMode",
-					DBUS_TYPE_BOOLEAN, &global_flightmode);
+	connman_dbus_dict_append_variant(&dict, "OfflineMode",
+				DBUS_TYPE_BOOLEAN, &global_offlinemode);
 
 	dbus_message_iter_close_container(&array, &dict);
 
@@ -222,17 +222,17 @@ static DBusMessage *set_property(DBusConnection *conn,
 			return __connman_error_invalid_arguments(msg);
 
 		global_policy = policy;
-	} else if (g_str_equal(name, "FlightMode") == TRUE) {
-		connman_bool_t flightmode;
+	} else if (g_str_equal(name, "OfflineMode") == TRUE) {
+		connman_bool_t offlinemode;
 
-		dbus_message_iter_get_basic(&value, &flightmode);
+		dbus_message_iter_get_basic(&value, &offlinemode);
 
-		if (global_flightmode == flightmode)
+		if (global_offlinemode == offlinemode)
 			return __connman_error_invalid_arguments(msg);
 
-		global_flightmode = flightmode;
+		global_offlinemode = offlinemode;
 
-		__connman_device_set_flightmode(flightmode);
+		__connman_device_set_offlinemode(offlinemode);
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
diff --git a/test/test-manager b/test/test-manager
index e9f12313..7915eaf5 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -54,7 +54,7 @@ def print_properties(key, value):
 for key in properties.keys():
 	if key in ["Profiles", "Devices", "Connections"]:
 		print_properties(key, properties[key])
-	elif key in ["FlightMode"]:
+	elif key in ["OfflineMode"]:
 		print "%s" % (key)
 		if properties[key] == dbus.Boolean(1):
 			print "    true"

commit e49304f3457f0d4a135f5f88b7197f144b647636
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jan 20 22:26:01 2009 +0100

    Remove old property system

diff --git a/include/element.h b/include/element.h
index d91886b6..3549f078 100644
--- a/include/element.h
+++ b/include/element.h
@@ -79,7 +79,7 @@ struct connman_element {
 		struct connman_network *network;
 	};
 
-	GSList *properties;
+	GHashTable *properties;
 
 	struct {
 		enum connman_ipv4_method method;
@@ -102,9 +102,6 @@ extern int connman_element_set_static_property(struct connman_element *element,
 				const char *name, int type, const void *value);
 extern int connman_element_add_static_array_property(struct connman_element *element,
 			const char *name, int type, const void *value, int len);
-extern int connman_element_define_properties(struct connman_element *element, ...);
-extern int connman_element_create_property(struct connman_element *element,
-						const char *name, int type);
 extern int connman_element_set_property(struct connman_element *element,
 				enum connman_property_id id, const void *value);
 extern int connman_element_get_value(struct connman_element *element,
diff --git a/src/connman.h b/src/connman.h
index b944465d..912aea1a 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -105,6 +105,8 @@ void __connman_element_start(void);
 void __connman_element_stop(void);
 void __connman_element_cleanup(void);
 
+void __connman_element_initialize(struct connman_element *element);
+
 typedef void (* element_cb_t) (struct connman_element *element,
 							gpointer user_data);
 
diff --git a/src/device.c b/src/device.c
index f9c153d2..cc5b7614 100644
--- a/src/device.c
+++ b/src/device.c
@@ -710,11 +710,10 @@ struct connman_device *connman_device_create(const char *node,
 
 	DBG("device %p", device);
 
-	device->element.refcount = 1;
+	__connman_element_initialize(&device->element);
 
 	device->element.name = g_strdup(node);
 	device->element.type = CONNMAN_ELEMENT_TYPE_DEVICE;
-	device->element.index = -1;
 
 	device->element.device = device;
 	device->element.destruct = device_destruct;
diff --git a/src/element.c b/src/element.c
index 2baeb1a3..858ac767 100644
--- a/src/element.c
+++ b/src/element.c
@@ -40,51 +40,6 @@ static gchar *device_filter = NULL;
 
 static gboolean started = FALSE;
 
-static struct {
-	enum connman_property_id id;
-	int type;
-	const char *name;
-	const void *value;
-} propid_table[] = {
-	{ CONNMAN_PROPERTY_ID_IPV4_METHOD,
-		DBUS_TYPE_STRING, "IPv4.Method", "dhcp" },
-	{ CONNMAN_PROPERTY_ID_IPV4_ADDRESS,
-		DBUS_TYPE_STRING, "IPv4.Address" },
-	{ CONNMAN_PROPERTY_ID_IPV4_NETMASK,
-		DBUS_TYPE_STRING, "IPv4.Netmask" },
-	{ CONNMAN_PROPERTY_ID_IPV4_GATEWAY,
-		DBUS_TYPE_STRING, "IPv4.Gateway" },
-	{ CONNMAN_PROPERTY_ID_IPV4_BROADCAST,
-		DBUS_TYPE_STRING, "IPv4.Broadcast" },
-	{ CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
-		DBUS_TYPE_STRING, "IPv4.Nameserver" },
-	{ }
-};
-
-static int propid2type(enum connman_property_id id)
-{
-	int i;
-
-	for (i = 0; propid_table[i].name; i++) {
-		if (propid_table[i].id == id)
-			return propid_table[i].type;
-	}
-
-	return DBUS_TYPE_INVALID;
-}
-
-static const char *propid2name(enum connman_property_id id)
-{
-	int i;
-
-	for (i = 0; propid_table[i].name; i++) {
-		if (propid_table[i].id == id)
-			return propid_table[i].name;
-	}
-
-	return NULL;
-}
-
 static const char *type2string(enum connman_element_type type)
 {
 	switch (type) {
@@ -149,116 +104,6 @@ enum connman_ipv4_method __connman_ipv4_string2method(const char *method)
 		return CONNMAN_IPV4_METHOD_UNKNOWN;
 }
 
-#if 0
-static void append_property(DBusMessageIter *dict,
-				struct connman_property *property)
-{
-	if (property->value == NULL)
-		return;
-
-	switch (property->type) {
-	case DBUS_TYPE_ARRAY:
-		connman_dbus_dict_append_array(dict, property->name,
-			property->subtype, &property->value, property->size);
-		break;
-	case DBUS_TYPE_STRING:
-		connman_dbus_dict_append_variant(dict, property->name,
-					property->type, &property->value);
-		break;
-	default:
-		connman_dbus_dict_append_variant(dict, property->name,
-					property->type, property->value);
-		break;
-	}
-}
-
-static void add_common_properties(struct connman_element *element,
-						DBusMessageIter *dict)
-{
-	const char *address = NULL, *netmask = NULL, *gateway = NULL;
-	GSList *list;
-
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_ADDRESS, &address);
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
-
-	if (element->priority > 0)
-		connman_dbus_dict_append_variant(dict, "Priority",
-					DBUS_TYPE_UINT16, &element->priority);
-
-	if (address != NULL)
-		connman_dbus_dict_append_variant(dict, "IPv4.Address",
-						DBUS_TYPE_STRING, &address);
-	if (netmask != NULL)
-		connman_dbus_dict_append_variant(dict, "IPv4.Netmask",
-						DBUS_TYPE_STRING, &netmask);
-	if (gateway != NULL)
-		connman_dbus_dict_append_variant(dict, "IPv4.Gateway",
-						DBUS_TYPE_STRING, &gateway);
-
-	if (element->wifi.security != NULL) {
-		const char *passphrase = "";
-
-		connman_dbus_dict_append_variant(dict, "WiFi.Security",
-				DBUS_TYPE_STRING, &element->wifi.security);
-
-		if (element->wifi.passphrase != NULL)
-			passphrase = element->wifi.passphrase;
-
-		connman_dbus_dict_append_variant(dict, "WiFi.Passphrase",
-				DBUS_TYPE_STRING, &passphrase);
-	}
-
-	__connman_element_lock(element);
-
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		append_property(dict, property);
-	}
-
-	__connman_element_unlock(element);
-}
-
-static void set_common_property(struct connman_element *element,
-				const char *name, DBusMessageIter *value)
-{
-	GSList *list;
-
-	if (g_str_equal(name, "Priority") == TRUE) {
-		dbus_message_iter_get_basic(value, &element->priority);
-		return;
-	}
-
-	__connman_element_lock(element);
-
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-		const char *str;
-
-		if (g_str_equal(property->name, name) == FALSE)
-			continue;
-
-		if (property->flags & CONNMAN_PROPERTY_FLAG_STATIC)
-			continue;
-
-		property->flags &= ~CONNMAN_PROPERTY_FLAG_REFERENCE;
-
-		if (property->type == DBUS_TYPE_STRING) {
-			dbus_message_iter_get_basic(value, &str);
-			g_free(property->value);
-			property->value = g_strdup(str);
-		} else
-			property->value = NULL;
-	}
-
-	__connman_element_unlock(element);
-}
-#endif
-
 static void emit_element_signal(DBusConnection *conn, const char *member,
 					struct connman_element *element)
 {
@@ -570,6 +415,34 @@ void connman_driver_unregister(struct connman_driver *driver)
 				G_TRAVERSE_ALL, -1, remove_driver, driver);
 }
 
+static void unregister_property(gpointer data)
+{
+	struct connman_property *property = data;
+
+	DBG("property %p", property);
+
+	if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
+		g_free(property->value);
+
+	g_free(property->name);
+	g_free(property);
+}
+
+void __connman_element_initialize(struct connman_element *element)
+{
+	DBG("element %p", element);
+
+	element->refcount = 1;
+
+	element->name    = NULL;
+	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
+	element->index   = -1;
+	element->enabled = FALSE;
+
+	element->properties = g_hash_table_new_full(g_str_hash, g_direct_equal,
+						g_free, unregister_property);
+}
+
 /**
  * connman_element_create:
  * @name: element name
@@ -589,12 +462,7 @@ struct connman_element *connman_element_create(const char *name)
 
 	DBG("element %p", element);
 
-	element->refcount = 1;
-
-	element->name    = g_strdup(name);
-	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
-	element->index   = -1;
-	element->enabled = FALSE;
+	__connman_element_initialize(element);
 
 	return element;
 }
@@ -611,24 +479,11 @@ struct connman_element *connman_element_ref(struct connman_element *element)
 
 static void free_properties(struct connman_element *element)
 {
-	GSList *list;
-
 	DBG("element %p name %s", element, element->name);
 
 	__connman_element_lock(element);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
-			g_free(property->value);
-
-		g_free(property->name);
-		g_free(property);
-	}
-
-	g_slist_free(element->properties);
-
+	g_hash_table_destroy(element->properties);
 	element->properties = NULL;
 
 	__connman_element_unlock(element);
@@ -689,7 +544,9 @@ int connman_element_add_static_property(struct connman_element *element,
 	}
 
 	__connman_element_lock(element);
-	element->properties = g_slist_append(element->properties, property);
+
+	g_hash_table_insert(element->properties, g_strdup(name), property);
+
 	__connman_element_unlock(element);
 
 	return 0;
@@ -698,7 +555,7 @@ int connman_element_add_static_property(struct connman_element *element,
 int connman_element_set_static_property(struct connman_element *element,
 				const char *name, int type, const void *value)
 {
-	GSList *list;
+	struct connman_property *property;
 
 	DBG("element %p name %s", element, element->name);
 
@@ -707,14 +564,9 @@ int connman_element_set_static_property(struct connman_element *element,
 
 	__connman_element_lock(element);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (g_str_equal(property->name, name) == FALSE)
-			continue;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
-			continue;
+	property = g_hash_table_lookup(element->properties, name);
+	if (property != NULL) {
+		property->flags |= CONNMAN_PROPERTY_FLAG_STATIC;
 
 		property->type = type;
 		g_free(property->value);
@@ -770,168 +622,14 @@ int connman_element_add_static_array_property(struct connman_element *element,
 	}
 
 	__connman_element_lock(element);
-	element->properties = g_slist_append(element->properties, property);
-	__connman_element_unlock(element);
 
-	return 0;
-}
-
-static void *get_reference_value(struct connman_element *element,
-						enum connman_property_id id)
-{
-	GSList *list;
-
-	DBG("element %p name %s", element, element->name);
+	g_hash_table_insert(element->properties, g_strdup(name), property);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (property->id != id)
-			continue;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
-			return property->value;
-	}
-
-	if (element->parent == NULL)
-		return NULL;
-
-	return get_reference_value(element->parent, id);
-}
-
-static void set_reference_properties(struct connman_element *element)
-{
-	GSList *list;
-
-	DBG("element %p name %s", element, element->name);
-
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
-			continue;
-
-		property->value = get_reference_value(element->parent,
-								property->id);
-	}
-}
-
-static struct connman_property *create_property(struct connman_element *element,
-						enum connman_property_id id)
-{
-	struct connman_property *property;
-	GSList *list;
-
-	DBG("element %p name %s", element, element->name);
-
-	__connman_element_lock(element);
-
-	for (list = element->properties; list; list = list->next) {
-		property = list->data;
-
-		if (property->id == id)
-			goto unlock;
-	}
-
-	property = g_try_new0(struct connman_property, 1);
-	if (property == NULL)
-		goto unlock;
-
-	property->flags = CONNMAN_PROPERTY_FLAG_REFERENCE;
-	property->id    = id;
-	property->name  = g_strdup(propid2name(id));
-	property->type  = propid2type(id);
-
-	if (property->name == NULL) {
-		g_free(property);
-		property = NULL;
-		goto unlock;
-	}
-
-	element->properties = g_slist_append(element->properties, property);
-
-unlock:
 	__connman_element_unlock(element);
 
-	return property;
-}
-
-static void create_default_properties(struct connman_element *element)
-{
-	struct connman_property *property;
-	int i;
-
-	DBG("element %p name %s", element, element->name);
-
-	for (i = 0; propid_table[i].name; i++) {
-		DBG("property %s", propid_table[i].name);
-
-		property = create_property(element, propid_table[i].id);
-
-		property->flags &= ~CONNMAN_PROPERTY_FLAG_REFERENCE;
-
-		if (propid_table[i].type != DBUS_TYPE_STRING)
-			continue;
-
-		if (propid_table[i].value)
-			property->value = g_strdup(propid_table[i].value);
-		else
-			property->value = g_strdup("");
-	}
-}
-
-static int define_properties_valist(struct connman_element *element,
-								va_list args)
-{
-	enum connman_property_id id;
-
-	DBG("element %p name %s", element, element->name);
-
-	id = va_arg(args, enum connman_property_id);
-
-	while (id != CONNMAN_PROPERTY_ID_INVALID) {
-
-		DBG("property %d", id);
-
-		create_property(element, id);
-
-		id = va_arg(args, enum connman_property_id);
-	}
-
 	return 0;
 }
 
-/**
- * connman_element_define_properties:
- * @element: an element
- * @varargs: list of property identifiers
- *
- * Define the valid properties for an element.
- *
- * Returns: %0 on success
- */
-int connman_element_define_properties(struct connman_element *element, ...)
-{
-	va_list args;
-	int err;
-
-	DBG("element %p name %s", element, element->name);
-
-	va_start(args, element);
-
-	err = define_properties_valist(element, args);
-
-	va_end(args);
-
-	return err;
-}
-
-int connman_element_create_property(struct connman_element *element,
-						const char *name, int type)
-{
-	return -EIO;
-}
-
 int connman_element_set_property(struct connman_element *element,
 				enum connman_property_id id, const void *value)
 {
@@ -1038,19 +736,16 @@ int connman_element_get_value(struct connman_element *element,
 gboolean connman_element_get_static_property(struct connman_element *element,
 						const char *name, void *value)
 {
-	GSList *list;
+	struct connman_property *property;
 	gboolean found = FALSE;
 
 	DBG("element %p name %s", element, element->name);
 
 	__connman_element_lock(element);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
-			continue;
-
+	property = g_hash_table_lookup(element->properties, name);
+	if (property != NULL &&
+			(property->flags & CONNMAN_PROPERTY_FLAG_STATIC)) {
 		if (g_str_equal(property->name, name) == TRUE) {
 			switch (property->type) {
 			case DBUS_TYPE_STRING:
@@ -1062,7 +757,6 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 				found = TRUE;
 				break;
 			}
-			break;
 		}
 	}
 
@@ -1078,24 +772,20 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 gboolean connman_element_get_static_array_property(struct connman_element *element,
 					const char *name, void *value, int *len)
 {
-	GSList *list;
+	struct connman_property *property;
 	gboolean found = FALSE;
 
 	DBG("element %p name %s", element, element->name);
 
 	__connman_element_lock(element);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
-			continue;
-
+	property = g_hash_table_lookup(element->properties, name);
+	if (property != NULL &&
+			(property->flags & CONNMAN_PROPERTY_FLAG_STATIC)) {
 		if (g_str_equal(property->name, name) == TRUE) {
 			*((char **) value) = property->value;
 			*len = property->size;
 			found = TRUE;
-			break;
 		}
 	}
 
@@ -1107,28 +797,20 @@ gboolean connman_element_get_static_array_property(struct connman_element *eleme
 gboolean connman_element_match_static_property(struct connman_element *element,
 					const char *name, const void *value)
 {
-	GSList *list;
+	struct connman_property *property;
 	gboolean result = FALSE;
 
 	DBG("element %p name %s", element, element->name);
 
 	__connman_element_lock(element);
 
-	for (list = element->properties; list; list = list->next) {
-		struct connman_property *property = list->data;
-
-		if (!(property->flags & CONNMAN_PROPERTY_FLAG_STATIC))
-			continue;
-
-		if (g_str_equal(property->name, name) == FALSE)
-			continue;
-
-		if (property->type == DBUS_TYPE_STRING)
+	property = g_hash_table_lookup(element->properties, name);
+	if (property != NULL &&
+			(property->flags & CONNMAN_PROPERTY_FLAG_STATIC)) {
+		if (g_str_equal(property->name, name) == TRUE &&
+					property->type == DBUS_TYPE_STRING)
 			result = g_str_equal(property->value,
 						*((const char **) value));
-
-		if (result == TRUE)
-			break;
 	}
 
 	__connman_element_unlock(element);
@@ -1250,8 +932,6 @@ static void register_element(gpointer data, gpointer user_data)
 
 	element->path = g_strdup_printf("%s/%s", basepath, element->name);
 
-	set_reference_properties(element);
-
 	__connman_element_unlock(element);
 
 	DBG("element %p path %s", element, element->path);
@@ -1443,8 +1123,6 @@ int __connman_element_init(DBusConnection *conn, const char *device)
 	element->path = g_strdup("/");
 	element->type = CONNMAN_ELEMENT_TYPE_ROOT;
 
-	create_default_properties(element);
-
 	element_root = g_node_new(element);
 
 	__connman_network_init();
diff --git a/src/network.c b/src/network.c
index 35635151..1e616e4f 100644
--- a/src/network.c
+++ b/src/network.c
@@ -434,11 +434,10 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	DBG("network %p", network);
 
-	network->element.refcount = 1;
+	__connman_element_initialize(&network->element);
 
 	network->element.name = g_strdup(identifier);
 	network->element.type = CONNMAN_ELEMENT_TYPE_NETWORK;
-	network->element.index = -1;
 
 	network->element.network = network;
 	network->element.destruct = network_destruct;

commit 0b95857f52f88596c45679351f6e80ef17d6fc58
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 01:36:32 2009 +0100

    Verify argument type before processing

diff --git a/src/connection.c b/src/connection.c
index 980b770f..f617ddea 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -291,6 +291,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 {
 	DBusMessageIter iter, value;
 	const char *name;
+	int type;
 
 	DBG("conn %p", conn);
 
@@ -305,6 +306,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
+	type = dbus_message_iter_get_arg_type(&value);
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
diff --git a/src/device.c b/src/device.c
index cc5b7614..6e2575b4 100644
--- a/src/device.c
+++ b/src/device.c
@@ -317,6 +317,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 	struct connman_device *device = data;
 	DBusMessageIter iter, value;
 	const char *name;
+	int type;
 
 	DBG("conn %p", conn);
 
@@ -331,10 +332,15 @@ static DBusMessage *set_property(DBusConnection *conn,
 					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
+	type = dbus_message_iter_get_arg_type(&value);
+
 	if (g_str_equal(name, "Powered") == TRUE) {
 		connman_bool_t powered;
 		int err;
 
+		if (type != DBUS_TYPE_BOOLEAN)
+			return __connman_error_invalid_arguments(msg);
+
 		dbus_message_iter_get_basic(&value, &powered);
 
 		if (device->powered == powered)
@@ -348,6 +354,9 @@ static DBusMessage *set_property(DBusConnection *conn,
 		const char *str;
 		int err;
 
+		if (type != DBUS_TYPE_STRING)
+			return __connman_error_invalid_arguments(msg);
+
 		dbus_message_iter_get_basic(&value, &str);
 		policy = string2policy(str);
 		if (policy == CONNMAN_DEVICE_POLICY_UNKNOWN)
@@ -359,6 +368,9 @@ static DBusMessage *set_property(DBusConnection *conn,
 	} else if (g_str_equal(name, "Priority") == TRUE) {
 		connman_uint8_t priority;
 
+		if (type != DBUS_TYPE_BYTE)
+			return __connman_error_invalid_arguments(msg);
+
 		dbus_message_iter_get_basic(&value, &priority);
 
 		device->priority = priority;
diff --git a/src/network.c b/src/network.c
index 1e616e4f..3e27e7ef 100644
--- a/src/network.c
+++ b/src/network.c
@@ -158,6 +158,7 @@ static DBusMessage *set_property(DBusConnection *conn,
 	struct connman_network *network = data;
 	DBusMessageIter iter, value;
 	const char *name;
+	int type;
 
 	DBG("conn %p", conn);
 
@@ -172,9 +173,14 @@ static DBusMessage *set_property(DBusConnection *conn,
 					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
+	type = dbus_message_iter_get_arg_type(&value);
+
 	if (g_str_equal(name, "Remember") == TRUE) {
 		connman_bool_t remember;
 
+		if (type != DBUS_TYPE_BOOLEAN)
+			return __connman_error_invalid_arguments(msg);
+
 		dbus_message_iter_get_basic(&value, &remember);
 
 		if (network->remember == remember)
@@ -184,6 +190,9 @@ static DBusMessage *set_property(DBusConnection *conn,
 	} else if (g_str_equal(name, "WiFi.Passphrase") == TRUE) {
 		const char *passphrase;
 
+		if (type != DBUS_TYPE_STRING)
+			return __connman_error_invalid_arguments(msg);
+
 		if (__connman_security_check_privilege(msg,
 					CONNMAN_SECURITY_PRIVILEGE_SECRET) < 0)
 			return __connman_error_permission_denied(msg);
@@ -195,6 +204,9 @@ static DBusMessage *set_property(DBusConnection *conn,
 	} else if (g_str_equal(name, "Priority") == TRUE) {
 		connman_uint8_t priority;
 
+		if (type != DBUS_TYPE_BYTE)
+			return __connman_error_invalid_arguments(msg);
+
 		dbus_message_iter_get_basic(&value, &priority);
 
 		network->priority = priority;

commit 6e9987061ef9bc393309adfcdba155386d1802c4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 01:44:02 2009 +0100

    Add function to get device mode

diff --git a/include/device.h b/include/device.h
index 350890fb..abd62cfb 100644
--- a/include/device.h
+++ b/include/device.h
@@ -83,6 +83,7 @@ extern void connman_device_set_policy(struct connman_device *device,
 					enum connman_device_policy policy);
 extern void connman_device_set_mode(struct connman_device *device,
 						enum connman_device_mode mode);
+extern enum connman_device_mode connman_device_get_mode(struct connman_device *device);
 
 extern int connman_device_set_powered(struct connman_device *device,
 						connman_bool_t powered);
diff --git a/src/device.c b/src/device.c
index 6e2575b4..ea72b251 100644
--- a/src/device.c
+++ b/src/device.c
@@ -892,6 +892,17 @@ void connman_device_set_mode(struct connman_device *device,
 	device->mode = mode;
 }
 
+/**
+ * connman_device_get_mode:
+ * @device: device structure
+ *
+ * Get network mode of device
+ */
+enum connman_device_mode connman_device_get_mode(struct connman_device *device)
+{
+	return device->mode;
+}
+
 /**
  * connman_device_set_powered:
  * @device: device structure

commit acd4243c17aa6a9896e2e7de41deb3369e8144c6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 01:55:25 2009 +0100

    Switch network to disconnected on removal

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index f9101066..f9af81ae 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1376,6 +1376,8 @@ int supplicant_disconnect(struct connman_network *network)
 
 	remove_network(task);
 
+	connman_network_set_connected(task->network, FALSE);
+
 	connman_network_unref(task->network);
 
 	return 0;

commit 3b6dd9aa9030e27513a4635e7a718feb4eea5ba1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 01:55:57 2009 +0100

    Add support for disconnecting networks first

diff --git a/include/network.h b/include/network.h
index 2232dfd3..f5d2e958 100644
--- a/include/network.h
+++ b/include/network.h
@@ -72,6 +72,7 @@ extern int connman_network_set_available(struct connman_network *network,
 extern connman_bool_t connman_network_get_available(struct connman_network *network);
 extern int connman_network_set_connected(struct connman_network *network,
 						connman_bool_t connected);
+extern connman_bool_t connman_network_get_connected(struct connman_network *network);
 extern int connman_network_set_remember(struct connman_network *network,
 						connman_bool_t remember);
 extern connman_bool_t connman_network_get_remember(struct connman_network *network);
diff --git a/src/connman.h b/src/connman.h
index 912aea1a..b007cca5 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -163,6 +163,8 @@ void __connman_device_cleanup(void);
 void __connman_device_increase_connections(struct connman_device *device);
 void __connman_device_decrease_connections(struct connman_device *device);
 
+void __connman_device_disconnect(struct connman_device *device);
+
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
 int __connman_device_set_offlinemode(connman_bool_t offlinemode);
@@ -175,6 +177,8 @@ void __connman_network_cleanup(void);
 void __connman_network_set_device(struct connman_network *network,
 					struct connman_device *device);
 
+int __connman_network_disconnect(struct connman_network *network);
+
 connman_bool_t __connman_network_has_driver(struct connman_network *network);
 
 #include <connman/rtnl.h>
diff --git a/src/device.c b/src/device.c
index ea72b251..74196b72 100644
--- a/src/device.c
+++ b/src/device.c
@@ -996,6 +996,25 @@ int connman_device_set_carrier(struct connman_device *device,
 	return 0;
 }
 
+void __connman_device_disconnect(struct connman_device *device)
+{
+	GHashTableIter iter;
+	gpointer key, value;
+
+	DBG("device %p", device);
+
+	g_hash_table_iter_init(&iter, device->networks);
+
+	while (g_hash_table_iter_next(&iter, &key, &value) == TRUE) {
+		struct connman_network *network = value;
+
+		if (connman_network_get_connected(network) == FALSE)
+			continue;
+
+		__connman_network_disconnect(network);
+	}
+}
+
 static void connect_known_network(struct connman_device *device)
 {
 	struct connman_network *network = NULL;
diff --git a/src/network.c b/src/network.c
index 3e27e7ef..6571da65 100644
--- a/src/network.c
+++ b/src/network.c
@@ -233,6 +233,12 @@ static DBusMessage *do_connect(DBusConnection *conn,
 		return __connman_error_failed(msg);
 
 	if (network->driver && network->driver->connect) {
+		enum connman_device_mode mode;
+
+		mode = connman_device_get_mode(network->device);
+		if (mode == CONNMAN_DEVICE_MODE_NETWORK_SINGLE)
+			__connman_device_disconnect(network->device);
+
 		err = network->driver->connect(network);
 		if (err < 0 && err != -EINPROGRESS)
 			return __connman_error_failed(msg);
@@ -683,6 +689,17 @@ int connman_network_set_connected(struct connman_network *network,
 	return 0;
 }
 
+/**
+ * connman_network_get_connected:
+ * @network: network structure
+ *
+ * Get network connection status
+ */
+connman_bool_t connman_network_get_connected(struct connman_network *network)
+{
+	return network->connected;
+}
+
 /**
  * connman_network_set_remember:
  * @network: network structure
@@ -756,6 +773,19 @@ int connman_network_connect(struct connman_network *network)
 	return 0;
 }
 
+int __connman_network_disconnect(struct connman_network *network)
+{
+	if (network->connected == FALSE)
+		return -ENOTCONN;
+
+	if (network->driver && network->driver->disconnect)
+		return network->driver->disconnect(network);
+
+	network->connected = FALSE;
+
+	return 0;
+}
+
 /**
  * connman_network_set_string:
  * @network: network structure

commit d09ffbb2caf8b7e1e5a092e79f3675eb98861798
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 10:33:15 2009 +0100

    Track current network within device framework

diff --git a/src/connman.h b/src/connman.h
index b007cca5..6da4c7a3 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -163,6 +163,9 @@ void __connman_device_cleanup(void);
 void __connman_device_increase_connections(struct connman_device *device);
 void __connman_device_decrease_connections(struct connman_device *device);
 
+void __connman_device_set_network(struct connman_device *device,
+					struct connman_network *network);
+
 void __connman_device_disconnect(struct connman_device *device);
 
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
diff --git a/src/device.c b/src/device.c
index 74196b72..9c31c72f 100644
--- a/src/device.c
+++ b/src/device.c
@@ -47,6 +47,7 @@ struct connman_device {
 
 	connman_bool_t registered;
 
+	struct connman_network *network;
 	GHashTable *networks;
 };
 
@@ -1008,10 +1009,8 @@ void __connman_device_disconnect(struct connman_device *device)
 	while (g_hash_table_iter_next(&iter, &key, &value) == TRUE) {
 		struct connman_network *network = value;
 
-		if (connman_network_get_connected(network) == FALSE)
-			continue;
-
-		__connman_network_disconnect(network);
+		if (connman_network_get_connected(network) == TRUE)
+			__connman_network_disconnect(network);
 	}
 }
 
@@ -1312,6 +1311,12 @@ int connman_device_remove_network(struct connman_device *device,
 	return 0;
 }
 
+void __connman_device_set_network(struct connman_device *device,
+					struct connman_network *network)
+{
+	device->network = network;
+}
+
 /**
  * connman_device_register:
  * @device: device structure
diff --git a/src/network.c b/src/network.c
index 6571da65..16df43e0 100644
--- a/src/network.c
+++ b/src/network.c
@@ -671,6 +671,8 @@ int connman_network_set_connected(struct connman_network *network,
 
 		__connman_device_increase_connections(network->device);
 
+		__connman_device_set_network(network->device, network);
+
 		element = connman_element_create(NULL);
 		if (element != NULL) {
 			element->type  = type;
@@ -683,6 +685,8 @@ int connman_network_set_connected(struct connman_network *network,
 	} else {
 		connman_element_unregister_children(&network->element);
 
+		__connman_device_set_network(network->device, NULL);
+
 		__connman_device_decrease_connections(network->device);
 	}
 

commit 03cbc012afd80dbdd75f1293ab2ada6b25044944
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 17:01:25 2009 +0100

    Add support for static IPv4 settings

diff --git a/src/connection.c b/src/connection.c
index f617ddea..f011b0c4 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -207,8 +207,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	DBusMessageIter array, dict;
 	connman_uint8_t strength = 0;
 	const char *device, *network;
-	const char *type = NULL, *method = NULL;
-	const char *address = NULL, *netmask = NULL, *gateway = NULL;
+	const char *type = NULL;
 
 	DBG("conn %p", conn);
 
@@ -255,31 +254,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Network",
 					DBUS_TYPE_OBJECT_PATH, &network);
 
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_METHOD, &method);
-
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_ADDRESS, &address);
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
-	connman_element_get_value(element,
-				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
-
-	if (method != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Method",
-						DBUS_TYPE_STRING, &method);
-
-	if (address != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Address",
-						DBUS_TYPE_STRING, &address);
-
-	if (netmask != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Netmask",
-						DBUS_TYPE_STRING, &netmask);
-
-	if (gateway != NULL)
-		connman_dbus_dict_append_variant(&dict, "IPv4.Gateway",
-						DBUS_TYPE_STRING, &gateway);
+	__connman_element_append_ipv4(element, &dict);
 
 	dbus_message_iter_close_container(&array, &dict);
 
diff --git a/src/connman.h b/src/connman.h
index 6da4c7a3..58f57ff5 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -132,6 +132,11 @@ static inline void __connman_element_unlock(struct connman_element *element)
 {
 }
 
+int __connman_element_append_ipv4(struct connman_element *element,
+						DBusMessageIter *dict);
+int __connman_element_set_ipv4(struct connman_element *element,
+				const char *name, DBusMessageIter *value);
+
 int __connman_detect_init(void);
 void __connman_detect_cleanup(void);
 
diff --git a/src/device.c b/src/device.c
index 9c31c72f..054e1aa6 100644
--- a/src/device.c
+++ b/src/device.c
@@ -296,7 +296,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 
 	switch (device->mode) {
 	case CONNMAN_DEVICE_MODE_UNKNOWN:
+		break;
 	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		__connman_element_append_ipv4(&device->element, &dict);
 		break;
 	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
 	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
@@ -375,6 +377,17 @@ static DBusMessage *set_property(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &priority);
 
 		device->priority = priority;
+	} else if (g_str_has_prefix(name, "IPv4") == TRUE) {
+		switch (device->mode) {
+		case CONNMAN_DEVICE_MODE_UNKNOWN:
+		case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+		case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+			return __connman_error_invalid_arguments(msg);
+		case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+			__connman_element_set_ipv4(&device->element,
+								name, &value);
+			break;
+		}
 	}
 
 	__connman_storage_save_device(device);
@@ -736,6 +749,8 @@ struct connman_device *connman_device_create(const char *node,
 		connman_element_add_static_property(&device->element,
 					"Type", DBUS_TYPE_STRING, &str);
 
+	device->element.ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
+
 	device->type   = type;
 	device->mode   = CONNMAN_DEVICE_MODE_UNKNOWN;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
@@ -980,11 +995,24 @@ int connman_device_set_carrier(struct connman_device *device,
 	device->carrier = carrier;
 
 	if (carrier == TRUE) {
+		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 		struct connman_element *element;
 
+		switch (device->element.ipv4.method) {
+		case CONNMAN_IPV4_METHOD_UNKNOWN:
+		case CONNMAN_IPV4_METHOD_OFF:
+			return 0;
+		case CONNMAN_IPV4_METHOD_STATIC:
+			type = CONNMAN_ELEMENT_TYPE_IPV4;
+			break;
+		case CONNMAN_IPV4_METHOD_DHCP:
+			type = CONNMAN_ELEMENT_TYPE_DHCP;
+			break;
+		}
+
 		element = connman_element_create(NULL);
 		if (element != NULL) {
-			element->type  = CONNMAN_ELEMENT_TYPE_DHCP;
+			element->type  = type;
 			element->index = device->element.index;
 
 			if (connman_element_register(element,
diff --git a/src/element.c b/src/element.c
index 858ac767..f6742f22 100644
--- a/src/element.c
+++ b/src/element.c
@@ -818,6 +818,107 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 	return result;
 }
 
+int __connman_element_append_ipv4(struct connman_element *element,
+						DBusMessageIter *dict)
+{
+	const char *method = NULL;
+	const char *address = NULL, *netmask = NULL, *gateway = NULL;
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_METHOD, &method);
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_ADDRESS, &address);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_NETMASK, &netmask);
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	if (method != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Method",
+						DBUS_TYPE_STRING, &method);
+
+	if (address != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Address",
+						DBUS_TYPE_STRING, &address);
+
+	if (netmask != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Netmask",
+						DBUS_TYPE_STRING, &netmask);
+
+	if (gateway != NULL)
+		connman_dbus_dict_append_variant(dict, "IPv4.Gateway",
+						DBUS_TYPE_STRING, &gateway);
+
+	return 0;
+}
+
+int __connman_element_set_ipv4(struct connman_element *element,
+				const char *name, DBusMessageIter *value)
+{
+	int type;
+
+	type = dbus_message_iter_get_arg_type(value);
+
+	if (g_str_equal(name, "IPv4.Method") == TRUE) {
+		enum connman_ipv4_method method;
+		const char *str;
+
+		if (type != DBUS_TYPE_STRING)
+			return -EINVAL;
+
+		dbus_message_iter_get_basic(value, &str);
+		method = __connman_ipv4_string2method(str);
+		if (method == CONNMAN_IPV4_METHOD_UNKNOWN)
+			return -EINVAL;
+
+		if (method == element->ipv4.method)
+			return -EALREADY;
+
+		element->ipv4.method = method;
+
+		connman_element_update(element);
+	} else if (g_str_equal(name, "IPv4.Address") == TRUE) {
+		const char *address;
+
+		if (type != DBUS_TYPE_STRING)
+			return -EINVAL;
+
+		dbus_message_iter_get_basic(value, &address);
+
+		g_free(element->ipv4.address);
+		element->ipv4.address = g_strdup(address);
+
+		connman_element_update(element);
+	} else if (g_str_equal(name, "IPv4.Netmask") == TRUE) {
+		const char *netmask;
+
+		if (type != DBUS_TYPE_STRING)
+			return -EINVAL;
+
+		dbus_message_iter_get_basic(value, &netmask);
+
+		g_free(element->ipv4.netmask);
+		element->ipv4.netmask = g_strdup(netmask);
+
+		connman_element_update(element);
+	} else if (g_str_equal(name, "IPv4.Gateway") == TRUE) {
+		const char *gateway;
+
+		if (type != DBUS_TYPE_STRING)
+			return -EINVAL;
+
+		dbus_message_iter_get_basic(value, &gateway);
+
+		g_free(element->ipv4.gateway);
+		element->ipv4.gateway = g_strdup(gateway);
+
+		connman_element_update(element);
+	}
+
+	return 0;
+}
+
 static void append_connections(DBusMessageIter *entry)
 {
 	DBusMessageIter value, iter;

commit d7480e83fdcc558705237c888cdc6fab8620d846
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 18:22:08 2009 +0100

    More simplification of property functions

diff --git a/include/element.h b/include/element.h
index 3549f078..5bd987b3 100644
--- a/include/element.h
+++ b/include/element.h
@@ -96,11 +96,9 @@ extern struct connman_element *connman_element_create(const char *name);
 extern struct connman_element *connman_element_ref(struct connman_element *element);
 extern void connman_element_unref(struct connman_element *element);
 
-extern int connman_element_add_static_property(struct connman_element *element,
-				const char *name, int type, const void *value);
 extern int connman_element_set_static_property(struct connman_element *element,
 				const char *name, int type, const void *value);
-extern int connman_element_add_static_array_property(struct connman_element *element,
+extern int connman_element_set_static_array_property(struct connman_element *element,
 			const char *name, int type, const void *value, int len);
 extern int connman_element_set_property(struct connman_element *element,
 				enum connman_property_id id, const void *value);
diff --git a/include/property.h b/include/property.h
index e792487f..ec8254cb 100644
--- a/include/property.h
+++ b/include/property.h
@@ -43,20 +43,8 @@ enum connman_property_id {
 	CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 };
 
-/**
- * connman_property_flags:
- * @CONNMAN_PROPERTY_FLAG_STATIC: read-only property
- * @CONNMAN_PROPERTY_FLAG_REFERENCE: inheritated value (reference only)
- */
-enum connman_property_flags {
-	CONNMAN_PROPERTY_FLAG_STATIC     = (1 << 0),
-	CONNMAN_PROPERTY_FLAG_REFERENCE  = (1 << 1),
-};
-
 struct connman_property {
-	enum connman_property_flags flags;
 	enum connman_property_id id;
-	char *name;
 	int type;
 	int subtype;
 	void *value;
diff --git a/src/device.c b/src/device.c
index 054e1aa6..a0530443 100644
--- a/src/device.c
+++ b/src/device.c
@@ -746,7 +746,7 @@ struct connman_device *connman_device_create(const char *node,
 
 	str = type2string(type);
 	if (str != NULL)
-		connman_element_add_static_property(&device->element,
+		connman_element_set_static_property(&device->element,
 					"Type", DBUS_TYPE_STRING, &str);
 
 	device->element.ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
diff --git a/src/element.c b/src/element.c
index f6742f22..70fc82a8 100644
--- a/src/element.c
+++ b/src/element.c
@@ -421,10 +421,7 @@ static void unregister_property(gpointer data)
 
 	DBG("property %p", property);
 
-	if (!(property->flags & CONNMAN_PROPERTY_FLAG_REFERENCE))
-		g_free(property->value);
-
-	g_free(property->name);
+	g_free(property->value);
 	g_free(property);
 }
 
@@ -439,7 +436,7 @@ void __connman_element_initialize(struct connman_element *element)
 	element->index   = -1;
 	element->enabled = FALSE;
 
-	element->properties = g_hash_table_new_full(g_str_hash, g_direct_equal,
+	element->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
 						g_free, unregister_property);
 }
 
@@ -511,7 +508,7 @@ void connman_element_unref(struct connman_element *element)
 	}
 }
 
-int connman_element_add_static_property(struct connman_element *element,
+int connman_element_set_static_property(struct connman_element *element,
 				const char *name, int type, const void *value)
 {
 	struct connman_property *property;
@@ -525,10 +522,8 @@ int connman_element_add_static_property(struct connman_element *element,
 	if (property == NULL)
 		return -ENOMEM;
 
-	property->flags = CONNMAN_PROPERTY_FLAG_STATIC;
-	property->id    = CONNMAN_PROPERTY_ID_INVALID;
-	property->name  = g_strdup(name);
-	property->type  = type;
+	property->id   = CONNMAN_PROPERTY_ID_INVALID;
+	property->type = type;
 
 	DBG("name %s type %d value %p", name, type, value);
 
@@ -545,50 +540,14 @@ int connman_element_add_static_property(struct connman_element *element,
 
 	__connman_element_lock(element);
 
-	g_hash_table_insert(element->properties, g_strdup(name), property);
+	g_hash_table_replace(element->properties, g_strdup(name), property);
 
 	__connman_element_unlock(element);
 
 	return 0;
 }
 
-int connman_element_set_static_property(struct connman_element *element,
-				const char *name, int type, const void *value)
-{
-	struct connman_property *property;
-
-	DBG("element %p name %s", element, element->name);
-
-	if (type != DBUS_TYPE_STRING && type != DBUS_TYPE_BYTE)
-		return -EINVAL;
-
-	__connman_element_lock(element);
-
-	property = g_hash_table_lookup(element->properties, name);
-	if (property != NULL) {
-		property->flags |= CONNMAN_PROPERTY_FLAG_STATIC;
-
-		property->type = type;
-		g_free(property->value);
-
-		switch (type) {
-		case DBUS_TYPE_STRING:
-			property->value = g_strdup(*((const char **) value));
-			break;
-		case DBUS_TYPE_BYTE:
-			property->value = g_try_malloc(1);
-			if (property->value != NULL)
-				memcpy(property->value, value, 1);
-			break;
-		}
-	}
-
-	__connman_element_unlock(element);
-
-	return 0;
-}
-
-int connman_element_add_static_array_property(struct connman_element *element,
+int connman_element_set_static_array_property(struct connman_element *element,
 			const char *name, int type, const void *value, int len)
 {
 	struct connman_property *property;
@@ -602,9 +561,7 @@ int connman_element_add_static_array_property(struct connman_element *element,
 	if (property == NULL)
 		return -ENOMEM;
 
-	property->flags   = CONNMAN_PROPERTY_FLAG_STATIC;
 	property->id      = CONNMAN_PROPERTY_ID_INVALID;
-	property->name    = g_strdup(name);
 	property->type    = DBUS_TYPE_ARRAY;
 	property->subtype = type;
 
@@ -623,7 +580,7 @@ int connman_element_add_static_array_property(struct connman_element *element,
 
 	__connman_element_lock(element);
 
-	g_hash_table_insert(element->properties, g_strdup(name), property);
+	g_hash_table_replace(element->properties, g_strdup(name), property);
 
 	__connman_element_unlock(element);
 
@@ -744,19 +701,16 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 	__connman_element_lock(element);
 
 	property = g_hash_table_lookup(element->properties, name);
-	if (property != NULL &&
-			(property->flags & CONNMAN_PROPERTY_FLAG_STATIC)) {
-		if (g_str_equal(property->name, name) == TRUE) {
-			switch (property->type) {
-			case DBUS_TYPE_STRING:
-				*((char **) value) = property->value;
-				found = TRUE;
-				break;
-			case DBUS_TYPE_BYTE:
-				memcpy(value, property->value, 1);
-				found = TRUE;
-				break;
-			}
+	if (property != NULL) {
+		switch (property->type) {
+		case DBUS_TYPE_STRING:
+			*((char **) value) = property->value;
+			found = TRUE;
+			break;
+		case DBUS_TYPE_BYTE:
+			memcpy(value, property->value, 1);
+			found = TRUE;
+			break;
 		}
 	}
 
@@ -780,13 +734,10 @@ gboolean connman_element_get_static_array_property(struct connman_element *eleme
 	__connman_element_lock(element);
 
 	property = g_hash_table_lookup(element->properties, name);
-	if (property != NULL &&
-			(property->flags & CONNMAN_PROPERTY_FLAG_STATIC)) {
-		if (g_str_equal(property->name, name) == TRUE) {
-			*((char **) value) = property->value;
-			*len = property->size;
-			found = TRUE;
-		}
+	if (property != NULL) {
+		*((char **) value) = property->value;
+		*len = property->size;
+		found = TRUE;
 	}
 
 	__connman_element_unlock(element);
@@ -805,10 +756,8 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 	__connman_element_lock(element);
 
 	property = g_hash_table_lookup(element->properties, name);
-	if (property != NULL &&
-			(property->flags & CONNMAN_PROPERTY_FLAG_STATIC)) {
-		if (g_str_equal(property->name, name) == TRUE &&
-					property->type == DBUS_TYPE_STRING)
+	if (property != NULL) {
+		if (property->type == DBUS_TYPE_STRING)
 			result = g_str_equal(property->value,
 						*((const char **) value));
 	}
diff --git a/src/network.c b/src/network.c
index 16df43e0..458ae820 100644
--- a/src/network.c
+++ b/src/network.c
@@ -462,10 +462,10 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	str = type2string(type);
 	if (str != NULL)
-		connman_element_add_static_property(&network->element,
+		connman_element_set_static_property(&network->element,
 					"Type", DBUS_TYPE_STRING, &str);
 
-	connman_element_add_static_property(&network->element,
+	connman_element_set_static_property(&network->element,
 					"Strength", DBUS_TYPE_BYTE, &strength);
 
 	network->type = type;

commit 9e003a1ccd8b2499ae44b548c3a987a493937839
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 18:26:07 2009 +0100

    Don't sent available signal for connected networks

diff --git a/src/network.c b/src/network.c
index 458ae820..b3d8812b 100644
--- a/src/network.c
+++ b/src/network.c
@@ -581,7 +581,10 @@ int connman_network_set_available(struct connman_network *network,
 	if (network->registered == FALSE)
 		return 0;
 
-	if (network->connected == FALSE && network->remember == FALSE)
+	if (network->connected == TRUE)
+		return 0;
+
+	if (network->remember == FALSE)
 		return 0;
 
 	signal = dbus_message_new_signal(network->element.path,

commit 9f02a110ab06991b9bcce6ff1ff651c2069eb3ad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 18:46:55 2009 +0100

    Reconnecting to last selected network by default

diff --git a/src/device.c b/src/device.c
index a0530443..a2a29beb 100644
--- a/src/device.c
+++ b/src/device.c
@@ -47,6 +47,7 @@ struct connman_device {
 
 	connman_bool_t registered;
 
+	char *last_network;
 	struct connman_network *network;
 	GHashTable *networks;
 };
@@ -709,6 +710,8 @@ static void device_destruct(struct connman_element *element)
 	g_free(device->name);
 	g_free(device->interface);
 
+	g_free(device->last_network);
+
 	g_hash_table_destroy(device->networks);
 	device->networks = NULL;
 }
@@ -1056,9 +1059,18 @@ static void connect_known_network(struct connman_device *device)
 	while (g_hash_table_iter_next(&iter, &key, &value) == TRUE) {
 		connman_uint8_t old_priority, new_priority;
 		connman_uint8_t old_strength, new_strength;
+		const char *name;
 
 		count++;
 
+		name = connman_network_get_string(value, "Name");
+		if (name != NULL && device->last_network != NULL) {
+			if (g_str_equal(name, device->last_network) == TRUE) {
+				network = value;
+				break;
+			}
+		}
+
 		if (connman_network_get_remember(value) == FALSE)
 			continue;
 
@@ -1342,6 +1354,13 @@ int connman_device_remove_network(struct connman_device *device,
 void __connman_device_set_network(struct connman_device *device,
 					struct connman_network *network)
 {
+	const char *name;
+
+	if (network != NULL) {
+		name = connman_network_get_string(network, "Name");
+		device->last_network = g_strdup(name);
+	}
+
 	device->network = network;
 }
 
@@ -1513,6 +1532,11 @@ static int device_load(struct connman_device *device)
 	if (val > 0)
 		device->priority = val;
 
+	str = g_key_file_get_string(keyfile, "Configuration",
+							"LastNetwork", NULL);
+	if (str != NULL)
+		device->last_network = str;
+
 	g_key_file_free(keyfile);
 
 	return 0;
@@ -1554,6 +1578,10 @@ update:
 		g_key_file_set_integer(keyfile, "Configuration",
 						"Priority", device->priority);
 
+	if (device->last_network != NULL)
+		g_key_file_set_string(keyfile, "Configuration",
+					"LastNetwork", device->last_network);
+
 	data = g_key_file_to_data(keyfile, &length, NULL);
 
 	g_file_set_contents(pathname, data, length, NULL);
@@ -1565,6 +1593,9 @@ done:
 
 	g_free(pathname);
 
+	if (device->network != NULL)
+		__connman_storage_save_network(device->network);
+
 	return 0;
 }
 
diff --git a/src/network.c b/src/network.c
index b3d8812b..4a7b8f2d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1109,15 +1109,13 @@ static int network_load(struct connman_network *network)
 	if (val > 0)
 		network->priority = val;
 
-	if (network->remember == TRUE) {
-		g_free(network->wifi.security);
-		network->wifi.security = g_key_file_get_string(keyfile,
+	g_free(network->wifi.security);
+	network->wifi.security = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Security", NULL);
 
-		g_free(network->wifi.passphrase);
-		network->wifi.passphrase = g_key_file_get_string(keyfile,
+	g_free(network->wifi.passphrase);
+	network->wifi.passphrase = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Passphrase", NULL);
-	}
 
 	g_key_file_free(keyfile);
 
@@ -1162,7 +1160,7 @@ update:
 		g_key_file_set_integer(keyfile, network->identifier,
 						"Priority", network->priority);
 
-	if (network->remember == TRUE) {
+	if (network->remember == TRUE || network->connected == TRUE) {
 		if (network->wifi.security != NULL)
 			g_key_file_set_string(keyfile, network->identifier,
 				"WiFi.Security", network->wifi.security);

commit 7054e93685c8c18838cc78500566ba4277a5cb26
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 18:54:41 2009 +0100

    Add more advanced test script for device handling

diff --git a/test/Makefile.am b/test/Makefile.am
index 11f19fd7..e88b602d 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -4,6 +4,7 @@ EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-networks select-network disable-network create-network \
 		set-passphrase set-address set-policy test-manager \
 		connect-network disconnect-network simple-agent \
-		show-introspection test-compat monitor-connman debug-connman
+		show-introspection test-compat \
+		test-connman monitor-connman debug-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/test-connman b/test/test-connman
new file mode 100755
index 00000000..c59a064c
--- /dev/null
+++ b/test/test-connman
@@ -0,0 +1,265 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+if len(sys.argv) < 2:
+	print "Usage: %s <command>" % (sys.argv[0])
+	print ""
+	print "  state"
+	print "  scan [ <interface> ]"
+	print "  dev <interface>"
+	print "  dev <interface> scan"
+	print "  dev <interface> networks"
+	print "  dev <interface> connect <network>"
+	print "  dev <interface> remember <network>"
+	print "  dev <interface> disconnect [network]"
+	print "  dev <interface> policy [ignore|off|auto|manual]"
+	print "  dev <interface> powered [on|off]"
+	print "  dev <interface> priority [0-255]"
+	sys.exit(1)
+
+def print_properties(path, properties):
+	print "[ %s ]" % (path)
+	for key in properties.keys():
+		if key == "Networks":
+			continue
+
+		if key in ["Powered", "Scanning", "Connected",
+					"Available", "Remember", "Default"]:
+			if properties[key] == dbus.Boolean(1):
+				val = "true"
+			else:
+				val = "false"
+		elif key in ["Strength", "Priority"]:
+			val = int(properties[key])
+		else:
+			val = str(properties[key])
+
+		print "     %s = %s" % (key, val)
+
+	if "Networks" in properties.keys():
+		list = ""
+		for path in properties["Networks"]:
+			val = str(path)
+			list = list + val[val.rfind("/") + 1:] + " "
+		print "     Networks = [ %s]" % (list)
+
+def print_networks(networks):
+	for path in networks:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if properties["Connected"] == dbus.Boolean(1):
+			connected = "*"
+		else:
+			connected = " "
+
+		name = properties["Name"]
+		strength = int(properties["Strength"])
+
+		details = ""
+		try:
+			details += "{" + properties["WiFi.Mode"] + "} "
+		except:
+			pass
+		try:
+			details += "{" + properties["WiFi.Security"] + "} "
+		except:
+			pass
+		if "WiFi.Passphrase" in properties.keys():
+			if properties["WiFi.Passphrase"] != "":
+				details += "{passphrase present}"
+
+		print "%s %-20s %3d%%  %s" % (connected,
+						name, strength, details)
+
+def select_network(networks, name):
+	for path in networks:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if properties["Name"] != name:
+			continue
+
+		if properties["Connected"] == dbus.Boolean(1):
+			print "Already connected to network %s" % (name)
+			break
+
+		print "Selecting network %s" % (name)
+
+		network.Connect()
+
+def remember_network(networks, name):
+	for path in networks:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if properties["Name"] != name:
+			continue
+
+		if properties["Remember"] == dbus.Boolean(1):
+			print "Already a known network %s" % (name)
+			break
+
+		print "Remembering network %s" % (name)
+
+		network.SetProperty("Remember", dbus.Boolean(1))
+
+def disconnect_network(networks, name):
+	for path in networks:
+		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Network")
+
+		properties = network.GetProperties()
+
+		if name != "" and properties["Name"] != name:
+			continue
+
+		if properties["Connected"] == dbus.Boolean(1):
+			name = properties["Name"]
+			print "Disconnecting from network %s" % (name)
+			network.Disconnect()
+
+if sys.argv[1] == "state":
+	properties = manager.GetProperties()
+
+	print "System is %s" % (properties["State"])
+
+elif sys.argv[1] == "scan":
+	properties = manager.GetProperties()
+
+	interface = ""
+	found = 0
+
+	if len(sys.argv) > 2:
+		interface = sys.argv[2]
+
+	for path in properties["Devices"]:
+		device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+		properties = device.GetProperties()
+
+		if interface != "" and properties["Interface"] != interface:
+			continue
+
+		if properties["Type"] in ["wifi", "wimax"]:
+			interface = properties["Interface"]
+			print "Propose scanning for device %s" % (interface)
+			device.ProposeScan()
+			found = 1
+		elif interface != "":
+			print "No scanning support for device %s" % (interface)
+			found = 1
+
+	if found == 0:
+		print "No such device"
+
+elif sys.argv[1] == "dev":
+	properties = manager.GetProperties()
+
+	interface = ""
+	command = ""
+	value = ""
+	found = 0
+
+	if len(sys.argv) > 2:
+		interface = sys.argv[2]
+		if len(sys.argv) > 3:
+			command = sys.argv[3]
+			if len(sys.argv) > 4:
+				value = sys.argv[4]
+
+	for path in properties["Devices"]:
+		device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+		properties = device.GetProperties()
+
+		if interface != "" and properties["Interface"] != interface:
+			continue
+
+		if command == "scan":
+			if properties["Type"] in ["wifi", "wimax"]:
+				interface = properties["Interface"]
+				print "Scan for device %s" % (interface)
+				device.ProposeScan()
+			else:
+				print "No scanning for device %s" % (interface)
+		elif command in ["networks", "net"]:
+			if "Networks" in properties.keys():
+				print_networks(properties["Networks"])
+			else:
+				print "Device has no networks"
+		elif command in ["connect", "conn"] and value != "":
+			if "Networks" in properties.keys():
+				select_network(properties["Networks"], value)
+			else:
+				print "Device can't connect networks"
+		elif command in ["connect", "conn"]:
+			print "Need to specify network"
+		elif command in ["remember", "known"] and value != "":
+			if "Networks" in properties.keys():
+				remember_network(properties["Networks"], value)
+			else:
+				print "Device has no networks"
+		elif command in ["remember", "known"]:
+			print "Need to specify network"
+		elif command in ["disconnect", "disc"] and value != "":
+			if "Networks" in properties.keys():
+				disconnect_network(properties["Networks"], value)
+			else:
+				print "Device has no networks"
+		elif command in ["discconnect", "disc"]:
+			if "Networks" in properties.keys():
+				disconnect_network(properties["Networks"], "")
+			else:
+				print "Device has no networks"
+		elif command == "policy" and value != "":
+			policy = value
+			device.SetProperty("Policy", policy)
+		elif command == "policy":
+			interface = properties["Interface"]
+			policy = properties["Policy"]
+			print "Policy of device %s is %s" % (interface, policy)
+		elif command == "powered" and value != "":
+			if value == "on":
+				powered = dbus.Boolean(1)
+			elif value == "off":
+				powered = dbus.Boolean(0)
+			else:
+				powered = dbus.Boolean(value)
+			device.SetProperty("Powered", powered)
+		elif command == "powered":
+			interface = properties["Interface"]
+			if properties["Powered"] == dbus.Boolean(1):
+				powered = "on"
+			else:
+				powered = "off"
+			print "Device %s is powered %s" % (interface, powered)
+		elif command == "priority" and value != "":
+			priority = int(value)
+			device.SetProperty("Priority", priority)
+		elif command == "priority":
+			interface = properties["Interface"]
+			priority = properties["Priority"]
+			print "Device %s has priority of %d" % (interface, priority)
+		elif command == "list" or command == "":
+			print_properties(path, properties)
+		else:
+			print "Unknown command"
+
+else:
+	print "Unknown command"

commit 2c171d0621ec983c641525d33b6b6c8766e79cb8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 19:26:44 2009 +0100

    Introduce global "connecting" state

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 5ff5f6a8..1f50d944 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -45,6 +45,10 @@ Properties	string State [readonly]
 			values are "online" if at least one connection exists
 			and "offline" if no device is connected.
 
+			In certain situations the state might change to
+			the value "connected". This can only be seen if
+			previously no connection was present.
+
 		string Policy [readwrite]
 
 			The global connection policy of a system. This
diff --git a/include/element.h b/include/element.h
index 5bd987b3..8bdc42c4 100644
--- a/include/element.h
+++ b/include/element.h
@@ -64,6 +64,7 @@ struct connman_element {
 	gchar *path;
 	enum connman_element_type type;
 	gboolean enabled;
+	gboolean configuring;
 	gchar *devname;
 
 	struct connman_element *parent;
diff --git a/src/element.c b/src/element.c
index 70fc82a8..0a6a0378 100644
--- a/src/element.c
+++ b/src/element.c
@@ -436,6 +436,8 @@ void __connman_element_initialize(struct connman_element *element)
 	element->index   = -1;
 	element->enabled = FALSE;
 
+	element->configuring = FALSE;
+
 	element->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
 						g_free, unregister_property);
 }
@@ -988,9 +990,27 @@ static void register_element(gpointer data, gpointer user_data)
 
 	g_node_append_data(node, element);
 
+	if (element->type == CONNMAN_ELEMENT_TYPE_DHCP) {
+		element->parent->configuring = TRUE;
+
+		if (__connman_element_count(NULL,
+					CONNMAN_ELEMENT_TYPE_CONNECTION) == 0)
+			emit_state_change(connection, "connecting");
+	}
+
 	if (element->type == CONNMAN_ELEMENT_TYPE_CONNECTION) {
+		struct connman_element *parent = element->parent;
+
+		while (parent) {
+			parent->configuring = FALSE;
+			parent = parent->parent;
+		}
+
 		emit_connections_signal(connection);
-		emit_state_change(connection, "online");
+
+		if (__connman_element_count(NULL,
+					CONNMAN_ELEMENT_TYPE_CONNECTION) == 1)
+			emit_state_change(connection, "online");
 	}
 
 	emit_element_signal(connection, "ElementAdded", element);
@@ -1082,6 +1102,7 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		if (__connman_element_count(NULL,
 					CONNMAN_ELEMENT_TYPE_CONNECTION) == 0)
 			emit_state_change(connection, "offline");
+
 		emit_connections_signal(connection);
 	}
 

commit 6265392bdc7c99f926114c5af3ccf008d8e45710
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 19:49:08 2009 +0100

    Add support for special disconnected device state

diff --git a/include/device.h b/include/device.h
index abd62cfb..0f30100b 100644
--- a/include/device.h
+++ b/include/device.h
@@ -91,6 +91,8 @@ extern int connman_device_set_carrier(struct connman_device *device,
 						connman_bool_t carrier);
 extern int connman_device_set_scanning(struct connman_device *device,
 						connman_bool_t scanning);
+extern int connman_device_set_disconnected(struct connman_device *device,
+						connman_bool_t disconnected);
 
 extern int connman_device_set_string(struct connman_device *device,
 					const char *key, const char *value);
diff --git a/src/device.c b/src/device.c
index a2a29beb..293055b5 100644
--- a/src/device.c
+++ b/src/device.c
@@ -36,6 +36,7 @@ struct connman_device {
 	connman_bool_t powered;
 	connman_bool_t carrier;
 	connman_bool_t scanning;
+	connman_bool_t disconnected;
 	connman_uint8_t priority;
 	char *name;
 	char *node;
@@ -1187,6 +1188,9 @@ int connman_device_set_scanning(struct connman_device *device,
 	if (device->connections > 0)
 		return 0;
 
+	if (device->disconnected == TRUE)
+		return 0;
+
 	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
 		return 0;
 
@@ -1195,6 +1199,35 @@ int connman_device_set_scanning(struct connman_device *device,
 	return 0;
 }
 
+/**
+ * connman_device_set_disconnected:
+ * @device: device structure
+ * @disconnected: disconnected state
+ *
+ * Change disconnected state of device (only for device with networks)
+ */
+int connman_device_set_disconnected(struct connman_device *device,
+						connman_bool_t disconnected)
+{
+	DBG("driver %p disconnected %d", device, disconnected);
+
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		return -EINVAL;
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		break;
+	}
+
+	if (device->disconnected == disconnected)
+		return -EALREADY;
+
+	device->disconnected = disconnected;
+
+	return 0;
+}
+
 /**
  * connman_device_set_string:
  * @device: device structure
diff --git a/src/network.c b/src/network.c
index 4a7b8f2d..45213a9b 100644
--- a/src/network.c
+++ b/src/network.c
@@ -245,6 +245,8 @@ static DBusMessage *do_connect(DBusConnection *conn,
 	} else
 		network->connected = TRUE;
 
+	connman_device_set_disconnected(network->device, FALSE);
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -272,6 +274,8 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 	} else
 		network->connected = FALSE;
 
+	connman_device_set_disconnected(network->device, TRUE);
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 

commit 8852fdac8997bf2160c633ed64cadad34cb0ca8a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 19:55:37 2009 +0100

    Remove the disconnected state once connected

diff --git a/src/device.c b/src/device.c
index 293055b5..00b80196 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1036,6 +1036,8 @@ void __connman_device_disconnect(struct connman_device *device)
 
 	DBG("device %p", device);
 
+	connman_device_set_disconnected(device, TRUE);
+
 	g_hash_table_iter_init(&iter, device->networks);
 
 	while (g_hash_table_iter_next(&iter, &key, &value) == TRUE) {
diff --git a/src/network.c b/src/network.c
index 45213a9b..c41871d0 100644
--- a/src/network.c
+++ b/src/network.c
@@ -245,8 +245,6 @@ static DBusMessage *do_connect(DBusConnection *conn,
 	} else
 		network->connected = TRUE;
 
-	connman_device_set_disconnected(network->device, FALSE);
-
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -267,6 +265,8 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 
 	connman_element_unregister_children(&network->element);
 
+	connman_device_set_disconnected(network->device, TRUE);
+
 	if (network->driver && network->driver->disconnect) {
 		err = network->driver->disconnect(network);
 		if (err < 0 && err != -EINPROGRESS)
@@ -274,8 +274,6 @@ static DBusMessage *do_disconnect(DBusConnection *conn,
 	} else
 		network->connected = FALSE;
 
-	connman_device_set_disconnected(network->device, TRUE);
-
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -680,6 +678,8 @@ int connman_network_set_connected(struct connman_network *network,
 
 		__connman_device_set_network(network->device, network);
 
+		connman_device_set_disconnected(network->device, FALSE);
+
 		element = connman_element_create(NULL);
 		if (element != NULL) {
 			element->type  = type;

commit 621adb59b0fc8d576e5372ae7221aae3e055b726
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 21:25:30 2009 +0100

    Fix network out of range detection

diff --git a/src/device.c b/src/device.c
index 00b80196..a2b8f6f1 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1118,7 +1118,7 @@ static void mark_network_unavailable(gpointer key, gpointer value,
 {
 	struct connman_network *network = value;
 
-	if (connman_network_get_remember(network) == TRUE)
+	if (connman_network_get_connected(network) == TRUE)
 		return;
 
 	connman_network_set_available(network, FALSE);
@@ -1129,6 +1129,9 @@ static gboolean remove_unavailable_network(gpointer key, gpointer value,
 {
 	struct connman_network *network = value;
 
+	if (connman_network_get_connected(network) == TRUE)
+		return FALSE;
+
 	if (connman_network_get_remember(network) == TRUE)
 		return FALSE;
 

commit ec02283f6e4bcfa2cda224cbc23b398c2862c5d1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 21:39:50 2009 +0100

    Fix copy and paste mistake

diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index e53c4354..f58f8333 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -211,5 +211,5 @@ static void udhcp_exit(void)
 	dbus_connection_unref(connection);
 }
 
-CONNMAN_PLUGIN_DEFINE(dhclient, "uDHCP client plugin", VERSION,
+CONNMAN_PLUGIN_DEFINE(udhcp, "uDHCP client plugin", VERSION,
 						udhcp_init, udhcp_exit)

commit 0f02f72a8e871f79c8230b9bc954c9db66dbd34b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 21:42:41 2009 +0100

    Add extra options to exclude devices and plugins

diff --git a/src/connman.h b/src/connman.h
index 58f57ff5..42382348 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -62,7 +62,7 @@ gboolean __connman_debug_enabled(void);
 
 #include <connman/plugin.h>
 
-int __connman_plugin_init(const char *pattern);
+int __connman_plugin_init(const char *pattern, const char *exclude);
 void __connman_plugin_cleanup(void);
 
 #include <connman/security.h>
@@ -100,7 +100,8 @@ void __connman_driver_rescan(struct connman_driver *driver);
 
 #include <connman/element.h>
 
-int __connman_element_init(DBusConnection *conn, const char *device);
+int __connman_element_init(DBusConnection *conn, const char *device,
+							const char *nodevice);
 void __connman_element_start(void);
 void __connman_element_stop(void);
 void __connman_element_cleanup(void);
diff --git a/src/element.c b/src/element.c
index 0a6a0378..2f1aa433 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1177,7 +1177,8 @@ int connman_element_set_enabled(struct connman_element *element,
 	return 0;
 }
 
-int __connman_element_init(DBusConnection *conn, const char *device)
+int __connman_element_init(DBusConnection *conn, const char *device,
+							const char *nodevice)
 {
 	struct connman_element *element;
 
diff --git a/src/main.c b/src/main.c
index 5da7c861..581446e6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -52,6 +52,8 @@ static void disconnect_callback(DBusConnection *conn, void *user_data)
 
 static gchar *option_device = NULL;
 static gchar *option_plugin = NULL;
+static gchar *option_nodevice = NULL;
+static gchar *option_noplugin = NULL;
 static gboolean option_detach = TRUE;
 static gboolean option_compat = FALSE;
 static gboolean option_debug = FALSE;
@@ -60,9 +62,13 @@ static gboolean option_version = FALSE;
 
 static GOptionEntry options[] = {
 	{ "device", 'i', 0, G_OPTION_ARG_STRING, &option_device,
-				"Specify network device/interface", "DEV" },
+			"Specify networking device or interface", "DEV" },
+	{ "nodevice", 'I', 0, G_OPTION_ARG_STRING, &option_nodevice,
+			"Specify networking interface to ignore", "DEV" },
 	{ "plugin", 'p', 0, G_OPTION_ARG_STRING, &option_plugin,
 				"Specify plugins to load", "NAME" },
+	{ "noplugin", 'P', 0, G_OPTION_ARG_STRING, &option_noplugin,
+				"Specify plugins not to load", "NAME" },
 	{ "nodaemon", 'n', G_OPTION_FLAG_REVERSE,
 				G_OPTION_ARG_NONE, &option_detach,
 				"Don't fork daemon to background" },
@@ -164,7 +170,7 @@ int main(int argc, char *argv[])
 	__connman_dbus_init(conn);
 
 	__connman_storage_init();
-	__connman_element_init(conn, option_device);
+	__connman_element_init(conn, option_device, option_nodevice);
 
 	__connman_agent_init(conn);
 	__connman_manager_init(conn, option_compat);
@@ -174,12 +180,14 @@ int main(int argc, char *argv[])
 	__connman_rtnl_init();
 	__connman_udev_init();
 
-	__connman_plugin_init(option_plugin);
+	__connman_plugin_init(option_plugin, option_noplugin);
 
 	__connman_element_start();
 
 	g_free(option_device);
 	g_free(option_plugin);
+	g_free(option_nodevice);
+	g_free(option_noplugin);
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_handler = sig_term;
diff --git a/src/plugin.c b/src/plugin.c
index 7fb7d444..59d3572c 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -43,8 +43,10 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	if (desc->init == NULL)
 		return FALSE;
 
-	if (g_str_equal(desc->version, CONNMAN_VERSION) == FALSE)
+	if (g_str_equal(desc->version, CONNMAN_VERSION) == FALSE) {
+		DBG("version mismatch for %s", desc->description);
 		return FALSE;
+	}
 
 	plugin = g_try_new0(struct connman_plugin, 1);
 	if (plugin == NULL)
@@ -63,7 +65,7 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	return TRUE;
 }
 
-int __connman_plugin_init(const char *pattern)
+int __connman_plugin_init(const char *pattern, const char *exclude)
 {
 	GDir *dir;
 	const gchar *file;
@@ -100,6 +102,13 @@ int __connman_plugin_init(const char *pattern)
 				continue;
 			}
 
+			if (exclude != NULL && g_pattern_match_simple(exclude,
+							desc->name) == TRUE) {
+				DBG("excluding %s", desc->description);
+				dlclose(handle);
+				continue;
+			}
+
 			if (pattern != NULL && g_pattern_match_simple(pattern,
 							desc->name) == FALSE) {
 				DBG("ignoring %s", desc->description);

commit 8074bba2f209e26bc2ab6cf0426241f5ec30da23
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 21:43:53 2009 +0100

    Don't try to re-connect to networks out of range

diff --git a/src/device.c b/src/device.c
index a2b8f6f1..b9ed1f51 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1066,6 +1066,9 @@ static void connect_known_network(struct connman_device *device)
 
 		count++;
 
+		if (connman_network_get_available(value) == FALSE)
+			continue;
+
 		name = connman_network_get_string(value, "Name");
 		if (name != NULL && device->last_network != NULL) {
 			if (g_str_equal(name, device->last_network) == TRUE) {

commit 346c30414e8a347aa001758d666124aec4035cd9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 22:11:58 2009 +0100

    Add support for toggling debug output

diff --git a/src/connman.h b/src/connman.h
index 42382348..729dc42d 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -58,6 +58,7 @@ void __connman_profile_list(DBusMessageIter *iter);
 int __connman_log_init(gboolean detach, gboolean debug);
 void __connman_log_cleanup(void);
 
+void __connman_toggle_debug(void);
 gboolean __connman_debug_enabled(void);
 
 #include <connman/plugin.h>
diff --git a/src/log.c b/src/log.c
index 33d2bf50..3a87b936 100644
--- a/src/log.c
+++ b/src/log.c
@@ -90,6 +90,14 @@ void connman_debug(const char *format, ...)
 	va_end(ap);
 }
 
+void __connman_toggle_debug(void)
+{
+	if (debug_enabled == TRUE)
+		debug_enabled = FALSE;
+	else
+		debug_enabled = TRUE;
+}
+
 int __connman_log_init(gboolean detach, gboolean debug)
 {
 	int option = LOG_NDELAY | LOG_PID;
diff --git a/src/main.c b/src/main.c
index 581446e6..457776c2 100644
--- a/src/main.c
+++ b/src/main.c
@@ -43,6 +43,11 @@ static void sig_term(int sig)
 	g_main_loop_quit(main_loop);
 }
 
+static void sig_debug(int sig)
+{
+	__connman_toggle_debug();
+}
+
 static void disconnect_callback(DBusConnection *conn, void *user_data)
 {
 	DBG("D-Bus disconnect");
@@ -194,6 +199,9 @@ int main(int argc, char *argv[])
 	sigaction(SIGINT, &sa, NULL);
 	sigaction(SIGTERM, &sa, NULL);
 
+	sa.sa_handler = sig_debug;
+	sigaction(SIGUSR2, &sa, NULL);
+
 	g_main_loop_run(main_loop);
 
 	__connman_element_stop();

commit fc12c78cc7d2a442a52c96d1c0c1912bff309a43
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 22:44:05 2009 +0100

    Add support for ScanInterval property

diff --git a/doc/device-api.txt b/doc/device-api.txt
index b0cf440e..ce50be7b 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -106,6 +106,19 @@ Properties	string Name [readonly]
 			example would be modifications via the "ifconfig"
 			command line utility.
 
+		uint16 ScanInterval [readwrite]
+
+			The scan interval describes the time in seconds
+			between automated scan attempts. Setting this
+			value to 0 will disable the background scanning.
+
+			The default value is 300 and so every 5 minutes
+			a scan procedure will be triggered.
+
+			This property is not available with all types
+			of devices. Some might not support background
+			scanning at all.
+
 		boolean Scanning [readonly]
 
 			Indicates if a device is scanning. Not all device
diff --git a/include/types.h b/include/types.h
index af2a81bc..ab58f1e0 100644
--- a/include/types.h
+++ b/include/types.h
@@ -36,6 +36,7 @@ extern "C" {
 
 typedef int		connman_bool_t;
 typedef unsigned char	connman_uint8_t;
+typedef unsigned short	connman_uint16_t;
 
 #ifdef __cplusplus
 }
diff --git a/src/device.c b/src/device.c
index b9ed1f51..69604ddd 100644
--- a/src/device.c
+++ b/src/device.c
@@ -38,10 +38,12 @@ struct connman_device {
 	connman_bool_t scanning;
 	connman_bool_t disconnected;
 	connman_uint8_t priority;
+	connman_uint16_t scan_interval;
 	char *name;
 	char *node;
 	char *interface;
 	unsigned int connections;
+	guint scan_timeout;
 
 	struct connman_device_driver *driver;
 	void *driver_data;
@@ -53,6 +55,23 @@ struct connman_device {
 	GHashTable *networks;
 };
 
+static gboolean device_scan_trigger(gpointer user_data)
+{
+	struct connman_device *device = user_data;
+
+	DBG("device %p", device);
+
+	if (device->driver == NULL) {
+		device->scan_timeout = 0;
+		return FALSE;
+	}
+
+	if (device->driver->scan)
+		device->driver->scan(device);
+
+	return TRUE;
+}
+
 static const char *type2description(enum connman_device_type type)
 {
 	switch (type) {
@@ -304,6 +323,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		break;
 	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
 	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		if (device->scan_interval > 0)
+			connman_dbus_dict_append_variant(&dict, "ScanInterval",
+				DBUS_TYPE_UINT16, &device->scan_interval);
+
 		dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
 								NULL, &entry);
 		append_networks(device, &entry);
@@ -379,6 +402,35 @@ static DBusMessage *set_property(DBusConnection *conn,
 		dbus_message_iter_get_basic(&value, &priority);
 
 		device->priority = priority;
+	} else if (g_str_equal(name, "ScanInterval") == TRUE) {
+		connman_uint16_t interval;
+
+		switch (device->mode) {
+		case CONNMAN_DEVICE_MODE_UNKNOWN:
+		case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+			return __connman_error_invalid_arguments(msg);
+		case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+		case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+			break;
+		}
+
+		if (type != DBUS_TYPE_UINT16)
+			return __connman_error_invalid_arguments(msg);
+
+		dbus_message_iter_get_basic(&value, &interval);
+
+		device->scan_interval = interval;
+
+		if (device->scan_timeout > 0) {
+			g_source_remove(device->scan_timeout);
+			device->scan_timeout = 0;
+		}
+
+		if (device->scan_interval > 0) {
+			guint interval = device->scan_interval;
+			device->scan_timeout = g_timeout_add_seconds(interval,
+						device_scan_trigger, device);
+		}
 	} else if (g_str_has_prefix(name, "IPv4") == TRUE) {
 		switch (device->mode) {
 		case CONNMAN_DEVICE_MODE_UNKNOWN:
@@ -763,22 +815,27 @@ struct connman_device *connman_device_create(const char *node,
 	case CONNMAN_DEVICE_TYPE_UNKNOWN:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
 		device->priority = 0;
+		device->scan_interval = 0;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
 	case CONNMAN_DEVICE_TYPE_WIFI:
 		device->priority = 100;
+		device->scan_interval = 300;
 		break;
 	case CONNMAN_DEVICE_TYPE_WIMAX:
 		device->priority = 20;
+		device->scan_interval = 0;
 		break;
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		device->priority = 50;
+		device->scan_interval = 0;
 		break;
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 		device->priority = 60;
+		device->scan_interval = 0;
 		break;
 	}
 
@@ -966,6 +1023,17 @@ int connman_device_set_powered(struct connman_device *device,
 	if (device->policy != CONNMAN_DEVICE_POLICY_AUTO)
 		return 0;
 
+	if (device->scan_timeout > 0) {
+		g_source_remove(device->scan_timeout);
+		device->scan_timeout = 0;
+	}
+
+	if (device->scan_interval > 0) {
+		guint interval = device->scan_interval;
+		device->scan_timeout = g_timeout_add_seconds(interval,
+					device_scan_trigger, device);
+	}
+
 	if (device->driver->scan)
 		device->driver->scan(device);
 
@@ -1573,6 +1641,19 @@ static int device_load(struct connman_device *device)
 	if (val > 0)
 		device->priority = val;
 
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		break;
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		val = g_key_file_get_integer(keyfile, "Configuration",
+							"ScanInterval", NULL);
+		if (val > 0)
+			device->scan_interval = val;
+		break;
+	}
+
 	str = g_key_file_get_string(keyfile, "Configuration",
 							"LastNetwork", NULL);
 	if (str != NULL)
@@ -1619,6 +1700,18 @@ update:
 		g_key_file_set_integer(keyfile, "Configuration",
 						"Priority", device->priority);
 
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		break;
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		if (device->scan_interval > 0)
+			g_key_file_set_integer(keyfile, "Configuration",
+					"ScanInterval", device->scan_interval);
+		break;
+	}
+
 	if (device->last_network != NULL)
 		g_key_file_set_string(keyfile, "Configuration",
 					"LastNetwork", device->last_network);

commit fe697fea5b178b866d566e78d83e793f5aa7d862
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 21 22:51:23 2009 +0100

    Reset scan trigger when scanning was performed

diff --git a/src/device.c b/src/device.c
index 69604ddd..8427a2c9 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1253,6 +1253,17 @@ int connman_device_set_scanning(struct connman_device *device,
 	g_dbus_send_message(connection, signal);
 
 	if (scanning == TRUE) {
+		if (device->scan_timeout > 0) {
+			g_source_remove(device->scan_timeout);
+			device->scan_timeout = 0;
+		}
+
+		if (device->scan_interval > 0) {
+			guint interval = device->scan_interval;
+			device->scan_timeout = g_timeout_add_seconds(interval,
+						device_scan_trigger, device);
+		}
+
 		g_hash_table_foreach(device->networks,
 					mark_network_unavailable, NULL);
 		return 0;

commit 5c370e9cb43f2a7581bde26a96f0b20c38030d41
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 22 19:22:14 2009 +0100

    Release 0.9

diff --git a/ChangeLog b/ChangeLog
index 61d9dba5..edbb9df8 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,14 @@
+ver 0.9:
+	Rename FlightMode to OfflineMode.
+	Add static IPv4 setting support for Ethernet devices.
+	Add extra options to exclude devices and plugins.
+	Add support for toggling debug output.
+	Add support for ScanInterval property.
+	Fix handling of disconnect commands from applications.
+	Fix detection of networks that are out of range.
+	Fix setting network remember status.
+	Fix argument type checking of properties.
+
 ver 0.8:
 	Add Device and Network property to connection interface.
 	Add option to disable installation of data files.
diff --git a/configure.ac b/configure.ac
index 61870b68..f7d245a4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.8)
+AM_INIT_AUTOMAKE(connman, 0.9)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit c5f2e63d9026d92c5bb4676cad456d495b02dd1c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 23 23:15:24 2009 +0100

    Remove some empty lines

diff --git a/src/manager.c b/src/manager.c
index a2f1be81..5e68e4f5 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -81,9 +81,7 @@ static void append_profiles(DBusMessageIter *dict)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
 	__connman_profile_list(&iter);
-
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(&entry, &value);
@@ -107,9 +105,7 @@ static void append_devices(DBusMessageIter *dict)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
 	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_DEVICE, &iter);
-
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(&entry, &value);
@@ -133,9 +129,7 @@ static void append_connections(DBusMessageIter *dict)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-
 	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
-
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(&entry, &value);

commit 71d6a9e1271a7c18f22b9215f700c9b567a36fad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 23 23:15:44 2009 +0100

    Move connection signal handling away from elements core

diff --git a/src/connection.c b/src/connection.c
index f011b0c4..d102380c 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -63,48 +63,6 @@ static struct gateway_data *find_gateway(int index, const char *gateway)
 	return NULL;
 }
 
-static void connection_newgateway(int index, const char *gateway)
-{
-	struct gateway_data *data;
-
-	DBG("index %d gateway %s", index, gateway);
-
-	data = find_gateway(index, gateway);
-	if (data != NULL)
-		return;
-
-	data = g_try_new0(struct gateway_data, 1);
-	if (data == NULL)
-		return;
-
-	data->index = index;
-	data->gateway = g_strdup(gateway);
-
-	gateway_list = g_slist_append(gateway_list, data);
-}
-
-static void connection_delgateway(int index, const char *gateway)
-{
-	struct gateway_data *data;
-
-	DBG("index %d gateway %s", index, gateway);
-
-	data = find_gateway(index, gateway);
-	if (data == NULL)
-		return;
-
-	gateway_list = g_slist_remove(gateway_list, data);
-
-	g_free(data->gateway);
-	g_free(data);
-}
-
-static struct connman_rtnl connection_rtnl = {
-	.name		= "connection",
-	.newgateway	= connection_newgateway,
-	.delgateway	= connection_delgateway,
-};
-
 static int set_route(struct connman_element *element, const char *gateway)
 {
 	struct ifreq ifr;
@@ -199,6 +157,143 @@ static int del_route(struct connman_element *element, const char *gateway)
 	return err;
 }
 
+static DBusConnection *connection;
+
+static void emit_default_signal(struct connman_element *element)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry, value;
+	const char *key = "Default";
+
+	signal = dbus_message_new_signal(element->path,
+			CONNMAN_CONNECTION_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_BOOLEAN_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_BOOLEAN,
+							&element->enabled);
+	dbus_message_iter_close_container(&entry, &value);
+
+	g_dbus_send_message(connection, signal);
+}
+
+static void set_default(struct connman_element *element, gpointer user_data)
+{
+	struct gateway_data *data = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->index != data->index)
+		return;
+
+	if (element->enabled == TRUE)
+		return;
+
+	connman_element_set_enabled(element, TRUE);
+	emit_default_signal(element);
+}
+
+static void del_default(struct connman_element *element, gpointer user_data)
+{
+	struct gateway_data *data = user_data;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->index != data->index)
+		return;
+
+	if (element->enabled == FALSE)
+		return;
+
+	connman_element_set_enabled(element, FALSE);
+	emit_default_signal(element);
+}
+
+static void new_default(struct connman_element *element, gpointer user_data)
+{
+	const char *gateway;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (g_slist_length(gateway_list) > 0)
+		return;
+
+	connman_element_get_value(element,
+				CONNMAN_PROPERTY_ID_IPV4_GATEWAY, &gateway);
+
+	DBG("gateway %s", gateway);
+
+	if (gateway == NULL)
+		return;
+
+	set_route(element, gateway);
+
+	connman_element_set_enabled(element, TRUE);
+	emit_default_signal(element);
+}
+
+static void connection_newgateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	DBG("index %d gateway %s", index, gateway);
+
+	data = find_gateway(index, gateway);
+	if (data != NULL)
+		return;
+
+	data = g_try_new0(struct gateway_data, 1);
+	if (data == NULL)
+		return;
+
+	data->index = index;
+	data->gateway = g_strdup(gateway);
+
+	gateway_list = g_slist_append(gateway_list, data);
+
+	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION,
+							set_default, data);
+}
+
+static void connection_delgateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	DBG("index %d gateway %s", index, gateway);
+
+	data = find_gateway(index, gateway);
+	if (data == NULL)
+		return;
+
+	gateway_list = g_slist_remove(gateway_list, data);
+
+	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION,
+							del_default, data);
+
+	g_free(data->gateway);
+	g_free(data);
+
+	if (g_slist_length(gateway_list) > 0)
+		return;
+
+	DBG("selecting new default gateway");
+
+	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION,
+							new_default, NULL);
+}
+
+static struct connman_rtnl connection_rtnl = {
+	.name		= "connection",
+	.newgateway	= connection_newgateway,
+	.delgateway	= connection_delgateway,
+};
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -297,10 +392,40 @@ static GDBusSignalTable connection_signals[] = {
 	{ },
 };
 
-static DBusConnection *connection;
+static void append_connections(DBusMessageIter *entry)
+{
+	DBusMessageIter value, iter;
+	const char *key = "Connections";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
 
 static void emit_connections_signal(void)
 {
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+
+	append_connections(&entry);
+
+	g_dbus_send_message(connection, signal);
 }
 
 static int register_interface(struct connman_element *element)
@@ -353,6 +478,11 @@ static int connection_probe(struct connman_element *element)
 	if (gateway == NULL)
 		return 0;
 
+	if (find_gateway(element->index, gateway) != NULL) {
+		DBG("previous gateway still present");
+		goto done;
+	}
+
 	if (g_slist_length(gateway_list) > 0) {
 		DBG("default gateway already present");
 		return 0;
@@ -360,7 +490,9 @@ static int connection_probe(struct connman_element *element)
 
 	set_route(element, gateway);
 
+done:
 	connman_element_set_enabled(element, TRUE);
+	emit_default_signal(element);
 
 	return 0;
 }
@@ -381,6 +513,9 @@ static void connection_remove(struct connman_element *element)
 	if (gateway == NULL)
 		return;
 
+	connman_element_set_enabled(element, FALSE);
+	emit_default_signal(element);
+
 	del_route(element, gateway);
 }
 
diff --git a/src/element.c b/src/element.c
index 2f1aa433..b7e8951e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -870,44 +870,6 @@ int __connman_element_set_ipv4(struct connman_element *element,
 	return 0;
 }
 
-static void append_connections(DBusMessageIter *entry)
-{
-	DBusMessageIter value, iter;
-	const char *key = "Connections";
-
-	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
-		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
-								&value);
-
-	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_element_list(NULL, CONNMAN_ELEMENT_TYPE_CONNECTION, &iter);
-	dbus_message_iter_close_container(&value, &iter);
-
-	dbus_message_iter_close_container(entry, &value);
-}
-
-static void emit_connections_signal(DBusConnection *conn)
-{
-	DBusMessage *signal;
-	DBusMessageIter entry;
-
-	DBG("conn %p", conn);
-
-	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
-				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
-	if (signal == NULL)
-		return;
-
-	dbus_message_iter_init_append(signal, &entry);
-
-	append_connections(&entry);
-
-	g_dbus_send_message(conn, signal);
-}
-
 static void append_state(DBusMessageIter *entry, const char *state)
 {
 	DBusMessageIter value;
@@ -1006,8 +968,6 @@ static void register_element(gpointer data, gpointer user_data)
 			parent = parent->parent;
 		}
 
-		emit_connections_signal(connection);
-
 		if (__connman_element_count(NULL,
 					CONNMAN_ELEMENT_TYPE_CONNECTION) == 1)
 			emit_state_change(connection, "online");
@@ -1102,8 +1062,6 @@ static gboolean remove_element(GNode *node, gpointer user_data)
 		if (__connman_element_count(NULL,
 					CONNMAN_ELEMENT_TYPE_CONNECTION) == 0)
 			emit_state_change(connection, "offline");
-
-		emit_connections_signal(connection);
 	}
 
 	emit_element_signal(connection, "ElementRemoved", element);
@@ -1174,6 +1132,8 @@ int connman_element_set_enabled(struct connman_element *element,
 
 	element->enabled = enabled;
 
+	connman_element_update(element);
+
 	return 0;
 }
 

commit 45dc7174507082f96a30d538397e186788ff9173
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jan 24 00:35:42 2009 +0100

    Release 0.10

diff --git a/ChangeLog b/ChangeLog
index edbb9df8..887a47eb 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,7 @@
+ver 0.10:
+	Fix races with connection signals.
+	Fix automatic switching of default connection.
+
 ver 0.9:
 	Rename FlightMode to OfflineMode.
 	Add static IPv4 setting support for Ethernet devices.
diff --git a/configure.ac b/configure.ac
index f7d245a4..846ddcb7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.9)
+AM_INIT_AUTOMAKE(connman, 0.10)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 8be7c88e4db7281e2660e0b04bc015e7ad696481
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 30 15:45:06 2009 +0100

    Add skeleton for OSPM plugin

diff --git a/bootstrap-configure b/bootstrap-configure
index 3264b322..90e6947f 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -31,5 +31,6 @@ fi
 		--enable-hso \
 		--enable-ppp \
 		--enable-udev \
+		--enable-ospm \
 		--enable-polkit \
 		--enable-client $*
diff --git a/configure.ac b/configure.ac
index 846ddcb7..eeaa3d7c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -203,6 +203,10 @@ AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
 AM_CONDITIONAL(UDEV, test "${enable_udev}" = "yes")
 
+AC_ARG_ENABLE(ospm, AC_HELP_STRING([--enable-ospm],
+		[enable OSPM support]), [enable_ospm=${enableval}])
+AM_CONDITIONAL(OSPM, test "${enable_ospm}" = "yes")
+
 AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
 		[enable PolicyKit support]), [enable_polkit=${enableval}])
 if (test "${enable_polkit}" = "yes"); then
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 0bda0288..4c43ea5c 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -103,6 +103,13 @@ policy_DATA = connman.policy
 endif
 endif
 
+if OSPM
+plugin_LTLIBRARIES += ospm.la
+
+polkit_la_SOURCES = ospm.c
+polkit_la_CFLAGS = @GDBUS_CFLAGS@
+endif
+
 if FAKE
 plugin_LTLIBRARIES += fake.la
 
diff --git a/plugins/ospm.c b/plugins/ospm.c
new file mode 100644
index 00000000..87f18c64
--- /dev/null
+++ b/plugins/ospm.c
@@ -0,0 +1,40 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+#include <connman/plugin.h>
+#include <connman/log.h>
+
+static int ospm_init(void)
+{
+	return 0;
+}
+
+static void ospm_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE(ospm, "OSPM notification plugin", VERSION,
+							ospm_init, ospm_exit)

commit 5b4123c700d629397cc9ab72937e76e324eec59f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 3 23:23:14 2009 +0100

    Set network protocol to IP for Bluetooth PAN to allow DHCP

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 200c3ff3..5ffdab37 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -496,6 +496,8 @@ static void device_properties(DBusConnection *connection, const char *path,
 	if (network == NULL)
 		return;
 
+	connman_network_set_protocol(network, CONNMAN_NETWORK_PROTOCOL_IP);
+
 	connman_network_set_string(network, "Node", path);
 
 	connman_device_add_network(device, network);

commit 0f36d1d5de1d76c422e872bee24db729f72316c6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 3 23:32:25 2009 +0100

    The disconnect method PAN doesn't require the interface name

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 5ffdab37..25dc0ca4 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -298,8 +298,7 @@ static int pan_disconnect(struct connman_network *network)
 	if (message == NULL)
 		return -ENOMEM;
 
-	dbus_message_append_args(message, DBUS_TYPE_STRING, &data->interface,
-							DBUS_TYPE_INVALID);
+	dbus_message_append_args(message, DBUS_TYPE_INVALID);
 
 	if (dbus_connection_send_with_reply(data->connection, message,
 						&call, TIMEOUT) == FALSE) {

commit 3c9e9388c037ab64123abc1c864c46eac28e7322
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Feb 8 21:38:05 2009 +0100

    Fix broken bootstrap script

diff --git a/bootstrap b/bootstrap
index 053f5c8f..0dd71d91 100755
--- a/bootstrap
+++ b/bootstrap
@@ -2,6 +2,6 @@
 
 aclocal && \
     autoheader && \
-        libtoolize --automake --copy --force &&
+        libtoolize --automake --copy --force && \
 	    automake --add-missing --copy && \
 		autoconf

commit 92874ae11f5720356e3b35c62296a22cc315e843
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 26 23:06:30 2009 +0100

    Add network type for WiMAX

diff --git a/include/network.h b/include/network.h
index f5d2e958..78e5c0e4 100644
--- a/include/network.h
+++ b/include/network.h
@@ -38,6 +38,7 @@ extern "C" {
 enum connman_network_type {
 	CONNMAN_NETWORK_TYPE_UNKNOWN       = 0,
 	CONNMAN_NETWORK_TYPE_WIFI          = 1,
+	CONNMAN_NETWORK_TYPE_WIMAX         = 2,
 	CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN = 8,
 	CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN = 9,
 	CONNMAN_NETWORK_TYPE_HSO           = 23,
diff --git a/src/network.c b/src/network.c
index c41871d0..e5b2ae5e 100644
--- a/src/network.c
+++ b/src/network.c
@@ -66,6 +66,8 @@ static const char *type2string(enum connman_network_type type)
 		break;
 	case CONNMAN_NETWORK_TYPE_WIFI:
 		return "wifi";
+	case CONNMAN_NETWORK_TYPE_WIMAX:
+		return "wimax";
 	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
 	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
 		return "bluetooth";

commit fa7a1adf087f2dec6cbea91dac2e1c63a1c9cb52
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 26 23:13:56 2009 +0100

    Disable WiMAX device detection for now

diff --git a/src/detect.c b/src/detect.c
index bd51822d..01e67b1f 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -162,10 +162,12 @@ static void detect_newlink(unsigned short type, int index,
 
 		if (g_str_has_prefix(devname, "bnep") == TRUE)
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+		else if (g_str_has_prefix(devname, "wmx") == TRUE)
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
-			devtype = CONNMAN_DEVICE_TYPE_WIMAX;
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
 			devtype = CONNMAN_DEVICE_TYPE_WIFI;
 		else

commit 72ed7e7dd6a3b944c7edc35c407b719aa679fbca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 26 23:45:29 2009 +0100

    Convert identifier on-demand if needed

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index f9af81ae..b5c96992 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -845,9 +845,8 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	struct connman_network *network;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	char *security, *temp = NULL;
+	char *security;
 	unsigned char strength;
-	unsigned int i;
 
 	DBG("task %p", task);
 
@@ -922,17 +921,6 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	if (result.identifier[0] == '\0')
 		goto done;
 
-	temp = g_strdup(result.identifier);
-	if (temp == NULL)
-		goto done;
-
-	for (i = 0; i < strlen(temp); i++) {
-		char tmp = temp[i];
-		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
-						(tmp < 'a' || tmp > 'z'))
-			temp[i] = '_';
-	}
-
 	strength = result.quality;
 
 	if (result.has_rsn == TRUE)
@@ -944,12 +932,12 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	else
 		security = "none";
 
-	network = connman_device_get_network(task->device, temp);
+	network = connman_device_get_network(task->device, result.identifier);
 	if (network == NULL) {
 		const char *mode;
 		int index;
 
-		network = connman_network_create(temp,
+		network = connman_network_create(result.identifier,
 						CONNMAN_NETWORK_TYPE_WIFI);
 		if (network == NULL)
 			goto done;
@@ -985,7 +973,6 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 done:
 	g_free(result.identifier);
 	g_free(result.ssid);
-	g_free(temp);
 
 	dbus_message_unref(reply);
 
diff --git a/src/device.c b/src/device.c
index 8427a2c9..701528fc 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1449,9 +1449,28 @@ int connman_device_add_network(struct connman_device *device,
 struct connman_network *connman_device_get_network(struct connman_device *device,
 							const char *identifier)
 {
+	struct connman_network *network;
+	char *temp;
+	unsigned int i;
+
 	DBG("device %p identifier %s", device, identifier);
 
-	return g_hash_table_lookup(device->networks, identifier);
+	temp = g_strdup(identifier);
+	if (temp == NULL)
+		return NULL;
+
+	for (i = 0; i < strlen(temp); i++) {
+		char tmp = temp[i];
+		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
+						(tmp < 'a' || tmp > 'z'))
+			temp[i] = '_';
+	}
+
+	network = g_hash_table_lookup(device->networks, temp);
+
+	g_free(temp);
+
+	return network;
 }
 
 /**
diff --git a/src/network.c b/src/network.c
index e5b2ae5e..66158e98 100644
--- a/src/network.c
+++ b/src/network.c
@@ -447,6 +447,8 @@ struct connman_network *connman_network_create(const char *identifier,
 	struct connman_network *network;
 	connman_uint8_t strength = 0;
 	const char *str;
+	char *temp;
+	unsigned int i;
 
 	DBG("identifier %s type %d", identifier, type);
 
@@ -458,7 +460,20 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	__connman_element_initialize(&network->element);
 
-	network->element.name = g_strdup(identifier);
+	temp = g_strdup(identifier);
+	if (temp == NULL) {
+		g_free(network);
+		return NULL;
+	}
+
+	for (i = 0; i < strlen(temp); i++) {
+		char tmp = temp[i];
+		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
+						(tmp < 'a' || tmp > 'z'))
+			temp[i] = '_';
+	}
+
+	network->element.name = temp;
 	network->element.type = CONNMAN_ELEMENT_TYPE_NETWORK;
 
 	network->element.network = network;

commit 4dbcc5d0cc60785775a492e8fa1c368f52af6105
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 26 23:47:24 2009 +0100

    Fix missing include of "string.h"

diff --git a/src/device.c b/src/device.c
index 701528fc..687cea0c 100644
--- a/src/device.c
+++ b/src/device.c
@@ -24,6 +24,8 @@
 #endif
 
 #include <errno.h>
+#include <string.h>
+
 #include <gdbus.h>
 
 #include "connman.h"

commit 2e88ef3053cf2a12115f78fcd4292266b4c98943
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 27 08:37:46 2009 +0100

    Add priority field to plugin description

diff --git a/include/plugin.h b/include/plugin.h
index 84e09586..350937ee 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -33,6 +33,10 @@ extern "C" {
 understanding that ConnMan hasn't reached a stable API."
 #endif
 
+#define CONNMAN_PLUGIN_PRIORITY_LOW      -100
+#define CONNMAN_PLUGIN_PRIORITY_DEFAULT     0
+#define CONNMAN_PLUGIN_PRIORITY_HIGH      100
+
 /**
  * SECTION:plugin
  * @title: Plugin premitives
@@ -43,6 +47,7 @@ struct connman_plugin_desc {
 	const char *name;
 	const char *description;
 	const char *version;
+	int priority;
 	int (*init) (void);
 	void (*exit) (void);
 };
@@ -75,7 +80,8 @@ struct connman_plugin_desc {
  */
 #define CONNMAN_PLUGIN_DEFINE(name, description, version, init, exit) \
 		struct connman_plugin_desc connman_plugin_desc = { \
-			#name, description, version, init, exit \
+			#name, description, version, \
+			CONNMAN_PLUGIN_PRIORITY_DEFAULT, init, exit \
 		};
 
 #ifdef __cplusplus
diff --git a/src/plugin.c b/src/plugin.c
index 59d3572c..216fce15 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -36,6 +36,14 @@ struct connman_plugin {
 	struct connman_plugin_desc *desc;
 };
 
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_plugin *plugin1 = a;
+	const struct connman_plugin *plugin2 = b;
+
+	return plugin2->desc->priority - plugin1->desc->priority;
+}
+
 static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 {
 	struct connman_plugin *plugin;
@@ -60,7 +68,7 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 		return FALSE;
 	}
 
-	plugins = g_slist_append(plugins, plugin);
+	plugins = g_slist_insert_sorted(plugins, plugin, compare_priority);
 
 	return TRUE;
 }

commit c2d1b081ccdd3720ef645bf8dbf82ea4abc752fb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 28 01:18:56 2009 +0100

    Load plugins in priority order

diff --git a/src/plugin.c b/src/plugin.c
index 216fce15..1b573654 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -33,6 +33,7 @@ static GSList *plugins = NULL;
 
 struct connman_plugin {
 	void *handle;
+	gboolean active;
 	struct connman_plugin_desc *desc;
 };
 
@@ -61,13 +62,9 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 		return FALSE;
 
 	plugin->handle = handle;
+	plugin->active = FALSE;
 	plugin->desc = desc;
 
-	if (desc->init() < 0) {
-		g_free(plugin);
-		return FALSE;
-	}
-
 	plugins = g_slist_insert_sorted(plugins, plugin, compare_priority);
 
 	return TRUE;
@@ -75,6 +72,7 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 
 int __connman_plugin_init(const char *pattern, const char *exclude)
 {
+	GSList *list;
 	GDir *dir;
 	const gchar *file;
 	gchar *filename;
@@ -131,6 +129,15 @@ int __connman_plugin_init(const char *pattern, const char *exclude)
 		g_dir_close(dir);
 	}
 
+	for (list = plugins; list; list = list->next) {
+		struct connman_plugin *plugin = list->data;
+
+		if (plugin->desc->init() < 0)
+			continue;
+
+		plugin->active = TRUE;
+	}
+
 	return 0;
 }
 
@@ -143,7 +150,7 @@ void __connman_plugin_cleanup(void)
 	for (list = plugins; list; list = list->next) {
 		struct connman_plugin *plugin = list->data;
 
-		if (plugin->desc->exit)
+		if (plugin->active == TRUE && plugin->desc->exit)
 			plugin->desc->exit();
 
 		dlclose(plugin->handle);

commit 28037643bd3275b6567fbfd84feee909cbfb5352
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 28 02:31:50 2009 +0100

    Add priority field to plugin descriptor definition

diff --git a/include/plugin.h b/include/plugin.h
index 350937ee..059c50af 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -78,10 +78,9 @@ struct connman_plugin_desc {
  * 					example_init, example_exit)
  * ]|
  */
-#define CONNMAN_PLUGIN_DEFINE(name, description, version, init, exit) \
+#define CONNMAN_PLUGIN_DEFINE(name, description, version, priority, init, exit) \
 		struct connman_plugin_desc connman_plugin_desc = { \
-			#name, description, version, \
-			CONNMAN_PLUGIN_PRIORITY_DEFAULT, init, exit \
+			#name, description, version, priority, init, exit \
 		};
 
 #ifdef __cplusplus
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 25dc0ca4..12519c5a 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -849,4 +849,4 @@ static void bluetooth_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(bluetooth, "Bluetooth technology plugin", VERSION,
-						bluetooth_init, bluetooth_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, bluetooth_init, bluetooth_exit)
diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index cb0e8753..7e5e6d0a 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -364,4 +364,4 @@ static void dhclient_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(dhclient, "ISC DHCP client plugin", VERSION,
-						dhclient_init, dhclient_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, dhclient_init, dhclient_exit)
diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index c97553d3..ee65f03e 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -383,4 +383,4 @@ static void dnsproxy_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(dnsproxy, "DNS proxy resolver plugin", VERSION,
-						dnsproxy_init, dnsproxy_exit)
+		 CONNMAN_PLUGIN_PRIORITY_DEFAULT, dnsproxy_init, dnsproxy_exit)
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 4ef163c6..79ddf2b3 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -150,4 +150,4 @@ static void ethernet_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(ethernet, "Ethernet interface plugin", VERSION,
-						ethernet_init, ethernet_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, ethernet_init, ethernet_exit)
diff --git a/plugins/fake.c b/plugins/fake.c
index 4f57837a..8a271be5 100644
--- a/plugins/fake.c
+++ b/plugins/fake.c
@@ -106,4 +106,5 @@ static void fake_exit(void)
 	connman_device_driver_unregister(&device_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE(fake, "Tesing plugin", VERSION, fake_init, fake_exit)
+CONNMAN_PLUGIN_DEFINE(fake, "Tesing plugin", VERSION,
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, fake_init, fake_exit)
diff --git a/plugins/hso.c b/plugins/hso.c
index 9489cf1a..21df00df 100644
--- a/plugins/hso.c
+++ b/plugins/hso.c
@@ -243,4 +243,4 @@ static void hso_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(hso, "Option HSO device plugin", VERSION,
-						hso_init, hso_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, hso_init, hso_exit)
diff --git a/plugins/huawei.c b/plugins/huawei.c
index c165aeab..c1a2c0d5 100644
--- a/plugins/huawei.c
+++ b/plugins/huawei.c
@@ -80,4 +80,4 @@ static void huawei_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(huawei, "HUAWEI Mobile device plugin", VERSION,
-						huawei_init, huawei_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, huawei_init, huawei_exit)
diff --git a/plugins/loopback.c b/plugins/loopback.c
index c0a8f3b9..7607eea2 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -106,4 +106,4 @@ static void loopback_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(loopback, "Loopback device plugin", VERSION,
-						loopback_init, loopback_exit)
+		CONNMAN_PLUGIN_PRIORITY_HIGH, loopback_init, loopback_exit)
diff --git a/plugins/novatel.c b/plugins/novatel.c
index b1d7bb40..4c0c9aac 100644
--- a/plugins/novatel.c
+++ b/plugins/novatel.c
@@ -80,4 +80,4 @@ static void novatel_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(novatel, "Novatel Wireless device plugin", VERSION,
-						novatel_init, novatel_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, novatel_init, novatel_exit)
diff --git a/plugins/ospm.c b/plugins/ospm.c
index 87f18c64..7d2ebf5f 100644
--- a/plugins/ospm.c
+++ b/plugins/ospm.c
@@ -37,4 +37,4 @@ static void ospm_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(ospm, "OSPM notification plugin", VERSION,
-							ospm_init, ospm_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, ospm_init, ospm_exit)
diff --git a/plugins/polkit.c b/plugins/polkit.c
index 247721ee..16dd9d52 100644
--- a/plugins/polkit.c
+++ b/plugins/polkit.c
@@ -176,4 +176,4 @@ static void polkit_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(polkit, "PolicyKit authorization plugin", VERSION,
-						polkit_init, polkit_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, polkit_init, polkit_exit)
diff --git a/plugins/pppd.c b/plugins/pppd.c
index 3cd65bf0..bd026b9b 100644
--- a/plugins/pppd.c
+++ b/plugins/pppd.c
@@ -58,4 +58,4 @@ static void pppd_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(pppd, "Point-to-point protocol plugin", VERSION,
-							pppd_init, pppd_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, pppd_init, pppd_exit)
diff --git a/plugins/resolvconf.c b/plugins/resolvconf.c
index d59fc5e4..df3a834b 100644
--- a/plugins/resolvconf.c
+++ b/plugins/resolvconf.c
@@ -94,4 +94,4 @@ static void resolvconf_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(resolvconf, "Name resolver plugin", VERSION,
-					resolvconf_init, resolvconf_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, resolvconf_init, resolvconf_exit)
diff --git a/plugins/udhcp.c b/plugins/udhcp.c
index f58f8333..36ea23f0 100644
--- a/plugins/udhcp.c
+++ b/plugins/udhcp.c
@@ -212,4 +212,4 @@ static void udhcp_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(udhcp, "uDHCP client plugin", VERSION,
-						udhcp_init, udhcp_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, udhcp_init, udhcp_exit)
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 92e57871..a86b00ee 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -189,4 +189,4 @@ static void wifi_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(wifi, "WiFi interface plugin", VERSION,
-							wifi_init, wifi_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, wifi_init, wifi_exit)
diff --git a/plugins/wimax.c b/plugins/wimax.c
index e008dc92..1509e748 100644
--- a/plugins/wimax.c
+++ b/plugins/wimax.c
@@ -74,4 +74,4 @@ static void wimax_exit(void)
 }
 
 CONNMAN_PLUGIN_DEFINE(wimax, "WiMAX interface plugin", VERSION,
-						wimax_init, wimax_exit)
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, wimax_init, wimax_exit)

commit 4af045f265c95e59908009b192ce6cd4205f5ca3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 28 02:39:21 2009 +0100

    Don't use --pidfile in init script

diff --git a/scripts/connman.in b/scripts/connman.in
index a67f6673..ec98f391 100644
--- a/scripts/connman.in
+++ b/scripts/connman.in
@@ -1,7 +1,6 @@
 #!/bin/sh
 
 DAEMON=@prefix@/sbin/connmand
-PIDFILE=@localstatedir@/run/connmand.pid
 DESC="Connection Manager"
 
 . /lib/lsb/init-functions
@@ -13,13 +12,11 @@ fi
 set -e
 
 do_start() {
-	start-stop-daemon --start --oknodo \
-		--pidfile $PIDFILE --exec $DAEMON -- $DAEMON_OPTS
+	start-stop-daemon --start --oknodo --exec $DAEMON -- $DAEMON_OPTS
 }
 
 do_stop() {
-	start-stop-daemon --stop --oknodo --quiet \
-		--pidfile $PIDFILE --exec $DAEMON
+	start-stop-daemon --stop --oknodo --quiet --exec $DAEMON
 }
 
 case "$1" in

commit 51d57d448cf6f5b9fadfb15a6403a612e3b23234
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 28 02:41:00 2009 +0100

    Fix DHCLIENT and RESOLVCONF variable name typos

diff --git a/configure.ac b/configure.ac
index eeaa3d7c..91c3685d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -92,7 +92,7 @@ if (test "${enable_dhclient}" = "yes"); then
 	if (test -z "${path_dhclient}"); then
 		AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
 	else
-		UDHCPC="${path_dhclient}"
+		DHCLIENT="${path_dhclient}"
 		AC_SUBST(DHCLIENT)
 	fi
 fi
@@ -107,7 +107,7 @@ if (test "${enable_resolvconf}" = "yes"); then
 	if (test -z "${path_resolvconf}"); then
 		AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
 	else
-		UDHCPC="${path_resolvconf}"
+		RESOLVCONF="${path_resolvconf}"
 		AC_SUBST(RESOLVCONF)
 	fi
 fi

commit 5e1faea29b80b0278efe1056b598a835f8e23146
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 28 02:54:34 2009 +0100

    Release 0.11

diff --git a/ChangeLog b/ChangeLog
index 887a47eb..4d2dad86 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+ver 0.11:
+	Add plugin priority handling.
+	Add network type for WiMAX.
+	Fix network protocol selection for Bluetooth PAN.
+	Fix parameters for Bluetooth PAN disconnect method.
+
 ver 0.10:
 	Fix races with connection signals.
 	Fix automatic switching of default connection.
diff --git a/configure.ac b/configure.ac
index 91c3685d..6c915e3d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.10)
+AM_INIT_AUTOMAKE(connman, 0.11)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit c059f209d8bcffc3432ac67ea9217820de799e21
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 28 22:42:10 2009 +0100

    Check that interface name is provided

diff --git a/gdbus/object.c b/gdbus/object.c
index 0786aebe..2823054b 100644
--- a/gdbus/object.c
+++ b/gdbus/object.c
@@ -224,6 +224,9 @@ static struct interface_data *find_interface(GSList *interfaces,
 {
 	GSList *list;
 
+	if (!name)
+		return NULL;
+
 	for (list = interfaces; list; list = list->next) {
 		struct interface_data *iface = list->data;
 		if (!strcmp(name, iface->name))
@@ -391,7 +394,6 @@ static gboolean check_signal(DBusConnection *conn, const char *path,
 	}
 
 	iface = find_interface(data->interfaces, interface);
-
 	if (!iface) {
 		error("dbus_connection_emit_signal: %s does not implement %s",
 				path, interface);

commit fe6d53b30c20e57a371e3fbb8675ccdd91e629d8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 11:38:22 2009 +0100

    Fix issue with network identifier lookup

diff --git a/src/device.c b/src/device.c
index 687cea0c..c107757a 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1451,28 +1451,9 @@ int connman_device_add_network(struct connman_device *device,
 struct connman_network *connman_device_get_network(struct connman_device *device,
 							const char *identifier)
 {
-	struct connman_network *network;
-	char *temp;
-	unsigned int i;
-
 	DBG("device %p identifier %s", device, identifier);
 
-	temp = g_strdup(identifier);
-	if (temp == NULL)
-		return NULL;
-
-	for (i = 0; i < strlen(temp); i++) {
-		char tmp = temp[i];
-		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
-						(tmp < 'a' || tmp > 'z'))
-			temp[i] = '_';
-	}
-
-	network = g_hash_table_lookup(device->networks, temp);
-
-	g_free(temp);
-
-	return network;
+	return g_hash_table_lookup(device->networks, identifier);
 }
 
 /**

commit acd5275f1279b13b6e675e6a2de74e232bbd32c2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 13:09:02 2009 +0100

    Don't send signals when powered state changes occur during probe

diff --git a/src/device.c b/src/device.c
index c107757a..16572354 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1003,6 +1003,9 @@ int connman_device_set_powered(struct connman_device *device,
 
 	device->powered = powered;
 
+	if (device->registered == FALSE)
+		return 0;
+
 	signal = dbus_message_new_signal(device->element.path,
 				CONNMAN_DEVICE_INTERFACE, "PropertyChanged");
 	if (signal == NULL)

commit d5989b5b0a03f0e8205c6e7f80be0cc94c664ec2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 14:23:22 2009 +0100

    Make sure only matching device probe routines are called

diff --git a/src/device.c b/src/device.c
index 16572354..7bb9a40a 100644
--- a/src/device.c
+++ b/src/device.c
@@ -654,6 +654,9 @@ static void probe_driver(struct connman_element *element, gpointer user_data)
 	if (element->device->driver != NULL)
 		return;
 
+	if (driver->type != element->device->type)
+		return 0;
+
 	if (driver->probe(element->device) < 0)
 		return;
 

commit a26a66263673f9c91f71a4e915bd25f9d3e0afc0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 16:25:41 2009 +0100

    Fix connected state change handling

diff --git a/src/network.c b/src/network.c
index 66158e98..e0f0fa81 100644
--- a/src/network.c
+++ b/src/network.c
@@ -658,7 +658,7 @@ int connman_network_set_connected(struct connman_network *network,
 	network->connected = connected;
 
 	if (network->registered == FALSE)
-		return 0;
+		goto connected;
 
 	signal = dbus_message_new_signal(network->element.path,
 				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");
@@ -676,6 +676,7 @@ int connman_network_set_connected(struct connman_network *network,
 
 	g_dbus_send_message(connection, signal);
 
+connected:
 	if (connected == TRUE) {
 		struct connman_element *element;
 		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;

commit a9c1d0a135e77025b9810eeb5653283b0b5278c3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 16:53:54 2009 +0100

    Move network connection state handling to idle callback

diff --git a/src/network.c b/src/network.c
index e0f0fa81..332bbec8 100644
--- a/src/network.c
+++ b/src/network.c
@@ -636,6 +636,51 @@ connman_bool_t connman_network_get_available(struct connman_network *network)
 	return network->available;
 }
 
+static gboolean set_connected(gpointer user_data)
+{
+	struct connman_network *network = user_data;
+
+	if (network->connected == TRUE) {
+		struct connman_element *element;
+		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
+
+		switch (network->protocol) {
+		case CONNMAN_NETWORK_PROTOCOL_UNKNOWN:
+			return 0;
+		case CONNMAN_NETWORK_PROTOCOL_IP:
+			type = CONNMAN_ELEMENT_TYPE_DHCP;
+			break;
+		case CONNMAN_NETWORK_PROTOCOL_PPP:
+			type = CONNMAN_ELEMENT_TYPE_PPP;
+			break;
+		}
+
+		__connman_device_increase_connections(network->device);
+
+		__connman_device_set_network(network->device, network);
+
+		connman_device_set_disconnected(network->device, FALSE);
+
+		element = connman_element_create(NULL);
+		if (element != NULL) {
+			element->type  = type;
+			element->index = network->element.index;
+
+			if (connman_element_register(element,
+						&network->element) < 0)
+				connman_element_unref(element);
+		}
+	} else {
+		connman_element_unregister_children(&network->element);
+
+		__connman_device_set_network(network->device, NULL);
+
+		__connman_device_decrease_connections(network->device);
+	}
+
+	return FALSE;
+}
+
 /**
  * connman_network_set_connected:
  * @network: network structure
@@ -658,7 +703,7 @@ int connman_network_set_connected(struct connman_network *network,
 	network->connected = connected;
 
 	if (network->registered == FALSE)
-		goto connected;
+		g_idle_add(set_connected, network);
 
 	signal = dbus_message_new_signal(network->element.path,
 				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");
@@ -676,44 +721,7 @@ int connman_network_set_connected(struct connman_network *network,
 
 	g_dbus_send_message(connection, signal);
 
-connected:
-	if (connected == TRUE) {
-		struct connman_element *element;
-		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
-
-		switch (network->protocol) {
-		case CONNMAN_NETWORK_PROTOCOL_UNKNOWN:
-			return 0;
-		case CONNMAN_NETWORK_PROTOCOL_IP:
-			type = CONNMAN_ELEMENT_TYPE_DHCP;
-			break;
-		case CONNMAN_NETWORK_PROTOCOL_PPP:
-			type = CONNMAN_ELEMENT_TYPE_PPP;
-			break;
-		}
-
-		__connman_device_increase_connections(network->device);
-
-		__connman_device_set_network(network->device, network);
-
-		connman_device_set_disconnected(network->device, FALSE);
-
-		element = connman_element_create(NULL);
-		if (element != NULL) {
-			element->type  = type;
-			element->index = network->element.index;
-
-			if (connman_element_register(element,
-						&network->element) < 0)
-				connman_element_unref(element);
-		}
-	} else {
-		connman_element_unregister_children(&network->element);
-
-		__connman_device_set_network(network->device, NULL);
-
-		__connman_device_decrease_connections(network->device);
-	}
+	set_connected(network);
 
 	return 0;
 }

commit c5767e0eef17648dd083347ea3f1bf4ef391f313
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 16:54:31 2009 +0100

    Fix wrong return value for device type check

diff --git a/src/device.c b/src/device.c
index 7bb9a40a..43026462 100644
--- a/src/device.c
+++ b/src/device.c
@@ -655,7 +655,7 @@ static void probe_driver(struct connman_element *element, gpointer user_data)
 		return;
 
 	if (driver->type != element->device->type)
-		return 0;
+		return;
 
 	if (driver->probe(element->device) < 0)
 		return;

commit 79cb26df419c7e9234618c82aad408f61b76f31c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 17:28:35 2009 +0100

    Use the network list from the hash table

diff --git a/src/device.c b/src/device.c
index 43026462..a354fe23 100644
--- a/src/device.c
+++ b/src/device.c
@@ -237,6 +237,15 @@ static int set_policy(DBusConnection *connection,
 	return 0;
 }
 
+static void append_path(gpointer key, gpointer value, gpointer user_data)
+{
+	struct connman_element *element = value;
+	DBusMessageIter *iter = user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+							&element->path);
+}
+
 static void append_networks(struct connman_device *device,
 						DBusMessageIter *entry)
 {
@@ -251,8 +260,7 @@ static void append_networks(struct connman_device *device,
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_element_list((struct connman_element *) device,
-					CONNMAN_ELEMENT_TYPE_NETWORK, &iter);
+	g_hash_table_foreach(device->networks, append_path, &iter);
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(entry, &value);

commit 45824255d21607802e1852ba2272c2f957b2acfe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 18:19:17 2009 +0100

    Let the network drivers set connection state via idle callback

diff --git a/src/network.c b/src/network.c
index 332bbec8..ea1cf3c1 100644
--- a/src/network.c
+++ b/src/network.c
@@ -703,7 +703,7 @@ int connman_network_set_connected(struct connman_network *network,
 	network->connected = connected;
 
 	if (network->registered == FALSE)
-		g_idle_add(set_connected, network);
+		set_connected(network);
 
 	signal = dbus_message_new_signal(network->element.path,
 				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");

commit 3e93352f586db3de0c40cc554e2e74b7d40416ee
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 18:23:19 2009 +0100

    Use idle callback and make sure it is not called twice

diff --git a/src/network.c b/src/network.c
index ea1cf3c1..8cda5586 100644
--- a/src/network.c
+++ b/src/network.c
@@ -702,8 +702,10 @@ int connman_network_set_connected(struct connman_network *network,
 
 	network->connected = connected;
 
-	if (network->registered == FALSE)
-		set_connected(network);
+	if (network->registered == FALSE) {
+		g_idle_add(set_connected, network);
+		return 0;
+	}
 
 	signal = dbus_message_new_signal(network->element.path,
 				CONNMAN_NETWORK_INTERFACE, "PropertyChanged");

commit f63c388bfa0ce4d5fded07f6389227643d25658c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 8 18:52:08 2009 +0100

    Release 0.12

diff --git a/ChangeLog b/ChangeLog
index 4d2dad86..6def7cc1 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+ver 0.12:
+	Fix connection state change handling.
+	Fix network list enumeration.
+	Fix broken driver matching for devices.
+	Fix issue with network identifier lookup.
+
 ver 0.11:
 	Add plugin priority handling.
 	Add network type for WiMAX.
diff --git a/configure.ac b/configure.ac
index 6c915e3d..89cee225 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.11)
+AM_INIT_AUTOMAKE(connman, 0.12)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit fcdabedd99e617f36658c6ce636d3234d3d30a1a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 13:51:03 2009 +0100

    Add support for shave autoconf/automake beautifier

diff --git a/.gitignore b/.gitignore
index 11710f8d..bdea2a85 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,6 +20,8 @@ ltmain.sh
 missing
 stamp-h1
 autom4te.cache
+shave
+shave-libtool
 
 connman.pc
 include/connman
diff --git a/Makefile.am b/Makefile.am
index 37bb4e0e..80781771 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -24,4 +24,5 @@ DISTCLEANFILES = $(pkgconfig_DATA)
 
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
-	ltmain.sh depcomp missing install-sh mkinstalldirs
+	ltmain.sh depcomp missing install-sh mkinstalldirs \
+	shave.in shave-libtool.in
diff --git a/acinclude.m4 b/acinclude.m4
index 84086fde..7b836022 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -25,6 +25,61 @@ AC_DEFUN([COMPILER_FLAGS], [
 	fi
 ])
 
+AC_DEFUN([SHAVE_ARG_ENABLE],
+[
+  AC_ARG_ENABLE([shave],
+    AS_HELP_STRING(
+      [--enable-shave],
+      [use shave to make the build pretty [[default=no]]]),,
+      [enable_shave=no]
+    )
+  AC_CONFIG_FILES(shave shave-libtool)
+])
+
+AC_DEFUN([SHAVE_INIT],
+[
+  if test x"$enable_shave" = xyes; then
+    dnl where can we find the shave scripts?
+    m4_if([$1],,
+      [shavedir="$ac_pwd"],
+      [shavedir="$ac_pwd/$1"])
+    AC_SUBST(shavedir)
+
+    dnl make is now quiet
+    AC_SUBST([MAKEFLAGS], [-s])
+    AC_SUBST([AM_MAKEFLAGS], ['`test -z $V && echo -s`'])
+
+    dnl we need sed
+    AC_CHECK_PROG(SED,sed,sed,false)
+
+    dnl substitute libtool
+    SHAVE_SAVED_LIBTOOL=$LIBTOOL
+    LIBTOOL="${SHELL} ${shavedir}/shave-libtool '${SHAVE_SAVED_LIBTOOL}'"
+    AC_SUBST(LIBTOOL)
+
+    dnl substitute cc/cxx
+    SHAVE_SAVED_CC=$CC
+    SHAVE_SAVED_CXX=$CXX
+    SHAVE_SAVED_FC=$FC
+    SHAVE_SAVED_F77=$F77
+    CC="${SHELL} ${shavedir}/shave cc ${SHAVE_SAVED_CC}"
+    CXX="${SHELL} ${shavedir}/shave cxx ${SHAVE_SAVED_CXX}"
+    FC="${SHELL} ${shavedir}/shave fc ${SHAVE_SAVED_FC}"
+    F77="${SHELL} ${shavedir}/shave f77 ${SHAVE_SAVED_F77}"
+    AC_SUBST(CC)
+    AC_SUBST(CXX)
+    AC_SUBST(FC)
+    AC_SUBST(F77)
+
+    V=@
+  else
+    V=1
+  fi
+  Q='$(V:1=)'
+  AC_SUBST(V)
+  AC_SUBST(Q)
+])
+
 AC_DEFUN([GTK_DOC_CHECK],
 [
   AC_BEFORE([AC_PROG_LIBTOOL],[$0])dnl setup libtool first
diff --git a/configure.ac b/configure.ac
index 89cee225..0e4be13f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,6 +24,8 @@ AC_PROG_LIBTOOL
 
 GTK_DOC_CHECK
 
+SHAVE_ARG_ENABLE
+
 AC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug],
 			[enable compiling with debugging information]), [
 	if (test "${enableval}" = "yes" &&
@@ -235,6 +237,8 @@ AC_ARG_ENABLE(datafiles, AC_HELP_STRING([--disable-datafiles],
 					[enable_datafiles=${enableval}])
 AM_CONDITIONAL(DATAFILES, test "${enable_datafiles}" != "no")
 
+SHAVE_INIT
+
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile include/version.h
 		src/Makefile src/connman.service scripts/connman
 		scripts/Makefile plugins/Makefile client/Makefile
diff --git a/shave-libtool.in b/shave-libtool.in
new file mode 100644
index 00000000..1f3a720c
--- /dev/null
+++ b/shave-libtool.in
@@ -0,0 +1,69 @@
+#!/bin/sh
+
+# we need sed
+SED=@SED@
+if test -z "$SED" ; then
+SED=sed
+fi
+
+lt_unmangle ()
+{
+   last_result=`echo $1 | $SED -e 's#.libs/##' -e 's#[0-9a-zA-Z_\-\.]*_la-##'`
+}
+
+# the real libtool to use
+LIBTOOL="$1"
+shift
+
+# if 1, don't print anything, the underlaying wrapper will do it
+pass_though=0
+
+# scan the arguments, keep the right ones for libtool, and discover the mode
+preserved_args=
+while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+    --mode=*)
+        mode=`echo $opt | $SED -e 's/[-_a-zA-Z0-9]*=//'`
+        preserved_args="$preserved_args $opt"
+        ;;
+    -o)
+        lt_output="$1"
+        preserved_args="$preserved_args $opt"
+	;;
+    *)
+        preserved_args="$preserved_args $opt"
+        ;;
+      esac
+done
+
+case "$mode" in
+compile)
+    # shave will be called and print the actual CC/CXX/LINK line
+    preserved_args="$preserved_args --shave-mode=$mode"
+    pass_though=1
+    ;;
+link)
+    preserved_args="$preserved_args --shave-mode=$mode"
+    Q="  LINK  "
+    ;;
+*)
+    # let's u
+    # echo "*** libtool: Unimplemented mode: $mode, fill a bug report"
+    ;;
+esac
+
+lt_unmangle "$lt_output"
+output=$last_result
+
+if test -z $V; then
+    if test $pass_though -eq 0; then
+        echo "$Q$output"
+    fi
+    $LIBTOOL --silent $preserved_args
+else
+    echo $LIBTOOL $preserved_args
+    $LIBTOOL $preserved_args
+fi
diff --git a/shave.in b/shave.in
new file mode 100644
index 00000000..174641e9
--- /dev/null
+++ b/shave.in
@@ -0,0 +1,76 @@
+#!/bin/sh
+
+# we need sed
+SED=@SED@
+if test -z "$SED" ; then
+SED=sed
+fi
+
+lt_unmangle ()
+{
+   last_result=`echo $1 | $SED -e 's#.libs/##' -e 's#[0-9a-zA-Z_\-\.]*_la-##'`
+}
+
+# the tool to wrap (cc, cxx, ar, ranlib, ..)
+tool="$1"
+shift
+
+# the reel tool (to call)
+REEL_TOOL="$1"
+shift
+
+pass_through=0
+preserved_args=
+while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+    --shave-mode=*)
+        mode=`echo $opt | $SED -e 's/[-_a-zA-Z0-9]*=//'`
+	;;
+    -o)
+        lt_output="$1"
+        preserved_args="$preserved_args $opt"
+	;;
+    *)
+        preserved_args="$preserved_args $opt"
+        ;;
+      esac
+done
+
+# mode=link is handled in the libtool wrapper
+case "$mode,$tool" in
+link,*)
+    pass_through=1
+    ;;
+*,cxx)
+    Q="  CXX   "
+    ;;
+*,cc)
+    Q="  CC    "
+    ;;
+*,fc)
+    Q="  FC    "
+    ;;
+*,f77)
+    Q="  F77   "
+    ;;
+*,*)
+    # should not happen
+    Q="  CC    "
+    ;;
+esac
+
+lt_unmangle "$lt_output"
+output=$last_result
+
+if test -z $V; then
+    if test $pass_through -eq 0; then
+        echo "$Q$output"
+    fi
+    $REEL_TOOL $preserved_args
+else
+    echo $REEL_TOOL $preserved_args
+    $REEL_TOOL $preserved_args
+fi

commit 889ed8a414c9dc7f2ec89ed50575ee7b3a9dfda2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 14:01:14 2009 +0100

    Use GCC visibility for exporting symbols

diff --git a/include/plugin.h b/include/plugin.h
index 059c50af..086786c4 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -79,6 +79,8 @@ struct connman_plugin_desc {
  * ]|
  */
 #define CONNMAN_PLUGIN_DEFINE(name, description, version, priority, init, exit) \
+		extern struct connman_plugin_desc connman_plugin_desc \
+				__attribute__ ((visibility("default"))); \
 		struct connman_plugin_desc connman_plugin_desc = { \
 			#name, description, version, priority, init, exit \
 		};
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 4c43ea5c..fec81d58 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -57,7 +57,7 @@ if UDHCP
 plugin_LTLIBRARIES += udhcp.la
 
 udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
-udhcp_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DUDHCPC=\"@UDHCPC@\" \
+udhcp_la_CFLAGS = $(AM_CFLAGS) -DUDHCPC=\"@UDHCPC@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 endif
 
@@ -65,7 +65,7 @@ if DHCLIENT
 plugin_LTLIBRARIES += dhclient.la
 
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
-dhclient_la_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@ -DDHCLIENT=\"@DHCLIENT@\" \
+dhclient_la_CFLAGS = $(AM_CFLAGS) -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 endif
 
@@ -73,14 +73,14 @@ if PPPD
 plugin_LTLIBRARIES += pppd.la
 
 pppd_la_SOURCES = pppd.c
-pppd_la_CFLAGS = @GLIB_CFLAGS@ -DPPPD=\"@PPPD@\"
+pppd_la_CFLAGS = $(AM_CFLAGS) -DPPPD=\"@PPPD@\"
 endif
 
 if RESOLVCONF
 plugin_LTLIBRARIES += resolvconf.la
 
 resolvconf_la_SOURCES = resolvconf.c
-resolvconf_la_CFLAGS = @GLIB_CFLAGS@ -DRESOLVCONF=\"@RESOLVCONF@\"
+resolvconf_la_CFLAGS = $(AM_CFLAGS) -DRESOLVCONF=\"@RESOLVCONF@\"
 endif
 
 if DNSPROXY
@@ -94,7 +94,7 @@ plugin_LTLIBRARIES += polkit.la
 
 polkit_la_SOURCES = polkit.c
 polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
-polkit_la_CFLAGS = @GLIB_CFLAGS@ @POLKIT_CFLAGS@
+polkit_la_CFLAGS = $(AM_CFLAGS) @POLKIT_CFLAGS@
 
 if DATAFILES
 policydir = @POLKIT_DATADIR@
@@ -107,7 +107,7 @@ if OSPM
 plugin_LTLIBRARIES += ospm.la
 
 polkit_la_SOURCES = ospm.c
-polkit_la_CFLAGS = @GDBUS_CFLAGS@
+polkit_la_CFLAGS = $(AM_CFLAGS)
 endif
 
 if FAKE
@@ -116,8 +116,7 @@ plugin_LTLIBRARIES += fake.la
 fake_la_SOURCES = fake.c
 endif
 
-AM_LDFLAGS = -no-undefined -module -avoid-version \
-				-export-symbols-regex connman_plugin_desc
+AM_LDFLAGS = -no-undefined -module -avoid-version
 
 statedir = $(localstatedir)/run/connman
 
@@ -127,7 +126,7 @@ else
 scriptdir = $(libdir)/connman/scripts
 endif
 
-AM_CFLAGS = @GLIB_CFLAGS@ @GDBUS_CFLAGS@
+AM_CFLAGS = -fvisibility=hidden @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 

commit a31c992485e05a28d70c467c3d0a7f8763698ecc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 14:06:59 2009 +0100

    Fix broken shave and shave-libtool cleanup

diff --git a/Makefile.am b/Makefile.am
index 80781771..8651e978 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -25,4 +25,4 @@ DISTCLEANFILES = $(pkgconfig_DATA)
 MAINTAINERCLEANFILES = Makefile.in \
 	aclocal.m4 configure config.h.in config.sub config.guess \
 	ltmain.sh depcomp missing install-sh mkinstalldirs \
-	shave.in shave-libtool.in
+	shave shave-libtool

commit dd0678d005a28c3936f04dcbafb481fc80f0bea8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 14:12:45 2009 +0100

    Rename OSPM plugin to Intel OSPM plugin

diff --git a/bootstrap-configure b/bootstrap-configure
index 90e6947f..21a68793 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -31,6 +31,6 @@ fi
 		--enable-hso \
 		--enable-ppp \
 		--enable-udev \
-		--enable-ospm \
+		--enable-iospm \
 		--enable-polkit \
 		--enable-client $*
diff --git a/configure.ac b/configure.ac
index 0e4be13f..ac7de69c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -205,9 +205,9 @@ AC_SUBST(UDEV_CFLAGS)
 AC_SUBST(UDEV_LIBS)
 AM_CONDITIONAL(UDEV, test "${enable_udev}" = "yes")
 
-AC_ARG_ENABLE(ospm, AC_HELP_STRING([--enable-ospm],
-		[enable OSPM support]), [enable_ospm=${enableval}])
-AM_CONDITIONAL(OSPM, test "${enable_ospm}" = "yes")
+AC_ARG_ENABLE(iospm, AC_HELP_STRING([--enable-iospm],
+		[enable Intel OSPM support]), [enable_iospm=${enableval}])
+AM_CONDITIONAL(IOSPM, test "${enable_iospm}" = "yes")
 
 AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
 		[enable PolicyKit support]), [enable_polkit=${enableval}])
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index fec81d58..443b2c1e 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -103,11 +103,11 @@ policy_DATA = connman.policy
 endif
 endif
 
-if OSPM
-plugin_LTLIBRARIES += ospm.la
+if IOSPM
+plugin_LTLIBRARIES += iospm.la
 
-polkit_la_SOURCES = ospm.c
-polkit_la_CFLAGS = $(AM_CFLAGS)
+iospm_la_SOURCES = iospm.c
+iospm_la_CFLAGS = $(AM_CFLAGS)
 endif
 
 if FAKE
diff --git a/plugins/ospm.c b/plugins/iospm.c
similarity index 83%
rename from plugins/ospm.c
rename to plugins/iospm.c
index 7d2ebf5f..ead675e2 100644
--- a/plugins/ospm.c
+++ b/plugins/iospm.c
@@ -27,14 +27,14 @@
 #include <connman/plugin.h>
 #include <connman/log.h>
 
-static int ospm_init(void)
+static int iospm_init(void)
 {
 	return 0;
 }
 
-static void ospm_exit(void)
+static void iospm_exit(void)
 {
 }
 
-CONNMAN_PLUGIN_DEFINE(ospm, "OSPM notification plugin", VERSION,
-		CONNMAN_PLUGIN_PRIORITY_DEFAULT, ospm_init, ospm_exit)
+CONNMAN_PLUGIN_DEFINE(ospm, "Intel OSPM notification plugin", VERSION,
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, iospm_init, iospm_exit)

commit 74ff14b1fb654a877a66e8b4db66d3f8c4c94baa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 14:26:00 2009 +0100

    Rename WiMAX plugin to Intel WiMAX SDK plugin

diff --git a/bootstrap-configure b/bootstrap-configure
index 21a68793..265d8815 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -20,7 +20,6 @@ fi
 		--enable-loopback \
 		--enable-ethernet \
 		--enable-wifi \
-		--enable-wimax \
 		--enable-bluetooth \
 		--enable-udhcp \
 		--enable-dhclient \
@@ -32,5 +31,6 @@ fi
 		--enable-ppp \
 		--enable-udev \
 		--enable-iospm \
+		--enable-iwmxsdk \
 		--enable-polkit \
 		--enable-client $*
diff --git a/configure.ac b/configure.ac
index ac7de69c..09bae924 100644
--- a/configure.ac
+++ b/configure.ac
@@ -62,10 +62,6 @@ if (test "${enable_wifi}" = "yes"); then
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
 
-AC_ARG_ENABLE(wimax, AC_HELP_STRING([--enable-wimax],
-		[enable WiMAX support]), [enable_wimax=${enableval}])
-AM_CONDITIONAL(WIMAX, test "${enable_wimax}" = "yes")
-
 AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--enable-bluetooth],
 		[enable Bluetooth support]), [enable_bluetooth=${enableval}])
 AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" = "yes")
@@ -209,6 +205,10 @@ AC_ARG_ENABLE(iospm, AC_HELP_STRING([--enable-iospm],
 		[enable Intel OSPM support]), [enable_iospm=${enableval}])
 AM_CONDITIONAL(IOSPM, test "${enable_iospm}" = "yes")
 
+AC_ARG_ENABLE(iwmxsdk, AC_HELP_STRING([--enable-iwmxsdk],
+                [enable Intel WiMAX support]), [enable_iwmxsdk=${enableval}])
+AM_CONDITIONAL(IWMXSDK, test "${enable_iwmxsdk}" = "yes")
+
 AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
 		[enable PolicyKit support]), [enable_polkit=${enableval}])
 if (test "${enable_polkit}" = "yes"); then
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 443b2c1e..8e5b98e9 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -22,12 +22,6 @@ wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
 endif
 
-if WIMAX
-plugin_LTLIBRARIES += wimax.la
-
-wimax_la_SOURCES = wimax.c
-endif
-
 if BLUETOOTH
 plugin_LTLIBRARIES += bluetooth.la
 
@@ -110,6 +104,12 @@ iospm_la_SOURCES = iospm.c
 iospm_la_CFLAGS = $(AM_CFLAGS)
 endif
 
+if IWMXSDK
+plugin_LTLIBRARIES += iwmxsdk.la
+
+iwmxsdk_la_SOURCES = iwmxsdk.c
+endif
+
 if FAKE
 plugin_LTLIBRARIES += fake.la
 
diff --git a/plugins/wimax.c b/plugins/iwmxsdk.c
similarity index 61%
rename from plugins/wimax.c
rename to plugins/iwmxsdk.c
index 1509e748..c30004f7 100644
--- a/plugins/wimax.c
+++ b/plugins/iwmxsdk.c
@@ -28,50 +28,50 @@
 #include <connman/device.h>
 #include <connman/log.h>
 
-static int wimax_probe(struct connman_device *device)
+static int iwmxsdk_probe(struct connman_device *device)
 {
 	DBG("device %p", device);
 
 	return 0;
 }
 
-static void wimax_remove(struct connman_device *device)
+static void iwmxsdk_remove(struct connman_device *device)
 {
 	DBG("device %p", device);
 }
 
-static int wimax_enable(struct connman_device *device)
+static int iwmxsdk_enable(struct connman_device *device)
 {
 	DBG("device %p", device);
 
 	return 0;
 }
 
-static int wimax_disable(struct connman_device *device)
+static int iwmxsdk_disable(struct connman_device *device)
 {
 	DBG("device %p", device);
 
 	return 0;
 }
 
-static struct connman_device_driver wimax_driver = {
-	.name		= "wimax",
+static struct connman_device_driver iwmxsdk_driver = {
+	.name		= "iwmxsdk",
 	.type		= CONNMAN_DEVICE_TYPE_WIMAX,
-	.probe		= wimax_probe,
-	.remove		= wimax_remove,
-	.enable		= wimax_enable,
-	.disable	= wimax_disable,
+	.probe		= iwmxsdk_probe,
+	.remove		= iwmxsdk_remove,
+	.enable		= iwmxsdk_enable,
+	.disable	= iwmxsdk_disable,
 };
 
-static int wimax_init(void)
+static int iwmxsdk_init(void)
 {
-	return connman_device_driver_register(&wimax_driver);
+	return connman_device_driver_register(&iwmxsdk_driver);
 }
 
-static void wimax_exit(void)
+static void iwmxsdk_exit(void)
 {
-	connman_device_driver_unregister(&wimax_driver);
+	connman_device_driver_unregister(&iwmxsdk_driver);
 }
 
-CONNMAN_PLUGIN_DEFINE(wimax, "WiMAX interface plugin", VERSION,
-		CONNMAN_PLUGIN_PRIORITY_DEFAULT, wimax_init, wimax_exit)
+CONNMAN_PLUGIN_DEFINE(iwmxsdk, "Intel WiMAX interface plugin", VERSION,
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, iwmxsdk_init, iwmxsdk_exit)

commit af9e77603bf7cfd12ac5de15540712ceb93c761d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 14:28:24 2009 +0100

    Cleanup of SOURCES targets for plugins

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 8e5b98e9..c7580434 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -5,8 +5,6 @@ plugin_LTLIBRARIES =
 
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
-
-loopback_la_SOURCES = loopback.c
 endif
 
 if ETHERNET
@@ -66,27 +64,22 @@ endif
 if PPPD
 plugin_LTLIBRARIES += pppd.la
 
-pppd_la_SOURCES = pppd.c
 pppd_la_CFLAGS = $(AM_CFLAGS) -DPPPD=\"@PPPD@\"
 endif
 
 if RESOLVCONF
 plugin_LTLIBRARIES += resolvconf.la
 
-resolvconf_la_SOURCES = resolvconf.c
 resolvconf_la_CFLAGS = $(AM_CFLAGS) -DRESOLVCONF=\"@RESOLVCONF@\"
 endif
 
 if DNSPROXY
 plugin_LTLIBRARIES += dnsproxy.la
-
-dnsproxy_la_SOURCES = dnsproxy.c
 endif
 
 if POLKIT
 plugin_LTLIBRARIES += polkit.la
 
-polkit_la_SOURCES = polkit.c
 polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
 polkit_la_CFLAGS = $(AM_CFLAGS) @POLKIT_CFLAGS@
 
@@ -99,21 +92,16 @@ endif
 
 if IOSPM
 plugin_LTLIBRARIES += iospm.la
-
-iospm_la_SOURCES = iospm.c
-iospm_la_CFLAGS = $(AM_CFLAGS)
 endif
 
 if IWMXSDK
 plugin_LTLIBRARIES += iwmxsdk.la
 
-iwmxsdk_la_SOURCES = iwmxsdk.c
+iwmxsdk_la_SOURCES = iwmxsdk.c inet.h inet.c
 endif
 
 if FAKE
 plugin_LTLIBRARIES += fake.la
-
-fake_la_SOURCES = fake.c
 endif
 
 AM_LDFLAGS = -no-undefined -module -avoid-version

commit 3225efab82eb76cb4fd6b2e12b344f2746f4ba72
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 14:41:58 2009 +0100

    Check for libiWmxSdk-0 when enabling Intel WiMAX plugin

diff --git a/configure.ac b/configure.ac
index 09bae924..9ad6824e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -206,7 +206,13 @@ AC_ARG_ENABLE(iospm, AC_HELP_STRING([--enable-iospm],
 AM_CONDITIONAL(IOSPM, test "${enable_iospm}" = "yes")
 
 AC_ARG_ENABLE(iwmxsdk, AC_HELP_STRING([--enable-iwmxsdk],
-                [enable Intel WiMAX support]), [enable_iwmxsdk=${enableval}])
+		[enable Intel WiMAX support]), [enable_iwmxsdk=${enableval}])
+if (test "${enable_iwmxsdk}" = "yes"); then
+	PKG_CHECK_MODULES(IWMXSDK, libiWmxSdk-0, enable_iwmxsdk=yes,
+				AC_MSG_ERROR(Intel WiMAX SDK is required))
+	AC_SUBST(IWMXSDK_CFLAGS)
+	AC_SUBST(IWMXSDK_LIBS)
+fi
 AM_CONDITIONAL(IWMXSDK, test "${enable_iwmxsdk}" = "yes")
 
 AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],

commit db8715b20112f7baf770428e6cf43943d54dbe54
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 15:04:12 2009 +0100

    Add linking for libiWmxSdk-0 library

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index c7580434..df912bd1 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -98,6 +98,8 @@ if IWMXSDK
 plugin_LTLIBRARIES += iwmxsdk.la
 
 iwmxsdk_la_SOURCES = iwmxsdk.c inet.h inet.c
+iwmxsdk_la_LIBADD = @IWMXSDK_LIBS@ @GLIB_LIBS@
+iwmxsdk_la_CFLAGS = $(AM_CFLAGS) @IWMXSDK_CFLAGS@
 endif
 
 if FAKE

commit 883c2ef2cfc898a8be08eb46557c19170a0479e8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 9 22:08:12 2009 +0100

    Enforce threading support when using Intel WiMAX plugin

diff --git a/configure.ac b/configure.ac
index 9ad6824e..4842ad20 100644
--- a/configure.ac
+++ b/configure.ac
@@ -148,34 +148,6 @@ AM_CONDITIONAL(PPPD, test "${enable_ppp}" = "yes")
 AC_CHECK_LIB(dl, dlopen, dummy=yes,
 			AC_MSG_ERROR(dynamic linking loader is required))
 
-PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
-				AC_MSG_ERROR(GLib >= 2.16 is required))
-AC_SUBST(GLIB_CFLAGS)
-AC_SUBST(GLIB_LIBS)
-
-if (test "${enable_threads}" = "yes"); then
-	AC_DEFINE(NEED_THREADS, 1, [Define if threading support is required])
-	PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
-				AC_MSG_ERROR(GThread >= 2.16 is required))
-	GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
-	GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
-fi
-
-PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
-				AC_MSG_ERROR(D-Bus >= 1.0 is required))
-AC_SUBST(DBUS_CFLAGS)
-AC_SUBST(DBUS_LIBS)
-DBUS_DATADIR="`$PKG_CONFIG --variable=sysconfdir dbus-1`"
-if (test -z "{DBUS_DATADIR}"); then
-	DBUS_DATADIR="${sysconfdir}/dbus-1/system.d"
-else
-	DBUS_DATADIR="$DBUS_DATADIR/dbus-1/system.d"
-fi
-AC_SUBST(DBUS_DATADIR)
-
-AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
-AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
-
 AC_ARG_ENABLE(udev, AC_HELP_STRING([--enable-udev],
 		[enable udev support]), [enable_udev=${enableval}])
 if (test "${enable_udev}" = "yes"); then
@@ -208,6 +180,7 @@ AM_CONDITIONAL(IOSPM, test "${enable_iospm}" = "yes")
 AC_ARG_ENABLE(iwmxsdk, AC_HELP_STRING([--enable-iwmxsdk],
 		[enable Intel WiMAX support]), [enable_iwmxsdk=${enableval}])
 if (test "${enable_iwmxsdk}" = "yes"); then
+	enable_threads="yes"
 	PKG_CHECK_MODULES(IWMXSDK, libiWmxSdk-0, enable_iwmxsdk=yes,
 				AC_MSG_ERROR(Intel WiMAX SDK is required))
 	AC_SUBST(IWMXSDK_CFLAGS)
@@ -215,6 +188,34 @@ if (test "${enable_iwmxsdk}" = "yes"); then
 fi
 AM_CONDITIONAL(IWMXSDK, test "${enable_iwmxsdk}" = "yes")
 
+PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
+				AC_MSG_ERROR(GLib >= 2.16 is required))
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GLIB_LIBS)
+
+if (test "${enable_threads}" = "yes"); then
+	AC_DEFINE(NEED_THREADS, 1, [Define if threading support is required])
+	PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
+				AC_MSG_ERROR(GThread >= 2.16 is required))
+	GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
+	GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
+fi
+
+PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
+				AC_MSG_ERROR(D-Bus >= 1.0 is required))
+AC_SUBST(DBUS_CFLAGS)
+AC_SUBST(DBUS_LIBS)
+DBUS_DATADIR="`$PKG_CONFIG --variable=sysconfdir dbus-1`"
+if (test -z "{DBUS_DATADIR}"); then
+	DBUS_DATADIR="${sysconfdir}/dbus-1/system.d"
+else
+	DBUS_DATADIR="$DBUS_DATADIR/dbus-1/system.d"
+fi
+AC_SUBST(DBUS_DATADIR)
+
+AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
+AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
+
 AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
 		[enable PolicyKit support]), [enable_polkit=${enableval}])
 if (test "${enable_polkit}" = "yes"); then
diff --git a/src/Makefile.am b/src/Makefile.am
index 4eda6715..79da404f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -22,7 +22,7 @@ rules_DATA = 92-connman.rules
 endif
 endif
 
-connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @UDEV_LIBS@ -ldl
+connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ @UDEV_LIBS@ -ldl
 
 connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
@@ -40,10 +40,11 @@ else
 plugindir = $(libdir)/connman/plugins
 endif
 
-AM_CFLAGS = @UDEV_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
-				-DSTATEDIR=\""$(statedir)"\" \
-					-DSTORAGEDIR=\""$(storagedir)\"" \
-						-DPLUGINDIR=\""$(plugindir)"\"
+AM_CFLAGS = @UDEV_CFLAGS@ @GTHREAD_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
+					-DSTATEDIR=\""$(statedir)"\" \
+					-DPLUGINDIR=\""$(plugindir)"\" \
+					-DSTORAGEDIR=\""$(storagedir)\""
+
 INCLUDES = -I$(top_builddir)/include
 
 EXTRA_DIST = connman-dbus.conf connman-polkit.conf connman.rules

commit 6bf9ea4781e346af8faa5cea4e6734f13b7bb3f3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 17:17:36 2009 +0100

    Add skeleton for profile API description

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 745841be..995f9985 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -38,4 +38,4 @@ EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
 EXTRA_DIST += manager-api.txt device-api.txt network-api.txt service-api.txt \
-				connection-api.txt agent-api.txt plugin-api.txt
+		connection-api.txt profile-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/profile-api.txt b/doc/profile-api.txt
new file mode 100644
index 00000000..e4aa5358
--- /dev/null
+++ b/doc/profile-api.txt
@@ -0,0 +1,22 @@
+Profile hierarchy
+=================
+
+Service		org.moblin.connman
+Interface	org.moblin.connman.Profile
+Object path	[variable prefix]/{profile0,profile1,...}
+
+Methods		dict GetProperties()
+
+			Returns properties for the profile object. See
+			the properties section for available properties.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+Signals		PropertyChanged(string name, variant value)
+
+			This signal indicates a changed value of the given
+			property.
+
+Properties	string Name [readonly]
+
+			Name of this profile.

commit 571d1f1862ec992aca5c175f48dc482d1285a4c1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 17:57:58 2009 +0100

    Add comment about WPS support

diff --git a/TODO b/TODO
index 0fb4ff7e..ee6a01e4 100644
--- a/TODO
+++ b/TODO
@@ -5,6 +5,11 @@
 	present, but it needs properly hooked up. This involves a correct
 	security architecture since it uses personalized credentials.
 
+  o Support for WPS based WiFi authentication
+
+	Newer versions of wpa_supplicant contain support for WPS. For full
+	integration of WPS support, the agent concept needs to be extended.
+
   o Support for multiple profiles
 
 	Currently only one active profile (the default profile) is supported.

commit 925e46442d09bccaec4e5077011eb2c45189a3e2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 19:44:43 2009 +0100

    Add skeleton for profile/service integration

diff --git a/src/connman.h b/src/connman.h
index 729dc42d..36d65efa 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -179,6 +179,9 @@ connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
 int __connman_device_set_offlinemode(connman_bool_t offlinemode);
 
+int __connman_profile_add_device(struct connman_device *device);
+int __connman_profile_remove_device(struct connman_device *device);
+
 #include <connman/network.h>
 
 int __connman_network_init(void);
@@ -191,6 +194,9 @@ int __connman_network_disconnect(struct connman_network *network);
 
 connman_bool_t __connman_network_has_driver(struct connman_network *network);
 
+int __connman_profile_add_network(struct connman_network *network);
+int __connman_profile_remove_network(struct connman_network *network);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/device.c b/src/device.c
index a354fe23..93a076f5 100644
--- a/src/device.c
+++ b/src/device.c
@@ -645,6 +645,16 @@ static int setup_device(struct connman_device *device)
 		return err;
 	}
 
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		break;
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		__connman_profile_add_device(device);
+		break;
+	}
+
 	device_enable(device);
 
 	return 0;
@@ -679,6 +689,16 @@ static void remove_device(struct connman_device *device)
 
 	device_disable(device);
 
+	switch (device->mode) {
+	case CONNMAN_DEVICE_MODE_UNKNOWN:
+	case CONNMAN_DEVICE_MODE_NETWORK_SINGLE:
+	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
+		break;
+	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
+		__connman_profile_remove_device(device);
+		break;
+	}
+
 	unregister_interface(&device->element);
 
 	if (device->driver->remove)
diff --git a/src/network.c b/src/network.c
index 8cda5586..2618dad9 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1062,6 +1062,8 @@ static int network_probe(struct connman_element *element)
 		return err;
 	}
 
+	__connman_profile_add_network(network);
+
 	return 0;
 }
 
@@ -1077,6 +1079,8 @@ static void network_remove(struct connman_element *element)
 	if (network->driver == NULL)
 		return;
 
+	__connman_profile_remove_network(network);
+
 	unregister_interface(element);
 
 	if (network->driver->remove)
diff --git a/src/profile.c b/src/profile.c
index 44dcf55f..f9d643ce 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -28,6 +28,34 @@
 
 #include "connman.h"
 
+int __connman_profile_add_device(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+int __connman_profile_remove_device(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+int __connman_profile_add_network(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
+int __connman_profile_remove_network(struct connman_network *network)
+{
+	DBG("network %p", network);
+
+	return 0;
+}
+
 void __connman_profile_list(DBusMessageIter *iter)
 {
 	const char *path = "/profile/default";

commit cd36491ca34d68b65f33be9289e314ca3a5f2ae6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 20:02:50 2009 +0100

    Add basic support for notifier infrastructure

diff --git a/include/Makefile.am b/include/Makefile.am
index f8e9e73e..a13ef802 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -2,7 +2,7 @@
 includedir = @includedir@/connman
 
 include_HEADERS = types.h log.h plugin.h security.h resolver.h \
-					storage.h device.h network.h
+				storage.h device.h network.h notifier.h
 
 nodist_include_HEADERS = version.h
 
diff --git a/include/notifier.h b/include/notifier.h
new file mode 100644
index 00000000..fc9939c2
--- /dev/null
+++ b/include/notifier.h
@@ -0,0 +1,55 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_NOTIFIER_H
+#define __CONNMAN_NOTIFIER_H
+
+#include <connman/device.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * SECTION:notifier
+ * @title: Notifier premitives
+ * @short_description: Functions for registering notifier modules
+ */
+
+#define CONNMAN_NOTIFIER_PRIORITY_LOW      -100
+#define CONNMAN_NOTIFIER_PRIORITY_DEFAULT     0
+#define CONNMAN_NOTIFIER_PRIORITY_HIGH      100
+
+struct connman_notifier {
+	const char *name;
+	int priority;
+	int (*device_powered) (struct connman_device *device,
+			       			connman_bool_t powered);
+};
+
+extern int connman_notifier_register(struct connman_notifier *notifier);
+extern void connman_notifier_unregister(struct connman_notifier *notifier);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_NOTIFIER_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 79da404f..897d5738 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -9,8 +9,8 @@ sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
 			profile.c element.c device.c network.c connection.c \
-			security.c resolver.c storage.c manager.c agent.c \
-			ipv4.c detect.c rtnl.c dbus.c
+			security.c resolver.c notifier.c storage.c manager.c \
+			agent.c ipv4.c detect.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/connman.h b/src/connman.h
index 36d65efa..c4a079e7 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -197,6 +197,11 @@ connman_bool_t __connman_network_has_driver(struct connman_network *network);
 int __connman_profile_add_network(struct connman_network *network);
 int __connman_profile_remove_network(struct connman_network *network);
 
+#include <connman/notifier.h>
+
+int __connman_notifier_init(void);
+void __connman_notifier_cleanup(void);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/element.c b/src/element.c
index b7e8951e..9a2ec3b6 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1157,6 +1157,7 @@ int __connman_element_init(DBusConnection *conn, const char *device,
 
 	element_root = g_node_new(element);
 
+	__connman_notifier_init();
 	__connman_network_init();
 	__connman_device_init();
 
@@ -1241,6 +1242,7 @@ void __connman_element_cleanup(void)
 
 	__connman_device_cleanup();
 	__connman_network_cleanup();
+	__connman_notifier_cleanup();
 
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
 							free_driver, NULL);
diff --git a/src/notifier.c b/src/notifier.c
new file mode 100644
index 00000000..e2dcff80
--- /dev/null
+++ b/src/notifier.c
@@ -0,0 +1,79 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+static GSList *notifier_list = NULL;
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_notifier *notifier1 = a;
+	const struct connman_notifier *notifier2 = b;
+
+	return notifier2->priority - notifier1->priority;
+}
+
+/**
+ * connman_notifier_register:
+ * @notifier: notifier module
+ *
+ * Register a new notifier module
+ *
+ * Returns: %0 on success
+ */
+int connman_notifier_register(struct connman_notifier *notifier)
+{
+	DBG("notifier %p name %s", notifier, notifier->name);
+
+	notifier_list = g_slist_insert_sorted(notifier_list, notifier,
+							compare_priority);
+
+	return 0;
+}
+
+/**
+ * connman_notifier_unregister:
+ * @notifier: notifier module
+ *
+ * Remove a previously registered notifier module
+ */
+void connman_notifier_unregister(struct connman_notifier *notifier)
+{
+	DBG("notifier %p name %s", notifier, notifier->name);
+
+	notifier_list = g_slist_remove(notifier_list, notifier);
+}
+
+int __connman_notifier_init(void)
+{
+	DBG("");
+
+	return 0;
+}
+
+void __connman_notifier_cleanup(void)
+{
+	DBG("");
+}

commit 306c84e60b5779356addbbeff7084c0c7478a056
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 20:06:48 2009 +0100

    Add support for notifier registration for Intel OSPM module

diff --git a/plugins/iospm.c b/plugins/iospm.c
index ead675e2..b9d657d9 100644
--- a/plugins/iospm.c
+++ b/plugins/iospm.c
@@ -25,15 +25,22 @@
 
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
+#include <connman/notifier.h>
 #include <connman/log.h>
 
+static struct connman_notifier iospm_notifier = {
+	.name		= "iospm",
+	.priority	= CONNMAN_NOTIFIER_PRIORITY_DEFAULT,
+};
+
 static int iospm_init(void)
 {
-	return 0;
+	return connman_notifier_register(&iospm_notifier);
 }
 
 static void iospm_exit(void)
 {
+	connman_notifier_unregister(&iospm_notifier);
 }
 
 CONNMAN_PLUGIN_DEFINE(ospm, "Intel OSPM notification plugin", VERSION,

commit 64e21423a7872663e23bb369af56c6d0776b3658
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 20:39:37 2009 +0100

    Add more helpers for handling profile/service support

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index 1f50d944..dd819418 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -22,6 +22,29 @@ Methods		dict GetProperties()
 			Possible Errors: [service].Error.InvalidArguments
 					 [service].Error.DoesNotExist
 
+		object AddProfile(string name)
+
+			Add a new profile with the specified name.
+
+			It is possible to create two profiles with the same
+			name. The identification is done via the object path
+			and not the name of the profile.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+		void RemoveProfile(object path)
+
+			Remove profile with specified object path.
+
+			It is not possible to remove the current active
+			profile. To remove the active profile a different
+			one must be selected via ActiveProfile property
+			first.
+
+			At minium one profile must be available all the time.
+
+			Possible Errors: [service].Error.InvalidArguments
+
 		void RegisterAgent(object path)
 
 			Register new agent for handling user requests.
@@ -74,6 +97,10 @@ Properties	string State [readonly]
 			the limited usage of WiFi or Bluetooth devices might
 			be allowed in some situations.
 
+		object ActiveProfile [readwrite]
+
+			Object path of the current active profile.
+
 		array{object} Profiles [readonly]
 
 			List of profile object paths.
@@ -82,6 +109,19 @@ Properties	string State [readonly]
 
 			List of device object paths.
 
+		array{object} Services [readonly]
+
+			List of service object paths.
+
+			This list represents the available services for the
+			current selected profile. If the profile gets changed
+			then this list will be updated.
+
+			The same list is available via the profile object
+			itself. It is just provided here for convenience of
+			applications only dealing with the current active
+			profile.
+
 		array{object} Connections [readonly]
 
 			List of active connection object paths.
diff --git a/src/connman.h b/src/connman.h
index c4a079e7..e9d72ae9 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -52,6 +52,8 @@ int __connman_profile_init(DBusConnection *conn);
 void __connman_profile_cleanup(void);
 
 void __connman_profile_list(DBusMessageIter *iter);
+void __connman_profile_list_services(DBusMessageIter *iter);
+const char *__connman_profile_active(void);
 
 #include <connman/log.h>
 
diff --git a/src/manager.c b/src/manager.c
index 5e68e4f5..4814f532 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -89,6 +89,30 @@ static void append_profiles(DBusMessageIter *dict)
 	dbus_message_iter_close_container(dict, &entry);
 }
 
+static void append_services(DBusMessageIter *dict)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "Services";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	__connman_profile_list_services(&iter);
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
 static void append_devices(DBusMessageIter *dict)
 {
 	DBusMessageIter entry, value, iter;
@@ -161,7 +185,13 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = __connman_profile_active();
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "ActiveProfile",
+						DBUS_TYPE_OBJECT_PATH, &str);
+
 	append_profiles(&dict);
+	append_services(&dict);
 
 	append_devices(&dict);
 	append_connections(&dict);
@@ -227,11 +257,43 @@ static DBusMessage *set_property(DBusConnection *conn,
 		global_offlinemode = offlinemode;
 
 		__connman_device_set_offlinemode(offlinemode);
+	} else if (g_str_equal(name, "ActiveProfile") == TRUE) {
+		const char *str;
+
+		dbus_message_iter_get_basic(&value, &str);
+
+		return __connman_error_not_supported(msg);
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static DBusMessage *add_profile(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	const char *name;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &name,
+							DBUS_TYPE_INVALID);
+
+	return __connman_error_not_supported(msg);
+}
+
+static DBusMessage *remove_profile(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	const char *path;
+
+	DBG("conn %p", conn);
+
+	dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,
+							DBUS_TYPE_INVALID);
+
+	return __connman_error_not_supported(msg);
+}
+
 static DBusMessage *register_agent(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -283,6 +345,8 @@ static DBusMessage *unregister_agent(DBusConnection *conn,
 static GDBusMethodTable manager_methods[] = {
 	{ "GetProperties",   "",   "a{sv}", get_properties   },
 	{ "SetProperty",     "sv", "",      set_property     },
+	{ "AddProfile",      "s",  "o",     add_profile      },
+	{ "RemoveProfile",   "o",  "",      remove_profile   },
 	{ "RegisterAgent",   "o",  "",      register_agent   },
 	{ "UnregisterAgent", "o",  "",      unregister_agent },
 	{ },
diff --git a/src/profile.c b/src/profile.c
index f9d643ce..d1aea70c 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -56,15 +56,27 @@ int __connman_profile_remove_network(struct connman_network *network)
 	return 0;
 }
 
+const char *__connman_profile_active(void)
+{
+	DBG("");
+
+	return "/profile/default";
+}
+
 void __connman_profile_list(DBusMessageIter *iter)
 {
-	const char *path = "/profile/default";
+	const char *path = __connman_profile_active();
 
 	DBG("");
 
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
+void __connman_profile_list_services(DBusMessageIter *iter)
+{
+	DBG("");
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
diff --git a/test/test-manager b/test/test-manager
index 7915eaf5..4b056f9f 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -16,6 +16,8 @@ def print_properties(key, value):
 		interface = "org.moblin.connman.Device"
 	elif key == "Connections":
 		interface = "org.moblin.connman.Connection"
+	elif key == "Services":
+		interface = "org.moblin.connman.Service"
 	else:
 		return
 
@@ -52,7 +54,7 @@ def print_properties(key, value):
 			print "        Networks = [ %s]" % (list)
 
 for key in properties.keys():
-	if key in ["Profiles", "Devices", "Connections"]:
+	if key in ["Profiles", "Devices", "Connections", "Services"]:
 		print_properties(key, properties[key])
 	elif key in ["OfflineMode"]:
 		print "%s" % (key)

commit dd5db19baeec6c4d586b23cd590cce53bfea044d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 21:10:13 2009 +0100

    Add type for GPS based devices (just for power control)

diff --git a/include/device.h b/include/device.h
index 0f30100b..e4a735f1 100644
--- a/include/device.h
+++ b/include/device.h
@@ -41,6 +41,7 @@ enum connman_device_type {
 	CONNMAN_DEVICE_TYPE_WIFI      = 2,
 	CONNMAN_DEVICE_TYPE_WIMAX     = 3,
 	CONNMAN_DEVICE_TYPE_BLUETOOTH = 4,
+	CONNMAN_DEVICE_TYPE_GPS       = 5,
 	CONNMAN_DEVICE_TYPE_HSO       = 15,
 	CONNMAN_DEVICE_TYPE_NOZOMI    = 16,
 	CONNMAN_DEVICE_TYPE_HUAWEI    = 17,
diff --git a/src/detect.c b/src/detect.c
index 01e67b1f..d26dc29f 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -189,6 +189,7 @@ static void detect_newlink(unsigned short type, int index,
 		name = index2ident(index, "dev_");
 		break;
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_GPS:
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
@@ -211,6 +212,7 @@ static void detect_newlink(unsigned short type, int index,
 	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
+	case CONNMAN_DEVICE_TYPE_GPS:
 		mode = CONNMAN_DEVICE_MODE_UNKNOWN;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
diff --git a/src/device.c b/src/device.c
index 93a076f5..a07726a9 100644
--- a/src/device.c
+++ b/src/device.c
@@ -88,6 +88,8 @@ static const char *type2description(enum connman_device_type type)
 		return "WiMAX";
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "Bluetooth";
+	case CONNMAN_DEVICE_TYPE_GPS:
+		return "GPS";
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
@@ -112,6 +114,8 @@ static const char *type2string(enum connman_device_type type)
 		return "wimax";
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		return "bluetooth";
+	case CONNMAN_DEVICE_TYPE_GPS:
+		return "gps";
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:
 	case CONNMAN_DEVICE_TYPE_NOZOMI:
@@ -863,6 +867,10 @@ struct connman_device *connman_device_create(const char *node,
 		device->priority = 50;
 		device->scan_interval = 0;
 		break;
+	case CONNMAN_DEVICE_TYPE_GPS:
+		device->priority = 0;
+		device->scan_interval = 0;
+		break;
 	case CONNMAN_DEVICE_TYPE_HSO:
 	case CONNMAN_DEVICE_TYPE_NOZOMI:
 	case CONNMAN_DEVICE_TYPE_HUAWEI:

commit a8764dd1a3bb5f33f7c12260d61603d724c42fc4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 21:13:41 2009 +0100

    Update notifier callback event declarations

diff --git a/include/notifier.h b/include/notifier.h
index fc9939c2..046b8bf5 100644
--- a/include/notifier.h
+++ b/include/notifier.h
@@ -41,8 +41,9 @@ extern "C" {
 struct connman_notifier {
 	const char *name;
 	int priority;
-	int (*device_powered) (struct connman_device *device,
-			       			connman_bool_t powered);
+	void (*device_enabled) (enum connman_device_type type,
+						connman_bool_t enabled);
+	void (*offline_mode) (connman_bool_t enabled);
 };
 
 extern int connman_notifier_register(struct connman_notifier *notifier);

commit 87d190b3060eac7409f9c893e0a69ace65081f54
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 21:26:41 2009 +0100

    Hook up device type and offline mode notifications

diff --git a/src/connman.h b/src/connman.h
index e9d72ae9..128c084c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -204,6 +204,10 @@ int __connman_profile_remove_network(struct connman_network *network);
 int __connman_notifier_init(void);
 void __connman_notifier_cleanup(void);
 
+void __connman_notifier_device_type_increase(enum connman_device_type type);
+void __connman_notifier_device_type_decrease(enum connman_device_type type);
+void __connman_notifier_offline_mode(connman_bool_t enabled);
+
 #include <connman/rtnl.h>
 
 int __connman_rtnl_init(void);
diff --git a/src/device.c b/src/device.c
index a07726a9..30940385 100644
--- a/src/device.c
+++ b/src/device.c
@@ -169,16 +169,18 @@ static int set_powered(struct connman_device *device, connman_bool_t powered)
 		return -EINVAL;
 
 	if (powered == TRUE) {
-		if (driver->enable)
+		if (driver->enable) {
 			err = driver->enable(device);
-		else
+			__connman_notifier_device_type_increase(device->type);
+		} else
 			err = -EINVAL;
 	} else {
 		g_hash_table_remove_all(device->networks);
 
-		if (driver->disable)
+		if (driver->disable) {
 			err = driver->disable(device);
-		else
+			__connman_notifier_device_type_decrease(device->type);
+		} else
 			err = -EINVAL;
 	}
 
@@ -615,8 +617,10 @@ static void device_enable(struct connman_device *device)
 	if (device->powered == TRUE)
 		return;
 
-	if (device->driver->enable)
+	if (device->driver->enable) {
 		device->driver->enable(device);
+		__connman_notifier_device_type_increase(device->type);
+	}
 }
 
 static void device_disable(struct connman_device *device)
@@ -631,8 +635,10 @@ static void device_disable(struct connman_device *device)
 
 	g_hash_table_remove_all(device->networks);
 
-	if (device->driver->disable)
+	if (device->driver->disable) {
 		device->driver->disable(device);
+		__connman_notifier_device_type_decrease(device->type);
+	}
 }
 
 static int setup_device(struct connman_device *device)
@@ -1429,6 +1435,8 @@ int __connman_device_set_offlinemode(connman_bool_t offlinemode)
 	__connman_element_foreach(NULL, CONNMAN_ELEMENT_TYPE_DEVICE,
 			set_offlinemode, GUINT_TO_POINTER(offlinemode));
 
+	__connman_notifier_offline_mode(offlinemode);
+
 	return 0;
 }
 
diff --git a/src/notifier.c b/src/notifier.c
index e2dcff80..c23a5702 100644
--- a/src/notifier.c
+++ b/src/notifier.c
@@ -66,6 +66,21 @@ void connman_notifier_unregister(struct connman_notifier *notifier)
 	notifier_list = g_slist_remove(notifier_list, notifier);
 }
 
+void __connman_notifier_device_type_increase(enum connman_device_type type)
+{
+	DBG("type %d", type);
+}
+
+void __connman_notifier_device_type_decrease(enum connman_device_type type)
+{
+	DBG("type %d", type);
+}
+
+void __connman_notifier_offline_mode(connman_bool_t enabled)
+{
+	DBG("enabled %d", enabled);
+}
+
 int __connman_notifier_init(void)
 {
 	DBG("");

commit c23a88af4f9b3e55d7c76dcf0c25070d05ba8cf1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 21:30:51 2009 +0100

    Add event callbacks for device state and offline mode changes

diff --git a/plugins/iospm.c b/plugins/iospm.c
index b9d657d9..9d5db44b 100644
--- a/plugins/iospm.c
+++ b/plugins/iospm.c
@@ -28,9 +28,22 @@
 #include <connman/notifier.h>
 #include <connman/log.h>
 
+static void iospm_device_enabled(enum connman_device_type type,
+						connman_bool_t enabled)
+{
+	DBG("type %d enabled %d", type, enabled);
+}
+
+static void iospm_offline_mode(connman_bool_t enabled)
+{
+	DBG("enabled %d", enabled);
+}
+
 static struct connman_notifier iospm_notifier = {
 	.name		= "iospm",
 	.priority	= CONNMAN_NOTIFIER_PRIORITY_DEFAULT,
+	.device_enabled	= iospm_device_enabled,
+	.offline_mode	= iospm_offline_mode,
 };
 
 static int iospm_init(void)

commit 76ca29341f8c68a7345c0b09f7097debf759d585
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 21:52:10 2009 +0100

    Add implementation for notifier hooks

diff --git a/src/notifier.c b/src/notifier.c
index c23a5702..9092b24d 100644
--- a/src/notifier.c
+++ b/src/notifier.c
@@ -66,19 +66,80 @@ void connman_notifier_unregister(struct connman_notifier *notifier)
 	notifier_list = g_slist_remove(notifier_list, notifier);
 }
 
+static void device_enabled(enum connman_device_type type,
+						connman_bool_t enabled)
+{
+	GSList *list;
+
+	for (list = notifier_list; list; list = list->next) {
+		struct connman_notifier *notifier = list->data;
+
+		if (notifier->device_enabled)
+			notifier->device_enabled(type, enabled);
+	}
+
+}
+
+static volatile gint enabled[10];
+
 void __connman_notifier_device_type_increase(enum connman_device_type type)
 {
 	DBG("type %d", type);
+
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+		return;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_GPS:
+		if (g_atomic_int_exchange_and_add(&enabled[type], 1) == 0)
+			device_enabled(type, TRUE);
+		break;
+	}
 }
 
 void __connman_notifier_device_type_decrease(enum connman_device_type type)
 {
 	DBG("type %d", type);
+
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+		return;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_GPS:
+		if (g_atomic_int_dec_and_test(&enabled[type]) == TRUE)
+			device_enabled(type, FALSE);
+		break;
+	}
 }
 
 void __connman_notifier_offline_mode(connman_bool_t enabled)
 {
+	GSList *list;
+
 	DBG("enabled %d", enabled);
+
+	for (list = notifier_list; list; list = list->next) {
+		struct connman_notifier *notifier = list->data;
+
+		if (notifier->offline_mode)
+			notifier->offline_mode(enabled);
+	}
 }
 
 int __connman_notifier_init(void)

commit 18b98a772b0ddad66b79b958b271a20879e4f225
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 22:06:06 2009 +0100

    Add support for sending flight mode indication

diff --git a/plugins/iospm.c b/plugins/iospm.c
index 9d5db44b..b967d4bd 100644
--- a/plugins/iospm.c
+++ b/plugins/iospm.c
@@ -26,8 +26,16 @@
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/notifier.h>
+#include <connman/dbus.h>
 #include <connman/log.h>
 
+#define IOSPM_SERVICE		"com.intel.mid.ospm"
+#define IOSPM_INTERFACE		IOSPM_SERVICE ".MMF"
+
+#define IOSPM_FLIGHT_MODE	"/com/intel/mid/ospm/flight_mode"
+
+static DBusConnection *connection;
+
 static void iospm_device_enabled(enum connman_device_type type,
 						connman_bool_t enabled)
 {
@@ -36,7 +44,26 @@ static void iospm_device_enabled(enum connman_device_type type,
 
 static void iospm_offline_mode(connman_bool_t enabled)
 {
+	DBusMessage *message;
+	const char *method;
+
 	DBG("enabled %d", enabled);
+
+	if (enabled == TRUE)
+		method = "IndicateStart";
+	else
+		method = "IndicateStop";
+
+	message = dbus_message_new_method_call(IOSPM_SERVICE,
+				IOSPM_FLIGHT_MODE, IOSPM_INTERFACE, method);
+	if (message == NULL)
+		return;
+
+	dbus_message_set_no_reply(message, TRUE);
+
+	dbus_connection_send(connection, message, NULL);
+
+	dbus_message_unref(message);
 }
 
 static struct connman_notifier iospm_notifier = {
@@ -48,12 +75,16 @@ static struct connman_notifier iospm_notifier = {
 
 static int iospm_init(void)
 {
+	connection = connman_dbus_get_connection();
+
 	return connman_notifier_register(&iospm_notifier);
 }
 
 static void iospm_exit(void)
 {
 	connman_notifier_unregister(&iospm_notifier);
+
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE(ospm, "Intel OSPM notification plugin", VERSION,

commit aee3ce108157d7776420cecca4690c597d2cee8f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 23:45:25 2009 +0100

    Add fully dynamic property storage capabilities

diff --git a/include/element.h b/include/element.h
index 8bdc42c4..d8fa88c1 100644
--- a/include/element.h
+++ b/include/element.h
@@ -30,6 +30,7 @@ extern "C" {
 #include <glib.h>
 
 #include <connman/property.h>
+#include <connman/types.h>
 #include <connman/ipv4.h>
 
 /**
@@ -97,20 +98,21 @@ extern struct connman_element *connman_element_create(const char *name);
 extern struct connman_element *connman_element_ref(struct connman_element *element);
 extern void connman_element_unref(struct connman_element *element);
 
-extern int connman_element_set_static_property(struct connman_element *element,
-				const char *name, int type, const void *value);
-extern int connman_element_set_static_array_property(struct connman_element *element,
-			const char *name, int type, const void *value, int len);
-extern int connman_element_set_property(struct connman_element *element,
-				enum connman_property_id id, const void *value);
 extern int connman_element_get_value(struct connman_element *element,
 				enum connman_property_id id, void *value);
-extern gboolean connman_element_get_static_property(struct connman_element *element,
-						const char *name, void *value);
-extern gboolean connman_element_get_static_array_property(struct connman_element *element,
-					const char *name, void *value, int *len);
-extern gboolean connman_element_match_static_property(struct connman_element *element,
-					const char *name, const void *value);
+
+extern int connman_element_set_string(struct connman_element *element,
+					const char *key, const char *value);
+extern const char *connman_element_get_string(struct connman_element *element,
+							const char *key);
+extern int connman_element_set_uint8(struct connman_element *element,
+				const char *key, connman_uint8_t value);
+extern connman_uint8_t connman_element_get_uint8(struct connman_element *element,
+							const char *key);
+extern int connman_element_set_blob(struct connman_element *element,
+			const char *key, const void *data, unsigned int size);
+extern const void *connman_element_get_blob(struct connman_element *element,
+					const char *key, unsigned int *size);
 
 extern int connman_element_register(struct connman_element *element,
 					struct connman_element *parent);
diff --git a/include/property.h b/include/property.h
index ec8254cb..b4c7e18d 100644
--- a/include/property.h
+++ b/include/property.h
@@ -43,12 +43,19 @@ enum connman_property_id {
 	CONNMAN_PROPERTY_ID_IPV4_NAMESERVER,
 };
 
+enum connman_property_type {
+	CONNMAN_PROPERTY_TYPE_INVALID = 0,
+	CONNMAN_PROPERTY_TYPE_STRING,
+	CONNMAN_PROPERTY_TYPE_UINT8,
+	CONNMAN_PROPERTY_TYPE_BLOB,
+};
+
 struct connman_property {
 	enum connman_property_id id;
 	int type;
 	int subtype;
 	void *value;
-	int size;
+	unsigned int size;
 };
 
 #ifdef __cplusplus
diff --git a/src/connection.c b/src/connection.c
index d102380c..79890dc3 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -300,9 +300,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	struct connman_element *element = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	connman_uint8_t strength = 0;
+	connman_uint8_t strength;
 	const char *device, *network;
-	const char *type = NULL;
+	const char *type;
 
 	DBG("conn %p", conn);
 
@@ -321,13 +321,12 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	connman_element_get_static_property(element, "Type", &type);
-
+	type = connman_element_get_string(element, "Type");
 	if (type != NULL)
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &type);
 
-	connman_element_get_static_property(element, "Strength", &strength);
+	strength = connman_element_get_uint8(element, "Strength");
 	if (strength > 0)
 		connman_dbus_dict_append_variant(&dict, "Strength",
 						DBUS_TYPE_BYTE, &strength);
diff --git a/src/device.c b/src/device.c
index 30940385..010a1159 100644
--- a/src/device.c
+++ b/src/device.c
@@ -845,8 +845,7 @@ struct connman_device *connman_device_create(const char *node,
 
 	str = type2string(type);
 	if (str != NULL)
-		connman_element_set_static_property(&device->element,
-					"Type", DBUS_TYPE_STRING, &str);
+		connman_element_set_string(&device->element, "Type", str);
 
 	device->element.ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
 
@@ -1386,7 +1385,7 @@ int connman_device_set_string(struct connman_device *device,
 		device->node = g_strdup(value);
 	}
 
-	return 0;
+	return connman_element_set_string(&device->element, key, value);
 }
 
 /**
@@ -1406,7 +1405,7 @@ const char *connman_device_get_string(struct connman_device *device,
 	else if (g_str_equal(key, "Node") == TRUE)
 		return device->node;
 
-	return NULL;
+	return connman_element_get_string(&device->element, key);
 }
 
 static void set_offlinemode(struct connman_element *element, gpointer user_data)
diff --git a/src/element.c b/src/element.c
index 9a2ec3b6..614c875b 100644
--- a/src/element.c
+++ b/src/element.c
@@ -510,7 +510,7 @@ void connman_element_unref(struct connman_element *element)
 	}
 }
 
-int connman_element_set_static_property(struct connman_element *element,
+static int set_static_property(struct connman_element *element,
 				const char *name, int type, const void *value)
 {
 	struct connman_property *property;
@@ -549,7 +549,7 @@ int connman_element_set_static_property(struct connman_element *element,
 	return 0;
 }
 
-int connman_element_set_static_array_property(struct connman_element *element,
+static int set_static_array_property(struct connman_element *element,
 			const char *name, int type, const void *value, int len)
 {
 	struct connman_property *property;
@@ -589,7 +589,8 @@ int connman_element_set_static_array_property(struct connman_element *element,
 	return 0;
 }
 
-int connman_element_set_property(struct connman_element *element,
+#if 0
+static int set_property(struct connman_element *element,
 				enum connman_property_id id, const void *value)
 {
 	switch (id) {
@@ -629,6 +630,7 @@ int connman_element_set_property(struct connman_element *element,
 
 	return 0;
 }
+#endif
 
 int connman_element_get_value(struct connman_element *element,
 				enum connman_property_id id, void *value)
@@ -692,7 +694,7 @@ int connman_element_get_value(struct connman_element *element,
 	return 0;
 }
 
-gboolean connman_element_get_static_property(struct connman_element *element,
+static gboolean get_static_property(struct connman_element *element,
 						const char *name, void *value)
 {
 	struct connman_property *property;
@@ -719,14 +721,13 @@ gboolean connman_element_get_static_property(struct connman_element *element,
 	__connman_element_unlock(element);
 
 	if (found == FALSE && element->parent != NULL)
-		return connman_element_get_static_property(element->parent,
-								name, value);
+		return get_static_property(element->parent, name, value);
 
 	return found;
 }
 
-gboolean connman_element_get_static_array_property(struct connman_element *element,
-					const char *name, void *value, int *len)
+static gboolean get_static_array_property(struct connman_element *element,
+			const char *name, void *value, unsigned int *len)
 {
 	struct connman_property *property;
 	gboolean found = FALSE;
@@ -747,7 +748,8 @@ gboolean connman_element_get_static_array_property(struct connman_element *eleme
 	return found;
 }
 
-gboolean connman_element_match_static_property(struct connman_element *element,
+#if 0
+static gboolean match_static_property(struct connman_element *element,
 					const char *name, const void *value)
 {
 	struct connman_property *property;
@@ -768,6 +770,106 @@ gboolean connman_element_match_static_property(struct connman_element *element,
 
 	return result;
 }
+#endif
+
+/**
+ * connman_element_set_string:
+ * @element: element structure
+ * @key: unique identifier
+ * @value: string value
+ *
+ * Set string value for specific key
+ */
+int connman_element_set_string(struct connman_element *element,
+					const char *key, const char *value)
+{
+	return set_static_property(element, key, DBUS_TYPE_STRING, &value);
+}
+
+/**
+ * connman_element_get_string:
+ * @element: element structure
+ * @key: unique identifier
+ *
+ * Get string value for specific key
+ */
+const char *connman_element_get_string(struct connman_element *element,
+							const char *key)
+{
+	const char *value;
+
+	if (get_static_property(element, key, &value) == FALSE)
+		return NULL;
+
+	return value;
+}
+
+/**
+ * connman_element_set_uint8:
+ * @element: element structure
+ * @key: unique identifier
+ * @value: integer value
+ *
+ * Set integer value for specific key
+ */
+int connman_element_set_uint8(struct connman_element *element,
+					const char *key, connman_uint8_t value)
+{
+        return set_static_property(element, key, DBUS_TYPE_BYTE, &value);
+}
+
+/**
+ * connman_element_get_uint8:
+ * @element: element structure
+ * @key: unique identifier
+ *
+ * Get integer value for specific key
+ */
+connman_uint8_t connman_element_get_uint8(struct connman_element *element,
+							const char *key)
+{
+	connman_uint8_t value;
+
+	if (get_static_property(element, key, &value) == FALSE)
+                return 0;
+
+	return value;
+}
+
+/**
+ * connman_element_set_blob:
+ * @element: element structure
+ * @key: unique identifier
+ * @data: blob data
+ * @size: blob size
+ *
+ * Set binary blob value for specific key
+ */
+int connman_element_set_blob(struct connman_element *element,
+			const char *key, const void *data, unsigned int size)
+{
+	return set_static_array_property(element, key,
+						DBUS_TYPE_BYTE, data, size);
+}
+
+/**
+ * connman_element_get_blob:
+ * @element: element structure
+ * @key: unique identifier
+ * @size: pointer to blob size
+ *
+ * Get binary blob value for specific key
+ */
+const void *connman_element_get_blob(struct connman_element *element,
+					const char *key, unsigned int *size)
+{
+	void *value;
+
+	if (get_static_array_property(element, key, &value, size) == FALSE)
+		return NULL;
+
+	return value;
+}
 
 int __connman_element_append_ipv4(struct connman_element *element,
 						DBusMessageIter *dict)
diff --git a/src/network.c b/src/network.c
index 2618dad9..1ef7486c 100644
--- a/src/network.c
+++ b/src/network.c
@@ -481,11 +481,9 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	str = type2string(type);
 	if (str != NULL)
-		connman_element_set_static_property(&network->element,
-					"Type", DBUS_TYPE_STRING, &str);
+		connman_element_set_string(&network->element, "Type", str);
 
-	connman_element_set_static_property(&network->element,
-					"Strength", DBUS_TYPE_BYTE, &strength);
+	connman_element_set_uint8(&network->element, "Strength", strength);
 
 	network->type = type;
 	network->identifier = g_strdup(identifier);
@@ -855,7 +853,7 @@ int connman_network_set_string(struct connman_network *network,
 		network->wifi.passphrase = g_strdup(value);
 	}
 
-	return 0;
+	return connman_element_set_string(&network->element, key, value);
 }
 
 /**
@@ -881,7 +879,7 @@ const char *connman_network_get_string(struct connman_network *network,
 	else if (g_str_equal(key, "WiFi.Passphrase") == TRUE)
 		return network->wifi.passphrase;
 
-	return NULL;
+	return connman_element_get_string(&network->element, key);
 }
 
 /**
@@ -899,13 +897,10 @@ int connman_network_set_uint8(struct connman_network *network,
 
 	if (g_str_equal(key, "Priority") == TRUE)
 		network->priority = value;
-	else if (g_str_equal(key, "Strength") == TRUE) {
+	else if (g_str_equal(key, "Strength") == TRUE)
 		network->strength = value;
-		connman_element_set_static_property(&network->element,
-					"Strength", DBUS_TYPE_BYTE, &value);
-	}
 
-	return 0;
+	return connman_element_set_uint8(&network->element, key, value);
 }
 
 /**
@@ -925,7 +920,7 @@ connman_uint8_t connman_network_get_uint8(struct connman_network *network,
 	else if (g_str_equal(key, "Strength") == TRUE)
 		return network->strength;
 
-	return 0;
+	return connman_element_get_uint8(&network->element, key);
 }
 
 /**
@@ -952,7 +947,7 @@ int connman_network_set_blob(struct connman_network *network,
 			network->wifi.ssid_len = 0;
 	}
 
-	return 0;
+	return connman_element_set_blob(&network->element, key, data, size);
 }
 
 /**
@@ -974,7 +969,7 @@ const void *connman_network_get_blob(struct connman_network *network,
 		return network->wifi.ssid;
 	}
 
-	return NULL;
+	return connman_element_get_blob(&network->element, key, size);
 }
 
 void __connman_network_set_device(struct connman_network *network,

commit 496731294b2bbbe54cb75b1e01c1dd410a4c748a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 11 23:57:20 2009 +0100

    Add initial support for common property key constants

diff --git a/include/property.h b/include/property.h
index b4c7e18d..a6ea83c8 100644
--- a/include/property.h
+++ b/include/property.h
@@ -32,6 +32,11 @@ extern "C" {
  * @short_description: Functions for handling properties
  */
 
+#define CONNMAN_PROPERTY_ID_NAME	"Name"
+#define CONNMAN_PROPERTY_ID_TYPE	"Type"
+#define CONNMAN_PROPERTY_ID_PRIORITY	"Priority"
+#define CONNMAN_PROPERTY_ID_STRENGTH	"Strength"
+
 enum connman_property_id {
 	CONNMAN_PROPERTY_ID_INVALID = 0,
 
diff --git a/src/device.c b/src/device.c
index 010a1159..e7111257 100644
--- a/src/device.c
+++ b/src/device.c
@@ -845,7 +845,8 @@ struct connman_device *connman_device_create(const char *node,
 
 	str = type2string(type);
 	if (str != NULL)
-		connman_element_set_string(&device->element, "Type", str);
+		connman_element_set_string(&device->element,
+					CONNMAN_PROPERTY_ID_TYPE, str);
 
 	device->element.ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
 
@@ -1186,7 +1187,8 @@ static void connect_known_network(struct connman_device *device)
 		if (connman_network_get_available(value) == FALSE)
 			continue;
 
-		name = connman_network_get_string(value, "Name");
+		name = connman_network_get_string(value,
+						CONNMAN_PROPERTY_ID_NAME);
 		if (name != NULL && device->last_network != NULL) {
 			if (g_str_equal(name, device->last_network) == TRUE) {
 				network = value;
@@ -1202,8 +1204,10 @@ static void connect_known_network(struct connman_device *device)
 			continue;
 		}
 
-		old_priority = connman_network_get_uint8(network, "Priority");
-		new_priority = connman_network_get_uint8(value, "Priority");
+		old_priority = connman_network_get_uint8(network,
+						CONNMAN_PROPERTY_ID_PRIORITY);
+		new_priority = connman_network_get_uint8(value,
+						CONNMAN_PROPERTY_ID_PRIORITY);
 
 		if (new_priority != old_priority) {
 			if (new_priority > old_priority)
@@ -1211,8 +1215,10 @@ static void connect_known_network(struct connman_device *device)
 			continue;
 		}
 
-		old_strength = connman_network_get_uint8(network, "Strength");
-		new_strength = connman_network_get_uint8(value, "Strength");
+		old_strength = connman_network_get_uint8(network,
+						CONNMAN_PROPERTY_ID_STRENGTH);
+		new_strength = connman_network_get_uint8(value,
+						CONNMAN_PROPERTY_ID_STRENGTH);
 
 		if (new_strength > old_strength)
 			network = value;
@@ -1528,7 +1534,8 @@ void __connman_device_set_network(struct connman_device *device,
 	const char *name;
 
 	if (network != NULL) {
-		name = connman_network_get_string(network, "Name");
+		name = connman_network_get_string(network,
+						CONNMAN_PROPERTY_ID_NAME);
 		device->last_network = g_strdup(name);
 	}
 

commit 175ecf87549c9b23dfc67838dd248f17cb0c2507
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 07:32:20 2009 +0100

    Fix crash when unplugging WiFi devices

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b5c96992..f187b86a 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -362,6 +362,8 @@ static void remove_interface_reply(DBusPendingCall *call, void *user_data)
 
 	connman_device_set_powered(task->device, FALSE);
 
+	connman_device_unref(task->device);
+
 	free_task(task);
 
 	dbus_message_unref(reply);
@@ -1238,13 +1240,14 @@ int supplicant_start(struct connman_device *device)
 
 	task->ifindex = connman_device_get_index(device);
 	task->ifname = inet_index2name(task->ifindex);
-	task->device = device;
 
 	if (task->ifname == NULL) {
 		g_free(task);
 		return -ENOMEM;
 	}
 
+	task->device = connman_device_ref(device);
+
 	task->created = FALSE;
 	task->noscan = FALSE;
 	task->state = WPA_INVALID;

commit 7566520f1760973a5066db9f9e58cf57c3a8f82a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 07:38:08 2009 +0100

    Don't load last used network from configuration

diff --git a/src/device.c b/src/device.c
index e7111257..aa6a3977 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1723,10 +1723,12 @@ static int device_load(struct connman_device *device)
 		break;
 	}
 
+#if 0
 	str = g_key_file_get_string(keyfile, "Configuration",
 							"LastNetwork", NULL);
 	if (str != NULL)
 		device->last_network = str;
+#endif
 
 	g_key_file_free(keyfile);
 

commit 0a1c03c0a2ad11f5acd77e57605b6bb98325a875
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 07:59:06 2009 +0100

    Mention the service list property

diff --git a/doc/profile-api.txt b/doc/profile-api.txt
index e4aa5358..f807070e 100644
--- a/doc/profile-api.txt
+++ b/doc/profile-api.txt
@@ -20,3 +20,7 @@ Signals		PropertyChanged(string name, variant value)
 Properties	string Name [readonly]
 
 			Name of this profile.
+
+		array{object} Services [readonly]
+
+			List of service objects.

commit e234020c958d48676207de2744dec6066d555905
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 08:06:51 2009 +0100

    Release 0.13

diff --git a/ChangeLog b/ChangeLog
index 6def7cc1..cc58a65b 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,11 @@
+ver 0.13:
+	Add support for notification infrastructure.
+	Add fully dynamic property storage capabilities.
+	Fix broken loading of last network on bootup.
+	Fix crash when unplugging WiFi devices.
+	Rename OSPM plugin to Intel OSPM plugin.
+	Rename WiMAX plugin to Intel WiMAX SDK plugin.
+
 ver 0.12:
 	Fix connection state change handling.
 	Fix network list enumeration.
diff --git a/configure.ac b/configure.ac
index 4842ad20..c8274ead 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.12)
+AM_INIT_AUTOMAKE(connman, 0.13)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit f833926475da29a64ab64dabb7fa7ffdc13b18ab
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 10:04:43 2009 +0100

    Add example for DNS request parsing

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index ee65f03e..66d608c3 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -26,6 +26,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <string.h>
+#include <stdint.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 
@@ -235,6 +236,85 @@ static struct connman_resolver dnsproxy_resolver = {
 	.remove		= dnsproxy_remove,
 };
 
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+struct domain_hdr {
+	uint16_t id;
+	uint8_t rd:1;
+	uint8_t tc:1;
+	uint8_t aa:1;
+	uint8_t opcode:4;
+	uint8_t qr:1;
+	uint8_t rcode:4;
+	uint8_t z:3;
+	uint8_t ra:1;
+	uint16_t qdcount;
+	uint16_t ancount;
+	uint16_t nscount;
+	uint16_t arcount;
+} __attribute__ ((packed));
+#elif __BYTE_ORDER == __BIG_ENDIAN
+struct domain_hdr {
+	uint16_t id;
+	uint8_t qr:1;
+	uint8_t opcode:4;
+	uint8_t aa:1;
+	uint8_t tc:1;
+	uint8_t rd:1;
+	uint8_t ra:1;
+	uint8_t z:3;
+	uint8_t rcode:4;
+	uint16_t qdcount;
+	uint16_t ancount;
+	uint16_t nscount;
+	uint16_t arcount;
+} __attribute__ ((packed));
+#else
+#error "Unknown byte order"
+#endif
+
+static void parse_request(unsigned char *buf, int len)
+{
+	struct domain_hdr *hdr = (void *) buf;
+	uint16_t qdcount = ntohs(hdr->qdcount);
+	unsigned char *ptr;
+	char name[512];
+	unsigned int remain, used = 0;
+
+	if (len < 12)
+		return;
+
+	DBG("id 0x%04x qr %d opcode %d qdcount %d",
+				hdr->id, hdr->qr, hdr->opcode, qdcount);
+
+	if (hdr->qr != 0 || qdcount != 1)
+		return;
+
+	memset(name, 0, sizeof(name));
+
+	ptr = buf + 12;
+	remain = len - 12;
+
+	while (remain > 0) {
+		uint8_t len = *ptr;
+
+		if (len == 0x00)
+			break;
+
+		if (used + len + 1 > sizeof(name))
+			return;
+
+		strncat(name, (char *) (ptr + 1), len);
+		strcat(name, ".");
+
+		used += len + 1;
+
+		ptr += len + 1;
+		remain -= len + 1;
+	}
+
+	DBG("domain name %s", name);
+}
+
 static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 							gpointer user_data)
 {
@@ -255,6 +335,8 @@ static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 
 	DBG("Received %d bytes (id 0x%04x)", len, buf[0] | buf[1] << 8);
 
+	parse_request(buf, len);
+
 	if (g_slist_length(server_list) == 0)
 		return TRUE;
 

commit 0f844d00ed22e17eb90b4a7994fef8d097d91313
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 23 19:38:09 2009 +0100

    Fix crash with property blobs

diff --git a/src/element.c b/src/element.c
index 614c875b..73a3c8fe 100644
--- a/src/element.c
+++ b/src/element.c
@@ -849,7 +849,7 @@ int connman_element_set_blob(struct connman_element *element,
 			const char *key, const void *data, unsigned int size)
 {
 	return set_static_array_property(element, key,
-						DBUS_TYPE_BYTE, data, size);
+						DBUS_TYPE_BYTE, &data, size);
 }
 
 /**

commit 74fd87ac31a8b3f1f5061463fc3db9203c7e9253
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 24 15:13:09 2009 +0100

    Add definitions for element states and errors

diff --git a/include/driver.h b/include/driver.h
index f4c6187a..61ec465f 100644
--- a/include/driver.h
+++ b/include/driver.h
@@ -44,7 +44,8 @@ struct connman_driver {
 	int priority;
 	int (*probe) (struct connman_element *element);
 	void (*remove) (struct connman_element *element);
-	int (*update) (struct connman_element *element);
+	void (*update) (struct connman_element *element);
+	void (*change) (struct connman_element *element);
 };
 
 extern int connman_driver_register(struct connman_driver *driver);
diff --git a/include/element.h b/include/element.h
index d8fa88c1..bc6a2a9e 100644
--- a/include/element.h
+++ b/include/element.h
@@ -56,6 +56,19 @@ enum connman_element_type {
 	CONNMAN_ELEMENT_TYPE_VENDOR     = 10000,
 };
 
+enum connman_element_state {
+	CONNMAN_ELEMENT_STATE_UNKNOWN = 0,
+	CONNMAN_ELEMENT_STATE_ERROR   = 1,
+	CONNMAN_ELEMENT_STATE_IDLE    = 2,
+	CONNMAN_ELEMENT_STATE_DONE    = 3,
+};
+
+enum connman_element_error {
+	CONNMAN_ELEMENT_ERROR_UNKNOWN     = 0,
+	CONNMAN_ELEMENT_ERROR_FAILED      = 1,
+	CONNMAN_ELEMENT_ERROR_DHCP_FAILED = 2,
+};
+
 struct connman_driver;
 
 struct connman_element {
@@ -64,6 +77,8 @@ struct connman_element {
 	gchar *name;
 	gchar *path;
 	enum connman_element_type type;
+	enum connman_element_state state;
+	enum connman_element_error error;
 	gboolean enabled;
 	gboolean configuring;
 	gchar *devname;
@@ -122,6 +137,8 @@ extern void connman_element_update(struct connman_element *element);
 
 extern int connman_element_set_enabled(struct connman_element *element,
 							gboolean enabled);
+extern void connman_element_set_error(struct connman_element *element,
+					enum connman_element_error error);
 
 static inline void *connman_element_get_data(struct connman_element *element)
 {
diff --git a/src/element.c b/src/element.c
index 73a3c8fe..b68e954e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -433,6 +433,8 @@ void __connman_element_initialize(struct connman_element *element)
 
 	element->name    = NULL;
 	element->type    = CONNMAN_ELEMENT_TYPE_UNKNOWN;
+	element->state   = CONNMAN_ELEMENT_STATE_UNKNOWN;
+	element->error   = CONNMAN_ELEMENT_ERROR_UNKNOWN;
 	element->index   = -1;
 	element->enabled = FALSE;
 
@@ -1239,6 +1241,28 @@ int connman_element_set_enabled(struct connman_element *element,
 	return 0;
 }
 
+/**
+ * connman_element_set_error:
+ * @element: element structure
+ * @error: error identifier
+ *
+ * Set error state and specific error identifier
+ */
+void connman_element_set_error(struct connman_element *element,
+					enum connman_element_error error)
+{
+	DBG("element %p error %d", element, error);
+
+	if (element->type == CONNMAN_ELEMENT_TYPE_ROOT)
+		return;
+
+	element->state = CONNMAN_ELEMENT_STATE_ERROR;
+	element->error = error;
+
+	if (element->driver && element->driver->change)
+		element->driver->change(element);
+}
+
 int __connman_element_init(DBusConnection *conn, const char *device,
 							const char *nodevice)
 {

commit ee6a91f87363f8ecb31cac1c63e52328456469ba
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 24 15:13:57 2009 +0100

    Propagate DHCP errors to parent elements

diff --git a/plugins/dhclient.c b/plugins/dhclient.c
index 7e5e6d0a..0bf9ad11 100644
--- a/plugins/dhclient.c
+++ b/plugins/dhclient.c
@@ -215,11 +215,21 @@ static void dhclient_remove(struct connman_element *element)
 	kill_task(task);
 }
 
+static void dhclient_change(struct connman_element *element)
+{
+	DBG("element %p name %s", element, element->name);
+
+	if (element->state == CONNMAN_ELEMENT_STATE_ERROR)
+		connman_element_set_error(element->parent,
+					CONNMAN_ELEMENT_ERROR_DHCP_FAILED);
+}
+
 static struct connman_driver dhclient_driver = {
 	.name		= "dhclient",
 	.type		= CONNMAN_ELEMENT_TYPE_DHCP,
 	.probe		= dhclient_probe,
 	.remove		= dhclient_remove,
+	.change		= dhclient_change,
 };
 
 static DBusHandlerResult dhclient_filter(DBusConnection *conn,
@@ -306,6 +316,9 @@ static DBusHandlerResult dhclient_filter(DBusConnection *conn,
 	} else if (g_ascii_strcasecmp(text, "RENEW") == 0 ||
 				g_ascii_strcasecmp(text, "REBIND") == 0) {
 		connman_element_update(task->element);
+	} else if (g_ascii_strcasecmp(text, "FAIL") == 0) {
+		connman_element_set_error(task->element,
+						CONNMAN_ELEMENT_ERROR_FAILED);
 	} else {
 	}
 

commit 2c725f29c9f1d05bfc79f496028dd0b57e676b09
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 24 15:25:35 2009 +0100

    Handle DHCP failures and disconnect from the network

diff --git a/src/network.c b/src/network.c
index 1ef7486c..d77173b8 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1082,12 +1082,40 @@ static void network_remove(struct connman_element *element)
 		network->driver->remove(network);
 }
 
+static void network_change(struct connman_element *element)
+{
+	struct connman_network *network = element->network;
+
+	DBG("element %p name %s", element, element->name);
+
+	if (element->state != CONNMAN_ELEMENT_STATE_ERROR)
+		return;
+
+	if (element->error != CONNMAN_ELEMENT_ERROR_DHCP_FAILED)
+		return;
+
+	if (network->connected == FALSE)
+		return;
+
+	connman_element_unregister_children(element);
+
+	connman_device_set_disconnected(network->device, TRUE);
+
+	if (network->driver && network->driver->disconnect) {
+		network->driver->disconnect(network);
+		return;
+	}
+
+	network->connected = FALSE;
+}
+
 static struct connman_driver network_driver = {
 	.name		= "network",
 	.type		= CONNMAN_ELEMENT_TYPE_NETWORK,
 	.priority	= CONNMAN_DRIVER_PRIORITY_LOW,
 	.probe		= network_probe,
 	.remove		= network_remove,
+	.change		= network_change,
 };
 
 static int network_init(struct connman_device *device)

commit 2f30e758126caee8d4caaea3e6456d256cc47188
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 24 17:29:00 2009 +0100

    Mention the different gtk-doc package name for Debian

diff --git a/HACKING b/HACKING
index baf7ccd5..c14b2145 100644
--- a/HACKING
+++ b/HACKING
@@ -126,7 +126,10 @@ To make the gtk-doc process work, the gtk-doc tools need to be installed.
 Every distribution should provide a package for this, but the naming of the
 package might be different:
 
-  Ubuntu/Debian
+  Debian
+    # apt-get install gtk-doc-tools
+
+  Ubuntu
     # apt-get install gtk-doc-utils
 
   Fedora

commit 83b0c14871149ec2a009322a076e36af0de66e39
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 05:43:07 2009 +0100

    The loopback address must be set to 127.0.0.1

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 7607eea2..22a61fb9 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -61,7 +61,7 @@ static int loopback_init(void)
 
 	addr = (struct sockaddr_in *) &ifr.ifr_addr;
 	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = inet_addr("127.0.0.0");
+	addr->sin_addr.s_addr = inet_addr("127.0.0.1");
 
 	err = ioctl(sk, SIOCSIFADDR, &ifr);
 	if (err < 0) {

commit d768f6821cdb93ffbce08fbb19777202e61682b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 17:04:31 2009 -0700

    Check for socket errors and cancel gracefully

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index 66d608c3..84ad596b 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -94,10 +94,17 @@ static struct server_data *find_server(const char *interface,
 static gboolean server_event(GIOChannel *channel, GIOCondition condition,
 							gpointer user_data)
 {
+	struct server_data *data = user_data;
 	struct request_data *req;
 	unsigned char buf[768];
 	int sk, err, len;
 
+	if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
+		connman_error("Error with server channel");
+		data->watch = 0;
+		return FALSE;
+	}
+
 	sk = g_io_channel_unix_get_fd(channel);
 
 	len = recv(sk, buf, sizeof(buf), 0);
@@ -325,6 +332,12 @@ static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 	socklen_t size = sizeof(sin);
 	int sk, err, len;
 
+	if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
+		connman_error("Error with listener channel");
+		listener_watch = 0;
+		return FALSE;
+	}
+
 	sk = g_io_channel_unix_get_fd(channel);
 
 	memset(&sin, 0, sizeof(sin));

commit c1beabceca8862bb17efc2155e0ca4811928407f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 17:14:19 2009 -0700

    Add test script for setting device priorities

diff --git a/test/Makefile.am b/test/Makefile.am
index e88b602d..d09108e5 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -2,9 +2,9 @@
 EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
-		set-passphrase set-address set-policy test-manager \
+		set-passphrase set-address set-policy set-priority \
 		connect-network disconnect-network simple-agent \
-		show-introspection test-compat \
+		show-introspection test-compat test-manager \
 		test-connman monitor-connman debug-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/set-priority b/test/set-priority
new file mode 100755
index 00000000..37a0e72d
--- /dev/null
+++ b/test/set-priority
@@ -0,0 +1,28 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 3):
+	print "Usage: %s <device> <priority>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object('org.moblin.connman', "/"),
+					'org.moblin.connman.Manager')
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object('org.moblin.connman', path),
+						'org.moblin.connman.Device')
+
+	properties = device.GetProperties()
+
+	if properties["Interface"] != sys.argv[1]:
+		continue;
+
+	print "Setting priority %d for device %s" % (int(sys.argv[2]), path)
+
+	device.SetProperty("Priority", dbus.Byte(int(sys.argv[2])));

commit 3ed3733d91b7d350c54cc3bf39e30248e1ba6320
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 18:49:44 2009 -0700

    Add support for network address property

diff --git a/src/network.c b/src/network.c
index d77173b8..fefc369a 100644
--- a/src/network.c
+++ b/src/network.c
@@ -39,6 +39,7 @@ struct connman_network {
 	connman_uint8_t priority;
 	connman_uint8_t strength;
 	char *identifier;
+	char *address;
 	char *name;
 	char *node;
 
@@ -109,6 +110,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 						DBUS_TYPE_OBJECT_PATH, &path);
 	}
 
+	if (network->address != NULL)
+		connman_dbus_dict_append_variant(&dict, "Address",
+					DBUS_TYPE_STRING, &network->address);
+
 	if (network->name != NULL)
 		connman_dbus_dict_append_variant(&dict, "Name",
 					DBUS_TYPE_STRING, &network->name);
@@ -430,6 +435,7 @@ static void network_destruct(struct connman_element *element)
 
 	g_free(network->node);
 	g_free(network->name);
+	g_free(network->address);
 	g_free(network->identifier);
 }
 
@@ -836,7 +842,10 @@ int connman_network_set_string(struct connman_network *network,
 {
 	DBG("network %p key %s value %s", network, key, value);
 
-	if (g_str_equal(key, "Name") == TRUE) {
+	if (g_str_equal(key, "Address") == TRUE) {
+		g_free(network->address);
+		network->address = g_strdup(value);
+	} else if (g_str_equal(key, "Name") == TRUE) {
 		g_free(network->name);
 		network->name = g_strdup(value);
 	} else if (g_str_equal(key, "Node") == TRUE) {
@@ -868,7 +877,9 @@ const char *connman_network_get_string(struct connman_network *network,
 {
 	DBG("network %p key %s", network, key);
 
-	if (g_str_equal(key, "Name") == TRUE)
+	if (g_str_equal(key, "Address") == TRUE)
+		return network->address;
+	else if (g_str_equal(key, "Name") == TRUE)
 		return network->name;
 	else if (g_str_equal(key, "Node") == TRUE)
 		return network->node;

commit fa0509daa64c3543ae876472bf157339e9a2b646
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 18:53:08 2009 -0700

    Document the network address property

diff --git a/doc/network-api.txt b/doc/network-api.txt
index 66ad6fbd..fc4f3480 100644
--- a/doc/network-api.txt
+++ b/doc/network-api.txt
@@ -27,12 +27,20 @@ Signals		PropertyChanged(string name, variant value)
 			This signal indicates a changed value of the given
 			property.
 
-Properties	string Name [readonly]
+Properties	string Address [readonly]
+
+			The address of the network.
+
+		string Name [readonly]
 
 			The pretty/long version of the network name. For
 			example in case of WiFi this should be the UTF-8
 			valid version of the SSID.
 
+			This property might not be available for every
+			network. For example hidden WiFi networks will
+			not include it.
+
 		boolean Available [readonly]
 
 			Indicates that this network is in range and

commit 0d0a895973544466177880f4cdcdd6db806f6518
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 18:56:55 2009 -0700

    Fix broken test script for network selection

diff --git a/test/select-network b/test/select-network
index e7d1a635..e7c19be3 100755
--- a/test/select-network
+++ b/test/select-network
@@ -31,6 +31,9 @@ for path in properties["Devices"]:
 
 		properties = network.GetProperties()
 
+		if "Name" not in properties.keys:
+			continue
+
 		if (properties["Connected"] == dbus.Boolean(1)):
 			continue
 

commit e4cf28588ea76c004299c05c3d788aa95ae8ee5a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 18:57:32 2009 -0700

    Add support for BSSID and WPS IE extraction

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index f187b86a..47b75280 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -23,9 +23,11 @@
 #include <config.h>
 #endif
 
+#include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <net/ethernet.h>
 
 #include <gdbus.h>
 
@@ -145,7 +147,9 @@ enum supplicant_state {
 };
 
 struct supplicant_result {
-	char *identifier;
+	char *path;
+	char *name;
+	char *addr;
 	unsigned char *ssid;
 	unsigned int ssid_len;
 	dbus_uint16_t capabilities;
@@ -153,6 +157,7 @@ struct supplicant_result {
 	gboolean has_wep;
 	gboolean has_wpa;
 	gboolean has_rsn;
+	gboolean has_wps;
 	dbus_int32_t quality;
 	dbus_int32_t noise;
 	dbus_int32_t level;
@@ -769,6 +774,47 @@ static int initiate_scan(struct supplicant_task *task)
 	return 0;
 }
 
+static void extract_addr(DBusMessageIter *value,
+					struct supplicant_result *result)
+{
+	DBusMessageIter array;
+	struct ether_addr *eth;
+	unsigned char *addr;
+	int addr_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &addr, &addr_len);
+
+	if (addr_len != 6)
+		return;
+
+	eth = (void *) addr;
+
+	result->addr = g_try_malloc0(18);
+	if (result->addr == NULL)
+		return;
+
+	snprintf(result->addr, 18, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
+	result->path = g_try_malloc0(18);
+	if (result->path == NULL)
+		return;
+
+	snprintf(result->path, 18, "%02X_%02X_%02X_%02X_%02X_%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+}
+
 static void extract_ssid(DBusMessageIter *value,
 					struct supplicant_result *result)
 {
@@ -782,6 +828,9 @@ static void extract_ssid(DBusMessageIter *value,
 	if (ssid_len < 1)
 		return;
 
+	if (ssid[0] == '\0')
+		return;
+
 	result->ssid = g_try_malloc(ssid_len);
 	if (result->ssid == NULL)
 		return;
@@ -789,11 +838,11 @@ static void extract_ssid(DBusMessageIter *value,
 	memcpy(result->ssid, ssid, ssid_len);
 	result->ssid_len = ssid_len;
 
-	result->identifier = g_try_malloc0(ssid_len + 1);
-	if (result->identifier == NULL)
+	result->name = g_try_malloc0(ssid_len + 1);
+	if (result->name == NULL)
 		return;
 
-	memcpy(result->identifier, ssid, ssid_len);
+	memcpy(result->name, ssid, ssid_len);
 }
 
 static void extract_wpaie(DBusMessageIter *value,
@@ -824,6 +873,20 @@ static void extract_rsnie(DBusMessageIter *value,
 		result->has_rsn = TRUE;
 }
 
+static void extract_wpsie(DBusMessageIter *value,
+					struct supplicant_result *result)
+{
+	DBusMessageIter array;
+	unsigned char *ie;
+	int ie_len;
+
+	dbus_message_iter_recurse(value, &array);
+	dbus_message_iter_get_fixed_array(&array, &ie, &ie_len);
+
+	if (ie_len > 0)
+		result->has_wps = TRUE;
+}
+
 static void extract_capabilites(DBusMessageIter *value,
 					struct supplicant_result *result)
 {
@@ -847,7 +910,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	struct connman_network *network;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	char *security;
+	const char *mode, *security;
 	unsigned char strength;
 
 	DBG("task %p", task);
@@ -889,6 +952,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		 * ssid         : a (97)
 		 * wpaie        : a (97)
 		 * rsnie        : a (97)
+		 * wpsie        : a (97)
 		 * frequency    : i (105)
 		 * capabilities : q (113)
 		 * quality      : i (105)
@@ -897,12 +961,16 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		 * maxrate      : i (105)
 		 */
 
-		if (g_str_equal(key, "ssid") == TRUE)
+		if (g_str_equal(key, "bssid") == TRUE)
+			extract_addr(&value, &result);
+		else if (g_str_equal(key, "ssid") == TRUE)
 			extract_ssid(&value, &result);
 		else if (g_str_equal(key, "wpaie") == TRUE)
 			extract_wpaie(&value, &result);
 		else if (g_str_equal(key, "rsnie") == TRUE)
 			extract_rsnie(&value, &result);
+		else if (g_str_equal(key, "wpsie") == TRUE)
+			extract_wpsie(&value, &result);
 		else if (g_str_equal(key, "capabilities") == TRUE)
 			extract_capabilites(&value, &result);
 		else if (g_str_equal(key, "quality") == TRUE)
@@ -917,10 +985,10 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		dbus_message_iter_next(&dict);
 	}
 
-	if (result.identifier == NULL)
+	if (result.path == NULL)
 		goto done;
 
-	if (result.identifier[0] == '\0')
+	if (result.path[0] == '\0')
 		goto done;
 
 	strength = result.quality;
@@ -934,12 +1002,11 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	else
 		security = "none";
 
-	network = connman_device_get_network(task->device, result.identifier);
+	network = connman_device_get_network(task->device, result.path);
 	if (network == NULL) {
-		const char *mode;
 		int index;
 
-		network = connman_network_create(result.identifier,
+		network = connman_network_create(result.path,
 						CONNMAN_NETWORK_TYPE_WIFI);
 		if (network == NULL)
 			goto done;
@@ -950,16 +1017,7 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		connman_network_set_protocol(network,
 						CONNMAN_NETWORK_PROTOCOL_IP);
 
-		connman_network_set_string(network, "Name", result.identifier);
-
-		connman_network_set_blob(network, "WiFi.SSID",
-						result.ssid, result.ssid_len);
-
-		mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
-		connman_network_set_string(network, "WiFi.Mode", mode);
-
-		DBG("%s (%s %s) strength %d", result.identifier, mode,
-							security, strength);
+		connman_network_set_string(network, "Address", result.addr);
 
 		if (connman_device_add_network(task->device, network) < 0) {
 			connman_network_unref(network);
@@ -967,13 +1025,27 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		}
 	}
 
+	connman_network_set_string(network, "Name", result.name);
+
+	connman_network_set_blob(network, "WiFi.SSID",
+						result.ssid, result.ssid_len);
+
+	mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
+	connman_network_set_string(network, "WiFi.Mode", mode);
+
+	DBG("%s (%s %s) strength %d (%s)",
+			result.name, mode, security, strength,
+			(result.has_wps == TRUE) ? "WPS" : "no WPS");
+
 	connman_network_set_available(network, TRUE);
 	connman_network_set_uint8(network, "Strength", strength);
 
 	connman_network_set_string(network, "WiFi.Security", security);
 
 done:
-	g_free(result.identifier);
+	g_free(result.path);
+	g_free(result.addr);
+	g_free(result.name);
 	g_free(result.ssid);
 
 	dbus_message_unref(reply);

commit 7781553db8551db775b28f20c78a624203e2812b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 09:26:45 2009 +0100

    Unregister children of networks before disconnecting

diff --git a/src/network.c b/src/network.c
index fefc369a..e408e1d8 100644
--- a/src/network.c
+++ b/src/network.c
@@ -821,6 +821,8 @@ int __connman_network_disconnect(struct connman_network *network)
 	if (network->connected == FALSE)
 		return -ENOTCONN;
 
+	connman_element_unregister_children(&network->element);
+
 	if (network->driver && network->driver->disconnect)
 		return network->driver->disconnect(network);
 

commit b5a6e00c32bf531e9b35b826b2474654d923a27f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 12:00:30 2009 +0100

    Make sure entry for 127.0.0.1 is written to /etc/resolv.conf

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index 84ad596b..fb4411d2 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -209,6 +209,9 @@ static int dnsproxy_append(const char *interface, const char *domain,
 
 	DBG("interface %s server %s", interface, server);
 
+	if (g_str_equal(server, "127.0.0.1") == TRUE)
+		return -ENODEV;
+
 	data = create_server(interface, server);
 	if (data == NULL)
 		return -EIO;
@@ -225,6 +228,9 @@ static int dnsproxy_remove(const char *interface, const char *domain,
 
 	DBG("interface %s server %s", interface, server);
 
+	if (g_str_equal(server, "127.0.0.1") == TRUE)
+		return -ENODEV;
+
 	data = find_server(interface, server);
 	if (data == NULL)
 		return 0;
@@ -428,6 +434,8 @@ static int create_listener(void)
 	listener_watch = g_io_add_watch(listener_channel, G_IO_IN,
 							listener_event, NULL);
 
+	connman_resolver_append("lo", NULL, "127.0.0.1");
+
 	return 0;
 }
 
@@ -437,6 +445,8 @@ static void destroy_listener(void)
 
 	DBG("");
 
+	connman_resolver_remove_all("lo");
+
 	if (listener_watch > 0)
 		g_source_remove(listener_watch);
 

commit e22390fe984f7becb4689d5181a64907fae1d4aa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:04:40 2009 +0100

    Add support for device address property

diff --git a/doc/device-api.txt b/doc/device-api.txt
index ce50be7b..a45046d9 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -43,7 +43,11 @@ Signals		PropertyChanged(string name, variant value)
 			This signal indicates a changed value of the given
 			property.
 
-Properties	string Name [readonly]
+Properties	string Address [readonly]
+
+			The address of the device.
+
+		string Name [readonly]
 
 			The device name (for example "Wireless" etc.)
 
diff --git a/src/device.c b/src/device.c
index aa6a3977..54a74f19 100644
--- a/src/device.c
+++ b/src/device.c
@@ -43,6 +43,7 @@ struct connman_device {
 	connman_uint16_t scan_interval;
 	char *name;
 	char *node;
+	char *address;
 	char *interface;
 	unsigned int connections;
 	guint scan_timeout;
@@ -311,6 +312,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 						DBUS_TYPE_STRING, &str);
 
+	if (device->address != NULL)
+		connman_dbus_dict_append_variant(&dict, "Address",
+					DBUS_TYPE_STRING, &device->address);
+
 	if (device->interface != NULL)
 		connman_dbus_dict_append_variant(&dict, "Interface",
 					DBUS_TYPE_STRING, &device->interface);
@@ -804,6 +809,7 @@ static void device_destruct(struct connman_element *element)
 
 	g_free(device->node);
 	g_free(device->name);
+	g_free(device->address);
 	g_free(device->interface);
 
 	g_free(device->last_network);
@@ -1383,7 +1389,10 @@ int connman_device_set_string(struct connman_device *device,
 {
 	DBG("device %p key %s value %s", device, key, value);
 
-	if (g_str_equal(key, "Name") == TRUE) {
+	if (g_str_equal(key, "Address") == TRUE) {
+		g_free(device->address);
+		device->address = g_strdup(value);
+	} else if (g_str_equal(key, "Name") == TRUE) {
 		g_free(device->name);
 		device->name = g_strdup(value);
 	} else if (g_str_equal(key, "Node") == TRUE) {
@@ -1406,7 +1415,9 @@ const char *connman_device_get_string(struct connman_device *device,
 {
 	DBG("device %p key %s", device, key);
 
-	if (g_str_equal(key, "Name") == TRUE)
+	if (g_str_equal(key, "Address") == TRUE)
+		return device->address;
+	else if (g_str_equal(key, "Name") == TRUE)
 		return device->name;
 	else if (g_str_equal(key, "Node") == TRUE)
 		return device->node;

commit 910e0dcbd7b901419ec2fe4262a3c5f11124c6e4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:10:52 2009 +0100

    Store address property for Ethernet, WiFi and WiMAX devices

diff --git a/src/detect.c b/src/detect.c
index d26dc29f..1415638b 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -80,6 +80,49 @@ static char *index2name(int index)
 	return strdup(ifr.ifr_name);
 }
 
+static char *index2addr(int index)
+{
+	struct ifreq ifr;
+	struct ether_addr *eth;
+	char *str;
+	int sk, err;
+
+	if (index < 0)
+		return NULL;
+
+	sk = socket(PF_INET, SOCK_DGRAM, 0);
+	if (sk < 0)
+		return NULL;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = index;
+
+	err = ioctl(sk, SIOCGIFNAME, &ifr);
+
+	if (err == 0)
+		err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+
+	close(sk);
+
+	if (err < 0)
+		return NULL;
+
+	str = malloc(18);
+	if (!str)
+		return NULL;
+
+	eth = (void *) &ifr.ifr_hwaddr.sa_data;
+	snprintf(str, 18, "%02X:%02X:%02X:%02X:%02X:%02X",
+						eth->ether_addr_octet[0],
+						eth->ether_addr_octet[1],
+						eth->ether_addr_octet[2],
+						eth->ether_addr_octet[3],
+						eth->ether_addr_octet[4],
+						eth->ether_addr_octet[5]);
+
+	return str;
+}
+
 static char *index2ident(int index, const char *prefix)
 {
 	struct ifreq ifr;
@@ -132,7 +175,7 @@ static void detect_newlink(unsigned short type, int index,
 	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 	enum connman_device_mode mode = CONNMAN_DEVICE_MODE_UNKNOWN;
 	struct connman_device *device;
-	gchar *name, *devname;
+	gchar *addr, *name, *devname;
 
 	DBG("type %d index %d", type, index);
 
@@ -187,6 +230,7 @@ static void detect_newlink(unsigned short type, int index,
 	case CONNMAN_DEVICE_TYPE_WIFI:
 	case CONNMAN_DEVICE_TYPE_WIMAX:
 		name = index2ident(index, "dev_");
+		addr = index2addr(index);
 		break;
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 	case CONNMAN_DEVICE_TYPE_GPS:
@@ -196,6 +240,7 @@ static void detect_newlink(unsigned short type, int index,
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 	case CONNMAN_DEVICE_TYPE_VENDOR:
 		name = strdup(devname);
+		addr = NULL;
 		break;
 	}
 
@@ -203,6 +248,7 @@ static void detect_newlink(unsigned short type, int index,
 	if (device == NULL) {
 		g_free(devname);
 		g_free(name);
+		g_free(addr);
 		return;
 	}
 
@@ -236,8 +282,11 @@ static void detect_newlink(unsigned short type, int index,
 	connman_device_set_index(device, index);
 	connman_device_set_interface(device, devname);
 
+	connman_device_set_string(device, "Address", addr);
+
 	g_free(devname);
 	g_free(name);
+	g_free(addr);
 
 	if (connman_device_register(device) < 0) {
 		connman_device_unref(device);

commit d477bab6c1ac495ece889897cb0e5524c8363968
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:14:31 2009 +0100

    Add proper comment to generated /etc/resolv.conf file

diff --git a/src/resolver.c b/src/resolver.c
index de60cf13..04853624 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -254,7 +254,10 @@ static int resolvfile_append(const char *interface, const char *domain,
 
 	err = ftruncate(fd, 0);
 
-	cmd = g_strdup_printf("nameserver %s\n", server);
+	cmd = g_strdup_printf("# Generated by Connection Manager\n"
+						"domain localdomain\n"
+						"search localdomain\n"
+						"nameserver %s\n", server);
 
 	len = write(fd, cmd, strlen(cmd));
 

commit 56e4ccc1297a9033779bb7a365ffc96a1c1d11fc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:19:44 2009 +0100

    Add skeleton for method to join networks

diff --git a/doc/device-api.txt b/doc/device-api.txt
index a45046d9..83d65311 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -22,6 +22,14 @@ Methods		dict GetProperties()
 			Possible Errors: [service].Error.InvalidArguments
 					 [service].Error.DoesNotExist
 
+		void JoinNetwork(dict network)
+
+			Join network specified by the given properties. The
+			properties for WiFi networks can be WiFi.SSID,
+			WiFi.Security and WiFi.Passphrase.
+
+			Possible Errors: [service].Error.InvalidArguments
+
 		object CreateNetwork(dict network)
 
 			Creates a network object from the specified
diff --git a/src/device.c b/src/device.c
index 54a74f19..d7106eaf 100644
--- a/src/device.c
+++ b/src/device.c
@@ -470,6 +470,18 @@ static DBusMessage *set_property(DBusConnection *conn,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static DBusMessage *join_network(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	DBG("conn %p", conn);
+
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
+		return __connman_error_permission_denied(msg);
+
+	return __connman_error_invalid_arguments(msg);
+}
+
 static DBusMessage *create_network(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -527,6 +539,7 @@ static DBusMessage *propose_scan(DBusConnection *conn,
 static GDBusMethodTable device_methods[] = {
 	{ "GetProperties", "",      "a{sv}", get_properties },
 	{ "SetProperty",   "sv",    "",      set_property   },
+	{ "JoinNetwork",   "a{sv}", "",      join_network   },
 	{ "CreateNetwork", "a{sv}", "o",     create_network },
 	{ "RemoveNetwork", "o",     "",      remove_network },
 	{ "ProposeScan",   "",      "",      propose_scan   },

commit a311eedd5818bfcc8c25bfc93912ef35d6b670f3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:20:48 2009 +0100

    Document the ProposeScan method

diff --git a/doc/device-api.txt b/doc/device-api.txt
index 83d65311..55625ccf 100644
--- a/doc/device-api.txt
+++ b/doc/device-api.txt
@@ -46,6 +46,12 @@ Methods		dict GetProperties()
 			Possible Errors: [service].Error.InvalidArguments
 					 [service].Error.DoesNotExist
 
+		void ProposeScan()
+
+			Proposes to trigger a scan transaction.
+
+			Possible Errors: [service].Error.InvalidArguments
+
 Signals		PropertyChanged(string name, variant value)
 
 			This signal indicates a changed value of the given

commit f4261c4f1c66526112b83f3ba777ce88c5dfe3e5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:22:14 2009 +0100

    Fix wrong error return value

diff --git a/src/resolver.c b/src/resolver.c
index 04853624..481369e2 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -250,7 +250,7 @@ static int resolvfile_append(const char *interface, const char *domain,
 	fd = open("/etc/resolv.conf", O_RDWR | O_CREAT,
 					S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 	if (fd < 0)
-		return errno;
+		return -errno;
 
 	err = ftruncate(fd, 0);
 

commit ea61bb44c4f6057a0002366838ee5550d07fa784
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:36:19 2009 +0100

    Add support for join device driver callback

diff --git a/include/device.h b/include/device.h
index e4a735f1..c0042a9e 100644
--- a/include/device.h
+++ b/include/device.h
@@ -122,6 +122,8 @@ struct connman_device_driver {
 	int (*enable) (struct connman_device *device);
 	int (*disable) (struct connman_device *device);
 	int (*scan) (struct connman_device *device);
+	int (*join) (struct connman_device *device,
+					struct connman_network *network);
 };
 
 extern int connman_device_driver_register(struct connman_device_driver *driver);
diff --git a/src/device.c b/src/device.c
index d7106eaf..ef2e2d3b 100644
--- a/src/device.c
+++ b/src/device.c
@@ -473,13 +473,55 @@ static DBusMessage *set_property(DBusConnection *conn,
 static DBusMessage *join_network(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_device *device = data;
+	struct connman_network *network;
+	DBusMessageIter iter, array;
+	int err;
+
 	DBG("conn %p", conn);
 
 	if (__connman_security_check_privilege(msg,
 					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
 		return __connman_error_permission_denied(msg);
 
-	return __connman_error_invalid_arguments(msg);
+	if (!device->driver || !device->driver->join)
+		return __connman_error_not_supported(msg);
+
+	dbus_message_iter_init(msg, &iter);
+	dbus_message_iter_recurse(&iter, &array);
+
+	network = connman_network_create("_", CONNMAN_NETWORK_TYPE_UNKNOWN);
+	if (network == NULL)
+		return __connman_error_failed(msg);
+
+	while (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_DICT_ENTRY) {
+		DBusMessageIter entry, value;
+		const char *key, *str;
+
+		dbus_message_iter_recurse(&iter, &entry);
+		dbus_message_iter_get_basic(&entry, &key);
+
+		dbus_message_iter_next(&entry);
+		dbus_message_iter_recurse(&entry, &value);
+
+		switch (dbus_message_iter_get_arg_type(&value)) {
+		case DBUS_TYPE_STRING:
+			dbus_message_iter_get_basic(&value, &str);
+			connman_network_set_string(network, key, str);
+			break;
+		}
+
+		dbus_message_iter_next(&iter);
+	}
+
+	err = device->driver->join(device, network);
+
+	connman_network_unref(network);
+
+	if (err < 0)
+		return __connman_error_failed(msg);
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
 static DBusMessage *create_network(DBusConnection *conn,

commit 934cf07c50b1129c1e2e6354b28ca4ecbf5440d9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:43:47 2009 +0100

    Add test script for joining hidden networks

diff --git a/test/Makefile.am b/test/Makefile.am
index d09108e5..2537323a 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -3,8 +3,8 @@ EXTRA_DIST = get-state list-profiles list-connections select-connection \
 		list-devices enable-device disable-device start-scanning \
 		list-networks select-network disable-network create-network \
 		set-passphrase set-address set-policy set-priority \
-		connect-network disconnect-network simple-agent \
-		show-introspection test-compat test-manager \
+		connect-network disconnect-network join-network \
+		simple-agent show-introspection test-compat test-manager \
 		test-connman monitor-connman debug-connman
 
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/test/join-network b/test/join-network
new file mode 100755
index 00000000..7ca4637b
--- /dev/null
+++ b/test/join-network
@@ -0,0 +1,29 @@
+#!/usr/bin/python
+
+import sys
+import dbus
+
+if (len(sys.argv) < 2):
+	print "Usage: %s <ssid>" % (sys.argv[0])
+	sys.exit(1)
+
+bus = dbus.SystemBus()
+
+manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+					"org.moblin.connman.Manager")
+
+properties = manager.GetProperties()
+
+for path in properties["Devices"]:
+	device = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Device")
+
+	properties = device.GetProperties()
+
+	if (properties["Type"] != "wifi"):
+		continue;
+
+	print "[ %s ]" % (path)
+	print "Attempting to join %s" % (sys.argv[1])
+
+	device.JoinNetwork({ "WiFi.SSID": sys.argv[1] })

commit baa04e5d3a57c03eb3c4ebfd7a17f1486cdca3ad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:46:19 2009 +0100

    Add skeleton for WiFi network joining callback

diff --git a/plugins/wifi.c b/plugins/wifi.c
index a86b00ee..7c30f071 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -133,6 +133,20 @@ static int wifi_scan(struct connman_device *device)
 	return supplicant_scan(device);
 }
 
+static int wifi_join(struct connman_device *device,
+					struct connman_network *network)
+{
+	const char *ssid;
+
+	DBG("device %p", device);
+
+	ssid = connman_network_get_string(network, "WiFi.SSID");
+
+	DBG("SSID %s", ssid);
+
+	return -EIO;
+}
+
 static struct connman_device_driver wifi_driver = {
 	.name		= "wifi",
 	.type		= CONNMAN_DEVICE_TYPE_WIFI,
@@ -141,6 +155,7 @@ static struct connman_device_driver wifi_driver = {
 	.enable		= wifi_enable,
 	.disable	= wifi_disable,
 	.scan		= wifi_scan,
+	.join		= wifi_join,
 };
 
 static void wifi_register(void)

commit dcd2e1b44d5c0ac94bbfe913bcd6f92a9855376b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:48:03 2009 +0100

    Include security setting for network selection

diff --git a/test/join-network b/test/join-network
index 7ca4637b..400f4978 100755
--- a/test/join-network
+++ b/test/join-network
@@ -26,4 +26,5 @@ for path in properties["Devices"]:
 	print "[ %s ]" % (path)
 	print "Attempting to join %s" % (sys.argv[1])
 
-	device.JoinNetwork({ "WiFi.SSID": sys.argv[1] })
+	device.JoinNetwork({ "WiFi.SSID": sys.argv[1],
+				"WiFi.Security": "none" })

commit 79399da515d6be3357ea3580a32a84ab0b66a442
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 13:50:39 2009 +0100

    Set device index for network to be joined

diff --git a/src/device.c b/src/device.c
index ef2e2d3b..3ae6a801 100644
--- a/src/device.c
+++ b/src/device.c
@@ -476,7 +476,7 @@ static DBusMessage *join_network(DBusConnection *conn,
 	struct connman_device *device = data;
 	struct connman_network *network;
 	DBusMessageIter iter, array;
-	int err;
+	int err, index;
 
 	DBG("conn %p", conn);
 
@@ -514,6 +514,9 @@ static DBusMessage *join_network(DBusConnection *conn,
 		dbus_message_iter_next(&iter);
 	}
 
+	index = connman_device_get_index(device);
+	connman_network_set_index(network, index);
+
 	err = device->driver->join(device, network);
 
 	connman_network_unref(network);

commit af9cf6a2b91284ef320b6bb1e0186067ec0370f1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 14:04:13 2009 +0100

    Create network with dummy identifier and correct type

diff --git a/src/device.c b/src/device.c
index 3ae6a801..ad55006d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -475,6 +475,7 @@ static DBusMessage *join_network(DBusConnection *conn,
 {
 	struct connman_device *device = data;
 	struct connman_network *network;
+	enum connman_network_type type;
 	DBusMessageIter iter, array;
 	int err, index;
 
@@ -490,7 +491,15 @@ static DBusMessage *join_network(DBusConnection *conn,
 	dbus_message_iter_init(msg, &iter);
 	dbus_message_iter_recurse(&iter, &array);
 
-	network = connman_network_create("_", CONNMAN_NETWORK_TYPE_UNKNOWN);
+	switch (device->type) {
+	case CONNMAN_DEVICE_TYPE_WIFI:
+		type = CONNMAN_NETWORK_TYPE_WIFI;
+		break;
+	default:
+		return __connman_error_not_supported(msg);
+	}
+
+	network = connman_network_create("00_00_00_00_00_00", type);
 	if (network == NULL)
 		return __connman_error_failed(msg);
 

commit 001e24d0172afe9b8601256795b2728d4a7278fb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 25 14:04:35 2009 +0100

    Trigger supplicant connection when joining hidden networks

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 7c30f071..07fd9283 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -137,6 +137,7 @@ static int wifi_join(struct connman_device *device,
 					struct connman_network *network)
 {
 	const char *ssid;
+	int err;
 
 	DBG("device %p", device);
 
@@ -144,7 +145,15 @@ static int wifi_join(struct connman_device *device,
 
 	DBG("SSID %s", ssid);
 
-	return -EIO;
+	err = supplicant_connect(network);
+	if (err < 0)
+		return err;
+
+	connman_network_ref(network);
+
+	connman_device_add_network(device, network);
+
+	return 0;
 }
 
 static struct connman_device_driver wifi_driver = {

commit 71dc77ea6ceaf3d486a2d16305243687f6cdac24
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 01:22:44 2009 -0700

    Fix network selection test scripts

diff --git a/test/connect-network b/test/connect-network
index 8f4f26bf..37cf60bd 100755
--- a/test/connect-network
+++ b/test/connect-network
@@ -22,7 +22,7 @@ for path in properties["Devices"]:
 
 	if properties["Type"] not in ["wifi", "wimax",
 					"bluetooth", "cellular"]:
-		continue;
+		continue
 
 	for path in properties["Networks"]:
 		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
@@ -32,6 +32,9 @@ for path in properties["Devices"]:
 
 		dev = path[path.rfind("/") + 1:]
 
+		if "Name" not in properties.keys():
+			continue
+
 		if dev == sys.argv[1] or properties["Name"] == sys.argv[1]:
 			print "Connecting %s" % (path)
 			network.Connect()
diff --git a/test/select-network b/test/select-network
index e7c19be3..376d9d2b 100755
--- a/test/select-network
+++ b/test/select-network
@@ -21,7 +21,7 @@ for path in properties["Devices"]:
 	properties = device.GetProperties()
 
 	if (properties["Type"] != "wifi" and properties["Type"] != "wimax"):
-		continue;
+		continue
 
 	print "[ %s ]" % (path)
 
@@ -31,7 +31,7 @@ for path in properties["Devices"]:
 
 		properties = network.GetProperties()
 
-		if "Name" not in properties.keys:
+		if "Name" not in properties.keys():
 			continue
 
 		if (properties["Connected"] == dbus.Boolean(1)):

commit 35687e51f6bb14417777def599ba4f6cb65876de
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 01:29:22 2009 -0700

    Extend script for joining network with security options

diff --git a/test/join-network b/test/join-network
index 400f4978..576c6026 100755
--- a/test/join-network
+++ b/test/join-network
@@ -4,7 +4,7 @@ import sys
 import dbus
 
 if (len(sys.argv) < 2):
-	print "Usage: %s <ssid>" % (sys.argv[0])
+	print "Usage: %s <ssid> [passphrase] [security]" % (sys.argv[0])
 	sys.exit(1)
 
 bus = dbus.SystemBus()
@@ -26,5 +26,16 @@ for path in properties["Devices"]:
 	print "[ %s ]" % (path)
 	print "Attempting to join %s" % (sys.argv[1])
 
+	if len(sys.argv) > 2:
+		if len(sys.argv) > 3:
+			security = sys.argv[3]
+		else:
+			security = "wpa2"
+		passphrase = sys.argv[2]
+	else:
+		security = "none"
+		passphrase = ""
+
 	device.JoinNetwork({ "WiFi.SSID": sys.argv[1],
-				"WiFi.Security": "none" })
+					"WiFi.Security": security,
+					"WiFi.Passphrase": passphrase })

commit 3d671c662c9538607bcca2471df781a15bfeece7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 01:53:48 2009 -0700

    Add setting for the network mode

diff --git a/test/join-network b/test/join-network
index 576c6026..41cb492e 100755
--- a/test/join-network
+++ b/test/join-network
@@ -36,6 +36,7 @@ for path in properties["Devices"]:
 		security = "none"
 		passphrase = ""
 
-	device.JoinNetwork({ "WiFi.SSID": sys.argv[1],
+	device.JoinNetwork({ "WiFi.Mode": "managed",
+					"WiFi.SSID": sys.argv[1],
 					"WiFi.Security": security,
 					"WiFi.Passphrase": passphrase })

commit b42be8dc03e89c626cd5f91222808a7e5a142ca4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 01:54:58 2009 -0700

    Fix parsing of network dictionary

diff --git a/src/device.c b/src/device.c
index ad55006d..ccfa5924 100644
--- a/src/device.c
+++ b/src/device.c
@@ -503,11 +503,11 @@ static DBusMessage *join_network(DBusConnection *conn,
 	if (network == NULL)
 		return __connman_error_failed(msg);
 
-	while (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_DICT_ENTRY) {
+	while (dbus_message_iter_get_arg_type(&array) == DBUS_TYPE_DICT_ENTRY) {
 		DBusMessageIter entry, value;
 		const char *key, *str;
 
-		dbus_message_iter_recurse(&iter, &entry);
+		dbus_message_iter_recurse(&array, &entry);
 		dbus_message_iter_get_basic(&entry, &key);
 
 		dbus_message_iter_next(&entry);
@@ -516,16 +516,22 @@ static DBusMessage *join_network(DBusConnection *conn,
 		switch (dbus_message_iter_get_arg_type(&value)) {
 		case DBUS_TYPE_STRING:
 			dbus_message_iter_get_basic(&value, &str);
-			connman_network_set_string(network, key, str);
+			if (g_str_equal(key, "WiFi.SSID") == TRUE)
+				connman_network_set_blob(network, key,
+							str, strlen(str));
+			else
+				connman_network_set_string(network, key, str);
 			break;
 		}
 
-		dbus_message_iter_next(&iter);
+		dbus_message_iter_next(&array);
 	}
 
 	index = connman_device_get_index(device);
 	connman_network_set_index(network, index);
 
+	connman_network_set_available(network, TRUE);
+
 	err = device->driver->join(device, network);
 
 	connman_network_unref(network);

commit 08a8b7f6a025291e0641232d1e6a219b635500a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 01:55:29 2009 -0700

    Remove SSID debug statement

diff --git a/plugins/wifi.c b/plugins/wifi.c
index 07fd9283..ab5765e5 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -136,15 +136,10 @@ static int wifi_scan(struct connman_device *device)
 static int wifi_join(struct connman_device *device,
 					struct connman_network *network)
 {
-	const char *ssid;
 	int err;
 
 	DBG("device %p", device);
 
-	ssid = connman_network_get_string(network, "WiFi.SSID");
-
-	DBG("SSID %s", ssid);
-
 	err = supplicant_connect(network);
 	if (err < 0)
 		return err;

commit 3d5435d54aeffb22ffa27bfd2bd4ee78b237d65e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 01:59:15 2009 -0700

    Fix handling of missing name property

diff --git a/test/disconnect-network b/test/disconnect-network
index 8529c19c..3bb235af 100755
--- a/test/disconnect-network
+++ b/test/disconnect-network
@@ -22,7 +22,7 @@ for path in properties["Devices"]:
 
 	if properties["Type"] not in ["wifi", "wimax",
 					"bluetooth", "cellular"]:
-		continue;
+		continue
 
 	for path in properties["Networks"]:
 		network = dbus.Interface(bus.get_object("org.moblin.connman", path),
@@ -32,6 +32,9 @@ for path in properties["Devices"]:
 
 		dev = path[path.rfind("/") + 1:]
 
+		if "Name" not in properties.keys():
+			continue
+
 		if dev == sys.argv[1] or properties["Name"] == sys.argv[1]:
 			print "Disconnecting %s" % (path)
 			network.Disconnect()

commit c6ad3d59d894b089f122e6f22f320e05c78cc97c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 02:24:16 2009 -0700

    Check result before overwriting WiFi.Security and WiFi.Passphrase

diff --git a/src/device.c b/src/device.c
index ccfa5924..e7c4b677 100644
--- a/src/device.c
+++ b/src/device.c
@@ -530,7 +530,7 @@ static DBusMessage *join_network(DBusConnection *conn,
 	index = connman_device_get_index(device);
 	connman_network_set_index(network, index);
 
-	connman_network_set_available(network, TRUE);
+	connman_network_set_protocol(network, CONNMAN_NETWORK_PROTOCOL_IP);
 
 	err = device->driver->join(device, network);
 
diff --git a/src/network.c b/src/network.c
index e408e1d8..c2e79d7d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1144,6 +1144,7 @@ static int network_load(struct connman_network *network)
 	gchar *pathname, *data = NULL;
 	gsize length;
 	const char *name;
+	char *str;
 	int val;
 
 	DBG("network %p", network);
@@ -1181,13 +1182,19 @@ static int network_load(struct connman_network *network)
 	if (val > 0)
 		network->priority = val;
 
-	g_free(network->wifi.security);
-	network->wifi.security = g_key_file_get_string(keyfile,
+	str = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Security", NULL);
+	if (str != NULL) {
+		g_free(network->wifi.security);
+		network->wifi.security = str;
+	}
 
-	g_free(network->wifi.passphrase);
-	network->wifi.passphrase = g_key_file_get_string(keyfile,
+	str = g_key_file_get_string(keyfile,
 				network->identifier, "WiFi.Passphrase", NULL);
+	if (str != NULL) {
+		g_free(network->wifi.passphrase);
+		network->wifi.passphrase = str;
+	}
 
 	g_key_file_free(keyfile);
 

commit 6807913ff2db5e688eb27f8c7bb7ee5534f959de
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 02:25:09 2009 -0700

    Set AP scanning and make network available

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 47b75280..66398673 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -661,6 +661,7 @@ static int set_network(struct supplicant_task *task,
 	DBusMessage *message, *reply;
 	DBusMessageIter array, dict;
 	DBusError error;
+	const char *scan = "1";
 
 	DBG("task %p", task);
 
@@ -679,6 +680,9 @@ static int set_network(struct supplicant_task *task,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	connman_dbus_dict_append_variant(&dict, "scan_ssid",
+						DBUS_TYPE_STRING, &scan);
+
 	connman_dbus_dict_append_array(&dict, "ssid",
 					DBUS_TYPE_BYTE, &network, len);
 
diff --git a/plugins/wifi.c b/plugins/wifi.c
index ab5765e5..21b92082 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -148,6 +148,8 @@ static int wifi_join(struct connman_device *device,
 
 	connman_device_add_network(device, network);
 
+	connman_network_set_available(network, TRUE);
+
 	return 0;
 }
 

commit 3e3cba11f4644348cbcf87dc66d8bffbffc07d5a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 02:38:55 2009 -0700

    Use BSSID for network connection if possible

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 66398673..bc75f6cf 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -656,12 +656,12 @@ static int disable_network(struct supplicant_task *task)
 
 static int set_network(struct supplicant_task *task,
 				const unsigned char *network, int len,
-				const char *security, const char *passphrase)
+				const char *address, const char *security,
+							const char *passphrase)
 {
 	DBusMessage *message, *reply;
 	DBusMessageIter array, dict;
 	DBusError error;
-	const char *scan = "1";
 
 	DBG("task %p", task);
 
@@ -680,11 +680,19 @@ static int set_network(struct supplicant_task *task,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	connman_dbus_dict_append_variant(&dict, "scan_ssid",
+	if (len > 0 && address == NULL) {
+		const char *scan = "1";
+
+		connman_dbus_dict_append_variant(&dict, "scan_ssid",
 						DBUS_TYPE_STRING, &scan);
 
-	connman_dbus_dict_append_array(&dict, "ssid",
+		connman_dbus_dict_append_array(&dict, "ssid",
 					DBUS_TYPE_BYTE, &network, len);
+	}
+
+	if (address != NULL)
+		connman_dbus_dict_append_variant(&dict, "bssid",
+						DBUS_TYPE_STRING, &address);
 
 	if (g_ascii_strcasecmp(security, "wpa") == 0 ||
 				g_ascii_strcasecmp(security, "wpa2") == 0) {
@@ -1385,19 +1393,21 @@ int supplicant_scan(struct connman_device *device)
 int supplicant_connect(struct connman_network *network)
 {
 	struct supplicant_task *task;
-	const char *security, *passphrase;
+	const char *address, *security, *passphrase;
 	const void *ssid;
 	unsigned int ssid_len;
 	int index;
 
 	DBG("network %p", network);
 
+	address = connman_network_get_string(network, "Address");
 	security = connman_network_get_string(network, "WiFi.Security");
 	passphrase = connman_network_get_string(network, "WiFi.Passphrase");
 
 	ssid = connman_network_get_blob(network, "WiFi.SSID", &ssid_len);
 
-	DBG("security %s passphrase %s", security, passphrase);
+	DBG("address %s security %s passphrase %s",
+					address, security, passphrase);
 
 	if (security == NULL && passphrase == NULL)
 		return -EINVAL;
@@ -1418,7 +1428,7 @@ int supplicant_connect(struct connman_network *network)
 	select_network(task);
 	disable_network(task);
 
-	set_network(task, ssid, ssid_len, security, passphrase);
+	set_network(task, ssid, ssid_len, address, security, passphrase);
 
 	enable_network(task);
 

commit 8cba7d766c9c081091975595575ada98e34ad218
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 02:51:00 2009 -0700

    Set SSID and BSSID if both information are available

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index bc75f6cf..f78a3f5f 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -680,11 +680,12 @@ static int set_network(struct supplicant_task *task,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	if (len > 0 && address == NULL) {
-		const char *scan = "1";
-
-		connman_dbus_dict_append_variant(&dict, "scan_ssid",
+	if (len > 0) {
+		if (address == NULL) {
+			const char *scan = "1";
+			connman_dbus_dict_append_variant(&dict, "scan_ssid",
 						DBUS_TYPE_STRING, &scan);
+		}
 
 		connman_dbus_dict_append_array(&dict, "ssid",
 					DBUS_TYPE_BYTE, &network, len);

commit a2de68d751417d75fb30ea071314800e33952fab
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 03:01:28 2009 -0700

    Release 0.14

diff --git a/ChangeLog b/ChangeLog
index cc58a65b..b25eae1a 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+ver 0.14:
+	Add support for detecting DHCP failures.
+	Add support for joining hidden WiFi networks.
+	Add support for device and network address property.
+	Add support for default /etc/resolv.conf generation.
+	Fix issue with wrong address setting for loopback.
+	Fix detection of WiFi access point changes.
+	Fix crash with blob properties.
+
 ver 0.13:
 	Add support for notification infrastructure.
 	Add fully dynamic property storage capabilities.
diff --git a/configure.ac b/configure.ac
index c8274ead..42f928e2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.13)
+AM_INIT_AUTOMAKE(connman, 0.14)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 1c0828a97c2ca670cf2014d1f8491d644b97ce04
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 14:25:19 2009 -0700

    Fix setting of scan_ssid for hidden networks

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index f78a3f5f..d5b4c344 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -682,9 +682,9 @@ static int set_network(struct supplicant_task *task,
 
 	if (len > 0) {
 		if (address == NULL) {
-			const char *scan = "1";
+			dbus_uint32_t scan_ssid = 1;
 			connman_dbus_dict_append_variant(&dict, "scan_ssid",
-						DBUS_TYPE_STRING, &scan);
+						DBUS_TYPE_UINT32, &scan_ssid);
 		}
 
 		connman_dbus_dict_append_array(&dict, "ssid",

commit c4804168a76c5f81241b0b58e2c498b6a5a0cb21
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 14:34:25 2009 -0700

    Only add network name if it is actually present

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index d5b4c344..b2763fe8 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1038,7 +1038,8 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 		}
 	}
 
-	connman_network_set_string(network, "Name", result.name);
+	if (result.name != NULL && result.name[0] != '\0')
+		connman_network_set_string(network, "Name", result.name);
 
 	connman_network_set_blob(network, "WiFi.SSID",
 						result.ssid, result.ssid_len);

commit df13a0c65a8893f443d3684177ad8e8e5e73c190
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 16:53:30 2009 -0700

    Always add SSID value to network configuration

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index b2763fe8..4b587b8f 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -680,21 +680,17 @@ static int set_network(struct supplicant_task *task,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	if (len > 0) {
-		if (address == NULL) {
-			dbus_uint32_t scan_ssid = 1;
-			connman_dbus_dict_append_variant(&dict, "scan_ssid",
+	if (address == NULL) {
+		dbus_uint32_t scan_ssid = 1;
+		connman_dbus_dict_append_variant(&dict, "scan_ssid",
 						DBUS_TYPE_UINT32, &scan_ssid);
-		}
-
-		connman_dbus_dict_append_array(&dict, "ssid",
-					DBUS_TYPE_BYTE, &network, len);
-	}
-
-	if (address != NULL)
+	} else
 		connman_dbus_dict_append_variant(&dict, "bssid",
 						DBUS_TYPE_STRING, &address);
 
+	connman_dbus_dict_append_array(&dict, "ssid",
+					DBUS_TYPE_BYTE, &network, len);
+
 	if (g_ascii_strcasecmp(security, "wpa") == 0 ||
 				g_ascii_strcasecmp(security, "wpa2") == 0) {
 		const char *key_mgmt = "WPA-PSK";

commit bcb6370dc73d25c43692691c42bfd8d12e72074d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 17:24:07 2009 -0700

    Ignore VMware network devices

diff --git a/src/detect.c b/src/detect.c
index 1415638b..3a97816c 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -207,6 +207,8 @@ static void detect_newlink(unsigned short type, int index,
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (g_str_has_prefix(devname, "wmx") == TRUE)
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+		else if (g_str_has_prefix(devname, "vmnet") == TRUE)
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))

commit 3110ed4bdc1621b6b8c801cafcfbe61bf1d37548
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 17:33:12 2009 -0700

    Release 0.15

diff --git a/ChangeLog b/ChangeLog
index b25eae1a..7916015e 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,8 @@
+ver 0.15:
+	Detect VMware network interface and ignore them.
+	Fix setting of scan_ssid for hidden networks.
+	Fix empty network name property.
+
 ver 0.14:
 	Add support for detecting DHCP failures.
 	Add support for joining hidden WiFi networks.
diff --git a/configure.ac b/configure.ac
index 42f928e2..69f028a1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.14)
+AM_INIT_AUTOMAKE(connman, 0.15)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit af6de21147d970e9d34fd1e4176bee96e7b1c6b4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Mar 26 09:10:17 2009 +0100

    Ignore VirtualBox network devices

diff --git a/src/detect.c b/src/detect.c
index 3a97816c..b0963182 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -209,6 +209,8 @@ static void detect_newlink(unsigned short type, int index,
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (g_str_has_prefix(devname, "vmnet") == TRUE)
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
+		else if (g_str_has_prefix(devname, "vboxnet") == TRUE)
+			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))

commit 7a75d5e493c11078b4047b8886e26674222ab810
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 28 14:01:41 2009 -0700

    Add skeleton for testing tools directory

diff --git a/Makefile.am b/Makefile.am
index 8651e978..a949a551 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = gdbus include src plugins client scripts test doc
+SUBDIRS = gdbus include src plugins client tools scripts test doc
 
 pkgconfigdir = $(libdir)/pkgconfig
 
diff --git a/bootstrap-configure b/bootstrap-configure
index 265d8815..ac7d8bd1 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -33,4 +33,5 @@ fi
 		--enable-iospm \
 		--enable-iwmxsdk \
 		--enable-polkit \
-		--enable-client $*
+		--enable-client \
+		--enable-tools $*
diff --git a/configure.ac b/configure.ac
index 69f028a1..16025ac6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -235,6 +235,16 @@ AC_ARG_ENABLE(client, AC_HELP_STRING([--enable-client],
 		[enable command line client]), [enable_client=${enableval}])
 AM_CONDITIONAL(CLIENT, test "${enable_client}" = "yes")
 
+AC_ARG_ENABLE(tools, AC_HELP_STRING([--enable-tools],
+                [enable testing tools]), [enable_tools=${enableval}])
+if (test "${enable_tools}" = "yes"); then
+	PKG_CHECK_MODULES(NETLINK, libnl-1, enable_netlink=yes,
+				AC_MSG_ERROR(Netlink library is required))
+	AC_SUBST(NETLINK_CFLAGS)
+	AC_SUBST(NETLINK_LIBS)
+fi
+AM_CONDITIONAL(TOOLS, test "${enable_tools}" = "yes")
+
 AC_ARG_ENABLE(fake, AC_HELP_STRING([--enable-fake],
 		[enable fake device support]), [enable_fake=${enableval}])
 AM_CONDITIONAL(FAKE, test "${enable_fake}" = "yes")
@@ -247,6 +257,8 @@ AM_CONDITIONAL(DATAFILES, test "${enable_datafiles}" != "no")
 SHAVE_INIT
 
 AC_OUTPUT(Makefile gdbus/Makefile include/Makefile include/version.h
-		src/Makefile src/connman.service scripts/connman
-		scripts/Makefile plugins/Makefile client/Makefile
-		test/Makefile doc/Makefile doc/version.xml connman.pc)
+				src/Makefile src/connman.service
+				scripts/connman scripts/Makefile
+				plugins/Makefile client/Makefile
+				tools/Makefile test/Makefile
+				doc/Makefile doc/version.xml connman.pc)
diff --git a/tools/Makefile.am b/tools/Makefile.am
new file mode 100644
index 00000000..02742923
--- /dev/null
+++ b/tools/Makefile.am
@@ -0,0 +1,2 @@
+
+MAINTAINERCLEANFILES = Makefile.in

commit a822c8d387cea4b6d8bc51d227a8b7853cc2b617
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 28 14:07:45 2009 -0700

    Add skeleton for WiFi scanning tool

diff --git a/.gitignore b/.gitignore
index bdea2a85..6aa6a4e7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -37,6 +37,7 @@ scripts/connman
 scripts/udhcpc-script
 scripts/dhclient-script
 client/cm
+tools/wifi-scan
 doc/*.bak
 doc/*.stamp
 doc/connman.*
diff --git a/Makefile.am b/Makefile.am
index a949a551..b4c0917d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -18,7 +18,8 @@ DISTCHECK_CONFIGURE_FLAGS = --disable-gtk-doc \
 				--enable-novatel \
 				--enable-huawei \
 				--enable-hso \
-				--enable-client
+				--enable-client \
+				--enable-tools
 
 DISTCLEANFILES = $(pkgconfig_DATA)
 
diff --git a/tools/Makefile.am b/tools/Makefile.am
index 02742923..af219aca 100644
--- a/tools/Makefile.am
+++ b/tools/Makefile.am
@@ -1,2 +1,10 @@
 
+if TOOLS
+noinst_PROGRAMS = wifi-scan
+
+wifi_scan_LDADD = @GLIB_LIBS@ @NETLINK_LIBS@
+endif
+
+AM_CFLAGS = @NETLINK_CFLAGS@ @GLIB_CFLAGS@
+
 MAINTAINERCLEANFILES = Makefile.in
diff --git a/tools/wifi-scan.c b/tools/wifi-scan.c
new file mode 100644
index 00000000..6f110c17
--- /dev/null
+++ b/tools/wifi-scan.c
@@ -0,0 +1,29 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+int main(int argc, char *argv[])
+{
+	return 0;
+}

commit 1f51bad6c5ad8510a9012299f87a7d3f31054c80
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 18:07:13 2009 -0700

    Add function for setting network group name

diff --git a/include/network.h b/include/network.h
index 78e5c0e4..3e765d08 100644
--- a/include/network.h
+++ b/include/network.h
@@ -67,6 +67,8 @@ extern int connman_network_get_index(struct connman_network *network);
 
 extern void connman_network_set_protocol(struct connman_network *network,
 					enum connman_network_protocol protocol);
+extern void connman_network_set_group(struct connman_network *network,
+							const char *group);
 
 extern int connman_network_set_available(struct connman_network *network,
 						connman_bool_t available);
diff --git a/src/network.c b/src/network.c
index c2e79d7d..a83b921d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -42,6 +42,7 @@ struct connman_network {
 	char *address;
 	char *name;
 	char *node;
+	char *group;
 
 	struct connman_network_driver *driver;
 	void *driver_data;
@@ -433,6 +434,7 @@ static void network_destruct(struct connman_element *element)
 	g_free(network->wifi.security);
 	g_free(network->wifi.passphrase);
 
+	g_free(network->group);
 	g_free(network->node);
 	g_free(network->name);
 	g_free(network->address);
@@ -580,6 +582,20 @@ void connman_network_set_protocol(struct connman_network *network,
 	network->protocol = protocol;
 }
 
+/**
+ * connman_network_set_group:
+ * @network: network structure
+ * @group: group name
+ *
+ * Set group name for automatic clustering
+ */
+void connman_network_set_group(struct connman_network *network,
+							const char *group)
+{
+	g_free(network->group);
+	network->group = g_strdup(group);
+}
+
 /**
  * connman_network_set_available:
  * @network: network structure

commit 17112569b2227e443126d34dfac86e40c648ecab
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 18:33:09 2009 -0700

    Add helper function to encode D-Bus object paths

diff --git a/include/dbus.h b/include/dbus.h
index 77766c72..277e69a8 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -52,6 +52,8 @@ extern void connman_dbus_dict_append_array(DBusMessageIter *dict,
 extern void connman_dbus_dict_append_variant(DBusMessageIter *dict,
 					const char *key, int type, void *val);
 
+extern char *connman_dbus_encode_string(const char *value);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/dbus.c b/src/dbus.c
index 062cc7ab..daa2239c 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -23,8 +23,36 @@
 #include <config.h>
 #endif
 
+#include <string.h>
+
 #include "connman.h"
 
+char *connman_dbus_encode_string(const char *value)
+{
+	GString *str;
+	unsigned int i, size;
+
+	if (value == NULL)
+		return NULL;
+
+	size = strlen(value);
+
+	str = g_string_new(NULL);
+	if (str == NULL)
+		return NULL;
+
+	for (i = 0; i < size; i++) {
+		const char tmp = value[i];
+		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
+						(tmp < 'a' || tmp > 'z'))
+			g_string_append_printf(str, "_%02x", tmp);
+		else
+			str = g_string_append_c(str, tmp);
+	}
+
+	return g_string_free(str, FALSE);
+}
+
 void connman_dbus_property_append_variant(DBusMessageIter *iter,
 					const char *key, int type, void *val)
 {

commit a0f99ce23943d691636a6a27d647ca42a85fcd24
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 18:35:37 2009 -0700

    Use common helper to encode object name

diff --git a/src/network.c b/src/network.c
index a83b921d..754380d4 100644
--- a/src/network.c
+++ b/src/network.c
@@ -456,7 +456,6 @@ struct connman_network *connman_network_create(const char *identifier,
 	connman_uint8_t strength = 0;
 	const char *str;
 	char *temp;
-	unsigned int i;
 
 	DBG("identifier %s type %d", identifier, type);
 
@@ -468,19 +467,12 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	__connman_element_initialize(&network->element);
 
-	temp = g_strdup(identifier);
+	temp = connman_dbus_encode_string(identifier);
 	if (temp == NULL) {
 		g_free(network);
 		return NULL;
 	}
 
-	for (i = 0; i < strlen(temp); i++) {
-		char tmp = temp[i];
-		if ((tmp < '0' || tmp > '9') && (tmp < 'A' || tmp > 'Z') &&
-						(tmp < 'a' || tmp > 'z'))
-			temp[i] = '_';
-	}
-
 	network->element.name = temp;
 	network->element.type = CONNMAN_ELEMENT_TYPE_NETWORK;
 

commit dea4825d7f5677ea92163f31a5fb38238a520772
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 18:51:21 2009 -0700

    Set an unqiue group name based on SSID, mode and security details

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 4b587b8f..2009f7a0 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -783,6 +783,29 @@ static int initiate_scan(struct supplicant_task *task)
 	return 0;
 }
 
+static char *build_group(const unsigned char *ssid, unsigned int ssid_len,
+					const char *mode, const char *security)
+{
+	GString *str;
+	unsigned int i;
+
+	if (ssid_len < 1)
+		return NULL;
+
+	str = g_string_sized_new((ssid_len * 2) + 24);
+	if (str == NULL)
+		return NULL;
+
+	g_string_append_printf(str, "wifi_");
+
+	for (i = 0; i < ssid_len; i++)
+		g_string_append_printf(str, "%02x", ssid[i]);
+
+	g_string_append_printf(str, "_%s_%s", mode, security);
+
+	return g_string_free(str, FALSE);
+}
+
 static void extract_addr(DBusMessageIter *value,
 					struct supplicant_result *result)
 {
@@ -919,8 +942,9 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	struct connman_network *network;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
-	const char *mode, *security;
 	unsigned char strength;
+	const char *mode, *security;
+	char *group;
 
 	DBG("task %p", task);
 
@@ -1043,6 +1067,10 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
 	connman_network_set_string(network, "WiFi.Mode", mode);
 
+	group = build_group(result.ssid, result.ssid_len, mode, security);
+	connman_network_set_group(network, group);
+	g_free(group);
+
 	DBG("%s (%s %s) strength %d (%s)",
 			result.name, mode, security, strength,
 			(result.has_wps == TRUE) ? "WPS" : "no WPS");

commit b61dbfeba412dec291953724a92c6306f197643e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 19:30:28 2009 -0700

    Add basic automatic clustering support for networks

diff --git a/src/connman.h b/src/connman.h
index 128c084c..add13ae6 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -196,6 +196,8 @@ int __connman_network_disconnect(struct connman_network *network);
 
 connman_bool_t __connman_network_has_driver(struct connman_network *network);
 
+const char *__connman_network_get_group(struct connman_network *network);
+
 int __connman_profile_add_network(struct connman_network *network);
 int __connman_profile_remove_network(struct connman_network *network);
 
diff --git a/src/network.c b/src/network.c
index 754380d4..94e90ee1 100644
--- a/src/network.c
+++ b/src/network.c
@@ -588,6 +588,11 @@ void connman_network_set_group(struct connman_network *network,
 	network->group = g_strdup(group);
 }
 
+const char *__connman_network_get_group(struct connman_network *network)
+{
+	return network->group;
+}
+
 /**
  * connman_network_set_available:
  * @network: network structure
diff --git a/src/profile.c b/src/profile.c
index d1aea70c..43005206 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -28,31 +28,109 @@
 
 #include "connman.h"
 
+#define PROFILE_DEFAULT  "/profile/default"
+
+struct connman_group {
+	char *path;
+	GSList *networks;
+};
+
+static GHashTable *groups = NULL;
+
+static void free_group(gpointer data)
+{
+	struct connman_group *group = data;
+
+	DBG("group %p", group);
+
+	g_free(group->path);
+	g_free(group);
+}
+
+static struct connman_group *lookup_group(const char *name)
+{
+	struct connman_group *group;
+
+	DBG("name %s", name);
+
+	if (name == NULL)
+		return NULL;
+
+	group = g_hash_table_lookup(groups, name);
+	if (group != NULL)
+		goto done;
+
+	group = g_try_new0(struct connman_group, 1);
+	if (group == NULL)
+		return NULL;
+
+	group->path = g_strdup_printf("%s/%s", PROFILE_DEFAULT, name);
+
+	g_hash_table_insert(groups, g_strdup(name), group);
+
+done:
+	DBG("group %p", group);
+
+	return group;
+}
+
 int __connman_profile_add_device(struct connman_device *device)
 {
+	struct connman_group *group;
+	char *name;
+
 	DBG("device %p", device);
 
+	name = g_strdup_printf("device%d", connman_device_get_index(device));
+	group = lookup_group(name);
+	g_free(name);
+
+	if (group == NULL)
+		return -EINVAL;
+
 	return 0;
 }
 
 int __connman_profile_remove_device(struct connman_device *device)
 {
+	struct connman_group *group;
+	char *name;
+
 	DBG("device %p", device);
 
+	name = g_strdup_printf("device%d", connman_device_get_index(device));
+	group = lookup_group(name);
+	g_free(name);
+
+	if (group == NULL)
+		return -EINVAL;
+
 	return 0;
 }
 
 int __connman_profile_add_network(struct connman_network *network)
 {
+	struct connman_group *group;
+
 	DBG("network %p", network);
 
+	group = lookup_group(__connman_network_get_group(network));
+	if (group == NULL)
+		return -EINVAL;
+
 	return 0;
 }
 
 int __connman_profile_remove_network(struct connman_network *network)
 {
+	struct connman_group *group;
+
 	DBG("network %p", network);
 
+	group = lookup_group(__connman_network_get_group(network));
+	if (group == NULL)
+		return -EINVAL;
+
 	return 0;
 }
 
@@ -60,7 +138,7 @@ const char *__connman_profile_active(void)
 {
 	DBG("");
 
-	return "/profile/default";
+	return PROFILE_DEFAULT;
 }
 
 void __connman_profile_list(DBusMessageIter *iter)
@@ -72,9 +150,44 @@ void __connman_profile_list(DBusMessageIter *iter)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
+static void append_path(gpointer key, gpointer value, gpointer user_data)
+{
+	struct connman_group *group = value;
+	DBusMessageIter *iter = user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+							&group->path);
+}
+
 void __connman_profile_list_services(DBusMessageIter *iter)
 {
 	DBG("");
+
+	g_hash_table_foreach(groups, append_path, iter);
+}
+
+static void append_services(DBusMessageIter *dict)
+{
+	DBusMessageIter entry, value, iter;
+	const char *key = "Services";
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	__connman_profile_list_services(&iter);
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(&entry, &value);
+
+	dbus_message_iter_close_container(dict, &entry);
 }
 
 static DBusMessage *get_properties(DBusConnection *conn,
@@ -100,6 +213,8 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Name",
 						DBUS_TYPE_STRING, &name);
 
+	append_services(&dict);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -120,7 +235,10 @@ int __connman_profile_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -1;
 
-	g_dbus_register_interface(connection, "/profile/default",
+	groups = g_hash_table_new_full(g_str_hash, g_str_equal,
+							g_free, free_group);
+
+	g_dbus_register_interface(connection, PROFILE_DEFAULT,
 						CONNMAN_PROFILE_INTERFACE,
 						profile_methods,
 						NULL, NULL, NULL, NULL);
@@ -132,9 +250,12 @@ void __connman_profile_cleanup(void)
 {
 	DBG("conn %p", connection);
 
-	g_dbus_unregister_interface(connection, "/profile/default",
+	g_dbus_unregister_interface(connection, PROFILE_DEFAULT,
 						CONNMAN_PROFILE_INTERFACE);
 
+	g_hash_table_destroy(groups);
+	groups = NULL;
+
 	if (connection == NULL)
 		return;
 

commit ff790513bda739d0fd5eee6c372cecd176c3f207
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:04:16 2009 -0700

    Add function to retrieve string represenation for device type

diff --git a/src/connman.h b/src/connman.h
index add13ae6..ccfdcbd9 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -179,6 +179,8 @@ void __connman_device_disconnect(struct connman_device *device);
 
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
+const char *__connman_device_get_type(struct connman_device *device);
+
 int __connman_device_set_offlinemode(connman_bool_t offlinemode);
 
 int __connman_profile_add_device(struct connman_device *device);
diff --git a/src/device.c b/src/device.c
index e7c4b677..e8d46e98 100644
--- a/src/device.c
+++ b/src/device.c
@@ -996,6 +996,11 @@ void connman_device_unref(struct connman_device *device)
 	connman_element_unref(&device->element);
 }
 
+const char *__connman_device_get_type(struct connman_device *device)
+{
+	return type2string(device->type);
+}
+
 /**
  * connman_device_get_name:
  * @device: device structure

commit e66089af7b7aa73721f992407880819394b8765f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:07:18 2009 -0700

    Add function to retrieve string represenation for network type

diff --git a/src/connman.h b/src/connman.h
index ccfdcbd9..1ee54475 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -198,6 +198,7 @@ int __connman_network_disconnect(struct connman_network *network);
 
 connman_bool_t __connman_network_has_driver(struct connman_network *network);
 
+const char *__connman_network_get_type(struct connman_network *network);
 const char *__connman_network_get_group(struct connman_network *network);
 
 int __connman_profile_add_network(struct connman_network *network);
diff --git a/src/network.c b/src/network.c
index 94e90ee1..d17cffd5 100644
--- a/src/network.c
+++ b/src/network.c
@@ -516,6 +516,11 @@ void connman_network_unref(struct connman_network *network)
 	connman_element_unref(&network->element);
 }
 
+const char *__connman_network_get_type(struct connman_network *network)
+{
+	return type2string(network->type);
+}
+
 /**
  * connman_network_get_identifier:
  * @network: network structure

commit b6f52b052e6bf83a520cb0241e61bc894653b79f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:09:19 2009 -0700

    Add initial support for service properties

diff --git a/include/dbus.h b/include/dbus.h
index 277e69a8..4007a14d 100644
--- a/include/dbus.h
+++ b/include/dbus.h
@@ -38,6 +38,7 @@ extern "C" {
 #define CONNMAN_MANAGER_PATH		"/"
 
 #define CONNMAN_PROFILE_INTERFACE	CONNMAN_SERVICE ".Profile"
+#define CONNMAN_SERVICE_INTERFACE	CONNMAN_SERVICE ".Service"
 #define CONNMAN_DEVICE_INTERFACE	CONNMAN_SERVICE ".Device"
 #define CONNMAN_NETWORK_INTERFACE	CONNMAN_SERVICE ".Network"
 #define CONNMAN_CONNECTION_INTERFACE	CONNMAN_SERVICE ".Connection"
diff --git a/src/profile.c b/src/profile.c
index 43005206..5115aad9 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -31,18 +31,59 @@
 #define PROFILE_DEFAULT  "/profile/default"
 
 struct connman_group {
+	char *type;
 	char *path;
 	GSList *networks;
 };
 
 static GHashTable *groups = NULL;
 
+static DBusConnection *connection = NULL;
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_group *group = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	if (group->type != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+					DBUS_TYPE_STRING, &group->type);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static GDBusMethodTable service_methods[] = {
+	{ "GetProperties", "", "a{sv}", get_properties },
+	{ },
+};
+
 static void free_group(gpointer data)
 {
 	struct connman_group *group = data;
 
 	DBG("group %p", group);
 
+	g_dbus_unregister_interface(connection, group->path,
+						CONNMAN_SERVICE_INTERFACE);
+
+	g_free(group->type);
 	g_free(group->path);
 	g_free(group);
 }
@@ -64,10 +105,16 @@ static struct connman_group *lookup_group(const char *name)
 	if (group == NULL)
 		return NULL;
 
+	group->type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	group->path = g_strdup_printf("%s/%s", PROFILE_DEFAULT, name);
 
 	g_hash_table_insert(groups, g_strdup(name), group);
 
+	g_dbus_register_interface(connection, group->path,
+						CONNMAN_SERVICE_INTERFACE,
+						service_methods,
+						NULL, NULL, group, NULL);
+
 done:
 	DBG("group %p", group);
 
@@ -88,6 +135,8 @@ int __connman_profile_add_device(struct connman_device *device)
 	if (group == NULL)
 		return -EINVAL;
 
+	group->type = g_strdup(__connman_device_get_type(device));
+
 	return 0;
 }
 
@@ -118,6 +167,10 @@ int __connman_profile_add_network(struct connman_network *network)
 	if (group == NULL)
 		return -EINVAL;
 
+	g_free(group->type);
+
+	group->type = g_strdup(__connman_network_get_type(network));
+
 	return 0;
 }
 
@@ -190,7 +243,7 @@ static void append_services(DBusMessageIter *dict)
 	dbus_message_iter_close_container(dict, &entry);
 }
 
-static DBusMessage *get_properties(DBusConnection *conn,
+static DBusMessage *profile_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	const char *name = "Default";
@@ -221,12 +274,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 }
 
 static GDBusMethodTable profile_methods[] = {
-	{ "GetProperties", "", "a{sv}", get_properties },
+	{ "GetProperties", "", "a{sv}", profile_properties },
 	{ },
 };
 
-static DBusConnection *connection = NULL;
-
 int __connman_profile_init(DBusConnection *conn)
 {
 	DBG("conn %p", conn);

commit 7ee20adce0d35e0be30c3b41ee2c673ab9f7a925
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:09:43 2009 -0700

    Add support for listing service details

diff --git a/test/test-manager b/test/test-manager
index 4b056f9f..28a20dee 100755
--- a/test/test-manager
+++ b/test/test-manager
@@ -30,7 +30,7 @@ def print_properties(key, value):
 		properties = obj.GetProperties()
 
 		for key in properties.keys():
-			if key == "Networks":
+			if key in ["Networks", "Services"]:
 				continue
 
 			if key in ["Powered", "Scanning", "Connected",
@@ -52,6 +52,12 @@ def print_properties(key, value):
 				val = str(path)
 				list = list + val[val.rfind("/") + 1:] + " "
 			print "        Networks = [ %s]" % (list)
+		if "Services" in properties.keys():
+			list = ""
+			for path in properties["Services"]:
+				val = str(path)
+				list = list + val[val.rfind("/") + 1:] + " "
+			print "        Services = [ %s]" % (list)
 
 for key in properties.keys():
 	if key in ["Profiles", "Devices", "Connections", "Services"]:

commit 73f8a9f2b49a5db3595a90d26260fa53d7ad86d2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:12:27 2009 -0700

    Handle service list correctly

diff --git a/test/list-profiles b/test/list-profiles
index 47741141..9a68d20e 100755
--- a/test/list-profiles
+++ b/test/list-profiles
@@ -17,6 +17,13 @@ for path in properties["Profiles"]:
 
 	properties = profile.GetProperties()
 	for key in properties.keys():
-		print "    %s = %s" % (key, properties[key])
+		if key in ["Services"]:
+			list = ""
+			for path in properties["Services"]:
+				val = str(path)
+				list = list + val[val.rfind("/") + 1:] + " "
+			print "    Services = [ %s]" % (list)
+		else:
+			print "    %s = %s" % (key, properties[key])
 
 	print

commit d740b4a5c3d684a913af2fc1140a58d7f4f9f469
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:30:06 2009 -0700

    Export device and network names via service interface

diff --git a/src/device.c b/src/device.c
index e8d46e98..1d438550 100644
--- a/src/device.c
+++ b/src/device.c
@@ -298,14 +298,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	str = type2description(device->type);
-	if (str != NULL && device->interface != NULL) {
-		char *name = g_strdup_printf("%s (%s)", str, device->interface);
-		if (name != NULL)
-			connman_dbus_dict_append_variant(&dict, "Name",
-						DBUS_TYPE_STRING, &name);
-		g_free(name);
-	}
+	if (device->name != NULL)
+		connman_dbus_dict_append_variant(&dict, "Name",
+					DBUS_TYPE_STRING, &device->name);
 
 	str = type2string(device->type);
 	if (str != NULL)
@@ -930,6 +925,7 @@ struct connman_device *connman_device_create(const char *node,
 	device->element.ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
 
 	device->type   = type;
+	device->name   = g_strdup(type2description(device->type));
 	device->mode   = CONNMAN_DEVICE_MODE_UNKNOWN;
 	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
 
@@ -1061,6 +1057,13 @@ void connman_device_set_interface(struct connman_device *device,
 
 	g_free(device->interface);
 	device->interface = g_strdup(interface);
+
+	if (device->name == NULL) {
+		const char *str = type2description(device->type);
+		if (str != NULL && device->interface != NULL)
+			device->name = g_strdup_printf("%s (%s)", str,
+							device->interface);
+	}
 }
 
 /**
diff --git a/src/profile.c b/src/profile.c
index 5115aad9..e5aca9f1 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -31,8 +31,9 @@
 #define PROFILE_DEFAULT  "/profile/default"
 
 struct connman_group {
-	char *type;
 	char *path;
+	char *type;
+	char *name;
 	GSList *networks;
 };
 
@@ -64,6 +65,10 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Type",
 					DBUS_TYPE_STRING, &group->type);
 
+	if (group->name != NULL)
+		connman_dbus_dict_append_variant(&dict, "Name",
+					DBUS_TYPE_STRING, &group->name);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -83,6 +88,7 @@ static void free_group(gpointer data)
 	g_dbus_unregister_interface(connection, group->path,
 						CONNMAN_SERVICE_INTERFACE);
 
+	g_free(group->name);
 	g_free(group->type);
 	g_free(group->path);
 	g_free(group);
@@ -136,6 +142,7 @@ int __connman_profile_add_device(struct connman_device *device)
 		return -EINVAL;
 
 	group->type = g_strdup(__connman_device_get_type(device));
+	group->name = g_strdup(connman_device_get_string(device, "Name"));
 
 	return 0;
 }
@@ -168,8 +175,10 @@ int __connman_profile_add_network(struct connman_network *network)
 		return -EINVAL;
 
 	g_free(group->type);
+	g_free(group->name);
 
 	group->type = g_strdup(__connman_network_get_type(network));
+	group->name = g_strdup(connman_network_get_string(network, "Name"));
 
 	return 0;
 }

commit aa0d80d82c9bca7a8b9450ed490c621f8f5b79a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:31:40 2009 -0700

    Update default properties for service interface

diff --git a/doc/service-api.txt b/doc/service-api.txt
index ec29c95b..3ae9faf4 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -17,6 +17,13 @@ Signals		PropertyChanged(string name, variant value)
 			This signal indicates a changed value of the given
 			property.
 
-Properties	string Identifier [readonly]
+Properties	string Name [readonly]
 
-			Unique identifier for this service.
+			The service name (for example "Wireless" etc.)
+
+			This name can be used for directly displaying it in
+			the application. It has pure informational purpose.
+
+		string Type [readonly]
+
+			The device type (for example "ethernet", "wifi" etc.)

commit 2da467e698563d3be334a2bbf7038cb74e56c753
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:32:58 2009 -0700

    Update details about service type property

diff --git a/doc/service-api.txt b/doc/service-api.txt
index 3ae9faf4..0ed686c7 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -26,4 +26,8 @@ Properties	string Name [readonly]
 
 		string Type [readonly]
 
-			The device type (for example "ethernet", "wifi" etc.)
+			The service type (for example "ethernet", "wifi" etc.)
+
+			This information should only be used to determine
+			advanced properties or showing the correct icon
+			to the user.

commit 0cded07a3be87def98f9aafe7b5dd6c8f3b232e9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:36:49 2009 -0700

    Indicate the current active profile

diff --git a/test/list-profiles b/test/list-profiles
index 9a68d20e..710a36c2 100755
--- a/test/list-profiles
+++ b/test/list-profiles
@@ -9,8 +9,13 @@ manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
 
 properties = manager.GetProperties()
 
+active = properties["ActiveProfile"]
+
 for path in properties["Profiles"]:
-	print "[ %s ]" % (path)
+	if (active == path):
+		print "[ %s ]  <== active" % (path)
+	else:
+		print "[ %s ]" % (path)
 
 	profile = dbus.Interface(bus.get_object("org.moblin.connman", path),
 						"org.moblin.connman.Profile")

commit 7edc4abc4e6b01a422ffc4a719ce2abc26f6dc9a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 20:58:54 2009 -0700

    Add support for mode, security and signal strength service properties

diff --git a/doc/service-api.txt b/doc/service-api.txt
index 0ed686c7..405dd50c 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -31,3 +31,22 @@ Properties	string Name [readonly]
 			This information should only be used to determine
 			advanced properties or showing the correct icon
 			to the user.
+
+		string Mode [readonly]
+
+			If the service type is WiFi, then this property is
+			present and contains the mode of the network. The
+			possible values are "managed" or "adhoc".
+
+		string Security [readonly]
+
+			If the service type is WiFi, then this property is
+			present and contains the security method or key
+			management setting.
+
+			Possible values are "none", "wep", "wpa" and "wpa2".
+
+		uint8 Strength [readonly]
+
+			Indicates the signal strength of the service. This
+			is a normalized value between 0 and 100.
diff --git a/src/profile.c b/src/profile.c
index e5aca9f1..a2706546 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -34,7 +34,10 @@ struct connman_group {
 	char *path;
 	char *type;
 	char *name;
-	GSList *networks;
+	char *mode;
+	char *security;
+	connman_uint8_t strength;
+	struct connman_network *network;
 };
 
 static GHashTable *groups = NULL;
@@ -69,6 +72,18 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Name",
 					DBUS_TYPE_STRING, &group->name);
 
+	if (group->mode != NULL)
+		connman_dbus_dict_append_variant(&dict, "Mode",
+					DBUS_TYPE_STRING, &group->mode);
+
+	if (group->security != NULL)
+		connman_dbus_dict_append_variant(&dict, "Security",
+					DBUS_TYPE_STRING, &group->security);
+
+	if (group->strength > 0)
+		connman_dbus_dict_append_variant(&dict, "Strength",
+					DBUS_TYPE_BYTE, &group->strength);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -88,6 +103,8 @@ static void free_group(gpointer data)
 	g_dbus_unregister_interface(connection, group->path,
 						CONNMAN_SERVICE_INTERFACE);
 
+	g_free(group->security);
+	g_free(group->mode);
 	g_free(group->name);
 	g_free(group->type);
 	g_free(group->path);
@@ -134,7 +151,8 @@ int __connman_profile_add_device(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	name = g_strdup_printf("device%d", connman_device_get_index(device));
+	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
+					connman_device_get_index(device));
 	group = lookup_group(name);
 	g_free(name);
 
@@ -154,7 +172,8 @@ int __connman_profile_remove_device(struct connman_device *device)
 
 	DBG("device %p", device);
 
-	name = g_strdup_printf("device%d", connman_device_get_index(device));
+	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
+					connman_device_get_index(device));
 	group = lookup_group(name);
 	g_free(name);
 
@@ -180,6 +199,17 @@ int __connman_profile_add_network(struct connman_network *network)
 	group->type = g_strdup(__connman_network_get_type(network));
 	group->name = g_strdup(connman_network_get_string(network, "Name"));
 
+	group->strength = connman_network_get_uint8(network, "Strength");
+
+	if (group->network == NULL) {
+		group->network = network;
+
+		group->mode = g_strdup(connman_network_get_string(network,
+								"WiFi.Mode"));
+		group->security = g_strdup(connman_network_get_string(network,
+							"WiFi.Security"));
+	}
+
 	return 0;
 }
 
@@ -193,6 +223,16 @@ int __connman_profile_remove_network(struct connman_network *network)
 	if (group == NULL)
 		return -EINVAL;
 
+	if (group->network == network) {
+		g_free(group->security);
+		group->security = NULL;
+
+		g_free(group->mode);
+		group->mode = NULL;
+
+		group->network = NULL;
+	}
+
 	return 0;
 }
 

commit bd91f83892ec91781654f8cc3402a0f50b3f7a10
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 21:32:28 2009 -0700

    Mention the service state property

diff --git a/doc/service-api.txt b/doc/service-api.txt
index 405dd50c..25c4631c 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -17,7 +17,11 @@ Signals		PropertyChanged(string name, variant value)
 			This signal indicates a changed value of the given
 			property.
 
-Properties	string Name [readonly]
+Properties	string State [readonly]
+
+			The service state information.
+
+		string Name [readonly]
 
 			The service name (for example "Wireless" etc.)
 

commit ce9854b5e213a28e9403e9d58f1695eb25654b93
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Mar 31 21:34:16 2009 -0700

    Add initial text for D-Bus API overview/introduction

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 995f9985..92af2a93 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -37,5 +37,6 @@ else
 EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
-EXTRA_DIST += manager-api.txt device-api.txt network-api.txt service-api.txt \
+EXTRA_DIST += overview-api.txt manager-api.txt service-api.txt \
+		device-api.txt network-api.txt service-api.txt \
 		connection-api.txt profile-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/overview-api.txt b/doc/overview-api.txt
new file mode 100644
index 00000000..0dd24cdc
--- /dev/null
+++ b/doc/overview-api.txt
@@ -0,0 +1,88 @@
+Application programming interface
+*********************************
+
+
+Application basics
+==================
+
+All applications should use D-Bus to communicate with Connection Manager. The
+main entry point is the manager object. Currently the manager object is
+located at "/", but this might change to allow full namespacing of the API
+in the future. The manager interface is documented in manager-api.txt and
+contains a set of global properties and methods.
+
+A simple way to retrieve all global properties looks like this:
+
+	bus = dbus.SystemBus()
+
+	manager = dbus.Interface(bus.get_object("org.moblin.connman", "/"),
+						"org.moblin.connman.Manager")
+
+	properties = manager.GetProperties()
+
+Changing a global property is also pretty simple. For example enabling the
+so called offline mode (aka flight mode) it is enough to just set that
+property:
+
+	manager.SetProperty("OfflineMode", dbus.Boolean(1))
+
+The manager object contains references to profiles, devices, services and
+connections. All these references represent other interfaces that allow
+detailed control of Connection Manager. The profiles and devices interfaces
+are more for advanced features and most applications don't need them at all.
+
+The services are represented as a list of object paths. Every of these object
+paths contains a service interface. A service is a global collection for
+Ethernet devices, WiFi networks, Bluetooth services, WiMAX providers etc. and
+all these different types are treated equally.
+
+Every local Ethernet card will show up as exactly one service. WiFi networks
+will be grouped by SSID, mode and security setting. Bluetooth PAN and DUN
+service will show up per remote device. For WiMAX the provider name will
+be used for grouping different base stations and access providers. This
+creates a simple list that can be directly displayed to the users since these
+are the exact details users should care about.
+
+	properties = manager.GetProperties()
+
+	for path in properties["Services"]:
+		service = dbus.Interface(bus.get_object("org.moblin.connman", path),
+							"org.moblin.connman.Service")
+
+		service_properties = service.GetProperties()
+
+The service interface is documented in service-api.txt and contains common
+properties valid for all services. It also contains method to connect or
+disconnect a specific service. This allows users to select a specific service.
+Connection Manager can also auto-connect services based on his policies or
+via external events (like plugging in an Ethernet cable).
+
+Connecting (or disconnecting) a specific service manually is as simple as
+just telling it to actually connect:
+
+	service.Connect()  or  service.Disconnect()
+
+It is possible to connect multiple service if the underlying technology
+allows it. For example it would be possible to connect to a WiFi network
+and a Bluetooth service at the same time. Trying to connect to a second WiFi
+network with the same WiFi hardware would result in an automatic disconnect
+of the currently connected network. Connection Manager handles all of this
+for the applications in the background. Trying to connect an Ethernet service
+will result in an error if no cable is plugged in. All connection attempts
+can fail for one reason or another. Application should be able to handle
+such errors and will also be notified of changes via signals.
+
+In future versions Connection Manager will interact with an agent to confirm
+certain transaction with the user. This functionality is currently not
+implemented.
+
+To monitor the current status of a service the state property can be used. It
+gives detailed information about the current progress.
+
+	properties = service.GetProperties()
+
+	print properties["State"]
+
+All state changes are also send via the PropertyChanged signal on the
+service interface. This allows asynchronous monitoring with having to poll
+Connection Manager for changes.

commit 74fe0aa01a4f3e95a48ef231873615d3e0c96c38
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:07:13 2009 +0200

    Update manager and service interface documentation

diff --git a/doc/manager-api.txt b/doc/manager-api.txt
index dd819418..13ca3661 100644
--- a/doc/manager-api.txt
+++ b/doc/manager-api.txt
@@ -41,7 +41,7 @@ Methods		dict GetProperties()
 			one must be selected via ActiveProfile property
 			first.
 
-			At minium one profile must be available all the time.
+			At minimum one profile must be available all the time.
 
 			Possible Errors: [service].Error.InvalidArguments
 
@@ -111,7 +111,10 @@ Properties	string State [readonly]
 
 		array{object} Services [readonly]
 
-			List of service object paths.
+			List of service object paths. The list is sorted
+			internally to have the service with the default
+			route always first and then the favorite services
+			followed by scan results.
 
 			This list represents the available services for the
 			current selected profile. If the profile gets changed
diff --git a/doc/service-api.txt b/doc/service-api.txt
index 25c4631c..4e090567 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -12,6 +12,66 @@ Methods		dict GetProperties()
 
 			Possible Errors: [service].Error.InvalidArguments
 
+		void Connect()
+
+			Connect this service. It will attempt to connect
+			WiFi, WiMAX or Bluetooth services.
+
+			For Ethernet devices this method can only be used
+			if it has previously been disconnected. Otherwise
+			the plugging of a cable will trigger connecting
+			automatically. If no cable is plugged in this method
+			will fail.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+		void Disconnect()
+
+			Disconnect this service. If the service is not
+			connected an error message will be generated.
+
+			On Ethernet devices this will disconnect the IP
+			details from the service. It will not magically
+			unplug the cable. When no cable is plugged in this
+			method will fail.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+		void Remove()
+
+			A successfully connected service with Favorite=true
+			can be removed this way. If it is connected, it will
+			be automatically disconnected first.
+
+			This is similar to setting the Favorite property
+			to false, but that is currently not supported.
+
+			Calling this method on Ethernet devices will cause
+			an error message. It is not possible to remove these
+			kind of devices.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+		void MoveBefore(object service)
+
+			If a service has been used before, this allows a
+			reorder of the favorite services.
+
+			The target service object must be part of this
+			profile. Moving between profiles is not supported.
+
+			Possible Errors: [service].Error.InvalidArguments
+
+		void MoveAfter(object service)
+
+			If a service has been used before, this allows a
+			reorder of the favorite services.
+
+			The target service object must be part of this
+			profile. Moving between profiles is not supported.
+
+			Possible Errors: [service].Error.InvalidArguments
+
 Signals		PropertyChanged(string name, variant value)
 
 			This signal indicates a changed value of the given
@@ -21,6 +81,9 @@ Properties	string State [readonly]
 
 			The service state information.
 
+			Valid states are "idle", "failure", "association",
+			"configuration" and "ready".
+
 		string Name [readonly]
 
 			The service name (for example "Wireless" etc.)
@@ -28,6 +91,9 @@ Properties	string State [readonly]
 			This name can be used for directly displaying it in
 			the application. It has pure informational purpose.
 
+			For Ethernet device it is not guaranteed that this
+			property is present.
+
 		string Type [readonly]
 
 			The service type (for example "ethernet", "wifi" etc.)
@@ -42,6 +108,9 @@ Properties	string State [readonly]
 			present and contains the mode of the network. The
 			possible values are "managed" or "adhoc".
 
+			This property might be only present for WiFi
+			services.
+
 		string Security [readonly]
 
 			If the service type is WiFi, then this property is
@@ -50,7 +119,23 @@ Properties	string State [readonly]
 
 			Possible values are "none", "wep", "wpa" and "wpa2".
 
+			This property might be only present for WiFi
+			services.
+
 		uint8 Strength [readonly]
 
 			Indicates the signal strength of the service. This
 			is a normalized value between 0 and 100.
+
+			This property will not be present for Ethernet
+			devices.
+
+		boolean Favorite [readonly]
+
+			Will be true if a cable is plugged in or the user
+			selected and successfully connected to this service.
+
+			Setting this property to true has no effect at all
+			and setting it to false is similar to the Remove()
+			method. So for now it will be considered a read
+			only property.

commit 208a3bdf5d8f362759333b21c557b48e004ff039
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:09:49 2009 +0200

    Add additional information to the API overview

diff --git a/doc/overview-api.txt b/doc/overview-api.txt
index 0dd24cdc..afb996de 100644
--- a/doc/overview-api.txt
+++ b/doc/overview-api.txt
@@ -2,6 +2,324 @@ Application programming interface
 *********************************
 
 
+Service basics
+==============
+
+Inside Connection Manager there exists one advanced interface to allow the
+user interface an easy access to networking details and user chosen
+preferences. This is the service list and interface.
+
+The basic idea is that Connection Manager maintains a single flat and sorted
+list of all available, preferred or previously used services. A service here
+can be either a Ethernet device, a WiFi network, a WiMAX service provider
+or a remote Bluetooth device (for example a mobile phone).
+
+This list of service is sorted by Connection Manager and there is no need
+for the user interface to implement its own sorting. User decisions will
+need to be done via Connection Manager and it is then responsible to update
+the order of services in this list.
+
+	+---------------------------------------+
+	| Ethernet                              |
+	+---------------------------------------+
+	| Bluetooth phone                       |
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |
+	+---------------------------------------+
+	| Clear WiMAX      (strength 70)        |
+	+---------------------------------------+
+	| Other AP         (strength 70, wpa2)  |
+	+---------------------------------------+
+	| Friends AP       (strength 70, wep)   |
+	+---------------------------------------+
+	| Other WiMAX      (strength 50)        |
+	+---------------------------------------+
+
+If non of the services has been used before the sorting order will be done
+with these priorities:
+
+	1. Ethernet	(lower index numbers first)
+	2. Bluetooth	(last used devices first)
+	3. GSM/UTMS/3G	(if SIM card is present, activated and not roaming)
+	3. WiFi/WiMAX	(signal strength first, then prefer WiMAX over WiFi,
+			 then more secure network first)
+
+The Ethernet devices are always sorted first since they are physically built
+into the system and will be always present. In cases they are switched off
+manually they will not be showing in this list.
+
+Since every Bluetooth device has to be configured/paired first, the user
+already made a choice here that these are important. Connection Manager will
+only show devices with PAN or DUN profile support. While Bluetooth devices
+do have a signal strength, it is mostly unknown since background scanning
+in Bluetooth is too expensive. The choice here is to sort the last used
+Bluetooth device before the others.
+
+The WiFi and WiMAX networks are treated equally since both provide signal
+strength information and networks closer in the proximity should be shown
+before others since it is more likely they are selected first. The signal
+strength value is normalized to 0-100 (effectively a percentage) and allows
+an easy sorting.
+
+If the signal strength is identical than the WiMAX network should be shown
+first since it is a licensed spectrum and more reliable. Also the number
+of WiMAX networks will be smaller than the number of WiFi since that operates
+in an unlicensed spectrum.
+
+WiFi networks with the same signal strength are then sorted by its security
+setting. WPA2 encrypted networks should be preferred over WPA/WEP and also
+unencrypted ones. After that they will be sorted by the SSID in alphabetical
+order.
+
+In the case the WiFi network uses WPS for setup and it is clearly detectable
+that a network waits for Connection Manager to connect to it (for example via
+a push-to-connect button press on the AP), then this network should be shown
+first before any other WiFi or WiMAX network. The reason here is that the
+user already made a choice via the access point. However this depends on
+technical details if it is possible to detect these situations.
+
+
+Service order
+=============
+
+All unused services will have the internal order number of 0 and then will
+be sorted according to the rules above. For Bluetooth the user already made
+the decision to setup their device and by that means select it. However
+until the first connection attempt it might have been setup for total
+different reason (like audio usage) and thus it still counts as unused from
+a networking point of view.
+
+Selecting the "My WiFi AP" and successfully connecting to it makes it a
+favorite device and it will become an order number bigger than 0. All
+order numbers are internally. They are given only to service that are marked
+as favorite. For WiFi, WiMAX and Bluetooth a successful connection attempt
+makes these services automatically a favorite. For Ethernet the plugging
+of a cable makes it a favorite. Disconnecting from a network doesn't remove
+the favorite setting. It is a manual operation and is equal to users pressing
+delete/remove button.
+
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |  order=1 - favorite=yes
+	+---------------------------------------+
+	| Ethernet                              |  order=0
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+Ethernet is special here since the unplugging of the network cable will
+remove the favorite selection.
+
+	+---------------------------------------+
+	| Ethernet with cable                   |  order=1 - favorite=yes
+	+---------------------------------------+
+	| Ethernet without cable                |  order=0 - favorite=no
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+This means that all services with an order > 0 have favorite=yes and all
+other have favorite=no setting. The favorite setting is exposed via a
+property over the service interface. As mentioned above, the order number
+is only used internally.
+
+Within Connection Manager many service can be connected at the same time and
+also have an IP assignment. However only one can have the default route. The
+service with the the default route will always be sorted at the top of the
+list.
+
+	+---------------------------------------+
+	| Ethernet                              |  order=2 - connected=yes
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |  order=1 - connected=yes
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+To change the default connection to your access point, the user needs to
+manually drag the access point service to the top of the list. Connection
+Manager will not take down default routes if there is no reason to do so.
+A working connection is considered top priority.
+
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |  order=2 - connected=yes
+	+---------------------------------------+
+	| Ethernet                              |  order=1 - connected=yes
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+Another possible user interaction would be to unplug the Ethernet cable and
+in this case the favorite setting will be removed and the service falls back
+down in the list.
+
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |  order=1 - connected=yes
+	+---------------------------------------+
+	| Ethernet                              |  order=0
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+If the service on the top of the list changes the default route will be
+automatically adjusted as needed. The user can trigger this by disconnecting
+from a network, if the network becomes unavailable (out of range) or if the
+cable gets unplugged.
+
+As described above, the pure case of disconnecting from a network will not
+remove the favorite setting. So previously selected networks are still present
+and are sorted above all others.
+
+	+---------------------------------------+
+	| Ethernet                              |  order=2 - connected=yes
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |  order=1 - connected=no
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+Unplugging the Ethernet cable will remove the favorite setting, but due to
+the basic ordering of services it will be at the top of the services with an
+order number of 0 (directly after all favorite services).
+
+	+---------------------------------------+
+	| My WiFi AP       (strength 80, wpa2)  |  order=1 - connected=no
+	+---------------------------------------+
+	| Ethernet                              |  order=0 - connected=no
+	+---------------------------------------+
+	| Guest            (strength 90, none)  |  order=0
+	+---------------------------------------+
+	|                                       |
+
+
+Service tweaks
+==============
+
+The interfaces of Connection Manager will always export all services that are
+currently known. This includes Ethernet devices with no cable plugged into
+them. This is of course suboptimal since the user doesn't need to be bothered
+with a device that he/she can actually physically see.
+
+So in this case the user interface can choose to just not show Ethernet
+devices with a favorite=no setting. This is an advanced tweak that is up
+to the user interface. However it is highly recommended to not show Ethernet
+device until Connection Manager marks them as favorite.
+
+The service interface is not meant for basic device configuration task. So
+switching a device on and off (via RFKILL for example) should be done via
+the device interface.
+
+Due to limited screen size of small devices and the big amount of WiFi
+access points that are deployed right now it might be sensible to not show
+certain WiFi networks in the user interface.
+
+The choice to hide a WiFi network from the user interface should be purely
+done by the signal strength. The optimal cut-off value here still has to be
+determined, but in the end that is a user interface policy.
+
+
+Service naming
+==============
+
+Every service will have a name property that allows the user interface to
+display them directly. All names will be already converted into UTF-8. It
+derives from the netork details.
+
+In case of WiFi this will be the SSID value. The SSID is a binary array and
+will be converted into printable form. Unprintable characters are replaced
+with spaces.
+
+For WiMAX networks the provide name like Clear or X-OHM will be used. This
+name either comes directly from the networks itself or from a provisioning
+database of the WiMAX service.
+
+For Bluetooth the device alias is used. The alias is different since it
+can be overwritten by the user via the Bluetooth service. The identification
+is still done based on its address, but the display name might change. In
+most cases the alias is equal to the Bluetooth remote friendly name.
+
+For Ethernet device no name will be provided. The type property will indicate
+that this service is Ethernet and then it is up to the user interface to
+provide a proper localized name for it.
+
+
+Service states
+==============
+
+Every service can have multiple states that indicate what is currently
+going on with it. The choice to have multiple states instead of a simple
+connected yes/no value comes from the fact that it is important to let the
+user interface name if a service is in process of connecting/disconnecting.
+
+The basic state of every service is "idle". This means that this service
+is not in use at all at the moment. It also is not attempting to connect
+or do anything else.
+
+The "association" state indicates that this service tries to establish a
+low-level connection to the network. For example associating/connecting
+with a WiFi access point.
+
+With the "configuration" state the service indicates that it is trying
+to retrieve/configure IP settings.
+
+Some service might require special authentication procedure like a web based
+confirmation. The "login" should be used for this in the future. Currently
+this is not implemented.
+
+The "ready" state signals a successful connected device. This doesn't mean
+it has the default route, but basic IP operations will succeed.
+
+With the "disconnect" state a service indicates that it is going to terminate
+the current connection and will return to the "idle" state.
+
+In addition a "failure" state indicates a wrong behavior. It is similar to
+the "idle" state since the service is not connected.
+
+		+---------------+
+		| idle          |<-------------------------------+
+		+---------------+                                |
+		      |                      +-------------+     |
+		      +----------------------| failure     |     |
+		      | service.Connect()    +-------------+     |
+		      V                           A              |
+		+---------------+                 |              |
+		| association   |-----------------+              |
+		+---------------+      error      |              |
+		      |                           |              |
+		      | success                   |              |
+		      V                           |              |
+		+---------------+                 |              |
+		| configuration |-----------------+              |
+		+---------------+      error                     |
+		      |                                          |
+		      | success                                  |
+		      V                                          |
+		+---------------+                                |
+		| ready         |<----------------+              |
+		+---------------+                 |              |
+		      |                           |              |
+		      | service.Disconnect()      |              |
+		      V                           |              |
+		+---------------+                 |              |
+		| disconnect    |-----------------+              |
+		+---------------+      error                     |
+		      |                                          |
+		      +------------------------------------------+
+
+The different states should no be used by the user interface to trigger
+advanced actions. The state transitions are provided for the sole purpose
+to give the user feedback on what is currently going on. Especially in
+cases where networks are flaky or DHCP servers take a long time these
+information are helpful for the user.
+
+
 Application basics
 ==================
 

commit 8d025cd80e2d06eed04b3a7eac6d3860cacfd0c2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:18:13 2009 +0200

    Fix broken handling of ignore policy

diff --git a/src/device.c b/src/device.c
index 1d438550..24c69977 100644
--- a/src/device.c
+++ b/src/device.c
@@ -159,6 +159,39 @@ static enum connman_device_policy string2policy(const char *policy)
 		return CONNMAN_DEVICE_POLICY_UNKNOWN;
 }
 
+static int set_carrier(struct connman_device *device, connman_bool_t carrier)
+{
+	if (carrier == TRUE) {
+		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
+		struct connman_element *element;
+
+		switch (device->element.ipv4.method) {
+		case CONNMAN_IPV4_METHOD_UNKNOWN:
+		case CONNMAN_IPV4_METHOD_OFF:
+			return 0;
+		case CONNMAN_IPV4_METHOD_STATIC:
+			type = CONNMAN_ELEMENT_TYPE_IPV4;
+			break;
+		case CONNMAN_IPV4_METHOD_DHCP:
+			type = CONNMAN_ELEMENT_TYPE_DHCP;
+			break;
+		}
+
+		element = connman_element_create(NULL);
+		if (element != NULL) {
+			element->type  = type;
+			element->index = device->element.index;
+
+			if (connman_element_register(element,
+							&device->element) < 0)
+				connman_element_unref(element);
+		}
+	} else
+		connman_element_unregister_children(&device->element);
+
+	return 0;
+}
+
 static int set_powered(struct connman_device *device, connman_bool_t powered)
 {
 	struct connman_device_driver *driver = device->driver;
@@ -178,6 +211,8 @@ static int set_powered(struct connman_device *device, connman_bool_t powered)
 	} else {
 		g_hash_table_remove_all(device->networks);
 
+		set_carrier(device, FALSE);
+
 		if (driver->disable) {
 			err = driver->disable(device);
 			__connman_notifier_device_type_decrease(device->type);
@@ -215,6 +250,8 @@ static int set_policy(DBusConnection *connection,
 	case CONNMAN_DEVICE_POLICY_MANUAL:
 		if (device->powered == FALSE)
 			err = set_powered(device, TRUE);
+		else
+			err = set_carrier(device, device->carrier);
 		break;
 	}
 
@@ -1203,35 +1240,17 @@ int connman_device_set_carrier(struct connman_device *device,
 
 	device->carrier = carrier;
 
-	if (carrier == TRUE) {
-		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
-		struct connman_element *element;
-
-		switch (device->element.ipv4.method) {
-		case CONNMAN_IPV4_METHOD_UNKNOWN:
-		case CONNMAN_IPV4_METHOD_OFF:
-			return 0;
-		case CONNMAN_IPV4_METHOD_STATIC:
-			type = CONNMAN_ELEMENT_TYPE_IPV4;
-			break;
-		case CONNMAN_IPV4_METHOD_DHCP:
-			type = CONNMAN_ELEMENT_TYPE_DHCP;
-			break;
-		}
-
-		element = connman_element_create(NULL);
-		if (element != NULL) {
-			element->type  = type;
-			element->index = device->element.index;
-
-			if (connman_element_register(element,
-							&device->element) < 0)
-				connman_element_unref(element);
-		}
-	} else
-		connman_element_unregister_children(&device->element);
+	switch (device->policy) {
+	case CONNMAN_DEVICE_POLICY_UNKNOWN:
+	case CONNMAN_DEVICE_POLICY_IGNORE:
+	case CONNMAN_DEVICE_POLICY_OFF:
+		return 0;
+	case CONNMAN_DEVICE_POLICY_AUTO:
+	case CONNMAN_DEVICE_POLICY_MANUAL:
+		break;
+	}
 
-	return 0;
+	return set_carrier(device, device->carrier);
 }
 
 void __connman_device_disconnect(struct connman_device *device)

commit 401d2792c86ffe36ccf9b7b6d8ea5e65ca982dfb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:27:03 2009 +0200

    Fix group name setting for new networks

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 2009f7a0..3c1b0d81 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1035,6 +1035,10 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 	else
 		security = "none";
 
+	mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
+
+	group = build_group(result.ssid, result.ssid_len, mode, security);
+
 	network = connman_device_get_network(task->device, result.path);
 	if (network == NULL) {
 		int index;
@@ -1052,28 +1056,29 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 		connman_network_set_string(network, "Address", result.addr);
 
+		connman_network_set_group(network, group);
+
 		if (connman_device_add_network(task->device, network) < 0) {
 			connman_network_unref(network);
 			goto done;
 		}
 	}
 
+	connman_network_set_group(network, group);
+
+	g_free(group);
+
 	if (result.name != NULL && result.name[0] != '\0')
 		connman_network_set_string(network, "Name", result.name);
 
 	connman_network_set_blob(network, "WiFi.SSID",
 						result.ssid, result.ssid_len);
 
-	mode = (result.adhoc == TRUE) ? "adhoc" : "managed";
 	connman_network_set_string(network, "WiFi.Mode", mode);
 
-	group = build_group(result.ssid, result.ssid_len, mode, security);
-	connman_network_set_group(network, group);
-	g_free(group);
-
 	DBG("%s (%s %s) strength %d (%s)",
-			result.name, mode, security, strength,
-			(result.has_wps == TRUE) ? "WPS" : "no WPS");
+				result.name, mode, security, strength,
+				(result.has_wps == TRUE) ? "WPS" : "no WPS");
 
 	connman_network_set_available(network, TRUE);
 	connman_network_set_uint8(network, "Strength", strength);

commit 7af7e16c45130925cd95a560a8b47977ac238f03
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:29:19 2009 +0200

    Work around issue with missing properties before network registration

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 3c1b0d81..ce56e8fd 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -1058,6 +1058,14 @@ static void properties_reply(DBusPendingCall *call, void *user_data)
 
 		connman_network_set_group(network, group);
 
+		if (result.name != NULL && result.name[0] != '\0')
+			connman_network_set_string(network, "Name", result.name);
+
+		connman_network_set_uint8(network, "Strength", strength);
+
+		connman_network_set_string(network, "WiFi.Mode", mode);
+		connman_network_set_string(network, "WiFi.Security", security);
+
 		if (connman_device_add_network(task->device, network) < 0) {
 			connman_network_unref(network);
 			goto done;

commit 0d706f23d1d89f0359ffddb05a07a00bfcb84385
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:37:40 2009 +0200

    Leave the network identifier encoding to the plugins for now

diff --git a/src/network.c b/src/network.c
index d17cffd5..5a4eb766 100644
--- a/src/network.c
+++ b/src/network.c
@@ -467,7 +467,8 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	__connman_element_initialize(&network->element);
 
-	temp = connman_dbus_encode_string(identifier);
+	//temp = connman_dbus_encode_string(identifier);
+	temp = g_strdup(identifier);
 	if (temp == NULL) {
 		g_free(network);
 		return NULL;

commit 21cfc6e634c485a13229aff75dbe3f119989d90c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:39:57 2009 +0200

    Add support for favorite service setting

diff --git a/src/profile.c b/src/profile.c
index a2706546..9b1d2e72 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -37,6 +37,7 @@ struct connman_group {
 	char *mode;
 	char *security;
 	connman_uint8_t strength;
+	connman_bool_t favorite;
 	struct connman_network *network;
 };
 
@@ -84,6 +85,9 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Strength",
 					DBUS_TYPE_BYTE, &group->strength);
 
+	connman_dbus_dict_append_variant(&dict, "Favorite",
+					DBUS_TYPE_BOOLEAN, &group->favorite);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
@@ -131,6 +135,8 @@ static struct connman_group *lookup_group(const char *name)
 	group->type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	group->path = g_strdup_printf("%s/%s", PROFILE_DEFAULT, name);
 
+	group->favorite = FALSE;
+
 	g_hash_table_insert(groups, g_strdup(name), group);
 
 	g_dbus_register_interface(connection, group->path,

commit 7f0611d48b9029004eb381898fa96dffcf5b045d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:40:20 2009 +0200

    Don't set name for Ethernet devices

diff --git a/src/profile.c b/src/profile.c
index 9b1d2e72..ab0801d7 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -166,7 +166,6 @@ int __connman_profile_add_device(struct connman_device *device)
 		return -EINVAL;
 
 	group->type = g_strdup(__connman_device_get_type(device));
-	group->name = g_strdup(connman_device_get_string(device, "Name"));
 
 	return 0;
 }

commit 6624e3eab185cc68d0625a4ebf0e3f49fb78f69e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:45:32 2009 +0200

    Add D-Bus error message for not implemented methods

diff --git a/src/connman.h b/src/connman.h
index 1ee54475..220eb051 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -36,6 +36,7 @@ DBusMessage *__connman_error_failed(DBusMessage *msg);
 DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
 DBusMessage *__connman_error_not_supported(DBusMessage *msg);
+DBusMessage *__connman_error_not_implemented(DBusMessage *msg);
 
 int __connman_selftest(void);
 
diff --git a/src/error.c b/src/error.c
index 5556d589..1668a41d 100644
--- a/src/error.c
+++ b/src/error.c
@@ -50,3 +50,9 @@ DBusMessage *__connman_error_not_supported(DBusMessage *msg)
 	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
 						".NotSupported", NULL);
 }
+
+DBusMessage *__connman_error_not_implemented(DBusMessage *msg)
+{
+	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
+						".NotImplemented", NULL);
+}

commit bbfbba69c0a74567e1adb6b05a2e55b8a5b119be
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:46:42 2009 +0200

    Update service interface declarations

diff --git a/src/profile.c b/src/profile.c
index ab0801d7..b2d9bedb 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -93,8 +93,48 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	return reply;
 }
 
+static DBusMessage *connect_service(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *disconnect_service(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *remove_service(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *move_before(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *move_after(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	return __connman_error_not_implemented(msg);
+}
+
 static GDBusMethodTable service_methods[] = {
-	{ "GetProperties", "", "a{sv}", get_properties },
+	{ "GetProperties", "",  "a{sv}", get_properties     },
+	{ "Connect",       "",  "",      connect_service    },
+	{ "Disconnect",    "",  "",      disconnect_service },
+	{ "Remove",        "",  "",      remove_service     },
+	{ "MoveBefore",    "o", "",      move_before        },
+	{ "MoveAfter",     "o", "",      move_after         },
+	{ },
+};
+
+static GDBusSignalTable service_signals[] = {
+	{ "PropertyChanged", "sv" },
 	{ },
 };
 
@@ -140,9 +180,9 @@ static struct connman_group *lookup_group(const char *name)
 	g_hash_table_insert(groups, g_strdup(name), group);
 
 	g_dbus_register_interface(connection, group->path,
-						CONNMAN_SERVICE_INTERFACE,
-						service_methods,
-						NULL, NULL, group, NULL);
+					CONNMAN_SERVICE_INTERFACE,
+					service_methods, service_signals,
+							NULL, group, NULL);
 
 done:
 	DBG("group %p", group);

commit 3618208598e69425544b513a13a219366051351b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:53:24 2009 +0200

    Fix handling of watch functions

diff --git a/gdbus/watch.c b/gdbus/watch.c
index 38bf3d75..7d7853fc 100644
--- a/gdbus/watch.c
+++ b/gdbus/watch.c
@@ -37,6 +37,9 @@
 #define error(fmt...)
 #define debug(fmt...)
 
+static DBusHandlerResult name_exit_filter(DBusConnection *connection,
+					DBusMessage *message, void *user_data);
+
 static guint listener_id = 0;
 static GSList *name_listeners = NULL;
 
@@ -62,13 +65,11 @@ static struct name_data *name_data_find(DBusConnection *connection,
 			current != NULL; current = current->next) {
 		struct name_data *data = current->data;
 
-		if (name == NULL && data->name == NULL) {
-			if (connection == data->connection)
-				return data;
-		} else {
-			if (strcmp(name, data->name) == 0)
-				return data;
-		}
+		if (connection != data->connection)
+			continue;
+
+		if (name == NULL || g_str_equal(name, data->name))
+			return data;
 	}
 
 	return NULL;
@@ -165,10 +166,18 @@ static void name_data_remove(DBusConnection *connection,
 		g_free(cb);
 	}
 
-	if (!data->callbacks) {
-		name_listeners = g_slist_remove(name_listeners, data);
-		name_data_free(data);
-	}
+	if (data->callbacks)
+		return;
+
+	name_listeners = g_slist_remove(name_listeners, data);
+	name_data_free(data);
+
+	/* Remove filter if there are no listeners left for the connection */
+	data = name_data_find(connection, NULL);
+	if (!data)
+		dbus_connection_remove_filter(connection,
+						name_exit_filter,
+						NULL);
 }
 
 static gboolean add_match(DBusConnection *connection, const char *name)
@@ -263,6 +272,12 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 	name_listeners = g_slist_remove(name_listeners, data);
 	name_data_free(data);
 
+	/* Remove filter if there no listener left for the connection */
+	data = name_data_find(connection, NULL);
+	if (!data)
+		dbus_connection_remove_filter(connection, name_exit_filter,
+						NULL);
+
 	remove_match(connection, name);
 
 	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
@@ -275,7 +290,7 @@ guint g_dbus_add_service_watch(DBusConnection *connection, const char *name,
 {
 	int first;
 
-	if (!listener_id) {
+	if (!name_data_find(connection, NULL)) {
 		if (!dbus_connection_add_filter(connection,
 					name_exit_filter, NULL, NULL)) {
 			error("dbus_connection_add_filter() failed");
@@ -354,6 +369,12 @@ remove:
 	name_listeners = g_slist_remove(name_listeners, data);
 	name_data_free(data);
 
+	/* Remove filter if there are no listeners left for the connection */
+	data = name_data_find(connection, NULL);
+	if (!data)
+		dbus_connection_remove_filter(connection, name_exit_filter,
+						NULL);
+
 	return TRUE;
 }
 
@@ -361,13 +382,10 @@ void g_dbus_remove_all_watches(DBusConnection *connection)
 {
 	struct name_data *data;
 
-	data = name_data_find(connection, NULL);
-	if (!data) {
-		error("name_listener_indicate_disconnect: no listener found");
-		return;
+	while ((data = name_data_find(connection, NULL))) {
+		name_listeners = g_slist_remove(name_listeners, data);
+		name_data_call_and_free(data);
 	}
 
-	debug("name_listener_indicate_disconnect");
-
-	name_data_call_and_free(data);
+	dbus_connection_remove_filter(connection, name_exit_filter, NULL);
 }

commit 44412dd26ca12bbea6e6907546ce166cf8d281ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 04:58:20 2009 +0200

    Add skeleton for service state property

diff --git a/src/profile.c b/src/profile.c
index b2d9bedb..3cf1e1e2 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -30,6 +30,11 @@
 
 #define PROFILE_DEFAULT  "/profile/default"
 
+enum connman_service_state {
+	CONNMAN_SERVICE_STATE_UNKNOWN = 0,
+	CONNMAN_SERVICE_STATE_IDLE    = 1,
+};
+
 struct connman_group {
 	char *path;
 	char *type;
@@ -38,6 +43,7 @@ struct connman_group {
 	char *security;
 	connman_uint8_t strength;
 	connman_bool_t favorite;
+	enum connman_service_state state;
 	struct connman_network *network;
 };
 
@@ -45,12 +51,25 @@ static GHashTable *groups = NULL;
 
 static DBusConnection *connection = NULL;
 
+static const char *state2string(enum connman_service_state state)
+{
+	switch (state) {
+	case CONNMAN_SERVICE_STATE_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_STATE_IDLE:
+		return "idle";
+	}
+
+	return NULL;
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	struct connman_group *group = data;
 	DBusMessage *reply;
 	DBusMessageIter array, dict;
+	const char *str;
 
 	DBG("conn %p", conn);
 
@@ -65,6 +84,11 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = state2string(group->state);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "State",
+						DBUS_TYPE_STRING, &str);
+
 	if (group->type != NULL)
 		connman_dbus_dict_append_variant(&dict, "Type",
 					DBUS_TYPE_STRING, &group->type);
@@ -177,6 +201,8 @@ static struct connman_group *lookup_group(const char *name)
 
 	group->favorite = FALSE;
 
+	group->state = CONNMAN_SERVICE_STATE_IDLE;
+
 	g_hash_table_insert(groups, g_strdup(name), group);
 
 	g_dbus_register_interface(connection, group->path,

commit 8d8325b7b833a134024e6e20588944f5a0850040
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 12:22:46 2009 +0200

    Use sequence instead of hash table for service list

diff --git a/src/profile.c b/src/profile.c
index 3cf1e1e2..2343d211 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -36,6 +36,8 @@ enum connman_service_state {
 };
 
 struct connman_group {
+	GSequenceIter *iter;
+	char *id;
 	char *path;
 	char *type;
 	char *name;
@@ -47,7 +49,7 @@ struct connman_group {
 	struct connman_network *network;
 };
 
-static GHashTable *groups = NULL;
+static GSequence *groups = NULL;
 
 static DBusConnection *connection = NULL;
 
@@ -176,11 +178,20 @@ static void free_group(gpointer data)
 	g_free(group->name);
 	g_free(group->type);
 	g_free(group->path);
+	g_free(group->id);
 	g_free(group);
 }
 
+static gint compare_group(gconstpointer a, gconstpointer b, gpointer user_data)
+{
+	struct connman_group *group = (void *) a;
+
+	return g_strcmp0(group->id, user_data);
+}
+
 static struct connman_group *lookup_group(const char *name)
 {
+	GSequenceIter *iter;
 	struct connman_group *group;
 
 	DBG("name %s", name);
@@ -188,14 +199,20 @@ static struct connman_group *lookup_group(const char *name)
 	if (name == NULL)
 		return NULL;
 
-	group = g_hash_table_lookup(groups, name);
-	if (group != NULL)
-		goto done;
+	iter = g_sequence_search(groups, NULL, compare_group, (char *) name);
+	if (g_sequence_iter_is_begin(iter) == FALSE &&
+				g_sequence_iter_is_end(iter) == FALSE) {
+		group = g_sequence_get(iter);
+		if (group != NULL)
+			goto done;
+	}
 
 	group = g_try_new0(struct connman_group, 1);
 	if (group == NULL)
 		return NULL;
 
+	group->id = g_strdup(name);
+
 	group->type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 	group->path = g_strdup_printf("%s/%s", PROFILE_DEFAULT, name);
 
@@ -203,7 +220,7 @@ static struct connman_group *lookup_group(const char *name)
 
 	group->state = CONNMAN_SERVICE_STATE_IDLE;
 
-	g_hash_table_insert(groups, g_strdup(name), group);
+	group->iter = g_sequence_append(groups, group);
 
 	g_dbus_register_interface(connection, group->path,
 					CONNMAN_SERVICE_INTERFACE,
@@ -323,7 +340,7 @@ void __connman_profile_list(DBusMessageIter *iter)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
-static void append_path(gpointer key, gpointer value, gpointer user_data)
+static void append_path(gpointer value, gpointer user_data)
 {
 	struct connman_group *group = value;
 	DBusMessageIter *iter = user_data;
@@ -336,7 +353,7 @@ void __connman_profile_list_services(DBusMessageIter *iter)
 {
 	DBG("");
 
-	g_hash_table_foreach(groups, append_path, iter);
+	g_sequence_foreach(groups, append_path, iter);
 }
 
 static void append_services(DBusMessageIter *dict)
@@ -406,8 +423,7 @@ int __connman_profile_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -1;
 
-	groups = g_hash_table_new_full(g_str_hash, g_str_equal,
-							g_free, free_group);
+	groups = g_sequence_new(free_group);
 
 	g_dbus_register_interface(connection, PROFILE_DEFAULT,
 						CONNMAN_PROFILE_INTERFACE,
@@ -424,7 +440,7 @@ void __connman_profile_cleanup(void)
 	g_dbus_unregister_interface(connection, PROFILE_DEFAULT,
 						CONNMAN_PROFILE_INTERFACE);
 
-	g_hash_table_destroy(groups);
+	g_sequence_free(groups);
 	groups = NULL;
 
 	if (connection == NULL)

commit 10fb79650eded22a5deb030653f56da9b1baeba1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 18:26:14 2009 +0200

    Prefix group names with the service type

diff --git a/src/profile.c b/src/profile.c
index 2343d211..bba803c8 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -274,10 +274,18 @@ int __connman_profile_remove_device(struct connman_device *device)
 int __connman_profile_add_network(struct connman_network *network)
 {
 	struct connman_group *group;
+	char *name;
 
 	DBG("network %p", network);
 
-	group = lookup_group(__connman_network_get_group(network));
+	if (__connman_network_get_group(network) == NULL)
+		return -EINVAL;
+
+	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
+					__connman_network_get_group(network));
+	group = lookup_group(name);
+	g_free(name);
+
 	if (group == NULL)
 		return -EINVAL;
 
@@ -304,10 +312,18 @@ int __connman_profile_add_network(struct connman_network *network)
 int __connman_profile_remove_network(struct connman_network *network)
 {
 	struct connman_group *group;
+	char *name;
 
 	DBG("network %p", network);
 
-	group = lookup_group(__connman_network_get_group(network));
+	if (__connman_network_get_group(network) == NULL)
+		return -EINVAL;
+
+	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
+					__connman_network_get_group(network));
+	group = lookup_group(name);
+	g_free(name);
+
 	if (group == NULL)
 		return -EINVAL;
 

commit e51fa63da5cdc75f5512da1b8367d16aeafb9ee9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 18:27:09 2009 +0200

    Let the core handle the service prefix/namespace

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index ce56e8fd..69ef3728 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -796,8 +796,6 @@ static char *build_group(const unsigned char *ssid, unsigned int ssid_len,
 	if (str == NULL)
 		return NULL;
 
-	g_string_append_printf(str, "wifi_");
-
 	for (i = 0; i < ssid_len; i++)
 		g_string_append_printf(str, "%02x", ssid[i]);
 

commit 0d939f13d927ed5a4f49e15e1f10b117a6901d27
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 18:39:51 2009 +0200

    Add initial steps for sorting service list

diff --git a/src/profile.c b/src/profile.c
index bba803c8..a8c56ffc 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -183,6 +183,20 @@ static void free_group(gpointer data)
 }
 
 static gint compare_group(gconstpointer a, gconstpointer b, gpointer user_data)
+{
+	struct connman_group *group_a = (void *) a;
+	struct connman_group *group_b = (void *) b;
+
+	if (group_a->favorite == TRUE && group_b->favorite == FALSE)
+		return -1;
+
+	if (group_a->favorite == FALSE && group_b->favorite == TRUE)
+		return 1;
+
+	return (gint) group_b->strength - (gint) group_a->strength;
+}
+
+static gint search_group(gconstpointer a, gconstpointer b, gpointer user_data)
 {
 	struct connman_group *group = (void *) a;
 
@@ -199,7 +213,7 @@ static struct connman_group *lookup_group(const char *name)
 	if (name == NULL)
 		return NULL;
 
-	iter = g_sequence_search(groups, NULL, compare_group, (char *) name);
+	iter = g_sequence_search(groups, NULL, search_group, (char *) name);
 	if (g_sequence_iter_is_begin(iter) == FALSE &&
 				g_sequence_iter_is_end(iter) == FALSE) {
 		group = g_sequence_get(iter);
@@ -220,7 +234,8 @@ static struct connman_group *lookup_group(const char *name)
 
 	group->state = CONNMAN_SERVICE_STATE_IDLE;
 
-	group->iter = g_sequence_append(groups, group);
+	group->iter = g_sequence_insert_sorted(groups, group,
+						compare_group, NULL);
 
 	g_dbus_register_interface(connection, group->path,
 					CONNMAN_SERVICE_INTERFACE,
@@ -250,6 +265,8 @@ int __connman_profile_add_device(struct connman_device *device)
 
 	group->type = g_strdup(__connman_device_get_type(device));
 
+	g_sequence_sort_changed(group->iter, compare_group, NULL);
+
 	return 0;
 }
 
@@ -268,6 +285,11 @@ int __connman_profile_remove_device(struct connman_device *device)
 	if (group == NULL)
 		return -EINVAL;
 
+	g_free(group->type);
+	group->type = NULL;
+
+	g_sequence_sort_changed(group->iter, compare_group, NULL);
+
 	return 0;
 }
 
@@ -306,6 +328,8 @@ int __connman_profile_add_network(struct connman_network *network)
 							"WiFi.Security"));
 	}
 
+	g_sequence_sort_changed(group->iter, compare_group, NULL);
+
 	return 0;
 }
 
@@ -337,6 +361,11 @@ int __connman_profile_remove_network(struct connman_network *network)
 		group->network = NULL;
 	}
 
+	g_free(group->type);
+	group->type = NULL;
+
+	g_sequence_sort_changed(group->iter, compare_group, NULL);
+
 	return 0;
 }
 

commit 5d59515eb52adf085f9f124120bbaa2300d17c2e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 18:52:08 2009 +0200

    Add support for sending signals when service list changes

diff --git a/src/profile.c b/src/profile.c
index a8c56ffc..c94a7627 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -164,6 +164,73 @@ static GDBusSignalTable service_signals[] = {
 	{ },
 };
 
+const char *__connman_profile_active(void)
+{
+	DBG("");
+
+	return PROFILE_DEFAULT;
+}
+
+static void append_path(gpointer value, gpointer user_data)
+{
+	struct connman_group *group = value;
+	DBusMessageIter *iter = user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+							&group->path);
+}
+
+void __connman_profile_list_services(DBusMessageIter *iter)
+{
+	DBG("");
+
+	g_sequence_foreach(groups, append_path, iter);
+}
+
+static void append_services(DBusMessageIter *entry)
+{
+	DBusMessageIter value, iter;
+	const char *key = "Services";
+
+	dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(entry, DBUS_TYPE_VARIANT,
+		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
+								&value);
+
+	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
+				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
+	__connman_profile_list_services(&iter);
+	dbus_message_iter_close_container(&value, &iter);
+
+	dbus_message_iter_close_container(entry, &value);
+}
+
+static void emit_services_signal(void)
+{
+	const char *path = __connman_profile_active();
+	DBusMessage *signal;
+	DBusMessageIter entry;
+
+	signal = dbus_message_new_signal(path,
+				CONNMAN_PROFILE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+	append_services(&entry);
+	g_dbus_send_message(connection, signal);
+
+	signal = dbus_message_new_signal(CONNMAN_MANAGER_PATH,
+				CONNMAN_MANAGER_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+	append_services(&entry);
+	g_dbus_send_message(connection, signal);
+}
+
 static void free_group(gpointer data)
 {
 	struct connman_group *group = data;
@@ -266,6 +333,7 @@ int __connman_profile_add_device(struct connman_device *device)
 	group->type = g_strdup(__connman_device_get_type(device));
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
+	emit_services_signal();
 
 	return 0;
 }
@@ -289,6 +357,7 @@ int __connman_profile_remove_device(struct connman_device *device)
 	group->type = NULL;
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
+	emit_services_signal();
 
 	return 0;
 }
@@ -329,6 +398,7 @@ int __connman_profile_add_network(struct connman_network *network)
 	}
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
+	emit_services_signal();
 
 	return 0;
 }
@@ -365,17 +435,11 @@ int __connman_profile_remove_network(struct connman_network *network)
 	group->type = NULL;
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
+	emit_services_signal();
 
 	return 0;
 }
 
-const char *__connman_profile_active(void)
-{
-	DBG("");
-
-	return PROFILE_DEFAULT;
-}
-
 void __connman_profile_list(DBusMessageIter *iter)
 {
 	const char *path = __connman_profile_active();
@@ -385,52 +449,12 @@ void __connman_profile_list(DBusMessageIter *iter)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
-static void append_path(gpointer value, gpointer user_data)
-{
-	struct connman_group *group = value;
-	DBusMessageIter *iter = user_data;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
-							&group->path);
-}
-
-void __connman_profile_list_services(DBusMessageIter *iter)
-{
-	DBG("");
-
-	g_sequence_foreach(groups, append_path, iter);
-}
-
-static void append_services(DBusMessageIter *dict)
-{
-	DBusMessageIter entry, value, iter;
-	const char *key = "Services";
-
-	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
-								NULL, &entry);
-
-	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
-
-	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
-		DBUS_TYPE_ARRAY_AS_STRING DBUS_TYPE_OBJECT_PATH_AS_STRING,
-								&value);
-
-	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
-				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_profile_list_services(&iter);
-	dbus_message_iter_close_container(&value, &iter);
-
-	dbus_message_iter_close_container(&entry, &value);
-
-	dbus_message_iter_close_container(dict, &entry);
-}
-
 static DBusMessage *profile_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	const char *name = "Default";
 	DBusMessage *reply;
-	DBusMessageIter array, dict;
+	DBusMessageIter array, dict, entry;
 
 	DBG("conn %p", conn);
 
@@ -448,7 +472,10 @@ static DBusMessage *profile_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Name",
 						DBUS_TYPE_STRING, &name);
 
-	append_services(&dict);
+	dbus_message_iter_open_container(&dict, DBUS_TYPE_DICT_ENTRY,
+								NULL, &entry);
+	append_services(&entry);
+	dbus_message_iter_close_container(&dict, &entry);
 
 	dbus_message_iter_close_container(&array, &dict);
 
@@ -460,6 +487,11 @@ static GDBusMethodTable profile_methods[] = {
 	{ },
 };
 
+static GDBusSignalTable profile_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
+};
+
 int __connman_profile_init(DBusConnection *conn)
 {
 	DBG("conn %p", conn);
@@ -471,9 +503,9 @@ int __connman_profile_init(DBusConnection *conn)
 	groups = g_sequence_new(free_group);
 
 	g_dbus_register_interface(connection, PROFILE_DEFAULT,
-						CONNMAN_PROFILE_INTERFACE,
-						profile_methods,
-						NULL, NULL, NULL, NULL);
+					CONNMAN_PROFILE_INTERFACE,
+					profile_methods, profile_signals,
+							NULL, NULL, NULL);
 
 	return 0;
 }

commit c3f5d63a9788544edcf7846e6c0e6977db52c2bc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 19:10:50 2009 +0200

    Add function for getting device type

diff --git a/include/device.h b/include/device.h
index c0042a9e..a3a1d4a7 100644
--- a/include/device.h
+++ b/include/device.h
@@ -71,6 +71,7 @@ extern struct connman_device *connman_device_create(const char *node,
 extern struct connman_device *connman_device_ref(struct connman_device *device);
 extern void connman_device_unref(struct connman_device *device);
 
+extern enum connman_device_type connman_device_get_type(struct connman_device *device);
 extern const char *connman_device_get_name(struct connman_device *device);
 extern const char *connman_device_get_path(struct connman_device *device);
 extern void connman_device_set_index(struct connman_device *device,
diff --git a/src/device.c b/src/device.c
index 24c69977..b52fb7ea 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1034,6 +1034,17 @@ const char *__connman_device_get_type(struct connman_device *device)
 	return type2string(device->type);
 }
 
+/**
+ * connman_device_get_type:
+ * @device: device structure
+ *
+ * Get type of device
+ */
+enum connman_device_type connman_device_get_type(struct connman_device *device)
+{
+	return device->type;
+}
+
 /**
  * connman_device_get_name:
  * @device: device structure

commit 442bf8f1b944620b061b02a8e09cd33d0deb61fd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 19:11:09 2009 +0200

    Add function for getting network type

diff --git a/include/network.h b/include/network.h
index 3e765d08..02caa59e 100644
--- a/include/network.h
+++ b/include/network.h
@@ -58,6 +58,7 @@ extern struct connman_network *connman_network_create(const char *identifier,
 extern struct connman_network *connman_network_ref(struct connman_network *network);
 extern void connman_network_unref(struct connman_network *network);
 
+extern enum connman_network_type connman_network_get_type(struct connman_network *network);
 extern const char *connman_network_get_identifier(struct connman_network *network);
 
 extern const char *connman_network_get_path(struct connman_network *network);
diff --git a/src/network.c b/src/network.c
index 5a4eb766..85b601df 100644
--- a/src/network.c
+++ b/src/network.c
@@ -522,6 +522,17 @@ const char *__connman_network_get_type(struct connman_network *network)
 	return type2string(network->type);
 }
 
+/**
+ * connman_network_get_type:
+ * @network: network structure
+ *
+ * Get type of network
+ */
+enum connman_network_type connman_network_get_type(struct connman_network *network)
+{
+	return network->type;
+}
+
 /**
  * connman_network_get_identifier:
  * @network: network structure

commit 07b6b42bf350cba1887eb71dba1f654b86402c07
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 19:16:05 2009 +0200

    Use proper constants for service type

diff --git a/src/profile.c b/src/profile.c
index c94a7627..ce26c7ac 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -30,6 +30,13 @@
 
 #define PROFILE_DEFAULT  "/profile/default"
 
+enum connman_service_type {
+	CONNMAN_SERVICE_TYPE_UNKNOWN  = 0,
+	CONNMAN_SERVICE_TYPE_ETHERNET = 1,
+	CONNMAN_SERVICE_TYPE_WIFI     = 2,
+	CONNMAN_SERVICE_TYPE_WIMAX    = 3,
+};
+
 enum connman_service_state {
 	CONNMAN_SERVICE_STATE_UNKNOWN = 0,
 	CONNMAN_SERVICE_STATE_IDLE    = 1,
@@ -39,12 +46,12 @@ struct connman_group {
 	GSequenceIter *iter;
 	char *id;
 	char *path;
-	char *type;
 	char *name;
 	char *mode;
 	char *security;
 	connman_uint8_t strength;
 	connman_bool_t favorite;
+	enum connman_service_type type;
 	enum connman_service_state state;
 	struct connman_network *network;
 };
@@ -53,6 +60,22 @@ static GSequence *groups = NULL;
 
 static DBusConnection *connection = NULL;
 
+static const char *type2string(enum connman_service_type type)
+{
+	switch (type) {
+	case CONNMAN_SERVICE_TYPE_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_TYPE_ETHERNET:
+		return "ethernet";
+	case CONNMAN_SERVICE_TYPE_WIFI:
+		return "wifi";
+	case CONNMAN_SERVICE_TYPE_WIMAX:
+		return "wimax";
+	}
+
+	return NULL;
+}
+
 static const char *state2string(enum connman_service_state state)
 {
 	switch (state) {
@@ -86,15 +109,16 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
+	str = type2string(group->type);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
+
 	str = state2string(group->state);
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "State",
 						DBUS_TYPE_STRING, &str);
 
-	if (group->type != NULL)
-		connman_dbus_dict_append_variant(&dict, "Type",
-					DBUS_TYPE_STRING, &group->type);
-
 	if (group->name != NULL)
 		connman_dbus_dict_append_variant(&dict, "Name",
 					DBUS_TYPE_STRING, &group->name);
@@ -134,7 +158,11 @@ static DBusMessage *disconnect_service(DBusConnection *conn,
 static DBusMessage *remove_service(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
-	return __connman_error_not_implemented(msg);
+	struct connman_group *group = data;
+
+	group->favorite = FALSE;
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
 static DBusMessage *move_before(DBusConnection *conn,
@@ -243,7 +271,6 @@ static void free_group(gpointer data)
 	g_free(group->security);
 	g_free(group->mode);
 	g_free(group->name);
-	g_free(group->type);
 	g_free(group->path);
 	g_free(group->id);
 	g_free(group);
@@ -294,7 +321,7 @@ static struct connman_group *lookup_group(const char *name)
 
 	group->id = g_strdup(name);
 
-	group->type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
+	group->type = CONNMAN_SERVICE_TYPE_UNKNOWN;
 	group->path = g_strdup_printf("%s/%s", PROFILE_DEFAULT, name);
 
 	group->favorite = FALSE;
@@ -315,6 +342,29 @@ done:
 	return group;
 }
 
+static enum connman_service_type convert_device_type(struct connman_device *device)
+{
+	enum connman_device_type type = connman_device_get_type(device);
+
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_GPS:
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+		break;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		return CONNMAN_SERVICE_TYPE_ETHERNET;
+	}
+
+	return CONNMAN_SERVICE_TYPE_UNKNOWN;
+}
+
 int __connman_profile_add_device(struct connman_device *device)
 {
 	struct connman_group *group;
@@ -330,7 +380,7 @@ int __connman_profile_add_device(struct connman_device *device)
 	if (group == NULL)
 		return -EINVAL;
 
-	group->type = g_strdup(__connman_device_get_type(device));
+	group->type = convert_device_type(device);
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
 	emit_services_signal();
@@ -353,8 +403,7 @@ int __connman_profile_remove_device(struct connman_device *device)
 	if (group == NULL)
 		return -EINVAL;
 
-	g_free(group->type);
-	group->type = NULL;
+	group->type = CONNMAN_SERVICE_TYPE_UNKNOWN;
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
 	emit_services_signal();
@@ -362,6 +411,26 @@ int __connman_profile_remove_device(struct connman_device *device)
 	return 0;
 }
 
+static enum connman_service_type convert_network_type(struct connman_network *network)
+{
+	enum connman_network_type type = connman_network_get_type(network);
+
+	switch (type) {
+	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+	case CONNMAN_NETWORK_TYPE_VENDOR:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
+	case CONNMAN_NETWORK_TYPE_HSO:
+		break;
+	case CONNMAN_NETWORK_TYPE_WIFI:
+		return CONNMAN_SERVICE_TYPE_WIFI;
+	case CONNMAN_NETWORK_TYPE_WIMAX:
+		return CONNMAN_SERVICE_TYPE_WIMAX;
+	}
+
+	return CONNMAN_SERVICE_TYPE_UNKNOWN;
+}
+
 int __connman_profile_add_network(struct connman_network *network)
 {
 	struct connman_group *group;
@@ -380,10 +449,9 @@ int __connman_profile_add_network(struct connman_network *network)
 	if (group == NULL)
 		return -EINVAL;
 
-	g_free(group->type);
-	g_free(group->name);
+	group->type = convert_network_type(network);
 
-	group->type = g_strdup(__connman_network_get_type(network));
+	g_free(group->name);
 	group->name = g_strdup(connman_network_get_string(network, "Name"));
 
 	group->strength = connman_network_get_uint8(network, "Strength");
@@ -431,8 +499,7 @@ int __connman_profile_remove_network(struct connman_network *network)
 		group->network = NULL;
 	}
 
-	g_free(group->type);
-	group->type = NULL;
+	group->type = CONNMAN_SERVICE_TYPE_UNKNOWN;
 
 	g_sequence_sort_changed(group->iter, compare_group, NULL);
 	emit_services_signal();

commit 75970f6e60689bccb502f0977a482b8a9233bae1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 5 19:19:07 2009 +0200

    Add error checking for service methods

diff --git a/src/profile.c b/src/profile.c
index ce26c7ac..86b78f13 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -146,12 +146,22 @@ static DBusMessage *get_properties(DBusConnection *conn,
 static DBusMessage *connect_service(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_group *group = data;
+
+	if (group->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		return __connman_error_not_supported(msg);
+
 	return __connman_error_not_implemented(msg);
 }
 
 static DBusMessage *disconnect_service(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_group *group = data;
+
+	if (group->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		return __connman_error_not_supported(msg);
+
 	return __connman_error_not_implemented(msg);
 }
 
@@ -160,6 +170,9 @@ static DBusMessage *remove_service(DBusConnection *conn,
 {
 	struct connman_group *group = data;
 
+	if (group->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		return __connman_error_not_supported(msg);
+
 	group->favorite = FALSE;
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
@@ -168,12 +181,22 @@ static DBusMessage *remove_service(DBusConnection *conn,
 static DBusMessage *move_before(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_group *group = data;
+
+	if (group->favorite == FALSE)
+		return __connman_error_not_supported(msg);
+
 	return __connman_error_not_implemented(msg);
 }
 
 static DBusMessage *move_after(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
+	struct connman_group *group = data;
+
+	if (group->favorite == FALSE)
+		return __connman_error_not_supported(msg);
+
 	return __connman_error_not_implemented(msg);
 }
 

commit 836075a8d9279ffadccfb1f5c3c0cf56f51d1a95
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 6 09:01:37 2009 +0200

    Add support for handling carrier updates from devices

diff --git a/src/connman.h b/src/connman.h
index 220eb051..2299c495 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -186,6 +186,8 @@ int __connman_device_set_offlinemode(connman_bool_t offlinemode);
 
 int __connman_profile_add_device(struct connman_device *device);
 int __connman_profile_remove_device(struct connman_device *device);
+int __connman_profile_set_carrier(struct connman_device *device,
+						connman_bool_t carrier);
 
 #include <connman/network.h>
 
diff --git a/src/device.c b/src/device.c
index b52fb7ea..e36aa6db 100644
--- a/src/device.c
+++ b/src/device.c
@@ -161,6 +161,8 @@ static enum connman_device_policy string2policy(const char *policy)
 
 static int set_carrier(struct connman_device *device, connman_bool_t carrier)
 {
+	__connman_profile_set_carrier(device, carrier);
+
 	if (carrier == TRUE) {
 		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 		struct connman_element *element;
diff --git a/src/profile.c b/src/profile.c
index 86b78f13..abb2d235 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -313,13 +313,6 @@ static gint compare_group(gconstpointer a, gconstpointer b, gpointer user_data)
 	return (gint) group_b->strength - (gint) group_a->strength;
 }
 
-static gint search_group(gconstpointer a, gconstpointer b, gpointer user_data)
-{
-	struct connman_group *group = (void *) a;
-
-	return g_strcmp0(group->id, user_data);
-}
-
 static struct connman_group *lookup_group(const char *name)
 {
 	GSequenceIter *iter;
@@ -330,11 +323,11 @@ static struct connman_group *lookup_group(const char *name)
 	if (name == NULL)
 		return NULL;
 
-	iter = g_sequence_search(groups, NULL, search_group, (char *) name);
-	if (g_sequence_iter_is_begin(iter) == FALSE &&
-				g_sequence_iter_is_end(iter) == FALSE) {
+	iter = g_sequence_get_begin_iter(groups);
+	while (g_sequence_iter_is_end(iter) == FALSE) {
 		group = g_sequence_get(iter);
-		if (group != NULL)
+
+		if (g_strcmp0(group->id, name) == 0)
 			goto done;
 	}
 
@@ -434,6 +427,33 @@ int __connman_profile_remove_device(struct connman_device *device)
 	return 0;
 }
 
+int __connman_profile_set_carrier(struct connman_device *device,
+						connman_bool_t carrier)
+{
+	struct connman_group *group;
+	char *name;
+
+	DBG("device %p carrier %d", device, carrier);
+
+	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
+					connman_device_get_index(device));
+	group = lookup_group(name);
+	g_free(name);
+
+	if (group == NULL)
+		return -EINVAL;
+
+	if (group->favorite == carrier)
+		return -EALREADY;
+
+	group->favorite = carrier;
+
+	g_sequence_sort_changed(group->iter, compare_group, NULL);
+	emit_services_signal();
+
+	return 0;
+}
+
 static enum connman_service_type convert_network_type(struct connman_network *network)
 {
 	enum connman_network_type type = connman_network_get_type(network);

commit 26e12e21762c8400f6d27410ec3bacfa70d1ef6b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 6 11:33:18 2009 +0200

    Fix compilation with old D-Bus 1.0.x installations

diff --git a/configure.ac b/configure.ac
index 16025ac6..80c4611f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -203,6 +203,9 @@ fi
 
 PKG_CHECK_MODULES(DBUS, dbus-1 >= 1.0, dummy=yes,
 				AC_MSG_ERROR(D-Bus >= 1.0 is required))
+AC_CHECK_LIB(dbus-1, dbus_watch_get_unix_fd, dummy=yes,
+	AC_DEFINE(NEED_DBUS_WATCH_GET_UNIX_FD, 1,
+		[Define to 1 if you need the dbus_watch_get_unix_fd() function.]))
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 DBUS_DATADIR="`$PKG_CONFIG --variable=sysconfdir dbus-1`"

commit c9853debe7ca68ce1a2973259790a53128aed58e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 8 00:32:06 2009 +0200

    Add missing service states

diff --git a/src/profile.c b/src/profile.c
index abb2d235..cf98d88e 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -38,8 +38,13 @@ enum connman_service_type {
 };
 
 enum connman_service_state {
-	CONNMAN_SERVICE_STATE_UNKNOWN = 0,
-	CONNMAN_SERVICE_STATE_IDLE    = 1,
+	CONNMAN_SERVICE_STATE_UNKNOWN       = 0,
+	CONNMAN_SERVICE_STATE_IDLE          = 1,
+	CONNMAN_SERVICE_STATE_ASSOCIATION   = 2,
+	CONNMAN_SERVICE_STATE_CONFIGURATION = 3,
+	CONNMAN_SERVICE_STATE_READY         = 4,
+	CONNMAN_SERVICE_STATE_DISCONNECT    = 5,
+	CONNMAN_SERVICE_STATE_FAILURE       = 6,
 };
 
 struct connman_group {
@@ -83,6 +88,16 @@ static const char *state2string(enum connman_service_state state)
 		break;
 	case CONNMAN_SERVICE_STATE_IDLE:
 		return "idle";
+	case CONNMAN_SERVICE_STATE_ASSOCIATION:
+		return "association";
+	case CONNMAN_SERVICE_STATE_CONFIGURATION:
+		return "configuration";
+	case CONNMAN_SERVICE_STATE_READY:
+		return "ready";
+	case CONNMAN_SERVICE_STATE_DISCONNECT:
+		return "disconnect";
+	case CONNMAN_SERVICE_STATE_FAILURE:
+		return "failure";
 	}
 
 	return NULL;

commit 4717a5b5f1d98b0ab28c2c8b2284d4e02a025729
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 8 00:35:31 2009 +0200

    Add skeleton for service interface details

diff --git a/src/Makefile.am b/src/Makefile.am
index 897d5738..e0ccdae1 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -8,9 +8,10 @@ endif
 sbin_PROGRAMS = connmand
 
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
-			profile.c element.c device.c network.c connection.c \
-			security.c resolver.c notifier.c storage.c manager.c \
-			agent.c ipv4.c detect.c rtnl.c dbus.c
+			element.c device.c network.c connection.c \
+			manager.c profile.c service.c agent.c \
+			security.c resolver.c notifier.c storage.c \
+			ipv4.c detect.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/service.c b/src/service.c
new file mode 100644
index 00000000..97a6592a
--- /dev/null
+++ b/src/service.c
@@ -0,0 +1,26 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"

commit e6cadc10b7dfba48247876ad8d99e86de84d4ef4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 7 15:43:15 2009 -0700

    Add skeleton for service interface includes

diff --git a/include/Makefile.am b/include/Makefile.am
index a13ef802..25f9b301 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -6,7 +6,8 @@ include_HEADERS = types.h log.h plugin.h security.h resolver.h \
 
 nodist_include_HEADERS = version.h
 
-noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h
+noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h \
+								service.h
 
 MAINTAINERCLEANFILES = Makefile.in
 
diff --git a/include/service.h b/include/service.h
new file mode 100644
index 00000000..a056e7ee
--- /dev/null
+++ b/include/service.h
@@ -0,0 +1,39 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_SERVICE_H
+#define __CONNMAN_SERVICE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * SECTION:service
+ * @title: Service premitives
+ * @short_description: Functions for handling services
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_SERVICE_H */
diff --git a/src/connman.h b/src/connman.h
index 2299c495..44cba117 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -207,6 +207,8 @@ const char *__connman_network_get_group(struct connman_network *network);
 int __connman_profile_add_network(struct connman_network *network);
 int __connman_profile_remove_network(struct connman_network *network);
 
+#include <connman/service.h>
+
 #include <connman/notifier.h>
 
 int __connman_notifier_init(void);

commit bf2d48f979ee50656bf080111a8a5b506e4d69a0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 7 15:44:47 2009 -0700

    Move service type and state declarations to header file

diff --git a/include/service.h b/include/service.h
index a056e7ee..c285e772 100644
--- a/include/service.h
+++ b/include/service.h
@@ -32,6 +32,23 @@ extern "C" {
  * @short_description: Functions for handling services
  */
 
+enum connman_service_type {
+	CONNMAN_SERVICE_TYPE_UNKNOWN  = 0,
+	CONNMAN_SERVICE_TYPE_ETHERNET = 1,
+	CONNMAN_SERVICE_TYPE_WIFI     = 2,
+	CONNMAN_SERVICE_TYPE_WIMAX    = 3,
+};
+
+enum connman_service_state {
+	CONNMAN_SERVICE_STATE_UNKNOWN       = 0,
+	CONNMAN_SERVICE_STATE_IDLE          = 1,
+	CONNMAN_SERVICE_STATE_ASSOCIATION   = 2,
+	CONNMAN_SERVICE_STATE_CONFIGURATION = 3,
+	CONNMAN_SERVICE_STATE_READY         = 4,
+	CONNMAN_SERVICE_STATE_DISCONNECT    = 5,
+	CONNMAN_SERVICE_STATE_FAILURE       = 6,
+};
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/profile.c b/src/profile.c
index cf98d88e..db108285 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -30,23 +30,6 @@
 
 #define PROFILE_DEFAULT  "/profile/default"
 
-enum connman_service_type {
-	CONNMAN_SERVICE_TYPE_UNKNOWN  = 0,
-	CONNMAN_SERVICE_TYPE_ETHERNET = 1,
-	CONNMAN_SERVICE_TYPE_WIFI     = 2,
-	CONNMAN_SERVICE_TYPE_WIMAX    = 3,
-};
-
-enum connman_service_state {
-	CONNMAN_SERVICE_STATE_UNKNOWN       = 0,
-	CONNMAN_SERVICE_STATE_IDLE          = 1,
-	CONNMAN_SERVICE_STATE_ASSOCIATION   = 2,
-	CONNMAN_SERVICE_STATE_CONFIGURATION = 3,
-	CONNMAN_SERVICE_STATE_READY         = 4,
-	CONNMAN_SERVICE_STATE_DISCONNECT    = 5,
-	CONNMAN_SERVICE_STATE_FAILURE       = 6,
-};
-
 struct connman_group {
 	GSequenceIter *iter;
 	char *id;

commit 5ba5124850c59503bc8f08ace4beb707254e59da
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 7 15:49:01 2009 -0700

    Add definition for service structure

diff --git a/include/service.h b/include/service.h
index c285e772..33994c9e 100644
--- a/include/service.h
+++ b/include/service.h
@@ -49,6 +49,8 @@ enum connman_service_state {
 	CONNMAN_SERVICE_STATE_FAILURE       = 6,
 };
 
+struct connman_service;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/service.c b/src/service.c
index 97a6592a..1ca6fb1b 100644
--- a/src/service.c
+++ b/src/service.c
@@ -24,3 +24,9 @@
 #endif
 
 #include "connman.h"
+
+struct connman_service {
+	enum connman_service_type type;
+	enum connman_service_state state;
+	char *path;
+};

commit 5a5a93105bd1e2e70044b4d466a7a37ec696c94d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 7 15:56:31 2009 -0700

    Add definitions for service mode and security settings

diff --git a/include/service.h b/include/service.h
index 33994c9e..9e97cf63 100644
--- a/include/service.h
+++ b/include/service.h
@@ -39,6 +39,20 @@ enum connman_service_type {
 	CONNMAN_SERVICE_TYPE_WIMAX    = 3,
 };
 
+enum connman_service_mode {
+	CONNMAN_SERVICE_MODE_UNKNOWN = 0,
+	CONNMAN_SERVICE_MODE_MANAGED = 1,
+	CONNMAN_SERVICE_MODE_ADHOC   = 2,
+};
+
+enum connman_service_security {
+	CONNMAN_SERVICE_SECURITY_UNKNOWN = 0,
+	CONNMAN_SERVICE_SECURITY_NONE    = 1,
+	CONNMAN_SERVICE_SECURITY_WEP     = 2,
+	CONNMAN_SERVICE_SECURITY_WPA     = 3,
+	CONNMAN_SERVICE_SECURITY_WPA2    = 4,
+};
+
 enum connman_service_state {
 	CONNMAN_SERVICE_STATE_UNKNOWN       = 0,
 	CONNMAN_SERVICE_STATE_IDLE          = 1,
diff --git a/src/service.c b/src/service.c
index 1ca6fb1b..f272fe37 100644
--- a/src/service.c
+++ b/src/service.c
@@ -26,7 +26,12 @@
 #include "connman.h"
 
 struct connman_service {
+	char *path;
 	enum connman_service_type type;
+	enum connman_service_mode mode;
+	enum connman_service_security security;
 	enum connman_service_state state;
-	char *path;
+	connman_uint8_t strength;
+	connman_bool_t favorite;
+	char *name;
 };

commit c6dc4196705b7b93e11b6687b10cc49a7f038c34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 7 16:54:19 2009 -0700

    Add service initialization and lifetime tracking support

diff --git a/include/service.h b/include/service.h
index 9e97cf63..e83911c9 100644
--- a/include/service.h
+++ b/include/service.h
@@ -65,6 +65,9 @@ enum connman_service_state {
 
 struct connman_service;
 
+extern struct connman_service *connman_service_get(const char *identifier);
+extern void connman_service_put(struct connman_service *service);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/connman.h b/src/connman.h
index 44cba117..a97dfadd 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -209,6 +209,9 @@ int __connman_profile_remove_network(struct connman_network *network);
 
 #include <connman/service.h>
 
+int __connman_service_init(void);
+void __connman_service_cleanup(void);
+
 #include <connman/notifier.h>
 
 int __connman_notifier_init(void);
diff --git a/src/element.c b/src/element.c
index b68e954e..7b24a98e 100644
--- a/src/element.c
+++ b/src/element.c
@@ -1284,6 +1284,7 @@ int __connman_element_init(DBusConnection *conn, const char *device,
 	element_root = g_node_new(element);
 
 	__connman_notifier_init();
+	__connman_service_init();
 	__connman_network_init();
 	__connman_device_init();
 
@@ -1368,6 +1369,7 @@ void __connman_element_cleanup(void)
 
 	__connman_device_cleanup();
 	__connman_network_cleanup();
+	__connman_service_cleanup();
 	__connman_notifier_cleanup();
 
 	g_node_traverse(element_root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
diff --git a/src/service.c b/src/service.c
index f272fe37..9c95fc6e 100644
--- a/src/service.c
+++ b/src/service.c
@@ -25,7 +25,14 @@
 
 #include "connman.h"
 
+static DBusConnection *connection = NULL;
+
+static GSequence *service_list = NULL;
+static GHashTable *service_hash = NULL;
+
 struct connman_service {
+	gint refcount;
+	char *identifier;
 	char *path;
 	enum connman_service_type type;
 	enum connman_service_mode mode;
@@ -35,3 +42,104 @@ struct connman_service {
 	connman_bool_t favorite;
 	char *name;
 };
+
+static void service_free(gpointer data)
+{
+	struct connman_service *service = data;
+
+	DBG("service %p", service);
+
+	g_hash_table_remove(service_hash, service->identifier);
+
+	g_free(service->name);
+	g_free(service->path);
+	g_free(service->identifier);
+	g_free(service);
+}
+
+static gint service_compare(gconstpointer a, gconstpointer b,
+							gpointer user_data)
+{
+	struct connman_service *service_a = (void *) a;
+	struct connman_service *service_b = (void *) b;
+
+	if (service_a->favorite == TRUE && service_b->favorite == FALSE)
+		return -1;
+
+	if (service_a->favorite == FALSE && service_b->favorite == TRUE)
+		return 1;
+
+	return (gint) service_b->strength - (gint) service_a->strength;
+}
+
+struct connman_service *connman_service_get(const char *identifier)
+{
+	struct connman_service *service;
+	GSequenceIter *iter;
+
+	iter = g_hash_table_lookup(service_hash, identifier);
+	if (iter != NULL) {
+		service = g_sequence_get(iter);
+		if (service != NULL)
+			g_atomic_int_inc(&service->refcount);
+		return service;
+	}
+
+	service = g_try_new0(struct connman_service, 1);
+	if (service == NULL)
+		return NULL;
+
+	DBG("service %p", service);
+
+	service->refcount = 1;
+	service->identifier = g_strdup(identifier);
+
+	iter = g_sequence_insert_sorted(service_list, service,
+                                                service_compare, NULL);
+
+	g_hash_table_insert(service_hash, service->identifier, iter);
+
+	return service;
+}
+
+void connman_service_put(struct connman_service *service)
+{
+	DBG("service %p", service);
+
+	if (g_atomic_int_dec_and_test(&service->refcount) == TRUE) {
+		GSequenceIter *iter;
+
+		iter = g_hash_table_lookup(service_hash, service->identifier);
+		if (iter != NULL)
+			g_sequence_remove(iter);
+		else
+			service_free(service);
+	}
+}
+
+int __connman_service_init(void)
+{
+	DBG("");
+
+	connection = connman_dbus_get_connection();
+
+	service_hash = g_hash_table_new_full(g_str_hash, g_str_equal,
+								NULL, NULL);
+
+	service_list = g_sequence_new(service_free);
+
+	return 0;
+}
+
+void __connman_service_cleanup(void)
+{
+	DBG("");
+
+	g_sequence_free(service_list);
+	service_list = NULL;
+
+	g_hash_table_destroy(service_hash);
+	service_hash = NULL;
+
+	dbus_connection_unref(connection);
+}

commit 7815bbdbccbe426f743a711a72d48bba93ec2f4a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 10 06:48:49 2009 -0700

    Update Intel OSPM support to latest specification

diff --git a/plugins/iospm.c b/plugins/iospm.c
index b967d4bd..af6250bd 100644
--- a/plugins/iospm.c
+++ b/plugins/iospm.c
@@ -30,32 +30,27 @@
 #include <connman/log.h>
 
 #define IOSPM_SERVICE		"com.intel.mid.ospm"
-#define IOSPM_INTERFACE		IOSPM_SERVICE ".MMF"
+#define IOSPM_INTERFACE		IOSPM_SERVICE ".Comms"
 
+#define IOSPM_BLUETOOTH		"/com/intel/mid/ospm/bluetooth"
 #define IOSPM_FLIGHT_MODE	"/com/intel/mid/ospm/flight_mode"
 
 static DBusConnection *connection;
 
-static void iospm_device_enabled(enum connman_device_type type,
-						connman_bool_t enabled)
-{
-	DBG("type %d enabled %d", type, enabled);
-}
-
-static void iospm_offline_mode(connman_bool_t enabled)
+static void send_indication(const char *path, connman_bool_t enabled)
 {
 	DBusMessage *message;
 	const char *method;
 
-	DBG("enabled %d", enabled);
+	DBG("path %s enabled %d", path, enabled);
 
 	if (enabled == TRUE)
 		method = "IndicateStart";
 	else
 		method = "IndicateStop";
 
-	message = dbus_message_new_method_call(IOSPM_SERVICE,
-				IOSPM_FLIGHT_MODE, IOSPM_INTERFACE, method);
+	message = dbus_message_new_method_call(IOSPM_SERVICE, path,
+						IOSPM_INTERFACE, method);
 	if (message == NULL)
 		return;
 
@@ -66,6 +61,32 @@ static void iospm_offline_mode(connman_bool_t enabled)
 	dbus_message_unref(message);
 }
 
+static void iospm_device_enabled(enum connman_device_type type,
+						connman_bool_t enabled)
+{
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_GPS:
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+		break;
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+		send_indication(IOSPM_BLUETOOTH, enabled);
+		break;
+	}
+}
+
+static void iospm_offline_mode(connman_bool_t enabled)
+{
+	send_indication(IOSPM_FLIGHT_MODE, enabled);
+}
+
 static struct connman_notifier iospm_notifier = {
 	.name		= "iospm",
 	.priority	= CONNMAN_NOTIFIER_PRIORITY_DEFAULT,

commit 18d986264ac2c908ef4b709cb7493e4f5525b9ba
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 12 18:47:01 2009 +0200

    Fix coding style mistake

diff --git a/src/service.c b/src/service.c
index 9c95fc6e..9fed4515 100644
--- a/src/service.c
+++ b/src/service.c
@@ -95,7 +95,7 @@ struct connman_service *connman_service_get(const char *identifier)
 	service->identifier = g_strdup(identifier);
 
 	iter = g_sequence_insert_sorted(service_list, service,
-                                                service_compare, NULL);
+						service_compare, NULL);
 
 	g_hash_table_insert(service_hash, service->identifier, iter);
 

commit 5b0124db48a7ba6f4f704c546a48e3298941aae3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 12 18:59:29 2009 +0200

    Add service creation and reference counting functions

diff --git a/include/service.h b/include/service.h
index e83911c9..17f46b87 100644
--- a/include/service.h
+++ b/include/service.h
@@ -65,6 +65,10 @@ enum connman_service_state {
 
 struct connman_service;
 
+extern struct connman_service *connman_service_create(void);
+extern struct connman_service *connman_service_ref(struct connman_service *service);
+extern void connman_service_unref(struct connman_service *service);
+
 extern struct connman_service *connman_service_get(const char *identifier);
 extern void connman_service_put(struct connman_service *service);
 
diff --git a/src/service.c b/src/service.c
index 9fed4515..b921f5fc 100644
--- a/src/service.c
+++ b/src/service.c
@@ -57,6 +57,81 @@ static void service_free(gpointer data)
 	g_free(service);
 }
 
+void connman_service_put(struct connman_service *service)
+{
+	DBG("service %p", service);
+
+	if (g_atomic_int_dec_and_test(&service->refcount) == TRUE) {
+		GSequenceIter *iter;
+
+		iter = g_hash_table_lookup(service_hash, service->identifier);
+		if (iter != NULL)
+			g_sequence_remove(iter);
+		else
+			service_free(service);
+	}
+}
+
+static void __connman_service_initialize(struct connman_service *service)
+{
+	DBG("service %p", service);
+
+	service->refcount = 1;
+
+	service->type     = CONNMAN_SERVICE_TYPE_UNKNOWN;
+	service->mode     = CONNMAN_SERVICE_MODE_UNKNOWN;
+	service->security = CONNMAN_SERVICE_SECURITY_UNKNOWN;
+	service->state    = CONNMAN_SERVICE_STATE_UNKNOWN;
+
+	service->favorite = FALSE;
+}
+
+/**
+ * connman_service_create:
+ *
+ * Allocate a new service.
+ *
+ * Returns: a newly-allocated #connman_service structure
+ */
+struct connman_service *connman_service_create(void)
+{
+	struct connman_service *service;
+
+	service = g_try_new0(struct connman_service, 1);
+	if (service == NULL)
+		return NULL;
+
+	DBG("service %p", service);
+
+	__connman_service_initialize(service);
+
+	return service;
+}
+
+/**
+ * connman_service_ref:
+ * @service: service structure
+ *
+ * Increase reference counter of service
+ */
+struct connman_service *connman_service_ref(struct connman_service *service)
+{
+	g_atomic_int_inc(&service->refcount);
+
+	return service;
+}
+
+/**
+ * connman_service_unref:
+ * @service: service structure
+ *
+ * Decrease reference counter of service
+ */
+void connman_service_unref(struct connman_service *service)
+{
+	connman_service_put(service);
+}
+
 static gint service_compare(gconstpointer a, gconstpointer b,
 							gpointer user_data)
 {
@@ -91,7 +166,8 @@ struct connman_service *connman_service_get(const char *identifier)
 
 	DBG("service %p", service);
 
-	service->refcount = 1;
+	__connman_service_initialize(service);
+
 	service->identifier = g_strdup(identifier);
 
 	iter = g_sequence_insert_sorted(service_list, service,
@@ -102,21 +178,6 @@ struct connman_service *connman_service_get(const char *identifier)
 	return service;
 }
 
-void connman_service_put(struct connman_service *service)
-{
-	DBG("service %p", service);
-
-	if (g_atomic_int_dec_and_test(&service->refcount) == TRUE) {
-		GSequenceIter *iter;
-
-		iter = g_hash_table_lookup(service_hash, service->identifier);
-		if (iter != NULL)
-			g_sequence_remove(iter);
-		else
-			service_free(service);
-	}
-}
-
 int __connman_service_init(void)
 {
 	DBG("");

commit 37fbd0590c56f5386bf16710568f6adf7153177c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 12 19:52:14 2009 +0200

    Add basic IP configuration framework

diff --git a/include/Makefile.am b/include/Makefile.am
index 25f9b301..d6dbc30c 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,7 +1,7 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = types.h log.h plugin.h security.h resolver.h \
+include_HEADERS = types.h log.h plugin.h security.h resolver.h ipconfig.h \
 				storage.h device.h network.h notifier.h
 
 nodist_include_HEADERS = version.h
diff --git a/include/ipconfig.h b/include/ipconfig.h
new file mode 100644
index 00000000..9e92c69d
--- /dev/null
+++ b/include/ipconfig.h
@@ -0,0 +1,54 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_IPCONFIG_H
+#define __CONNMAN_IPCONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * SECTION:ipconfig
+ * @title: IP configuration premitives
+ * @short_description: Functions for registering IP configuration modules
+ */
+
+#define CONNMAN_IPCONFIG_PRIORITY_LOW      -100
+#define CONNMAN_IPCONFIG_PRIORITY_DEFAULT     0
+#define CONNMAN_IPCONFIG_PRIORITY_HIGH      100
+
+struct connman_ipconfig {
+	const char *name;
+	int priority;
+	int (*request) (const char *interface);
+	int (*release) (const char *interface);
+	int (*renew) (const char *interface);
+};
+
+extern int connman_ipconfig_register(struct connman_ipconfig *ipconfig);
+extern void connman_ipconfig_unregister(struct connman_ipconfig *ipconfig);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CONNMAN_IPCONFIG_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index e0ccdae1..9051c7f0 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -10,8 +10,8 @@ sbin_PROGRAMS = connmand
 connmand_SOURCES = main.c connman.h log.c selftest.c error.c plugin.c \
 			element.c device.c network.c connection.c \
 			manager.c profile.c service.c agent.c \
-			security.c resolver.c notifier.c storage.c \
-			ipv4.c detect.c rtnl.c dbus.c
+			security.c resolver.c ipconfig.c notifier.c \
+			storage.c ipv4.c detect.c rtnl.c dbus.c
 
 if UDEV
 connmand_SOURCES += udev.c
diff --git a/src/connman.h b/src/connman.h
index a97dfadd..67f75205 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -79,6 +79,8 @@ int __connman_security_check_privilege(DBusMessage *message,
 const char *__connman_ipv4_method2string(enum connman_ipv4_method method);
 enum connman_ipv4_method __connman_ipv4_string2method(const char *method);
 
+#include <connman/ipconfig.h>
+
 #include <connman/resolver.h>
 
 int __connman_resolver_init(void);
diff --git a/src/ipconfig.c b/src/ipconfig.c
new file mode 100644
index 00000000..1c8f2962
--- /dev/null
+++ b/src/ipconfig.c
@@ -0,0 +1,67 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connman.h"
+
+static GSList *ipconfig_list = NULL;
+
+static gint compare_priority(gconstpointer a, gconstpointer b)
+{
+	const struct connman_ipconfig *ipconfig1 = a;
+	const struct connman_ipconfig *ipconfig2 = b;
+
+	return ipconfig2->priority - ipconfig1->priority;
+}
+
+/**
+ * connman_ipconfig_register:
+ * @ipconfig: IP configuration module
+ *
+ * Register a new IP configuration module
+ *
+ * Returns: %0 on success
+ */
+int connman_ipconfig_register(struct connman_ipconfig *ipconfig)
+{
+	DBG("ipconfig %p name %s", ipconfig, ipconfig->name);
+
+	ipconfig_list = g_slist_insert_sorted(ipconfig_list, ipconfig,
+							compare_priority);
+
+	return 0;
+}
+
+/**
+ * connman_ipconfig_unregister:
+ * @ipconfig: IP configuration module
+ *
+ * Remove a previously registered IP configuration module.
+ */
+void connman_ipconfig_unregister(struct connman_ipconfig *ipconfig)
+{
+	DBG("ipconfig %p name %s", ipconfig, ipconfig->name);
+
+	ipconfig_list = g_slist_remove(ipconfig_list, ipconfig);
+}

commit 108ff92b0cec1940f8070e5722a41c222c990be5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 12 19:53:38 2009 +0200

    Don't install resolver and IP configuration headers

diff --git a/include/Makefile.am b/include/Makefile.am
index d6dbc30c..dce9b36b 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -1,13 +1,13 @@
 
 includedir = @includedir@/connman
 
-include_HEADERS = types.h log.h plugin.h security.h resolver.h ipconfig.h \
-				storage.h device.h network.h notifier.h
+include_HEADERS = types.h log.h plugin.h security.h notifier.h \
+					storage.h device.h network.h
 
 nodist_include_HEADERS = version.h
 
 noinst_HEADERS = driver.h element.h property.h ipv4.h rtnl.h dbus.h \
-								service.h
+					resolver.h ipconfig.h service.h
 
 MAINTAINERCLEANFILES = Makefile.in
 

commit b5d62db6c6af99a6dba2e0ec7738015a0e8439e1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 15:44:35 2009 +0200

    Fix handling of DHCP results with no nameserver

diff --git a/src/resolver.c b/src/resolver.c
index 481369e2..3a11fe71 100644
--- a/src/resolver.c
+++ b/src/resolver.c
@@ -149,6 +149,9 @@ int connman_resolver_append(const char *interface, const char *domain,
 
 	DBG("interface %s domain %s server %s", interface, domain, server);
 
+	if (server == NULL)
+		return -EINVAL;
+
 	entry = g_try_new0(struct entry_data, 1);
 	if (entry == NULL)
 		return -ENOMEM;

commit 7f8a4d27747012b3d3c5ec85b2cbff4892dc9fa4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 15:47:40 2009 +0200

    Add extra warning if no nameserver is defined

diff --git a/src/ipv4.c b/src/ipv4.c
index 4518d97c..b670cfdb 100644
--- a/src/ipv4.c
+++ b/src/ipv4.c
@@ -92,6 +92,9 @@ static int set_ipv4(struct connman_element *element,
 
 	close(sk);
 
+	if (nameserver == NULL)
+		connman_error("No nameserver for %s defined", ifr.ifr_name);
+
 	connman_resolver_append(ifr.ifr_name, NULL, nameserver);
 
 	return 0;

commit 81d9a32d97f33764969acc5e39a80ad9836ec6b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 15:54:52 2009 +0200

    Add error message for network and device storing failures

diff --git a/src/device.c b/src/device.c
index e36aa6db..bb9abf5f 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1913,7 +1913,8 @@ update:
 
 	data = g_key_file_to_data(keyfile, &length, NULL);
 
-	g_file_set_contents(pathname, data, length, NULL);
+	if (g_file_set_contents(pathname, data, length, NULL) == FALSE)
+		connman_error("Failed to store device information");
 
 done:
 	g_free(data);
diff --git a/src/network.c b/src/network.c
index 85b601df..f5e512e9 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1281,7 +1281,8 @@ update:
 
 	data = g_key_file_to_data(keyfile, &length, NULL);
 
-	g_file_set_contents(pathname, data, length, NULL);
+	if (g_file_set_contents(pathname, data, length, NULL) == FALSE)
+		connman_error("Failed to store network information");
 
 done:
 	g_free(data);

commit 97555b09dfe9af258eda343373837c0c88d54475
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 16:03:31 2009 +0200

    Remove gateway from list when switching connections

diff --git a/src/connection.c b/src/connection.c
index 79890dc3..62d6a31d 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -63,6 +63,17 @@ static struct gateway_data *find_gateway(int index, const char *gateway)
 	return NULL;
 }
 
+static void remove_gateway(int index, const char *gateway)
+{
+	struct gateway_data *data;
+
+	data = find_gateway(index, gateway);
+	if (data == NULL)
+		return;
+
+	gateway_list = g_slist_remove(gateway_list, data);
+}
+
 static int set_route(struct connman_element *element, const char *gateway)
 {
 	struct ifreq ifr;
@@ -512,6 +523,8 @@ static void connection_remove(struct connman_element *element)
 	if (gateway == NULL)
 		return;
 
+	remove_gateway(element->index, gateway);
+
 	connman_element_set_enabled(element, FALSE);
 	emit_default_signal(element);
 

commit d3e4c9c49a4baaf568ff8955ce42bafbcede8f8f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 22:19:43 2009 +0200

    Fix infinite loop for service lookup

diff --git a/src/profile.c b/src/profile.c
index db108285..2afba3fe 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -327,6 +327,8 @@ static struct connman_group *lookup_group(const char *name)
 
 		if (g_strcmp0(group->id, name) == 0)
 			goto done;
+
+		iter = g_sequence_iter_next(iter);
 	}
 
 	group = g_try_new0(struct connman_group, 1);

commit 2cf1a67e444cb3aadefd2b1df970a5269c49e3ce
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 23:11:58 2009 +0200

    Add error reporting for state and storage directory creation

diff --git a/src/main.c b/src/main.c
index 457776c2..56537e12 100644
--- a/src/main.c
+++ b/src/main.c
@@ -127,11 +127,17 @@ int main(int argc, char *argv[])
 		}
 	}
 
-	mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
-			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+	if (mkdir(STATEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
+				S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0) {
+		if (errno != EEXIST)
+			perror("Failed to create state directory");
+	}
 
-	mkdir(STORAGEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
-			S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+	if (mkdir(STORAGEDIR, S_IRUSR | S_IWUSR | S_IXUSR |
+				S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0) {
+		if (errno != EEXIST)
+			perror("Failed to create storage directory");
+	}
 
 	main_loop = g_main_loop_new(NULL, FALSE);
 

commit ac792e3fc9eef253d90363fa30216f72f8720481
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 13 23:40:57 2009 +0200

    Show message when ignoring VMware or VirtualBox interfaces

diff --git a/src/detect.c b/src/detect.c
index b0963182..9f3895df 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -203,18 +203,18 @@ static void detect_newlink(unsigned short type, int index,
 
 		sk = socket(PF_INET, SOCK_DGRAM, 0);
 
-		if (g_str_has_prefix(devname, "bnep") == TRUE)
+		if (g_str_has_prefix(devname, "vmnet") == TRUE ||
+				g_str_has_prefix(devname, "vboxnet") == TRUE) {
+			connman_info("Ignoring network interface %s", devname);
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else if (g_str_has_prefix(devname, "wmx") == TRUE)
+		} else if (g_str_has_prefix(devname, "bnep") == TRUE)
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else if (g_str_has_prefix(devname, "vmnet") == TRUE)
+		else if (g_str_has_prefix(devname, "wmx") == TRUE)
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else if (g_str_has_prefix(devname, "vboxnet") == TRUE)
+		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (stat(bridge_path, &st) == 0 && (st.st_mode & S_IFDIR))
 			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
-		else if (stat(wimax_path, &st) == 0 && (st.st_mode & S_IFDIR))
-			devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 		else if (ioctl(sk, SIOCGIWNAME, &iwr) == 0)
 			devtype = CONNMAN_DEVICE_TYPE_WIFI;
 		else

commit f873eb00ff71c39de436f7e863acac74174a5758
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 16 05:55:45 2009 +0200

    Add search domain support to DNS proxy

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index fb4411d2..b682d82d 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -37,8 +37,45 @@
 
 #include <glib.h>
 
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+struct domain_hdr {
+	uint16_t id;
+	uint8_t rd:1;
+	uint8_t tc:1;
+	uint8_t aa:1;
+	uint8_t opcode:4;
+	uint8_t qr:1;
+	uint8_t rcode:4;
+	uint8_t z:3;
+	uint8_t ra:1;
+	uint16_t qdcount;
+	uint16_t ancount;
+	uint16_t nscount;
+	uint16_t arcount;
+} __attribute__ ((packed));
+#elif __BYTE_ORDER == __BIG_ENDIAN
+struct domain_hdr {
+	uint16_t id;
+	uint8_t qr:1;
+	uint8_t opcode:4;
+	uint8_t aa:1;
+	uint8_t tc:1;
+	uint8_t rd:1;
+	uint8_t ra:1;
+	uint8_t z:3;
+	uint8_t rcode:4;
+	uint16_t qdcount;
+	uint16_t ancount;
+	uint16_t nscount;
+	uint16_t arcount;
+} __attribute__ ((packed));
+#else
+#error "Unknown byte order"
+#endif
+
 struct server_data {
 	char *interface;
+	char *domain;
 	char *server;
 	GIOChannel *channel;
 	guint watch;
@@ -47,11 +84,19 @@ struct server_data {
 struct request_data {
 	struct sockaddr_in sin;
 	socklen_t len;
-	guint16 id;
+	guint16 srcid;
+	guint16 dstid;
+	guint16 altid;
+	guint timeout;
+	guint numserv;
+	guint numresp;
+	gpointer resp;
+	gsize resplen;
 };
 
 static GSList *server_list = NULL;
 static GSList *request_list = NULL;
+static guint16 request_id = 0x0000;
 
 static GIOChannel *listener_channel = NULL;
 static guint listener_watch = 0;
@@ -61,17 +106,17 @@ static struct request_data *find_request(guint16 id)
 	GSList *list;
 
 	for (list = request_list; list; list = list->next) {
-		struct request_data *data = list->data;
+		struct request_data *req = list->data;
 
-		if (data->id == id)
-			return data;
+		if (req->dstid == id || req->altid == id)
+			return req;
 	}
 
 	return NULL;
 }
 
 static struct server_data *find_server(const char *interface,
-							const char *server)
+					const char *domain, const char *server)
 {
 	GSList *list;
 
@@ -84,8 +129,16 @@ static struct server_data *find_server(const char *interface,
 			continue;
 
 		if (g_str_equal(data->interface, interface) == TRUE &&
-				g_str_equal(data->server, server) == TRUE)
-			return data;
+				g_str_equal(data->server, server) == TRUE) {
+			if (domain == NULL) {
+				if (data->domain == NULL)
+					return data;
+				continue;
+			}
+
+			if (g_str_equal(data->domain, domain) == TRUE)
+				return data;
+		}
 	}
 
 	return NULL;
@@ -97,6 +150,7 @@ static gboolean server_event(GIOChannel *channel, GIOCondition condition,
 	struct server_data *data = user_data;
 	struct request_data *req;
 	unsigned char buf[768];
+	struct domain_hdr *hdr = (void *) &buf;
 	int sk, err, len;
 
 	if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
@@ -108,7 +162,7 @@ static gboolean server_event(GIOChannel *channel, GIOCondition condition,
 	sk = g_io_channel_unix_get_fd(channel);
 
 	len = recv(sk, buf, sizeof(buf), 0);
-	if (len < 2)
+	if (len < 12)
 		return TRUE;
 
 	DBG("Received %d bytes (id 0x%04x)", len, buf[0] | buf[1] << 8);
@@ -117,19 +171,46 @@ static gboolean server_event(GIOChannel *channel, GIOCondition condition,
 	if (req == NULL)
 		return TRUE;
 
+	DBG("id 0x%04x rcode %d", hdr->id, hdr->rcode);
+
+	buf[0] = req->srcid & 0xff;
+	buf[1] = req->srcid >> 8;
+
+	req->numresp++;
+
+	if (hdr->rcode == 0 || req->resp == NULL) {
+		g_free(req->resp);
+		req->resplen = 0;
+
+		req->resp = g_try_malloc(len);
+		if (req->resp == NULL)
+			return TRUE;
+
+		memcpy(req->resp, buf, len);
+		req->resplen = len;
+	}
+
+	if (hdr->rcode > 0 && req->numresp < req->numserv)
+		return TRUE;
+
+	if (req->timeout > 0)
+		g_source_remove(req->timeout);
+
 	request_list = g_slist_remove(request_list, req);
 
 	sk = g_io_channel_unix_get_fd(listener_channel);
 
-	err = sendto(sk, buf, len, 0, (struct sockaddr *) &req->sin, req->len);
+	err = sendto(sk, req->resp, req->resplen, 0,
+				(struct sockaddr *) &req->sin, req->len);
 
+	g_free(req->resp);
 	g_free(req);
 
 	return TRUE;
 }
 
 static struct server_data *create_server(const char *interface,
-							const char *server)
+					const char *domain, const char *server)
 {
 	struct server_data *data;
 	struct sockaddr_in sin;
@@ -183,6 +264,7 @@ static struct server_data *create_server(const char *interface,
 							server_event, data);
 
 	data->interface = g_strdup(interface);
+	data->domain = g_strdup(domain);
 	data->server = g_strdup(server);
 
 	return data;
@@ -197,8 +279,9 @@ static void destroy_server(struct server_data *data)
 
 	g_io_channel_unref(data->channel);
 
-	g_free(data->interface);
 	g_free(data->server);
+	g_free(data->domain);
+	g_free(data->interface);
 	g_free(data);
 }
 
@@ -212,7 +295,7 @@ static int dnsproxy_append(const char *interface, const char *domain,
 	if (g_str_equal(server, "127.0.0.1") == TRUE)
 		return -ENODEV;
 
-	data = create_server(interface, server);
+	data = create_server(interface, domain, server);
 	if (data == NULL)
 		return -EIO;
 
@@ -231,7 +314,7 @@ static int dnsproxy_remove(const char *interface, const char *domain,
 	if (g_str_equal(server, "127.0.0.1") == TRUE)
 		return -ENODEV;
 
-	data = find_server(interface, server);
+	data = find_server(interface, domain, server);
 	if (data == NULL)
 		return 0;
 
@@ -249,60 +332,26 @@ static struct connman_resolver dnsproxy_resolver = {
 	.remove		= dnsproxy_remove,
 };
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-struct domain_hdr {
-	uint16_t id;
-	uint8_t rd:1;
-	uint8_t tc:1;
-	uint8_t aa:1;
-	uint8_t opcode:4;
-	uint8_t qr:1;
-	uint8_t rcode:4;
-	uint8_t z:3;
-	uint8_t ra:1;
-	uint16_t qdcount;
-	uint16_t ancount;
-	uint16_t nscount;
-	uint16_t arcount;
-} __attribute__ ((packed));
-#elif __BYTE_ORDER == __BIG_ENDIAN
-struct domain_hdr {
-	uint16_t id;
-	uint8_t qr:1;
-	uint8_t opcode:4;
-	uint8_t aa:1;
-	uint8_t tc:1;
-	uint8_t rd:1;
-	uint8_t ra:1;
-	uint8_t z:3;
-	uint8_t rcode:4;
-	uint16_t qdcount;
-	uint16_t ancount;
-	uint16_t nscount;
-	uint16_t arcount;
-} __attribute__ ((packed));
-#else
-#error "Unknown byte order"
-#endif
-
-static void parse_request(unsigned char *buf, int len)
+static int parse_request(unsigned char *buf, int len,
+					char *name, unsigned int size)
 {
 	struct domain_hdr *hdr = (void *) buf;
 	uint16_t qdcount = ntohs(hdr->qdcount);
 	unsigned char *ptr;
-	char name[512];
+	char *last_label = NULL;
+	int label_count = 0;
 	unsigned int remain, used = 0;
 
 	if (len < 12)
-		return;
+		return -EINVAL;
 
 	DBG("id 0x%04x qr %d opcode %d qdcount %d",
 				hdr->id, hdr->qr, hdr->opcode, qdcount);
 
 	if (hdr->qr != 0 || qdcount != 1)
-		return;
+		return -EINVAL;
 
-	memset(name, 0, sizeof(name));
+	memset(name, 0, size);
 
 	ptr = buf + 12;
 	remain = len - 12;
@@ -310,11 +359,16 @@ static void parse_request(unsigned char *buf, int len)
 	while (remain > 0) {
 		uint8_t len = *ptr;
 
-		if (len == 0x00)
+		if (len == 0x00) {
+			if (label_count > 0)
+				last_label = (char *) (ptr + 1);
 			break;
+		}
+
+		label_count++;
 
-		if (used + len + 1 > sizeof(name))
-			return;
+		if (used + len + 1 > size)
+			return -ENOBUFS;
 
 		strncat(name, (char *) (ptr + 1), len);
 		strcat(name, ".");
@@ -325,7 +379,108 @@ static void parse_request(unsigned char *buf, int len)
 		remain -= len + 1;
 	}
 
-	DBG("domain name %s", name);
+	DBG("query %s (%d labels)", name, label_count);
+
+	return 0;
+}
+
+static void send_response(int sk, unsigned char *buf, int len,
+				const struct sockaddr *to, socklen_t tolen)
+{
+	struct domain_hdr *hdr = (void *) buf;
+	int err;
+
+	if (len < 12)
+		return;
+
+	DBG("id 0x%04x qr %d opcode %d", hdr->id, hdr->qr, hdr->opcode);
+
+	hdr->qr = 1;
+	hdr->rcode = 2;
+
+	hdr->ancount = 0;
+	hdr->nscount = 0;
+	hdr->arcount = 0;
+
+	err = sendto(sk, buf, len, 0, to, tolen);
+}
+
+static int append_query(unsigned char *buf, unsigned int size,
+				const char *query, const char *domain)
+{
+	unsigned char *ptr = buf;
+	char *offset;
+
+	DBG("query %s domain %s", query, domain);
+
+	offset = (char *) query;
+	while (offset != NULL) {
+		char *tmp;
+
+		tmp = strchr(offset, '.');
+		if (tmp == NULL) {
+			if (strlen(offset) == 0)
+				break;
+			*ptr = strlen(offset);
+			memcpy(ptr + 1, offset, strlen(offset));
+			ptr += strlen(offset) + 1;
+			break;
+		}
+
+		*ptr = tmp - offset;
+		memcpy(ptr + 1, offset, tmp - offset);
+		ptr += tmp - offset + 1;
+
+		offset = tmp + 1;
+	}
+
+	offset = (char *) domain;
+	while (offset != NULL) {
+		char *tmp;
+
+		tmp = strchr(offset, '.');
+		if (tmp == NULL) {
+			if (strlen(offset) == 0)
+				break;
+			*ptr = strlen(offset);
+			memcpy(ptr + 1, offset, strlen(offset));
+			ptr += strlen(offset) + 1;
+			break;
+		}
+
+		*ptr = tmp - offset;
+		memcpy(ptr + 1, offset, tmp - offset);
+		ptr += tmp - offset + 1;
+
+		offset = tmp + 1;
+	}
+
+	*ptr++ = 0x00;
+
+	return ptr - buf;
+}
+
+static gboolean request_timeout(gpointer user_data)
+{
+	struct request_data *req = user_data;
+
+	DBG("id 0x%04x", req->srcid);
+
+	request_list = g_slist_remove(request_list, req);
+
+	if (req->resplen > 0 && req->resp != NULL) {
+		int sk, err;
+
+		sk = g_io_channel_unix_get_fd(listener_channel);
+
+		err = sendto(sk, req->resp, req->resplen, 0,
+				(struct sockaddr *) &req->sin, req->len);
+	}
+
+	g_free(req->resp);
+	g_free(req);
+
+	return FALSE;
 }
 
 static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
@@ -333,6 +488,7 @@ static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 {
 	GSList *list;
 	unsigned char buf[768];
+	char query[512];
 	struct request_data *req;
 	struct sockaddr_in sin;
 	socklen_t size = sizeof(sin);
@@ -354,26 +510,34 @@ static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 
 	DBG("Received %d bytes (id 0x%04x)", len, buf[0] | buf[1] << 8);
 
-	parse_request(buf, len);
+	err = parse_request(buf, len, query, sizeof(query));
+	if (err < 0 || g_slist_length(server_list) == 0) {
+		send_response(sk, buf, len, (struct sockaddr *) &sin, size);
+		return TRUE;
+	}
 
-	if (g_slist_length(server_list) == 0)
+	req = g_try_new0(struct request_data, 1);
+	if (req == NULL)
 		return TRUE;
 
-	req = find_request(buf[0] | (buf[1] << 8));
-	if (req == NULL) {
-		req = g_try_new0(struct request_data, 1);
-		if (req == NULL)
-			return TRUE;
+	memcpy(&req->sin, &sin, sizeof(sin));
+	req->len = size;
 
-		memcpy(&req->sin, &sin, sizeof(sin));
-		req->len = size;
-		req->id = buf[0] | (buf[1] << 8);
+	request_id += 2;
+	if (request_id == 0x0000 || request_id == 0xffff)
+		request_id += 2;
 
-		request_list = g_slist_append(request_list, req);
-	} else {
-		memcpy(&req->sin, &sin, sizeof(sin));
-		req->len = size;
-	}
+	req->srcid = buf[0] | (buf[1] << 8);
+	req->dstid = request_id;
+	req->altid = request_id + 1;
+
+	buf[0] = req->dstid & 0xff;
+	buf[1] = req->dstid >> 8;
+
+	request_list = g_slist_append(request_list, req);
+
+	req->numserv = 0;
+	req->timeout = g_timeout_add_seconds(5, request_timeout, req);
 
 	for (list = server_list; list; list = list->next) {
 		struct server_data *data = list->data;
@@ -381,6 +545,34 @@ static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 		sk = g_io_channel_unix_get_fd(data->channel);
 
 		err = send(sk, buf, len, 0);
+
+		req->numserv++;
+
+		if (data->domain != NULL) {
+			unsigned char alt[1024];
+			struct domain_hdr *hdr = (void *) &alt;
+			int altlen;
+
+			alt[0] = req->altid & 0xff;
+			alt[1] = req->altid >> 8;
+
+			memcpy(alt + 2, buf + 2, 10);
+			hdr->qdcount = htons(1);
+
+			altlen = append_query(alt + 12, sizeof(alt) - 12,
+							query, data->domain);
+			if (altlen < 0)
+				continue;
+
+			alt[altlen + 12] = 0x00;
+			alt[altlen + 13] = 0x01;
+			alt[altlen + 14] = 0x00;
+			alt[altlen + 15] = 0x01;
+
+			err = send(sk, alt, altlen + 12 + 4, 0);
+
+			req->numserv++;
+		}
 	}
 
 	return TRUE;
@@ -451,11 +643,13 @@ static void destroy_listener(void)
 		g_source_remove(listener_watch);
 
 	for (list = request_list; list; list = list->next) {
-		struct request_data *data = list->data;
+		struct request_data *req = list->data;
 
-		DBG("Dropping request (id 0x%04x)", data->id);
+		DBG("Dropping request (id 0x%04x -> 0x%04x)",
+						req->srcid, req->dstid);
 
-		g_free(data);
+		g_free(req->resp);
+		g_free(req);
 		list->data = NULL;
 	}
 

commit e06445ba1d6d6744f22bcd9e175fad0ededc91a1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 18 22:46:00 2009 +0200

    Add skeleton for Modem Manager plugin

diff --git a/bootstrap-configure b/bootstrap-configure
index ac7d8bd1..49e5a640 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -21,6 +21,7 @@ fi
 		--enable-ethernet \
 		--enable-wifi \
 		--enable-bluetooth \
+		--enable-modemmgr \
 		--enable-udhcp \
 		--enable-dhclient \
 		--enable-resolvconf \
diff --git a/configure.ac b/configure.ac
index 80c4611f..ba282514 100644
--- a/configure.ac
+++ b/configure.ac
@@ -66,6 +66,10 @@ AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--enable-bluetooth],
 		[enable Bluetooth support]), [enable_bluetooth=${enableval}])
 AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" = "yes")
 
+AC_ARG_ENABLE(modemmgr, AC_HELP_STRING([--enable-modemmgr],
+                [enable Modem Manager support]), [enable_modemmgr=${enableval}])
+AM_CONDITIONAL(MODEMMGR, test "${enable_modemmgr}" = "yes")
+
 AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
 	[specify location of udhcpc binary]), [path_udhcpc=${withval}])
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index df912bd1..db3977fc 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -27,6 +27,12 @@ bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 endif
 
+if MODEMMGR
+plugin_LTLIBRARIES += modemmgr.la
+
+modemmgr_la_LIBADD = @GDBUS_LIBS@
+endif
+
 if NOVATEL
 plugin_LTLIBRARIES += novatel.la
 
diff --git a/plugins/modemmgr.c b/plugins/modemmgr.c
new file mode 100644
index 00000000..9a226845
--- /dev/null
+++ b/plugins/modemmgr.c
@@ -0,0 +1,40 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define CONNMAN_API_SUBJECT_TO_CHANGE
+#include <connman/plugin.h>
+#include <connman/log.h>
+
+static int modemmgr_init(void)
+{
+	return 0;
+}
+
+static void modemmgr_exit(void)
+{
+}
+
+CONNMAN_PLUGIN_DEFINE(modemmgr, "Modem Manager plugin", VERSION,
+		CONNMAN_PLUGIN_PRIORITY_DEFAULT, modemmgr_init, modemmgr_exit)

commit a264caec4b9b163ab93d66f412d5f6bebd6fa865
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 20 15:45:34 2009 +0100

    Add detection for Modem Manager running state

diff --git a/plugins/modemmgr.c b/plugins/modemmgr.c
index 9a226845..cbb5ebd5 100644
--- a/plugins/modemmgr.c
+++ b/plugins/modemmgr.c
@@ -23,17 +23,87 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+
+#include <gdbus.h>
+
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
+#include <connman/dbus.h>
 #include <connman/log.h>
 
+#define MODEMMGR_SERVICE	"org.freedesktop.ModemManager"
+#define MODEMMGR_INTERFACE	MODEMMGR_SERVICE
+
+#define ENUMERATE_DEVICES	"EnumerateDevices"
+
+#define TIMEOUT 5000
+
+static void enumerate_devices_reply(DBusPendingCall *call, void *user_data)
+{
+	DBusMessage *reply;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(call);
+
+	dbus_message_unref(reply);
+}
+
+static void modemmgr_connect(DBusConnection *connection, void *user_data)
+{
+	DBusMessage *message;
+	DBusPendingCall *call;
+
+	DBG("connection %p", connection);
+
+	message = dbus_message_new_method_call(MODEMMGR_SERVICE, "/",
+				MODEMMGR_INTERFACE, ENUMERATE_DEVICES);
+	if (message == NULL)
+		return;
+
+	if (dbus_connection_send_with_reply(connection, message,
+						&call, TIMEOUT) == FALSE) {
+		connman_error("Failed to get modem devices");
+		dbus_message_unref(message);
+		return;
+	}
+
+	dbus_pending_call_set_notify(call, enumerate_devices_reply,
+							NULL, NULL);
+
+	dbus_message_unref(message);
+}
+
+static void modemmgr_disconnect(DBusConnection *connection, void *user_data)
+{
+	DBG("connection %p", connection);
+}
+
+static DBusConnection *connection;
+static guint watch;
+
 static int modemmgr_init(void)
 {
+	connection = connman_dbus_get_connection();
+	if (connection == NULL)
+		return -EIO;
+
+	watch = g_dbus_add_service_watch(connection, MODEMMGR_SERVICE,
+			modemmgr_connect, modemmgr_disconnect, NULL, NULL);
+	if (watch == 0) {
+		dbus_connection_unref(connection);
+		return -EIO;
+	}
+
 	return 0;
 }
 
 static void modemmgr_exit(void)
 {
+	g_dbus_remove_watch(connection, watch);
+
+	dbus_connection_unref(connection);
 }
 
 CONNMAN_PLUGIN_DEFINE(modemmgr, "Modem Manager plugin", VERSION,

commit fb03c2b4bc0ab3e329ad797834131bea7cd15dc0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:03:05 2009 +0100

    Create proper service interface abstraction

diff --git a/include/service.h b/include/service.h
index 17f46b87..f85c3b39 100644
--- a/include/service.h
+++ b/include/service.h
@@ -69,6 +69,10 @@ extern struct connman_service *connman_service_create(void);
 extern struct connman_service *connman_service_ref(struct connman_service *service);
 extern void connman_service_unref(struct connman_service *service);
 
+extern int connman_service_set_favorite(struct connman_service *service,
+						connman_bool_t favorite);
+
+extern struct connman_service *connman_service_lookup(const char *identifier);
 extern struct connman_service *connman_service_get(const char *identifier);
 extern void connman_service_put(struct connman_service *service);
 
diff --git a/src/connman.h b/src/connman.h
index 67f75205..84bccaa2 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -53,9 +53,10 @@ int __connman_profile_init(DBusConnection *conn);
 void __connman_profile_cleanup(void);
 
 void __connman_profile_list(DBusMessageIter *iter);
-void __connman_profile_list_services(DBusMessageIter *iter);
 const char *__connman_profile_active(void);
 
+void __connman_profile_changed(void);
+
 #include <connman/log.h>
 
 int __connman_log_init(gboolean detach, gboolean debug);
@@ -214,6 +215,14 @@ int __connman_profile_remove_network(struct connman_network *network);
 int __connman_service_init(void);
 void __connman_service_cleanup(void);
 
+void __connman_service_list(DBusMessageIter *iter);
+
+struct connman_service *__connman_service_lookup_from_device(struct connman_device *device);
+struct connman_service *__connman_service_create_from_device(struct connman_device *device);
+
+struct connman_service *__connman_service_lookup_from_network(struct connman_network *network);
+struct connman_service *__connman_service_create_from_network(struct connman_network *network);
+
 #include <connman/notifier.h>
 
 int __connman_notifier_init(void);
diff --git a/src/manager.c b/src/manager.c
index 4814f532..0a59057c 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -105,7 +105,7 @@ static void append_services(DBusMessageIter *dict)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_profile_list_services(&iter);
+	__connman_service_list(&iter);
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(&entry, &value);
diff --git a/src/profile.c b/src/profile.c
index 2afba3fe..eeb777f1 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -30,189 +30,8 @@
 
 #define PROFILE_DEFAULT  "/profile/default"
 
-struct connman_group {
-	GSequenceIter *iter;
-	char *id;
-	char *path;
-	char *name;
-	char *mode;
-	char *security;
-	connman_uint8_t strength;
-	connman_bool_t favorite;
-	enum connman_service_type type;
-	enum connman_service_state state;
-	struct connman_network *network;
-};
-
-static GSequence *groups = NULL;
-
 static DBusConnection *connection = NULL;
 
-static const char *type2string(enum connman_service_type type)
-{
-	switch (type) {
-	case CONNMAN_SERVICE_TYPE_UNKNOWN:
-		break;
-	case CONNMAN_SERVICE_TYPE_ETHERNET:
-		return "ethernet";
-	case CONNMAN_SERVICE_TYPE_WIFI:
-		return "wifi";
-	case CONNMAN_SERVICE_TYPE_WIMAX:
-		return "wimax";
-	}
-
-	return NULL;
-}
-
-static const char *state2string(enum connman_service_state state)
-{
-	switch (state) {
-	case CONNMAN_SERVICE_STATE_UNKNOWN:
-		break;
-	case CONNMAN_SERVICE_STATE_IDLE:
-		return "idle";
-	case CONNMAN_SERVICE_STATE_ASSOCIATION:
-		return "association";
-	case CONNMAN_SERVICE_STATE_CONFIGURATION:
-		return "configuration";
-	case CONNMAN_SERVICE_STATE_READY:
-		return "ready";
-	case CONNMAN_SERVICE_STATE_DISCONNECT:
-		return "disconnect";
-	case CONNMAN_SERVICE_STATE_FAILURE:
-		return "failure";
-	}
-
-	return NULL;
-}
-
-static DBusMessage *get_properties(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_group *group = data;
-	DBusMessage *reply;
-	DBusMessageIter array, dict;
-	const char *str;
-
-	DBG("conn %p", conn);
-
-	reply = dbus_message_new_method_return(msg);
-	if (reply == NULL)
-		return NULL;
-
-	dbus_message_iter_init_append(reply, &array);
-
-	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
-			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
-			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
-
-	str = type2string(group->type);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "Type",
-						DBUS_TYPE_STRING, &str);
-
-	str = state2string(group->state);
-	if (str != NULL)
-		connman_dbus_dict_append_variant(&dict, "State",
-						DBUS_TYPE_STRING, &str);
-
-	if (group->name != NULL)
-		connman_dbus_dict_append_variant(&dict, "Name",
-					DBUS_TYPE_STRING, &group->name);
-
-	if (group->mode != NULL)
-		connman_dbus_dict_append_variant(&dict, "Mode",
-					DBUS_TYPE_STRING, &group->mode);
-
-	if (group->security != NULL)
-		connman_dbus_dict_append_variant(&dict, "Security",
-					DBUS_TYPE_STRING, &group->security);
-
-	if (group->strength > 0)
-		connman_dbus_dict_append_variant(&dict, "Strength",
-					DBUS_TYPE_BYTE, &group->strength);
-
-	connman_dbus_dict_append_variant(&dict, "Favorite",
-					DBUS_TYPE_BOOLEAN, &group->favorite);
-
-	dbus_message_iter_close_container(&array, &dict);
-
-	return reply;
-}
-
-static DBusMessage *connect_service(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_group *group = data;
-
-	if (group->type == CONNMAN_SERVICE_TYPE_ETHERNET)
-		return __connman_error_not_supported(msg);
-
-	return __connman_error_not_implemented(msg);
-}
-
-static DBusMessage *disconnect_service(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_group *group = data;
-
-	if (group->type == CONNMAN_SERVICE_TYPE_ETHERNET)
-		return __connman_error_not_supported(msg);
-
-	return __connman_error_not_implemented(msg);
-}
-
-static DBusMessage *remove_service(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_group *group = data;
-
-	if (group->type == CONNMAN_SERVICE_TYPE_ETHERNET)
-		return __connman_error_not_supported(msg);
-
-	group->favorite = FALSE;
-
-	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
-}
-
-static DBusMessage *move_before(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_group *group = data;
-
-	if (group->favorite == FALSE)
-		return __connman_error_not_supported(msg);
-
-	return __connman_error_not_implemented(msg);
-}
-
-static DBusMessage *move_after(DBusConnection *conn,
-					DBusMessage *msg, void *data)
-{
-	struct connman_group *group = data;
-
-	if (group->favorite == FALSE)
-		return __connman_error_not_supported(msg);
-
-	return __connman_error_not_implemented(msg);
-}
-
-static GDBusMethodTable service_methods[] = {
-	{ "GetProperties", "",  "a{sv}", get_properties     },
-	{ "Connect",       "",  "",      connect_service    },
-	{ "Disconnect",    "",  "",      disconnect_service },
-	{ "Remove",        "",  "",      remove_service     },
-	{ "MoveBefore",    "o", "",      move_before        },
-	{ "MoveAfter",     "o", "",      move_after         },
-	{ },
-};
-
-static GDBusSignalTable service_signals[] = {
-	{ "PropertyChanged", "sv" },
-	{ },
-};
-
 const char *__connman_profile_active(void)
 {
 	DBG("");
@@ -220,22 +39,6 @@ const char *__connman_profile_active(void)
 	return PROFILE_DEFAULT;
 }
 
-static void append_path(gpointer value, gpointer user_data)
-{
-	struct connman_group *group = value;
-	DBusMessageIter *iter = user_data;
-
-	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
-							&group->path);
-}
-
-void __connman_profile_list_services(DBusMessageIter *iter)
-{
-	DBG("");
-
-	g_sequence_foreach(groups, append_path, iter);
-}
-
 static void append_services(DBusMessageIter *entry)
 {
 	DBusMessageIter value, iter;
@@ -249,13 +52,13 @@ static void append_services(DBusMessageIter *entry)
 
 	dbus_message_iter_open_container(&value, DBUS_TYPE_ARRAY,
 				DBUS_TYPE_OBJECT_PATH_AS_STRING, &iter);
-	__connman_profile_list_services(&iter);
+	__connman_service_list(&iter);
 	dbus_message_iter_close_container(&value, &iter);
 
 	dbus_message_iter_close_container(entry, &value);
 }
 
-static void emit_services_signal(void)
+void __connman_profile_changed(void)
 {
 	const char *path = __connman_profile_active();
 	DBusMessage *signal;
@@ -280,149 +83,30 @@ static void emit_services_signal(void)
 	g_dbus_send_message(connection, signal);
 }
 
-static void free_group(gpointer data)
-{
-	struct connman_group *group = data;
-
-	DBG("group %p", group);
-
-	g_dbus_unregister_interface(connection, group->path,
-						CONNMAN_SERVICE_INTERFACE);
-
-	g_free(group->security);
-	g_free(group->mode);
-	g_free(group->name);
-	g_free(group->path);
-	g_free(group->id);
-	g_free(group);
-}
-
-static gint compare_group(gconstpointer a, gconstpointer b, gpointer user_data)
-{
-	struct connman_group *group_a = (void *) a;
-	struct connman_group *group_b = (void *) b;
-
-	if (group_a->favorite == TRUE && group_b->favorite == FALSE)
-		return -1;
-
-	if (group_a->favorite == FALSE && group_b->favorite == TRUE)
-		return 1;
-
-	return (gint) group_b->strength - (gint) group_a->strength;
-}
-
-static struct connman_group *lookup_group(const char *name)
-{
-	GSequenceIter *iter;
-	struct connman_group *group;
-
-	DBG("name %s", name);
-
-	if (name == NULL)
-		return NULL;
-
-	iter = g_sequence_get_begin_iter(groups);
-	while (g_sequence_iter_is_end(iter) == FALSE) {
-		group = g_sequence_get(iter);
-
-		if (g_strcmp0(group->id, name) == 0)
-			goto done;
-
-		iter = g_sequence_iter_next(iter);
-	}
-
-	group = g_try_new0(struct connman_group, 1);
-	if (group == NULL)
-		return NULL;
-
-	group->id = g_strdup(name);
-
-	group->type = CONNMAN_SERVICE_TYPE_UNKNOWN;
-	group->path = g_strdup_printf("%s/%s", PROFILE_DEFAULT, name);
-
-	group->favorite = FALSE;
-
-	group->state = CONNMAN_SERVICE_STATE_IDLE;
-
-	group->iter = g_sequence_insert_sorted(groups, group,
-						compare_group, NULL);
-
-	g_dbus_register_interface(connection, group->path,
-					CONNMAN_SERVICE_INTERFACE,
-					service_methods, service_signals,
-							NULL, group, NULL);
-
-done:
-	DBG("group %p", group);
-
-	return group;
-}
-
-static enum connman_service_type convert_device_type(struct connman_device *device)
-{
-	enum connman_device_type type = connman_device_get_type(device);
-
-	switch (type) {
-	case CONNMAN_DEVICE_TYPE_UNKNOWN:
-	case CONNMAN_DEVICE_TYPE_VENDOR:
-	case CONNMAN_DEVICE_TYPE_WIFI:
-	case CONNMAN_DEVICE_TYPE_WIMAX:
-	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
-	case CONNMAN_DEVICE_TYPE_GPS:
-	case CONNMAN_DEVICE_TYPE_HSO:
-	case CONNMAN_DEVICE_TYPE_NOZOMI:
-	case CONNMAN_DEVICE_TYPE_HUAWEI:
-	case CONNMAN_DEVICE_TYPE_NOVATEL:
-		break;
-	case CONNMAN_DEVICE_TYPE_ETHERNET:
-		return CONNMAN_SERVICE_TYPE_ETHERNET;
-	}
-
-	return CONNMAN_SERVICE_TYPE_UNKNOWN;
-}
-
 int __connman_profile_add_device(struct connman_device *device)
 {
-	struct connman_group *group;
-	char *name;
+	struct connman_service *service;
 
 	DBG("device %p", device);
 
-	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
-					connman_device_get_index(device));
-	group = lookup_group(name);
-	g_free(name);
-
-	if (group == NULL)
+	service = __connman_service_create_from_device(device);
+	if (service == NULL)
 		return -EINVAL;
 
-	group->type = convert_device_type(device);
-
-	g_sequence_sort_changed(group->iter, compare_group, NULL);
-	emit_services_signal();
-
 	return 0;
 }
 
 int __connman_profile_remove_device(struct connman_device *device)
 {
-	struct connman_group *group;
-	char *name;
+	struct connman_service *service;
 
 	DBG("device %p", device);
 
-	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
-					connman_device_get_index(device));
-	group = lookup_group(name);
-	g_free(name);
-
-	if (group == NULL)
+	service = __connman_service_lookup_from_device(device);
+	if (service == NULL)
 		return -EINVAL;
 
-	group->type = CONNMAN_SERVICE_TYPE_UNKNOWN;
-
-	g_sequence_sort_changed(group->iter, compare_group, NULL);
-	emit_services_signal();
+	connman_service_put(service);
 
 	return 0;
 }
@@ -430,122 +114,41 @@ int __connman_profile_remove_device(struct connman_device *device)
 int __connman_profile_set_carrier(struct connman_device *device,
 						connman_bool_t carrier)
 {
-	struct connman_group *group;
-	char *name;
+	struct connman_service *service;
 
 	DBG("device %p carrier %d", device, carrier);
 
-	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
-					connman_device_get_index(device));
-	group = lookup_group(name);
-	g_free(name);
-
-	if (group == NULL)
+	service = __connman_service_lookup_from_device(device);
+	if (service == NULL)
 		return -EINVAL;
 
-	if (group->favorite == carrier)
-		return -EALREADY;
-
-	group->favorite = carrier;
-
-	g_sequence_sort_changed(group->iter, compare_group, NULL);
-	emit_services_signal();
-
-	return 0;
-}
-
-static enum connman_service_type convert_network_type(struct connman_network *network)
-{
-	enum connman_network_type type = connman_network_get_type(network);
-
-	switch (type) {
-	case CONNMAN_NETWORK_TYPE_UNKNOWN:
-	case CONNMAN_NETWORK_TYPE_VENDOR:
-	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
-	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
-	case CONNMAN_NETWORK_TYPE_HSO:
-		break;
-	case CONNMAN_NETWORK_TYPE_WIFI:
-		return CONNMAN_SERVICE_TYPE_WIFI;
-	case CONNMAN_NETWORK_TYPE_WIMAX:
-		return CONNMAN_SERVICE_TYPE_WIMAX;
-	}
-
-	return CONNMAN_SERVICE_TYPE_UNKNOWN;
+	return connman_service_set_favorite(service, carrier);
 }
 
 int __connman_profile_add_network(struct connman_network *network)
 {
-	struct connman_group *group;
-	char *name;
+	struct connman_service *service;
 
 	DBG("network %p", network);
 
-	if (__connman_network_get_group(network) == NULL)
+	service = __connman_service_create_from_network(network);
+	if (service == NULL)
 		return -EINVAL;
 
-	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
-					__connman_network_get_group(network));
-	group = lookup_group(name);
-	g_free(name);
-
-	if (group == NULL)
-		return -EINVAL;
-
-	group->type = convert_network_type(network);
-
-	g_free(group->name);
-	group->name = g_strdup(connman_network_get_string(network, "Name"));
-
-	group->strength = connman_network_get_uint8(network, "Strength");
-
-	if (group->network == NULL) {
-		group->network = network;
-
-		group->mode = g_strdup(connman_network_get_string(network,
-								"WiFi.Mode"));
-		group->security = g_strdup(connman_network_get_string(network,
-							"WiFi.Security"));
-	}
-
-	g_sequence_sort_changed(group->iter, compare_group, NULL);
-	emit_services_signal();
-
 	return 0;
 }
 
 int __connman_profile_remove_network(struct connman_network *network)
 {
-	struct connman_group *group;
-	char *name;
+	struct connman_service *service;
 
 	DBG("network %p", network);
 
-	if (__connman_network_get_group(network) == NULL)
+	service = __connman_service_lookup_from_network(network);
+	if (service == NULL)
 		return -EINVAL;
 
-	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
-					__connman_network_get_group(network));
-	group = lookup_group(name);
-	g_free(name);
-
-	if (group == NULL)
-		return -EINVAL;
-
-	if (group->network == network) {
-		g_free(group->security);
-		group->security = NULL;
-
-		g_free(group->mode);
-		group->mode = NULL;
-
-		group->network = NULL;
-	}
-
-	group->type = CONNMAN_SERVICE_TYPE_UNKNOWN;
-
-	g_sequence_sort_changed(group->iter, compare_group, NULL);
-	emit_services_signal();
+	connman_service_put(service);
 
 	return 0;
 }
@@ -559,7 +162,7 @@ void __connman_profile_list(DBusMessageIter *iter)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
 }
 
-static DBusMessage *profile_properties(DBusConnection *conn,
+static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
 	const char *name = "Default";
@@ -593,7 +196,7 @@ static DBusMessage *profile_properties(DBusConnection *conn,
 }
 
 static GDBusMethodTable profile_methods[] = {
-	{ "GetProperties", "", "a{sv}", profile_properties },
+	{ "GetProperties", "", "a{sv}", get_properties },
 	{ },
 };
 
@@ -610,8 +213,6 @@ int __connman_profile_init(DBusConnection *conn)
 	if (connection == NULL)
 		return -1;
 
-	groups = g_sequence_new(free_group);
-
 	g_dbus_register_interface(connection, PROFILE_DEFAULT,
 					CONNMAN_PROFILE_INTERFACE,
 					profile_methods, profile_signals,
@@ -627,9 +228,6 @@ void __connman_profile_cleanup(void)
 	g_dbus_unregister_interface(connection, PROFILE_DEFAULT,
 						CONNMAN_PROFILE_INTERFACE);
 
-	g_sequence_free(groups);
-	groups = NULL;
-
 	if (connection == NULL)
 		return;
 
diff --git a/src/service.c b/src/service.c
index b921f5fc..6ecff7de 100644
--- a/src/service.c
+++ b/src/service.c
@@ -23,6 +23,8 @@
 #include <config.h>
 #endif
 
+#include <gdbus.h>
+
 #include "connman.h"
 
 static DBusConnection *connection = NULL;
@@ -40,23 +42,259 @@ struct connman_service {
 	enum connman_service_state state;
 	connman_uint8_t strength;
 	connman_bool_t favorite;
+	unsigned int order;
 	char *name;
+	struct connman_device *device;
+};
+
+static void append_path(gpointer value, gpointer user_data)
+{
+	struct connman_service *service = value;
+	DBusMessageIter *iter = user_data;
+
+	if (service->path == NULL)
+		return;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
+							&service->path);
+}
+
+void __connman_service_list(DBusMessageIter *iter)
+{
+	DBG("");
+
+	g_sequence_foreach(service_list, append_path, iter);
+}
+
+static const char *type2string(enum connman_service_type type)
+{
+	switch (type) {
+	case CONNMAN_SERVICE_TYPE_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_TYPE_ETHERNET:
+		return "ethernet";
+	case CONNMAN_SERVICE_TYPE_WIFI:
+		return "wifi";
+	case CONNMAN_SERVICE_TYPE_WIMAX:
+		return "wimax";
+	}
+
+	return NULL;
+}
+
+static const char *mode2string(enum connman_service_mode mode)
+{
+	switch (mode) {
+	case CONNMAN_SERVICE_MODE_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_MODE_MANAGED:
+		return "managed";
+	case CONNMAN_SERVICE_MODE_ADHOC:
+		return "adhoc";
+	}
+
+	return NULL;
+}
+
+static const char *security2string(enum connman_service_security security)
+{
+	switch (security) {
+	case CONNMAN_SERVICE_SECURITY_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_SECURITY_NONE:
+		return "none";
+	case CONNMAN_SERVICE_SECURITY_WEP:
+		return "wep";
+	case CONNMAN_SERVICE_SECURITY_WPA:
+		return "wpa";
+	case CONNMAN_SERVICE_SECURITY_WPA2:
+		return "wpa2";
+	}
+
+	return NULL;
+}
+
+static const char *state2string(enum connman_service_state state)
+{
+	switch (state) {
+	case CONNMAN_SERVICE_STATE_UNKNOWN:
+		break;
+	case CONNMAN_SERVICE_STATE_IDLE:
+		return "idle";
+	case CONNMAN_SERVICE_STATE_ASSOCIATION:
+		return "association";
+	case CONNMAN_SERVICE_STATE_CONFIGURATION:
+		return "configuration";
+	case CONNMAN_SERVICE_STATE_READY:
+		return "ready";
+	case CONNMAN_SERVICE_STATE_DISCONNECT:
+		return "disconnect";
+	case CONNMAN_SERVICE_STATE_FAILURE:
+		return "failure";
+	}
+
+	return NULL;
+}
+
+static DBusMessage *get_properties(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+	DBusMessage *reply;
+	DBusMessageIter array, dict;
+	const char *str;
+
+	DBG("conn %p", conn);
+
+	reply = dbus_message_new_method_return(msg);
+	if (reply == NULL)
+		return NULL;
+
+	dbus_message_iter_init_append(reply, &array);
+
+	dbus_message_iter_open_container(&array, DBUS_TYPE_ARRAY,
+			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	str = type2string(service->type);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Type",
+						DBUS_TYPE_STRING, &str);
+
+	str = mode2string(service->mode);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Mode",
+						DBUS_TYPE_STRING, &str);
+
+	str = security2string(service->security);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "Security",
+						DBUS_TYPE_STRING, &str);
+
+	str = state2string(service->state);
+	if (str != NULL)
+		connman_dbus_dict_append_variant(&dict, "State",
+						DBUS_TYPE_STRING, &str);
+
+	if (service->strength > 0)
+		connman_dbus_dict_append_variant(&dict, "Strength",
+					DBUS_TYPE_BYTE, &service->strength);
+
+	connman_dbus_dict_append_variant(&dict, "Favorite",
+					DBUS_TYPE_BOOLEAN, &service->favorite);
+
+	if (service->name != NULL)
+		connman_dbus_dict_append_variant(&dict, "Name",
+					DBUS_TYPE_STRING, &service->name);
+
+	dbus_message_iter_close_container(&array, &dict);
+
+	return reply;
+}
+
+static DBusMessage *connect_service(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+
+	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		return __connman_error_not_supported(msg);
+
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *disconnect_service(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+
+	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		return __connman_error_not_supported(msg);
+
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *remove_service(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+
+	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
+		return __connman_error_not_supported(msg);
+
+	service->favorite = FALSE;
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
+static DBusMessage *move_before(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+
+	if (service->favorite == FALSE)
+		return __connman_error_not_supported(msg);
+
+	return __connman_error_not_implemented(msg);
+}
+
+static DBusMessage *move_after(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+
+	if (service->favorite == FALSE)
+		return __connman_error_not_supported(msg);
+
+	return __connman_error_not_implemented(msg);
+}
+
+static GDBusMethodTable service_methods[] = {
+	{ "GetProperties", "",  "a{sv}", get_properties     },
+	{ "Connect",       "",  "",      connect_service    },
+	{ "Disconnect",    "",  "",      disconnect_service },
+	{ "Remove",        "",  "",      remove_service     },
+	{ "MoveBefore",    "o", "",      move_before        },
+	{ "MoveAfter",     "o", "",      move_after         },
+	{ },
+};
+
+static GDBusSignalTable service_signals[] = {
+	{ "PropertyChanged", "sv" },
+	{ },
 };
 
 static void service_free(gpointer data)
 {
 	struct connman_service *service = data;
+	char *path = service->path;
 
 	DBG("service %p", service);
 
 	g_hash_table_remove(service_hash, service->identifier);
 
+	service->path = NULL;
+
+	if (path != NULL) {
+		__connman_profile_changed();
+
+		g_dbus_unregister_interface(connection, path,
+						CONNMAN_SERVICE_INTERFACE);
+		g_free(path);
+	}
+
 	g_free(service->name);
-	g_free(service->path);
 	g_free(service->identifier);
 	g_free(service);
 }
 
+/**
+ * connman_service_put:
+ * @service: service structure
+ *
+ * Release service if no longer needed
+ */
 void connman_service_put(struct connman_service *service)
 {
 	DBG("service %p", service);
@@ -84,6 +322,8 @@ static void __connman_service_initialize(struct connman_service *service)
 	service->state    = CONNMAN_SERVICE_STATE_UNKNOWN;
 
 	service->favorite = FALSE;
+
+	service->order = 0;
 }
 
 /**
@@ -138,6 +378,12 @@ static gint service_compare(gconstpointer a, gconstpointer b,
 	struct connman_service *service_a = (void *) a;
 	struct connman_service *service_b = (void *) b;
 
+	if (service_a->order > service_b->order)
+		return -1;
+
+	if (service_a->order < service_b->order)
+		return 1;
+
 	if (service_a->favorite == TRUE && service_b->favorite == FALSE)
 		return -1;
 
@@ -147,6 +393,57 @@ static gint service_compare(gconstpointer a, gconstpointer b,
 	return (gint) service_b->strength - (gint) service_a->strength;
 }
 
+/**
+ * connman_service_set_favorite:
+ * @service: service structure
+ * @favorite: favorite value
+ *
+ * Change the favorite setting of service
+ */
+int connman_service_set_favorite(struct connman_service *service,
+						connman_bool_t favorite)
+{
+	GSequenceIter *iter;
+
+	iter = g_hash_table_lookup(service_hash, service->identifier);
+	if (iter == NULL)
+		return -ENOENT;
+
+	if (service->favorite)
+		return -EALREADY;
+
+	service->favorite = favorite;
+
+	g_sequence_sort_changed(iter, service_compare, NULL);
+
+	__connman_profile_changed();
+
+	return 0;
+}
+
+/**
+ * connman_service_lookup:
+ * @identifier: service identifier
+ *
+ * Look up a service by identifier (reference count will not be increased)
+ */
+struct connman_service *connman_service_lookup(const char *identifier)
+{
+	GSequenceIter *iter;
+
+	iter = g_hash_table_lookup(service_hash, identifier);
+	if (iter != NULL)
+		return g_sequence_get(iter);
+
+	return NULL;
+}
+
+/**
+ * connman_service_get:
+ * @identifier: service identifier
+ *
+ * Look up a service by identifier or create a new one if not found
+ */
 struct connman_service *connman_service_get(const char *identifier)
 {
 	struct connman_service *service;
@@ -178,6 +475,180 @@ struct connman_service *connman_service_get(const char *identifier)
 	return service;
 }
 
+static int service_register(struct connman_service *service)
+{
+	const char *path = __connman_profile_active();
+
+	if (service->path != NULL)
+		return -EALREADY;
+
+	service->path = g_strdup_printf("%s/%s", path, service->identifier);
+
+	g_dbus_register_interface(connection, service->path,
+					CONNMAN_SERVICE_INTERFACE,
+					service_methods, service_signals,
+							NULL, service, NULL);
+
+	__connman_profile_changed();
+
+	return 0;
+}
+
+/**
+ * connman_service_lookup_from_device:
+ * @device: device structure
+ *
+ * Look up a service by device (reference count will not be increased)
+ */
+struct connman_service *__connman_service_lookup_from_device(struct connman_device *device)
+{
+	struct connman_service *service;
+	char *name;
+
+	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
+					connman_device_get_index(device));
+
+	service = connman_service_lookup(name);
+
+	g_free(name);
+
+	return service;
+}
+
+static enum connman_service_type convert_device_type(struct connman_device *device)
+{
+	enum connman_device_type type = connman_device_get_type(device);
+
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_GPS:
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+		break;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		return CONNMAN_SERVICE_TYPE_ETHERNET;
+	}
+
+	return CONNMAN_SERVICE_TYPE_UNKNOWN;
+}
+
+/**
+ * connman_service_create_from_device:
+ * @device: device structure
+ *
+ * Look up service by device and if not found, create one
+ */
+struct connman_service *__connman_service_create_from_device(struct connman_device *device)
+{
+	struct connman_service *service;
+	char *name;
+
+	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
+					connman_device_get_index(device));
+
+	service = connman_service_get(name);
+	if (service == NULL)
+		goto done;
+
+	if (service->path != NULL) {
+		connman_service_put(service);
+		service = NULL;
+		goto done;
+	}
+
+	service->type = convert_device_type(device);
+
+	service->device = device;
+
+	service_register(service);
+
+done:
+	g_free(name);
+
+	return service;
+}
+
+/**
+ * connman_service_lookup_from_network:
+ * @device: device structure
+ *
+ * Look up a service by network (reference count will not be increased)
+ */
+struct connman_service *__connman_service_lookup_from_network(struct connman_network *network)
+{
+	struct connman_service *service;
+	char *name;
+
+	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
+					__connman_network_get_group(network));
+
+	service = connman_service_lookup(name);
+
+	g_free(name);
+
+	return service;
+}
+
+static enum connman_service_type convert_network_type(struct connman_network *network)
+{
+	enum connman_network_type type = connman_network_get_type(network);
+
+	switch (type) {
+	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+	case CONNMAN_NETWORK_TYPE_VENDOR:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
+	case CONNMAN_NETWORK_TYPE_HSO:
+		break;
+	case CONNMAN_NETWORK_TYPE_WIFI:
+		return CONNMAN_SERVICE_TYPE_WIFI;
+	case CONNMAN_NETWORK_TYPE_WIMAX:
+		return CONNMAN_SERVICE_TYPE_WIMAX;
+	}
+
+	return CONNMAN_SERVICE_TYPE_UNKNOWN;
+}
+
+/**
+ * connman_service_create_from_network:
+ * @device: device structure
+ *
+ * Look up service by network and if not found, create one
+ */
+struct connman_service *__connman_service_create_from_network(struct connman_network *network)
+{
+	struct connman_service *service;
+	char *name;
+
+	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
+					__connman_network_get_group(network));
+
+	service = connman_service_get(name);
+	if (service == NULL)
+		goto done;
+
+	if (service->path != NULL) {
+		connman_service_put(service);
+		service = NULL;
+		goto done;
+	}
+
+	service->type = convert_network_type(network);
+
+	service_register(service);
+
+done:
+	g_free(name);
+
+	return service;
+}
+
 int __connman_service_init(void)
 {
 	DBG("");

commit afe6619c67e6f658298cd34b9adf839efef809d0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:04:49 2009 +0100

    Add functions for device connect/disconnect handling

diff --git a/src/connman.h b/src/connman.h
index 84bccaa2..102b334c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -179,7 +179,8 @@ void __connman_device_decrease_connections(struct connman_device *device);
 void __connman_device_set_network(struct connman_device *device,
 					struct connman_network *network);
 
-void __connman_device_disconnect(struct connman_device *device);
+int __connman_device_connect(struct connman_device *device);
+int __connman_device_disconnect(struct connman_device *device);
 
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
diff --git a/src/device.c b/src/device.c
index bb9abf5f..c75e331d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1266,7 +1266,14 @@ int connman_device_set_carrier(struct connman_device *device,
 	return set_carrier(device, device->carrier);
 }
 
-void __connman_device_disconnect(struct connman_device *device)
+int __connman_device_connect(struct connman_device *device)
+{
+	DBG("device %p", device);
+
+	return 0;
+}
+
+int __connman_device_disconnect(struct connman_device *device)
 {
 	GHashTableIter iter;
 	gpointer key, value;
@@ -1283,6 +1290,8 @@ void __connman_device_disconnect(struct connman_device *device)
 		if (connman_network_get_connected(network) == TRUE)
 			__connman_network_disconnect(network);
 	}
+
+	return 0;
 }
 
 static void connect_known_network(struct connman_device *device)

commit 1c6f46550b226997dc3b37f91084ffcfd8d79f17
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:11:02 2009 +0100

    Add simple integration of device connect/disconnect callbacks

diff --git a/src/service.c b/src/service.c
index 6ecff7de..4c55555f 100644
--- a/src/service.c
+++ b/src/service.c
@@ -198,10 +198,14 @@ static DBusMessage *connect_service(DBusConnection *conn,
 {
 	struct connman_service *service = data;
 
-	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
-		return __connman_error_not_supported(msg);
+	if (service->device != NULL) {
+		if (__connman_device_connect(service->device) < 0)
+			return __connman_error_failed(msg);
 
-	return __connman_error_not_implemented(msg);
+		service->state = CONNMAN_SERVICE_STATE_READY;
+	}
+
+	return __connman_error_not_supported(msg);
 }
 
 static DBusMessage *disconnect_service(DBusConnection *conn,
@@ -209,10 +213,14 @@ static DBusMessage *disconnect_service(DBusConnection *conn,
 {
 	struct connman_service *service = data;
 
-	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
-		return __connman_error_not_supported(msg);
+	if (service->device != NULL) {
+		if (__connman_device_connect(service->device) < 0)
+			return __connman_error_failed(msg);
 
-	return __connman_error_not_implemented(msg);
+		service->state = CONNMAN_SERVICE_STATE_IDLE;
+	}
+
+	return __connman_error_not_supported(msg);
 }
 
 static DBusMessage *remove_service(DBusConnection *conn,
@@ -223,7 +231,7 @@ static DBusMessage *remove_service(DBusConnection *conn,
 	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
 		return __connman_error_not_supported(msg);
 
-	service->favorite = FALSE;
+	connman_service_set_favorite(service, FALSE);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }

commit c5ca807aa300eb258410abe57655286915d470f6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:20:46 2009 +0100

    Fail connect attempt if not disconnected

diff --git a/src/device.c b/src/device.c
index c75e331d..46c3967d 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1270,6 +1270,9 @@ int __connman_device_connect(struct connman_device *device)
 {
 	DBG("device %p", device);
 
+	if (device->disconnected == FALSE)
+		return -EINVAL;
+
 	return 0;
 }
 

commit 8a19214f544e882ea550402bdc36f364ac861764
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:23:37 2009 +0100

    Reset disconnected state if carrier changes

diff --git a/src/device.c b/src/device.c
index 46c3967d..b5d7cd66 100644
--- a/src/device.c
+++ b/src/device.c
@@ -1253,6 +1253,9 @@ int connman_device_set_carrier(struct connman_device *device,
 
 	device->carrier = carrier;
 
+	if (carrier == TRUE)
+		device->disconnected = FALSE;
+
 	switch (device->policy) {
 	case CONNMAN_DEVICE_POLICY_UNKNOWN:
 	case CONNMAN_DEVICE_POLICY_IGNORE:

commit 4b16c48074a5468804625de0092b20343fa97a27
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:45:59 2009 +0100

    Add skeleton for behavior document

diff --git a/doc/Makefile.am b/doc/Makefile.am
index 92af2a93..98282373 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -37,6 +37,6 @@ else
 EXTRA_DIST = $(DOC_MAIN_SGML_FILE) connman-introduction.xml
 endif
 
-EXTRA_DIST += overview-api.txt manager-api.txt service-api.txt \
+EXTRA_DIST += overview-api.txt behavior-api.txt manager-api.txt \
 		device-api.txt network-api.txt service-api.txt \
 		connection-api.txt profile-api.txt agent-api.txt plugin-api.txt
diff --git a/doc/behavior-api.txt b/doc/behavior-api.txt
new file mode 100644
index 00000000..5feea768
--- /dev/null
+++ b/doc/behavior-api.txt
@@ -0,0 +1,11 @@
+Interface behavior description
+******************************
+
+
+Ethernet service
+================
+
+The Ethernet based service is a special case since it has no children, but
+still can be manually connected and disconnected while also has an implicit
+behavior when physically plugging in or removing an Ethernet cable.
+

commit 87c4130bdb16e8ce0b033708e219d22b19e29a04
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 04:56:24 2009 +0100

    Describe the special carrier service state

diff --git a/doc/overview-api.txt b/doc/overview-api.txt
index afb996de..92aed886 100644
--- a/doc/overview-api.txt
+++ b/doc/overview-api.txt
@@ -262,6 +262,10 @@ The basic state of every service is "idle". This means that this service
 is not in use at all at the moment. It also is not attempting to connect
 or do anything else.
 
+With Ethernet services a special "carrier" state is available. It indicates
+that the cable has been plugged in. This state is only used when the device
+is from type Ethernet.
+
 The "association" state indicates that this service tries to establish a
 low-level connection to the network. For example associating/connecting
 with a WiFi access point.
@@ -285,6 +289,14 @@ the "idle" state since the service is not connected.
 		+---------------+
 		| idle          |<-------------------------------+
 		+---------------+                                |
+		      |    |                                     |
+		      |    +----------------------+              |
+		      |                           |              |
+		      |                           V              |
+		      |                      +-------------+     |
+		      +----------------------| carrier     |<----+
+		      |                      +-------------+     |
+		      |                                          |
 		      |                      +-------------+     |
 		      +----------------------| failure     |     |
 		      | service.Connect()    +-------------+     |

commit 90406cff092e149ef835d684e5d4d445687a2e01
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:08:48 2009 +0100

    Add support for carrier service state

diff --git a/include/service.h b/include/service.h
index f85c3b39..fb7d5e7f 100644
--- a/include/service.h
+++ b/include/service.h
@@ -56,11 +56,12 @@ enum connman_service_security {
 enum connman_service_state {
 	CONNMAN_SERVICE_STATE_UNKNOWN       = 0,
 	CONNMAN_SERVICE_STATE_IDLE          = 1,
-	CONNMAN_SERVICE_STATE_ASSOCIATION   = 2,
-	CONNMAN_SERVICE_STATE_CONFIGURATION = 3,
-	CONNMAN_SERVICE_STATE_READY         = 4,
-	CONNMAN_SERVICE_STATE_DISCONNECT    = 5,
-	CONNMAN_SERVICE_STATE_FAILURE       = 6,
+	CONNMAN_SERVICE_STATE_CARRIER       = 2,
+	CONNMAN_SERVICE_STATE_ASSOCIATION   = 3,
+	CONNMAN_SERVICE_STATE_CONFIGURATION = 4,
+	CONNMAN_SERVICE_STATE_READY         = 5,
+	CONNMAN_SERVICE_STATE_DISCONNECT    = 6,
+	CONNMAN_SERVICE_STATE_FAILURE       = 7,
 };
 
 struct connman_service;
diff --git a/src/connman.h b/src/connman.h
index 102b334c..d66e0cf7 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -224,6 +224,9 @@ struct connman_service *__connman_service_create_from_device(struct connman_devi
 struct connman_service *__connman_service_lookup_from_network(struct connman_network *network);
 struct connman_service *__connman_service_create_from_network(struct connman_network *network);
 
+int __connman_service_set_carrier(struct connman_service *service,
+						connman_bool_t carrier);
+
 #include <connman/notifier.h>
 
 int __connman_notifier_init(void);
diff --git a/src/profile.c b/src/profile.c
index eeb777f1..cad8a359 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -122,7 +122,7 @@ int __connman_profile_set_carrier(struct connman_device *device,
 	if (service == NULL)
 		return -EINVAL;
 
-	return connman_service_set_favorite(service, carrier);
+	return __connman_service_set_carrier(service, carrier);
 }
 
 int __connman_profile_add_network(struct connman_network *network)
diff --git a/src/service.c b/src/service.c
index 4c55555f..084ffb03 100644
--- a/src/service.c
+++ b/src/service.c
@@ -121,6 +121,8 @@ static const char *state2string(enum connman_service_state state)
 		break;
 	case CONNMAN_SERVICE_STATE_IDLE:
 		return "idle";
+	case CONNMAN_SERVICE_STATE_CARRIER:
+		return "carrier";
 	case CONNMAN_SERVICE_STATE_ASSOCIATION:
 		return "association";
 	case CONNMAN_SERVICE_STATE_CONFIGURATION:
@@ -429,6 +431,26 @@ int connman_service_set_favorite(struct connman_service *service,
 	return 0;
 }
 
+int __connman_service_set_carrier(struct connman_service *service,
+						connman_bool_t carrier)
+{
+	switch (service->type) {
+	case CONNMAN_SERVICE_TYPE_UNKNOWN:
+	case CONNMAN_SERVICE_TYPE_WIFI:
+	case CONNMAN_SERVICE_TYPE_WIMAX:
+		return -EINVAL;
+	case CONNMAN_SERVICE_TYPE_ETHERNET:
+		break;
+	}
+
+	if (carrier == TRUE)
+		service->state = CONNMAN_SERVICE_STATE_CARRIER;
+	else
+		service->state = CONNMAN_SERVICE_STATE_IDLE;
+
+	return connman_service_set_favorite(service, carrier);
+}
+
 /**
  * connman_service_lookup:
  * @identifier: service identifier

commit bae941e82a41fba45364ec3fa3dff6221f086e46
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:17:41 2009 +0100

    Add basic handling of configuration state

diff --git a/src/connman.h b/src/connman.h
index d66e0cf7..f370e0d0 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -190,8 +190,6 @@ int __connman_device_set_offlinemode(connman_bool_t offlinemode);
 
 int __connman_profile_add_device(struct connman_device *device);
 int __connman_profile_remove_device(struct connman_device *device);
-int __connman_profile_set_carrier(struct connman_device *device,
-						connman_bool_t carrier);
 
 #include <connman/network.h>
 
@@ -226,6 +224,7 @@ struct connman_service *__connman_service_create_from_network(struct connman_net
 
 int __connman_service_set_carrier(struct connman_service *service,
 						connman_bool_t carrier);
+int __connman_service_indicate_configuration(struct connman_service *service);
 
 #include <connman/notifier.h>
 
diff --git a/src/device.c b/src/device.c
index b5d7cd66..b0210b0c 100644
--- a/src/device.c
+++ b/src/device.c
@@ -161,7 +161,10 @@ static enum connman_device_policy string2policy(const char *policy)
 
 static int set_carrier(struct connman_device *device, connman_bool_t carrier)
 {
-	__connman_profile_set_carrier(device, carrier);
+	struct connman_service *service;
+
+	service = __connman_service_lookup_from_device(device);
+	__connman_service_set_carrier(service, carrier);
 
 	if (carrier == TRUE) {
 		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
@@ -187,6 +190,8 @@ static int set_carrier(struct connman_device *device, connman_bool_t carrier)
 			if (connman_element_register(element,
 							&device->element) < 0)
 				connman_element_unref(element);
+
+			__connman_service_indicate_configuration(service);
 		}
 	} else
 		connman_element_unregister_children(&device->element);
diff --git a/src/profile.c b/src/profile.c
index cad8a359..f12bdb84 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -111,20 +111,6 @@ int __connman_profile_remove_device(struct connman_device *device)
 	return 0;
 }
 
-int __connman_profile_set_carrier(struct connman_device *device,
-						connman_bool_t carrier)
-{
-	struct connman_service *service;
-
-	DBG("device %p carrier %d", device, carrier);
-
-	service = __connman_service_lookup_from_device(device);
-	if (service == NULL)
-		return -EINVAL;
-
-	return __connman_service_set_carrier(service, carrier);
-}
-
 int __connman_profile_add_network(struct connman_network *network)
 {
 	struct connman_service *service;
diff --git a/src/service.c b/src/service.c
index 084ffb03..7b765c26 100644
--- a/src/service.c
+++ b/src/service.c
@@ -434,6 +434,9 @@ int connman_service_set_favorite(struct connman_service *service,
 int __connman_service_set_carrier(struct connman_service *service,
 						connman_bool_t carrier)
 {
+	if (service == NULL)
+		return -EINVAL;
+
 	switch (service->type) {
 	case CONNMAN_SERVICE_TYPE_UNKNOWN:
 	case CONNMAN_SERVICE_TYPE_WIFI:
@@ -451,6 +454,16 @@ int __connman_service_set_carrier(struct connman_service *service,
 	return connman_service_set_favorite(service, carrier);
 }
 
+int __connman_service_indicate_configuration(struct connman_service *service)
+{
+	if (service == NULL)
+		return -EINVAL;
+
+	service->state = CONNMAN_SERVICE_STATE_CONFIGURATION;
+
+	return 0;
+}
+
 /**
  * connman_service_lookup:
  * @identifier: service identifier

commit f6ba1ce230293171982ae107adc20e5a6a5d2a0e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:23:18 2009 +0100

    Only add WiFi and WiMAX networks to service list for now

diff --git a/src/network.c b/src/network.c
index f5e512e9..7375d7f5 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1100,7 +1100,18 @@ static int network_probe(struct connman_element *element)
 		return err;
 	}
 
-	__connman_profile_add_network(network);
+	switch (network->type) {
+	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+	case CONNMAN_NETWORK_TYPE_VENDOR:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
+	case CONNMAN_NETWORK_TYPE_HSO:
+		break;
+	case CONNMAN_NETWORK_TYPE_WIFI:
+	case CONNMAN_NETWORK_TYPE_WIMAX:
+		__connman_profile_add_network(network);
+		break;
+	}
 
 	return 0;
 }
@@ -1117,7 +1128,18 @@ static void network_remove(struct connman_element *element)
 	if (network->driver == NULL)
 		return;
 
-	__connman_profile_remove_network(network);
+	switch (network->type) {
+	case CONNMAN_NETWORK_TYPE_UNKNOWN:
+	case CONNMAN_NETWORK_TYPE_VENDOR:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_PAN:
+	case CONNMAN_NETWORK_TYPE_BLUETOOTH_DUN:
+	case CONNMAN_NETWORK_TYPE_HSO:
+		break;
+	case CONNMAN_NETWORK_TYPE_WIFI:
+	case CONNMAN_NETWORK_TYPE_WIMAX:
+		__connman_profile_remove_network(network);
+		break;
+	}
 
 	unregister_interface(element);
 

commit e95ec7c1d780788f4c85a630d5dc4c84d36353e9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:33:42 2009 +0100

    Fix carrier and disconnected interaction

diff --git a/src/device.c b/src/device.c
index b0210b0c..13684ee0 100644
--- a/src/device.c
+++ b/src/device.c
@@ -170,6 +170,18 @@ static int set_carrier(struct connman_device *device, connman_bool_t carrier)
 		enum connman_element_type type = CONNMAN_ELEMENT_TYPE_UNKNOWN;
 		struct connman_element *element;
 
+		device->disconnected = TRUE;
+
+		switch (device->policy) {
+		case CONNMAN_DEVICE_POLICY_UNKNOWN:
+		case CONNMAN_DEVICE_POLICY_IGNORE:
+		case CONNMAN_DEVICE_POLICY_OFF:
+		case CONNMAN_DEVICE_POLICY_MANUAL:
+			return 0;
+		case CONNMAN_DEVICE_POLICY_AUTO:
+			break;
+		}
+
 		switch (device->element.ipv4.method) {
 		case CONNMAN_IPV4_METHOD_UNKNOWN:
 		case CONNMAN_IPV4_METHOD_OFF:
@@ -191,6 +203,8 @@ static int set_carrier(struct connman_device *device, connman_bool_t carrier)
 							&device->element) < 0)
 				connman_element_unref(element);
 
+			device->disconnected = FALSE;
+
 			__connman_service_indicate_configuration(service);
 		}
 	} else
@@ -1258,19 +1272,6 @@ int connman_device_set_carrier(struct connman_device *device,
 
 	device->carrier = carrier;
 
-	if (carrier == TRUE)
-		device->disconnected = FALSE;
-
-	switch (device->policy) {
-	case CONNMAN_DEVICE_POLICY_UNKNOWN:
-	case CONNMAN_DEVICE_POLICY_IGNORE:
-	case CONNMAN_DEVICE_POLICY_OFF:
-		return 0;
-	case CONNMAN_DEVICE_POLICY_AUTO:
-	case CONNMAN_DEVICE_POLICY_MANUAL:
-		break;
-	}
-
 	return set_carrier(device, device->carrier);
 }
 

commit db8a2e1563f59e4dde4517013c7e346ffe95278e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:43:37 2009 +0100

    Send signals for service state changes

diff --git a/src/service.c b/src/service.c
index 7b765c26..d2174414 100644
--- a/src/service.c
+++ b/src/service.c
@@ -138,6 +138,27 @@ static const char *state2string(enum connman_service_state state)
 	return NULL;
 }
 
+static void state_changed(struct connman_service *service)
+{
+	DBusMessage *signal;
+	DBusMessageIter entry;
+	const char *str;
+
+	str = state2string(service->state);
+	if (str == NULL)
+		return;
+
+	signal = dbus_message_new_signal(service->path,
+				CONNMAN_SERVICE_INTERFACE, "PropertyChanged");
+	if (signal == NULL)
+		return;
+
+	dbus_message_iter_init_append(signal, &entry);
+	connman_dbus_dict_append_variant(&entry, "State",
+						DBUS_TYPE_STRING, &str);
+	g_dbus_send_message(connection, signal);
+}
+
 static DBusMessage *get_properties(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -205,6 +226,8 @@ static DBusMessage *connect_service(DBusConnection *conn,
 			return __connman_error_failed(msg);
 
 		service->state = CONNMAN_SERVICE_STATE_READY;
+
+		state_changed(service);
 	}
 
 	return __connman_error_not_supported(msg);
@@ -220,6 +243,8 @@ static DBusMessage *disconnect_service(DBusConnection *conn,
 			return __connman_error_failed(msg);
 
 		service->state = CONNMAN_SERVICE_STATE_IDLE;
+
+		state_changed(service);
 	}
 
 	return __connman_error_not_supported(msg);
@@ -451,6 +476,8 @@ int __connman_service_set_carrier(struct connman_service *service,
 	else
 		service->state = CONNMAN_SERVICE_STATE_IDLE;
 
+	state_changed(service);
+
 	return connman_service_set_favorite(service, carrier);
 }
 
@@ -461,6 +488,8 @@ int __connman_service_indicate_configuration(struct connman_service *service)
 
 	service->state = CONNMAN_SERVICE_STATE_CONFIGURATION;
 
+	state_changed(service);
+
 	return 0;
 }
 

commit 8c7485826f2d337dd6f5b69275f254c301df1286
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:45:06 2009 +0100

    Check that service is actually registered

diff --git a/src/service.c b/src/service.c
index d2174414..b2d09a8e 100644
--- a/src/service.c
+++ b/src/service.c
@@ -144,6 +144,9 @@ static void state_changed(struct connman_service *service)
 	DBusMessageIter entry;
 	const char *str;
 
+	if (service->path == NULL)
+		return;
+
 	str = state2string(service->state);
 	if (str == NULL)
 		return;

commit 6c6839b5d7ee0826523ab8a49beb2484e923db61
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 05:57:29 2009 +0100

    Rename helper function to get device/network path

diff --git a/src/connection.c b/src/connection.c
index 62d6a31d..6fb1d764 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -349,12 +349,12 @@ static DBusMessage *get_properties(DBusConnection *conn,
 	connman_dbus_dict_append_variant(&dict, "Default",
 					DBUS_TYPE_BOOLEAN, &element->enabled);
 
-	device = __connman_element_get_device(element);
+	device = __connman_element_get_device_path(element);
 	if (device != NULL)
 		connman_dbus_dict_append_variant(&dict, "Device",
 					DBUS_TYPE_OBJECT_PATH, &device);
 
-	network = __connman_element_get_network(element);
+	network = __connman_element_get_network_path(element);
 	if (network != NULL)
 		connman_dbus_dict_append_variant(&dict, "Network",
 					DBUS_TYPE_OBJECT_PATH, &network);
diff --git a/src/connman.h b/src/connman.h
index f370e0d0..4ac49a74 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -127,8 +127,8 @@ void __connman_element_list(struct connman_element *element,
 int __connman_element_count(struct connman_element *element,
 					enum connman_element_type type);
 
-const char *__connman_element_get_device(struct connman_element *element);
-const char *__connman_element_get_network(struct connman_element *element);
+const char *__connman_element_get_device_path(struct connman_element *element);
+const char *__connman_element_get_network_path(struct connman_element *element);
 
 const char *__connman_element_type2string(enum connman_element_type type);
 
diff --git a/src/element.c b/src/element.c
index 7b24a98e..3b021da4 100644
--- a/src/element.c
+++ b/src/element.c
@@ -272,7 +272,7 @@ int __connman_element_count(struct connman_element *element,
 	return data.count;
 }
 
-const char *__connman_element_get_device(struct connman_element *element)
+const char *__connman_element_get_device_path(struct connman_element *element)
 {
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
 						element->device != NULL)
@@ -281,10 +281,10 @@ const char *__connman_element_get_device(struct connman_element *element)
 	if (element->parent == NULL)
 		return NULL;
 
-	return __connman_element_get_device(element->parent);
+	return __connman_element_get_device_path(element->parent);
 }
 
-const char *__connman_element_get_network(struct connman_element *element)
+const char *__connman_element_get_network_path(struct connman_element *element)
 {
 	if (element->type == CONNMAN_ELEMENT_TYPE_NETWORK &&
 						element->network != NULL)
@@ -293,7 +293,7 @@ const char *__connman_element_get_network(struct connman_element *element)
 	if (element->parent == NULL)
 		return NULL;
 
-	return __connman_element_get_network(element->parent);
+	return __connman_element_get_network_path(element->parent);
 }
 
 static gint compare_priority(gconstpointer a, gconstpointer b)

commit 3acabae42ea6db35c5937d5ac21ee61274bf4cdf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 06:01:12 2009 +0100

    Add function to retrieve device from an element

diff --git a/src/connman.h b/src/connman.h
index 4ac49a74..b7be4e85 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -127,6 +127,7 @@ void __connman_element_list(struct connman_element *element,
 int __connman_element_count(struct connman_element *element,
 					enum connman_element_type type);
 
+struct connman_device *__connman_element_get_device(struct connman_element *element);
 const char *__connman_element_get_device_path(struct connman_element *element);
 const char *__connman_element_get_network_path(struct connman_element *element);
 
diff --git a/src/element.c b/src/element.c
index 3b021da4..30e6963d 100644
--- a/src/element.c
+++ b/src/element.c
@@ -272,16 +272,27 @@ int __connman_element_count(struct connman_element *element,
 	return data.count;
 }
 
-const char *__connman_element_get_device_path(struct connman_element *element)
+struct connman_device *__connman_element_get_device(struct connman_element *element)
 {
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
 						element->device != NULL)
-		return element->path;
+		return element->device;
 
 	if (element->parent == NULL)
 		return NULL;
 
-	return __connman_element_get_device_path(element->parent);
+	return __connman_element_get_device(element->parent);
+}
+
+const char *__connman_element_get_device_path(struct connman_element *element)
+{
+	struct connman_device *device;
+
+	device = __connman_element_get_device(element);
+	if (device == NULL)
+		return NULL;
+
+	return element->path;
 }
 
 const char *__connman_element_get_network_path(struct connman_element *element)

commit 08c0c3a49b4b02add54856948629dd57b3927791
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 06:13:25 2009 +0100

    Add support for service ready and disconnect state changes

diff --git a/src/connection.c b/src/connection.c
index 6fb1d764..0d544eb7 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -467,6 +467,7 @@ static void unregister_interface(struct connman_element *element)
 
 static int connection_probe(struct connman_element *element)
 {
+	struct connman_service *service;
 	const char *gateway = NULL;
 
 	DBG("element %p name %s", element, element->name);
@@ -485,6 +486,9 @@ static int connection_probe(struct connman_element *element)
 	if (register_interface(element) < 0)
 		return -ENODEV;
 
+	service = __connman_element_get_service(element);
+	__connman_service_ready(service);
+
 	if (gateway == NULL)
 		return 0;
 
@@ -509,10 +513,14 @@ done:
 
 static void connection_remove(struct connman_element *element)
 {
+	struct connman_service *service;
 	const char *gateway = NULL;
 
 	DBG("element %p name %s", element, element->name);
 
+	service = __connman_element_get_service(element);
+	__connman_service_disconnect(service);
+
 	unregister_interface(element);
 
 	connman_element_get_value(element,
diff --git a/src/connman.h b/src/connman.h
index b7be4e85..e13c3de7 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -127,6 +127,7 @@ void __connman_element_list(struct connman_element *element,
 int __connman_element_count(struct connman_element *element,
 					enum connman_element_type type);
 
+struct connman_service *__connman_element_get_service(struct connman_element *element);
 struct connman_device *__connman_element_get_device(struct connman_element *element);
 const char *__connman_element_get_device_path(struct connman_element *element);
 const char *__connman_element_get_network_path(struct connman_element *element);
@@ -226,6 +227,8 @@ struct connman_service *__connman_service_create_from_network(struct connman_net
 int __connman_service_set_carrier(struct connman_service *service,
 						connman_bool_t carrier);
 int __connman_service_indicate_configuration(struct connman_service *service);
+int __connman_service_ready(struct connman_service *service);
+int __connman_service_disconnect(struct connman_service *service);
 
 #include <connman/notifier.h>
 
diff --git a/src/element.c b/src/element.c
index 30e6963d..3dc15045 100644
--- a/src/element.c
+++ b/src/element.c
@@ -272,6 +272,38 @@ int __connman_element_count(struct connman_element *element,
 	return data.count;
 }
 
+struct connman_service *__connman_element_get_service(struct connman_element *element)
+{
+	struct connman_service *service;
+	struct connman_device *device;
+	enum connman_device_type type;
+
+	device = __connman_element_get_device(element);
+	if (device == NULL)
+		return NULL;
+
+	type = connman_device_get_type(device);
+
+	switch (type) {
+	case CONNMAN_DEVICE_TYPE_UNKNOWN:
+	case CONNMAN_DEVICE_TYPE_VENDOR:
+	case CONNMAN_DEVICE_TYPE_WIFI:
+	case CONNMAN_DEVICE_TYPE_WIMAX:
+	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
+	case CONNMAN_DEVICE_TYPE_GPS:
+	case CONNMAN_DEVICE_TYPE_HSO:
+	case CONNMAN_DEVICE_TYPE_NOZOMI:
+	case CONNMAN_DEVICE_TYPE_HUAWEI:
+	case CONNMAN_DEVICE_TYPE_NOVATEL:
+		return NULL;
+	case CONNMAN_DEVICE_TYPE_ETHERNET:
+		service = __connman_service_lookup_from_device(device);
+		break;
+	}
+
+	return service;
+}
+
 struct connman_device *__connman_element_get_device(struct connman_element *element)
 {
 	if (element->type == CONNMAN_ELEMENT_TYPE_DEVICE &&
diff --git a/src/service.c b/src/service.c
index b2d09a8e..8e31511b 100644
--- a/src/service.c
+++ b/src/service.c
@@ -496,6 +496,30 @@ int __connman_service_indicate_configuration(struct connman_service *service)
 	return 0;
 }
 
+int __connman_service_ready(struct connman_service *service)
+{
+	if (service == NULL)
+		return -EINVAL;
+
+	service->state = CONNMAN_SERVICE_STATE_READY;
+
+	state_changed(service);
+
+	return 0;
+}
+
+int __connman_service_disconnect(struct connman_service *service)
+{
+	if (service == NULL)
+		return -EINVAL;
+
+	service->state = CONNMAN_SERVICE_STATE_DISCONNECT;
+
+	state_changed(service);
+
+	return 0;
+}
+
 /**
  * connman_service_lookup:
  * @identifier: service identifier

commit 15787f609916d93ea6d8c8362d1a6aefae54ae97
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 06:15:01 2009 +0100

    Add extra debug messages for service state changes

diff --git a/src/service.c b/src/service.c
index 8e31511b..c5562293 100644
--- a/src/service.c
+++ b/src/service.c
@@ -462,6 +462,8 @@ int connman_service_set_favorite(struct connman_service *service,
 int __connman_service_set_carrier(struct connman_service *service,
 						connman_bool_t carrier)
 {
+	DBG("service %p carrier %d", service, carrier);
+
 	if (service == NULL)
 		return -EINVAL;
 
@@ -486,6 +488,8 @@ int __connman_service_set_carrier(struct connman_service *service,
 
 int __connman_service_indicate_configuration(struct connman_service *service)
 {
+	DBG("service %p", service);
+
 	if (service == NULL)
 		return -EINVAL;
 
@@ -498,6 +502,8 @@ int __connman_service_indicate_configuration(struct connman_service *service)
 
 int __connman_service_ready(struct connman_service *service)
 {
+	DBG("service %p", service);
+
 	if (service == NULL)
 		return -EINVAL;
 
@@ -510,6 +516,8 @@ int __connman_service_ready(struct connman_service *service)
 
 int __connman_service_disconnect(struct connman_service *service)
 {
+	DBG("service %p", service);
+
 	if (service == NULL)
 		return -EINVAL;
 

commit 61b634632e62251647cede96476091c626a6b56c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 11:42:22 2009 +0100

    Fix broken service state change signal

diff --git a/src/service.c b/src/service.c
index c5562293..7a8d14fb 100644
--- a/src/service.c
+++ b/src/service.c
@@ -141,8 +141,8 @@ static const char *state2string(enum connman_service_state state)
 static void state_changed(struct connman_service *service)
 {
 	DBusMessage *signal;
-	DBusMessageIter entry;
-	const char *str;
+	DBusMessageIter entry, value;
+	const char *str, *key = "State";
 
 	if (service->path == NULL)
 		return;
@@ -157,8 +157,14 @@ static void state_changed(struct connman_service *service)
 		return;
 
 	dbus_message_iter_init_append(signal, &entry);
-	connman_dbus_dict_append_variant(&entry, "State",
-						DBUS_TYPE_STRING, &str);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+					DBUS_TYPE_STRING_AS_STRING, &value);
+	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, &str);
+	dbus_message_iter_close_container(&entry, &value);
+
 	g_dbus_send_message(connection, signal);
 }
 

commit 961d5b2ce43b5cca65cef2e9e34be60f92435f65
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 21 23:50:26 2009 +0100

    Add debug output for used domain name server

diff --git a/plugins/dnsproxy.c b/plugins/dnsproxy.c
index b682d82d..ff7ce8a1 100644
--- a/plugins/dnsproxy.c
+++ b/plugins/dnsproxy.c
@@ -542,6 +542,8 @@ static gboolean listener_event(GIOChannel *channel, GIOCondition condition,
 	for (list = server_list; list; list = list->next) {
 		struct server_data *data = list->data;
 
+		DBG("server %s domain %s", data->server, data->domain);
+
 		sk = g_io_channel_unix_get_fd(data->channel);
 
 		err = send(sk, buf, len, 0);

commit 3879bf3074ad4611027ea8022e1fd53022eda883
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 16:27:11 2009 +0100

    Handle errors with DBusPendingCall and lost connection

diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 12519c5a..009c6c7d 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -117,6 +117,13 @@ static void get_properties(DBusConnection *connection,
 		return;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		g_free(data);
+		return;
+	}
+
 	data->connection = connection;
 	data->message    = message;
 	data->callback   = callback;
@@ -240,6 +247,12 @@ static int pan_connect(struct connman_network *network)
 		return -EINVAL;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		return -EINVAL;
+	}
+
 	dbus_pending_call_set_notify(call, connect_reply, network, NULL);
 
 	dbus_message_unref(message);
@@ -307,6 +320,12 @@ static int pan_disconnect(struct connman_network *network)
 		return -EINVAL;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		return -EINVAL;
+	}
+
 	dbus_pending_call_set_notify(call, disconnect_reply, network, NULL);
 
 	dbus_message_unref(message);
@@ -393,6 +412,12 @@ static int change_powered(DBusConnection *connection, const char *path,
 		return -EINVAL;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		return -EINVAL;
+	}
+
 	dbus_pending_call_set_notify(call, powered_reply, NULL, NULL);
 
 	dbus_message_unref(message);
@@ -718,13 +743,18 @@ static void bluetooth_connect(DBusConnection *connection, void *user_data)
 	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to get Bluetooth adapters");
-		dbus_message_unref(message);
-		return;
+		goto done;
+	}
+
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		goto done;
 	}
 
 	dbus_pending_call_set_notify(call, list_adapters_reply,
 							connection, NULL);
 
+done:
 	dbus_message_unref(message);
 }
 
diff --git a/plugins/modemmgr.c b/plugins/modemmgr.c
index cbb5ebd5..0950848c 100644
--- a/plugins/modemmgr.c
+++ b/plugins/modemmgr.c
@@ -65,13 +65,18 @@ static void modemmgr_connect(DBusConnection *connection, void *user_data)
 	if (dbus_connection_send_with_reply(connection, message,
 						&call, TIMEOUT) == FALSE) {
 		connman_error("Failed to get modem devices");
-		dbus_message_unref(message);
-		return;
+		goto done;
+	}
+
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		goto done;
 	}
 
 	dbus_pending_call_set_notify(call, enumerate_devices_reply,
 							NULL, NULL);
 
+done:
 	dbus_message_unref(message);
 }
 
diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index 69ef3728..fc57d35b 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -279,6 +279,12 @@ static int add_interface(struct supplicant_task *task)
 		return -EIO;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
 	dbus_pending_call_set_notify(call, add_interface_reply, task, NULL);
 
 	dbus_message_unref(message);
@@ -349,6 +355,12 @@ static int create_interface(struct supplicant_task *task)
 		return -EIO;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
 	dbus_pending_call_set_notify(call, get_interface_reply, task, NULL);
 
 	dbus_message_unref(message);
@@ -401,6 +413,12 @@ static int remove_interface(struct supplicant_task *task)
 		return -EIO;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		return -EIO;
+	}
+
 	dbus_pending_call_set_notify(call, remove_interface_reply, task, NULL);
 
 	dbus_message_unref(message);
@@ -1129,6 +1147,12 @@ static void get_properties(struct supplicant_task *task)
 		goto noscan;
 	}
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		dbus_message_unref(message);
+		goto noscan;
+	}
+
 	dbus_pending_call_set_notify(call, properties_reply, task, NULL);
 
 	dbus_message_unref(message);
@@ -1220,6 +1244,11 @@ static void scan_results_available(struct supplicant_task *task)
 	if (task->noscan == FALSE)
 		connman_device_set_scanning(task->device, TRUE);
 
+	if (call == NULL) {
+		connman_error("D-Bus connection not available");
+		goto done;
+	}
+
 	dbus_pending_call_set_notify(call, scan_results_reply, task, NULL);
 
 done:

commit 509ec7575e2b784e6ad5088048b5dc88689b80c8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 16:33:12 2009 +0100

    Fix handling of networks without a group name

diff --git a/src/service.c b/src/service.c
index 7a8d14fb..b9f657e5 100644
--- a/src/service.c
+++ b/src/service.c
@@ -592,11 +592,15 @@ static int service_register(struct connman_service *service)
 {
 	const char *path = __connman_profile_active();
 
+	DBG("service %p", service);
+
 	if (service->path != NULL)
 		return -EALREADY;
 
 	service->path = g_strdup_printf("%s/%s", path, service->identifier);
 
+	DBG("path %s", service->path);
+
 	g_dbus_register_interface(connection, service->path,
 					CONNMAN_SERVICE_INTERFACE,
 					service_methods, service_signals,
@@ -696,10 +700,15 @@ done:
 struct connman_service *__connman_service_lookup_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
+	const char *group;
 	char *name;
 
-	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
-					__connman_network_get_group(network));
+	group = __connman_network_get_group(network);
+	if (group == NULL)
+		return NULL;
+
+	name = g_strdup_printf("%s_%s",
+				__connman_network_get_type(network), group);
 
 	service = connman_service_lookup(name);
 
@@ -737,10 +746,15 @@ static enum connman_service_type convert_network_type(struct connman_network *ne
 struct connman_service *__connman_service_create_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
+	const char *group;
 	char *name;
 
-	name = g_strdup_printf("%s_%s", __connman_network_get_type(network),
-					__connman_network_get_group(network));
+	group = __connman_network_get_group(network);
+	if (group == NULL)
+		return NULL;
+
+	name = g_strdup_printf("%s_%s",
+				__connman_network_get_type(network), group);
 
 	service = connman_service_get(name);
 	if (service == NULL)

commit 8380d01bf815b9d9e53b9ef6cb642e011f2afe33
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 16:48:17 2009 +0100

    Add properties for WiFi services

diff --git a/src/service.c b/src/service.c
index b9f657e5..3f730aa3 100644
--- a/src/service.c
+++ b/src/service.c
@@ -737,6 +737,34 @@ static enum connman_service_type convert_network_type(struct connman_network *ne
 	return CONNMAN_SERVICE_TYPE_UNKNOWN;
 }
 
+static enum connman_service_mode convert_wifi_mode(const char *mode)
+{
+	if (mode == NULL)
+		return CONNMAN_SERVICE_MODE_UNKNOWN;
+	else if (g_str_equal(mode, "managed") == 0)
+		return CONNMAN_SERVICE_MODE_MANAGED;
+	else if (g_str_equal(mode, "adhoc") == 0)
+		return CONNMAN_SERVICE_MODE_ADHOC;
+	else
+		return CONNMAN_SERVICE_MODE_UNKNOWN;
+}
+
+static enum connman_service_mode convert_wifi_security(const char *security)
+{
+	if (security == NULL)
+		return CONNMAN_SERVICE_SECURITY_UNKNOWN;
+	else if (g_str_equal(security, "none") == 0)
+		return CONNMAN_SERVICE_SECURITY_NONE;
+	else if (g_str_equal(security, "wep") == 0)
+		return CONNMAN_SERVICE_SECURITY_WEP;
+	else if (g_str_equal(security, "wpa") == 0)
+		return CONNMAN_SERVICE_SECURITY_WPA;
+	else if (g_str_equal(security, "wpa2") == 0)
+		return CONNMAN_SERVICE_SECURITY_WPA2;
+	else
+		return CONNMAN_SERVICE_SECURITY_UNKNOWN;
+}
+
 /**
  * connman_service_create_from_network:
  * @device: device structure
@@ -746,7 +774,7 @@ static enum connman_service_type convert_network_type(struct connman_network *ne
 struct connman_service *__connman_service_create_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
-	const char *group;
+	const char *group, *str;
 	char *name;
 
 	group = __connman_network_get_group(network);
@@ -768,6 +796,15 @@ struct connman_service *__connman_service_create_from_network(struct connman_net
 
 	service->type = convert_network_type(network);
 
+	service->name = g_strdup(connman_network_get_string(network, "Name"));
+	service->strength = connman_network_get_uint8(network, "Strength");
+
+	str = connman_network_get_string(network, "WiFi.Mode");
+	service->mode = convert_wifi_mode(str);
+
+	str = connman_network_get_string(network, "WiFi.Security");
+	service->security = convert_wifi_security(str);
+
 	service_register(service);
 
 done:

commit 8d7aee1581144c2e8ca664aebc36ef61a32f69ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 16:58:54 2009 +0100

    Fix missing call to trigger service list resorting

diff --git a/src/service.c b/src/service.c
index 3f730aa3..106595b9 100644
--- a/src/service.c
+++ b/src/service.c
@@ -774,6 +774,7 @@ static enum connman_service_mode convert_wifi_security(const char *security)
 struct connman_service *__connman_service_create_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
+	GSequenceIter *iter;
 	const char *group, *str;
 	char *name;
 
@@ -805,6 +806,10 @@ struct connman_service *__connman_service_create_from_network(struct connman_net
 	str = connman_network_get_string(network, "WiFi.Security");
 	service->security = convert_wifi_security(str);
 
+	iter = g_hash_table_lookup(service_hash, service->identifier);
+	if (iter != NULL)
+		g_sequence_sort_changed(iter, service_compare, NULL);
+
 	service_register(service);
 
 done:

commit 601103f1737b2e9a3243f2bcc1dcd06bdd55d388
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 17:06:16 2009 +0100

    Fix broken mode and security string comparison

diff --git a/src/service.c b/src/service.c
index 106595b9..768e9743 100644
--- a/src/service.c
+++ b/src/service.c
@@ -741,9 +741,9 @@ static enum connman_service_mode convert_wifi_mode(const char *mode)
 {
 	if (mode == NULL)
 		return CONNMAN_SERVICE_MODE_UNKNOWN;
-	else if (g_str_equal(mode, "managed") == 0)
+	else if (g_str_equal(mode, "managed") == TRUE)
 		return CONNMAN_SERVICE_MODE_MANAGED;
-	else if (g_str_equal(mode, "adhoc") == 0)
+	else if (g_str_equal(mode, "adhoc") == TRUE)
 		return CONNMAN_SERVICE_MODE_ADHOC;
 	else
 		return CONNMAN_SERVICE_MODE_UNKNOWN;
@@ -753,13 +753,13 @@ static enum connman_service_mode convert_wifi_security(const char *security)
 {
 	if (security == NULL)
 		return CONNMAN_SERVICE_SECURITY_UNKNOWN;
-	else if (g_str_equal(security, "none") == 0)
+	else if (g_str_equal(security, "none") == TRUE)
 		return CONNMAN_SERVICE_SECURITY_NONE;
-	else if (g_str_equal(security, "wep") == 0)
+	else if (g_str_equal(security, "wep") == TRUE)
 		return CONNMAN_SERVICE_SECURITY_WEP;
-	else if (g_str_equal(security, "wpa") == 0)
+	else if (g_str_equal(security, "wpa") == TRUE)
 		return CONNMAN_SERVICE_SECURITY_WPA;
-	else if (g_str_equal(security, "wpa2") == 0)
+	else if (g_str_equal(security, "wpa2") == TRUE)
 		return CONNMAN_SERVICE_SECURITY_WPA2;
 	else
 		return CONNMAN_SERVICE_SECURITY_UNKNOWN;

commit 39c111ac510f17fbd916d8bed389db24a18c4bd6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 18:51:50 2009 +0100

    Add support for service passphrase handling

diff --git a/doc/service-api.txt b/doc/service-api.txt
index 4e090567..48649512 100644
--- a/doc/service-api.txt
+++ b/doc/service-api.txt
@@ -122,6 +122,14 @@ Properties	string State [readonly]
 			This property might be only present for WiFi
 			services.
 
+		string Passphrase [readwrite]
+
+			If the service type is WiFi, then this property
+			can be used to store a passphrase.
+
+			This property is still experimental and might be
+			removed in future version.
+
 		uint8 Strength [readonly]
 
 			Indicates the signal strength of the service. This
diff --git a/src/service.c b/src/service.c
index 768e9743..22c40570 100644
--- a/src/service.c
+++ b/src/service.c
@@ -44,7 +44,9 @@ struct connman_service {
 	connman_bool_t favorite;
 	unsigned int order;
 	char *name;
+	char *passphrase;
 	struct connman_device *device;
+	struct connman_network *network;
 };
 
 static void append_path(gpointer value, gpointer user_data)
@@ -220,11 +222,63 @@ static DBusMessage *get_properties(DBusConnection *conn,
 		connman_dbus_dict_append_variant(&dict, "Name",
 					DBUS_TYPE_STRING, &service->name);
 
+	if (service->passphrase != NULL &&
+			__connman_security_check_privilege(msg,
+				CONNMAN_SECURITY_PRIVILEGE_SECRET) == 0)
+		connman_dbus_dict_append_variant(&dict, "Passphrase",
+				DBUS_TYPE_STRING, &service->passphrase);
+
 	dbus_message_iter_close_container(&array, &dict);
 
 	return reply;
 }
 
+static DBusMessage *set_property(DBusConnection *conn,
+					DBusMessage *msg, void *data)
+{
+	struct connman_service *service = data;
+	DBusMessageIter iter, value;
+	const char *name;
+	int type;
+
+	DBG("conn %p", conn);
+
+	if (dbus_message_iter_init(msg, &iter) == FALSE)
+		return __connman_error_invalid_arguments(msg);
+
+	dbus_message_iter_get_basic(&iter, &name);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &value);
+
+	if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_MODIFY) < 0)
+		return __connman_error_permission_denied(msg);
+
+	type = dbus_message_iter_get_arg_type(&value);
+
+	if (g_str_equal(name, "Passphrase") == TRUE) {
+		const char *passphrase;
+
+		if (type != DBUS_TYPE_STRING)
+			return __connman_error_invalid_arguments(msg);
+
+		if (__connman_security_check_privilege(msg,
+					CONNMAN_SECURITY_PRIVILEGE_SECRET) < 0)
+			return __connman_error_permission_denied(msg);
+
+		dbus_message_iter_get_basic(&value, &passphrase);
+
+		g_free(service->passphrase);
+		service->passphrase = g_strdup(passphrase);
+
+		if (service->network != NULL)
+			connman_network_set_string(service->network,
+				"WiFi.Passphrase", service->passphrase);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static DBusMessage *connect_service(DBusConnection *conn,
 					DBusMessage *msg, void *data)
 {
@@ -295,12 +349,13 @@ static DBusMessage *move_after(DBusConnection *conn,
 }
 
 static GDBusMethodTable service_methods[] = {
-	{ "GetProperties", "",  "a{sv}", get_properties     },
-	{ "Connect",       "",  "",      connect_service    },
-	{ "Disconnect",    "",  "",      disconnect_service },
-	{ "Remove",        "",  "",      remove_service     },
-	{ "MoveBefore",    "o", "",      move_before        },
-	{ "MoveAfter",     "o", "",      move_after         },
+	{ "GetProperties", "",   "a{sv}", get_properties     },
+	{ "SetProperty",   "sv", "",      set_property       },
+	{ "Connect",       "",   "",      connect_service    },
+	{ "Disconnect",    "",   "",      disconnect_service },
+	{ "Remove",        "",   "",      remove_service     },
+	{ "MoveBefore",    "o",  "",      move_before        },
+	{ "MoveAfter",     "o",  "",      move_after         },
 	{ },
 };
 
@@ -328,7 +383,11 @@ static void service_free(gpointer data)
 		g_free(path);
 	}
 
+	if (service->network != NULL)
+		connman_network_unref(service->network);
+
 	g_free(service->name);
+	g_free(service->passphrase);
 	g_free(service->identifier);
 	g_free(service);
 }
@@ -693,7 +752,7 @@ done:
 
 /**
  * connman_service_lookup_from_network:
- * @device: device structure
+ * @network: network structure
  *
  * Look up a service by network (reference count will not be increased)
  */
@@ -765,17 +824,57 @@ static enum connman_service_mode convert_wifi_security(const char *security)
 		return CONNMAN_SERVICE_SECURITY_UNKNOWN;
 }
 
+static void update_from_network(struct connman_service *service,
+					struct connman_network *network)
+{
+	connman_uint8_t strength = service->strength;
+	GSequenceIter *iter;
+	const char *str;
+
+	str = connman_network_get_string(network, "Name");
+	if (str != NULL) {
+		g_free(service->name);
+		service->name = g_strdup(str);
+	}
+
+	service->strength = connman_network_get_uint8(network, "Strength");
+
+	str = connman_network_get_string(network, "WiFi.Mode");
+	service->mode = convert_wifi_mode(str);
+
+	str = connman_network_get_string(network, "WiFi.Security");
+	service->security = convert_wifi_security(str);
+
+	if (service->strength > strength && service->network != NULL) {
+		connman_network_unref(service->network);
+		service->network = NULL;
+	}
+
+	if (service->network == NULL) {
+		service->network = connman_network_ref(network);
+
+		str = connman_network_get_string(network, "WiFi.Passphrase");
+		if (str != NULL) {
+			g_free(service->passphrase);
+			service->passphrase = g_strdup(str);
+		}
+	}
+
+	iter = g_hash_table_lookup(service_hash, service->identifier);
+	if (iter != NULL)
+		g_sequence_sort_changed(iter, service_compare, NULL);
+}
+
 /**
  * connman_service_create_from_network:
- * @device: device structure
+ * @network: network structure
  *
  * Look up service by network and if not found, create one
  */
 struct connman_service *__connman_service_create_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
-	GSequenceIter *iter;
-	const char *group, *str;
+	const char *group;
 	char *name;
 
 	group = __connman_network_get_group(network);
@@ -790,6 +889,10 @@ struct connman_service *__connman_service_create_from_network(struct connman_net
 		goto done;
 
 	if (service->path != NULL) {
+		update_from_network(service, network);
+
+		__connman_profile_changed();
+
 		connman_service_put(service);
 		service = NULL;
 		goto done;
@@ -797,18 +900,7 @@ struct connman_service *__connman_service_create_from_network(struct connman_net
 
 	service->type = convert_network_type(network);
 
-	service->name = g_strdup(connman_network_get_string(network, "Name"));
-	service->strength = connman_network_get_uint8(network, "Strength");
-
-	str = connman_network_get_string(network, "WiFi.Mode");
-	service->mode = convert_wifi_mode(str);
-
-	str = connman_network_get_string(network, "WiFi.Security");
-	service->security = convert_wifi_security(str);
-
-	iter = g_hash_table_lookup(service_hash, service->identifier);
-	if (iter != NULL)
-		g_sequence_sort_changed(iter, service_compare, NULL);
+	update_from_network(service, network);
 
 	service_register(service);
 

commit 7609551bc6c7f675f212ffde9b64db9811fb42c4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 19:37:58 2009 +0100

    Add commands for service testing

diff --git a/test/test-connman b/test/test-connman
index c59a064c..c1802829 100755
--- a/test/test-connman
+++ b/test/test-connman
@@ -12,6 +12,12 @@ if len(sys.argv) < 2:
 	print "Usage: %s <command>" % (sys.argv[0])
 	print ""
 	print "  state"
+	print "  services"
+	print "  passphrase <service> [passphrase]"
+	print "  connect <service>"
+	print "  disconnect <service>"
+	print "  remove <service>"
+	print ""
 	print "  scan [ <interface> ]"
 	print "  dev <interface>"
 	print "  dev <interface> scan"
@@ -62,7 +68,11 @@ def print_networks(networks):
 		else:
 			connected = " "
 
-		name = properties["Name"]
+		if "Name" in properties.keys():
+			name = properties["Name"]
+		else:
+			name = ""
+
 		strength = int(properties["Strength"])
 
 		details = ""
@@ -78,7 +88,7 @@ def print_networks(networks):
 			if properties["WiFi.Passphrase"] != "":
 				details += "{passphrase present}"
 
-		print "%s %-20s %3d%%  %s" % (connected,
+		print "%s %-26s %3d%%  %s" % (connected,
 						name, strength, details)
 
 def select_network(networks, name):
@@ -132,11 +142,110 @@ def disconnect_network(networks, name):
 			print "Disconnecting from network %s" % (name)
 			network.Disconnect()
 
+def print_services(services):
+	for path in services:
+		service = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Service")
+
+		properties = service.GetProperties()
+
+		identifier = path[path.rfind("/") + 1:]
+
+		if properties["Favorite"] == dbus.Boolean(1):
+			favorite = "*"
+		else:
+			favorite = " "
+
+		if "Name" in properties.keys():
+			name = properties["Name"]
+		else:
+			name = "{" + properties["Type"] + "}"
+
+		print "%s %-26s { %s }" % (favorite, name, identifier)
+
 if sys.argv[1] == "state":
 	properties = manager.GetProperties()
 
 	print "System is %s" % (properties["State"])
 
+elif sys.argv[1] in ["services", "list", "show"]:
+	properties = manager.GetProperties()
+
+	print_services(properties["Services"])
+
+elif sys.argv[1] in ["passphrase", "pass"]:
+	if (len(sys.argv) < 3):
+		print "Need at least service parameter"
+		sys.exit(1)
+
+	path = "/profile/default/" + sys.argv[2]
+
+	service = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Service")
+
+	if (len(sys.argv) > 3):
+		passphrase = sys.argv[3]
+
+		service.SetProperty("Passphrase", passphrase);
+
+		print "Passphrase %s set for %s" % (passphrase, sys.argv[2])
+	else:
+		properties = service.GetProperties()
+
+		if "Name" in properties.keys():
+			name = properties["Name"]
+		else:
+			name = "{" + properties["Type"] + "}"
+
+		if "Passphrase" in properties.keys():
+			passphrase = properties["Passphrase"]
+		else:
+			passphrase = "not set"
+
+		print "Passphrase for %s is %s" % (name, passphrase)
+
+elif sys.argv[1] in ["connect", "conn"]:
+	if (len(sys.argv) < 3):
+		print "Need at least service parameter"
+		sys.exit(1)
+
+	path = "/profile/default/" + sys.argv[2]
+
+	service = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Service")
+
+	service.Connect()
+
+elif sys.argv[1] in ["disconnect", "disc"]:
+	if (len(sys.argv) < 3):
+		print "Need at least service parameter"
+		sys.exit(1)
+
+	path = "/profile/default/" + sys.argv[2]
+
+	service = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Service")
+
+	service.Disconnect()
+
+elif sys.argv[1] in ["remove"]:
+	if (len(sys.argv) < 3):
+		print "Need at least service parameter"
+		sys.exit(1)
+
+	path = "/profile/default/" + sys.argv[2]
+
+	service = dbus.Interface(bus.get_object("org.moblin.connman", path),
+						"org.moblin.connman.Service")
+
+	properties = service.GetProperties()
+
+	if properties["Favorite"] == dbus.Boolean(0):
+		print "Only favorite services can be removed"
+		sys.exit(1)
+
+	service.Remove()
+
 elif sys.argv[1] == "scan":
 	properties = manager.GetProperties()
 

commit 4e8dfd85cc5f5c8a46fd3e4c25637588421a67e1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 20:07:50 2009 +0100

    Add helper function for no carrier error messages

diff --git a/src/connman.h b/src/connman.h
index e13c3de7..f2c26aea 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -37,6 +37,7 @@ DBusMessage *__connman_error_invalid_arguments(DBusMessage *msg);
 DBusMessage *__connman_error_permission_denied(DBusMessage *msg);
 DBusMessage *__connman_error_not_supported(DBusMessage *msg);
 DBusMessage *__connman_error_not_implemented(DBusMessage *msg);
+DBusMessage *__connman_error_no_carrier(DBusMessage *msg);
 
 int __connman_selftest(void);
 
diff --git a/src/error.c b/src/error.c
index 1668a41d..f8f6fdc1 100644
--- a/src/error.c
+++ b/src/error.c
@@ -56,3 +56,9 @@ DBusMessage *__connman_error_not_implemented(DBusMessage *msg)
 	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
 						".NotImplemented", NULL);
 }
+
+DBusMessage *__connman_error_no_carrier(DBusMessage *msg)
+{
+	return g_dbus_create_error(msg, CONNMAN_ERROR_INTERFACE
+							".NoCarrier", NULL);
+}

commit c9db6015a16ec048d9ed4b439947a6919af882ce
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 20:15:12 2009 +0100

    Add support for service connect and disconnect methods

diff --git a/src/service.c b/src/service.c
index 22c40570..57337bb9 100644
--- a/src/service.c
+++ b/src/service.c
@@ -284,13 +284,32 @@ static DBusMessage *connect_service(DBusConnection *conn,
 {
 	struct connman_service *service = data;
 
+	if (service->network != NULL) {
+		int err;
+
+		err = connman_network_connect(service->network);
+		if (err < 0 && err != -EINPROGRESS)
+			return __connman_error_failed(msg);
+
+		service->state = CONNMAN_SERVICE_STATE_ASSOCIATION;
+
+		state_changed(service);
+
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+	}
+
 	if (service->device != NULL) {
+		if (service->favorite == FALSE)
+			return __connman_error_no_carrier(msg);
+
 		if (__connman_device_connect(service->device) < 0)
 			return __connman_error_failed(msg);
 
 		service->state = CONNMAN_SERVICE_STATE_READY;
 
 		state_changed(service);
+
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 	}
 
 	return __connman_error_not_supported(msg);
@@ -301,13 +320,32 @@ static DBusMessage *disconnect_service(DBusConnection *conn,
 {
 	struct connman_service *service = data;
 
+	if (service->network != NULL) {
+		int err;
+
+		err = __connman_network_disconnect(service->network);
+		if (err < 0 && err != -EINPROGRESS)
+			return __connman_error_failed(msg);
+
+		service->state = CONNMAN_SERVICE_STATE_DISCONNECT;
+
+		state_changed(service);
+
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+	}
+
 	if (service->device != NULL) {
+		if (service->favorite == FALSE)
+			return __connman_error_no_carrier(msg);
+
 		if (__connman_device_connect(service->device) < 0)
 			return __connman_error_failed(msg);
 
 		service->state = CONNMAN_SERVICE_STATE_IDLE;
 
 		state_changed(service);
+
+		return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 	}
 
 	return __connman_error_not_supported(msg);
@@ -321,6 +359,18 @@ static DBusMessage *remove_service(DBusConnection *conn,
 	if (service->type == CONNMAN_SERVICE_TYPE_ETHERNET)
 		return __connman_error_not_supported(msg);
 
+	if (service->network != NULL) {
+		int err;
+
+		err = __connman_network_disconnect(service->network);
+		if (err < 0 && err != -EINPROGRESS)
+			return __connman_error_failed(msg);
+
+		service->state = CONNMAN_SERVICE_STATE_DISCONNECT;
+
+		state_changed(service);
+	}
+
 	connman_service_set_favorite(service, FALSE);
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);

commit ea4b917988a6b7e153e4b03b2444fdb2581bef9b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 22 21:39:09 2009 +0100

    Read hostname after setting up loopback interface

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 22a61fb9..04b29e1d 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -25,6 +25,7 @@
 
 #include <errno.h>
 #include <unistd.h>
+#include <limits.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
@@ -35,6 +36,22 @@
 #include <connman/plugin.h>
 #include <connman/log.h>
 
+static int setup_hostname(void)
+{
+	char name[HOST_NAME_MAX + 1];
+
+	memset(name, 0, sizeof(name));
+
+	if (gethostname(name, HOST_NAME_MAX) < 0) {
+		connman_error("Failed to get current hostname");
+		return -EIO;
+	}
+
+	connman_info("System hostname is %s", name);
+
+	return 0;
+}
+
 static int loopback_init(void)
 {
 	struct ifreq ifr;
@@ -98,6 +115,8 @@ static int loopback_init(void)
 done:
 	close(sk);
 
+	setup_hostname();
+
 	return err;
 }
 

commit 1d03ff3861fe4c04840744c58abc684bedb69712
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 00:08:52 2009 +0100

    Check for inotify header files and library support

diff --git a/configure.ac b/configure.ac
index ba282514..daa40c39 100644
--- a/configure.ac
+++ b/configure.ac
@@ -149,6 +149,12 @@ if (test "${enable_ppp}" = "yes" || test "${enable_novatel}" = "yes" ||
 fi
 AM_CONDITIONAL(PPPD, test "${enable_ppp}" = "yes")
 
+AC_CHECK_HEADERS(sys/inotify.h, dummy=yes,
+			AC_MSG_ERROR(inotify header files are required))
+
+AC_CHECK_LIB(c, inotify_init, dummy=yes,
+			AC_MSG_ERROR(inotify library support is required))
+
 AC_CHECK_LIB(dl, dlopen, dummy=yes,
 			AC_MSG_ERROR(dynamic linking loader is required))
 

commit f67f58354bef906f35aa28346052d8f6b2ffae08
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 00:48:10 2009 +0100

    Add monitoring of /etc/hostname modifications

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 04b29e1d..7eac1e87 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -28,14 +28,112 @@
 #include <limits.h>
 #include <string.h>
 #include <sys/ioctl.h>
+#include <sys/inotify.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
 #include <net/if.h>
 
+#include <glib.h>
+
 #define CONNMAN_API_SUBJECT_TO_CHANGE
 #include <connman/plugin.h>
 #include <connman/log.h>
 
+static GIOChannel *inotify_channel = NULL;
+
+static int hostname_descriptor = -1;
+
+static gboolean inotify_event(GIOChannel *channel,
+					GIOCondition condition, gpointer data)
+{
+	unsigned char buf[129], *ptr = buf;
+	gsize len;
+	GIOError err;
+
+	if (condition & (G_IO_HUP | G_IO_ERR))
+		return FALSE;
+
+	memset(buf, 0, sizeof(buf));
+
+	err = g_io_channel_read(channel, (gchar *) buf, sizeof(buf) - 1, &len);
+	if (err != G_IO_ERROR_NONE) {
+		if (err == G_IO_ERROR_AGAIN)
+			return TRUE;
+		connman_error("Reading from inotify channel failed");
+		return FALSE;
+	}
+
+	while (len >= sizeof(struct inotify_event)) {
+		struct inotify_event *evt = (struct inotify_event *) ptr;
+
+		if (evt->wd == hostname_descriptor) {
+			if (evt->mask & (IN_CREATE | IN_MOVED_TO))
+				connman_info("create hostname file");
+
+			if (evt->mask & (IN_DELETE | IN_MOVED_FROM))
+				connman_info("delete hostname file");
+
+			if (evt->mask & (IN_MODIFY | IN_MOVE_SELF))
+				connman_info("modify hostname file");
+		}
+
+		len -= sizeof(struct inotify_event) + evt->len;
+		ptr += sizeof(struct inotify_event) + evt->len;
+	}
+
+	return TRUE;
+}
+
+static int create_watch(void)
+{
+	int fd;
+
+	fd = inotify_init();
+	if (fd < 0) {
+		connman_error("Creation of inotify context failed");
+		return -EIO;
+	}
+
+	inotify_channel = g_io_channel_unix_new(fd);
+	if (inotify_channel == NULL) {
+		connman_error("Creation of inotify channel failed");
+		close(fd);
+		return -EIO;
+	}
+
+	g_io_add_watch(inotify_channel, G_IO_IN | G_IO_ERR | G_IO_HUP,
+							inotify_event, NULL);
+
+	hostname_descriptor = inotify_add_watch(fd, "/etc/hostname",
+				IN_MODIFY | IN_DELETE_SELF | IN_MOVE_SELF);
+	if (hostname_descriptor < 0) {
+		connman_error("Creation of hostname watch failed");
+		g_io_channel_unref(inotify_channel);
+		inotify_channel = NULL;
+		close(fd);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void remove_watch(void)
+{
+	int fd;
+
+	if (inotify_channel == NULL)
+		return;
+
+	fd = g_io_channel_unix_get_fd(inotify_channel);
+
+	if (hostname_descriptor >= 0)
+		inotify_rm_watch(fd, hostname_descriptor);
+
+	g_io_channel_unref(inotify_channel);
+
+	close(fd);
+}
+
 static int setup_hostname(void)
 {
 	char name[HOST_NAME_MAX + 1];
@@ -52,7 +150,7 @@ static int setup_hostname(void)
 	return 0;
 }
 
-static int loopback_init(void)
+static int setup_loopback(void)
 {
 	struct ifreq ifr;
 	struct sockaddr_in *addr;
@@ -115,13 +213,23 @@ static int loopback_init(void)
 done:
 	close(sk);
 
+	return err;
+}
+
+static int loopback_init(void)
+{
+	setup_loopback();
+
 	setup_hostname();
 
-	return err;
+	create_watch();
+
+	return 0;
 }
 
 static void loopback_exit(void)
 {
+	remove_watch();
 }
 
 CONNMAN_PLUGIN_DEFINE(loopback, "Loopback device plugin", VERSION,

commit bce7ddce246b6bf4799db2c15099445f24b41715
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 00:55:13 2009 +0100

    Read domainname after reading the local hostname

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 7eac1e87..0a3a1d34 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -147,6 +147,18 @@ static int setup_hostname(void)
 
 	connman_info("System hostname is %s", name);
 
+	memset(name, 0, sizeof(name));
+
+	if (getdomainname(name, HOST_NAME_MAX) < 0) {
+		connman_error("Failed to get current domainname");
+		return -EIO;
+	}
+
+	if (strcmp(name, "(none)") == 0)
+		return 0;
+
+	connman_info("System domainname is %s", name);
+
 	return 0;
 }
 

commit eb0286572813ca040954e6a54eb18e2683415072
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 01:04:38 2009 +0100

    Check that hostname and domainname is valid

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 0a3a1d34..04bd7a1c 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -145,7 +145,8 @@ static int setup_hostname(void)
 		return -EIO;
 	}
 
-	connman_info("System hostname is %s", name);
+	if (strlen(name) > 0 && strcmp(name, "(none)") != 0)
+		connman_info("System hostname is %s", name);
 
 	memset(name, 0, sizeof(name));
 
@@ -154,10 +155,8 @@ static int setup_hostname(void)
 		return -EIO;
 	}
 
-	if (strcmp(name, "(none)") == 0)
-		return 0;
-
-	connman_info("System domainname is %s", name);
+	if (strlen(name) > 0 && strcmp(name, "(none)") != 0)
+		connman_info("System domainname is %s", name);
 
 	return 0;
 }

commit 4a6714894c506c1f4be0031dbc08662fca6a240c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 09:04:38 2009 +0100

    Register inotify watch only if setup succeeds

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 04bd7a1c..deaaac27 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -101,9 +101,6 @@ static int create_watch(void)
 		return -EIO;
 	}
 
-	g_io_add_watch(inotify_channel, G_IO_IN | G_IO_ERR | G_IO_HUP,
-							inotify_event, NULL);
-
 	hostname_descriptor = inotify_add_watch(fd, "/etc/hostname",
 				IN_MODIFY | IN_DELETE_SELF | IN_MOVE_SELF);
 	if (hostname_descriptor < 0) {
@@ -114,6 +111,9 @@ static int create_watch(void)
 		return -EIO;
 	}
 
+	g_io_add_watch(inotify_channel, G_IO_IN | G_IO_ERR | G_IO_HUP,
+							inotify_event, NULL);
+
 	return 0;
 }
 

commit 57fd27cea85afca9f81dca76149f4b9775c1bdd6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 12:04:46 2009 +0100

    Disable the inotify for hostname changes

diff --git a/plugins/loopback.c b/plugins/loopback.c
index deaaac27..72258120 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -39,6 +39,7 @@
 #include <connman/plugin.h>
 #include <connman/log.h>
 
+#if 0
 static GIOChannel *inotify_channel = NULL;
 
 static int hostname_descriptor = -1;
@@ -133,6 +134,7 @@ static void remove_watch(void)
 
 	close(fd);
 }
+#endif
 
 static int setup_hostname(void)
 {
@@ -233,14 +235,14 @@ static int loopback_init(void)
 
 	setup_hostname();
 
-	create_watch();
+	//create_watch();
 
 	return 0;
 }
 
 static void loopback_exit(void)
 {
-	remove_watch();
+	//remove_watch();
 }
 
 CONNMAN_PLUGIN_DEFINE(loopback, "Loopback device plugin", VERSION,

commit 125de0a5c3a45182aa53dd7f0355621f8e823fad
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 12:10:51 2009 +0100

    Add support for setting default hostname

diff --git a/plugins/loopback.c b/plugins/loopback.c
index 72258120..782853ef 100644
--- a/plugins/loopback.c
+++ b/plugins/loopback.c
@@ -136,6 +136,14 @@ static void remove_watch(void)
 }
 #endif
 
+static void create_hostname(void)
+{
+	const char *name = "localhost";
+
+	if (sethostname(name, strlen(name)) < 0)
+		connman_error("Failed to set hostname to %s", name);
+}
+
 static int setup_hostname(void)
 {
 	char name[HOST_NAME_MAX + 1];
@@ -149,6 +157,8 @@ static int setup_hostname(void)
 
 	if (strlen(name) > 0 && strcmp(name, "(none)") != 0)
 		connman_info("System hostname is %s", name);
+	else
+		create_hostname();
 
 	memset(name, 0, sizeof(name));
 

commit c999302dcb52b293fb125cfe17ded412787322b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 12:59:01 2009 +0100

    Add initial steps for builtin plugins

diff --git a/include/plugin.h b/include/plugin.h
index 086786c4..21ecd0ef 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -78,12 +78,21 @@ struct connman_plugin_desc {
  * 					example_init, example_exit)
  * ]|
  */
+#ifdef CONNMAN_PLUGIN_BUILTIN
+#define CONNMAN_PLUGIN_DEFINE(name, description, version, priority, init, exit) \
+		extern struct connman_plugin_desc connman_builtin_ ## name \
+				__attribute__ ((visibility("default"))); \
+		struct connman_plugin_desc connman_builtin_ ## name = { \
+			#name, description, version, priority, init, exit \
+		};
+#else
 #define CONNMAN_PLUGIN_DEFINE(name, description, version, priority, init, exit) \
 		extern struct connman_plugin_desc connman_plugin_desc \
 				__attribute__ ((visibility("default"))); \
 		struct connman_plugin_desc connman_plugin_desc = { \
 			#name, description, version, priority, init, exit \
 		};
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/src/plugin.c b/src/plugin.c
index 1b573654..36e816bd 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -27,6 +27,10 @@
 
 #include <glib.h>
 
+#ifdef CONNMAN_PLUGIN_BUILTIN
+#undef CONNMAN_PLUGIN_BUILTIN
+#endif
+
 #include "connman.h"
 
 static GSList *plugins = NULL;

commit 0dd4cfa689fa50f12d954fd8e5698d66c1e115a6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 14:37:13 2009 +0100

    Add functions for handling unique device identifiers

diff --git a/include/device.h b/include/device.h
index a3a1d4a7..17a2a0ca 100644
--- a/include/device.h
+++ b/include/device.h
@@ -81,6 +81,9 @@ extern void connman_device_set_interface(struct connman_device *device,
 							const char *interface);
 extern const char *connman_device_get_interface(struct connman_device *device);
 
+extern void connman_device_set_ident(struct connman_device *device,
+							const char *ident);
+
 extern void connman_device_set_policy(struct connman_device *device,
 					enum connman_device_policy policy);
 extern void connman_device_set_mode(struct connman_device *device,
diff --git a/src/connman.h b/src/connman.h
index f2c26aea..b941185c 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -188,6 +188,7 @@ int __connman_device_disconnect(struct connman_device *device);
 connman_bool_t __connman_device_has_driver(struct connman_device *device);
 
 const char *__connman_device_get_type(struct connman_device *device);
+const char *__connman_device_get_ident(struct connman_device *device);
 
 int __connman_device_set_offlinemode(connman_bool_t offlinemode);
 
@@ -208,6 +209,7 @@ connman_bool_t __connman_network_has_driver(struct connman_network *network);
 
 const char *__connman_network_get_type(struct connman_network *network);
 const char *__connman_network_get_group(struct connman_network *network);
+const char *__connman_network_get_ident(struct connman_network *network);
 
 int __connman_profile_add_network(struct connman_network *network);
 int __connman_profile_remove_network(struct connman_network *network);
diff --git a/src/device.c b/src/device.c
index 13684ee0..df7e7fbf 100644
--- a/src/device.c
+++ b/src/device.c
@@ -45,6 +45,7 @@ struct connman_device {
 	char *node;
 	char *address;
 	char *interface;
+	char *ident;
 	unsigned int connections;
 	guint scan_timeout;
 
@@ -933,6 +934,7 @@ static void device_destruct(struct connman_element *element)
 
 	DBG("element %p name %s", element, element->name);
 
+	g_free(device->ident);
 	g_free(device->node);
 	g_free(device->name);
 	g_free(device->address);
@@ -1146,6 +1148,25 @@ const char *connman_device_get_interface(struct connman_device *device)
 	return device->interface;
 }
 
+/**
+ * connman_device_set_ident:
+ * @device: device structure
+ * @ident: unique identifier
+ *
+ * Set unique identifier of device
+ */
+void connman_device_set_ident(struct connman_device *device,
+							const char *ident)
+{
+	g_free(device->ident);
+	device->ident = g_strdup(ident);
+}
+
+const char *__connman_device_get_ident(struct connman_device *device)
+{
+	return device->ident;
+}
+
 /**
  * connman_device_set_policy:
  * @device: device structure
diff --git a/src/network.c b/src/network.c
index 7375d7f5..6c37eacd 100644
--- a/src/network.c
+++ b/src/network.c
@@ -610,6 +610,14 @@ const char *__connman_network_get_group(struct connman_network *network)
 	return network->group;
 }
 
+const char *__connman_network_get_ident(struct connman_network *network)
+{
+	if (network->device == NULL)
+		return NULL;
+
+	return __connman_device_get_ident(network->device);
+}
+
 /**
  * connman_network_set_available:
  * @network: network structure

commit 6d6df9a7a4c1dfb794830c08629a9f89a1dea68c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 14:49:12 2009 +0100

    Add extra unique identifier to service object path

diff --git a/src/detect.c b/src/detect.c
index 9f3895df..0dce3d3f 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -157,7 +157,7 @@ static char *index2ident(int index, const char *prefix)
 		return NULL;
 
 	eth = (void *) &ifr.ifr_hwaddr.sa_data;
-	snprintf(str, len, "%s%02X_%02X_%02X_%02X_%02X_%02X",
+	snprintf(str, len, "%s%02x%02x%02x%02x%02x%02x",
 						prefix ? prefix : "",
 						eth->ether_addr_octet[0],
 						eth->ether_addr_octet[1],
@@ -175,7 +175,7 @@ static void detect_newlink(unsigned short type, int index,
 	enum connman_device_type devtype = CONNMAN_DEVICE_TYPE_UNKNOWN;
 	enum connman_device_mode mode = CONNMAN_DEVICE_MODE_UNKNOWN;
 	struct connman_device *device;
-	gchar *addr, *name, *devname;
+	char *addr, *name, *devname, *ident;
 
 	DBG("type %d index %d", type, index);
 
@@ -264,19 +264,24 @@ static void detect_newlink(unsigned short type, int index,
 	case CONNMAN_DEVICE_TYPE_NOVATEL:
 	case CONNMAN_DEVICE_TYPE_GPS:
 		mode = CONNMAN_DEVICE_MODE_UNKNOWN;
+		ident = NULL;
 		break;
 	case CONNMAN_DEVICE_TYPE_ETHERNET:
 		mode = CONNMAN_DEVICE_MODE_TRANSPORT_IP;
+		ident = index2ident(index, NULL);
 		break;
 	case CONNMAN_DEVICE_TYPE_WIFI:
 	case CONNMAN_DEVICE_TYPE_WIMAX:
 		mode = CONNMAN_DEVICE_MODE_NETWORK_SINGLE;
+		ident = index2ident(index, NULL);
 		break;
 	case CONNMAN_DEVICE_TYPE_BLUETOOTH:
 		mode = CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE;
+		ident = NULL;
 		break;
 	case CONNMAN_DEVICE_TYPE_HSO:
 		mode = CONNMAN_DEVICE_MODE_NETWORK_SINGLE;
+		ident = NULL;
 		connman_device_set_policy(device, CONNMAN_DEVICE_POLICY_MANUAL);
 		break;
 	}
@@ -286,6 +291,11 @@ static void detect_newlink(unsigned short type, int index,
 	connman_device_set_index(device, index);
 	connman_device_set_interface(device, devname);
 
+	if (ident != NULL) {
+		connman_device_set_ident(device, ident);
+		g_free(ident);
+	}
+
 	connman_device_set_string(device, "Address", addr);
 
 	g_free(devname);
diff --git a/src/service.c b/src/service.c
index 57337bb9..77618146 100644
--- a/src/service.c
+++ b/src/service.c
@@ -729,10 +729,15 @@ static int service_register(struct connman_service *service)
 struct connman_service *__connman_service_lookup_from_device(struct connman_device *device)
 {
 	struct connman_service *service;
+	const char *ident;
 	char *name;
 
-	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
-					connman_device_get_index(device));
+	ident = __connman_device_get_ident(device);
+	if (ident == NULL)
+		return NULL;
+
+	name = g_strdup_printf("%s_%s",
+				__connman_device_get_type(device), ident);
 
 	service = connman_service_lookup(name);
 
@@ -773,10 +778,15 @@ static enum connman_service_type convert_device_type(struct connman_device *devi
 struct connman_service *__connman_service_create_from_device(struct connman_device *device)
 {
 	struct connman_service *service;
+	const char *ident;
 	char *name;
 
-	name = g_strdup_printf("%s_%d", __connman_device_get_type(device),
-					connman_device_get_index(device));
+	ident = __connman_device_get_ident(device);
+	if (ident == NULL)
+		return NULL;
+
+	name = g_strdup_printf("%s_%s",
+				__connman_device_get_type(device), ident);
 
 	service = connman_service_get(name);
 	if (service == NULL)
@@ -809,15 +819,19 @@ done:
 struct connman_service *__connman_service_lookup_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
-	const char *group;
+	const char *ident, *group;
 	char *name;
 
+	ident = __connman_network_get_ident(network);
+	if (ident == NULL)
+		return NULL;
+
 	group = __connman_network_get_group(network);
 	if (group == NULL)
 		return NULL;
 
-	name = g_strdup_printf("%s_%s",
-				__connman_network_get_type(network), group);
+	name = g_strdup_printf("%s_%s_%s",
+			__connman_network_get_type(network), ident, group);
 
 	service = connman_service_lookup(name);
 
@@ -924,15 +938,19 @@ static void update_from_network(struct connman_service *service,
 struct connman_service *__connman_service_create_from_network(struct connman_network *network)
 {
 	struct connman_service *service;
-	const char *group;
+	const char *ident, *group;
 	char *name;
 
+	ident = __connman_network_get_ident(network);
+	if (ident == NULL)
+		return NULL;
+
 	group = __connman_network_get_group(network);
 	if (group == NULL)
 		return NULL;
 
-	name = g_strdup_printf("%s_%s",
-				__connman_network_get_type(network), group);
+	name = g_strdup_printf("%s_%s_%s",
+			__connman_network_get_type(network), ident, group);
 
 	service = connman_service_get(name);
 	if (service == NULL)

commit 56060fa05d883c16e4235b3f0cf1441d0a0b58a3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 16:29:24 2009 +0100

    Add callbacks for service storage functions

diff --git a/include/storage.h b/include/storage.h
index cd31b691..61cbf9a4 100644
--- a/include/storage.h
+++ b/include/storage.h
@@ -24,6 +24,7 @@
 
 #include <connman/device.h>
 #include <connman/network.h>
+#include <connman/service.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -50,6 +51,9 @@ struct connman_storage {
 	int (*network_init) (struct connman_device *device);
 	int (*network_load) (struct connman_network *network);
 	int (*network_save) (struct connman_network *network);
+	enum connman_service_type service_type;
+	int (*service_load) (struct connman_service *service);
+	int (*service_save) (struct connman_service *service);
 };
 
 extern int connman_storage_register(struct connman_storage *storage);
diff --git a/src/connman.h b/src/connman.h
index b941185c..43392513 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -98,9 +98,12 @@ void __connman_storage_cleanup(void);
 int __connman_storage_init_device();
 int __connman_storage_load_device(struct connman_device *device);
 int __connman_storage_save_device(struct connman_device *device);
-int __connman_storage_init_network();
+int __connman_storage_init_network(struct connman_device *device);
 int __connman_storage_load_network(struct connman_network *network);
 int __connman_storage_save_network(struct connman_network *network);
+int __connman_storage_init_service();
+int __connman_storage_load_service(struct connman_service *service);
+int __connman_storage_save_service(struct connman_service *service);
 
 #include <connman/driver.h>
 
diff --git a/src/service.c b/src/service.c
index 77618146..2b607833 100644
--- a/src/service.c
+++ b/src/service.c
@@ -978,12 +978,36 @@ done:
 	return service;
 }
 
+static int service_load(struct connman_service *service)
+{
+	DBG("service %p", service);
+
+	return 0;
+}
+
+static int service_save(struct connman_service *service)
+{
+	DBG("service %p", service);
+
+	return 0;
+}
+
+static struct connman_storage service_storage = {
+	.name		= "service",
+	.priority	= CONNMAN_STORAGE_PRIORITY_LOW,
+	.service_load	= service_load,
+	.service_save	= service_save,
+};
+
 int __connman_service_init(void)
 {
 	DBG("");
 
 	connection = connman_dbus_get_connection();
 
+	if (connman_storage_register(&service_storage) < 0)
+		connman_error("Failed to register service storage");
+
 	service_hash = g_hash_table_new_full(g_str_hash, g_str_equal,
 								NULL, NULL);
 
@@ -1002,5 +1026,7 @@ void __connman_service_cleanup(void)
 	g_hash_table_destroy(service_hash);
 	service_hash = NULL;
 
+	connman_storage_unregister(&service_storage);
+
 	dbus_connection_unref(connection);
 }
diff --git a/src/storage.c b/src/storage.c
index b63c43b5..08b7249c 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -174,6 +174,49 @@ int __connman_storage_save_network(struct connman_network *network)
 	return -ENOENT;
 }
 
+int __connman_storage_init_service(void)
+{
+	DBG("");
+
+	return -ENOENT;
+}
+
+int __connman_storage_load_service(struct connman_service *service)
+{
+	GSList *list;
+
+	DBG("service %p", service);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->service_load) {
+			if (storage->service_load(service) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
+int __connman_storage_save_service(struct connman_service *service)
+{
+	GSList *list;
+
+	DBG("service %p", service);
+
+	for (list = storage_list; list; list = list->next) {
+		struct connman_storage *storage = list->data;
+
+		if (storage->service_save) {
+			if (storage->service_save(service) == 0)
+				return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
 int __connman_storage_init(void)
 {
 	DBG("");

commit 14ef36c854fdd223b4b32cce5c26e39ef6d56ac9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 16:33:22 2009 +0100

    Add hooks for saving and loading service details

diff --git a/src/service.c b/src/service.c
index 2b607833..9522294b 100644
--- a/src/service.c
+++ b/src/service.c
@@ -274,6 +274,8 @@ static DBusMessage *set_property(DBusConnection *conn,
 		if (service->network != NULL)
 			connman_network_set_string(service->network,
 				"WiFi.Passphrase", service->passphrase);
+
+		__connman_storage_save_service(service);
 	}
 
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
@@ -373,6 +375,8 @@ static DBusMessage *remove_service(DBusConnection *conn,
 
 	connman_service_set_favorite(service, FALSE);
 
+	__connman_storage_save_service(service);
+
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
@@ -689,6 +693,8 @@ struct connman_service *connman_service_get(const char *identifier)
 
 	service->identifier = g_strdup(identifier);
 
+	__connman_storage_load_service(service);
+
 	iter = g_sequence_insert_sorted(service_list, service,
 						service_compare, NULL);
 

commit 36a56c493664eb4fe74f640e4d01d18131ce0a03
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 23 17:04:33 2009 +0100

    Export active profile path and ident information

diff --git a/src/connman.h b/src/connman.h
index 43392513..0edade44 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -54,7 +54,8 @@ int __connman_profile_init(DBusConnection *conn);
 void __connman_profile_cleanup(void);
 
 void __connman_profile_list(DBusMessageIter *iter);
-const char *__connman_profile_active(void);
+const char *__connman_profile_active_ident(void);
+const char *__connman_profile_active_path(void);
 
 void __connman_profile_changed(void);
 
diff --git a/src/manager.c b/src/manager.c
index 0a59057c..6c079ff3 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -185,7 +185,7 @@ static DBusMessage *get_properties(DBusConnection *conn,
 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
 
-	str = __connman_profile_active();
+	str = __connman_profile_active_path();
 	if (str != NULL)
 		connman_dbus_dict_append_variant(&dict, "ActiveProfile",
 						DBUS_TYPE_OBJECT_PATH, &str);
diff --git a/src/profile.c b/src/profile.c
index f12bdb84..729c7de2 100644
--- a/src/profile.c
+++ b/src/profile.c
@@ -28,15 +28,22 @@
 
 #include "connman.h"
 
-#define PROFILE_DEFAULT  "/profile/default"
+#define PROFILE_DEFAULT_IDENT  "default"
 
 static DBusConnection *connection = NULL;
 
-const char *__connman_profile_active(void)
+const char *__connman_profile_active_ident(void)
 {
 	DBG("");
 
-	return PROFILE_DEFAULT;
+	return PROFILE_DEFAULT_IDENT;
+}
+
+const char *__connman_profile_active_path(void)
+{
+	DBG("");
+
+	return "/profile/" PROFILE_DEFAULT_IDENT;
 }
 
 static void append_services(DBusMessageIter *entry)
@@ -60,7 +67,7 @@ static void append_services(DBusMessageIter *entry)
 
 void __connman_profile_changed(void)
 {
-	const char *path = __connman_profile_active();
+	const char *path = __connman_profile_active_path();
 	DBusMessage *signal;
 	DBusMessageIter entry;
 
@@ -141,7 +148,7 @@ int __connman_profile_remove_network(struct connman_network *network)
 
 void __connman_profile_list(DBusMessageIter *iter)
 {
-	const char *path = __connman_profile_active();
+	const char *path = __connman_profile_active_path();
 
 	DBG("");
 
@@ -193,13 +200,15 @@ static GDBusSignalTable profile_signals[] = {
 
 int __connman_profile_init(DBusConnection *conn)
 {
+	const char *path = __connman_profile_active_path();
+
 	DBG("conn %p", conn);
 
 	connection = dbus_connection_ref(conn);
 	if (connection == NULL)
 		return -1;
 
-	g_dbus_register_interface(connection, PROFILE_DEFAULT,
+	g_dbus_register_interface(connection, path,
 					CONNMAN_PROFILE_INTERFACE,
 					profile_methods, profile_signals,
 							NULL, NULL, NULL);
@@ -209,9 +218,11 @@ int __connman_profile_init(DBusConnection *conn)
 
 void __connman_profile_cleanup(void)
 {
+	const char *path = __connman_profile_active_path();
+
 	DBG("conn %p", connection);
 
-	g_dbus_unregister_interface(connection, PROFILE_DEFAULT,
+	g_dbus_unregister_interface(connection, path,
 						CONNMAN_PROFILE_INTERFACE);
 
 	if (connection == NULL)
diff --git a/src/service.c b/src/service.c
index 9522294b..ec09cc1c 100644
--- a/src/service.c
+++ b/src/service.c
@@ -705,7 +705,7 @@ struct connman_service *connman_service_get(const char *identifier)
 
 static int service_register(struct connman_service *service)
 {
-	const char *path = __connman_profile_active();
+	const char *path = __connman_profile_active_path();
 
 	DBG("service %p", service);
 

commit 5a5c569add1d4cc9eb8aaf8be40eac2bf8c97bd3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 26 21:38:30 2009 +0200

    Fix the GIT repository location

diff --git a/HACKING b/HACKING
index c14b2145..2d212296 100644
--- a/HACKING
+++ b/HACKING
@@ -46,7 +46,7 @@ So the normal steps to checkout, build and install such a repository is
 like this:
 
   Checkout repository
-    # git-clone git://git.moblin.org/projects/connman.git
+    # git-clone git://git.kernel.org/pub/scm/network/connman/connman.git
     # cd connman
 
   Configure and build

commit e3fafb1cb55307f6c5f118872d72abdd03011cbd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 27 21:41:52 2009 -0700

    Add infrastructure for built-in plugins

diff --git a/.gitignore b/.gitignore
index 6aa6a4e7..2b32d749 100644
--- a/.gitignore
+++ b/.gitignore
@@ -33,6 +33,7 @@ src/connman.conf
 src/connman.service
 src/*-connman.rules
 plugins/connman.policy
+plugins/builtin.h
 scripts/connman
 scripts/udhcpc-script
 scripts/dhclient-script
diff --git a/Makefile.am b/Makefile.am
index b4c0917d..31665787 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = gdbus include src plugins client tools scripts test doc
+SUBDIRS = gdbus include plugins src client tools scripts test doc
 
 pkgconfigdir = $(libdir)/pkgconfig
 
diff --git a/include/plugin.h b/include/plugin.h
index 21ecd0ef..db76ad9f 100644
--- a/include/plugin.h
+++ b/include/plugin.h
@@ -80,9 +80,7 @@ struct connman_plugin_desc {
  */
 #ifdef CONNMAN_PLUGIN_BUILTIN
 #define CONNMAN_PLUGIN_DEFINE(name, description, version, priority, init, exit) \
-		extern struct connman_plugin_desc connman_builtin_ ## name \
-				__attribute__ ((visibility("default"))); \
-		struct connman_plugin_desc connman_builtin_ ## name = { \
+		struct connman_plugin_desc __connman_builtin_ ## name = { \
 			#name, description, version, priority, init, exit \
 		};
 #else
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index db3977fc..7c9d0544 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -3,6 +3,9 @@ plugindir = $(libdir)/connman/plugins
 
 plugin_LTLIBRARIES =
 
+builtin_modules =
+builtin_sources =
+
 if LOOPBACK
 plugin_LTLIBRARIES += loopback.la
 endif
@@ -112,6 +115,16 @@ if FAKE
 plugin_LTLIBRARIES += fake.la
 endif
 
+noinst_LTLIBRARIES = libbuiltin.la
+
+libbuiltin_la_SOURCES = $(builtin_sources)
+libbuiltin_la_LDFLAGS =
+libbuiltin_la_CFLAGS = $(AM_CFLAGS) -DCONNMAN_PLUGIN_BUILTIN
+
+BUILT_SOURCES = builtin.h
+
+nodist_libbuiltin_la_SOURCES = $(BUILT_SOURCES)
+
 AM_LDFLAGS = -no-undefined -module -avoid-version
 
 statedir = $(localstatedir)/run/connman
@@ -126,11 +139,20 @@ AM_CFLAGS = -fvisibility=hidden @GLIB_CFLAGS@ @GDBUS_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/include
 
-CLEANFILES = connman.policy
+CLEANFILES = $(BUILT_SOURCES) connman.policy
 
 EXTRA_DIST = polkit.policy
 
 MAINTAINERCLEANFILES = Makefile.in
 
+builtin.h:
+	echo "" > $@
+	list='$(builtin_modules)'; for i in $$list; \
+	  do echo "extern struct connman_plugin_desc __connman_builtin_$$i;" > $@; done
+	echo "static struct connman_plugin_desc *__connman_builtin[] = {" >> $@
+	list='$(builtin_modules)'; for i in $$list; \
+	  do echo "&__connman_builtin_$$i," >> $@; done
+	echo "NULL };" >> $@
+
 connman.policy: polkit.policy
 	cp $< $@
diff --git a/src/Makefile.am b/src/Makefile.am
index 9051c7f0..9a1738c4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -23,7 +23,8 @@ rules_DATA = 92-connman.rules
 endif
 endif
 
-connmand_LDADD = @GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ @UDEV_LIBS@ -ldl
+connmand_LDADD = $(top_builddir)/plugins/libbuiltin.la \
+		@GDBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ @UDEV_LIBS@ -ldl
 
 connmand_LDFLAGS = -Wl,--export-dynamic -Wl,--version-script=connman.ver
 
@@ -46,7 +47,7 @@ AM_CFLAGS = @UDEV_CFLAGS@ @GTHREAD_CFLAGS@ @GLIB_CFLAGS@ @GDBUS_CFLAGS@ \
 					-DPLUGINDIR=\""$(plugindir)"\" \
 					-DSTORAGEDIR=\""$(storagedir)\""
 
-INCLUDES = -I$(top_builddir)/include
+INCLUDES = -I$(top_builddir)/include -I$(top_builddir)/plugins
 
 EXTRA_DIST = connman-dbus.conf connman-polkit.conf connman.rules
 
diff --git a/src/plugin.c b/src/plugin.c
index 36e816bd..23caa0a8 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -74,15 +74,21 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	return TRUE;
 }
 
+#include "builtin.h"
+
 int __connman_plugin_init(const char *pattern, const char *exclude)
 {
 	GSList *list;
 	GDir *dir;
 	const gchar *file;
 	gchar *filename;
+	unsigned int i;
 
 	DBG("");
 
+	for (i = 0; __connman_builtin[i]; i++)
+		add_plugin(NULL, __connman_builtin[i]);
+
 	dir = g_dir_open(PLUGINDIR, 0, NULL);
 	if (dir != NULL) {
 		while ((file = g_dir_read_name(dir)) != NULL) {
@@ -157,7 +163,8 @@ void __connman_plugin_cleanup(void)
 		if (plugin->active == TRUE && plugin->desc->exit)
 			plugin->desc->exit();
 
-		dlclose(plugin->handle);
+		if (plugin->handle != NULL)
+			dlclose(plugin->handle);
 
 		g_free(plugin);
 	}

commit 5e8e434393bdb77bf634c99c9d18b4e45be8fd82
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 27 21:48:13 2009 -0700

    Choose to built-in loopback, ethernet and dnsproxy plugins

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 7c9d0544..151adabd 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -7,13 +7,13 @@ builtin_modules =
 builtin_sources =
 
 if LOOPBACK
-plugin_LTLIBRARIES += loopback.la
+builtin_modules += loopback
+builtin_sources += loopback.c
 endif
 
 if ETHERNET
-plugin_LTLIBRARIES += ethernet.la
-
-ethernet_la_SOURCES = ethernet.c inet.h inet.c
+builtin_modules += ethernet
+builtin_sources += ethernet.c inet.h inet.c
 endif
 
 if WIFI
@@ -83,7 +83,8 @@ resolvconf_la_CFLAGS = $(AM_CFLAGS) -DRESOLVCONF=\"@RESOLVCONF@\"
 endif
 
 if DNSPROXY
-plugin_LTLIBRARIES += dnsproxy.la
+builtin_modules += dnsproxy
+builtin_sources += dnsproxy.c
 endif
 
 if POLKIT
@@ -148,7 +149,7 @@ MAINTAINERCLEANFILES = Makefile.in
 builtin.h:
 	echo "" > $@
 	list='$(builtin_modules)'; for i in $$list; \
-	  do echo "extern struct connman_plugin_desc __connman_builtin_$$i;" > $@; done
+	  do echo "extern struct connman_plugin_desc __connman_builtin_$$i;" >> $@; done
 	echo "static struct connman_plugin_desc *__connman_builtin[] = {" >> $@
 	list='$(builtin_modules)'; for i in $$list; \
 	  do echo "&__connman_builtin_$$i," >> $@; done

commit 47bd0ee5afe38109771623335a5272f682432c5a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Apr 27 23:59:46 2009 -0700

    Allow selective option for current built-in plugins

diff --git a/bootstrap-configure b/bootstrap-configure
index 49e5a640..c58f7aa4 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -17,15 +17,15 @@ fi
 		--localstatedir=/var \
 		--sysconfdir=/etc \
 		--disable-datafiles \
-		--enable-loopback \
-		--enable-ethernet \
+		--enable-loopback=builtin \
+		--enable-ethernet=builtin \
 		--enable-wifi \
 		--enable-bluetooth \
 		--enable-modemmgr \
 		--enable-udhcp \
 		--enable-dhclient \
 		--enable-resolvconf \
-		--enable-dnsproxy \
+		--enable-dnsproxy=builtin \
 		--enable-novatel \
 		--enable-huawei \
 		--enable-hso \
diff --git a/configure.ac b/configure.ac
index daa40c39..2bcac75f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -48,11 +48,13 @@ AC_ARG_ENABLE(threads, AC_HELP_STRING([--enable-threads],
 
 AC_ARG_ENABLE(loopback, AC_HELP_STRING([--enable-loopback],
 		[enable loopback support]), [enable_loopback=${enableval}])
-AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" = "yes")
+AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" != "no")
+AM_CONDITIONAL(LOOPBACK_BUILTIN, test "${enable_loopback}" = "builtin")
 
 AC_ARG_ENABLE(ethernet, AC_HELP_STRING([--enable-ethernet],
 		[enable Ethernet support]), [enable_ethernet=${enableval}])
-AM_CONDITIONAL(ETHERNET, test "${enable_ethernet}" = "yes")
+AM_CONDITIONAL(ETHERNET, test "${enable_ethernet}" != "no")
+AM_CONDITIONAL(ETHERNET_BUILTIN, test "${enable_ethernet}" = "builtin")
 
 AC_ARG_ENABLE(wifi, AC_HELP_STRING([--enable-wifi],
 		[enable WiFi support]), [enable_wifi=${enableval}])
@@ -117,7 +119,8 @@ AM_CONDITIONAL(RESOLVCONF, test "${enable_resolvconf}" = "yes")
 
 AC_ARG_ENABLE(dnsproxy, AC_HELP_STRING([--enable-dnsproxy],
 		[enable DNS proxy support]), [enable_dnsproxy=${enableval}])
-AM_CONDITIONAL(DNSPROXY, test "${enable_dnsproxy}" = "yes")
+AM_CONDITIONAL(DNSPROXY, test "${enable_dnsproxy}" != "no")
+AM_CONDITIONAL(DNSPROXY_BUILTIN, test "${enable_dnsproxy}" = "builtin")
 
 AC_ARG_ENABLE(novatel, AC_HELP_STRING([--enable-novatel],
 		[enable Novatel support]), [enable_novatel=${enableval}])
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 151adabd..2fb60174 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -7,13 +7,22 @@ builtin_modules =
 builtin_sources =
 
 if LOOPBACK
+if LOOPBACK_BUILTIN
 builtin_modules += loopback
 builtin_sources += loopback.c
+else
+plugin_LTLIBRARIES += loopback.la
+endif
 endif
 
 if ETHERNET
+if ETHERNET_BUILTIN
 builtin_modules += ethernet
 builtin_sources += ethernet.c inet.h inet.c
+else
+plugin_LTLIBRARIES += ethernet.la
+ethernet_la_SOURCES = ethernet.c inet.h inet.c
+endif
 endif
 
 if WIFI
@@ -83,8 +92,12 @@ resolvconf_la_CFLAGS = $(AM_CFLAGS) -DRESOLVCONF=\"@RESOLVCONF@\"
 endif
 
 if DNSPROXY
+if DNSPROXY_BUILTIN
 builtin_modules += dnsproxy
 builtin_sources += dnsproxy.c
+else
+plugin_LTLIBRARIES += dnsproxy.la
+endif
 endif
 
 if POLKIT

commit d670a771cfe15aa99d812f4e4775f3924610a3af
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 28 00:11:52 2009 -0700

    Allow built-in of wifi, bluetooth and resolvconf plugins

diff --git a/bootstrap-configure b/bootstrap-configure
index c58f7aa4..e73f5eb8 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -19,12 +19,12 @@ fi
 		--disable-datafiles \
 		--enable-loopback=builtin \
 		--enable-ethernet=builtin \
-		--enable-wifi \
-		--enable-bluetooth \
+		--enable-wifi=builtin \
+		--enable-bluetooth=builtin \
 		--enable-modemmgr \
 		--enable-udhcp \
 		--enable-dhclient \
-		--enable-resolvconf \
+		--enable-resolvconf=builtin \
 		--enable-dnsproxy=builtin \
 		--enable-novatel \
 		--enable-huawei \
diff --git a/configure.ac b/configure.ac
index 2bcac75f..3b12175c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -62,11 +62,13 @@ if (test "${enable_wifi}" = "yes"); then
 	AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], [],
 						$PATH:/sbin:/usr/sbin)
 fi
-AM_CONDITIONAL(WIFI, test "${enable_wifi}" = "yes")
+AM_CONDITIONAL(WIFI, test "${enable_wifi}" != "no")
+AM_CONDITIONAL(WIFI_BUILTIN, test "${enable_wifi}" = "builtin")
 
 AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--enable-bluetooth],
 		[enable Bluetooth support]), [enable_bluetooth=${enableval}])
-AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" = "yes")
+AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" != "no")
+AM_CONDITIONAL(BLUETOOTH_BUILTIN, test "${enable_bluetooth}" = "builtin")
 
 AC_ARG_ENABLE(modemmgr, AC_HELP_STRING([--enable-modemmgr],
                 [enable Modem Manager support]), [enable_modemmgr=${enableval}])
@@ -115,7 +117,8 @@ if (test "${enable_resolvconf}" = "yes"); then
 		AC_SUBST(RESOLVCONF)
 	fi
 fi
-AM_CONDITIONAL(RESOLVCONF, test "${enable_resolvconf}" = "yes")
+AM_CONDITIONAL(RESOLVCONF, test "${enable_resolvconf}" != "no")
+AM_CONDITIONAL(RESOLVCONF_BUILTIN, test "${enable_resolvconf}" = "builtin")
 
 AC_ARG_ENABLE(dnsproxy, AC_HELP_STRING([--enable-dnsproxy],
 		[enable DNS proxy support]), [enable_dnsproxy=${enableval}])
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2fb60174..ed14ac2e 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -5,6 +5,7 @@ plugin_LTLIBRARIES =
 
 builtin_modules =
 builtin_sources =
+builtin_cflags =
 
 if LOOPBACK
 if LOOPBACK_BUILTIN
@@ -26,46 +27,49 @@ endif
 endif
 
 if WIFI
+if WIFI_BUILTIN
+builtin_modules += wifi
+builtin_sources += wifi.c inet.h inet.c supplicant.h supplicant.c
+else
 plugin_LTLIBRARIES += wifi.la
-
 wifi_la_SOURCES = wifi.c inet.h inet.c supplicant.h supplicant.c
 wifi_la_LIBADD = @GDBUS_LIBS@
 endif
+endif
 
 if BLUETOOTH
+if BLUETOOTH_BUILTIN
+builtin_modules += bluetooth
+builtin_sources += bluetooth.c inet.h inet.c
+else
 plugin_LTLIBRARIES += bluetooth.la
-
 bluetooth_la_SOURCES = bluetooth.c inet.h inet.c
 bluetooth_la_LIBADD = @GDBUS_LIBS@
 endif
+endif
 
 if MODEMMGR
 plugin_LTLIBRARIES += modemmgr.la
-
 modemmgr_la_LIBADD = @GDBUS_LIBS@
 endif
 
 if NOVATEL
 plugin_LTLIBRARIES += novatel.la
-
 novatel_la_SOURCES = novatel.c modem.h modem.c
 endif
 
 if HUAWEI
 plugin_LTLIBRARIES += huawei.la
-
 huawei_la_SOURCES = huawei.c modem.h modem.c
 endif
 
 if HSO
 plugin_LTLIBRARIES += hso.la
-
 hso_la_SOURCES = hso.c modem.h modem.c
 endif
 
 if UDHCP
 plugin_LTLIBRARIES += udhcp.la
-
 udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
 udhcp_la_CFLAGS = $(AM_CFLAGS) -DUDHCPC=\"@UDHCPC@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
@@ -73,7 +77,6 @@ endif
 
 if DHCLIENT
 plugin_LTLIBRARIES += dhclient.la
-
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = $(AM_CFLAGS) -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
@@ -81,15 +84,19 @@ endif
 
 if PPPD
 plugin_LTLIBRARIES += pppd.la
-
 pppd_la_CFLAGS = $(AM_CFLAGS) -DPPPD=\"@PPPD@\"
 endif
 
 if RESOLVCONF
+if RESOLVCONF_BUILTIN
+builtin_modules += resolvconf
+builtin_sources += resolvconf.c
+builtin_cflags += -DRESOLVCONF=\"@RESOLVCONF@\"
+else
 plugin_LTLIBRARIES += resolvconf.la
-
 resolvconf_la_CFLAGS = $(AM_CFLAGS) -DRESOLVCONF=\"@RESOLVCONF@\"
 endif
+endif
 
 if DNSPROXY
 if DNSPROXY_BUILTIN
@@ -102,7 +109,6 @@ endif
 
 if POLKIT
 plugin_LTLIBRARIES += polkit.la
-
 polkit_la_LIBADD = @POLKIT_LIBS@ @GLIB_LIBS@
 polkit_la_CFLAGS = $(AM_CFLAGS) @POLKIT_CFLAGS@
 
@@ -119,7 +125,6 @@ endif
 
 if IWMXSDK
 plugin_LTLIBRARIES += iwmxsdk.la
-
 iwmxsdk_la_SOURCES = iwmxsdk.c inet.h inet.c
 iwmxsdk_la_LIBADD = @IWMXSDK_LIBS@ @GLIB_LIBS@
 iwmxsdk_la_CFLAGS = $(AM_CFLAGS) @IWMXSDK_CFLAGS@
@@ -133,7 +138,7 @@ noinst_LTLIBRARIES = libbuiltin.la
 
 libbuiltin_la_SOURCES = $(builtin_sources)
 libbuiltin_la_LDFLAGS =
-libbuiltin_la_CFLAGS = $(AM_CFLAGS) -DCONNMAN_PLUGIN_BUILTIN
+libbuiltin_la_CFLAGS = $(AM_CFLAGS) $(builtin_cflags) -DCONNMAN_PLUGIN_BUILTIN
 
 BUILT_SOURCES = builtin.h
 
@@ -163,6 +168,7 @@ builtin.h:
 	echo "" > $@
 	list='$(builtin_modules)'; for i in $$list; \
 	  do echo "extern struct connman_plugin_desc __connman_builtin_$$i;" >> $@; done
+	echo "" >> $@
 	echo "static struct connman_plugin_desc *__connman_builtin[] = {" >> $@
 	list='$(builtin_modules)'; for i in $$list; \
 	  do echo "&__connman_builtin_$$i," >> $@; done

commit 79fb1a9209a23a42c173f0775f8dd9b0c381bbe8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 28 00:23:03 2009 -0700

    Add built-in support for udhcp and dhclient plugins

diff --git a/bootstrap-configure b/bootstrap-configure
index e73f5eb8..bef329df 100755
--- a/bootstrap-configure
+++ b/bootstrap-configure
@@ -22,8 +22,8 @@ fi
 		--enable-wifi=builtin \
 		--enable-bluetooth=builtin \
 		--enable-modemmgr \
-		--enable-udhcp \
-		--enable-dhclient \
+		--enable-udhcp=builtin \
+		--enable-dhclient=builtin \
 		--enable-resolvconf=builtin \
 		--enable-dnsproxy=builtin \
 		--enable-novatel \
diff --git a/configure.ac b/configure.ac
index 3b12175c..1488820c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -87,7 +87,8 @@ if (test "${enable_udhcp}" = "yes"); then
 		AC_SUBST(UDHCPC)
 	fi
 fi
-AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" = "yes")
+AM_CONDITIONAL(UDHCP, test "${enable_udhcp}" != "no")
+AM_CONDITIONAL(UDHCP_BUILTIN, test "${enable_udhcp}" = "builtin")
 
 AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
 	[specify location of dhclient binary]), [path_dhclient=${withval}])
@@ -102,7 +103,8 @@ if (test "${enable_dhclient}" = "yes"); then
 		AC_SUBST(DHCLIENT)
 	fi
 fi
-AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" = "yes")
+AM_CONDITIONAL(DHCLIENT, test "${enable_dhclient}" != "no")
+AM_CONDITIONAL(DHCLIENT_BUILTIN, test "${enable_dhclient}" = "builtin")
 
 AC_ARG_WITH(resolvconf, AC_HELP_STRING([--with-resolvconf=PROGRAM],
 	[specify location of resolvconf binary]), [path_resolvconf=${withval}])
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index ed14ac2e..f3d6d1eb 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -69,18 +69,30 @@ hso_la_SOURCES = hso.c modem.h modem.c
 endif
 
 if UDHCP
+if UDHCP_BUILTIN
+builtin_modules += udhcp
+builtin_sources += udhcp.c inet.h inet.c task.h task.c
+builtin_cflags += -DUDHCPC=\"@UDHCPC@\"
+else
 plugin_LTLIBRARIES += udhcp.la
 udhcp_la_SOURCES = udhcp.c inet.h inet.c task.h task.c
 udhcp_la_CFLAGS = $(AM_CFLAGS) -DUDHCPC=\"@UDHCPC@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 endif
+endif
 
 if DHCLIENT
+if DHCLIENT_BUILTIN
+builtin_modules += dhclient
+builtin_sources += dhclient.c inet.h inet.c
+builtin_cflags += -DDHCLIENT=\"@DHCLIENT@\"
+else
 plugin_LTLIBRARIES += dhclient.la
 dhclient_la_SOURCES = dhclient.c inet.h inet.c
 dhclient_la_CFLAGS = $(AM_CFLAGS) -DDHCLIENT=\"@DHCLIENT@\" \
 		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 endif
+endif
 
 if PPPD
 plugin_LTLIBRARIES += pppd.la
@@ -138,7 +150,9 @@ noinst_LTLIBRARIES = libbuiltin.la
 
 libbuiltin_la_SOURCES = $(builtin_sources)
 libbuiltin_la_LDFLAGS =
-libbuiltin_la_CFLAGS = $(AM_CFLAGS) $(builtin_cflags) -DCONNMAN_PLUGIN_BUILTIN
+libbuiltin_la_CFLAGS = $(AM_CFLAGS) \
+		$(builtin_cflags) -DCONNMAN_PLUGIN_BUILTIN \
+		-DSTATEDIR=\""$(statedir)"\" -DSCRIPTDIR=\""$(scriptdir)"\"
 
 BUILT_SOURCES = builtin.h
 

commit 3af53ed8a11154d1c36a0e492b098f52bb980bb3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 28 00:32:41 2009 -0700

    Fix udhcpc, dhclient and resolvconf binary detection

diff --git a/configure.ac b/configure.ac
index 1488820c..414ba62a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -79,7 +79,7 @@ AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
 
 AC_ARG_ENABLE(udhcp, AC_HELP_STRING([--enable-udhcp],
 		[enable uDHCP support]), [enable_udhcp=${enableval}])
-if (test "${enable_udhcp}" = "yes"); then
+if (test "${enable_udhcp}" != "no"); then
 	if (test -z "${path_udhcpc}"); then
 		AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
 	else
@@ -95,7 +95,7 @@ AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
 
 AC_ARG_ENABLE(dhclient, AC_HELP_STRING([--enable-dhclient],
 		[enable dhclient support]), [enable_dhclient=${enableval}])
-if (test "${enable_dhclient}" = "yes"); then
+if (test "${enable_dhclient}" != "no"); then
 	if (test -z "${path_dhclient}"); then
 		AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
 	else
@@ -111,7 +111,7 @@ AC_ARG_WITH(resolvconf, AC_HELP_STRING([--with-resolvconf=PROGRAM],
 
 AC_ARG_ENABLE(resolvconf, AC_HELP_STRING([--enable-resolvconf],
 		[enable resolvconf support]), [enable_resolvconf=${enableval}])
-if (test "${enable_resolvconf}" = "yes"); then
+if (test "${enable_resolvconf}" != "no"); then
 	if (test -z "${path_resolvconf}"); then
 		AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
 	else

commit d165e9b31ffc44a06ab5064812113556ade18c4d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 28 07:25:14 2009 -0700

    Fix default values for built-in enabled plugins

diff --git a/configure.ac b/configure.ac
index 414ba62a..982bb953 100644
--- a/configure.ac
+++ b/configure.ac
@@ -43,42 +43,49 @@ AC_ARG_ENABLE(pie, AC_HELP_STRING([--enable-pie],
 	fi
 ])
 
-AC_ARG_ENABLE(threads, AC_HELP_STRING([--enable-threads],
-		[enable threading support]), [enable_threads=${enableval}])
+AC_ARG_ENABLE(threads,
+	AC_HELP_STRING([--enable-threads], [enable threading support]),
+			[enable_threads=${enableval}], [enable_threads="no"])
 
-AC_ARG_ENABLE(loopback, AC_HELP_STRING([--enable-loopback],
-		[enable loopback support]), [enable_loopback=${enableval}])
+AC_ARG_ENABLE(loopback,
+	AC_HELP_STRING([--enable-loopback], [enable loopback support]),
+			[enable_loopback=${enableval}], [enable_loopback="no"])
 AM_CONDITIONAL(LOOPBACK, test "${enable_loopback}" != "no")
 AM_CONDITIONAL(LOOPBACK_BUILTIN, test "${enable_loopback}" = "builtin")
 
-AC_ARG_ENABLE(ethernet, AC_HELP_STRING([--enable-ethernet],
-		[enable Ethernet support]), [enable_ethernet=${enableval}])
+AC_ARG_ENABLE(ethernet,
+	AC_HELP_STRING([--enable-ethernet], [enable Ethernet support]),
+			[enable_ethernet=${enableval}], [enable_ethernet="no"])
 AM_CONDITIONAL(ETHERNET, test "${enable_ethernet}" != "no")
 AM_CONDITIONAL(ETHERNET_BUILTIN, test "${enable_ethernet}" = "builtin")
 
-AC_ARG_ENABLE(wifi, AC_HELP_STRING([--enable-wifi],
-		[enable WiFi support]), [enable_wifi=${enableval}])
-if (test "${enable_wifi}" = "yes"); then
+AC_ARG_ENABLE(wifi,
+	AC_HELP_STRING([--enable-wifi], [enable WiFi support]),
+			[enable_wifi=${enableval}], [enable_wifi="no"])
+if (test "${enable_wifi}" != "no"); then
 	AC_PATH_PROG(WPASUPPLICANT, [wpa_supplicant], [],
 						$PATH:/sbin:/usr/sbin)
 fi
 AM_CONDITIONAL(WIFI, test "${enable_wifi}" != "no")
 AM_CONDITIONAL(WIFI_BUILTIN, test "${enable_wifi}" = "builtin")
 
-AC_ARG_ENABLE(bluetooth, AC_HELP_STRING([--enable-bluetooth],
-		[enable Bluetooth support]), [enable_bluetooth=${enableval}])
+AC_ARG_ENABLE(bluetooth,
+	AC_HELP_STRING([--enable-bluetooth], [enable Bluetooth support]),
+			[enable_bluetooth=${enableval}], [enable_bluetooth="no"])
 AM_CONDITIONAL(BLUETOOTH, test "${enable_bluetooth}" != "no")
 AM_CONDITIONAL(BLUETOOTH_BUILTIN, test "${enable_bluetooth}" = "builtin")
 
-AC_ARG_ENABLE(modemmgr, AC_HELP_STRING([--enable-modemmgr],
-                [enable Modem Manager support]), [enable_modemmgr=${enableval}])
+AC_ARG_ENABLE(modemmgr,
+	AC_HELP_STRING([--enable-modemmgr], [enable Modem Manager support]),
+			[enable_modemmgr=${enableval}], [enable_modemmgr="no"])
 AM_CONDITIONAL(MODEMMGR, test "${enable_modemmgr}" = "yes")
 
 AC_ARG_WITH(udhcpc, AC_HELP_STRING([--with-udhcpc=PROGRAM],
 	[specify location of udhcpc binary]), [path_udhcpc=${withval}])
 
-AC_ARG_ENABLE(udhcp, AC_HELP_STRING([--enable-udhcp],
-		[enable uDHCP support]), [enable_udhcp=${enableval}])
+AC_ARG_ENABLE(udhcp,
+	AC_HELP_STRING([--enable-udhcp], [enable uDHCP support]),
+			[enable_udhcp=${enableval}], [enable_udhcp="no"])
 if (test "${enable_udhcp}" != "no"); then
 	if (test -z "${path_udhcpc}"); then
 		AC_PATH_PROG(UDHCPC, [udhcpc], [], $PATH:/sbin:/usr/sbin)
@@ -93,8 +100,9 @@ AM_CONDITIONAL(UDHCP_BUILTIN, test "${enable_udhcp}" = "builtin")
 AC_ARG_WITH(dhclient, AC_HELP_STRING([--with-dhclient=PROGRAM],
 	[specify location of dhclient binary]), [path_dhclient=${withval}])
 
-AC_ARG_ENABLE(dhclient, AC_HELP_STRING([--enable-dhclient],
-		[enable dhclient support]), [enable_dhclient=${enableval}])
+AC_ARG_ENABLE(dhclient,
+	AC_HELP_STRING([--enable-dhclient], [enable dhclient support]),
+			[enable_dhclient=${enableval}], [enable_dhclient="no"])
 if (test "${enable_dhclient}" != "no"); then
 	if (test -z "${path_dhclient}"); then
 		AC_PATH_PROG(DHCLIENT, [dhclient], [], $PATH:/sbin:/usr/sbin)
@@ -109,8 +117,9 @@ AM_CONDITIONAL(DHCLIENT_BUILTIN, test "${enable_dhclient}" = "builtin")
 AC_ARG_WITH(resolvconf, AC_HELP_STRING([--with-resolvconf=PROGRAM],
 	[specify location of resolvconf binary]), [path_resolvconf=${withval}])
 
-AC_ARG_ENABLE(resolvconf, AC_HELP_STRING([--enable-resolvconf],
-		[enable resolvconf support]), [enable_resolvconf=${enableval}])
+AC_ARG_ENABLE(resolvconf,
+	AC_HELP_STRING([--enable-resolvconf], [enable resolvconf support]),
+			[enable_resolvconf=${enableval}], [enable_resolvconf="no"])
 if (test "${enable_resolvconf}" != "no"); then
 	if (test -z "${path_resolvconf}"); then
 		AC_PATH_PROG(RESOLVCONF, [resolvconf], [], $PATH:/sbin:/usr/sbin)
@@ -122,8 +131,9 @@ fi
 AM_CONDITIONAL(RESOLVCONF, test "${enable_resolvconf}" != "no")
 AM_CONDITIONAL(RESOLVCONF_BUILTIN, test "${enable_resolvconf}" = "builtin")
 
-AC_ARG_ENABLE(dnsproxy, AC_HELP_STRING([--enable-dnsproxy],
-		[enable DNS proxy support]), [enable_dnsproxy=${enableval}])
+AC_ARG_ENABLE(dnsproxy,
+	AC_HELP_STRING([--enable-dnsproxy], [enable DNS proxy support]),
+			[enable_dnsproxy=${enableval}], [enable_dnsproxy="no"])
 AM_CONDITIONAL(DNSPROXY, test "${enable_dnsproxy}" != "no")
 AM_CONDITIONAL(DNSPROXY_BUILTIN, test "${enable_dnsproxy}" = "builtin")
 
@@ -257,7 +267,7 @@ AC_ARG_ENABLE(client, AC_HELP_STRING([--enable-client],
 AM_CONDITIONAL(CLIENT, test "${enable_client}" = "yes")
 
 AC_ARG_ENABLE(tools, AC_HELP_STRING([--enable-tools],
-                [enable testing tools]), [enable_tools=${enableval}])
+		[enable testing tools]), [enable_tools=${enableval}])
 if (test "${enable_tools}" = "yes"); then
 	PKG_CHECK_MODULES(NETLINK, libnl-1, enable_netlink=yes,
 				AC_MSG_ERROR(Netlink library is required))

commit f47ba233b60652cda14e4aa543b8d43f177f2d17
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 1 09:03:13 2009 -0700

    Add support for marking devices as secondary

diff --git a/include/device.h b/include/device.h
index 17a2a0ca..8311607b 100644
--- a/include/device.h
+++ b/include/device.h
@@ -89,6 +89,9 @@ extern void connman_device_set_policy(struct connman_device *device,
 extern void connman_device_set_mode(struct connman_device *device,
 						enum connman_device_mode mode);
 extern enum connman_device_mode connman_device_get_mode(struct connman_device *device);
+extern void connman_device_set_secondary(struct connman_device *device,
+						connman_bool_t secondary);
+extern connman_bool_t connman_device_get_secondary(struct connman_device *device);
 
 extern int connman_device_set_powered(struct connman_device *device,
 						connman_bool_t powered);
diff --git a/src/device.c b/src/device.c
index df7e7fbf..f33d601c 100644
--- a/src/device.c
+++ b/src/device.c
@@ -35,6 +35,7 @@ struct connman_device {
 	enum connman_device_type type;
 	enum connman_device_mode mode;
 	enum connman_device_policy policy;
+	connman_bool_t secondary;
 	connman_bool_t powered;
 	connman_bool_t carrier;
 	connman_bool_t scanning;
@@ -793,7 +794,8 @@ static int setup_device(struct connman_device *device)
 	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
 		break;
 	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
-		__connman_profile_add_device(device);
+		if (device->secondary == FALSE)
+			__connman_profile_add_device(device);
 		break;
 	}
 
@@ -837,7 +839,8 @@ static void remove_device(struct connman_device *device)
 	case CONNMAN_DEVICE_MODE_NETWORK_MULTIPLE:
 		break;
 	case CONNMAN_DEVICE_MODE_TRANSPORT_IP:
-		__connman_profile_remove_device(device);
+		if (device->secondary == FALSE)
+			__connman_profile_remove_device(device);
 		break;
 	}
 
@@ -984,10 +987,11 @@ struct connman_device *connman_device_create(const char *node,
 
 	device->element.ipv4.method = CONNMAN_IPV4_METHOD_DHCP;
 
-	device->type   = type;
-	device->name   = g_strdup(type2description(device->type));
-	device->mode   = CONNMAN_DEVICE_MODE_UNKNOWN;
-	device->policy = CONNMAN_DEVICE_POLICY_AUTO;
+	device->type      = type;
+	device->name      = g_strdup(type2description(device->type));
+	device->mode      = CONNMAN_DEVICE_MODE_UNKNOWN;
+	device->policy    = CONNMAN_DEVICE_POLICY_AUTO;
+	device->secondary = FALSE;
 
 	switch (type) {
 	case CONNMAN_DEVICE_TYPE_UNKNOWN:
@@ -1204,6 +1208,30 @@ enum connman_device_mode connman_device_get_mode(struct connman_device *device)
 	return device->mode;
 }
 
+/**
+ * connman_device_set_secondary:
+ * @device: device structure
+ * @secondary: secondary value
+ *
+ * Change secondary value of device
+ */
+void connman_device_set_secondary(struct connman_device *device,
+                                                connman_bool_t secondary)
+{
+	device->secondary = secondary;
+}
+
+/**
+ * connman_device_get_secondary:
+ * @device: device structure
+ *
+ * Get secondary value of device
+ */
+connman_bool_t connman_device_get_secondary(struct connman_device *device)
+{
+	return device->secondary;
+}
+
 /**
  * connman_device_set_powered:
  * @device: device structure
diff --git a/src/network.c b/src/network.c
index 6c37eacd..f2b9da24 100644
--- a/src/network.c
+++ b/src/network.c
@@ -33,6 +33,7 @@ struct connman_network {
 	struct connman_element element;
 	enum connman_network_type type;
 	enum connman_network_protocol protocol;
+	connman_bool_t secondary;
 	connman_bool_t available;
 	connman_bool_t connected;
 	connman_bool_t remember;
@@ -486,7 +487,8 @@ struct connman_network *connman_network_create(const char *identifier,
 
 	connman_element_set_uint8(&network->element, "Strength", strength);
 
-	network->type = type;
+	network->type       = type;
+	network->secondary  = FALSE;
 	network->identifier = g_strdup(identifier);
 
 	return network;
@@ -1108,6 +1110,8 @@ static int network_probe(struct connman_element *element)
 		return err;
 	}
 
+	network->secondary = connman_device_get_secondary(network->device);
+
 	switch (network->type) {
 	case CONNMAN_NETWORK_TYPE_UNKNOWN:
 	case CONNMAN_NETWORK_TYPE_VENDOR:
@@ -1117,7 +1121,8 @@ static int network_probe(struct connman_element *element)
 		break;
 	case CONNMAN_NETWORK_TYPE_WIFI:
 	case CONNMAN_NETWORK_TYPE_WIMAX:
-		__connman_profile_add_network(network);
+		if (network->secondary == FALSE)
+			__connman_profile_add_network(network);
 		break;
 	}
 
@@ -1145,7 +1150,8 @@ static void network_remove(struct connman_element *element)
 		break;
 	case CONNMAN_NETWORK_TYPE_WIFI:
 	case CONNMAN_NETWORK_TYPE_WIMAX:
-		__connman_profile_remove_network(network);
+		if (network->secondary == FALSE)
+			__connman_profile_remove_network(network);
 		break;
 	}
 

commit 8cbe9b1d129c7651b185788197ac423758b86590
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 1 09:13:37 2009 -0700

    Add pattern and exclude matching for builtin plugins

diff --git a/src/plugin.c b/src/plugin.c
index 23caa0a8..9af616f7 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -76,6 +76,24 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 
 #include "builtin.h"
 
+static gboolean check_plugin(struct connman_plugin_desc *desc,
+				const char *pattern, const char *exclude)
+{
+	if (exclude != NULL &&
+			g_pattern_match_simple(exclude, desc->name) == TRUE) {
+		DBG("excluding %s", desc->description);
+		return FALSE;
+	}
+
+	if (pattern != NULL &&
+			g_pattern_match_simple(pattern, desc->name) == FALSE) {
+		DBG("ignoring %s", desc->description);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
 int __connman_plugin_init(const char *pattern, const char *exclude)
 {
 	GSList *list;
@@ -86,8 +104,13 @@ int __connman_plugin_init(const char *pattern, const char *exclude)
 
 	DBG("");
 
-	for (i = 0; __connman_builtin[i]; i++)
+	for (i = 0; __connman_builtin[i]; i++) {
+		if (check_plugin(__connman_builtin[i],
+						pattern, exclude) == FALSE)
+			continue;
+
 		add_plugin(NULL, __connman_builtin[i]);
+	}
 
 	dir = g_dir_open(PLUGINDIR, 0, NULL);
 	if (dir != NULL) {
@@ -118,16 +141,7 @@ int __connman_plugin_init(const char *pattern, const char *exclude)
 				continue;
 			}
 
-			if (exclude != NULL && g_pattern_match_simple(exclude,
-							desc->name) == TRUE) {
-				DBG("excluding %s", desc->description);
-				dlclose(handle);
-				continue;
-			}
-
-			if (pattern != NULL && g_pattern_match_simple(pattern,
-							desc->name) == FALSE) {
-				DBG("ignoring %s", desc->description);
+			if (check_plugin(desc, pattern, exclude) == FALSE) {
 				dlclose(handle);
 				continue;
 			}

commit 26b32c4111928deafa0f53c28b66088c82ead503
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 1 09:16:29 2009 -0700

    Use proper error helpers for plugin failures

diff --git a/src/plugin.c b/src/plugin.c
index 9af616f7..02d46019 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -57,7 +57,7 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 		return FALSE;
 
 	if (g_str_equal(desc->version, CONNMAN_VERSION) == FALSE) {
-		DBG("version mismatch for %s", desc->description);
+		connman_error("Version mismatch for %s", desc->description);
 		return FALSE;
 	}
 
@@ -81,13 +81,13 @@ static gboolean check_plugin(struct connman_plugin_desc *desc,
 {
 	if (exclude != NULL &&
 			g_pattern_match_simple(exclude, desc->name) == TRUE) {
-		DBG("excluding %s", desc->description);
+		connman_info("Excluding %s", desc->description);
 		return FALSE;
 	}
 
 	if (pattern != NULL &&
 			g_pattern_match_simple(pattern, desc->name) == FALSE) {
-		DBG("ignoring %s", desc->description);
+		connman_info("Ignoring %s", desc->description);
 		return FALSE;
 	}
 
@@ -126,8 +126,8 @@ int __connman_plugin_init(const char *pattern, const char *exclude)
 
 			handle = dlopen(filename, RTLD_NOW);
 			if (handle == NULL) {
-				g_warning("Can't load %s: %s", filename,
-								dlerror());
+				connman_error("Can't load %s: %s",
+							filename, dlerror());
 				g_free(filename);
 				continue;
 			}
@@ -136,7 +136,8 @@ int __connman_plugin_init(const char *pattern, const char *exclude)
 
 			desc = dlsym(handle, "connman_plugin_desc");
 			if (desc == NULL) {
-				g_warning("Can't load symbol: %s", dlerror());
+				connman_error("Can't load symbol: %s",
+								dlerror());
 				dlclose(handle);
 				continue;
 			}

commit 30dd41c532ff021247f75e2de0a8c84308877d81
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 1 09:19:36 2009 -0700

    Fix position of builtin include

diff --git a/src/plugin.c b/src/plugin.c
index 02d46019..e5e24647 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -74,8 +74,6 @@ static gboolean add_plugin(void *handle, struct connman_plugin_desc *desc)
 	return TRUE;
 }
 
-#include "builtin.h"
-
 static gboolean check_plugin(struct connman_plugin_desc *desc,
 				const char *pattern, const char *exclude)
 {
@@ -94,6 +92,8 @@ static gboolean check_plugin(struct connman_plugin_desc *desc,
 	return TRUE;
 }
 
+#include "builtin.h"
+
 int __connman_plugin_init(const char *pattern, const char *exclude)
 {
 	GSList *list;

commit 89045fb8c22c2c76f6a6e761f253d12a4e7f365e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 1 09:31:26 2009 -0700

    Fix wrong device path in connection properties

diff --git a/src/element.c b/src/element.c
index 3dc15045..9dd566a2 100644
--- a/src/element.c
+++ b/src/element.c
@@ -324,7 +324,7 @@ const char *__connman_element_get_device_path(struct connman_element *element)
 	if (device == NULL)
 		return NULL;
 
-	return element->path;
+	return connman_device_get_path(device);
 }
 
 const char *__connman_element_get_network_path(struct connman_element *element)

commit 864cd602c0b400a2368f14b22bb9c224fd67b176
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon May 4 14:54:12 2009 -0700

    Make sure interface is down after wpa_supplicant releases it

diff --git a/plugins/supplicant.c b/plugins/supplicant.c
index fc57d35b..b92793cb 100644
--- a/plugins/supplicant.c
+++ b/plugins/supplicant.c
@@ -381,6 +381,8 @@ static void remove_interface_reply(DBusPendingCall *call, void *user_data)
 
 	connman_device_unref(task->device);
 
+	inet_ifdown(task->ifindex);
+
 	free_task(task);
 
 	dbus_message_unref(reply);

commit d924889a050c1a325b0edc118e8ad6e910f7d60a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue May 5 17:55:33 2009 -0700

    Fix format string warnings

diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index 79ddf2b3..e6d45ff4 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -51,7 +51,7 @@ static void ethernet_newlink(unsigned flags, unsigned change, void *user_data)
 	struct connman_device *device = user_data;
 	struct ethernet_data *ethernet = connman_device_get_data(device);
 
-	DBG("index %d flags %ld change %ld", ethernet->index, flags, change);
+	DBG("index %d flags %d change %d", ethernet->index, flags, change);
 
 	if ((ethernet->flags & IFF_UP) != (flags & IFF_UP)) {
 		if (flags & IFF_UP) {
diff --git a/plugins/modem.c b/plugins/modem.c
index 17036466..4c8a3e3d 100644
--- a/plugins/modem.c
+++ b/plugins/modem.c
@@ -141,7 +141,7 @@ static gboolean modem_event(GIOChannel *channel,
 		return FALSE;
 	}
 
-	DBG("Read %d bytes (offset %d)", len, modem->offset);
+	DBG("Read %zu bytes (offset %d)", len, modem->offset);
 
 	if (g_str_has_suffix(modem->buf, "\r\n") == TRUE) {
 		for (list = modem->callbacks; list; list = list->next) {

commit b374f6d47e4953aa20795ac6b5ba2709dab382cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue May 5 17:55:52 2009 -0700

    Add printf format checking attribute

diff --git a/include/log.h b/include/log.h
index e9ee8e49..d154ba7c 100644
--- a/include/log.h
+++ b/include/log.h
@@ -32,9 +32,12 @@ extern "C" {
  * @short_description: Functions for logging error and debug information
  */
 
-extern void connman_info(const char *format, ...);
-extern void connman_error(const char *format, ...);
-extern void connman_debug(const char *format, ...);
+extern void connman_info(const char *format, ...)
+				__attribute__((format(printf, 1, 2)));
+extern void connman_error(const char *format, ...)
+				__attribute__((format(printf, 1, 2)));
+extern void connman_debug(const char *format, ...)
+				__attribute__((format(printf, 1, 2)));
 
 /**
  * DBG:

commit 5ba06ab2d7cccb0743fb077e8e2714d5ca404533
Author: Luiz Augusto von Dentz <luiz.dentz@openbossa.org>
Date:   Wed May 6 17:15:27 2009 -0300

    Fix crash when calling g_dbus_remove_watch from watch callback

diff --git a/gdbus/watch.c b/gdbus/watch.c
index 7d7853fc..c7a4e691 100644
--- a/gdbus/watch.c
+++ b/gdbus/watch.c
@@ -54,6 +54,8 @@ struct name_data {
 	DBusConnection *connection;
 	char *name;
 	GSList *callbacks;
+	GSList *processed;
+	gboolean lock;
 };
 
 static struct name_data *name_data_find(DBusConnection *connection,
@@ -146,7 +148,11 @@ static int name_data_add(DBusConnection *connection, const char *name,
 	name_listeners = g_slist_append(name_listeners, data);
 
 done:
-	data->callbacks = g_slist_append(data->callbacks, cb);
+	if (data->lock)
+		data->processed = g_slist_append(data->processed, cb);
+	else
+		data->callbacks = g_slist_append(data->callbacks, cb);
+
 	return first;
 }
 
@@ -229,10 +235,9 @@ static gboolean remove_match(DBusConnection *connection, const char *name)
 static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 					DBusMessage *message, void *user_data)
 {
-	GSList *l;
 	struct name_data *data;
+	struct name_callback *cb;
 	char *name, *old, *new;
-	int keep = 0;
 
 	if (!dbus_message_is_signal(message, DBUS_INTERFACE_DBUS,
 							"NameOwnerChanged"))
@@ -253,8 +258,11 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 	}
 
-	for (l = data->callbacks; l != NULL; l = l->next) {
-		struct name_callback *cb = l->data;
+	data->lock = TRUE;
+
+	while (data->callbacks) {
+		cb = data->callbacks->data;
+
 		if (*new == '\0') {
 			if (cb->disc_func)
 				cb->disc_func(connection, cb->user_data);
@@ -262,11 +270,27 @@ static DBusHandlerResult name_exit_filter(DBusConnection *connection,
 			if (cb->conn_func)
 				cb->conn_func(connection, cb->user_data);
 		}
-		if (cb->conn_func && cb->disc_func)
-			keep = 1;
+
+		/* Check if the watch was removed/freed by the callback
+		 * function */
+		if (!g_slist_find(data->callbacks, cb))
+			continue;
+
+		data->callbacks = g_slist_remove(data->callbacks, cb);
+
+		if (!cb->conn_func || !cb->disc_func) {
+			g_free(cb);
+			continue;
+		}
+
+		data->processed = g_slist_append(data->processed, cb);
 	}
 
-	if (keep)
+	data->callbacks = data->processed;
+	data->processed = NULL;
+	data->lock = FALSE;
+
+	if (data->callbacks)
 		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
 	name_listeners = g_slist_remove(name_listeners, data);
@@ -349,16 +373,23 @@ gboolean g_dbus_remove_watch(DBusConnection *connection, guint id)
 			if (cb->id == id)
 				goto remove;
 		}
+		for (lcb = data->processed; lcb; lcb = lcb->next) {
+			cb = lcb->data;
+			if (cb->id == id)
+				goto remove;
+		}
 	}
 
 	return FALSE;
 
 remove:
 	data->callbacks = g_slist_remove(data->callbacks, cb);
+	data->processed = g_slist_remove(data->processed, cb);
 	g_free(cb);
 
-	/* Don't remove the filter if other callbacks exist */
-	if (data->callbacks)
+	/* Don't remove the filter if other callbacks exist or data is lock
+	 * processing callbacks */
+	if (data->callbacks || data->lock)
 		return TRUE;
 
 	if (data->name) {

commit cdc85a525a549d069d68747acc61bb1baaa041f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 8 14:42:11 2009 -0700

    Fix some more wrong format identifiers

diff --git a/src/rtnl.c b/src/rtnl.c
index 3ea7608c..f46be359 100644
--- a/src/rtnl.c
+++ b/src/rtnl.c
@@ -249,30 +249,30 @@ static inline void print_inet(struct rtattr *attr, const char *name, int family)
 	if (family == AF_INET) {
 		struct in_addr addr;
 		addr = *((struct in_addr *) RTA_DATA(attr));
-		DBG("  attr %s (len %jd) %s\n",
+		DBG("  attr %s (len %d) %s\n",
 				name, RTA_PAYLOAD(attr), inet_ntoa(addr));
 	} else
-		DBG("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
+		DBG("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
 }
 
 static inline void print_char(struct rtattr *attr, const char *name)
 {
-	DBG("  attr %s (len %jd) %s\n", name, RTA_PAYLOAD(attr),
+	DBG("  attr %s (len %d) %s\n", name, RTA_PAYLOAD(attr),
 						(char *) RTA_DATA(attr));
 }
 
 static inline void print_byte(struct rtattr *attr, const char *name)
 {
-	DBG("  attr %s (len %jd) 0x%02x\n", name, RTA_PAYLOAD(attr),
+	DBG("  attr %s (len %d) 0x%02x\n", name, RTA_PAYLOAD(attr),
 					*((unsigned char *) RTA_DATA(attr)));
 }
 
 static inline void print_attr(struct rtattr *attr, const char *name)
 {
 	if (name)
-		DBG("  attr %s (len %jd)\n", name, RTA_PAYLOAD(attr));
+		DBG("  attr %s (len %d)\n", name, RTA_PAYLOAD(attr));
 	else
-		DBG("  attr %d (len %jd)\n",
+		DBG("  attr %d (len %d)\n",
 					attr->rta_type, RTA_PAYLOAD(attr));
 }
 

commit 622be473e966d1b22e150ab6df5e0819cb50bf7a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 8 14:43:08 2009 -0700

    Release 0.16

diff --git a/ChangeLog b/ChangeLog
index 7916015e..5cf3c38c 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+ver 0.16:
+	Update Intel OSPM support to latest specification.
+	Add initial support for new service interface.
+	Add support for builtin plugins.
+	Add extra warning if no nameserver is defined.
+	Add error reporting for state and storage directory creation.
+	Add error message for network and device storing failures
+	Fix stale entry in gateway list after connection changes.
+	Fix handling of DHCP results with no nameserver.
+	Fix infinite loop for service lookup.
+	Fix various format string warnings.
+
 ver 0.15:
 	Detect VMware network interface and ignore them.
 	Fix setting of scan_ssid for hidden networks.
diff --git a/configure.ac b/configure.ac
index 982bb953..98a02bfd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.60)
 AC_INIT()
 
-AM_INIT_AUTOMAKE(connman, 0.15)
+AM_INIT_AUTOMAKE(connman, 0.16)
 AM_CONFIG_HEADER(config.h)
 
 AM_MAINTAINER_MODE

commit 0b1cc2ffd2312cf83a5d8ab21881932610623a8d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 8 14:48:44 2009 -0700

    Add directory for AT chat library

diff --git a/Makefile.am b/Makefile.am
index 31665787..8e559bd5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = gdbus include plugins src client tools scripts test doc
+SUBDIRS = gdbus gatchat include plugins src client tools scripts test doc
 
 pkgconfigdir = $(libdir)/pkgconfig
 
diff --git a/configure.ac b/configure.ac
index 98a02bfd..9fb15f1b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -247,6 +247,9 @@ AC_SUBST(DBUS_DATADIR)
 AC_SUBST([GDBUS_CFLAGS], ['$(DBUS_CFLAGS) -I$(top_srcdir)/gdbus'])
 AC_SUBST([GDBUS_LIBS], ['$(top_builddir)/gdbus/libgdbus.la $(DBUS_LIBS)'])
 
+AC_SUBST([GATCHAT_CFLAGS], ['-I$(top_srcdir)/gatchat'])
+AC_SUBST([GATCHAT_LIBS], ['$(top_builddir)/gatchat/libgatchat.la'])
+
 AC_ARG_ENABLE(polkit, AC_HELP_STRING([--enable-polkit],
 		[enable PolicyKit support]), [enable_polkit=${enableval}])
 if (test "${enable_polkit}" = "yes"); then
@@ -287,7 +290,8 @@ AM_CONDITIONAL(DATAFILES, test "${enable_datafiles}" != "no")
 
 SHAVE_INIT
 
-AC_OUTPUT(Makefile gdbus/Makefile include/Makefile include/version.h
+AC_OUTPUT(Makefile gdbus/Makefile gatchat/Makefile
+				include/Makefile include/version.h
 				src/Makefile src/connman.service
 				scripts/connman scripts/Makefile
 				plugins/Makefile client/Makefile
diff --git a/gatchat/Makefile.am b/gatchat/Makefile.am
new file mode 100644
index 00000000..56c17421
--- /dev/null
+++ b/gatchat/Makefile.am
@@ -0,0 +1,8 @@
+
+noinst_LTLIBRARIES = libgatchat.la
+
+libgatchat_la_SOURCES =
+
+AM_CFLAGS = @GLIB_CFLAGS@
+
+MAINTAINERCLEANFILES = Makefile.in

commit 0ec6287f5393a11c8644d93562ada5de9187db7b
Author: Denis Kenzior <denis.kenzior@intel.com>
Date:   Fri May 8 14:49:56 2009 -0700

    Add AT chat library implementation

diff --git a/gatchat/Makefile.am b/gatchat/Makefile.am
index 56c17421..9f1da113 100644
--- a/gatchat/Makefile.am
+++ b/gatchat/Makefile.am
@@ -1,7 +1,8 @@
 
 noinst_LTLIBRARIES = libgatchat.la
 
-libgatchat_la_SOURCES =
+libgatchat_la_SOURCES = gatchat.h gatchat.c gatresult.h gatresult.c \
+						ringbuffer.h ringbuffer.c
 
 AM_CFLAGS = @GLIB_CFLAGS@
 
diff --git a/gatchat/gatchat.c b/gatchat/gatchat.c
new file mode 100644
index 00000000..e54e5d93
--- /dev/null
+++ b/gatchat/gatchat.c
@@ -0,0 +1,1104 @@
+/*
+ *
+ *  AT chat library with GLib integration
+ *
+ *  Copyright (C) 2008-2009  Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+
+#include <glib.h>
+
+#include "ringbuffer.h"
+#include "gatresult.h"
+#include "gatchat.h"
+
+/* #define WRITE_SCHEDULER_DEBUG 1 */
+
+static void g_at_chat_wakeup_writer(GAtChat *chat);
+
+enum chat_state {
+	PARSER_STATE_IDLE = 0,
+	PARSER_STATE_INITIAL_CR,
+	PARSER_STATE_INITIAL_LF,
+	PARSER_STATE_RESPONSE,
+	PARSER_STATE_TERMINATOR_CR,
+	PARSER_STATE_RESPONSE_COMPLETE,
+	PARSER_STATE_PDU,
+	PARSER_STATE_PDU_CR,
+	PARSER_STATE_PDU_COMPLETE,
+	PARSER_STATE_PROMPT,
+	PARSER_STATE_PROMPT_COMPLETE
+};
+
+struct at_command {
+	char *cmd;
+	char **prefixes;
+	guint id;
+	GAtResultFunc callback;
+	gpointer user_data;
+	GDestroyNotify notify;
+};
+
+struct at_notify_node {
+	guint id;
+	GAtNotifyFunc callback;
+	gpointer user_data;
+	GDestroyNotify notify;
+};
+
+struct at_notify {
+	GSList *nodes;
+	gboolean pdu;
+};
+
+struct _GAtChat {
+	gint ref_count;				/* Ref count */
+	guint next_cmd_id;			/* Next command id */
+	guint next_notify_id;			/* Next notify id */
+	guint read_watch;			/* GSource read id, 0 if none */
+	guint write_watch;			/* GSource write id, 0 if none */
+	GIOChannel *channel;			/* channel */
+	GQueue *command_queue;			/* Command queue */
+	guint cmd_bytes_written;		/* bytes written from cmd */
+	GHashTable *notify_list;		/* List of notification reg */
+	GAtDisconnectFunc user_disconnect;	/* user disconnect func */
+	gpointer user_disconnect_data;		/* user disconnect data */
+	struct ring_buffer *buf;		/* Current read buffer */
+	guint read_so_far;			/* Number of bytes processed */
+	gboolean disconnecting;			/* Whether we're disconnecting */
+	enum chat_state state;		/* Current chat state */
+	int flags;
+	char *pdu_notify;			/* Unsolicited Resp w/ PDU */
+	GSList *response_lines;			/* char * lines of the response */
+	char *wakeup;				/* command sent to wakeup modem */
+	gdouble inactivity_time;		/* Period of inactivity */
+	guint wakeup_timeout;			/* How long to wait for resp */
+	GTimer *wakeup_timer;			/* Keep track of elapsed time */
+};
+
+static gint at_notify_node_compare_by_id(gconstpointer a, gconstpointer b)
+{
+	const struct at_notify_node *node = a;
+	guint id = GPOINTER_TO_UINT(b);
+
+	if (node->id < id)
+		return -1;
+
+	if (node->id > id)
+		return 1;
+
+	return 0;
+}
+
+static void at_notify_node_destroy(struct at_notify_node *node)
+{
+	if (node->notify)
+		node->notify(node->user_data);
+
+	g_free(node);
+}
+
+static void at_notify_destroy(struct at_notify *notify)
+{
+	g_slist_foreach(notify->nodes, (GFunc) at_notify_node_destroy, NULL);
+	g_free(notify);
+}
+
+static gint at_command_compare_by_id(gconstpointer a, gconstpointer b)
+{
+	const struct at_command *command = a;
+	guint id = GPOINTER_TO_UINT(b);
+
+	if (command->id < id)
+		return -1;
+
+	if (command->id > id)
+		return 1;
+
+	return 0;
+}
+
+static struct at_command *at_command_create(const char *cmd,
+						const char **prefix_list,
+						GAtResultFunc func,
+						gpointer user_data,
+						GDestroyNotify notify)
+{
+	struct at_command *c;
+	gsize len;
+	char **prefixes = NULL;
+
+	if (prefix_list) {
+		int num_prefixes = 0;
+		int i;
+
+		while (prefix_list[num_prefixes])
+			num_prefixes += 1;
+
+		prefixes = g_new(char *, num_prefixes + 1);
+
+		for (i = 0; i < num_prefixes; i++)
+			prefixes[i] = strdup(prefix_list[i]);
+
+		prefixes[num_prefixes] = NULL;
+	}
+
+	c = g_try_new0(struct at_command, 1);
+
+	if (!c)
+		return 0;
+
+	len = strlen(cmd);
+	c->cmd = g_try_new(char, len + 2);
+
+	if (!c->cmd) {
+		g_free(c);
+		return 0;
+	}
+
+	memcpy(c->cmd, cmd, len);
+
+	/* If we have embedded '\r' then this is a command expecting a prompt
+	 * from the modem.  Embed Ctrl-Z at the very end automatically
+	 */
+	if (strchr(cmd, '\r'))
+		c->cmd[len] = 26;
+	else
+		c->cmd[len] = '\r';
+
+	c->cmd[len+1] = '\0';
+
+	c->prefixes = prefixes;
+	c->callback = func;
+	c->user_data = user_data;
+	c->notify = notify;
+
+	return c;
+}
+
+static void at_command_destroy(struct at_command *cmd)
+{
+	if (cmd->notify)
+		cmd->notify(cmd->user_data);
+
+	g_strfreev(cmd->prefixes);
+	g_free(cmd->cmd);
+	g_free(cmd);
+}
+
+static void g_at_chat_cleanup(GAtChat *chat)
+{
+	struct at_command *c;
+
+	ring_buffer_free(chat->buf);
+	chat->buf = NULL;
+
+	/* Cleanup pending commands */
+	while ((c = g_queue_pop_head(chat->command_queue)))
+		at_command_destroy(c);
+
+	g_queue_free(chat->command_queue);
+	chat->command_queue = NULL;
+
+	/* Cleanup any response lines we have pending */
+	g_slist_foreach(chat->response_lines, (GFunc)g_free, NULL);
+	g_slist_free(chat->response_lines);
+	chat->response_lines = NULL;
+
+	/* Cleanup registered notifications */
+	g_hash_table_destroy(chat->notify_list);
+	chat->notify_list = NULL;
+
+	if (chat->pdu_notify) {
+		g_free(chat->pdu_notify);
+		chat->pdu_notify = NULL;
+	}
+
+	if (chat->wakeup) {
+		g_free(chat->wakeup);
+		chat->wakeup = NULL;
+	}
+
+	if (chat->wakeup_timer) {
+		g_timer_destroy(chat->wakeup_timer);
+		chat->wakeup_timer = 0;
+	}
+}
+
+static void read_watcher_destroy_notify(GAtChat *chat)
+{
+	chat->read_watch = 0;
+
+	if (chat->disconnecting)
+		return;
+
+	chat->channel = NULL;
+
+	g_at_chat_cleanup(chat);
+
+	if (chat->user_disconnect)
+		chat->user_disconnect(chat->user_disconnect_data);
+}
+
+static void write_watcher_destroy_notify(GAtChat *chat)
+{
+	chat->write_watch = 0;
+}
+
+static void at_notify_call_callback(gpointer data, gpointer user_data)
+{
+	struct at_notify_node *node = data;
+	GAtResult *result = user_data;
+
+	node->callback(result, node->user_data);
+}
+
+static gboolean g_at_chat_match_notify(GAtChat *chat, char *line)
+{
+	GHashTableIter iter;
+	struct at_notify *notify;
+	char *prefix;
+	gpointer key, value;
+	gboolean ret = FALSE;
+	GAtResult result;
+
+	g_hash_table_iter_init(&iter, chat->notify_list);
+	result.lines = 0;
+	result.final_or_pdu = 0;
+
+	while (g_hash_table_iter_next(&iter, &key, &value)) {
+		prefix = key;
+		notify = value;
+
+		if (!g_str_has_prefix(line, key))
+			continue;
+
+		if (notify->pdu) {
+			chat->pdu_notify = line;
+			chat->state = PARSER_STATE_PDU;
+			return TRUE;
+		}
+
+		if (!result.lines)
+			result.lines = g_slist_prepend(NULL, line);
+
+		g_slist_foreach(notify->nodes, at_notify_call_callback,
+					&result);
+		ret = TRUE;
+	}
+
+	if (ret) {
+		g_slist_free(result.lines);
+		g_free(line);
+		chat->state = PARSER_STATE_IDLE;
+	}
+
+	return ret;
+}
+
+static void g_at_chat_finish_command(GAtChat *p, gboolean ok,
+						char *final)
+{
+	struct at_command *cmd = g_queue_pop_head(p->command_queue);
+
+	/* Cannot happen, but lets be paranoid */
+	if (!cmd)
+		return;
+
+	if (cmd->callback) {
+		GAtResult result;
+
+		p->response_lines = g_slist_reverse(p->response_lines);
+
+		result.final_or_pdu = final;
+		result.lines = p->response_lines;
+
+		cmd->callback(ok, &result, cmd->user_data);
+	}
+
+	g_slist_foreach(p->response_lines, (GFunc)g_free, NULL);
+	g_slist_free(p->response_lines);
+	p->response_lines = NULL;
+
+	g_free(final);
+
+	at_command_destroy(cmd);
+
+	p->cmd_bytes_written = 0;
+
+	if (g_queue_peek_head(p->command_queue))
+		g_at_chat_wakeup_writer(p);
+}
+
+struct terminator_info {
+	const char *terminator;
+	int len;
+	gboolean success;
+};
+
+static struct terminator_info terminator_table[] = {
+	{ "OK", -1, TRUE },
+	{ "ERROR", -1, FALSE },
+	{ "NO DIALTONE", -1, FALSE },
+	{ "BUSY", -1, FALSE },
+	{ "NO CARRIER", -1, FALSE },
+	{ "CONNECT", -1, TRUE },
+	{ "NO ANSWER", -1, FALSE },
+	{ "+CMS ERROR:", 11, FALSE },
+	{ "+CME ERROR:", 11, FALSE },
+	{ "+EXT ERROR:", 11, FALSE }
+};
+
+static gboolean g_at_chat_handle_command_response(GAtChat *p,
+							struct at_command *cmd,
+							char *line)
+{
+	int i;
+	int size = sizeof(terminator_table) / sizeof(struct terminator_info);
+
+	p->state = PARSER_STATE_IDLE;
+
+	for (i = 0; i < size; i++) {
+		struct terminator_info *info = &terminator_table[i];
+
+		if (info->len == -1 && !strcmp(line, info->terminator)) {
+			g_at_chat_finish_command(p, info->success, line);
+			return TRUE;
+		}
+
+		if (info->len > 0 &&
+			!strncmp(line, info->terminator, info->len)) {
+			g_at_chat_finish_command(p, info->success, line);
+			return TRUE;
+		}
+	}
+
+	if (cmd->prefixes) {
+		int i;
+
+		for (i = 0; cmd->prefixes[i]; i++)
+			if (g_str_has_prefix(line, cmd->prefixes[i]))
+				goto out;
+
+		return FALSE;
+	}
+
+out:
+	p->response_lines = g_slist_prepend(p->response_lines,
+						line);
+
+	return TRUE;
+}
+
+static void have_line(GAtChat *p)
+{
+	/* We're not going to copy terminal <CR><LF> */
+	unsigned int len = p->read_so_far - 2;
+	char *str;
+	struct at_command *cmd;
+
+	/* If we have preceding <CR><LF> modify the len */
+	if ((p->flags & G_AT_CHAT_FLAG_NO_LEADING_CRLF) == 0)
+		len -= 2;
+
+	/* Make sure we have terminal null */
+	str = g_try_new(char, len + 1);
+
+	if (!str) {
+		ring_buffer_drain(p->buf, p->read_so_far);
+		return;
+	}
+
+	if ((p->flags & G_AT_CHAT_FLAG_NO_LEADING_CRLF) == 0)
+		ring_buffer_drain(p->buf, 2);
+	ring_buffer_read(p->buf, str, len);
+	ring_buffer_drain(p->buf, 2);
+
+	str[len] = '\0';
+
+	/* Check for echo, this should not happen, but lets be paranoid */
+	if (!strncmp(str, "AT", 2) == TRUE)
+		goto done;
+
+	cmd = g_queue_peek_head(p->command_queue);
+
+	if (cmd && p->cmd_bytes_written == strlen(cmd->cmd) &&
+		g_at_chat_handle_command_response(p, cmd, str))
+		return;
+
+	if (g_at_chat_match_notify(p, str) == TRUE)
+		return;
+
+done:
+	/* No matches & no commands active, ignore line */
+	g_free(str);
+	p->state = PARSER_STATE_IDLE;
+}
+
+static void have_pdu(GAtChat *p)
+{
+	unsigned int len = p->read_so_far - 2;
